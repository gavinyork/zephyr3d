## API Report File for "@zephyr3d/scene"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AABB } from '@zephyr3d/base';
import { AbstractDevice } from '@zephyr3d/device';
import { BaseTexture } from '@zephyr3d/device';
import { BindGroup } from '@zephyr3d/device';
import { BindGroupLayout } from '@zephyr3d/device';
import { Clonable } from '@zephyr3d/base';
import { ColorState } from '@zephyr3d/device';
import { CubeFace } from '@zephyr3d/base';
import { DecoderModule } from 'draco3d';
import { DeepRequireOptionals } from '@zephyr3d/base';
import { DeviceBackend } from '@zephyr3d/device';
import { Disposable } from '@zephyr3d/base';
import { DRef } from '@zephyr3d/base';
import { FaceMode } from '@zephyr3d/device';
import { FrameBuffer } from '@zephyr3d/device';
import { Frustum } from '@zephyr3d/base';
import { GenericConstructor } from '@zephyr3d/base';
import { GPUDataBuffer } from '@zephyr3d/device';
import { GPUProgram } from '@zephyr3d/device';
import { HttpRequest } from '@zephyr3d/base';
import { IDisposable } from '@zephyr3d/base';
import { IEventTarget } from '@zephyr3d/base';
import { Immutable } from '@zephyr3d/base';
import { IndexBuffer } from '@zephyr3d/device';
import { InterpolationMode } from '@zephyr3d/base';
import { Interpolator } from '@zephyr3d/base';
import { Matrix4x4 } from '@zephyr3d/base';
import { Metadata as Metadata_2 } from 'draco3d';
import { Nullable } from '@zephyr3d/base';
import { Observable } from '@zephyr3d/base';
import { PBFunctionScope } from '@zephyr3d/device';
import { PBGlobalScope } from '@zephyr3d/device';
import { PBInsideFunctionScope } from '@zephyr3d/device';
import { PBShaderExp } from '@zephyr3d/device';
import { Plane } from '@zephyr3d/base';
import { PrimitiveType } from '@zephyr3d/device';
import { ProgramBuilder } from '@zephyr3d/device';
import { Quaternion } from '@zephyr3d/base';
import { Ray } from '@zephyr3d/base';
import { ReadOptions } from '@zephyr3d/base';
import { Rect } from '@zephyr3d/base';
import { RenderStateSet } from '@zephyr3d/device';
import { RequireOptionals } from '@zephyr3d/base';
import { SamplerOptions } from '@zephyr3d/device';
import { ShaderTypeFunc } from '@zephyr3d/device';
import { StructuredBuffer } from '@zephyr3d/device';
import { Texture2D } from '@zephyr3d/device';
import { Texture2DArray } from '@zephyr3d/device';
import { TextureAddressMode } from '@zephyr3d/device';
import { TextureCube } from '@zephyr3d/device';
import { TextureFilterMode } from '@zephyr3d/device';
import { TextureFormat } from '@zephyr3d/device';
import { TextureSampler } from '@zephyr3d/device';
import { TypedArray } from '@zephyr3d/base';
import { Vector2 } from '@zephyr3d/base';
import { Vector3 } from '@zephyr3d/base';
import { Vector4 } from '@zephyr3d/base';
import { VertexAttribFormat } from '@zephyr3d/device';
import { VertexSemantic } from '@zephyr3d/device';
import { VertexStepMode } from '@zephyr3d/device';
import { VFS } from '@zephyr3d/base';
import { WriteOptions } from '@zephyr3d/base';
import * as _zephyr3d_base from '@zephyr3d/base';
import * as _zephyr3d_device from '@zephyr3d/device';

// @public
export class AABBTree {
    constructor();
    constructor(rhs: AABBTree);
    buildFromPrimitives(vertices: number[] | TypedArray, indices: number[] | TypedArray, primitiveType: PrimitiveType): void;
    getTopLevelAABB(): AABB | null;
    rayIntersectionDistance(ray: Ray): number | null;
    rayIntersectionTest(ray: Ray): boolean;
    transform(matrix: Matrix4x4): void;
}

// @public
export class AbsNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof AbsNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class AbstractPostEffect extends Disposable {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    protected drawFullscreenQuad(renderStateSet?: RenderStateSet): void;
    get enabled(): boolean;
    set enabled(val: boolean);
    // (undocumented)
    protected _enabled: boolean;
    get layer(): PostEffectLayer;
    // (undocumented)
    protected _layer: PostEffectLayer;
    needFlip(device: AbstractDevice): boolean;
    // (undocumented)
    protected onDispose(): void;
    // (undocumented)
    protected passThrough(ctx: DrawContext, inputColorTexture: Texture2D, srgbOutput: boolean, renderStates?: RenderStateSet): void;
    requireDepthAttachment(_ctx: DrawContext): boolean;
    requireLinearDepthTexture(_ctx: DrawContext): boolean;
}

// @public
export class ABufferOIT extends Disposable implements OIT {
    constructor(numLayers?: number);
    applyUniforms(ctx: DrawContext, bindGroup: BindGroup): void;
    begin(ctx: DrawContext): number;
    beginPass(ctx: DrawContext, pass: number): boolean;
    calculateHash(): string;
    end(ctx: DrawContext): void;
    endPass(ctx: DrawContext, pass: number): void;
    getType(): string;
    // (undocumented)
    protected onDispose(): void;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): void;
    setupFragmentOutput(scope: PBGlobalScope): void;
    supportDevice(deviceType: string): deviceType is "webgpu";
    static readonly type = "ab";
    // (undocumented)
    static readonly usePremultipliedAlpha = true;
    wantsPremultipliedAlpha(): boolean;
}

// @public
export class AllConditionNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof AllConditionNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): "" | "bool";
    toString(): string;
}

// @public
export class AnimationClip extends Disposable {
    constructor(name: string, animationSet: AnimationSet, embedded?: boolean);
    addSkeleton(skeletonId: string): void;
    addTrack(target: object, track: AnimationTrack): this;
    get animationSet(): AnimationSet;
    get autoPlay(): boolean;
    set autoPlay(val: boolean);
    deleteTrack(track: AnimationTrack): this;
    get embedded(): boolean;
    get name(): string;
    get skeletons(): Set<string>;
    set skeletons(val: Set<string>);
    get timeDuration(): number;
    set timeDuration(val: number);
    get tracks(): Map<object, AnimationTrack<unknown>[]>;
    get weight(): number;
    set weight(val: number);
    // (undocumented)
    protected _weight: number;
}

// @public
export class AnimationSet extends Disposable implements IDisposable {
    constructor(model: SceneNode);
    createAnimation(name: string, embedded?: boolean): AnimationClip | null;
    deleteAnimation(name: string): void;
    get(name: string): AnimationClip | null;
    getAnimationClip(name: string): AnimationClip | null;
    getAnimationNames(): string[];
    isPlayingAnimation(name?: string): boolean;
    get model(): SceneNode;
    get numAnimations(): number;
    protected onDispose(): void;
    playAnimation(name: string, options?: PlayAnimationOptions): void;
    setAnimationWeight(name: string, weight: number): void;
    get skeletons(): DRef<Skeleton>[];
    stopAnimation(name: string, options?: StopAnimationOptions): void;
    update(deltaInSeconds: number): void;
}

// @public
export abstract class AnimationTrack<StateType = unknown> {
    constructor(embedded?: boolean);
    get animation(): Nullable<AnimationClip>;
    set animation(ani: Nullable<AnimationClip>);
    abstract applyState(target: object, state: StateType): unknown;
    abstract calculateState(target: object, currentTime: number): StateType;
    get embedded(): boolean;
    abstract getBlendId(): unknown;
    abstract getDuration(): number;
    get jointIndex(): number;
    set jointIndex(index: number);
    abstract mixState(a: StateType, b: StateType, t: number): StateType;
    get name(): string;
    set name(val: string);
    reset(_target: object): void;
    get target(): string;
    set target(val: string);
}

// @public
export class AnyConditionNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof AnyConditionNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): "" | "bool";
    toString(): string;
}

// @public
export interface AppCreationOptions extends AppOptions {
    runtimeOptions?: {
        VFS?: VFS;
        scriptsRoot?: string;
        editorMode?: EditorMode;
        enabled?: boolean;
        screen?: ScreenConfig;
    };
}

// Warning: (ae-forgotten-export) The symbol "appEventMap" needs to be exported by the entry point index.d.ts
//
// @public
export class Application extends Observable<appEventMap> {
    constructor(opt: AppCreationOptions);
    get device(): AbstractDevice;
    get deviceType(): string;
    get editorMode(): EditorMode;
    get engine(): Engine;
    focus(): void;
    frame(): void;
    get inputManager(): InputManager;
    get options(): RequireOptionals<AppOptions>;
    ready(): Promise<void>;
    run(): void;
    stop(): void;
}

// @public
export function applyMaterialMixins<M extends ((target: any) => any)[], T>(target: T, ...mixins: M): T & _zephyr3d_base.ExtractMixinType<M>;

// @public
export interface AppOptions {
    backend: DeviceBackend;
    canvas: HTMLCanvasElement;
    enableMSAA?: boolean;
    pixelRatio?: number;
}

// @public
export class ArccosineHNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ArccosineHNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ArcCosNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ArcCosNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ArcsineHNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ArcsineHNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ArcSinNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ArcSinNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ArcTan2Node extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ArcTan2Node;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ArctangentHNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ArctangentHNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ArcTanNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ArcTanNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export interface AssetAnimationData {
    // (undocumented)
    name: string;
    // (undocumented)
    nodes: AssetHierarchyNode[];
    // (undocumented)
    skeletons: AssetSkeleton[];
    // (undocumented)
    tracks: AssetAnimationTrack[];
}

// @public
export interface AssetAnimationTrack {
    // (undocumented)
    defaultMorphWeights?: number[];
    // (undocumented)
    interpolator: Interpolator;
    // (undocumented)
    node: AssetHierarchyNode;
    // (undocumented)
    type: 'translation' | 'scale' | 'rotation' | 'weights';
}

// @public
export class AssetHierarchyNode extends NamedObject {
    constructor(name: string, parent?: Nullable<AssetHierarchyNode>);
    addChild(child: AssetHierarchyNode): void;
    attachToSkeleton(skeleton: AssetSkeleton): void;
    get children(): AssetHierarchyNode[];
    get instances(): {
        t: Vector3;
        s: Vector3;
        r: Quaternion;
    }[] | null;
    get matrix(): Nullable<Matrix4x4>;
    get mesh(): Nullable<AssetMeshData>;
    set mesh(data: Nullable<AssetMeshData>);
    get meshAttached(): boolean;
    get parent(): Nullable<AssetHierarchyNode>;
    get position(): Vector3;
    set position(val: Vector3);
    removeChild(child: AssetHierarchyNode): void;
    get rotation(): Quaternion;
    set rotation(val: Quaternion);
    get scaling(): Vector3;
    set scaling(val: Vector3);
    get skeleton(): Nullable<AssetSkeleton>;
    set skeleton(skeleton: Nullable<AssetSkeleton>);
    get skeletonAttached(): Nullable<Set<AssetSkeleton>>;
    get weights(): Nullable<number[]>;
    set weights(val: Nullable<number[]>);
    get worldMatrix(): Nullable<Matrix4x4>;
}

// @public
export class AssetManager {
    constructor(resourceManager?: ResourceManager);
    // Warning: (ae-forgotten-export) The symbol "AbstractModelLoader" needs to be exported by the entry point index.d.ts
    static addModelLoader(loader: AbstractModelLoader): void;
    // Warning: (ae-forgotten-export) The symbol "AbstractTextureLoader" needs to be exported by the entry point index.d.ts
    static addTextureLoader(loader: AbstractTextureLoader): void;
    clearCache(): void;
    // (undocumented)
    createBluePrintDAG(nodeMap: Record<number, IGraphNode>, roots: number[], links: {
        startNodeId: number;
        startSlotId: number;
        endNodeId: number;
        endSlotId: number;
    }[]): {
        graph: GraphStructure;
        nodeMap: Record<number, IGraphNode>;
        roots: number[];
        order: number[];
    };
    fetchBinaryData(url: string, postProcess?: Nullable<(data: ArrayBuffer) => ArrayBuffer>, httpRequest?: Nullable<HttpRequest>, VFSs?: VFS[]): Promise<Nullable<ArrayBuffer>>;
    // (undocumented)
    fetchBluePrint(url: string, VFSs?: VFS[]): Promise<Nullable<Record<string, MaterialBlueprintIR>>>;
    fetchBuiltinTexture<T extends BaseTexture>(name: string, texture?: T): T;
    fetchJsonData<T = any>(url: string, postProcess?: (json: T) => T, httpRequest?: HttpRequest, VFSs?: VFS[]): Promise<T>;
    fetchMaterial<T extends Material = Material>(url: string, VFSs?: VFS[]): Promise<Nullable<T>>;
    fetchModel(scene: Scene, url: string, options?: ModelFetchOptions, VFSs?: VFS[]): Promise<{
        group: SceneNode;
        animationSet: AnimationSet;
    }>;
    fetchPrimitive<T extends Primitive = Primitive>(url: string, VFSs?: VFS[]): Promise<Nullable<T>>;
    fetchTextData(url: string, postProcess?: (text: string) => string, httpRequest?: HttpRequest, VFSs?: VFS[]): Promise<string>;
    fetchTexture<T extends BaseTexture>(url: string, options?: TextureFetchOptions<T>, VFSs?: VFS[]): Promise<T>;
    // (undocumented)
    invalidateBluePrint(path: string): void;
    // (undocumented)
    loadBluePrint(path: string, VFSs?: VFS[]): Promise<Record<string, MaterialBlueprintIR> | null>;
    // (undocumented)
    loadPrimitive<T extends Primitive = Primitive>(url: string, VFSs?: VFS[]): Promise<Nullable<T>>;
    loadTextureFromBuffer<T extends BaseTexture>(arrayBuffer: ArrayBuffer | TypedArray, mimeType: string, srgb?: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture): Promise<T>;
    // (undocumented)
    reloadBluePrintMaterials(filter?: (m: PBRBluePrintMaterial) => boolean): Promise<void>;
    static setBuiltinTextureLoader(name: string, loader: (assetManager: AssetManager) => BaseTexture): void;
    get vfs(): VFS;
    writeFileToVFSs(path: string, data: ArrayBuffer | string, options: WriteOptions, vfsList?: VFS[]): Promise<void>;
}

// @public
export interface AssetMaterial {
    // (undocumented)
    common: AssetMaterialCommon;
    // (undocumented)
    type: string;
}

// @public
export interface AssetMaterialClearcoat {
    // (undocumented)
    clearCoatFactor?: number;
    // (undocumented)
    clearCoatIntensityMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    clearCoatNormalMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    clearCoatRoughnessFactor?: number;
    // (undocumented)
    clearCoatRoughnessMap?: Nullable<MaterialTextureInfo>;
}

// @public
export interface AssetMaterialCommon {
    // (undocumented)
    alphaCutoff?: number;
    // (undocumented)
    alphaMode?: 'blend' | 'mask';
    // (undocumented)
    bumpScale?: number;
    // (undocumented)
    doubleSided?: boolean;
    // (undocumented)
    emissiveColor?: Vector3;
    // (undocumented)
    emissiveMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    emissiveStrength?: number;
    // (undocumented)
    normalMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    occlusionMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    occlusionStrength?: number;
    // (undocumented)
    useTangent?: boolean;
    // (undocumented)
    vertexColor?: boolean;
    // (undocumented)
    vertexNormal?: boolean;
}

// @public
export interface AssetMaterialIridescence {
    // (undocumented)
    iridescenceFactor?: number;
    // (undocumented)
    iridescenceIor?: number;
    // (undocumented)
    iridescenceMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    iridescenceThicknessMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    iridescenceThicknessMaximum?: number;
    // (undocumented)
    iridescenceThicknessMinimum?: number;
}

// @public
export interface AssetMaterialSheen {
    // (undocumented)
    sheenColorFactor?: Vector3;
    // (undocumented)
    sheenColorMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    sheenRoughnessFactor?: number;
    // (undocumented)
    sheenRoughnessMap?: Nullable<MaterialTextureInfo>;
}

// @public
export interface AssetMaterialTransmission {
    // (undocumented)
    attenuationColor?: Vector3;
    // (undocumented)
    attenuationDistance?: number;
    // (undocumented)
    thicknessFactor?: number;
    // (undocumented)
    thicknessMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    transmissionFactor?: number;
    // (undocumented)
    transmissionMap?: Nullable<MaterialTextureInfo>;
}

// @public
export interface AssetMeshData {
    // (undocumented)
    morphWeights?: Nullable<number[]>;
    // (undocumented)
    subMeshes: AssetSubMeshData[];
}

// @public
export interface AssetPBRMaterialCommon extends AssetUnlitMaterial {
    // (undocumented)
    ior?: number;
}

// @public
export interface AssetPBRMaterialMR extends AssetPBRMaterialCommon {
    // (undocumented)
    clearcoat?: AssetMaterialClearcoat;
    // (undocumented)
    iridescence?: AssetMaterialIridescence;
    // (undocumented)
    metallic?: number;
    // (undocumented)
    metallicIndex?: number;
    // (undocumented)
    metallicMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    roughness?: number;
    // (undocumented)
    roughnessIndex?: number;
    // (undocumented)
    sheen?: AssetMaterialSheen;
    // (undocumented)
    specularColorMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    specularFactor?: Vector4;
    // (undocumented)
    specularMap?: Nullable<MaterialTextureInfo>;
    // (undocumented)
    transmission?: AssetMaterialTransmission;
}

// @public
export interface AssetPBRMaterialSG extends AssetPBRMaterialCommon {
    // (undocumented)
    glossness?: number;
    // (undocumented)
    specular?: Vector3;
    // (undocumented)
    specularGlossnessMap?: Nullable<MaterialTextureInfo>;
}

// @public
export interface AssetRotationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Quaternion[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export interface AssetScaleTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Vector3[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export class AssetScene extends NamedObject {
    constructor(name: string);
    rootNodes: AssetHierarchyNode[];
}

// @public
export interface AssetSkeletalAnimationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, {
        translation: Vector3;
        rotation: Quaternion;
        scale: Vector3;
    }[]>;
    // (undocumented)
    skeleton: AssetSkeleton;
}

// @public
export class AssetSkeleton extends NamedObject {
    constructor(name: string);
    addJoint(joint: AssetHierarchyNode, inverseBindMatrix: Matrix4x4): void;
    bindPoseMatrices: Matrix4x4[];
    inverseBindMatrices: Matrix4x4[];
    joints: AssetHierarchyNode[];
    pivot: Nullable<AssetHierarchyNode>;
}

// @public
export interface AssetSubMeshData {
    // (undocumented)
    material: DRef<MeshMaterial>;
    // (undocumented)
    mesh?: Mesh;
    // (undocumented)
    morphAttribCount?: number;
    // (undocumented)
    name: string;
    // (undocumented)
    numTargets: number;
    // (undocumented)
    primitive: DRef<Primitive>;
    // (undocumented)
    rawBlendIndices: Nullable<TypedArray>;
    // (undocumented)
    rawJointWeights: Nullable<TypedArray>;
    // (undocumented)
    rawPositions: Nullable<Float32Array>;
    // (undocumented)
    targetBox?: BoundingBox[];
    // (undocumented)
    targets?: Partial<Record<number, {
        numComponents: number;
        data: Float32Array[];
    }>>;
}

// @public
export interface AssetTranslationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Vector3[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export interface AssetUnlitMaterial extends AssetMaterial {
    // (undocumented)
    diffuse?: Vector4;
    // (undocumented)
    diffuseMap?: Nullable<MaterialTextureInfo>;
}

// @public
export const ATMOSPHERIC_FOG_BIT: number;

// @public
export class BaseCameraController {
    constructor();
    _getCamera(): Nullable<Camera>;
    lookAt(from: Vector3, to: Vector3, up: Vector3): void;
    onKeyDown(evt: IControllerKeydownEvent): boolean;
    protected _onKeyDown(_evt: IControllerKeydownEvent): boolean;
    onKeyUp(evt: IControllerKeyupEvent): boolean;
    protected _onKeyUp(_evt: IControllerKeyupEvent): boolean;
    onMouseDown(evt: IControllerPointerDownEvent): boolean;
    protected _onMouseDown(_evt: IControllerPointerDownEvent): boolean;
    onMouseMove(evt: IControllerPointerMoveEvent): boolean;
    protected _onMouseMove(_evt: IControllerPointerMoveEvent): boolean;
    onMouseUp(evt: IControllerPointerUpEvent): boolean;
    protected _onMouseUp(_evt: IControllerPointerUpEvent): boolean;
    onMouseWheel(evt: IControllerWheelEvent): boolean;
    protected _onMouseWheel(_evt: IControllerWheelEvent): boolean;
    reset(): void;
    _setCamera(camera: Nullable<Camera>): void;
    update(): void;
}

// @public
export abstract class BaseGraphNode extends Observable<{
    changed: [];
}> implements IGraphNode {
    constructor();
    check(): void;
    get error(): string;
    set error(str: string);
    protected _error: string;
    getOutputType(id: number): string;
    protected abstract getType(_id?: number): string;
    get inputs(): GraphNodeInput[];
    protected _inputs: GraphNodeInput[];
    get isUniform(): boolean;
    get outputs(): GraphNodeOutput[];
    protected _outputs: GraphNodeOutput[];
    get paramName(): string;
    reset(): void;
    setInput(id: number, node: BaseGraphNode, inputId: number): void;
    toString(): string;
    protected validate(): string;
}

// @public
export abstract class BaseLight extends GraphNode {
    constructor(scene: Scene, type: number);
    get diffuseAndIntensity(): Vector4;
    get directionAndCutoff(): Vector4;
    get intensity(): number;
    set intensity(val: number);
    isDirectionLight(): this is DirectionalLight;
    isLight(): this is BaseLight;
    isPointLight(): this is PointLight;
    isPunctualLight(): this is PunctualLight;
    isSpotLight(): this is SpotLight;
    get lightType(): number;
    get positionAndRange(): Immutable<Vector4>;
    setIntensity(val: number): this;
    get viewMatrix(): Immutable<Matrix4x4>;
}

// Warning: (ae-forgotten-export) The symbol "BaseSprite_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BaseSprite<M extends SpriteMaterial> extends BaseSprite_base implements BatchDrawable {
    constructor(scene: Scene);
    // (undocumented)
    get anchorX(): number;
    set anchorX(value: number);
    // (undocumented)
    get anchorY(): number;
    set anchorY(value: number);
    // (undocumented)
    calculateLocalTransform(outMatrix: Matrix4x4): void;
    // (undocumented)
    calculateWorldTransform(outMatrix: Matrix4x4): void;
    computeBoundingVolume(): null;
    computeWorldBoundingVolume(): BoundingBox | null;
    draw(ctx: DrawContext, renderQueue: Nullable<RenderQueue>, hash?: string): void;
    getBoneMatrices(): null;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "getInstanceId"
    //
    // (undocumented)
    getInstanceId(_renderPass: RenderPass): string;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "getInstanceUniforms"
    //
    // (undocumented)
    getInstanceUniforms(): Float32Array<ArrayBuffer>;
    getMaterial(): M;
    getMorphData(): null;
    getMorphInfo(): null;
    getName(): string;
    getNode(): this;
    getPickTarget(): PickTarget;
    getPrimitive(): Primitive;
    getQueueType(): number;
    isBatchable(): this is BatchDrawable;
    isUnlit(): boolean;
    get material(): M;
    set material(m: M);
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    protected onDispose(): void;
    protected onSetMaterial(material: M): void;
    // (undocumented)
    setPickTarget(node: SceneNode, label?: string): void;
    // (undocumented)
    get uvBottomRight(): Vector2;
    set uvBottomRight(value: Vector2);
    // (undocumented)
    get uvTopLeft(): Vector2;
    set uvTopLeft(value: Vector2);
}

// @public
export abstract class BaseTextureNode extends BaseGraphNode {
    constructor();
    addressU: TextureAddressMode;
    addressV: TextureAddressMode;
    filterMag: TextureFilterMode;
    filterMin: TextureFilterMode;
    filterMip: TextureFilterMode;
    protected getType(): string;
    get isUniform(): boolean;
    get paramName(): string;
    set paramName(val: string);
    sRGB: boolean;
    textureId: string;
    toString(): string;
    protected validate(): string;
}

// @public
export interface BatchDrawable extends Drawable {
}

// @public
export class BatchGroup extends GraphNode {
    constructor(scene: Scene);
    getName(): string;
    invalidate(): void;
    isBatchGroup(): this is BatchGroup;
}

// @public
export class BillboardMatrixNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof BillboardMatrixNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export type BlendMode = 'none' | 'blend' | 'additive';

// Warning: (ae-forgotten-export) The symbol "BlinnMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BlinnMaterial extends BlinnMaterial_base implements Clonable<BlinnMaterial> {
    constructor();
    // (undocumented)
    clone(): BlinnMaterial;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// @public
export abstract class Blitter {
    constructor();
    blit(source: Texture2D, dest: Nullable<FrameBuffer>, sampler?: Nullable<TextureSampler>): void;
    blit(source: Texture2D, dest: Texture2D, sampler?: Nullable<TextureSampler>): void;
    blit(source: Texture2D, dest: Texture2DArray, layer: number, sampler?: Nullable<TextureSampler>): void;
    blit(source: Texture2DArray, dest: Texture2DArray, sampler?: Nullable<TextureSampler>): void;
    blit(source: Texture2DArray, dest: Nullable<FrameBuffer>, layer: number, sampler?: Nullable<TextureSampler>): void;
    blit(source: Texture2DArray, dest: Texture2D, layer: number, sampler?: Nullable<TextureSampler>): void;
    blit(source: TextureCube, dest: TextureCube, sampler?: Nullable<TextureSampler>): void;
    blit(source: TextureCube, dest: Nullable<FrameBuffer>, face: number, sampler?: Nullable<TextureSampler>): void;
    blit(source: TextureCube, dest: Texture2D, face: number, sampler?: Nullable<TextureSampler>): void;
    // (undocumented)
    blit(source: BaseTexture, dest: BaseTexture | Nullable<FrameBuffer>, layer?: number | Nullable<TextureSampler>, sampler?: Nullable<TextureSampler>): void;
    protected abstract calcHash(): string;
    get destRect(): Nullable<number[]>;
    set destRect(val: Nullable<number[]>);
    abstract filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampeType: 'float' | 'int' | 'uint' | 'depth'): PBShaderExp;
    get hash(): string;
    invalidateHash(): void;
    readTexel(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, uv: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint' | 'depth'): PBShaderExp;
    get renderStates(): Nullable<RenderStateSet>;
    set renderStates(rs: Nullable<RenderStateSet>);
    get scissor(): Nullable<number[]>;
    set scissor(val: Nullable<number[]>);
    setUniforms(_bindGroup: BindGroup, _sourceTex: BaseTexture): void;
    setup(_scope: PBGlobalScope, _type: BlitType): void;
    get srgbOut(): boolean;
    set srgbOut(val: boolean);
    get viewport(): Nullable<number[]>;
    set viewport(val: Nullable<number[]>);
    writeTexel(scope: PBInsideFunctionScope, type: BlitType, uv: PBShaderExp, texel: PBShaderExp): PBShaderExp;
}

// @public
export type BlitType = '2d' | '2d-array' | 'cube';

// @public
export class Bloom extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, _sceneDepthTexture: Texture2D, _srgbOutput: boolean): void;
    // (undocumented)
    static readonly className: "Bloom";
    get downsampleLimit(): number;
    set downsampleLimit(val: number);
    get intensity(): number;
    set intensity(val: number);
    get maxDownsampleLevel(): number;
    set maxDownsampleLevel(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get threshold(): number;
    set threshold(val: number);
    get thresholdKnee(): number;
    set thresholdKnee(val: number);
}

// @public
export interface BlueprintDAG {
    graph: GraphStructure;
    nodeMap: Record<number, IGraphNode>;
    order: number[];
    roots: number[];
}

// @public
export interface BluePrintEditorState {
    // (undocumented)
    links: {
        startNodeId: number;
        startSlotId: number;
        endNodeId: number;
        endSlotId: number;
    }[];
    // (undocumented)
    nodes: {
        id: number;
        locked: boolean;
        node: Record<string, unknown>;
        title: string;
    }[];
}

// @public
export interface BluePrintUniformTexture extends IRUniformTexture {
    // (undocumented)
    finalSampler?: TextureSampler;
    // (undocumented)
    finalTexture?: Nullable<DRef<BaseTexture>>;
    // (undocumented)
    inFragmentShader: boolean;
    // (undocumented)
    inVertexShader: boolean;
    // (undocumented)
    params?: Nullable<Vector4>;
}

// @public
export interface BluePrintUniformValue extends IRUniformValue {
    // (undocumented)
    finalValue?: Nullable<number | Float32Array<ArrayBuffer>>;
    // (undocumented)
    inFragmentShader: boolean;
    // (undocumented)
    inVertexShader: boolean;
}

// @public
export class BoundingBox extends AABB implements BoundingVolume {
    constructor();
    constructor(box: AABB);
    constructor(minPoint: Vector3, maxPoint: Vector3);
    behindPlane(plane: Plane): boolean;
    clone(): BoundingBox;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): this;
    transform(matrix: Matrix4x4): BoundingBox;
}

// @public
export interface BoundingVolume {
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export interface BoxCreationOptions extends ShapeCreationOptions {
    anchor?: number;
    anchorX?: number;
    anchorY?: number;
    anchorZ?: number;
    size?: number;
    sizeX?: number;
    sizeY?: number;
    sizeZ?: number;
}

// @public
export class BoxFilterBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernelSize: number, blurSize: number);
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    get logSpace(): boolean;
    set logSpace(val: boolean);
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
}

// @public
export class BoxFrameShape extends Shape<BoxCreationOptions> implements Clonable<BoxFrameShape> {
    constructor(options?: BoxCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        size: number;
        sizeX: number;
        sizeY: number;
        sizeZ: number;
        anchor: number;
        anchorX: number;
        anchorY: number;
        anchorZ: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    static generateData(options: DeepRequireOptionals<BoxCreationOptions>, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "line-list";
    get type(): "BoxFrame";
}

// @public
export class BoxShape extends Shape<BoxCreationOptions> implements Clonable<BoxShape> {
    constructor(options?: BoxCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        size: number;
        anchor: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    get depth(): number;
    static generateData(opt: BoxCreationOptions, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "triangle-list";
    get height(): number;
    get type(): "Box";
    get width(): number;
}

// @public
export const BUILTIN_ASSET_TEST_CUBEMAP = "TEST_Cubemap";

// @public
export const BUILTIN_ASSET_TEXTURE_SHEEN_LUT = "LUT_Sheen";

// @public (undocumented)
export type CachedBindGroup = {
    bindGroup: BindGroup;
    buffer: Float32Array;
    offset: number;
    dirty: boolean;
};

// @public
export class Camera extends SceneNode {
    constructor(scene: Nullable<Scene>, projectionMatrix?: Matrix4x4);
    get adapted(): boolean;
    set adapted(val: boolean);
    get bloom(): boolean;
    set bloom(val: boolean);
    get bloomDownsampleLimit(): number;
    set bloomDownsampleLimit(val: number);
    get bloomIntensity(): number;
    set bloomIntensity(val: number);
    get bloomMaxDownsampleLevels(): number;
    set bloomMaxDownsampleLevels(val: number);
    get bloomThreshold(): number;
    set bloomThreshold(val: number);
    get bloomThresholdKnee(): number;
    set bloomThresholdKnee(val: number);
    get clearColor(): Vector4;
    set clearColor(v: Vector4);
    get clearDepth(): number;
    set clearDepth(v: number);
    clearHistoryData(): void;
    get clearStencil(): number;
    set clearStencil(v: number);
    get clipMask(): number;
    set clipMask(val: number);
    get commandBufferReuse(): boolean;
    set commandBufferReuse(val: boolean);
    get compositor(): Compositor;
    constructRay(x: number, y: number): Ray;
    get controller(): Nullable<BaseCameraController>;
    set controller(controller: Nullable<BaseCameraController>);
    get depthPrePass(): boolean;
    set depthPrePass(val: boolean);
    get frustum(): Immutable<Frustum>;
    // (undocumented)
    get frustumViewSpace(): Immutable<Frustum>;
    get FXAA(): boolean;
    set FXAA(val: boolean);
    getAspect(): number;
    getFarPlane(): number;
    getFOV(): number;
    getHistoryData(): CameraHistoryData;
    getInvProjectionMatrix(): Immutable<Matrix4x4>;
    getNearPlane(): number;
    getProjectionMatrix(): Immutable<Matrix4x4>;
    // (undocumented)
    getRotationMatrix(): Matrix4x4;
    getTanHalfFovy(): number;
    handleEvent<T extends IBaseEvent<any>>(ev: T, type?: string): boolean;
    get HDR(): boolean;
    set HDR(val: boolean);
    get HiZ(): boolean;
    set HiZ(val: boolean);
    get interactionRect(): Nullable<[left: number, top: number, width: number, height: number]>;
    set interactionRect(rect: Nullable<[left: number, top: number, width: number, height: number]>);
    get invViewProjectionMatrix(): Immutable<Matrix4x4>;
    isCamera(): this is Camera;
    isOrtho(): boolean;
    isPerspective(): boolean;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    lookAtCubeFace(face: CubeFace, position?: Vector3): this;
    get motionBlur(): boolean;
    set motionBlur(val: boolean);
    get motionBlurStrength(): number;
    set motionBlurStrength(val: number);
    get oit(): Nullable<OIT>;
    set oit(val: Nullable<OIT>);
    protected onDispose(): void;
    // (undocumented)
    pickAsync(posX: number, posY: number): Promise<Nullable<PickResult>>;
    // (undocumented)
    get relativeViewport(): Nullable<Immutable<number[]>>;
    render(scene: Scene): void;
    resetController(): void;
    get scissor(): Nullable<Immutable<number[]>>;
    set scissor(rect: Nullable<Immutable<number[]>>);
    get screenConfig(): Immutable<ScreenConfig>;
    set screenConfig(config: Immutable<ScreenConfig>);
    get screenViewport(): Nullable<Immutable<number[]>>;
    set screenViewport(viewport: Nullable<Immutable<number[]>>);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get SSAO(): boolean;
    set SSAO(val: boolean);
    get SSAOBias(): number;
    set SSAOBias(val: number);
    get SSAOBlurDepthCutoff(): number;
    set SSAOBlurDepthCutoff(val: number);
    get SSAOIntensity(): number;
    set SSAOIntensity(val: number);
    get SSAORadius(): number;
    set SSAORadius(val: number);
    get SSAOScale(): number;
    set SSAOScale(val: number);
    get SSR(): boolean;
    set SSR(val: boolean);
    get ssrBlurDepthCutoff(): number;
    set ssrBlurDepthCutoff(val: number);
    get ssrBlurKernelSize(): number;
    set ssrBlurKernelSize(val: number);
    get ssrBlurScale(): number;
    set ssrBlurScale(val: number);
    get ssrBlurStdDev(): number;
    set ssrBlurStdDev(val: number);
    get ssrCalcThickness(): boolean;
    set ssrCalcThickness(val: boolean);
    get ssrIterations(): number;
    set ssrIterations(val: number);
    get ssrMaxDistance(): number;
    set ssrMaxDistance(val: number);
    get ssrMaxRoughness(): number;
    set ssrMaxRoughness(val: number);
    get ssrRoughnessFactor(): number;
    set ssrRoughnessFactor(val: number);
    get ssrStride(): number;
    set ssrStride(val: number);
    get ssrThickness(): number;
    set ssrThickness(val: number);
    get TAA(): boolean;
    set TAA(val: boolean);
    get TAADebug(): number;
    set TAADebug(val: number);
    get toneMap(): boolean;
    set toneMap(val: boolean);
    get toneMapExposure(): number;
    set toneMapExposure(val: number);
    updateController(): void;
    get viewMatrix(): Immutable<Matrix4x4>;
    get viewport(): Nullable<Immutable<number[]>>;
    set viewport(rect: Nullable<Immutable<number[]>>);
    // (undocumented)
    get viewProjectionMatrix(): Immutable<Matrix4x4>;
}

// @public
export type CameraHistoryData = {
    prevColorTex: Nullable<BaseTexture>;
    prevMotionVectorTex: Nullable<BaseTexture>;
};

// @public
export class CameraNearFarNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof CameraNearFarNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec2";
    toString(): string;
    protected validate(): string;
}

// @public
export class CameraPositionNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof CameraPositionNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec3";
    toString(): string;
    protected validate(): string;
}

// @public
export class CeilNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CeilNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ClampNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ClampNode;
        name: string;
        getProps(): never[];
    };
}

// Warning: (ae-forgotten-export) The symbol "ClipmapTerrain_base" needs to be exported by the entry point index.d.ts
//
// @public
export class ClipmapTerrain extends ClipmapTerrain_base implements Drawable {
    constructor(scene: Scene, sizeX?: number, sizeZ?: number, clipMapTileSize?: number);
    calculateLocalTransform(outMatrix: Matrix4x4): void;
    calculateWorldTransform(outMatrix: Matrix4x4): void;
    get castShadow(): boolean;
    set castShadow(val: boolean);
    clone(): Promise<this>;
    computeBoundingVolume(): null;
    computeWorldBoundingVolume(): BoundingBox | null;
    draw(ctx: DrawContext, renderQueue: Nullable<RenderQueue>): void;
    getMaterial(): Nullable<ClipmapTerrainMaterial>;
    getMorphData(): null;
    getMorphInfo(): null;
    getPickTarget(): PickTarget;
    getPrimitive(): null;
    getQueueType(): number;
    // (undocumented)
    set grassAssetId(val: string);
    get grassRenderer(): GrassRenderer;
    get heightMap(): Texture2D<unknown> | null;
    set heightMap(val: Texture2D<unknown> | null);
    // (undocumented)
    set heightMapAssetId(val: string);
    isClipmapTerrain(): this is ClipmapTerrain;
    isUnlit(): boolean;
    get material(): ClipmapTerrainMaterial | null;
    get MAX_DETAIL_MAP_COUNT(): number;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    get numDetailMaps(): number;
    set numDetailMaps(val: number);
    protected onDispose(): void;
    setSize(sizeX: number, sizeZ: number): void;
    get sizeX(): number;
    set sizeX(val: number);
    get sizeZ(): number;
    set sizeZ(val: number);
    get splatMap(): Texture2D<unknown> | _zephyr3d_device.Texture2DArray<unknown> | null;
    // (undocumented)
    set splatMapAssetId(val: string);
    updateBoundingBox(): void;
    updatePerCamera(camera: Camera, _elapsedInSeconds: number, _deltaInSeconds: number): void;
    updateRegion(): void;
    get wireframe(): boolean;
    set wireframe(val: boolean);
    get worldRegion(): Immutable<Vector4>;
}

// Warning: (ae-forgotten-export) The symbol "ClipmapTerrainMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class ClipmapTerrainMaterial extends ClipmapTerrainMaterial_base {
    constructor(heightMap: Texture2D);
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    calculateAlbedoColor(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    calculateDetailNormal(scope: PBInsideFunctionScope, TBN: PBShaderExp): any;
    // (undocumented)
    calculateTerrainTBN(scope: PBInsideFunctionScope, clipmapPos: PBShaderExp, uv: PBShaderExp, texSize: PBShaderExp, scale: PBShaderExp, levelStart: PBShaderExp, levelDiff: PBShaderExp, tangent: PBShaderExp, bitangent: PBShaderExp, normal: PBShaderExp): PBShaderExp;
    // (undocumented)
    get debugMode(): TerrainDebugMode;
    set debugMode(mode: TerrainDebugMode);
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    static getDefaultDetailMap(): Nullable<Texture2D<unknown>>;
    // (undocumented)
    static getDefaultNormalMap(): Nullable<Texture2D<unknown>>;
    // (undocumented)
    getDetailMap(index: number): Nullable<Texture2D<unknown>>;
    // (undocumented)
    getDetailMapRoughness(index: number): number;
    // (undocumented)
    getDetailMapUVScale(index: number): number;
    // (undocumented)
    getDetailNormalMap(index: number): Nullable<Texture2D<unknown>>;
    // (undocumented)
    getMetallicRoughnessTexCoord: (scope: PBInsideFunctionScope) => PBShaderExp;
    // (undocumented)
    getNormalTexCoord: (scope: PBInsideFunctionScope) => PBShaderExp;
    // (undocumented)
    getSplatMap(): Texture2D<unknown> | Texture2DArray<unknown> | null;
    // (undocumented)
    get heightMap(): Texture2D;
    set heightMap(val: Texture2D);
    // (undocumented)
    static get MAX_DETAIL_MAP_COUNT(): number;
    // (undocumented)
    needSceneColor(): boolean;
    // (undocumented)
    needSceneDepth(): boolean;
    // (undocumented)
    get numDetailMaps(): number;
    set numDetailMaps(val: number);
    // (undocumented)
    protected onDispose(): void;
    // (undocumented)
    set region(val: Vector4);
    // (undocumented)
    sampleDetailNormalMap(scope: PBInsideFunctionScope, index: number, texCoord: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleHeightMap(scope: PBInsideFunctionScope, uv: PBShaderExp, pos: PBShaderExp, levelStart: PBShaderExp, levelDiff: PBShaderExp): any;
    // (undocumented)
    setClipmapGridInfo(gridScale: number, gridOffsetX: number, gridOffsetY: number): void;
    // (undocumented)
    setDetailMap(index: number, albedoMap: Nullable<Texture2D>): void;
    // (undocumented)
    setDetailMapRoughness(index: number, val: number): void;
    // (undocumented)
    setDetailMapUVScale(index: number, scale: number): void;
    // (undocumented)
    setDetailNormalMap(index: number, normalMap: Nullable<Texture2D>): void;
    // (undocumented)
    setSplatMap(tex: Texture2DArray): void;
    // (undocumented)
    supportInstancing(): boolean;
    // (undocumented)
    supportLighting(): boolean;
    // (undocumented)
    set terrainScale(val: Vector3);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export class CompAddNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CompAddNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export type ComparisonMode = 'eq' | 'ne' | 'lt' | 'le' | 'gt' | 'ge';

// @public
export class CompComparisonNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof CompComparisonNode;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(): string;
    get mode(): ComparisonMode;
    set mode(val: ComparisonMode);
    toString(): string;
    protected validate(): string;
}

// @public
export class CompDivNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CompDivNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class CompMulNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CompMulNode;
        name: string;
        getProps(): never[];
    };
    // (undocumented)
    protected getType(): string;
}

// @public
export class Compositor {
    constructor();
    appendPostEffect(postEffect: AbstractPostEffect): void;
    clear(): void;
    removePostEffect(postEffect: AbstractPostEffect): void;
}

// @public
export interface CompositorContext {
    // (undocumented)
    finalFramebuffer: FrameBuffer;
    // (undocumented)
    pingpongFramebuffers: FrameBuffer[];
    // (undocumented)
    writeIndex: number;
}

// @public
export class CompSubNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CompSubNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ConstantBooleanNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantBooleanNode;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
    get x(): boolean;
    set x(val: boolean);
}

// @public
export class ConstantBVec2Node extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantBVec2Node;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(id: number): "bool" | "bvec2";
    toString(): string;
    protected validate(): string;
    get x(): boolean;
    set x(val: boolean);
    get y(): boolean;
    set y(val: boolean);
}

// @public
export class ConstantBVec3Node extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantBVec3Node;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(id: number): "bool" | "bvec3";
    toString(): string;
    protected validate(): string;
    get x(): boolean;
    set x(val: boolean);
    get y(): boolean;
    set y(val: boolean);
    get z(): boolean;
    set z(val: boolean);
}

// @public
export class ConstantBVec4Node extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantBVec4Node;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(id: number): "bool" | "bvec4";
    toString(): string;
    protected validate(): string;
    get w(): boolean;
    set w(val: boolean);
    get x(): boolean;
    set x(val: boolean);
    get y(): boolean;
    set y(val: boolean);
    get z(): boolean;
    set z(val: boolean);
}

// @public
export class ConstantScalarNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantScalarNode;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(): string;
    get isUniform(): boolean;
    set isUniform(val: boolean);
    get paramName(): string;
    set paramName(val: string);
    toString(): string;
    protected validate(): string;
    get x(): number;
    set x(val: number);
}

// @public
export class ConstantTexture2DArrayNode extends BaseTextureNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(): string;
}

// @public
export class ConstantTexture2DNode extends BaseTextureNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(): string;
}

// @public
export class ConstantTextureCubeNode extends BaseTextureNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(): string;
}

// @public
export class ConstantVec2Node extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantVec2Node;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(id: number): "float" | "vec2";
    get isUniform(): boolean;
    set isUniform(val: boolean);
    get paramName(): string;
    set paramName(val: string);
    toString(): string;
    protected validate(): string;
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
}

// @public
export class ConstantVec3Node extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantVec3Node;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(id: number): "float" | "vec3";
    get isUniform(): boolean;
    set isUniform(val: boolean);
    get paramName(): string;
    set paramName(val: string);
    toString(): string;
    protected validate(): string;
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
}

// @public
export class ConstantVec4Node extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ConstantVec4Node;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(id: number): "float" | "vec4";
    get isUniform(): boolean;
    set isUniform(val: boolean);
    get paramName(): string;
    set paramName(val: string);
    toString(): string;
    protected validate(): string;
    get w(): number;
    set w(val: number);
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
}

// @public
export class CopyBlitter extends Blitter {
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
}

// @public
export class CosHNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CosHNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class CosNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CosNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class CrossProductNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof CrossProductNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class CubemapSHProjector extends Disposable {
    constructor(numSamples?: number);
    protected onDispose(): void;
    projectCubemap(cubemap: TextureCube, outBuffer: GPUDataBuffer, radianceSource?: boolean): void;
    projectCubemapToTexture(cubemap: TextureCube, framebuffer: FrameBuffer, radianceSource?: boolean): void;
}

// @public
export class CullVisitor implements Visitor<SceneNode | OctreeNode> {
    constructor(renderPass: RenderPass, camera: Camera, renderQueue: RenderQueue);
    get camera(): Camera;
    set camera(camera: Camera);
    get frustum(): Readonly<{
        readonly planes: readonly Readonly<{
            readonly [x: number]: number;
            readonly a: number;
            readonly b: number;
            readonly c: number;
            readonly d: number;
            readonly assign: (other: ArrayLike<number>) => _zephyr3d_base.Plane;
            readonly setEquation: (a: number, b: number, c: number, d: number) => _zephyr3d_base.Plane;
            readonly initWithOriginNormal: (origin: _zephyr3d_base.Vector3, normal: _zephyr3d_base.Vector3) => _zephyr3d_base.Plane;
            readonly initWithPoints: (p0: _zephyr3d_base.Vector3, p1: _zephyr3d_base.Vector3, p2: _zephyr3d_base.Vector3) => _zephyr3d_base.Plane;
            readonly distanceToPoint: (p: _zephyr3d_base.Vector3) => number;
            readonly nearestPointToPoint: (p: _zephyr3d_base.Vector3, result?: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly getNormal: (result?: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly inplaceFlip: () => _zephyr3d_base.Plane;
            readonly inplaceNormalize: () => _zephyr3d_base.Plane;
            readonly equalsTo: (other: Float32Array<ArrayBuffer>, epsl?: number) => boolean;
            readonly toString: () => string;
            readonly isNaN: () => boolean;
            readonly setRandom: (minValue: number, maxValue: number) => void;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: Readonly<{
                readonly byteLength: number;
                readonly slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: "ArrayBuffer";
            }>;
            readonly byteLength: number;
            readonly byteOffset: number;
            readonly copyWithin: (target: number, start: number, end?: number) => _zephyr3d_base.Plane;
            readonly every: (predicate: (value: number, index: number, array: _zephyr3d_base.Plane) => unknown, thisArg?: any) => boolean;
            readonly fill: (value: number, start?: number, end?: number) => _zephyr3d_base.Plane;
            readonly filter: (predicate: (value: number, index: number, array: _zephyr3d_base.Plane) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
            readonly find: (predicate: (value: number, index: number, obj: _zephyr3d_base.Plane) => boolean, thisArg?: any) => number | undefined;
            readonly findIndex: (predicate: (value: number, index: number, obj: _zephyr3d_base.Plane) => boolean, thisArg?: any) => number;
            readonly forEach: (callbackfn: (value: number, index: number, array: _zephyr3d_base.Plane) => void, thisArg?: any) => void;
            readonly indexOf: (searchElement: number, fromIndex?: number) => number;
            readonly join: (separator?: string) => string;
            readonly lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            readonly map: (callbackfn: (value: number, index: number, array: _zephyr3d_base.Plane) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
            readonly reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Plane) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Plane) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: _zephyr3d_base.Plane) => U, initialValue: U): U;
            };
            readonly reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Plane) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Plane) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: _zephyr3d_base.Plane) => U, initialValue: U): U;
            };
            readonly reverse: () => _zephyr3d_base.Plane;
            readonly set: (array: ArrayLike<number>, offset?: number) => void;
            readonly slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
            readonly some: (predicate: (value: number, index: number, array: _zephyr3d_base.Plane) => unknown, thisArg?: any) => boolean;
            readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => _zephyr3d_base.Plane;
            readonly subarray: (begin?: number, end?: number) => Float32Array<ArrayBuffer>;
            readonly toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            readonly valueOf: () => _zephyr3d_base.Plane;
            readonly entries: () => ArrayIterator<[number, number]>;
            readonly keys: () => ArrayIterator<number>;
            readonly values: () => ArrayIterator<number>;
            readonly includes: (searchElement: number, fromIndex?: number) => boolean;
            readonly [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Float32Array";
        }>[];
        readonly corners: readonly Readonly<{
            readonly [x: number]: number;
            readonly clone: () => _zephyr3d_base.Vector3;
            readonly x: number;
            readonly y: number;
            readonly z: number;
            readonly magnitude: number;
            readonly magnitudeSq: number;
            readonly xy: () => _zephyr3d_base.Vector2;
            readonly setXYZ: (x: number, y: number, z: number) => _zephyr3d_base.Vector3;
            readonly setAndNormalize: (x: number, y: number, z: number) => _zephyr3d_base.Vector3;
            readonly subBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly addBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly combineBy: (other: _zephyr3d_base.Vector3, t0: number, t1: number) => _zephyr3d_base.Vector3;
            readonly mulBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly divBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly scaleBy: (f: number) => _zephyr3d_base.Vector3;
            readonly inplaceNormalize: () => _zephyr3d_base.Vector3;
            readonly inplaceInverse: () => _zephyr3d_base.Vector3;
            readonly inplaceMin: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly inplaceMax: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            readonly equalsTo: (other: Float32Array<ArrayBuffer>, epsl?: number) => boolean;
            readonly toString: () => string;
            readonly isNaN: () => boolean;
            readonly setRandom: (minValue: number, maxValue: number) => void;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: Readonly<{
                readonly byteLength: number;
                readonly slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: "ArrayBuffer";
            }>;
            readonly byteLength: number;
            readonly byteOffset: number;
            readonly copyWithin: (target: number, start: number, end?: number) => _zephyr3d_base.Vector3;
            readonly every: (predicate: (value: number, index: number, array: _zephyr3d_base.Vector3) => unknown, thisArg?: any) => boolean;
            readonly fill: (value: number, start?: number, end?: number) => _zephyr3d_base.Vector3;
            readonly filter: (predicate: (value: number, index: number, array: _zephyr3d_base.Vector3) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
            readonly find: (predicate: (value: number, index: number, obj: _zephyr3d_base.Vector3) => boolean, thisArg?: any) => number | undefined;
            readonly findIndex: (predicate: (value: number, index: number, obj: _zephyr3d_base.Vector3) => boolean, thisArg?: any) => number;
            readonly forEach: (callbackfn: (value: number, index: number, array: _zephyr3d_base.Vector3) => void, thisArg?: any) => void;
            readonly indexOf: (searchElement: number, fromIndex?: number) => number;
            readonly join: (separator?: string) => string;
            readonly lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            readonly map: (callbackfn: (value: number, index: number, array: _zephyr3d_base.Vector3) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
            readonly reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => U, initialValue: U): U;
            };
            readonly reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => U, initialValue: U): U;
            };
            readonly reverse: () => _zephyr3d_base.Vector3;
            readonly set: (array: ArrayLike<number>, offset?: number) => void;
            readonly slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
            readonly some: (predicate: (value: number, index: number, array: _zephyr3d_base.Vector3) => unknown, thisArg?: any) => boolean;
            readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => _zephyr3d_base.Vector3;
            readonly subarray: (begin?: number, end?: number) => Float32Array<ArrayBuffer>;
            readonly toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            readonly valueOf: () => _zephyr3d_base.Vector3;
            readonly entries: () => ArrayIterator<[number, number]>;
            readonly keys: () => ArrayIterator<number>;
            readonly values: () => ArrayIterator<number>;
            readonly includes: (searchElement: number, fromIndex?: number) => boolean;
            readonly [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Float32Array";
        }>[];
        getCorner: (pos: number) => Readonly<{
            [x: number]: number;
            clone: () => _zephyr3d_base.Vector3;
            x: number;
            y: number;
            z: number;
            readonly magnitude: number;
            readonly magnitudeSq: number;
            xy: () => _zephyr3d_base.Vector2;
            setXYZ: (x: number, y: number, z: number) => _zephyr3d_base.Vector3;
            setAndNormalize: (x: number, y: number, z: number) => _zephyr3d_base.Vector3;
            subBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            addBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            combineBy: (other: _zephyr3d_base.Vector3, t0: number, t1: number) => _zephyr3d_base.Vector3;
            mulBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            divBy: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            scaleBy: (f: number) => _zephyr3d_base.Vector3;
            inplaceNormalize: () => _zephyr3d_base.Vector3;
            inplaceInverse: () => _zephyr3d_base.Vector3;
            inplaceMin: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            inplaceMax: (other: _zephyr3d_base.Vector3) => _zephyr3d_base.Vector3;
            equalsTo: (other: Float32Array<ArrayBuffer>, epsl?: number) => boolean;
            toString: () => string;
            isNaN: () => boolean;
            setRandom: (minValue: number, maxValue: number) => void;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: Readonly<{
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: "ArrayBuffer";
            }>;
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => _zephyr3d_base.Vector3;
            every: (predicate: (value: number, index: number, array: _zephyr3d_base.Vector3) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => _zephyr3d_base.Vector3;
            filter: (predicate: (value: number, index: number, array: _zephyr3d_base.Vector3) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: _zephyr3d_base.Vector3) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: _zephyr3d_base.Vector3) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: _zephyr3d_base.Vector3) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: _zephyr3d_base.Vector3) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
            reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => U, initialValue: U): U;
            };
            reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: _zephyr3d_base.Vector3) => U, initialValue: U): U;
            };
            reverse: () => _zephyr3d_base.Vector3;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: _zephyr3d_base.Vector3) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => _zephyr3d_base.Vector3;
            subarray: (begin?: number, end?: number) => Float32Array<ArrayBuffer>;
            toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            valueOf: () => _zephyr3d_base.Vector3;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Float32Array";
        }>;
        containsPoint: (pt: _zephyr3d_base.Vector3, epsl?: number) => boolean;
        initWithMatrix: (transform: _zephyr3d_base.Matrix4x4) => _zephyr3d_base.Frustum;
    }>;
    get frustumCulling(): boolean;
    set frustumCulling(val: boolean);
    get renderPass(): RenderPass;
    get renderQueue(): RenderQueue;
    set renderQueue(renderQueue: RenderQueue);
    visit(target: SceneNode | OctreeNode): boolean;
    // (undocumented)
    visitSprite(node: Sprite): boolean;
}

// @public
export interface CylinderCreationOptions extends ShapeCreationOptions {
    anchor?: number;
    bottomCap?: boolean;
    bottomRadius?: number;
    height?: number;
    heightDetail?: number;
    radialDetail?: number;
    topCap?: boolean;
    topRadius?: number;
}

// @public
export class CylinderShape extends Shape<CylinderCreationOptions> implements Clonable<CylinderShape> {
    constructor(options?: CylinderCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        topCap: boolean;
        bottomCap: boolean;
        bottomRadius: number;
        topRadius: number;
        heightDetail: number;
        radialDetail: number;
        height: number;
        anchor: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    static generateData(opt: CylinderCreationOptions, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "triangle-list";
    get type(): "Cylinder";
}

// @public
export class DDXNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof DDXNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class DDYNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof DDYNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export function decode2HalfFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeNormalizedFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeRGBM(scope: PBInsideFunctionScope, rgbm: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// @public (undocumented)
export function defineProps(accessors: PropertyAccessor<any, 'DUMMY'>[]): PropertyAccessor[];

// @public
export class Degrees2RadiansNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof Degrees2RadiansNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class DepthPass extends RenderPass {
    constructor();
    // (undocumented)
    get encodeDepth(): boolean;
    set encodeDepth(val: boolean);
    // (undocumented)
    get renderBackface(): boolean;
    set renderBackface(val: boolean);
    // (undocumented)
    get transmission(): boolean;
    set transmission(val: boolean);
}

// @public
export class DirectionalLight extends PunctualLight {
    constructor(scene: Scene);
    // (undocumented)
    static getSunLight(scene: Scene): DirectionalLight | null;
    // @override
    isDirectionLight(): this is DirectionalLight;
    // (undocumented)
    static setSunLight(scene: Scene, light: Nullable<DirectionalLight>): void;
    get sunLight(): boolean;
    set sunLight(val: boolean);
}

// @public
export class DistanceNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof DistanceNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class DotProductNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof DotProductNode;
        name: string;
        getProps(): never[];
    };
}

// @public (undocumented)
export class DracoMeshDecoder {
    constructor(data: Int8Array<ArrayBuffer>, decoderModule: DecoderModule);
    // (undocumented)
    getAttributeBuffer(id: number, buffer: TypedArray): TypedArray | null;
    // (undocumented)
    getIndexBuffer(): Uint32Array<ArrayBuffer> | null;
}

// @public
export interface Drawable {
    applyTransformUniforms(renderQueue: RenderQueue): void;
    dispose(): void;
    draw(ctx: DrawContext, renderQueue: Nullable<RenderQueue>, hash?: string): void;
    getBoneMatrices(): Nullable<Texture2D>;
    getDrawableId(): number;
    getMaterial(): Nullable<MeshMaterial>;
    getMorphData(): Nullable<MorphData>;
    getMorphInfo(): Nullable<MorphInfo>;
    getName(): string;
    getNode(): SceneNode;
    getObjectColor(): Vector4;
    getPickTarget(): PickTarget;
    getPrimitive(): Nullable<Primitive>;
    getQueueType(): number;
    getSortDistance(camera: Camera): number;
    isBatchable(): this is BatchDrawable;
    isUnlit(): boolean;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    pushRenderQueueRef(ref: RenderQueueRef): void;
}

// @public
export interface DrawableInstanceInfo {
    // (undocumented)
    bindGroup: CachedBindGroup;
    // (undocumented)
    offset: number;
}

// @public
export interface DrawContext {
    readonly camera: Camera;
    // Warning: (ae-forgotten-export) The symbol "ClusteredLight" needs to be exported by the entry point index.d.ts
    clusteredLight?: ClusteredLight;
    readonly colorFormat: TextureFormat;
    compositor?: Nullable<Compositor>;
    readonly depthFormat: TextureFormat;
    depthTexture?: Texture2D;
    readonly device: AbstractDevice;
    drawEnvLight: boolean;
    env: Nullable<Environment>;
    finalFramebuffer: Nullable<FrameBuffer>;
    flip: boolean;
    forceColorState?: Nullable<ColorState>;
    forceCullMode?: Nullable<FaceMode>;
    // Warning: (ae-forgotten-export) The symbol "GlobalBindGroupAllocator" needs to be exported by the entry point index.d.ts
    readonly globalBindGroupAllocator: GlobalBindGroupAllocator;
    readonly HiZ: boolean;
    HiZTexture: Nullable<Texture2D>;
    instanceData?: Nullable<InstanceData>;
    intermediateFramebuffer: Nullable<FrameBuffer>;
    lightBlending: boolean;
    linearDepthTexture?: Texture2D;
    materialFlags: number;
    readonly motionVectors: boolean;
    motionVectorTexture?: Nullable<Texture2D>;
    oit: Nullable<OIT>;
    queue: number;
    readonly renderHeight: number;
    renderPass: Nullable<RenderPass>;
    renderPassHash: Nullable<string>;
    readonly renderWidth: number;
    readonly scene: Scene;
    sceneColorTexture?: Texture2D;
    readonly SSR: boolean;
    SSRCalcThickness: boolean;
    SSRNormalTexture: Texture2D;
    SSRRoughnessTexture: Texture2D;
    sunLight?: Nullable<DirectionalLight>;
}

// @public
export type EditorMode = 'editor' | 'editor-preview' | 'none';

// @public
export class ElapsedTimeNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ElapsedTimeNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export type EmitterBehavior = 'surface' | 'volume';

// @public
export type EmitterShape = 'point' | 'sphere' | 'box' | 'cylinder' | 'cone';

// @public
export function encode2HalfToRGBA(scope: PBInsideFunctionScope, a: PBShaderExp | number, b: PBShaderExp | number): PBShaderExp;

// @public
export function encodeFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeNormalizedFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeRGBM(scope: PBInsideFunctionScope, rgb: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// @public
export class Engine {
    constructor(VFS?: VFS, scriptsRoot?: string, enabled?: boolean);
    // (undocumented)
    protected _activeRenderables: {
        renderable: DRef<IRenderable>;
        hook: Nullable<IRenderHook>;
    }[];
    attachScript<T extends Host>(host: Nullable<T>, module: string): Promise<Nullable<RuntimeScript<T>>>;
    detachAllScripts(): void;
    detachScript<T extends Host>(host: T, idOrInstance: string | RuntimeScript<T>): void;
    getScriptObjects<T extends RuntimeScript<any>>(host: unknown): T[];
    // (undocumented)
    loadSceneFromFile(path: string): Promise<Nullable<Scene>>;
    // (undocumented)
    readFile<T extends ReadOptions['encoding'] = 'binary'>(path: string, encoding?: T): Promise<(T extends "binary" ? ArrayBuffer : string) | null>;
    // (undocumented)
    render(): void;
    get resourceManager(): ResourceManager;
    get screen(): ScreenAdapter;
    get scriptingSystem(): ScriptingSystem;
    // (undocumented)
    setRenderable(renderable: Nullable<IRenderable>, layer?: number, hook?: IRenderHook): void;
    // (undocumented)
    startup(startupScene?: Nullable<string>, splashScreen?: Nullable<string>, startupScript?: Nullable<string>): Promise<void>;
    update(deltaTime: number, elapsedTime: number): void;
    get VFS(): VFS;
    set VFS(vfs: VFS);
}

// @public
export class EnvConstantAmbient extends EnvironmentLighting {
    constructor(ambientColor?: Vector4);
    get ambientColor(): Immutable<Vector4>;
    set ambientColor(ambientColor: Immutable<Vector4>);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, _normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(_scope: PBInsideFunctionScope, _refl: PBShaderExp, _roughness: PBShaderExp): null;
    // @override
    getType(): "constant";
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EnvHemisphericAmbient extends EnvironmentLighting {
    constructor(ambientUp: Vector4, ambientDown: Vector4);
    get ambientDown(): Immutable<Vector4>;
    set ambientDown(color: Immutable<Vector4>);
    get ambientUp(): Immutable<Vector4>;
    set ambientUp(color: Immutable<Vector4>);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, _roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): "hemisphere";
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class Environment extends Disposable {
    get light(): EnvLightWrapper;
    protected onDispose(): void;
    get sky(): SkyRenderer;
}

// @public
export abstract class EnvironmentLighting extends Disposable {
    abstract getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    abstract getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): Nullable<PBShaderExp>;
    abstract getType(): EnvLightType;
    abstract hasIrradiance(): boolean;
    abstract hasRadiance(): boolean;
    abstract initShaderBindings(pb: ProgramBuilder): void;
    abstract updateBindGroup(bg: BindGroup): void;
}

// @public
export type EnvLightType = 'ibl' | 'hemisphere' | 'constant' | 'none';

// @public
export class EnvLightWrapper extends Disposable {
    get ambientColor(): Vector4;
    set ambientColor(val: Vector4);
    get ambientDown(): Vector4;
    set ambientDown(val: Vector4);
    get ambientUp(): Vector4;
    set ambientUp(val: Vector4);
    get irradianceSH(): Nullable<GPUDataBuffer<unknown>>;
    set irradianceSH(value: Nullable<GPUDataBuffer<unknown>>);
    get irradianceSHFB(): Nullable<FrameBuffer<unknown>>;
    set irradianceSHFB(value: Nullable<FrameBuffer<unknown>>);
    get irradianceWindow(): Immutable<Vector3>;
    set irradianceWindow(value: Immutable<Vector3>);
    protected onDispose(): void;
    get radianceMap(): Nullable<TextureCube<unknown>>;
    set radianceMap(tex: Nullable<TextureCube<unknown>>);
    get strength(): number;
    set strength(val: number);
    get type(): EnvLightType;
    set type(val: EnvLightType);
}

// @public
export class EnvShIBL extends EnvironmentLighting {
    constructor(radianceMap?: TextureCube, irradianceSH?: GPUDataBuffer, irradianceSHFB?: FrameBuffer);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): "ibl";
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    get irradianceSH(): Nullable<GPUDataBuffer<unknown>>;
    set irradianceSH(value: Nullable<GPUDataBuffer<unknown>>);
    get irradianceSHFB(): Nullable<FrameBuffer<unknown>>;
    set irradianceSHFB(value: Nullable<FrameBuffer<unknown>>);
    get irradianceWindow(): Vector3;
    set irradianceWindow(val: Vector3);
    // @override
    protected onDispose(): void;
    get radianceMap(): Nullable<TextureCube<unknown>>;
    set radianceMap(tex: Nullable<TextureCube<unknown>>);
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EqualNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof EqualNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class Exp2Node extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof Exp2Node;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ExpNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ExpNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export type ExtractMixinReturnType<M> = M extends (target: infer A) => infer R ? R : never;

// @public
export type ExtractMixinType<M> = M extends [infer First] ? ExtractMixinReturnType<First> : M extends [infer First, ...infer Rest] ? ExtractMixinReturnType<First> & ExtractMixinType<[...Rest]> : never;

// @public
export class FaceForwardNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof FaceForwardNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class FBMWaveGenerator extends Disposable implements WaveGenerator {
    constructor();
    get amplitude(): number;
    set amplitude(val: number);
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    clone(): this;
    get frequency(): number;
    set frequency(val: number);
    getHash(): string;
    isOk(): boolean;
    needUpdate(): boolean;
    get numOctaves(): number;
    set numOctaves(val: number);
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    update(): void;
    // (undocumented)
    get version(): number;
    get wind(): Immutable<Vector2>;
    set wind(val: Immutable<Vector2>);
}

// @public
export function fetchSampler(type: SamplerType): TextureSampler<unknown> | null;

// @public
export class FFTWaveGenerator extends Disposable implements WaveGenerator {
    // Warning: (ae-forgotten-export) The symbol "OceanFieldBuildParams" needs to be exported by the entry point index.d.ts
    constructor(params?: OceanFieldBuildParams);
    get alignment(): number;
    set alignment(val: number);
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, _vertexNormal: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    clone(): this;
    get foamContrast(): number;
    set foamContrast(val: number);
    get foamWidth(): number;
    set foamWidth(val: number);
    getHash(): string;
    getWaveCroppiness(cascade: number): number;
    getWaveLength(cascade: number): number;
    getWaveStrength(cascade: number): number;
    isOk(): boolean;
    needUpdate(): boolean;
    // (undocumented)
    protected onDispose(): void;
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    setWaveCroppiness(cascade: number, croppiness: number): void;
    setWaveLength(cascade: number, length: number): void;
    setWaveStrength(cascade: number, strength: number): void;
    update(time: number): void;
    // (undocumented)
    get version(): number;
    get wind(): Immutable<Vector2>;
    set wind(val: Immutable<Vector2>);
}

// @public
export class FloorNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof FloorNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class FmaNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof FmaNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export type FogType = 'height_fog' | 'none';

// @public
export class FPSCameraController extends BaseCameraController {
    constructor(options?: FPSCameraControllerOptions);
    // @override
    protected _onKeyDown(evt: IControllerKeydownEvent): boolean;
    // @override
    protected _onKeyUp(evt: IControllerKeyupEvent): boolean;
    // @override
    protected _onMouseDown(evt: IControllerPointerDownEvent): boolean;
    // @override
    protected _onMouseMove(evt: IControllerPointerMoveEvent): boolean;
    // @override
    protected _onMouseUp(evt: IControllerPointerUpEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: FPSCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface FPSCameraControllerOptions {
    controlKeys?: {
        up: string;
        down: string;
        forward: string;
        backward: string;
        left: string;
        right: string;
    };
    moveSpeed?: number;
    rotateSpeed?: number;
}

// @public
export class FractNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof FractNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class FunctionCallNode extends BaseGraphNode {
    constructor(path: string, name: string, IR: MaterialBlueprintIR);
    get args(): {
        index: number;
        name: string;
        type: string;
    }[];
    static getSerializationCls(manager: ResourceManager): {
        ctor: typeof FunctionCallNode;
        name: string;
        createFunc(_: unknown, init: string): Promise<{
            obj: FunctionCallNode;
        }>;
        getInitParams(obj: FunctionCallNode): string;
        getProps(): never[];
    };
    protected getType(id: number): string;
    get IR(): MaterialBlueprintIR;
    get name(): string;
    get outs(): {
        index: number;
        name: string;
        type: string;
    }[];
    get path(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class FunctionInputNode extends BaseGraphNode {
    constructor();
    static argId: number;
    static getSerializationCls(): {
        ctor: typeof FunctionInputNode;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(): string;
    get name(): string;
    set name(val: string);
    toString(): string;
    get type(): string;
    protected validate(): string;
}

// @public
export class FunctionOutputNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof FunctionOutputNode;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(): string;
    get name(): string;
    set name(val: string);
    static outId: number;
    toString(): string;
    get type(): string;
    protected validate(): "" | "Missing result" | "Cannot determin result type";
}

// @public
export class FWidthNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof FWidthNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class FXAA extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export function gammaToLinear(scope: PBInsideFunctionScope, color: PBShaderExp): PBShaderExp;

// @public
export class GaussianBlurBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernalSize: number, sigma: number, blurSize: number);
    get blurSize(): number;
    set blurSize(val: number);
    // @override
    protected calcHash(): string;
    get depthCutoff(): number;
    set depthCutoff(val: number);
    get depthTexture(): Nullable<Texture2D<unknown>>;
    set depthTexture(tex: Nullable<Texture2D<unknown>>);
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    get kernelSize(): number;
    set kernelSize(val: number);
    get logSpace(): boolean;
    set logSpace(val: boolean);
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
}

// @public
export abstract class GenericMathNode extends BaseGraphNode {
    constructor(func: string, numArgs: number, outType?: Nullable<string>, inTypes?: Nullable<string[]>, explicitInTypes?: Nullable<Record<number, string[]>>, additionalInTypes?: Nullable<Record<number, string[]>>, originTypes?: string[]);
    readonly additionalInTypes: Nullable<Record<number, string[]>>;
    readonly explicitInTypes: Nullable<Record<number, string[]>>;
    readonly func: string;
    protected getType(): string;
    readonly outType: string;
    toString(): string;
    protected validate(): string;
}

// @public
export class GerstnerWaveGenerator extends Disposable implements WaveGenerator {
    constructor();
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    clone(): this;
    deleteWave(index: number): void;
    getHash(): string;
    getOriginX(waveIndex: number): number;
    getOriginZ(waveIndex: number): number;
    getWaveAmplitude(waveIndex: number): number;
    getWaveDirection(waveIndex: number): number;
    getWaveLength(waveIndex: number): number;
    getWaveSteepness(waveIndex: number): number;
    insertWave(index: number): void;
    isOk(): boolean;
    isOmniWave(waveIndex: number): boolean;
    needUpdate(): boolean;
    get numWaves(): number;
    set numWaves(val: number);
    setOmniWave(waveIndex: number, isOmni: boolean): void;
    setOrigin(waveIndex: number, x: number, z: number): void;
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    setWaveAmplitude(waveIndex: number, val: number): void;
    setWaveDirection(waveIndex: number, angle: number): void;
    setWaveLength(waveIndex: number, val: number): void;
    setWaveSteepness(waveIndex: number, steepness: number): void;
    update(): void;
    // (undocumented)
    get version(): number;
}

// @public
export function getApp(): Application;

// @public
export function getDevice(): _zephyr3d_device.AbstractDevice;

// @public
export function getEngine(): Engine;

// @public
export function getInput(): InputManager;

// @public
export function gradient(scope: PBInsideFunctionScope, p: PBShaderExp, t: PBShaderExp | number): PBShaderExp;

// @public
export class GraphNode extends SceneNode {
    constructor(scene: Scene);
    getBoneMatrices(): Nullable<Texture2D>;
    getName(): string;
    getNode(): this;
    getSortDistance(camera: Camera): number;
    isBatchable(): this is BatchDrawable;
    // @override
    isGraphNode(): this is GraphNode;
    // (undocumented)
    set octreeNode(node: Nullable<OctreeNode>);
}

// @public
export type GraphNodeInput = {
    id: number;
    name: string;
    type: string[];
    inputNode?: Nullable<IGraphNode>;
    inputId?: Nullable<number>;
    defaultValue?: number[];
    required?: boolean;
    originType?: string;
};

// @public
export type GraphNodeOutput = {
    id: number;
    name: string;
    swizzle?: string;
};

// @public
export interface GraphStructure {
    incoming: Record<number, NodeConnection[]>;
    outgoing: Record<number, NodeConnection[]>;
}

// @public
export type GrassInstanceInfo = {
    x: number;
    y: number;
    angle: number;
};

// @public
export class GrassLayer extends Disposable {
    constructor(terrain: ClipmapTerrain, bladeWidth: number, bladeHeight: number, albedoMap?: Texture2D);
    addInstances(instances: GrassInstanceInfo[]): number;
    get bladeHeight(): number;
    set bladeHeight(val: number);
    get bladeWidth(): number;
    set bladeWidth(val: number);
    getAlbedoMap(): Nullable<Texture2D<unknown>>;
    removeInstances(minX: number, minZ: number, maxX: number, maxZ: number, numInstances: number): void;
    setAlbedoMap(albedoMap: Texture2D): void;
    setBladeSize(width: number, height: number): void;
}

// Warning: (ae-forgotten-export) The symbol "GrassMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class GrassMaterial extends GrassMaterial_base implements Clonable<GrassMaterial> {
    constructor(terrainSize: Vector2, normalMap: Texture2D, grassTexture?: Nullable<Texture2D>);
    // (undocumented)
    apply(ctx: DrawContext): boolean;
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    clone(): GrassMaterial;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // @override
    isTransparentPass(_pass: number): boolean;
    // @override
    supportInstancing(): boolean;
    // @override
    supportLighting(): boolean;
    // (undocumented)
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export class GrassRenderer extends Disposable {
    constructor(terrain: ClipmapTerrain);
    addInstances(layer: number, instances: GrassInstanceInfo[]): void;
    addLayer(bladeWidth: number, bladeHeight: number, albedoMap?: Texture2D): number;
    getBladeHeight(layer: number): number;
    getBladeWidth(layer: number): number;
    getGrassTexture(layer: number): Texture2D<unknown> | null;
    getLayer(index: number): GrassLayer;
    get numGrassBlades(): number;
    get numLayers(): number;
    // (undocumented)
    protected onDispose(): void;
    removeInstances(layer: number, minX: number, minZ: number, maxX: number, maxZ: number, num: number): void;
    setBladeSize(layer: number, width: number, height: number): void;
    setGrassTexture(layer: number, texture: Texture2D): void;
}

// @public
export class Grayscale extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export function hash11(scope: PBInsideFunctionScope, p: number | PBShaderExp): PBShaderExp;

// @public
export function hash12(scope: PBInsideFunctionScope, p: number | PBShaderExp): PBShaderExp;

// @public
export function hash13(scope: PBInsideFunctionScope, p: number | PBShaderExp): PBShaderExp;

// @public
export class Hash1Node extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof Hash1Node;
        name: string;
        getProps(): never[];
    };
}

// @public
export function hash21(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export function hash22(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export function hash23(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class Hash2Node extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof Hash2Node;
        name: string;
        getProps(): never[];
    };
}

// @public
export function hash31(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export function hash32(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export function hash33(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class Hash3Node extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof Hash3Node;
        name: string;
        getProps(): never[];
    };
}

// @public
export const HEIGHT_FOG_BIT: number;

// @public
export type Host = IDisposable;

// @public
export interface IAttachedScript {
    id: string;
    instance: RuntimeScript<any>;
    url: string;
}

// @public
export interface IBaseEvent<T extends string> {
    preventDefault?: () => void;
    type: T;
}

// @public
export interface IControllerKeyboardEvent<T extends string> extends IBaseEvent<T>, IModKey {
    readonly code: string;
    readonly key: string;
}

// @public
export interface IControllerKeydownEvent extends IControllerKeyboardEvent<'keydown'> {
}

// @public
export interface IControllerKeypressEvent extends IControllerKeyboardEvent<'keypress'> {
}

// @public
export interface IControllerKeyupEvent extends IControllerKeyboardEvent<'keyup'> {
}

// @public
export interface IControllerMouseEvent<T extends string> extends IBaseEvent<T>, IModKey {
    readonly button: number;
    readonly offsetX: number;
    readonly offsetY: number;
}

// @public
export interface IControllerPointerCancelEvent extends IControllerMouseEvent<'pointercancel'> {
}

// @public
export interface IControllerPointerDownEvent extends IControllerMouseEvent<'pointerdown'> {
}

// @public
export interface IControllerPointerMoveEvent extends IControllerMouseEvent<'pointermove'> {
}

// @public
export interface IControllerPointerUpEvent extends IControllerMouseEvent<'pointerup'> {
}

// @public
export interface IControllerWheelEvent extends IControllerMouseEvent<'wheel'> {
    readonly deltaMode: number;
    readonly deltaX: number;
    readonly deltaY: number;
}

// @public
export interface IGraphNode extends IEventTarget<{
    changed: [];
}> {
    check(): void;
    error: string;
    getOutputType(id: number): string;
    readonly inputs: GraphNodeInput[];
    isUniform: boolean;
    readonly outputs: GraphNodeOutput[];
    paramName: string;
    reset(): void;
    toString(): string;
}

// @public
export type IMixinAlbedoColor = {
    albedoColor: Vector4;
    calculateAlbedoColor(scope: PBInsideFunctionScope, uv?: PBShaderExp): PBShaderExp;
} & TextureMixinInstanceTypes<['albedo']>;

// @public
export type IMixinBlinnPhong = {
    shininess: number;
    blinnPhongLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
} & IMixinLight;

// @public
export interface IMixinFoliage {
    // (undocumented)
    calculateFoliageAlbedo(scope: PBInsideFunctionScope, albedoColor: PBShaderExp, texelCoord: PBShaderExp): PBShaderExp;
}

// @public
export type IMixinLambert = {
    lambertLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, albedo: PBShaderExp): PBShaderExp;
} & IMixinLight;

// @public
export type IMixinLight = {
    normalScale: number;
    normalMapMode: 'tangent-space' | 'object-space';
    doubleSidedLighting: boolean;
    needCalculateEnvLight(): boolean;
    getUniformNormalScale(scope: PBInsideFunctionScope): PBShaderExp;
    getEnvLightIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    getEnvLightRadiance(scope: PBInsideFunctionScope, reflectVec: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    calculateViewVector(scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    calculateReflectionVector(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp): PBShaderExp;
    calculateTBN(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateNormal(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateNormalAndTBN(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateLightAttenuation(scope: PBInsideFunctionScope, type: PBShaderExp, worldPos: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateLightDirection(scope: PBInsideFunctionScope, type: PBShaderExp, worldPos: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateShadow(scope: PBInsideFunctionScope, worldPos: PBShaderExp, NoL: PBShaderExp): PBShaderExp;
    forEachLight(scope: PBInsideFunctionScope, callback: (this: PBInsideFunctionScope, type: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp, colorIntensity: PBShaderExp, shadow: boolean) => void): void;
} & TextureMixinInstanceTypes<['normal']> & IMixinAlbedoColor;

// Warning: (ae-forgotten-export) The symbol "IMixinPBRBRDF" needs to be exported by the entry point index.d.ts
//
// @public
export type IMixinPBRBluePrint = {
    PBRLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
    getCommonDatasStruct(scope: PBInsideFunctionScope): ShaderTypeFunc;
    getCommonData(scope: PBInsideFunctionScope, data: PBShaderExp, viewVec: PBShaderExp, worldPos: PBShaderExp, worldNorm: PBShaderExp, worldTangent: PBShaderExp, worldBinormal: PBShaderExp, vertexColor: PBShaderExp, vertexUV: PBShaderExp, ir: MaterialBlueprintIR): void;
    calculateCommonData(scope: PBInsideFunctionScope, ir: MaterialBlueprintIR, viewVec: PBShaderExp, worldPos: PBShaderExp, worldNorm: PBShaderExp, worldTangent: PBShaderExp, worldBinormal: PBShaderExp, vertexColor: PBShaderExp, vertexUV: PBShaderExp, data: PBShaderExp): void;
    directLighting(scope: PBInsideFunctionScope, lightDir: PBShaderExp, lightColor: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp): void;
    indirectLighting(scope: PBInsideFunctionScope, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp, outRoughness?: PBShaderExp): void;
} & IMixinPBRBRDF & IMixinLight;

// @public
export type IMixinPBRCommon = {
    ior: number;
    emissiveColor: Vector3;
    emissiveStrength: number;
    occlusionStrength: number;
    transmission: boolean;
    transmissionFactor: number;
    thicknessFactor: number;
    attenuationColor: Vector3;
    attenuationDistance: number;
    sheen: boolean;
    sheenColorFactor: Vector3;
    sheenRoughnessFactor: number;
    clearcoat: boolean;
    clearcoatIntensity: number;
    clearcoatRoughnessFactor: number;
    iridescence: boolean;
    iridescenceFactor: number;
    iridescenceIor: number;
    iridescenceThicknessMin: number;
    iridescenceThicknessMax: number;
    getCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
    getCommonDatasStruct(scope: PBInsideFunctionScope): ShaderTypeFunc;
    calculateEmissiveColor(scope: PBInsideFunctionScope): PBShaderExp;
    getF0(scope: PBInsideFunctionScope): PBShaderExp;
    directLighting(scope: PBInsideFunctionScope, lightDir: PBShaderExp, lightColor: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp): void;
    indirectLighting(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp, outRoughness?: PBShaderExp): void;
} & TextureMixinInstanceTypes<[
'occlusion',
'emissive',
'sheenColor',
'sheenRoughness',
'clearcoatIntensity',
'clearcoatRoughness',
'clearcoatNormal',
'transmission',
'thickness',
'iridescence',
'iridescenceThickness'
]> & IMixinPBRBRDF;

// @public
export type IMixinPBRMetallicRoughness = {
    metallic: number;
    roughness: number;
    specularFactor: Vector4;
    PBRLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, TBN: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
    calculateMetallic(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp): PBShaderExp;
    calculateRoughness(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp): PBShaderExp;
    calculateSpecularFactor(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['metallicRoughness', 'occlusion', 'specular', 'specularColor']>;

// @public
export type IMixinPBRSpecularGlossiness = {
    specularFactor: Vector3;
    glossinessFactor: number;
    PBRLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, TBN: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['specular']>;

// @public
export interface IMixinVertexColor {
    // (undocumented)
    getVertexColor(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    vertexColor: boolean;
}

// @public
export interface IModKey {
    readonly altKey: boolean;
    readonly ctrlKey: boolean;
    readonly metaKey: boolean;
    readonly shiftKey: boolean;
}

// @public
export type InputEventHandler = (ev: Event, type?: string) => boolean;

// @public
export class InputManager {
    constructor(app: Application);
    // (undocumented)
    enableSystemContextMenu(enable: boolean): void;
    static log(ev: Event, type?: string): boolean;
    unuse(handler: InputEventHandler, ctx?: unknown): this;
    use(handler: Nullable<InputEventHandler>, ctx?: unknown): this;
    useFirst(handler: Nullable<InputEventHandler>, ctx?: unknown): this;
}

// @public
export class InstanceBindGroupAllocator {
    constructor();
    // (undocumented)
    allocateInstanceBindGroup(framestamp: number, sizeInFloats: number): CachedBindGroup;
    // (undocumented)
    _bindGroupList: CachedBindGroup[];
}

// @public
export interface InstanceData {
    // (undocumented)
    bindGroup: CachedBindGroup;
    // (undocumented)
    numInstances: number;
    // (undocumented)
    offset: number;
    // (undocumented)
    stride: number;
}

// @public
export type InstanceUniformType = 'float' | 'vec2' | 'vec3' | 'vec4' | 'rgb' | 'rgba';

// @public
export function interleavedGradientNoise(scope: PBInsideFunctionScope, c: PBShaderExp): PBShaderExp;

// @public
export class InvProjMatrixNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof InvProjMatrixNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class InvSqrtNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof InvSqrtNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class InvViewProjMatrixNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof InvViewProjMatrixNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export interface IRenderable extends IDisposable {
    // (undocumented)
    render(): void;
}

// @public
export interface IRenderHook {
    // (undocumented)
    afterRender?: (renderable: any) => void;
    // (undocumented)
    beforeRender?: (renderable: any) => boolean | void;
}

// @public
export interface IRUniformTexture {
    // (undocumented)
    magFilter: string;
    // (undocumented)
    minFilter: string;
    // (undocumented)
    mipFilter: string;
    // (undocumented)
    name: string;
    // (undocumented)
    sRGB: boolean;
    // (undocumented)
    texture: string;
    // (undocumented)
    type: string;
    // (undocumented)
    wrapS: string;
    // (undocumented)
    wrapT: string;
}

// @public
export interface IRUniformValue {
    // (undocumented)
    name: string;
    // (undocumented)
    type: string;
    // (undocumented)
    value: number[];
}

// Warning: (ae-forgotten-export) The symbol "LambertMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class LambertMaterial extends LambertMaterial_base implements Clonable<LambertMaterial> {
    constructor();
    // (undocumented)
    clone(): LambertMaterial;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// @public
export class LengthNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof LengthNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export const LIGHT_TYPE_DIRECTIONAL = 1;

// @public
export const LIGHT_TYPE_NONE = 0;

// @public
export const LIGHT_TYPE_POINT = 2;

// @public
export const LIGHT_TYPE_SPOT = 3;

// @public
export function linearToGamma(scope: PBInsideFunctionScope, color: PBShaderExp): PBShaderExp;

// @public
export class Log2Node extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof Log2Node;
        name: string;
        getProps(): never[];
    };
}

// @public
export class LogicallyAndNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof LogicallyAndNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class LogicallyOrNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof LogicallyOrNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export type LogMode = 'info' | 'warn' | 'error' | 'debug';

// @public
export class LogNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof LogNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class MakeVectorNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof MakeVectorNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class Material extends Disposable implements Clonable<Material>, IDisposable {
    constructor();
    apply(ctx: DrawContext): boolean;
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean, pass: number): void;
    protected _applyUniforms(_bindGroup: BindGroup, _ctx: DrawContext, _pass: number): void;
    get changeTag(): number;
    // (undocumented)
    clearCache(): void;
    clone(): Material;
    copyFrom(other: this): void;
    protected _createHash(): string;
    createInstance(): this;
    protected _createProgram(_pb: ProgramBuilder, _ctx: DrawContext, _pass: number): GPUProgram;
    drawPrimitive(pass: number, primitive: Primitive, ctx: DrawContext, numInstances: number): void;
    getQueueType(): number;
    get instanceId(): number;
    isBatchable(): boolean;
    isTransparentPass(_pass: number): boolean;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    get numPasses(): number;
    set numPasses(val: number);
    protected onDispose(): void;
    passToHash(pass: number): string;
    supportInstancing(): boolean;
    supportLighting(): boolean;
    protected updateRenderStates(_pass: number, _renderStates: RenderStateSet, _ctx: DrawContext): void;
}

// @public
export class MaterialBlueprintIR {
    constructor(dag: BlueprintDAG, hash: string, editorState: BluePrintEditorState);
    get behaviors(): MaterialBlueprintIRBehaviors;
    compile(): boolean;
    create(pb: ProgramBuilder): Nullable<{
        name: string;
        exp: PBShaderExp | number | boolean;
    }[]>;
    get DAG(): BlueprintDAG;
    set DAG(dag: BlueprintDAG);
    get editorState(): BluePrintEditorState;
    get hash(): string;
    get ok(): boolean;
    get uniformTextures(): IRUniformTexture[];
    get uniformValues(): IRUniformValue[];
}

// @public
export interface MaterialBlueprintIRBehaviors {
    useVertexColor: boolean;
    useVertexUV: boolean;
}

// @public
export interface MaterialTextureInfo {
    // (undocumented)
    sampler: Nullable<TextureSampler>;
    // (undocumented)
    texCoord: number;
    // (undocumented)
    texture: Nullable<Texture2D>;
    // (undocumented)
    transform: Nullable<Matrix4x4>;
}

// @public
export const enum MaterialVaryingFlags {
    // (undocumented)
    APPLY_FOG = 16,
    // (undocumented)
    INSTANCING = 4,
    // (undocumented)
    MORPH_ANIMATION = 1,
    // (undocumented)
    SKIN_ANIMATION = 2,
    // (undocumented)
    SSR_STORE_ROUGHNESS = 8
}

// @public
export const MAX_CLUSTERED_LIGHTS = 255;

// @public (undocumented)
export const MAX_GERSTNER_WAVE_COUNT = 16;

// @public (undocumented)
export const MAX_MORPH_ATTRIBUTES = 8;

// @public (undocumented)
export const MAX_MORPH_TARGETS = 256;

// @public (undocumented)
export const MAX_TERRAIN_MIPMAP_LEVELS = 64;

// @public
export class MaxNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof MaxNode;
        name: string;
        getProps(): never[];
    };
}

// Warning: (ae-forgotten-export) The symbol "Mesh_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Mesh extends Mesh_base implements BatchDrawable {
    constructor(scene: Scene, primitive?: Primitive, material?: MeshMaterial);
    get castShadow(): boolean;
    set castShadow(b: boolean);
    draw(ctx: DrawContext, renderQueue: Nullable<RenderQueue>, hash?: string): void;
    getAnimatedBoundingBox(): BoundingBox | null;
    getBoneMatrices(): Nullable<Texture2D<unknown>>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "getInstanceId"
    //
    // (undocumented)
    getInstanceId(_renderPass: RenderPass): string;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "getInstanceUniforms"
    //
    // (undocumented)
    getInstanceUniforms(): Float32Array<ArrayBuffer>;
    getMaterial(): Nullable<MeshMaterial>;
    getMorphData(): Nullable<MorphData>;
    getMorphInfo(): Nullable<MorphInfo>;
    getMorphTargetName(index: number): Nullable<string>;
    getMorphWeight(name: string): number;
    getName(): string;
    getNode(): this;
    getNumMorphTargets(): number;
    getPickTarget(): PickTarget;
    getPrimitive(): Nullable<Primitive>;
    getQueueType(): number;
    isBatchable(): this is BatchDrawable;
    isMesh(): this is Mesh;
    isUnlit(): boolean;
    get material(): Nullable<MeshMaterial>;
    set material(m: Nullable<MeshMaterial>);
    // (undocumented)
    set morphAnimation(val: boolean);
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    protected onDispose(): void;
    get primitive(): Nullable<Primitive>;
    set primitive(prim: Nullable<Primitive>);
    setAnimatedBoundingBox(bbox: Nullable<BoundingBox>): void;
    setBoneMatrices(matrices: Nullable<Texture2D>): void;
    setMorphData(data: Nullable<MorphData>): void;
    setMorphInfo(info: Nullable<MorphInfo>): void;
    setMorphWeight(name: string, weight: number): void;
    // (undocumented)
    setPickTarget(node: SceneNode, label?: string): void;
    setSkinnedBoundingInfo(info: Nullable<SkinnedBoundingBox>): void;
    // (undocumented)
    get skeletonName(): string;
    set skeletonName(name: string);
    // (undocumented)
    set skinAnimation(val: boolean);
    update(frameId: number, elapsedInSeconds: number, deltaInSeconds: number): void;
    updateMorphWeights(weight: number[]): void;
}

// @public
export class MeshMaterial extends Material implements Clonable<MeshMaterial> {
    constructor();
    get alphaCutoff(): number;
    set alphaCutoff(val: number);
    get alphaToCoverage(): boolean;
    set alphaToCoverage(val: boolean);
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    get blendMode(): BlendMode;
    set blendMode(val: BlendMode);
    clone(): MeshMaterial;
    copyFrom(other: this): void;
    createInstance(): this;
    get cullMode(): FaceMode;
    set cullMode(val: FaceMode);
    static defineFeature(): number;
    static defineInstanceUniform(prop: string, type: InstanceUniformType, name?: string): number;
    get drawContext(): DrawContext;
    featureUsed<T = unknown>(feature: number): T;
    fragmentShader(scope: PBFunctionScope): void;
    getInstancedUniform(scope: PBInsideFunctionScope, uniformIndex: number): PBShaderExp;
    getInstancedUniforms(): {
        prop: string;
        type: InstanceUniformType;
        offset: number;
        name: string;
    }[];
    getQueueType(): number;
    isTransparentPass(_pass: number): boolean;
    needFragmentColor(ctx?: DrawContext): boolean;
    get objectColor(): Immutable<Vector4>;
    set objectColor(val: Immutable<Vector4>);
    get opacity(): number;
    set opacity(val: number);
    outputFragmentColor(scope: PBInsideFunctionScope, worldPos: PBShaderExp, color: Nullable<PBShaderExp>, ssrRoughness?: PBShaderExp, ssrNormal?: PBShaderExp): void;
    get pass(): number;
    supportLighting(): boolean;
    get TAADisabled(): boolean;
    set TAADisabled(val: boolean);
    get TAAStrength(): number;
    set TAAStrength(val: number);
    uniformChanged(): void;
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    useFeature(feature: number, use: unknown): void;
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export interface Metadata {
    // (undocumented)
    [key: string]: string | number | boolean | null | Metadata | Array<string | number | boolean | null | undefined | Metadata>;
}

// @public
export class MinNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof MinNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export function mixinAlbedoColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinAlbedoColor);

// @public
export function mixinBlinnPhong<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinBlinnPhong);

// @public
export function mixinFoliage<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinFoliage);

// @public
export function mixinLambert<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinLambert);

// @public
export function mixinLight<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinLight);

// @public
export function mixinPBRBluePrint<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRBluePrint);

// @public
export function mixinPBRCommon<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRCommon);

// @public
export function mixinPBRMetallicRoughness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRMetallicRoughness);

// @public
export function mixinPBRSpecularGlossness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRSpecularGlossiness);

// @public
export function mixinTextureProps<U extends string>(name: U): <T extends typeof MeshMaterial>(BaseCls: T, vertex?: boolean) => T & (new (...args: any[]) => TextureProp<U> & TexturePropUniforms<U>);

// @public
export function mixinVertexColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinVertexColor);

// @public
export class MixNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof MixNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export type ModelFetchOptions = {
    mimeType?: string;
    dracoDecoderModule?: DecoderModule;
    enableInstancing?: boolean;
    postProcess?: (model: SharedModel) => SharedModel;
};

// @public
export type ModelInfo = {
    group: SceneNode;
    animationSet: AnimationSet;
};

// @public
export class ModNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ModNode;
        name: string;
        getProps(): never[];
    };
}

// @public (undocumented)
export const MORPH_ATTRIBUTE_VECTOR_COUNT: number;

// @public (undocumented)
export const MORPH_TARGET_COLOR = 3;

// @public (undocumented)
export const MORPH_TARGET_NORMAL = 1;

// @public (undocumented)
export const MORPH_TARGET_POSITION = 0;

// @public (undocumented)
export const MORPH_TARGET_TANGENT = 2;

// @public (undocumented)
export const MORPH_TARGET_TEX0 = 4;

// @public (undocumented)
export const MORPH_TARGET_TEX1 = 5;

// @public (undocumented)
export const MORPH_TARGET_TEX2 = 6;

// @public (undocumented)
export const MORPH_TARGET_TEX3 = 7;

// @public (undocumented)
export const MORPH_WEIGHTS_VECTOR_COUNT: number;

// @public
export type MorphData = {
    width: number;
    height: number;
    data: Float32Array<ArrayBuffer>;
    texture?: DRef<Texture2D>;
};

// @public
export type MorphInfo = {
    data: TypedArray;
    buffer?: DRef<GPUDataBuffer>;
    names: Record<string, number>;
};

// @public
export type MorphState = {
    numTargets: number;
    weights: Float32Array<ArrayBuffer>;
    boundingBox: BoundingBox;
};

// @public
export class MorphTargetTrack extends AnimationTrack<MorphState> {
    constructor();
    constructor(interpolator?: Interpolator, defaultMorphWeights?: number[], targetBox?: BoundingBox[], originBox?: AABB, embedded?: boolean);
    applyState(node: SceneNode, state: MorphState): void;
    // (undocumented)
    get boundingBox(): Nullable<BoundingBox[]>;
    set boundingBox(box: Nullable<BoundingBox[]>);
    calculateState(target: object, currentTime: number): MorphState;
    // (undocumented)
    get defaultWeights(): Nullable<number[]>;
    set defaultWeights(value: Nullable<number[]>);
    getBlendId(): string;
    getDuration(): number;
    // (undocumented)
    get interpolator(): Nullable<Interpolator>;
    set interpolator(interp: Nullable<Interpolator>);
    mixState(a: MorphState, b: MorphState, t: number): MorphState;
    // (undocumented)
    get originBoundingBox(): Nullable<AABB>;
    set originBoundingBox(box: Nullable<AABB>);
    reset(node: SceneNode): void;
}

// @public
export class NamedObject {
    constructor(name: string);
    // (undocumented)
    name: string;
}

// @public
export interface NodeConnection {
    // (undocumented)
    endSlotId: number;
    // (undocumented)
    startSlotId: number;
    // (undocumented)
    targetNodeId: number;
}

// @public
export class NodeEulerRotationTrack extends AnimationTrack<Quaternion> {
    constructor();
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[], embedded?: boolean);
    applyState(node: SceneNode, state: Quaternion): void;
    calculateState(target: object, currentTime: number): Quaternion;
    getBlendId(): string;
    getDuration(): number;
    // (undocumented)
    get interpolator(): Interpolator;
    set interpolator(interp: Interpolator);
    mixState(a: Quaternion, b: Quaternion, t: number): Quaternion;
}

// @public
export type NodeIterateFunc = ((node: SceneNode) => boolean) | ((node: SceneNode) => void);

// @public
export class NodeRotationTrack extends AnimationTrack<Quaternion> {
    constructor();
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Quaternion;
    }[], embedded?: boolean);
    applyState(node: SceneNode, state: Quaternion): void;
    calculateState(target: object, currentTime: number): Quaternion;
    getBlendId(): string;
    getDuration(): number;
    // (undocumented)
    get interpolator(): Interpolator;
    set interpolator(interp: Interpolator);
    mixState(a: Quaternion, b: Quaternion, t: number): Quaternion;
}

// @public
export class NodeScaleTrack extends AnimationTrack<Vector3> {
    constructor();
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[], embedded?: boolean);
    applyState(node: SceneNode, state: Vector3): void;
    calculateState(target: object, currentTime: number): Vector3;
    getBlendId(): string;
    getDuration(): number;
    // (undocumented)
    get interpolator(): Interpolator;
    set interpolator(interp: Interpolator);
    mixState(a: Vector3, b: Vector3, t: number): Vector3;
}

// @public
export class NodeTranslationTrack extends AnimationTrack<Vector3> {
    constructor();
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[], embedded?: boolean);
    applyState(node: SceneNode, state: Vector3): void;
    calculateState(target: object, currentTime: number): Vector3;
    getBlendId(): string;
    getDuration(): number;
    // (undocumented)
    get interpolator(): Interpolator;
    set interpolator(interp: Interpolator);
    mixState(a: Vector3, b: Vector3, t: number): Vector3;
}

// @public
export function noise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class NormalizeNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof NormalizeNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class NotEqualNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof NotEqualNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class Octree {
    constructor(scene: Scene, rootSize?: number, leafSize?: number, maxRootSize?: number);
    finalize(): void;
    getChunk(level: number): OctreeNodeChunk;
    getLeafSize(): number;
    getNumChunks(): number;
    getRootNode(): OctreeNode;
    getRootSize(): number;
    getScene(): Scene;
    initialize(rootSize: number, leafSize: number): void;
    locateNodeChain(candidate: Nullable<OctreeNode>, center: Vector3, radius: number): OctreeNode | null;
    placeNode(node: GraphNode): void;
    prune(): void;
    removeNode(node: GraphNode): void;
    resize(size: number): void;
}

// @public
export class OctreeNode {
    constructor();
    addNode(node: GraphNode): void;
    clearNodes(): void;
    createChildren(): void;
    getBox(): Nullable<AABB>;
    getBoxLoosed(): AABB;
    getChild(placement: OctreePlacement): OctreeNode | null;
    getChunk(): Nullable<OctreeNodeChunk>;
    getLevel(): number;
    getMaxPoint(): Vector3;
    getMaxPointLoosed(): Vector3;
    getMinPoint(): Vector3;
    getMinPointLoosed(): Vector3;
    getNodes(): GraphNode[];
    getOrCreateChild(placement: OctreePlacement): OctreeNode | null;
    getOrCreateParent(): OctreeNode | null;
    getParent(): OctreeNode | null;
    getPosition(): number;
    removeNode(node: GraphNode): void;
    setChunk(chunk: OctreeNodeChunk): void;
    setPosition(index: number): void;
    traverse(v: Visitor<OctreeNode>): void;
}

// @public
export class OctreeNodeChunk {
    constructor(octree: Octree);
    clearNodes(): void;
    empty(): boolean;
    getChildIndex(index: number, placement: OctreePlacement): number;
    getDimension(): number;
    getLevel(): number;
    getNext(): Nullable<OctreeNodeChunk>;
    getNode(index: number): OctreeNode | null;
    getNodeSize(): number;
    getOctree(): Octree;
    getOrCreateNode(index: number): OctreeNode;
    getOrCreateNodeChain(index: number): OctreeNode;
    getParentIndex(index: number): number;
    getPrev(): Nullable<OctreeNodeChunk>;
    getWorldSize(): number;
    setDimension(dimension: number): void;
    setLevel(level: number): void;
    setNext(chunk: OctreeNodeChunk): void;
    setNodeSize(size: number): void;
    setPrev(chunk: OctreeNodeChunk): void;
}

// @public
export enum OctreePlacement {
    // (undocumented)
    NNN = 7,
    // (undocumented)
    NNP = 6,
    // (undocumented)
    NPN = 5,
    // (undocumented)
    NPP = 4,
    // (undocumented)
    PNN = 3,
    // (undocumented)
    PNP = 2,
    // (undocumented)
    PPN = 1,
    // (undocumented)
    PPP = 0
}

// @public
export interface OIT extends IDisposable {
    applyUniforms(ctx: DrawContext, bindGroup: BindGroup): void;
    begin(ctx: DrawContext): number;
    beginPass(ctx: DrawContext, pass: number): boolean;
    calculateHash(): string;
    dispose(): void;
    readonly disposed: boolean;
    end(ctx: DrawContext): void;
    endPass(ctx: DrawContext, pass: number): void;
    getType(): string;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): void;
    setupFragmentOutput(scope: PBGlobalScope): void;
    supportDevice(deviceType: string): boolean;
    wantsPremultipliedAlpha(): boolean;
}

// @public
export class OrbitCameraController extends BaseCameraController {
    constructor(options?: Partial<OrbitCameraControllerOptions>);
    get center(): Immutable<Vector3>;
    set center(val: Immutable<Vector3>);
    // (undocumented)
    lookAt(from: Vector3, to: Vector3, up: Vector3): void;
    // @override
    protected _onMouseDown(evt: IControllerPointerDownEvent): boolean;
    // @override
    protected _onMouseMove(evt: IControllerPointerMoveEvent): boolean;
    // @override
    protected _onMouseUp(evt: IControllerPointerUpEvent): boolean;
    // @override
    protected _onMouseWheel(evt: IControllerWheelEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: OrbitCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface OrbitCameraControllerOptions {
    center: Vector3;
    // (undocumented)
    controls?: {
        rotate?: {
            button: number;
            shiftKey: boolean;
            ctrlKey: boolean;
            altKey: boolean;
            metaKey: boolean;
        };
        pan?: {
            button: number;
            shiftKey: boolean;
            ctrlKey: boolean;
            altKey: boolean;
            metaKey: boolean;
        };
        zoom?: {
            button: number;
            shiftKey: boolean;
            ctrlKey: boolean;
            altKey: boolean;
            metaKey: boolean;
        };
        zoomWheel?: boolean;
    };
    damping?: number;
    panSpeed?: number;
    rotateSpeed?: number;
    zoomSpeed?: number;
}

// @public
export class OrthoCamera extends Camera {
    constructor(scene: Nullable<Scene>, left?: number, right?: number, bottom?: number, top?: number, near?: number, far?: number);
    get bottom(): number;
    set bottom(val: number);
    get far(): number;
    set far(val: number);
    get left(): number;
    set left(val: number);
    get near(): number;
    set near(val: number);
    get right(): number;
    set right(val: number);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get top(): number;
    set top(val: number);
    get window(): Nullable<Immutable<number[]>>;
    set window(val: Nullable<Immutable<number[]>>);
}

// @public
export function panoramaToCubemap(tex: Texture2D, outputCubeMap: TextureCube): void;

// @public
export class ParticleMaterial extends MeshMaterial implements Clonable<ParticleMaterial> {
    constructor();
    get alphaMap(): _zephyr3d_base.Nullable<Texture2D<unknown>>;
    set alphaMap(tex: _zephyr3d_base.Nullable<Texture2D<unknown>>);
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    get aspect(): number;
    set aspect(val: number);
    clone(): ParticleMaterial;
    copyFrom(other: this): void;
    get directional(): boolean;
    set directional(b: boolean);
    fragmentShader(scope: PBFunctionScope): void;
    get jitterPower(): number;
    set jitterPower(val: number);
    get rampMap(): _zephyr3d_base.Nullable<Texture2D<unknown>>;
    set rampMap(tex: _zephyr3d_base.Nullable<Texture2D<unknown>>);
    supportInstancing(): boolean;
    vertexShader(scope: PBFunctionScope): void;
}

// Warning: (ae-forgotten-export) The symbol "ParticleSystem_base" needs to be exported by the entry point index.d.ts
//
// @public
export class ParticleSystem extends ParticleSystem_base implements Drawable {
    constructor(scene: Scene);
    get airResistence(): boolean;
    set airResistence(value: boolean);
    get aspect(): number;
    set aspect(value: number);
    get directional(): boolean;
    set directional(val: boolean);
    draw(ctx: DrawContext, renderQueue: Nullable<RenderQueue>): void;
    get emitCount(): number;
    set emitCount(value: number);
    get emitInterval(): number;
    set emitInterval(value: number);
    get emitterBehavior(): EmitterBehavior;
    set emitterBehavior(value: EmitterBehavior);
    get emitterConeRadiusMax(): number;
    set emitterConeRadiusMax(value: number);
    get emitterConeRadiusMin(): number;
    set emitterConeRadiusMin(value: number);
    get emitterShape(): EmitterShape;
    set emitterShape(value: EmitterShape);
    get emitterShapeSizeMax(): Vector3;
    set emitterShapeSizeMax(value: Vector3);
    get emitterShapeSizeMin(): Vector3;
    set emitterShapeSizeMin(value: Vector3);
    // (undocumented)
    set flags(value: number);
    getMaterial(): Nullable<ParticleMaterial>;
    getMorphData(): null;
    getMorphInfo(): null;
    getPickTarget(): PickTarget;
    getPrimitive(): Nullable<Primitive>;
    getQueueType(): number;
    get gravity(): Immutable<Vector3>;
    set gravity(value: Immutable<Vector3>);
    isParticleSystem(): this is ParticleSystem;
    isUnlit(): boolean;
    get jitterPower(): number;
    set jitterPower(value: number);
    get jitterSpeed(): number;
    set jitterSpeed(value: number);
    get material(): Nullable<ParticleMaterial>;
    set material(material: Nullable<ParticleMaterial>);
    get maxParticleCount(): number;
    set maxParticleCount(value: number);
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    // (undocumented)
    newParticle(num: number, worldMatrix: Matrix4x4): void;
    onDispose(): void;
    get particleAccelMax(): number;
    set particleAccelMax(value: number);
    get particleAccelMin(): number;
    set particleAccelMin(value: number);
    get particleLifeMax(): number;
    set particleLifeMax(value: number);
    get particleLifeMin(): number;
    set particleLifeMin(value: number);
    get particleRotationMax(): number;
    set particleRotationMax(value: number);
    get particleRotationMin(): number;
    set particleRotationMin(value: number);
    get particleSize1Max(): number;
    set particleSize1Max(value: number);
    get particleSize1Min(): number;
    set particleSize1Min(value: number);
    get particleSize2Max(): number;
    set particleSize2Max(value: number);
    get particleSize2Min(): number;
    set particleSize2Min(value: number);
    get particleVelocityMax(): number;
    set particleVelocityMax(value: number);
    get particleVelocityMin(): number;
    set particleVelocityMin(value: number);
    // (undocumented)
    resizeVertexBuffers(): void;
    get scalar(): number;
    set scalar(value: number);
    // (undocumented)
    update(_frameId: number, elapsedInSeconds: number, deltaInSeconds: number): void;
    get wind(): Immutable<Vector3>;
    set wind(value: Immutable<Vector3>);
    get worldSpace(): boolean;
    set worldSpace(value: boolean);
}

// @public
export class PBRBlockNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// Warning: (ae-forgotten-export) The symbol "PBRBluePrintMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class PBRBluePrintMaterial extends PBRBluePrintMaterial_base implements Clonable<PBRBluePrintMaterial> {
    constructor(irFrag?: MaterialBlueprintIR, irVertex?: MaterialBlueprintIR, uniformValues?: BluePrintUniformValue[], uniformTextures?: BluePrintUniformTexture[]);
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    clone(): PBRBluePrintMaterial;
    protected _createHash(): string;
    protected createProgram(ctx: DrawContext, pass: number): _zephyr3d_device.GPUProgram<unknown>;
    get fragmentIR(): MaterialBlueprintIR;
    set fragmentIR(ir: MaterialBlueprintIR);
    fragmentShader(scope: PBFunctionScope): void;
    protected onDispose(): void;
    get uniformTextures(): BluePrintUniformTexture[];
    set uniformTextures(val: BluePrintUniformTexture[]);
    get uniformValues(): BluePrintUniformValue[];
    set uniformValues(val: BluePrintUniformValue[]);
    get vertexIR(): MaterialBlueprintIR;
    set vertexIR(ir: MaterialBlueprintIR);
    vertexShader(scope: PBFunctionScope): void;
}

// Warning: (ae-forgotten-export) The symbol "PBRMetallicRoughnessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class PBRMetallicRoughnessMaterial extends PBRMetallicRoughnessMaterial_base implements Clonable<PBRMetallicRoughnessMaterial> {
    constructor();
    // (undocumented)
    clone(): PBRMetallicRoughnessMaterial;
    // (undocumented)
    copyFrom(other: this): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// Warning: (ae-forgotten-export) The symbol "PBRSpecularGlossinessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class PBRSpecularGlossinessMaterial extends PBRSpecularGlossinessMaterial_base implements Clonable<PBRSpecularGlossinessMaterial> {
    constructor();
    // (undocumented)
    clone(): PBRSpecularGlossinessMaterial;
    // (undocumented)
    copyFrom(other: this): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// @public
export function perlinNoise2D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class PerlinNoise2DNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof PerlinNoise2DNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export function perlinNoise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class PerspectiveCamera extends Camera {
    constructor(scene: Nullable<Scene>, fovY?: number, near?: number, far?: number, aspect?: number);
    adjustAspectRatio(): void;
    get aspect(): number;
    set aspect(val: number);
    get autoAspect(): boolean;
    set autoAspect(val: boolean);
    get far(): number;
    set far(val: number);
    get fovY(): number;
    set fovY(val: number);
    get near(): number;
    set near(val: number);
    render(scene: Scene): void;
    setOrtho(_left: number, _right: number, _bottom: number, _top: number, _near: number, _far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get window(): Nullable<Immutable<number[]>>;
    set window(val: Nullable<number[]>);
}

// @public
export type PickResult = {
    distance: number;
    intersectedPoint: Vector3;
    drawable: Drawable;
    target: PickTarget;
};

// @public
export type PickTarget = {
    node: SceneNode;
    label?: string;
};

// @public
export interface PlaneCreationOptions extends ShapeCreationOptions {
    anchor?: number;
    anchorX?: number;
    anchorY?: number;
    resolution?: number;
    resolutionX?: number;
    resolutionY?: number;
    size?: number;
    sizeX?: number;
    sizeY?: number;
    twoSided?: boolean;
}

// @public
export class PlaneShape extends Shape<PlaneCreationOptions> implements Clonable<PlaneShape> {
    constructor(options?: PlaneCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        size: number;
        resolution: number;
        twoSided: boolean;
        anchor: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    static generateData(opt: PlaneCreationOptions, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "triangle-list";
    get type(): "Plane";
}

// @public
export type PlayAnimationOptions = {
    repeat?: number;
    speedRatio?: number;
    fadeIn?: number;
    weight?: number;
};

// @public
export class PointLight extends PunctualLight {
    constructor(scene: Scene);
    // @override
    isPointLight(): this is PointLight;
    get range(): number;
    set range(val: number);
    setRange(val: number): this;
}

// @public
export type PointTransform = {
    scaleX: number;
    scaleY: number;
    offsetX: number;
    offsetY: number;
};

// @public
export enum PostEffectLayer {
    // (undocumented)
    end = 2,
    // (undocumented)
    opaque = 0,
    // (undocumented)
    transparent = 1
}

// @public
export class PowNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof PowNode;
        name: string;
        getProps(): never[];
    };
}

// Warning: (ae-forgotten-export) The symbol "DistributionType" needs to be exported by the entry point index.d.ts
//
// @public
export function prefilterCubemap(tex: TextureCube, type: DistributionType, destTexture: TextureCube | FrameBuffer, numSamples?: number, radianceSource?: boolean): void;

// Warning: (ae-forgotten-export) The symbol "Primitive_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Primitive extends Primitive_base implements Clonable<Primitive> {
    constructor();
    get changeTag(): number;
    clone(): Primitive;
    copyFrom(other: this): void;
    createAndSetIndexBuffer(data: Uint16Array<ArrayBuffer> | Uint32Array<ArrayBuffer>, dynamic?: boolean): IndexBuffer<unknown>;
    createAndSetVertexBuffer(format: VertexAttribFormat[] | VertexAttribFormat, data: TypedArray, stepMode?: VertexStepMode): StructuredBuffer<unknown>;
    draw(): void;
    drawInstanced(numInstances: number): void;
    getBoundingVolume(): Nullable<BoundingVolume>;
    getIndexBuffer(): IndexBuffer<unknown> | null;
    getNumFaces(): number;
    getNumVertices(): number;
    getVertexBuffer(semantic: VertexSemantic): StructuredBuffer<unknown> | null;
    getVertexBufferInfo(semantic: VertexSemantic): _zephyr3d_device.VertexBufferInfo | null;
    get indexCount(): number;
    set indexCount(val: number);
    get indexStart(): number;
    set indexStart(val: number);
    protected onDispose(): void;
    get primitiveType(): PrimitiveType;
    set primitiveType(type: PrimitiveType);
    raycast(ray: Ray): number | null;
    removeVertexBuffer(semantic: VertexSemantic): void;
    setBoundingVolume(bv: BoundingVolume): void;
    setIndexBuffer(buffer: Nullable<IndexBuffer>): void;
    setVertexBuffer(buffer: StructuredBuffer, stepMode?: VertexStepMode): StructuredBuffer<unknown>;
}

// @public
export class ProjectionMatrixNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ProjectionMatrixNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export type PropEdit = 'aabb' | 'quaternion' | 'proptrack';

// @public
export type PropertyAccessor<T = object, U extends string = ''> = {
    type: PropertyType;
    name: string;
    phase?: number;
    readonly?: boolean;
    default?: any;
    options?: PropertyAccessorOptions;
    get: <K extends string>(this: T, value: U extends '' ? Required<Pick<PropertyValue, PropertyToType<K>>> : RequireOptionals<PropertyValue>) => void;
    set?: <K extends string>(this: T, value: U extends '' ? Required<Pick<PropertyValue, PropertyToType<K>>> : RequireOptionals<PropertyValue>, index?: number) => void | Promise<void>;
    create?: (this: T, ctor: GenericConstructor, index: number) => Nullable<object>;
    delete?: (this: T, index: number) => void | Promise<void>;
    add?: <K extends string>(this: T, value: U extends '' ? Required<Pick<PropertyValue, PropertyToType<K>>> : RequireOptionals<PropertyValue>, index?: number) => void | Promise<void>;
    isValid?: (this: T) => boolean;
    isPersistent?: (this: T) => boolean;
    isNullable?: (this: T, index: number) => boolean;
    isHidden?: (this: T, index: number, obj?: unknown) => boolean;
    command?: (this: T, index: number) => boolean;
    getDefaultValue?: (this: T) => any;
};

// @public
export type PropertyAccessorOptions = {
    label?: string;
    group?: string;
    edit?: PropEdit;
    minValue?: number;
    maxValue?: number;
    speed?: number;
    animatable?: boolean;
    mimeTypes?: string[];
    objectTypes?: GenericConstructor[];
    enum?: {
        labels: string[];
        values: unknown[];
    };
};

// @public (undocumented)
export type PropertyToType<T extends string> = T extends 'float' | 'vec2' | 'vec3' | 'vec4' | 'int' | 'int2' | 'int3' | 'int4' | 'rgb' | 'rgba' ? 'num' : T extends 'bool' ? 'bool' : T extends 'string' ? 'str' : T extends 'object' | 'object_array' ? 'object' : 'num' | 'bool' | 'str' | 'object';

// @public
export class PropertyTrack extends AnimationTrack<number[]> {
    constructor(prop: PropertyAccessor, value?: number[], embedded?: boolean);
    applyState(target: object, state: number[]): void;
    calculateState(target: unknown, currentTime: number): number[];
    getBlendId(): PropertyAccessor;
    getDuration(): number;
    getProp(): PropertyAccessor;
    get interpolator(): Nullable<Interpolator>;
    set interpolator(interpolator: Nullable<Interpolator>);
    get interpolatorAlpha(): Nullable<Interpolator>;
    set interpolatorAlpha(interpolator: Nullable<Interpolator>);
    mixState(a: number[], b: number[], t: number): number[];
}

// @public
export type PropertyType = string;

// @public
export type PropertyValue = {
    num?: number[];
    str?: string[];
    bool?: boolean[];
    object?: Nullable<object>[];
};

// @public
export class PunctualLight extends BaseLight {
    constructor(scene: Scene, type: number);
    get castShadow(): boolean;
    set castShadow(b: boolean);
    get color(): Vector4;
    set color(color: Vector4);
    // @override
    isPunctualLight(): this is PunctualLight;
    setCastShadow(b: boolean): this;
    setColor(color: Vector4 | Vector3): this;
    get shadow(): ShadowMapper;
}

// @public
export const QUEUE_OPAQUE = 1;

// @public
export const QUEUE_TRANSPARENT = 2;

// @public
export class Radians2DegreesNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof Radians2DegreesNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class ReflectNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof ReflectNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class RefractNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof RefractNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export const RENDER_PASS_TYPE_DEPTH = 2;

// @public
export const RENDER_PASS_TYPE_LIGHT = 0;

// @public
export const RENDER_PASS_TYPE_OBJECT_COLOR = 3;

// @public
export const RENDER_PASS_TYPE_SHADOWMAP = 1;

// @public (undocumented)
export class RenderContext {
    constructor(_camera: Camera, w: number, h: number);
    // (undocumented)
    device: AbstractDevice;
    // (undocumented)
    renderHeight: number;
    // (undocumented)
    renderWidth: number;
}

// @public
export interface RenderItemList {
    // (undocumented)
    opaque: RenderItemListBundle;
    // (undocumented)
    transmission: RenderItemListBundle;
    // (undocumented)
    transmission_trans: RenderItemListBundle;
    // (undocumented)
    transparent: RenderItemListBundle;
}

// @public
export interface RenderItemListBundle {
    // (undocumented)
    lit: RenderItemListInfo[];
    // (undocumented)
    unlit: RenderItemListInfo[];
}

// @public
export interface RenderItemListInfo {
    // (undocumented)
    instanceItemList: RenderQueueItem[];
    // (undocumented)
    instanceList: Record<string, BatchDrawable[]>;
    // (undocumented)
    instanceRenderBundle?: RenderBundleWrapper;
    // (undocumented)
    itemList: RenderQueueItem[];
    // (undocumented)
    materialList: Set<Material>;
    // (undocumented)
    morphItemList: RenderQueueItem[];
    // (undocumented)
    morphRenderBundle?: RenderBundleWrapper;
    // Warning: (ae-forgotten-export) The symbol "RenderBundleWrapper" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    renderBundle?: RenderBundleWrapper;
    // (undocumented)
    renderQueue: RenderQueue;
    // (undocumented)
    skinAndMorphItemList: RenderQueueItem[];
    // (undocumented)
    skinAndMorphRenderBundle?: RenderBundleWrapper;
    // (undocumented)
    skinItemList: RenderQueueItem[];
    // (undocumented)
    skinRenderBundle?: RenderBundleWrapper;
}

// @public
export abstract class RenderPass extends Disposable {
    constructor(type: number);
    get clearColor(): Nullable<Immutable<Vector4>>;
    set clearColor(color: Nullable<Immutable<Vector4>>);
    get clearDepth(): Nullable<number>;
    set clearDepth(depth: Nullable<number>);
    get clearStencil(): Nullable<number>;
    set clearStencil(stencil: Nullable<number>);
    cullScene(ctx: DrawContext, cullCamera: Camera): RenderQueue;
    protected onDispose(): void;
    render(ctx: DrawContext, renderCamera?: Nullable<Camera>, cullCamera?: Nullable<Camera>, renderQueue?: RenderQueue): void;
    get type(): number;
}

// @public
export class RenderQueue extends Disposable {
    constructor(renderPass: RenderPass, bindGroupAllocator?: InstanceBindGroupAllocator);
    // (undocumented)
    binaryInsert(itemList: RenderQueueItem[], item: RenderQueueItem): void;
    get drawTransparent(): boolean;
    getInstanceInfo(drawable: Drawable): DrawableInstanceInfo | undefined;
    get itemList(): Nullable<RenderItemList>;
    protected onDispose(): void;
    push(camera: Camera, drawable: Drawable): void;
    pushLight(light: PunctualLight): void;
    pushRenderQueue(queue: RenderQueue): void;
    get ref(): RenderQueueRef;
    get renderPass(): RenderPass;
    reset(): void;
    get shadowedLights(): PunctualLight[];
    sortTransparentItems(cameraPos: Vector3): void;
    get sunLight(): Nullable<DirectionalLight>;
    set sunLight(light: Nullable<DirectionalLight>);
    get unshadowedLights(): PunctualLight[];
}

// @public
export interface RenderQueueItem {
    // (undocumented)
    drawable: Drawable;
    // (undocumented)
    instanceColor?: Vector4;
    // (undocumented)
    instanceData: Nullable<InstanceData>;
    // (undocumented)
    sortDistance: number;
}

// @public
export interface RenderQueueRef {
    // (undocumented)
    ref: RenderQueue;
}

// @public (undocumented)
export abstract class RenderTarget {
    // (undocumented)
    abstract calcOrthographicProjection(nearClip: number, farClip: number, outMatrix?: Matrix4x4): Matrix4x4;
    // (undocumented)
    abstract calcPerspectiveProjection(fov: number, nearClip: number, farClip: number, outMatrix?: Matrix4x4): Matrix4x4;
    // (undocumented)
    abstract calcRelativeViewport(outViewport?: Nullable<number[]>): number[];
    // (undocumented)
    abstract calcViewport(outViewport?: Nullable<number[]>): number[];
    // (undocumented)
    abstract getVersion(): number;
}

// @public
export type ResolutionTransform = {
    viewportX: number;
    viewportY: number;
    viewportWidth: number;
    viewportHeight: number;
    croppedViewport: Rect;
    canvasToViewport: PointTransform;
    canvasToLogic: PointTransform;
};

// @public
export class ResolveVertexNormalNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ResolveVertexNormalNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class ResolveVertexPositionNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ResolveVertexPositionNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class ResolveVertexTangentNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ResolveVertexTangentNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class ResourceManager {
    constructor(vfs: VFS, editorMode?: boolean);
    get assetManager(): AssetManager;
    clearCache(): void;
    // (undocumented)
    createBluePrintDAG(nodeMap: Record<number, IGraphNode>, roots: number[], links: {
        startNodeId: number;
        startSlotId: number;
        endNodeId: number;
        endSlotId: number;
    }[]): BlueprintDAG;
    deserializeObject<T extends object>(ctx: any, json: Record<string, unknown>): Promise<Nullable<T>>;
    deserializeObjectProps(obj: any, json: any, info?: SerializableClass): Promise<void>;
    get editorMode(): boolean;
    fetchBinary(id: string): Promise<Nullable<ArrayBuffer>>;
    fetchMaterial<T extends Material = MeshMaterial>(id: string): Promise<Nullable<T>>;
    fetchModel(id: string, scene: Scene, options?: ModelFetchOptions): Promise<{
        group: SceneNode;
        animationSet: AnimationSet;
    }>;
    fetchPrimitive<T extends Primitive = Primitive>(id: string): Promise<Nullable<T>>;
    fetchTexture<T extends Texture2D | TextureCube | Texture2DArray>(id: string, options?: TextureFetchOptions<T>): Promise<T>;
    findAnimationTarget(node: SceneNode, track: PropertyTrack): object | null;
    getAssetId(asset: unknown): string | null;
    getClassByConstructor(ctor: GenericConstructor): SerializableClass | null;
    getClassByName(className: string): SerializableClass | null;
    getClassByObject(obj: object): SerializableClass | null;
    getClassByProperty(prop: PropertyAccessor): Nullable<SerializableClass>;
    getClasses(): SerializableClass[];
    getPropertiesByClass(cls: SerializableClass): PropertyAccessor[] | null;
    getPropertyByClass(cls: SerializableClass, name: string): PropertyAccessor | null;
    getPropertyByName(name: string): PropertyAccessor;
    getPropertyName(prop: PropertyAccessor): string | null;
    instantiatePrefab(parent: SceneNode, path: string): Promise<Nullable<SceneNode>>;
    invalidateBluePrint(path: string): void;
    // (undocumented)
    loadBluePrint(path: string): Promise<Record<string, MaterialBlueprintIR> | null>;
    loadPrefabContent(path: string): Promise<Nullable<{
        type: string;
        data: object;
    }>>;
    loadScene(filename: string): Promise<Nullable<Scene>>;
    loadTextureFromBuffer<T extends BaseTexture>(arrayBuffer: ArrayBuffer | TypedArray, mimeType: string, srgb?: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture): Promise<T>;
    registerClass(cls: SerializableClass): void;
    reloadBluePrintMaterials(filter?: (m: PBRBluePrintMaterial) => boolean): Promise<void>;
    saveScene(scene: Scene, filename: string): Promise<void>;
    serializeObject(obj: any, json?: any, asyncTasks?: Nullable<Promise<unknown>[]>): Promise<any>;
    serializeObjectProps(obj: any, json?: any, asyncTasks?: Nullable<Promise<unknown>[]>, info?: SerializableClass): Promise<any>;
    setAssetId(asset: unknown, id?: Nullable<string>): void;
    get VFS(): VFS;
    set VFS(vfs: VFS);
}

// @public
export class RuntimeScript<T extends IDisposable | null> {
    onAttached(_host: Nullable<T>): void | Promise<void>;
    onCreated(): void | Promise<void>;
    onDestroy(): void;
    onDetached(_host: T): void;
    onUpdate(_deltaTime: number, _elapsedTime: number): void;
}

// @public
export type SamplerType = 'clamp_linear' | 'clamp_linear_nomip' | 'clamp_nearest' | 'clamp_nearest_nomip' | 'repeat_linear' | 'repeat_linear_nomip' | 'repeat_nearest' | 'repeat_nearest_nomip';

// @public
export class SAO extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get bias(): number;
    set bias(val: number);
    get blurDepthCutoff(): number;
    set blurDepthCutoff(val: number);
    get blurKernelSize(): number;
    set blurKernelSize(val: number);
    get blurStdDev(): number;
    set blurStdDev(val: number);
    get intensity(): number;
    set intensity(val: number);
    get minResolution(): number;
    set minResolution(val: number);
    get radius(): number;
    set radius(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get scale(): number;
    set scale(val: number);
}

// @public
export class SaturateNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof SaturateNode;
        name: string;
        getProps(): never[];
    };
}

// Warning: (ae-forgotten-export) The symbol "Scene_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Scene extends Scene_base implements IRenderable {
    constructor(name?: string);
    get boundingBox(): _zephyr3d_base.AABB;
    constructRay(camera: Camera, viewportWidth: number, viewportHeight: number, screenX: number, screenY: number, invModelMatrix?: Matrix4x4): Ray;
    get env(): Environment;
    findNodeById<T extends SceneNode>(id: string): T;
    findNodeByName<T extends SceneNode>(name: string): Nullable<T>;
    frameUpdate(): void;
    frameUpdatePerCamera(camera: Camera): void;
    get id(): number;
    get mainCamera(): Nullable<Camera>;
    set mainCamera(camera: Nullable<Camera>);
    get metaData(): Nullable<Metadata_2>;
    set metaData(val: Nullable<Metadata_2>);
    get name(): string;
    set name(val: string);
    get octree(): Octree;
    protected onDispose(): void;
    queuePerCameraUpdateNode(node: SceneNode): void;
    queueUpdateNode(node: SceneNode): void;
    raycast(ray: Ray, length?: number): {
        target: PickTarget;
        dist: number;
        point: Vector3;
    } | null;
    render(): void;
    get rootNode(): SceneNode;
    get script(): string;
    set script(fileName: string);
    updateNodePlacement(octree: Octree, list: Set<GraphNode>): void;
}

// Warning: (ae-forgotten-export) The symbol "SceneNode_base" needs to be exported by the entry point index.d.ts
//
// @public
export class SceneNode extends SceneNode_base implements IDisposable {
    constructor(scene: Nullable<Scene>);
    get animationSet(): AnimationSet;
    get attached(): boolean;
    static readonly BBOXDRAW_DISABLED = 0;
    static readonly BBOXDRAW_INHERITED = -1;
    static readonly BBOXDRAW_LOCAL = 1;
    static readonly BBOXDRAW_WORLD = 2;
    get boundingBoxDrawMode(): number;
    set boundingBoxDrawMode(mode: number);
    calculateLocalTransform(outMatrix: Matrix4x4): void;
    calculateWorldTransform(outMatrix: Matrix4x4): void;
    get children(): DRef<SceneNode>[];
    get clipTestEnabled(): boolean;
    set clipTestEnabled(val: boolean);
    clone(): Promise<this>;
    computeBoundingVolume(): Nullable<BoundingVolume>;
    get computedBoundingBoxDrawMode(): number;
    computeWorldBoundingVolume(localBV: Nullable<BoundingVolume>): Nullable<BoundingVolume>;
    findNodeById<T extends SceneNode>(id: string): T;
    findNodeByName<T extends SceneNode>(name: string): Nullable<T>;
    findSkeletonById(id: string): Skeleton | null;
    getBoundingVolume(): Nullable<BoundingVolume>;
    getPrefabNode(): Nullable<SceneNode>;
    getWorldBoundingVolume(): Nullable<BoundingVolume>;
    getWorldPosition(outPos?: Vector3): Vector3;
    get gpuPickable(): boolean;
    set gpuPickable(val: boolean);
    hasChild(child: SceneNode): boolean;
    get hidden(): boolean;
    invalidateBoundingVolume(): void;
    invalidateWorldBoundingVolume(transformChanged: boolean): void;
    get invWorldMatrix(): Immutable<Matrix4x4>;
    isBatchGroup(): this is BatchGroup;
    isCamera(): this is Camera;
    isClipmapTerrain(): this is ClipmapTerrain;
    isGraphNode(): this is GraphNode;
    isLight(): this is BaseLight;
    isMesh(): this is Mesh;
    isParentOf(child: Nullable<SceneNode>): boolean;
    isParticleSystem(): this is ParticleSystem;
    isPunctualLight(): this is PunctualLight;
    isSprite(): this is Sprite;
    isWater(): this is Water;
    iterate(callback: NodeIterateFunc): boolean;
    iterateBottomToTop(callback: NodeIterateFunc): boolean;
    get jointTypeR(): "none" | "animated" | "static";
    set jointTypeR(val: 'none' | 'animated' | 'static');
    get jointTypeS(): "none" | "animated" | "static";
    set jointTypeS(val: 'none' | 'animated' | 'static');
    get jointTypeT(): "none" | "animated" | "static";
    set jointTypeT(val: 'none' | 'animated' | 'static');
    get localMatrix(): Immutable<Matrix4x4>;
    set localMatrix(matrix: Immutable<Matrix4x4>);
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    get metaData(): Nullable<Metadata_2>;
    set metaData(val: Nullable<Metadata_2>);
    moveBy(delta: Vector3): this;
    get name(): string;
    set name(val: string);
    protected _onAttached(): void;
    protected _onDetached(): void;
    protected onDispose(): void;
    protected onPostClone(): void | Promise<void>;
    otherToThis(other: SceneNode, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    otherToThis(other: SceneNode, v: Vector4, result?: Vector4): Vector4;
    get parent(): Nullable<SceneNode>;
    set parent(p: Nullable<SceneNode>);
    get persistentId(): string;
    set persistentId(id: string);
    get pickable(): boolean;
    set pickable(val: boolean);
    get placeToOctree(): boolean;
    set placeToOctree(val: boolean);
    get position(): Vector3;
    set position(val: Vector3);
    get prefabId(): string;
    set prefabId(id: string);
    remove(): this;
    removeChildren(): void;
    reparent(p?: Nullable<SceneNode>): this;
    get rotation(): Quaternion;
    set rotation(val: Quaternion);
    get runtimeId(): number;
    get scale(): Vector3;
    set scale(val: Vector3);
    scaleBy(factor: Vector3): this;
    get scene(): Nullable<Scene>;
    get script(): string;
    set script(fileName: string);
    get sealed(): boolean;
    set sealed(val: boolean);
    setBoundingVolume(bv: BoundingVolume): void;
    setLocalTransform(matrix: Matrix4x4): this;
    get sharedModel(): Nullable<SharedModel>;
    set sharedModel(model: Nullable<SharedModel>);
    get showState(): SceneNodeVisible;
    set showState(val: SceneNodeVisible);
    thisToOther(other: SceneNode, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToOther(other: SceneNode, v: Vector4, result?: Vector4): Vector4;
    thisToWorld(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToWorld(v: Vector4, result?: Vector4): Vector4;
    traverse(v: Visitor<SceneNode>): void;
    update(frameId: number, elapsedInSeconds: number, deltaInSeconds: number): void;
    updatePerCamera(_camera: Camera, _elapsedInSeconds: number, _deltaInSeconds: number): void;
    get worldMatrix(): Immutable<Matrix4x4>;
    get worldMatrixDet(): number;
    worldToThis(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    worldToThis(v: Vector4, result?: Vector4): Vector4;
}

// @public
export type SceneNodeVisible = 'visible' | 'inherit' | 'hidden';

// @public
export class ScreenAdapter {
    constructor(config?: Immutable<ScreenConfig>);
    calculateResolutionTransform(viewportX: number, viewportY: number, viewportWidth: number, viewportHeight: number): {
        viewportX: number;
        viewportY: number;
        viewportWidth: number;
        viewportHeight: number;
        croppedViewport: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        canvasToViewport: {
            scaleX: number;
            scaleY: number;
            offsetX: number;
            offsetY: number;
        };
        canvasToLogic: {
            scaleX: number;
            scaleY: number;
            offsetX: number;
            offsetY: number;
        };
    };
    canvasPosToLogic(canvasPos: Vector2, logicPosOut?: Vector2): Vector2;
    canvasPosToViewport(canvasPos: Vector2, viewportPosOut?: Vector2): Vector2;
    get config(): Immutable<ScreenConfig>;
    set config(config: Immutable<ScreenConfig>);
    resolveViewport(): void;
    get transform(): Immutable<ResolutionTransform>;
    transformPoint(transform: PointTransform, pointIn: Vector2, pointOut?: Vector2): Vector2;
    get version(): number;
    get viewport(): Nullable<Immutable<number[]>>;
    set viewport(vp: Nullable<Immutable<number[]>>);
}

// @public
export type ScreenConfig = {
    designWidth: number;
    designHeight: number;
    scaleMode: ScreenScaleMode;
};

// @public (undocumented)
export class ScreenRenderTarget extends RenderTarget {
    constructor(screenAdapter?: ScreenAdapter);
    // (undocumented)
    calcOrthographicProjection(nearClip: number, farClip: number, outMatrix?: Matrix4x4): Matrix4x4;
    // (undocumented)
    calcPerspectiveProjection(fov: number, nearClip: number, farClip: number, outMatrix?: Matrix4x4): Matrix4x4;
    // (undocumented)
    calcRelativeViewport(outViewport?: Nullable<number[]>): number[];
    // (undocumented)
    calcViewport(outViewport?: Nullable<number[]>): number[];
    // (undocumented)
    getVersion(): number;
}

// @public
export type ScreenScaleMode = 'fit' | 'fit-width' | 'fit-height' | 'cover' | 'stretch';

// @public
export class ScriptingSystem {
    constructor(opts?: ScriptingSystemOptions);
    attachScript<T extends Host>(host: Nullable<T>, module: string): Promise<Nullable<RuntimeScript<T>>>;
    detachAllScripts(): void;
    detachScript<T extends Host>(host: T, idOrInstance?: string | RuntimeScript<T>): void;
    getScriptObjects<T extends RuntimeScript<any>>(host: unknown): T[];
    get registry(): ScriptRegistry;
    update(deltaTime: number, elapsedTime: number): void;
}

// @public
export type ScriptingSystemOptions = {
    VFS?: VFS;
    scriptsRoot?: string;
    importComment?: string;
    onLoadError?: (e: unknown, id: string) => void;
};

// @public
export class ScriptRegistry {
    constructor(vfs: VFS, scriptsRoot: string);
    protected fetchSource(id: string): Promise<{
        code: string;
        type: "js" | "ts";
        path: string;
    } | undefined>;
    getDependencies(entryId: string, fromId: string, dependencies: Record<string, string>): Promise<void>;
    resolveLogicalId(spec: string, fromId?: string): Promise<string>;
    resolveRuntimeUrl(entryId: string): Promise<string>;
    resolveSourcePath(logicalId: string): Promise<{
        type: "js" | "ts";
        path: string;
    } | null>;
    get scriptsRoot(): string;
    set scriptsRoot(path: string);
    get VFS(): VFS;
    set VFS(vfs: VFS);
}

// @public
export class SelectionNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof SelectionNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export type SerializableClass = {
    ctor: GenericConstructor;
    parent?: GenericConstructor;
    noTitle?: boolean;
    name: string;
    createFunc?: (ctx?: any, init?: any) => {
        obj: any;
        loadProps?: boolean;
    } | Promise<{
        obj: any;
        loadProps?: boolean;
    }>;
    getInitParams?: (obj: any, flags: {
        saveProps: boolean;
    }) => any;
    getProps: () => PropertyAccessor<any>[];
};

// @public
export class ShaderHelper {
    // (undocumented)
    static applyFog(scope: PBInsideFunctionScope, worldPos: PBShaderExp, color: PBShaderExp, ctx: DrawContext): void;
    // (undocumented)
    static readonly BILLBOARD_SPHERICAL = 1;
    // (undocumented)
    static readonly BILLBOARD_SYLINDRAL = 2;
    // (undocumented)
    static calculateMorphDelta(scope: PBInsideFunctionScope, attrib: number): PBShaderExp;
    static calculateShadow(scope: PBInsideFunctionScope, worldPos: PBShaderExp, NoL: PBShaderExp, ctx: DrawContext): PBShaderExp;
    static calculateSkinMatrix(scope: PBInsideFunctionScope): PBShaderExp | null;
    static encodeColorOutput(scope: PBInsideFunctionScope, outputColor: PBShaderExp): PBShaderExp;
    static getAerialPerspectiveLUT(scope: PBInsideFunctionScope): PBShaderExp;
    static getAtmosphereParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getBakedSkyTexture(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getBoneInvBindMatrixUniformName(): string;
    // (undocumented)
    static getBoneMatricesUniformName(): string;
    // (undocumented)
    static getBoneTextureSizeUniformName(): string;
    static getCameraClipPlane(scope: PBInsideFunctionScope): any;
    static getCameraClipPlaneFlag(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraPosition(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraRoughnessFactor(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getDrawableBindGroupLayout(skinning: boolean, morphing: boolean, instancing: boolean): BindGroupLayout;
    static getElapsedTime(scope: PBInsideFunctionScope): PBShaderExp;
    static getElapsedTimeFrame(scope: PBInsideFunctionScope): PBShaderExp;
    static getEnvLightStrength(scope: PBInsideFunctionScope): PBShaderExp;
    static getFramestamp(scope: PBInsideFunctionScope): PBShaderExp;
    static getHiZDepthTexture(scope: PBInsideFunctionScope): PBShaderExp;
    static getHiZDepthTextureMipLevelCount(scope: PBInsideFunctionScope): PBShaderExp;
    static getHiZDepthTextureSize(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getInstanceDataOffsetUniformName(): string;
    // (undocumented)
    static getInstanceDataStrideUniformName(): string;
    // (undocumented)
    static getInstanceDataUniformName(): string;
    static getInstancedUniform(scope: PBInsideFunctionScope, uniformIndex: number | PBShaderExp): PBShaderExp;
    static getInvProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getInvViewMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getInvViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getJitteredInvVPMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getLightBufferUniformName(): string;
    static getLinearDepthTexture(scope: PBInsideFunctionScope): PBShaderExp;
    static getLinearDepthTextureSize(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getMorphDataUniformName(): string;
    // (undocumented)
    static getMorphInfoUniformName(): string;
    static getNormalMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getObjectColorUniformName(): string;
    static getPrevUnjitteredViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getPrevWorldMatrix(scope: PBInsideFunctionScope): any;
    // (undocumented)
    static getPrevWorldMatrixFrameUniformName(): string;
    // (undocumented)
    static getPrevWorldMatrixUniformName(): string;
    static getProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getProjectionMatrixJitterValue(scope: PBInsideFunctionScope): PBShaderExp;
    static getRenderSize(scope: PBInsideFunctionScope): PBShaderExp;
    static getSceneColorTexture(scope: PBInsideFunctionScope): PBShaderExp;
    static getSceneColorTextureSize(scope: PBInsideFunctionScope): PBShaderExp;
    static getShadowMap(scope: PBInsideFunctionScope): PBShaderExp;
    static getUnjitteredViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getWorldMatrixUniformName(): string;
    static hasMorphing(scope: PBInsideFunctionScope): boolean;
    static hasSkinning(scope: PBInsideFunctionScope): boolean;
    static linearDepthToNonLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    // (undocumented)
    static readonly MATERIAL_INSTANCE_DATA_OFFSET = 9;
    static nonLinearDepthToLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    static nonLinearDepthToLinearNormalized(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    static prepareFragmentShader(pb: ProgramBuilder, ctx: DrawContext): void;
    static prepareVertexShader(pb: ProgramBuilder, ctx: DrawContext): void;
    static resolveMotionVector(scope: PBInsideFunctionScope, worldPos: PBShaderExp, prevWorldPos: PBShaderExp): void;
    static resolveVertexNormal(scope: PBInsideFunctionScope, normal?: PBShaderExp): PBShaderExp;
    static resolveVertexPosition(scope: PBInsideFunctionScope): PBShaderExp;
    static resolveVertexTangent(scope: PBInsideFunctionScope, tangent?: PBShaderExp): PBShaderExp;
    static sampleLinearDepth(scope: PBInsideFunctionScope, tex: PBShaderExp, uv: PBShaderExp, level: PBShaderExp | number): PBShaderExp;
    static sampleLinearDepthWithBackface(scope: PBInsideFunctionScope, tex: PBShaderExp, uv: PBShaderExp, level: PBShaderExp | number): PBShaderExp;
    // (undocumented)
    static samplePositionFromDepth(scope: PBInsideFunctionScope, depthTex: PBShaderExp, uv: PBShaderExp, mat: PBShaderExp, cameraNearFar: PBShaderExp): PBShaderExp;
    static setClipSpacePosition(scope: PBInsideFunctionScope, pos: PBShaderExp): void;
    static vertexShaderDrawableStuff(scope: PBGlobalScope, skinning: boolean, morphing: boolean, instanced: boolean): void;
}

// @public
export class ShadowMapPass extends RenderPass {
    constructor();
    get light(): Nullable<PunctualLight>;
    set light(light: Nullable<PunctualLight>);
}

// @public
export class ShadowMapper {
    constructor(light: PunctualLight);
    // (undocumented)
    copyFrom(other: ShadowMapper): void;
    get depthBias(): number;
    set depthBias(val: number);
    get esmBlur(): boolean;
    set esmBlur(val: boolean);
    get esmBlurKernelSize(): number;
    set esmBlurKernelSize(val: number);
    get esmBlurRadius(): number;
    set esmBlurRadius(val: number);
    get esmDepthScale(): number;
    set esmDepthScale(val: number);
    get light(): PunctualLight;
    get mode(): ShadowMode;
    set mode(mode: ShadowMode);
    get nearClip(): number;
    set nearClip(val: number);
    get normalBias(): number;
    set normalBias(val: number);
    get numShadowCascades(): number;
    set numShadowCascades(num: number);
    get pcfKernelSize(): number;
    set pcfKernelSize(val: number);
    get pdSampleCount(): number;
    set pdSampleCount(val: number);
    get pdSampleRadius(): number;
    set pdSampleRadius(val: number);
    get shadowDistance(): number;
    set shadowDistance(val: number);
    get shadowMapSize(): number;
    set shadowMapSize(num: number);
    get shadowRegion(): Nullable<AABB>;
    set shadowRegion(region: Nullable<AABB>);
    get splitLambda(): number;
    set splitLambda(val: number);
    get vsmBlurKernelSize(): number;
    set vsmBlurKernelSize(val: number);
    get vsmBlurRadius(): number;
    set vsmBlurRadius(val: number);
    get vsmDarkness(): number;
    set vsmDarkness(val: number);
}

// @public
export type ShadowMode = 'hard' | 'vsm' | 'esm' | 'pcf-pd' | 'pcf-opt';

// @public
export abstract class Shape<T extends ShapeCreationOptions = ShapeCreationOptions> extends Primitive implements Clonable<Shape<T>> {
    constructor(options?: T);
    // (undocumented)
    abstract clone(): this;
    // (undocumented)
    protected static computeTangent(v0: number[], v1: number[], v2: number[], uv0: number[], uv1: number[], uv2: number[], normal: number[]): number[];
    // (undocumented)
    static _defaultOptions: {
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    normalizeOptions(options?: T): DeepRequireOptionals<T>;
    get options(): DeepRequireOptionals<T>;
    set options(options: T);
    // (undocumented)
    protected _options: DeepRequireOptionals<T>;
    abstract get type(): string;
}

// @public
export interface ShapeCreationOptions {
    needNormal?: boolean;
    needTangent?: boolean;
    needUV?: boolean;
    transform?: Nullable<Matrix4x4>;
}

// @public
export type ShapeOptionType<ST extends ShapeType> = ST extends Shape<infer U> ? U : never;

// @public
export type ShapeType = BoxShape | BoxFrameShape | SphereShape | CylinderShape | PlaneShape | TorusShape | TetrahedronShape | TetrahedronFrameShape;

// @public
export class SharedModel extends Disposable {
    constructor(name?: string);
    get activeScene(): number;
    set activeScene(val: number);
    addAnimation(animation: AssetAnimationData): void;
    addNode(parent: Nullable<AssetHierarchyNode>, index: number, name: string): AssetHierarchyNode;
    addSkeleton(skeleton: AssetSkeleton): void;
    get animations(): AssetAnimationData[];
    // (undocumented)
    createSceneNode(scene: Scene, instancing: boolean): SceneNode;
    get name(): string;
    set name(val: string);
    get nodes(): AssetHierarchyNode[];
    // (undocumented)
    protected onDispose(): void;
    get scenes(): AssetScene[];
    get skeletons(): AssetSkeleton[];
}

// @public
export class SignNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof SignNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class SimplexNoise2DNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof SimplexNoise2DNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class SinHNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof SinHNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class SinNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof SinNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class Skeleton extends Disposable {
    constructor(joints: SceneNode[], inverseBindMatrices: Matrix4x4[], bindPoseMatrices: Matrix4x4[], jointTransforms?: {
        scale: Vector3;
        rotation: Quaternion;
        position: Vector3;
    }[]);
    getBoundingInfo(data: {
        positions: Float32Array;
        blendIndices: TypedArray;
        weights: TypedArray;
    }): SkinnedBoundingBox;
    get jointTexture(): Texture2D<unknown>;
    protected onDispose(): void;
    // (undocumented)
    set persistentId(val: string);
    // (undocumented)
    set playing(b: boolean);
}

// @public
export interface SkinnedBoundingBox {
    boundingBox: BoundingBox;
    boundingVertexBlendIndices: Float32Array;
    boundingVertexJointWeights: Float32Array;
    boundingVertices: Vector3[];
}

// @public
export class SkyEnvTextureNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof SkyEnvTextureNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class SkyRenderer extends Disposable {
    constructor();
    // (undocumented)
    set aerialPerspectiveDebug(val: number);
    get aerialPerspectiveDistance(): number;
    set aerialPerspectiveDistance(val: number);
    get atmosphereExposure(): number;
    set atmosphereExposure(val: number);
    get cameraHeightScale(): number;
    set cameraHeightScale(val: number);
    get cloudIntensity(): number;
    set cloudIntensity(val: number);
    get cloudy(): number;
    set cloudy(val: number);
    get envTextureFormat(): TextureFormat;
    get fogType(): FogType;
    set fogType(val: FogType);
    getBakedSkyTexture(ctx: DrawContext): TextureCube<unknown>;
    get heightFogAtmosphereContribution(): number;
    set heightFogAtmosphereContribution(val: number);
    get heightFogColor(): Immutable<Vector3>;
    set heightFogColor(val: Immutable<Vector3>);
    get heightFogDensity(): number;
    set heightFogDensity(val: number);
    get heightFogDirColor(): Immutable<Vector3>;
    set heightFogDirColor(val: Immutable<Vector3>);
    get heightFogDirExponent(): number;
    set heightFogDirExponent(val: number);
    get heightFogEndDistance(): number;
    set heightFogEndDistance(val: number);
    get heightFogFalloff(): number;
    set heightFogFalloff(val: number);
    get heightFogMaxOpacity(): number;
    set heightFogMaxOpacity(val: number);
    get heightFogStartDistance(): number;
    set heightFogStartDistance(val: number);
    get heightFogStartHeight(): number;
    set heightFogStartHeight(val: number);
    invalidate(): void;
    get irradianceConvSamples(): number;
    set irradianceConvSamples(val: number);
    get irradianceSH(): GPUDataBuffer<unknown>;
    get irradianceSHFB(): FrameBuffer<unknown>;
    protected onDispose(): void;
    // (undocumented)
    set panoramaTextureAsset(id: string);
    get radianceConvSamples(): number;
    set radianceConvSamples(val: number);
    get radianceMap(): TextureCube<unknown>;
    // (undocumented)
    renderAtmosphereLUTs(ctx: DrawContext): void;
    // (undocumented)
    renderSkyDistantLut(ctx: DrawContext, skybox: TextureCube): void;
    // (undocumented)
    renderUberFog(camera: Camera, depthTexture: Nullable<BaseTexture>): void;
    get shWindowWeights(): Immutable<Vector3>;
    set shWindowWeights(weights: Immutable<Vector3>);
    get skyboxTexture(): Nullable<TextureCube<unknown>>;
    set skyboxTexture(tex: Nullable<TextureCube<unknown>>);
    // (undocumented)
    set skyboxTextureSize(size: number);
    get skyColor(): Immutable<Vector4>;
    set skyColor(val: Immutable<Vector4>);
    get skyImage(): Nullable<Texture2D<unknown>>;
    set skyImage(texture: Nullable<Texture2D<unknown>>);
    get skyType(): SkyType;
    set skyType(val: SkyType);
    // (undocumented)
    set skyWorldMatrix(val: Immutable<Matrix4x4>);
    // (undocumented)
    update(ctx: DrawContext): Vector4 | null;
    // (undocumented)
    updateBakedSkyMap(ctx: DrawContext): void;
    get wind(): Immutable<Vector2>;
    set wind(val: Immutable<Vector2>);
}

// @public
export type SkyType = 'image' | 'skybox' | 'scatter' | 'none';

// @public
export function smoothNoise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class SmoothStepNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof SmoothStepNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export interface SphereCreationOptions extends ShapeCreationOptions {
    horizonalDetail?: number;
    radius?: number;
    verticalDetail?: number;
}

// @public
export class SphereShape extends Shape<SphereCreationOptions> implements Clonable<SphereShape> {
    constructor(options?: SphereCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        radius: number;
        verticalDetail: number;
        horizonalDetail: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    static generateData(opt: SphereCreationOptions, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "triangle-list";
    get radius(): number;
    // @override
    raycast(ray: Ray): number | null;
    get type(): "Sphere";
}

// @public
export class SpotLight extends PunctualLight {
    constructor(scene: Scene);
    get cutoff(): number;
    set cutoff(val: number);
    // @override
    isSpotLight(): this is SpotLight;
    get range(): number;
    set range(val: number);
    setCutoff(val: number): this;
    setRange(val: number): this;
}

// @public
export class Sprite extends BaseSprite<SpriteMaterial> {
    constructor(scene: Scene, material?: SpriteMaterial);
    // (undocumented)
    isSprite(): this is Sprite;
}

// @public
export class SpriteBlockNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class SpriteBlueprintMaterial extends SpriteMaterial {
    constructor(irFrag?: MaterialBlueprintIR, uniformValues?: BluePrintUniformValue[], uniformTextures?: BluePrintUniformTexture[]);
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    protected calcFragmentColor(scope: PBInsideFunctionScope): PBShaderExp;
    clone(): SpriteBlueprintMaterial;
    protected _createHash(): string;
    protected createProgram(ctx: DrawContext, pass: number): _zephyr3d_device.GPUProgram<unknown>;
    get fragmentIR(): MaterialBlueprintIR;
    set fragmentIR(ir: MaterialBlueprintIR);
    protected onDispose(): void;
    get uniformTextures(): BluePrintUniformTexture[];
    set uniformTextures(val: BluePrintUniformTexture[]);
    get uniformValues(): BluePrintUniformValue[];
    set uniformValues(val: BluePrintUniformValue[]);
}

// @public
export class SpriteMaterial extends MeshMaterial implements Clonable<SpriteMaterial> {
    constructor();
    get anchor(): Immutable<Vector2>;
    set anchor(value: Immutable<Vector2>);
    // (undocumented)
    static ANCHOR_ROTATION: number;
    get anchorRotation(): Immutable<Vector4>;
    set anchorRotation(value: Immutable<Vector4>);
    get anchorX(): number;
    set anchorX(value: number);
    get anchorY(): number;
    set anchorY(value: number);
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    protected calcFragmentColor(scope: PBInsideFunctionScope): _zephyr3d_device.PBShaderExp;
    clone(): SpriteMaterial;
    copyFrom(other: this): void;
    fragmentShader(scope: PBFunctionScope): void;
    protected internalApplyUniforms(_bindGroup: BindGroup, _ctx: DrawContext, _pass: number): void;
    protected internalSetupUniforms(_scope: PBInsideFunctionScope): void;
    get rotation(): number;
    set rotation(value: number);
    setAnchor(anchorX: number, anchorY: number): void;
    setUVInfo(uvx0: number, uvy0: number, uvx1: number, uvy1: number): void;
    // (undocumented)
    static UVINFO: number;
    get uvinfo(): Immutable<Vector4>;
    set uvinfo(value: Immutable<Vector4>);
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export class SqrtNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof SqrtNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class StandardSpriteMaterial extends SpriteMaterial implements Clonable<StandardSpriteMaterial> {
    constructor();
    protected calcFragmentColor(scope: PBInsideFunctionScope): _zephyr3d_device.PBShaderExp;
    clone(): StandardSpriteMaterial;
    copyFrom(other: this): void;
    // (undocumented)
    static FEATURE_SPRITE_TEXTURE: number;
    protected internalApplyUniforms(bindGroup: BindGroup, ctx: DrawContext): void;
    protected internalSetupUniforms(scope: PBInsideFunctionScope): void;
    protected onDispose(): void;
    get spriteTexture(): _zephyr3d_base.Nullable<Texture2D<unknown>>;
    set spriteTexture(tex: _zephyr3d_base.Nullable<Texture2D<unknown>>);
    // (undocumented)
    protected _texture: DRef<Texture2D>;
}

// @public
export class StepNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof StepNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export type StopAnimationOptions = {
    fadeOut?: number;
};

// @public
export class SwizzleNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof SwizzleNode;
        name: string;
        getProps(): PropertyAccessor<object, "">[];
    };
    protected getType(): string;
    get swizzle(): string;
    set swizzle(val: string);
    toString(): string;
    protected validate(): string;
}

// @public
export class TanHNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof TanHNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export class TanNode extends GenericMathNode {
    constructor();
    // (undocumented)
    static getSerializationCls(): {
        ctor: typeof TanNode;
        name: string;
        getProps(): never[];
    };
}

// @public
export function temporalResolve(scope: PBInsideFunctionScope, currentColorTex: PBShaderExp, historyColorTex: PBShaderExp, currentDepthTex: PBShaderExp, motionVectorTex: PBShaderExp, prevMotionVectorTex: PBShaderExp, uv: PBShaderExp, workSize: PBShaderExp, debug?: number): PBShaderExp;

// @public
export type TerrainDebugMode = 'none' | 'vertex_normal' | 'detail_normal' | 'tangent' | 'uv' | 'bitangent' | 'albedo';

// @public
export interface TetrahedronCreationOptions extends ShapeCreationOptions {
    // (undocumented)
    height?: number;
    // (undocumented)
    sizeX?: number;
    // (undocumented)
    sizeZ?: number;
}

// @public
export class TetrahedronFrameShape extends Shape<TetrahedronCreationOptions> implements Clonable<TetrahedronShape> {
    constructor(options?: TetrahedronCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        height: number;
        sizeX: number;
        sizeZ: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    // (undocumented)
    static generateData(opt: TetrahedronCreationOptions, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "line-list";
    // (undocumented)
    get type(): "TetrahedronFrame";
}

// @public
export class TetrahedronShape extends Shape<TetrahedronCreationOptions> implements Clonable<TetrahedronShape> {
    constructor(options?: TetrahedronCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        height: number;
        sizeX: number;
        sizeZ: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    // (undocumented)
    static generateData(opt: TetrahedronCreationOptions, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "triangle-list";
    // (undocumented)
    get type(): string;
}

// @public
export type TextureFetchOptions<T extends BaseTexture> = {
    mimeType?: string;
    linearColorSpace?: boolean;
    texture?: T;
    samplerOptions?: SamplerOptions;
};

// @public
export type TextureMixinInstanceTypes<T> = TextureMixinTypes<T> extends {
    new (...args: any[]): infer U;
} ? U : never;

// @public
export type TextureMixinTypes<T> = ReturnType<typeof applyMaterialMixins<ToMixedTextureType<T>, typeof MeshMaterial>>;

// @public
export type TextureProp<U extends string> = {
    [P in 'Texture' | 'TextureSampler' | 'TexCoordIndex' | 'TexCoordMatrix' as `${U}${P}`]: P extends 'Texture' ? Nullable<Texture2D> : P extends 'TextureSampler' ? Nullable<TextureSampler> : P extends 'TexCoordIndex' ? number : P extends 'TexCoordMatrix' ? Nullable<Matrix4x4> : never;
};

// @public
export type TexturePropUniforms<U extends string> = {
    [P in 'TextureUniform' | 'TexCoord' as `get${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope) => PBShaderExp;
} & {
    [P in 'Texture' as `sample${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope, texCoord?: PBShaderExp) => PBShaderExp;
};

// @public
export class TextureSampleGrad extends BaseGraphNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(): string;
    samplerType: 'Color' | 'Normal';
    toString(): string;
    protected validate(): string;
}

// @public
export class TextureSampleNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(id: number): "" | "float" | "vec3" | "vec4";
    samplerType: 'Color' | 'Normal';
    toString(): string;
    protected validate(): string;
}

// @public
export type ToMixedTextureType<T> = T extends [infer First, ...infer Rest] ? [First extends string ? ReturnType<typeof mixinTextureProps<First>> : never, ...ToMixedTextureType<Rest>] : [];

// @public
export class Tonemap extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get exposure(): number;
    set exposure(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export interface TorusCreationOptions extends ShapeCreationOptions {
    innerRadius?: number;
    numSegments?: number;
    numSlices?: number;
    outerRadius?: number;
    radialDetail?: number;
}

// @public
export class TorusShape extends Shape<TorusCreationOptions> implements Clonable<TorusShape> {
    constructor(options?: TorusCreationOptions);
    // (undocumented)
    clone(): this;
    // (undocumented)
    static _defaultOptions: {
        numSlices: number;
        numSegments: number;
        outerRadius: number;
        innerRadius: number;
        radialDetail: number;
        needNormal: boolean;
        needTangent: boolean;
        needUV: boolean;
        transform: null;
    };
    static generateData(opt: TorusCreationOptions, vertices: number[], normals: number[], tangents: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): "triangle-list";
    get type(): "Torus";
}

// @public
export class TransformNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof TransformNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): "" | "vec2" | "vec3" | "vec4" | "mat2" | "mat3" | "mat4";
    toString(): string;
    protected validate(): string;
}

// @public
export function tryGetApp(): Nullable<Application>;

// Warning: (ae-forgotten-export) The symbol "UnlitMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class UnlitMaterial extends UnlitMaterial_base implements Clonable<UnlitMaterial> {
    constructor();
    // (undocumented)
    clone(): UnlitMaterial;
    // (undocumented)
    static readonly FEATURE_VERTEX_COLOR = "um_vertexcolor";
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export function valueNoise(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class VertexBinormalNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof VertexBinormalNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec3";
    toString(): string;
    protected validate(): string;
}

// @public
export class VertexBlockNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): SerializableClass;
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class VertexColorNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof VertexColorNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec4";
    toString(): string;
    protected validate(): string;
}

// @public
export class VertexNormalNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof VertexNormalNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec3";
    toString(): string;
    protected validate(): string;
}

// @public
export class VertexPositionNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof VertexPositionNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec3";
    toString(): string;
    protected validate(): string;
}

// @public
export class VertexTangentNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof VertexTangentNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec3";
    toString(): string;
    protected validate(): string;
}

// @public
export class VertexUVNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof VertexUVNode;
        name: string;
        getProps(): never[];
    };
    protected getType(id: number): "float" | "vec2";
    toString(): string;
    protected validate(): string;
}

// @public
export class ViewMatrixNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ViewMatrixNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export class ViewProjMatrixNode extends BaseGraphNode {
    constructor();
    static getSerializationCls(): {
        ctor: typeof ViewProjMatrixNode;
        name: string;
        getProps(): never[];
    };
    protected getType(): string;
    toString(): string;
    protected validate(): string;
}

// @public
export interface Visitor<T> {
    // (undocumented)
    visit(target: T): unknown;
}

// Warning: (ae-forgotten-export) The symbol "Water_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Water extends Water_base implements Drawable {
    constructor(scene: Scene);
    get animationSpeed(): number;
    set animationSpeed(val: number);
    // (undocumented)
    calculateLocalTransform(outMatrix: Matrix4x4): void;
    // (undocumented)
    calculateWorldTransform(outMatrix: Matrix4x4): void;
    computeBoundingVolume(): null;
    computeWorldBoundingVolume(): BoundingBox | null;
    draw(ctx: DrawContext, renderQueue: Nullable<RenderQueue>): void;
    getMaterial(): Nullable<WaterMaterial>;
    getMorphData(): null;
    getMorphInfo(): null;
    getPickTarget(): PickTarget;
    getPrimitive(): null;
    getQueueType(): number;
    getSurfacePoint(points: Vector3[], outPos?: Vector3[], outNorm?: Vector3[]): Promise<void>;
    get gridScale(): number;
    set gridScale(val: number);
    isUnlit(): boolean;
    isWater(): this is Water;
    // Warning: (ae-forgotten-export) The symbol "WaterMaterial" needs to be exported by the entry point index.d.ts
    get material(): WaterMaterial;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    protected onDispose(): void;
    // (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    get TAAStrength(): number;
    set TAAStrength(val: number);
    update(frameId: number, elapsedInSeconds: number): void;
    updatePerCamera(camera: Camera, _elapsedInSeconds: number, _deltaInSeconds: number): void;
    get waveGenerator(): Nullable<WaveGenerator>;
    set waveGenerator(waveGenerator: Nullable<WaveGenerator>);
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// @public
export interface WaveGenerator extends IDisposable {
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    clone(): this;
    dispose(): void;
    getHash(): string;
    isOk(device: AbstractDevice): boolean;
    needUpdate(): boolean;
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    update(timeInSeconds: number): void;
}

// @public
export class WeightedBlendedOIT extends Disposable implements OIT {
    constructor();
    applyUniforms(_ctx: DrawContext, _bindGroup: BindGroup): void;
    begin(_ctx: DrawContext): number;
    beginPass(ctx: DrawContext, _pass: number): boolean;
    calculateHash(): string;
    end(_ctx: DrawContext): void;
    endPass(ctx: DrawContext, _pass: number): void;
    getType(): string;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): void;
    setupFragmentOutput(scope: PBGlobalScope): void;
    supportDevice(_deviceType: string): boolean;
    static readonly type = "wb";
    wantsPremultipliedAlpha(): boolean;
}

// @public
export function whiteNoise(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export function worleyFBM(scope: PBInsideFunctionScope, p: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// @public
export function worleyNoise(scope: PBInsideFunctionScope, uv: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// (No @packageDocumentation comment for this package)

```
