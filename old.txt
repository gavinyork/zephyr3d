#version 300 es
precision highp float;
precision highp int;
struct zStruct0 {
    vec4 position;
    vec4 clipPlane;
    mat4 viewProjectionMatrix;
    mat4 viewMatrix;
    vec4 params;
    float roughnessFactor;
    int framestamp;
};
struct zStruct1 {
    int fogType;
    vec4 fogColor;
    vec4 fogParams;
    float apDensity;
};
struct zStruct2 {
    vec3 sunDir;
    float envLightStrength;
    vec4 clusterParams;
    ivec4 countParams;
    ivec2 lightIndexTexSize;
};
struct zStruct3 {
    zStruct0 camera;
    zStruct2 light;
    zStruct1 fog;
};
struct zStruct4 {
    mat3 TBN;
    vec3 normal;
};
struct zStruct5 {
    vec4 f0;
    vec3 f90;
    vec4 diffuse;
    float metallic;
    float roughness;
    float specularWeight;
};
struct zStruct7 {
    float zIBLRadianceMapMaxLOD;
};
struct zStruct8 {
    vec4 zF0;
    vec4 zEmissiveFactor;
    vec4 zAlbedo;
    float zNormalScale;
    float zMetallic;
    float zRoughness;
    vec4 zSpecularFactor;
};
struct zStruct9 {
    zStruct3 Z_UniformGlobal;
};
struct zStruct10 {
    vec4 Z_UniformLightBuffer[768];
};
uniform highp usampler2D Z_UniformLightIndexTex;
uniform highp samplerCube zIBLRadianceMap;
uniform highp samplerCube zIBLIrradianceMap;
uniform highp sampler2D zGGXLut;
uniform highp sampler2D zAlbedoTex;
uniform highp sampler2D zNormalTex;
layout(std140) uniform ch_block_name_ch_fragment_uniform_block_0_0 {
    zStruct7 ch_fragment_uniform_block_0_0;
};
layout(std140) uniform ch_block_name_ch_fragment_uniform_block_2_0 {
    zStruct8 ch_fragment_uniform_block_2_0;
};
layout(std140) uniform ch_block_name_ch_shared_uniform_block_0_0 {
    zStruct9 ch_shared_uniform_block_0_0;
};
layout(std140) uniform ch_block_name_ch_shared_uniform_block_0_1 {
    zStruct10 ch_shared_uniform_block_0_1;
};
in vec2 zVSOutput_zAlbedoTexCoord;
in vec2 zVSOutput_zNormalTexCoord;
in vec3 zVSOutput_worldPos;
in vec3 zVSOutput_wNorm;
layout(location = 0) out vec4 zFSOutput_zFragmentOutput;
mat3 Z_calculateTBN_N(vec3 worldPos, vec3 worldNormal) {
    vec2 uv = zVSOutput_zNormalTexCoord;
    mat3 TBN;
    vec3 uv_dx = dFdx(vec3(uv, 0.0));
    vec3 uv_dy = dFdy(vec3(uv, 0.0));
    if ((length(uv_dx) + length(uv_dy)) <= 0.000001) {
        uv_dx = vec3(1.0, 0.0, 0.0);
        uv_dy = vec3(0.0, 1.0, 0.0);
    }
    vec3 t_ = ((dFdx(worldPos) * uv_dy.y) - (dFdy(worldPos) * uv_dx.y)) / ((uv_dx.x * uv_dy.y) - (uv_dx.y * uv_dy.x));
    vec3 ng = normalize(worldNormal);
    vec3 t = normalize(t_ - (ng * dot(ng, t_)));
    vec3 b = cross(ng, t);
    if (!gl_FrontFacing) {
        t = t * -1.0;
        b = b * -1.0;
        ng = ng * -1.0;
    }
    TBN = mat3(t, b, ng);
    return TBN;
}
zStruct4 Z_calculateNormalAndTBN_N(vec3 worldPos, vec3 worldNormal) {
    vec2 uv = zVSOutput_zNormalTexCoord;
    mat3 TBN = Z_calculateTBN_N(worldPos.xyz, worldNormal);
    return zStruct4(TBN, normalize(TBN * (((texture(zNormalTex, uv).rgb * 2.0) - vec3(1.0)) * vec3(vec3(ch_fragment_uniform_block_2_0.zNormalScale).xx, 1.0))));
}
zStruct5 Z_getCommonData(vec4 albedo, vec3 normal, vec3 viewVec, mat3 TBN) {
    zStruct5 data;
    data.metallic = ch_fragment_uniform_block_2_0.zMetallic;
    data.roughness = ch_fragment_uniform_block_2_0.zRoughness;
    data.roughness = data.roughness * ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.roughnessFactor;
    vec3 specularColor = ch_fragment_uniform_block_2_0.zSpecularFactor.rgb;
    data.specularWeight = ch_fragment_uniform_block_2_0.zSpecularFactor.a;
    data.f0 = vec4(mix(min(ch_fragment_uniform_block_2_0.zF0.rgb * specularColor, vec3(1.0)), albedo.rgb, data.metallic), ch_fragment_uniform_block_2_0.zF0.a);
    data.f90 = vec3(1.0);
    data.diffuse = vec4(mix(albedo.rgb, vec3(0.0), data.metallic), albedo.a);
    return data;
}
void Z_PBRIndirectLighting(vec3 normal, vec3 viewVec, zStruct5 data, inout vec3 outColor) {
    float occlusion = ch_shared_uniform_block_0_0.Z_UniformGlobal.light.envLightStrength;
    float NoV = clamp(dot(normal, viewVec), 0.0001, 1.0);
    vec4 ggxLutSample = clamp(textureLod(zGGXLut, clamp(vec2(NoV, data.roughness), vec2(0.0), vec2(1.0)), 0.0), vec4(0.0), vec4(1.0));
    vec2 f_ab = ggxLutSample.rg;
    vec3 Fr = max(vec3(1.0 - data.roughness), data.f0.rgb) - data.f0.rgb;
    vec3 k_S = data.f0.rgb + (Fr * pow(1.0 - NoV, 5.0));
    vec3 FssEss = (k_S * f_ab.x) + vec3(f_ab.y);
    vec3 specularFactor = (FssEss * data.specularWeight) * occlusion;
    vec3 radiance = textureLod(zIBLRadianceMap, reflect(-viewVec, normal), data.roughness * ch_fragment_uniform_block_0_0.zIBLRadianceMapMaxLOD).rgb;
    outColor = outColor + (radiance * specularFactor);
    vec3 irradiance = textureLod(zIBLIrradianceMap, normal, 0.0).rgb;
    vec3 mixedF0 = data.f0.rgb;
    FssEss = ((k_S * f_ab.x) * data.specularWeight) + vec3(f_ab.y);
    float Ems = 1.0 - (f_ab.x + f_ab.y);
    vec3 F_avg = (mixedF0 + ((vec3(1.0) - mixedF0) / 21.0)) * data.specularWeight;
    vec3 FmsEms = ((FssEss * F_avg) * Ems) / (vec3(1.0) - (F_avg * Ems));
    vec3 k_D = data.diffuse.rgb * ((vec3(1.0) - FssEss) + FmsEms);
    vec3 iblDiffuse = ((FmsEms + k_D) * irradiance) * occlusion;
    outColor = outColor + iblDiffuse;
}
ivec3 lm_getClusterIndex(vec3 fragCoord) {
    int zTile = int(max((log2((ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.params.x * ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.params.y) / mix(ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.params.y, ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.params.x, fragCoord.z)) * ch_shared_uniform_block_0_0.Z_UniformGlobal.light.clusterParams.z) + ch_shared_uniform_block_0_0.Z_UniformGlobal.light.clusterParams.w, 0.0));
    vec2 f = vec2(fragCoord.x, ch_shared_uniform_block_0_0.Z_UniformGlobal.light.clusterParams.y - (fragCoord.y + 1.0));
    ivec2 xyTile = ivec2(f / (ch_shared_uniform_block_0_0.Z_UniformGlobal.light.clusterParams.xy / vec2(ch_shared_uniform_block_0_0.Z_UniformGlobal.light.countParams.xy)));
    return ivec3(xyTile, zTile);
}
float Z_calculatePointLightAttenuation(vec3 worldPos, vec4 posRange) {
    float dist = distance(posRange.xyz, worldPos);
    float falloff = max(0.0, 1.0 - (dist / posRange.w));
    return falloff * falloff;
}
float Z_calculateSpotLightAttenuation(vec3 worldPos, vec4 posRange, vec4 dirCutoff) {
    float dist = distance(posRange.xyz, worldPos);
    float falloff = max(0.0, 1.0 - (dist / posRange.w));
    float spotFactor = dot(normalize(worldPos - posRange.xyz), dirCutoff.xyz);
    spotFactor = smoothstep(dirCutoff.w, mix(dirCutoff.w, 1.0, 0.5), spotFactor);
    return (spotFactor * falloff) * falloff;
}
vec3 Z_fresnelSchlick(float cosTheta, vec3 f0, vec3 f90) {
    return f0 + ((f90 - f0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0));
}
float Z_distributionGGX(float NdotH, float roughness) {
    float a2 = roughness * roughness;
    float NdotH2 = NdotH * NdotH;
    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0)) + 1.0;
    denom = (3.14159265 * denom) * denom;
    return num / denom;
}
float Z_visGGX(float NdotV, float NdotL, float roughness) {
    float a = roughness;
    float ggxV = NdotL * sqrt(((NdotV * NdotV) * (1.0 - a)) + a);
    float ggxL = NdotV * sqrt(((NdotL * NdotL) * (1.0 - a)) + a);
    float ggx = (ggxV + ggxL) + 0.00001;
    if (ggx > 0.0) {
        return 0.5 / ggx;
    }
    else {
        return 0.0;
    }

}
void Z_PBRDirectLighting(vec3 L, vec3 lightColor, vec3 normal, vec3 viewVec, zStruct5 data, inout vec3 outColor) {
    vec3 H = normalize(viewVec + L);
    float NoH = clamp(dot(normal, H), 0.0, 1.0);
    float NoL = clamp(dot(normal, L), 0.0, 1.0);
    float NoV = clamp(dot(normal, viewVec), 0.0, 1.0);
    if (NoL > 0.0) {
        float VoH = clamp(dot(viewVec, H), 0.0, 1.0);
        vec3 schlickFresnel = Z_fresnelSchlick(VoH, data.f0.rgb, data.f90);
        vec3 F = schlickFresnel;
        float alphaRoughness = data.roughness * data.roughness;
        float D = Z_distributionGGX(NoH, alphaRoughness);
        float V = Z_visGGX(NoV, NoL, alphaRoughness);
        vec3 specular = (((lightColor * D) * V) * F) * data.specularWeight;
        outColor = outColor + specular;
        vec3 diffuseBRDF = (vec3(1.0) - (F * data.specularWeight)) * (data.diffuse.rgb / 3.141592653589793);
        vec3 diffuse = lightColor * max(diffuseBRDF, vec3(0.0));
        outColor = outColor + diffuse;
    }

}
vec3 Z_PBRMetallicRoughnessLight(vec3 worldPos, vec3 normal, mat3 TBN, vec3 viewVec, vec4 albedo) {
    zStruct5 pbrData = Z_getCommonData(albedo, normal, viewVec, TBN);
    vec3 lightingColor = vec3(0.0);
    vec3 emissiveColor = ch_fragment_uniform_block_2_0.zEmissiveFactor.rgb * ch_fragment_uniform_block_2_0.zEmissiveFactor.a;
    Z_PBRIndirectLighting(normal, viewVec, pbrData, lightingColor); {
        ivec3 cluster = lm_getClusterIndex(gl_FragCoord.xyz);
        int clusterIndex = (cluster.x + (cluster.y * ch_shared_uniform_block_0_0.Z_UniformGlobal.light.countParams.x)) + ((cluster.z * ch_shared_uniform_block_0_0.Z_UniformGlobal.light.countParams.x) * ch_shared_uniform_block_0_0.Z_UniformGlobal.light.countParams.y);
        ivec2 texSize = ch_shared_uniform_block_0_0.Z_UniformGlobal.light.lightIndexTexSize;
        int texCoordX = clusterIndex % texSize.x;
        int texCoordY = clusterIndex / texSize.x;
        uvec4 samp = texelFetch(Z_UniformLightIndexTex, ivec2(texCoordX, texCoordY), 0);
        for (uint i = 0u; i < 4u; i++) {
            for (uint k = 0u; k < 4u; k++) {
                uint c = (samp[i] >> (k * 8u)) & 255u;
                if (c > 0u) {
                    vec4 positionRange = ch_shared_uniform_block_0_1.Z_UniformLightBuffer[c * 3u];
                    vec4 directionCutoff = ch_shared_uniform_block_0_1.Z_UniformLightBuffer[(c * 3u) + 1u];
                    vec4 diffuseIntensity = ch_shared_uniform_block_0_1.Z_UniformLightBuffer[(c * 3u) + 2u];
                    int lightType = (positionRange.w < 0.0) ? 1 : ((directionCutoff.w < 0.0) ? 2 : 3); {
                        vec3 diffuse;
                        vec3 specular;
                        float lightAtten = (lightType == 1) ? 1.0 : ((lightType == 2) ? Z_calculatePointLightAttenuation(worldPos.xyz, positionRange) : Z_calculateSpotLightAttenuation(worldPos.xyz, positionRange, directionCutoff));
                        vec3 lightDir = (lightType == 1) ? -directionCutoff.xyz : normalize(positionRange.xyz - worldPos.xyz);
                        float NoL = clamp(dot(normal, lightDir), 0.0, 1.0);
                        vec3 lightColor = ((diffuseIntensity.rgb * diffuseIntensity.a) * lightAtten) * NoL;
                        Z_PBRDirectLighting(lightDir, lightColor, normal, viewVec, pbrData, lightingColor);
                    }

                }

            }

        }

    }
    return lightingColor + emissiveColor;
}
void Z_discardIfClippped(vec3 worldPos) {
    if (ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.position.w ! = 0.0) {
        vec4 clipPlane = ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.clipPlane;
        if ((dot(worldPos.xyz, clipPlane.xyz) + clipPlane.w) > 0.0) {
            discard;
        }

    }

}
vec3 Z_linearToGamma(vec3 color) {
    return max((pow(color, vec3(0.416666667)) * 1.055) - vec3(0.055), vec3(0.0));
}
vec4 Z_encodeColorOutput(vec4 outputColor) {
    if (ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.params.w ! = 0.0) {
        return vec4(Z_linearToGamma(outputColor.rgb), outputColor.w);
    }
    else {
        return outputColor;
    }

}
void Z_outputFragmentColor(vec3 worldPos, vec4 color) {
    vec4 outColor = color;
    Z_discardIfClippped(worldPos);
    outColor.a = 1.0;
    zFSOutput_zFragmentOutput = Z_encodeColorOutput(outColor);
}
void main() {
    vec4 albedo = ch_fragment_uniform_block_2_0.zAlbedo * texture(zAlbedoTex, zVSOutput_zAlbedoTexCoord);
    zStruct4 normalInfo = Z_calculateNormalAndTBN_N(zVSOutput_worldPos.xyz, zVSOutput_wNorm);
    vec3 viewVec = normalize(ch_shared_uniform_block_0_0.Z_UniformGlobal.camera.position.xyz - zVSOutput_worldPos.xyz);
    vec3 litColor = Z_PBRMetallicRoughnessLight(zVSOutput_worldPos, normalInfo.normal, normalInfo.TBN, viewVec, albedo);
    Z_outputFragmentColor(zVSOutput_worldPos, vec4(litColor, albedo.a));
}
