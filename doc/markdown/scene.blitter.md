<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](doc/markdown/./index.md) &gt; [@zephyr3d/scene](doc/markdown/./scene.md) &gt; [Blitter](doc/markdown/./scene.blitter.md)

## Blitter class

Base class for any kind of blitters

**Signature:**

```typescript
declare abstract class Blitter 
```

## Constructors

<table><thead><tr><th>

Constructor


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[(constructor)()](doc/markdown/./scene.blitter._constructor_.md)


</td><td>


</td><td>

Creates an instance of Blitter


</td></tr>
</tbody></table>

## Properties

<table><thead><tr><th>

Property


</th><th>

Modifiers


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[destRect](doc/markdown/./scene.blitter.destrect.md)


</td><td>


</td><td>

number\[\]


</td><td>

Destination rectangle


</td></tr>
<tr><td>

[hash](doc/markdown/./scene.blitter.hash.md)


</td><td>

`readonly`


</td><td>

string


</td><td>

Program hash code


</td></tr>
<tr><td>

[renderStates](doc/markdown/./scene.blitter.renderstates.md)


</td><td>


</td><td>

[RenderStateSet](doc/markdown/./device.renderstateset.md)


</td><td>

Render states used to do the blitting


</td></tr>
<tr><td>

[scissor](doc/markdown/./scene.blitter.scissor.md)


</td><td>


</td><td>

number\[\]


</td><td>

Scissor rect


</td></tr>
<tr><td>

[srgbOut](doc/markdown/./scene.blitter.srgbout.md)


</td><td>


</td><td>

boolean


</td><td>

Whether output color value in gamma color space


</td></tr>
<tr><td>

[viewport](doc/markdown/./scene.blitter.viewport.md)


</td><td>


</td><td>

number\[\]


</td><td>

Viewport


</td></tr>
</tbody></table>

## Methods

<table><thead><tr><th>

Method


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[blit(source, dest, sampler)](doc/markdown/./scene.blitter.blit.md)


</td><td>


</td><td>

Blits a 2D texture to a frame buffer


</td></tr>
<tr><td>

[blit(source, dest, layer, sampler)](doc/markdown/./scene.blitter.blit_9.md)


</td><td>


</td><td>


</td></tr>
<tr><td>

[blit(source, dest, sampler)](doc/markdown/./scene.blitter.blit_1.md)


</td><td>


</td><td>

Blits a 2D texture to 2D texture or frame buffer


</td></tr>
<tr><td>

[blit(source, dest, layer, sampler)](doc/markdown/./scene.blitter.blit_2.md)


</td><td>


</td><td>

Blits a 2D texture to given layer of a 2D array texture


</td></tr>
<tr><td>

[blit(source, dest, sampler)](doc/markdown/./scene.blitter.blit_3.md)


</td><td>


</td><td>

Blits a 2d array texture to another 2d array texture


</td></tr>
<tr><td>

[blit(source, dest, layer, sampler)](doc/markdown/./scene.blitter.blit_4.md)


</td><td>


</td><td>

Blits given layer of a 2d array texture to a frame buffer


</td></tr>
<tr><td>

[blit(source, dest, layer, sampler)](doc/markdown/./scene.blitter.blit_5.md)


</td><td>


</td><td>

Blits given layer of a 2d array texture to a 2d texture or frame buffer


</td></tr>
<tr><td>

[blit(source, dest, sampler)](doc/markdown/./scene.blitter.blit_6.md)


</td><td>


</td><td>

Blits a cube texture to another cube texture


</td></tr>
<tr><td>

[blit(source, dest, face, sampler)](doc/markdown/./scene.blitter.blit_7.md)


</td><td>


</td><td>

Blits given face of a cube texture to a frame buffer


</td></tr>
<tr><td>

[blit(source, dest, face, sampler)](doc/markdown/./scene.blitter.blit_8.md)


</td><td>


</td><td>

Blits given face of a cube texture to a 2d texture or frame buffer


</td></tr>
<tr><td>

[calcHash()](doc/markdown/./scene.blitter.calchash.md)


</td><td>

`protected`

`abstract`


</td><td>

Calculates the hash code


</td></tr>
<tr><td>

[filter(scope, type, srcTex, srcUV, srcLayer, sampeType)](doc/markdown/./scene.blitter.filter.md)


</td><td>

`abstract`


</td><td>

Calculates the destination texel by the source texel


</td></tr>
<tr><td>

[invalidateHash()](doc/markdown/./scene.blitter.invalidatehash.md)


</td><td>


</td><td>

Force the hash code to be regenerated


</td></tr>
<tr><td>

[readTexel(scope, type, srcTex, uv, srcLayer, sampleType)](doc/markdown/./scene.blitter.readtexel.md)


</td><td>


</td><td>

Reads a texel from the source texture


</td></tr>
<tr><td>

[setUniforms(\_bindGroup, \_sourceTex)](doc/markdown/./scene.blitter.setuniforms.md)


</td><td>


</td><td>

Update uniforms of the bind group


</td></tr>
<tr><td>

[setup(\_scope, \_type)](doc/markdown/./scene.blitter.setup.md)


</td><td>


</td><td>

Initialize uniforms of the blit program


</td></tr>
<tr><td>

[writeTexel(scope, type, uv, texel)](doc/markdown/./scene.blitter.writetexel.md)


</td><td>


</td><td>

Writes a texel to destination texture


</td></tr>
</tbody></table>

