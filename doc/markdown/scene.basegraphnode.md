<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](doc/markdown/./index.md) &gt; [@zephyr3d/scene](doc/markdown/./scene.md) &gt; [BaseGraphNode](doc/markdown/./scene.basegraphnode.md)

## BaseGraphNode class

Abstract base class for graph nodes

**Signature:**

```typescript
declare abstract class BaseGraphNode extends Observable<{
    changed: [];
}> implements IGraphNode 
```
**Extends:** [Observable](doc/markdown/./base.observable.md)<!-- -->&lt;{ changed: \[\]; }&gt;

**Implements:** [IGraphNode](doc/markdown/./scene.igraphnode.md)

## Remarks

Provides common functionality for all graph node types: - Input/output slot storage - Error state management - Basic validation logic - Change event emission

Subclasses must implement: - `getType()`<!-- -->: Define output type logic - Optionally override `validate()` for custom validation - Optionally override `toString()` for code generation

## Example


```typescript
class MultiplyNode extends BaseGraphNode {
  constructor() {
    super();
    this._inputs = [
      { id: 0, name: 'a', type: ['float', 'vec2', 'vec3'], required: true },
      { id: 1, name: 'b', type: ['float', 'vec2', 'vec3'], required: true }
    ];
    this._outputs = [
      { id: 0, name: 'result' }
    ];
  }

  protected getType(id?: number): string {
    // Return type based on input types
    return this._inputs[0].inputNode?.getOutputType(0) ?? 'float';
  }

  toString(): string {
    return `${this.getType()} result = a * b;`;
  }
}
```

## Constructors

<table><thead><tr><th>

Constructor


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[(constructor)()](doc/markdown/./scene.basegraphnode._constructor_.md)


</td><td>


</td><td>

Creates a new BaseGraphNode instance


</td></tr>
</tbody></table>

## Properties

<table><thead><tr><th>

Property


</th><th>

Modifiers


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[\_error](doc/markdown/./scene.basegraphnode._error.md)


</td><td>

`protected`


</td><td>

string


</td><td>

Internal storage for error message


</td></tr>
<tr><td>

[\_inputs](doc/markdown/./scene.basegraphnode._inputs.md)


</td><td>

`protected`


</td><td>

[GraphNodeInput](doc/markdown/./scene.graphnodeinput.md)<!-- -->\[\]


</td><td>

Internal storage for input slot definitions


</td></tr>
<tr><td>

[\_outputs](doc/markdown/./scene.basegraphnode._outputs.md)


</td><td>

`protected`


</td><td>

[GraphNodeOutput](doc/markdown/./scene.graphnodeoutput.md)<!-- -->\[\]


</td><td>

Internal storage for output slot definitions


</td></tr>
<tr><td>

[error](doc/markdown/./scene.basegraphnode.error.md)


</td><td>


</td><td>

string


</td><td>

Gets the current error message


</td></tr>
<tr><td>

[inputs](doc/markdown/./scene.basegraphnode.inputs.md)


</td><td>

`readonly`


</td><td>

[GraphNodeInput](doc/markdown/./scene.graphnodeinput.md)<!-- -->\[\]


</td><td>

Gets the input slot definitions array


</td></tr>
<tr><td>

[isUniform](doc/markdown/./scene.basegraphnode.isuniform.md)


</td><td>

`readonly`


</td><td>

boolean


</td><td>

Whether this node contains uniform value/texture


</td></tr>
<tr><td>

[outputs](doc/markdown/./scene.basegraphnode.outputs.md)


</td><td>

`readonly`


</td><td>

[GraphNodeOutput](doc/markdown/./scene.graphnodeoutput.md)<!-- -->\[\]


</td><td>

Gets the output slot definitions array


</td></tr>
<tr><td>

[paramName](doc/markdown/./scene.basegraphnode.paramname.md)


</td><td>

`readonly`


</td><td>

string


</td><td>

Uniform parameter name


</td></tr>
</tbody></table>

## Methods

<table><thead><tr><th>

Method


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[check()](doc/markdown/./scene.basegraphnode.check.md)


</td><td>


</td><td>

Validates the node and updates error state


</td></tr>
<tr><td>

[getOutputType(id)](doc/markdown/./scene.basegraphnode.getoutputtype.md)


</td><td>


</td><td>

Gets the output type for a specific output slot


</td></tr>
<tr><td>

[getType(\_id)](doc/markdown/./scene.basegraphnode.gettype.md)


</td><td>

`protected`

`abstract`


</td><td>

Gets the type name for a specific output slot


</td></tr>
<tr><td>

[reset()](doc/markdown/./scene.basegraphnode.reset.md)


</td><td>


</td><td>

Clears the error state


</td></tr>
<tr><td>

[setInput(id, node, inputId)](doc/markdown/./scene.basegraphnode.setinput.md)


</td><td>


</td><td>

Connects an input slot to another node's output


</td></tr>
<tr><td>

[toString()](doc/markdown/./scene.basegraphnode.tostring.md)


</td><td>


</td><td>

Generates a string representation of the node


</td></tr>
<tr><td>

[validate()](doc/markdown/./scene.basegraphnode.validate.md)


</td><td>

`protected`


</td><td>

Validates the node's current state


</td></tr>
</tbody></table>

