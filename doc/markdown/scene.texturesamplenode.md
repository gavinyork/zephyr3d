<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](doc/markdown/./index.md) &gt; [@zephyr3d/scene](doc/markdown/./scene.md) &gt; [TextureSampleNode](doc/markdown/./scene.texturesamplenode.md)

## TextureSampleNode class

Texture sampling node

**Signature:**

```typescript
declare class TextureSampleNode extends BaseGraphNode 
```
**Extends:** [BaseGraphNode](doc/markdown/./scene.basegraphnode.md)

## Remarks

Samples a texture at the specified coordinates and returns the color value. This is the primary way to read texture data in material shaders.

Supports multiple texture types: - \*\*tex2D\*\*: Requires vec2 coordinates (u, v) - \*\*tex2DArray\*\*: Requires vec3 coordinates (u, v, layer) - \*\*texCube\*\*: Requires vec3 direction vector

Sampler types: - \*\*Color\*\*: Standard color sampling (returns RGBA as-is) - \*\*Normal\*\*: Normal map sampling (may apply special transformations)

The sampling uses the texture's configured filtering and addressing modes. Mipmap level is automatically selected based on screen-space derivatives.

Inputs: - Input 1: Texture sampler (tex2D, tex2DArray, or texCube) - Input 2: Texture coordinates (vec2 for 2D, vec3 for array/cube)

Output: - Output 1: Sampled color (vec4 RGBA)

## Example 1


```typescript
// Basic 2D texture sampling
const albedoTex = new ConstantTexture2DNode();
const uv = new VertexUVNode();

const sample = new TextureSampleNode();
sample.samplerType = 'Color';
sample.connectInput(1, albedoTex, 1);
sample.connectInput(2, uv, 1);

output.connectInput(1, sample, 1); // Use as base color
```

## Example 2


```typescript
// Normal map sampling
const normalMap = new ConstantTexture2DNode();
const uv = new VertexUVNode();

const sample = new TextureSampleNode();
sample.samplerType = 'Normal';
sample.connectInput(1, normalMap, 1);
sample.connectInput(2, uv, 1);

output.connectInput(6, sample, 1); // Use as normal
```

## Example 3


```typescript
// Cubemap environment sampling
const envMap = new ConstantTextureCubeNode();
const normal = new VertexNormalNode();
const viewDir = new ViewDirectionNode();

const reflectDir = new ReflectNode();
reflectDir.connectInput(1, viewDir, 1);
reflectDir.connectInput(2, normal, 1);

const sample = new TextureSampleNode();
sample.connectInput(1, envMap, 1);
sample.connectInput(2, reflectDir, 1);
```

## Constructors

<table><thead><tr><th>

Constructor


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[(constructor)()](doc/markdown/./scene.texturesamplenode._constructor_.md)


</td><td>


</td><td>

Creates a new texture sample node


</td></tr>
</tbody></table>

## Properties

<table><thead><tr><th>

Property


</th><th>

Modifiers


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[samplerType](doc/markdown/./scene.texturesamplenode.samplertype.md)


</td><td>


</td><td>

'Color' \| 'Normal'


</td><td>

The type of sampling (Color or Normal)


</td></tr>
</tbody></table>

## Methods

<table><thead><tr><th>

Method


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[getSerializationCls()](doc/markdown/./scene.texturesamplenode.getserializationcls.md)


</td><td>

`static`


</td><td>

Gets the serialization descriptor for this node type


</td></tr>
<tr><td>

[getType()](doc/markdown/./scene.texturesamplenode.gettype.md)


</td><td>

`protected`


</td><td>

Gets the output type


</td></tr>
<tr><td>

[toString()](doc/markdown/./scene.texturesamplenode.tostring.md)


</td><td>


</td><td>

Generates a string representation of this node


</td></tr>
<tr><td>

[validate()](doc/markdown/./scene.texturesamplenode.validate.md)


</td><td>

`protected`


</td><td>

Validates the node state and input type compatibility


</td></tr>
</tbody></table>

