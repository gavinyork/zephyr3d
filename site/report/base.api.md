## API Report File for "@zephyr3d/base"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class AABB {
    constructor();
    constructor(box: AABB);
    constructor(minPoint: Vector3, maxPoint: Vector3);
    beginExtend(): void;
    behindPlane(p: Plane): boolean;
    get center(): Vector3;
    static readonly ClipBack: number;
    static readonly ClipBottom: number;
    static readonly ClipFront: number;
    static readonly ClipLeft: number;
    static readonly ClipRight: number;
    static readonly ClipTop: number;
    computePoints(): Vector3[];
    containsBox(other: AABB): boolean;
    containsPoint(pt: Vector3): boolean;
    get diagonalLength(): number;
    equalsTo(other: AABB, epsl?: number): boolean;
    extend(v: Vector3): void;
    extend3(x: number, y: number, z: number): void;
    get extents(): Vector3;
    getClipState(viewProjMatrix: Matrix4x4): ClipState;
    getClipStateMask(viewProjMatrix: Matrix4x4, mask: number): ClipState;
    getClipStateWithFrustum(frustum: Frustum): ClipState;
    getClipStateWithFrustumMask(frustum: Frustum, mask: number): ClipState;
    inplaceTransform(matrix: Matrix4x4): AABB;
    intersectedWithBox(other: AABB): boolean;
    isValid(): boolean;
    get maxPoint(): Vector3;
    set maxPoint(p: Vector3);
    get minPoint(): Vector3;
    set minPoint(p: Vector3);
    get size(): Vector3;
    static transform(bbox: AABB, matrix: Matrix4x4, result?: AABB): AABB;
    union(other: AABB): this;
}

// @public
export function applyMixins(derivedCtor: any, baseCtors: any[]): void;

// @public
export enum BoxSide {
    BACK = 5,
    BOTTOM = 2,
    FRONT = 4,
    LEFT = 0,
    RIGHT = 1,
    TOP = 3
}

// @public
export enum ClipState {
    A_INSIDE_B = 1,
    B_INSIDE_A = 2,
    CLIPPED = 2,
    NOT_CLIPPED = 0
}

// @public
export interface ColorRGBA {
    // (undocumented)
    a: number;
    // (undocumented)
    b: number;
    // (undocumented)
    g: number;
    // (undocumented)
    r: number;
}

// @public
export enum CubeFace {
    // (undocumented)
    NX = 1,
    // (undocumented)
    NY = 3,
    // (undocumented)
    NZ = 5,
    // (undocumented)
    PX = 0,
    // (undocumented)
    PY = 2,
    // (undocumented)
    PZ = 4
}

// @public
type EventListener_2<T extends EventMap, K extends keyof T> = (evt: T[K]) => void | Promise<void>;
export { EventListener_2 as EventListener }

// @public
export type EventMap = Record<string, any>;

// @public
export type EventType<T extends EventMap> = T[keyof T];

// @public
export function floatToHalf(val: number): number;

// @public
export class Frustum {
    constructor(transform: Matrix4x4);
    constructor(other: Frustum);
    containsPoint(pt: Vector3): boolean;
    // (undocumented)
    static readonly CORNER_LEFT_BOTTOM_FAR = 5;
    // (undocumented)
    static readonly CORNER_LEFT_BOTTOM_NEAR = 4;
    // (undocumented)
    static readonly CORNER_LEFT_TOP_FAR = 1;
    // (undocumented)
    static readonly CORNER_LEFT_TOP_NEAR = 0;
    // (undocumented)
    static readonly CORNER_RIGHT_BOTTOM_FAR = 6;
    // (undocumented)
    static readonly CORNER_RIGHT_BOTTOM_NEAR = 7;
    // (undocumented)
    static readonly CORNER_RIGHT_TOP_FAR = 2;
    // (undocumented)
    static readonly CORNER_RIGHT_TOP_NEAR = 3;
    get corners(): Vector3[];
    getCorner(pos: number): Vector3;
    initWithMatrix(transform: Matrix4x4): this;
    get planes(): Plane[];
}

// @public
export type GenericConstructor<T = {}> = {
    new (...args: any[]): T;
};

// @public
export function halfToFloat(val: number): number;

// @public
export class HttpRequest {
    constructor();
    get crossOrigin(): string;
    set crossOrigin(val: string);
    get headers(): Record<string, string>;
    set headers(val: Record<string, string>);
    request(url: string): Promise<Response>;
    requestArrayBuffer(url: string): Promise<ArrayBuffer>;
    requestBlob(url: string): Promise<Blob>;
    requestText(url: string): Promise<string>;
    resolveURL(url: string): string;
    get urlResolver(): (url: string) => string;
    set urlResolver(resolver: (url: string) => string);
}

// @public
export interface IEventTarget<T extends EventMap = any> {
    dispatchEvent(evt: T[keyof T], type?: string & keyof T): void;
    off<K extends keyof T>(type: K, listener: EventListener_2<T, K>): void;
    on<K extends keyof T>(type: K, listener: EventListener_2<T, K>, context?: unknown): void;
    once<K extends keyof T>(type: K, listener: EventListener_2<T, K>, context?: unknown): void;
}

// @public
export type InterpolationMode = 'unknown' | 'step' | 'linear' | 'cubicspline';

// @public
export type InterpolationTarget = 'number' | 'vec2' | 'vec3' | 'vec4' | 'quat';

// @public
export class Interpolator {
    constructor(mode: InterpolationMode, target: InterpolationTarget, inputs: TypedArray, outputs: TypedArray);
    static getTargetStride(target: InterpolationTarget): number;
    interpolate(t: number, maxTime: number, result: Float32Array): Float32Array;
    // (undocumented)
    get maxTime(): number;
    get mode(): InterpolationMode;
    get target(): InterpolationTarget;
}

// @public
export function isPowerOf2(value: number): boolean;

// @public
export class List<T = unknown> {
    constructor();
    append(data: T): ListIterator<T>;
    back(): T;
    begin(): ListIterator<T>;
    clear(): void;
    end(): ListIterator<T>;
    forEach(callback: (data: T) => void): void;
    forEachReverse(callback: (data: T) => void): void;
    front(): T;
    insert(data: T, at: ListIterator<T>): ListIterator<T>;
    get length(): number;
    prepend(data: T): ListIterator<T>;
    rbegin(): ListIterator<T>;
    remove(it: ListIterator<T>): void;
    rend(): ListIterator<T>;
}

// @public
export class ListIterator<T = unknown> {
    get data(): T;
    set data(val: T);
    getNext(): ListIterator<T>;
    getPrev(): ListIterator<T>;
    get list(): List<T>;
    next(): ListIterator<T>;
    prev(): ListIterator<T>;
    get reversed(): boolean;
    valid(): boolean;
}

// @public
export function makeEventTarget<C extends GenericConstructor | ObjectConstructor>(cls: C): <X extends EventMap>() => {
    new (...args: any[]): {
        _listeners: Partial<{
            [type: string]: {
                handler: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, any>;
                options: REventHandlerOptions;
                removed: boolean;
            }[];
        }>;
        on<K extends keyof (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)>(type: K, listener: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, K>, context?: unknown): void;
        once<K_1 extends keyof (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)>(type: K_1, listener: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, K_1>, context?: unknown): void;
        off<K_2 extends keyof (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)>(type: K_2, listener: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, K_2>): void;
        dispatchEvent(evt: (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)[keyof (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)], type?: string & keyof (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)): void;
        _internalAddEventListener<K_3 extends keyof (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)>(listenerMap: Partial<{
            [type: string]: {
                handler: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, any>;
                options: REventHandlerOptions;
                removed: boolean;
            }[];
        }>, type: K_3, listener: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, K_3>, options?: REventHandlerOptions): Partial<{
            [type: string]: {
                handler: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, any>;
                options: REventHandlerOptions;
                removed: boolean;
            }[];
        }>;
        _internalRemoveEventListener<K_4 extends keyof (InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X)>(listenerMap: Partial<{
            [type: string]: {
                handler: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, any>;
                options: REventHandlerOptions;
                removed: boolean;
            }[];
        }>, type: K_4, listener: EventListener_2<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X, K_4>): void;
        _invokeLocalListeners(evt: EventType<InstanceType<C> extends IEventTarget<infer U extends EventMap> ? X & U : X>, type?: string): void;
    };
} & C;

// @public
export class Matrix3x3 extends VectorBase {
    constructor(m00: number, m10: number, m20: number, m01: number, m11: number, m21: number, m02: number, m12: number, m22: number);
    constructor(elements: number[]);
    constructor(array: Float32Array);
    constructor(buffer: ArrayBuffer, offset: number);
    constructor();
    static add(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    addBy(other: Matrix3x3): Matrix3x3;
    clone(): Matrix3x3;
    static div(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    divBy(other: Matrix3x3): Matrix3x3;
    getCol(col: number, result?: Vector3): Vector3;
    getRow(row: number, result?: Vector3): Vector3;
    static identity(result?: Matrix3x3): Matrix3x3;
    identity(): Matrix3x3;
    inplaceInvert(): Matrix3x3;
    static invert(matrix: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    get m00(): number;
    set m00(v: number);
    get m01(): number;
    set m01(v: number);
    get m02(): number;
    set m02(v: number);
    get m10(): number;
    set m10(v: number);
    get m11(): number;
    set m11(v: number);
    get m12(): number;
    set m12(v: number);
    get m20(): number;
    set m20(v: number);
    get m21(): number;
    set m21(v: number);
    get m22(): number;
    set m22(v: number);
    static mul(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    mulBy(other: Matrix3x3): Matrix3x3;
    static multiply(m1: Matrix3x3, m2: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    multiplyLeft(other: Matrix3x3): Matrix3x3;
    multiplyRight(other: Matrix3x3): Matrix3x3;
    static rotation(axis: Vector3, angle: number, result?: Matrix3x3): Matrix3x3;
    rotation(axis: Vector3, angle: number): Matrix3x3;
    static rotationX(angle: number, result?: Matrix3x3): Matrix3x3;
    rotationX(angle: number): Matrix3x3;
    static rotationY(angle: number, result?: Matrix3x3): Matrix3x3;
    rotationY(angle: number): Matrix3x3;
    static rotationZ(angle: number, result?: Matrix3x3): Matrix3x3;
    rotationZ(angle: number): Matrix3x3;
    static scale(a: Matrix3x3, f: number, result?: Matrix3x3): Matrix3x3;
    scaleBy(f: number): Matrix3x3;
    setCol(col: number, v: Vector3): this;
    setColXYZ(col: number, x: number, y: number, z: number): this;
    setRow(row: number, v: Vector3): this;
    setRowXYZ(row: number, x: number, y: number, z: number): this;
    static sub(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    subBy(other: Matrix3x3): Matrix3x3;
    transform(vec: Vector3, result?: Vector3): Vector3;
    transformPoint(vec: Vector3, result?: Vector3): Vector3;
    transformVector(vec: Vector3, result?: Vector3): Vector3;
    static transpose(matrix: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    transpose(): Matrix3x3;
}

// @public
export class Matrix4x4 extends VectorBase {
    constructor(m00: number, m10: number, m20: number, m30: number, m01: number, m11: number, m21: number, m31: number, m02: number, m12: number, m22: number, m32: number, m03: number, m13: number, m23: number, m33: number);
    constructor(elements: number[]);
    constructor(array: Float32Array);
    constructor(buffer: ArrayBuffer, offset: number);
    constructor();
    static add(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    addBy(other: Matrix4x4): Matrix4x4;
    clone(): Matrix4x4;
    decompose(scale?: Vector3, rotation?: Quaternion | Matrix3x3 | Matrix4x4, translation?: Vector3): this;
    decomposeLookAt(eye?: Vector3, target?: Vector3, up?: Vector3): this;
    det(): number;
    static div(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    divBy(other: Matrix4x4): Matrix4x4;
    static frustum(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result?: Matrix4x4): Matrix4x4;
    frustum(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix4x4;
    getAspect(): number;
    getBottomPlane(): number;
    getCol(col: number, result?: Vector4): Vector4;
    getFarPlane(): number;
    getFarPlaneHeight(): number;
    getFarPlaneWidth(): number;
    getFov(): number;
    getLeftPlane(): number;
    getNearPlane(): number;
    getNearPlaneHeight(): number;
    getNearPlaneWidth(): number;
    getRightPlane(): number;
    getRow(row: number, result?: Vector4): Vector4;
    getTanHalfFov(): number;
    getTopPlane(): number;
    static identity(result?: Matrix4x4): Matrix4x4;
    identity(): Matrix4x4;
    inplaceInvert(): Matrix4x4;
    inplaceInvertAffine(): Matrix4x4;
    static invert(matrix: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static invertAffine(matrix: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    isOrtho(): boolean;
    isPerspective(): boolean;
    static lookAt(eye: Vector3, target: Vector3, up: Vector3, result?: Matrix4x4): Matrix4x4;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4x4;
    static lookAtCubeFace(face: CubeFace, pos: Vector3, result?: Matrix4x4): Matrix4x4;
    get m00(): number;
    set m00(v: number);
    get m01(): number;
    set m01(v: number);
    get m02(): number;
    set m02(v: number);
    get m03(): number;
    set m03(v: number);
    get m10(): number;
    set m10(v: number);
    get m11(): number;
    set m11(v: number);
    get m12(): number;
    set m12(v: number);
    get m13(): number;
    set m13(v: number);
    get m20(): number;
    set m20(v: number);
    get m21(): number;
    set m21(v: number);
    get m22(): number;
    set m22(v: number);
    get m23(): number;
    set m23(v: number);
    get m30(): number;
    set m30(v: number);
    get m31(): number;
    set m31(v: number);
    get m32(): number;
    set m32(v: number);
    get m33(): number;
    set m33(v: number);
    static mul(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    mulBy(other: Matrix4x4): Matrix4x4;
    static multiply(m1: Matrix4x4, m2: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static multiplyAffine(m1: Matrix4x4, m2: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    multiplyLeft(other: Matrix4x4): Matrix4x4;
    multiplyLeftAffine(other: Matrix4x4): Matrix4x4;
    multiplyRight(other: Matrix4x4): Matrix4x4;
    multiplyRightAffine(other: Matrix4x4): Matrix4x4;
    // (undocumented)
    static obliquePerspective(perspectiveMatrix: Matrix4x4, nearPlane: Vector4): Matrix4x4;
    // (undocumented)
    static obliqueProjection(projectionMatrix: Matrix4x4, clipPlane: Plane): Matrix4x4;
    static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number, result?: Matrix4x4): Matrix4x4;
    ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4x4;
    static perspective(fovY: number, aspect: number, znear: number, zfar: number, result?: Matrix4x4): Matrix4x4;
    perspective(fovY: number, aspect: number, znear: number, zfar: number): Matrix4x4;
    static reflection(nx: number, ny: number, nz: number, d: number, result?: Matrix4x4): Matrix4x4;
    static rotateLeft(m: Matrix4x4, r: Matrix3x3 | Matrix4x4 | Quaternion, result?: Matrix4x4): Matrix4x4;
    rotateLeft(r: Matrix3x3 | Matrix4x4 | Quaternion): Matrix4x4;
    static rotateRight(m: Matrix4x4, r: Matrix3x3 | Matrix4x4 | Quaternion, result?: Matrix4x4): Matrix4x4;
    rotateRight(r: Matrix3x3 | Matrix4x4 | Quaternion): Matrix4x4;
    static rotation(axis: Vector3, angle: number, result?: Matrix4x4): Matrix4x4;
    rotation(axis: Vector3, angle: number): Matrix4x4;
    static rotationX(angle: number, result?: Matrix4x4): Matrix4x4;
    rotationX(angle: number): Matrix4x4;
    static rotationY(angle: number, result?: Matrix4x4): Matrix4x4;
    rotationY(angle: number): Matrix4x4;
    static rotationZ(angle: number, result?: Matrix4x4): Matrix4x4;
    rotationZ(angle: number): Matrix4x4;
    static scale(a: Matrix4x4, f: number, result?: Matrix4x4): Matrix4x4;
    scaleBy(f: number): Matrix4x4;
    static scaleLeft(m: Matrix4x4, s: Vector3, result?: Matrix4x4): Matrix4x4;
    scaleLeft(s: Vector3): Matrix4x4;
    static scaleRight(m: Matrix4x4, s: Vector3, result?: Matrix4x4): Matrix4x4;
    scaleRight(s: Vector3): Matrix4x4;
    static scaling(s: Vector3, result?: Matrix4x4): Matrix4x4;
    scaling(s: Vector3): Matrix4x4;
    setCol(col: number, v: Vector4): this;
    setColXYZW(col: number, x: number, y: number, z: number, w: number): this;
    setNearFar(znear: number, zfar: number): this;
    setRow(row: number, v: Vector4): this;
    setRowXYZW(row: number, x: number, y: number, z: number, w: number): this;
    static sub(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    subBy(other: Matrix4x4): Matrix4x4;
    transform(vec: Vector4, result?: Vector4): Vector4;
    transformAffine(vec: Vector4, result?: Vector4): Vector4;
    transformPoint(point: Vector3, result?: Vector4): Vector4;
    transformPointAffine(point: Vector3, result?: Vector3): Vector3;
    transformPointP(point: Vector3, result?: Vector3): Vector3;
    transformVector(vec: Vector3, result?: Vector4): Vector4;
    transformVectorAffine(vec: Vector3, result?: Vector3): Vector3;
    static translateLeft(m: Matrix4x4, t: Vector3, result?: Matrix4x4): Matrix4x4;
    translateLeft(t: Vector3): Matrix4x4;
    static translateRight(m: Matrix4x4, t: Vector3, result?: Matrix4x4): Matrix4x4;
    translateRight(t: Vector3): Matrix4x4;
    static translation(t: Vector3, result?: Matrix4x4): Matrix4x4;
    translation(t: Vector3): Matrix4x4;
    static transpose(matrix: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    transpose(): Matrix4x4;
}

// @public
export function nextPowerOf2(value: number): number;

// @public
export class ObservableQuaternion extends Quaternion {
    get callback(): () => void;
    set callback(cb: () => void);
    copyWithin(target: number, start: number, end?: number): this;
    fill(value: number, start?: number, end?: number): this;
    reverse(): Float32Array;
    set(array: ArrayLike<number>, offset?: number): void;
    setXYZW(x: number, y: number, z: number, w: number): this;
    sort(compareFn?: (a: number, b: number) => number): this;
    get w(): number;
    set w(val: number);
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
}

// @public
export class ObservableVector2 extends Vector2 {
    get callback(): () => void;
    set callback(cb: () => void);
    copyWithin(target: number, start: number, end?: number): this;
    fill(value: number, start?: number, end?: number): this;
    reverse(): Float32Array;
    set(array: ArrayLike<number>, offset?: number): void;
    setXY(x: number, y: number): this;
    sort(compareFn?: (a: number, b: number) => number): this;
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
}

// @public
export class ObservableVector3 extends Vector3 {
    get callback(): () => void;
    set callback(cb: () => void);
    copyWithin(target: number, start: number, end?: number): this;
    fill(value: number, start?: number, end?: number): this;
    reverse(): Float32Array;
    set(array: ArrayLike<number>, offset?: number): void;
    setXYZ(x: number, y: number, z: number): this;
    sort(compareFn?: (a: number, b: number) => number): this;
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
}

// @public
export class ObservableVector4 extends Vector4 {
    get callback(): () => void;
    set callback(cb: () => void);
    copyWithin(target: number, start: number, end?: number): this;
    fill(value: number, start?: number, end?: number): this;
    reverse(): Float32Array;
    set(array: ArrayLike<number>, offset?: number): void;
    setXYZW(x: number, y: number, z: number, w: number): this;
    sort(compareFn?: (a: number, b: number) => number): this;
    get w(): number;
    set w(val: number);
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
}

// @public
export function packFloat3(a: number, b: number, c: number): number;

// @public
export type PackRect = {
    x: number;
    y: number;
    width: number;
    height: number;
    binIndex: number;
};

// @public
export function parseColor(input: string): ColorRGBA;

// @public
export class Plane extends VectorBase {
    constructor();
    constructor(a: number, b: number, c: number, d: number);
    constructor(other: Plane);
    constructor(origin: Vector3, normal: Vector3);
    constructor(p0: Vector3, p1: Vector3, p2: Vector3);
    get a(): number;
    set a(val: number);
    assign(other: ArrayLike<number>): this;
    get b(): number;
    set b(val: number);
    get c(): number;
    set c(val: number);
    get d(): number;
    set d(val: number);
    distanceToPoint(p: Vector3): number;
    static flip(plane: Plane, result?: Plane): Plane;
    getNormal(result?: Vector3): Vector3;
    initWithOriginNormal(origin: Vector3, normal: Vector3): this;
    initWithPoints(p0: Vector3, p1: Vector3, p2: Vector3): this;
    inplaceFlip(): Plane;
    inplaceNormalize(): Plane;
    nearestPointToPoint(p: Vector3, result?: Vector3): Vector3;
    static normalize(plane: Plane, result?: Plane): Plane;
    setEquation(a: number, b: number, c: number, d: number): this;
    static transform(plane: Plane, matrix: Matrix4x4, result?: Plane): Plane;
}

// @public
export class PRNG {
    constructor(seed?: number);
    get(): number;
}

// @public
export class Quaternion extends VectorBase {
    constructor(x: number, y: number, z: number, w: number);
    constructor(elements: number[]);
    constructor(array: Float32Array);
    constructor(buffer: ArrayBuffer, offset: number);
    constructor();
    static angleBetween(a: Quaternion, b: Quaternion): number;
    clone(): Quaternion;
    static conjugate(q: Quaternion, result?: Quaternion): Quaternion;
    static dot(a: Quaternion, b: Quaternion): number;
    fromAxisAngle(axis: Vector3, angle: number): Quaternion;
    static fromAxisAngle(axis: Vector3, angle: number, result?: Quaternion): Quaternion;
    fromEulerAngle(x: number, y: number, z: number, order: 'XYZ' | 'YXZ' | 'ZXY' | 'ZYX' | 'YZX' | 'XZY'): Quaternion;
    static fromEulerAngle(a: number, b: number, c: number, order: 'XYZ' | 'YXZ' | 'ZXY' | 'ZYX' | 'YZX' | 'XZY', result?: Quaternion): Quaternion;
    fromRotationMatrix(matrix: Matrix3x3 | Matrix4x4): Quaternion;
    static fromRotationMatrix(matrix: Matrix3x3 | Matrix4x4, result?: Quaternion): Quaternion;
    getAxisAngle(result?: Vector4): Vector4;
    getDirectionX(result?: Vector3): Vector3;
    getDirectionY(result?: Vector3): Vector3;
    getDirectionZ(result?: Vector3): Vector3;
    identity(): Quaternion;
    static identity(q?: Quaternion): Quaternion;
    inplaceConjugate(): Quaternion;
    inplaceNormalize(): Quaternion;
    get magnitude(): number;
    get magnitudeSq(): number;
    static multiply(a: Quaternion, b: Quaternion, result?: Quaternion): Quaternion;
    multiplyLeft(other: Quaternion): Quaternion;
    multiplyRight(other: Quaternion): Quaternion;
    static normalize(q: Quaternion, result?: Quaternion): Quaternion;
    static scale(q: Quaternion, t: number, result?: Quaternion): Quaternion;
    scaleBy(f: number): Quaternion;
    setAndNormalize(x: number, y: number, z: number, w: number): Quaternion;
    setXYZW(x: number, y: number, z: number, w: number): Quaternion;
    static slerp(a: Quaternion, b: Quaternion, t: number, result?: Quaternion): Quaternion;
    toAxisAngle(axis: Vector3): number;
    toEulerAngles(angles?: Vector3): Vector3;
    toMatrix3x3(matrix?: Matrix3x3): Matrix3x3;
    toMatrix4x4(matrix?: Matrix4x4): Matrix4x4;
    transform(v: Vector3, result?: Vector3): Vector3;
    unitVectorToUnitVector(from: Vector3, to: Vector3): Quaternion;
    static unitVectorToUnitVector(from: Vector3, to: Vector3, result?: Quaternion): Quaternion;
    get w(): number;
    set w(v: number);
    get x(): number;
    set x(v: number);
    get y(): number;
    set y(v: number);
    get z(): number;
    set z(v: number);
}

// @public
export class Ray {
    constructor(origin?: Vector3, directionNormalized?: Vector3);
    bboxIntersectionTest: (bbox: AABB) => boolean;
    bboxIntersectionTestEx: (bbox: AABB) => number | null;
    get direction(): Vector3;
    intersectionTestTriangle(v1: Vector3, v2: Vector3, v3: Vector3, cull: boolean): number | null;
    get origin(): Vector3;
    set(origin: Vector3, directionNormalized: Vector3): void;
    transform(matrix: Matrix4x4, other?: Ray): Ray;
}

// @public
export class RectsPacker {
    constructor(width: number, height: number, maxBins?: number);
    clear(): void;
    insert(width: number, height: number): PackRect;
}

// @public
export type REventHandlerOptions = {
    once?: boolean;
    context?: unknown;
};

// @public
export class SH {
    static evalBasis(direction: Vector3, order: number): number[];
    static evalDirectionLight(direction: Vector3, color: Vector3, order: number): Vector3[];
    static readonly MAX_ORDER = 3;
    static readonly MIN_ORDER = 2;
}

// @public
export function toFloat(val: number): number;

// @public
export interface Tuple2 {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export interface Tuple3 {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    z: number;
}

// @public
export interface Tuple4 {
    // (undocumented)
    w: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    z: number;
}

// @public
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;

// @public
export type TypedArrayConstructor<T extends TypedArray = any> = {
    new (): T;
    new (size: number): T;
    new (elements: number[]): T;
    new (buffer: ArrayBuffer): T;
    new (buffer: ArrayBuffer, byteOffset: number): T;
    new (buffer: ArrayBuffer, byteOffset: number, length: number): T;
    BYTES_PER_ELEMENT: number;
};

// @public
export function unpackFloat3<T extends Number[] | Float32Array>(pk: number, result: T): void;

// @public
export class Vector2 extends VectorBase {
    constructor(x: number, y: number);
    constructor(elements: number[]);
    constructor(array: Float32Array);
    constructor(buffer: ArrayBuffer, offset: number);
    constructor();
    static abs(a: Vector2, result?: Vector2): Vector2;
    static add(a: Vector2, b: Vector2, result?: Vector2): Vector2;
    addBy(other: Vector2): Vector2;
    static axisNX(): Vector2;
    static axisNY(): Vector2;
    static axisPX(): Vector2;
    static axisPY(): Vector2;
    clone(): Vector2;
    static cross(a: Vector2, b: Vector2): number;
    static distance(v1: Vector2, v2: Vector2): number;
    static distanceSq(v1: Vector2, v2: Vector2): number;
    static div(a: Vector2, b: Vector2, result?: Vector2): Vector2;
    divBy(other: Vector2): Vector2;
    static dot(a: Vector2, b: Vector2): number;
    inplaceInverse(): Vector2;
    inplaceMax(other: Vector2): Vector2;
    inplaceMin(other: Vector2): Vector2;
    inplaceNormalize(): Vector2;
    static inverse(v: Vector2, result?: Vector2): Vector2;
    get magnitude(): number;
    get magnitudeSq(): number;
    static max(a: Vector2, b: Vector2, result?: Vector2): Vector2;
    static min(a: Vector2, b: Vector2, result?: Vector2): Vector2;
    static mul(a: Vector2, b: Vector2, result?: Vector2): Vector2;
    mulBy(other: Vector2): Vector2;
    static normalize(v: Vector2, result?: Vector2): Vector2;
    static one(): Vector2;
    static scale(a: Vector2, b: number, result?: Vector2): Vector2;
    scaleBy(f: number): Vector2;
    setAndNormalize(x: number, y: number): this;
    setXY(x: number, y: number): this;
    static sub(a: Vector2, b: Vector2, result?: Vector2): Vector2;
    subBy(other: Vector2): Vector2;
    get x(): number;
    set x(v: number);
    get y(): number;
    set y(v: number);
    static zero(): Vector2;
}

// @public
export class Vector3 extends VectorBase {
    constructor(x: number, y: number, z: number);
    constructor(elements: number[]);
    constructor(array: Float32Array);
    constructor(buffer: ArrayBuffer, offset: number);
    constructor();
    static abs(a: Vector3, result?: Vector3): Vector3;
    static add(a: Vector3, b: Vector3, result?: Vector3): Vector3;
    addBy(other: Vector3): Vector3;
    static axisNX(): Vector3;
    static axisNY(): Vector3;
    static axisNZ(): Vector3;
    static axisPX(): Vector3;
    static axisPY(): Vector3;
    static axisPZ(): Vector3;
    clone(): Vector3;
    static cross(a: Vector3, b: Vector3, result?: Vector3): Vector3;
    static distance(v1: Vector3, v2: Vector3): number;
    static distanceSq(v1: Vector3, v2: Vector3): number;
    static div(a: Vector3, b: Vector3, result?: Vector3): Vector3;
    divBy(other: Vector3): Vector3;
    static dot(a: Vector3, b: Vector3): number;
    inplaceInverse(): Vector3;
    inplaceMax(other: Vector3): Vector3;
    inplaceMin(other: Vector3): Vector3;
    inplaceNormalize(): Vector3;
    static inverse(v: Vector3, result?: Vector3): Vector3;
    get magnitude(): number;
    get magnitudeSq(): number;
    static max(a: Vector3, b: Vector3, result?: Vector3): Vector3;
    static min(a: Vector3, b: Vector3, result?: Vector3): Vector3;
    static mul(a: Vector3, b: Vector3, result?: Vector3): Vector3;
    mulBy(other: Vector3): Vector3;
    static normalize(v: Vector3, result?: Vector3): Vector3;
    static one(): Vector3;
    static scale(a: Vector3, b: number, result?: Vector3): Vector3;
    scaleBy(f: number): Vector3;
    setAndNormalize(x: number, y: number, z: number): Vector3;
    setXYZ(x: number, y: number, z: number): Vector3;
    static sub(a: Vector3, b: Vector3, result?: Vector3): Vector3;
    subBy(other: Vector3): Vector3;
    get x(): number;
    set x(v: number);
    xy(): Vector2;
    get y(): number;
    set y(v: number);
    get z(): number;
    set z(v: number);
    static zero(): Vector3;
}

// @public
export class Vector4 extends VectorBase {
    constructor(x: number, y: number, z: number, w: number);
    constructor(elements: number[]);
    constructor(array: Float32Array);
    constructor(buffer: ArrayBuffer, offset: number);
    constructor();
    static abs(a: Vector4, result?: Vector4): Vector4;
    static add(a: Vector4, b: Vector4, result?: Vector4): Vector4;
    addBy(other: Vector4): Vector4;
    static axisNW(): Vector4;
    static axisNX(): Vector4;
    static axisNY(): Vector4;
    static axisNZ(): Vector4;
    static axisPW(): Vector4;
    static axisPX(): Vector4;
    static axisPY(): Vector4;
    static axisPZ(): Vector4;
    clone(): Vector4;
    static div(a: Vector4, b: Vector4, result?: Vector4): Vector4;
    divBy(other: Vector4): Vector4;
    static dot(a: Vector4, b: Vector4): number;
    inplaceInverse(): Vector4;
    inplaceMax(other: Vector4): Vector4;
    inplaceMin(other: Vector4): Vector4;
    inplaceNormalize(): Vector4;
    static inverse(v: Vector4, result?: Vector4): Vector4;
    get magnitude(): number;
    get magnitudeSq(): number;
    static max(a: Vector4, b: Vector4, result?: Vector4): Vector4;
    static min(a: Vector4, b: Vector4, result?: Vector4): Vector4;
    static mul(a: Vector4, b: Vector4, result?: Vector4): Vector4;
    mulBy(other: Vector4): Vector4;
    static normalize(v: Vector4, result?: Vector4): Vector4;
    static one(): Vector4;
    static scale(a: Vector4, b: number, result?: Vector4): Vector4;
    scaleBy(f: number): Vector4;
    setAndNormalize(x: number, y: number, z: number, w: number): Vector4;
    setXYZW(x: number, y: number, z: number, w: number): Vector4;
    static sub(a: Vector4, b: Vector4, result?: Vector4): Vector4;
    subBy(other: Vector4): Vector4;
    get w(): number;
    set w(v: number);
    get x(): number;
    set x(v: number);
    xy(): Vector2;
    xyz(): Vector3;
    get y(): number;
    set y(v: number);
    get z(): number;
    set z(v: number);
    static zero(): Vector4;
}

// @public
export class VectorBase extends Float32Array {
    equalsTo(other: Float32Array, epsl?: number): boolean;
    isNaN(): boolean;
    toString(): string;
}

// (No @packageDocumentation comment for this package)

```
