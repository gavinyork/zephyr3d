## API Report File for "@zephyr3d/device"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CubeFace } from '@zephyr3d/base';
import { IEventTarget } from '@zephyr3d/base';
import { TypedArray } from '@zephyr3d/base';
import { Vector4 } from '@zephyr3d/base';
import { VectorBase } from '@zephyr3d/base';

// @public
export interface AbstractDevice extends IEventTarget<DeviceEventMap> {
    beginCapture(): void;
    beginFrame(): boolean;
    buildComputeProgram(options: PBComputeOptions): GPUProgram;
    buildRenderProgram(options: PBRenderOptions): GPUProgram;
    canvas: HTMLCanvasElement;
    clearFrameBuffer(clearColor: Vector4, clearDepth: number, clearStencil: number): any;
    compute(workgroupCountX: number, workgroupCountY: number, workgroupCountZ: number): void;
    createBindGroup(layout: BindGroupLayout): BindGroup;
    createBuffer(sizeInBytes: number, options: BufferCreationOptions): GPUDataBuffer;
    createCubeTexture(format: TextureFormat, size: number, options?: TextureCreationOptions): TextureCube;
    createCubeTextureFromMipmapData(data: TextureMipmapData, sRGB: boolean, options?: TextureCreationOptions): TextureCube;
    createFrameBuffer(colorAttachments: BaseTexture[], depthAttachment: BaseTexture, options?: FrameBufferOptions): FrameBuffer;
    createGPUProgram(params: GPUProgramConstructParams): GPUProgram;
    createIndexBuffer(data: Uint16Array | Uint32Array, options?: BufferCreationOptions): IndexBuffer;
    createInterleavedVertexBuffer(attribFormats: VertexAttribFormat[], data: TypedArray, options?: BufferCreationOptions): StructuredBuffer;
    createRenderStateSet(): RenderStateSet;
    createSampler(options: SamplerOptions): TextureSampler;
    createStructuredBuffer(structureType: PBStructTypeInfo, options: BufferCreationOptions, data?: TypedArray): StructuredBuffer;
    createTexture2D(format: TextureFormat, width: number, height: number, options?: TextureCreationOptions): Texture2D;
    createTexture2DArray(format: TextureFormat, width: number, height: number, depth: number, options?: TextureCreationOptions): Texture2DArray;
    createTexture2DArrayFromImages(elements: TextureImageElement[], sRGB: boolean, options?: TextureCreationOptions): Texture2DArray;
    createTexture2DArrayFromMipmapData(data: TextureMipmapData, options?: TextureCreationOptions): Texture2DArray;
    createTexture2DFromImage(element: TextureImageElement, sRGB: boolean, options?: TextureCreationOptions): Texture2D;
    createTexture2DFromMipmapData(data: TextureMipmapData, sRGB: boolean, options?: TextureCreationOptions): Texture2D;
    createTexture3D(format: TextureFormat, width: number, height: number, depth: number, options?: TextureCreationOptions): Texture3D;
    createTextureFromMipmapData<T extends BaseTexture = BaseTexture>(data: TextureMipmapData, sRGB: boolean, options?: TextureCreationOptions): T;
    createTextureVideo(el: HTMLVideoElement, samplerOptions?: SamplerOptions): TextureVideo;
    createVertexBuffer(attribFormat: VertexAttribFormat, data: TypedArray, options?: BufferCreationOptions): StructuredBuffer;
    createVertexLayout(options: VertexLayoutOptions): VertexLayout;
    deviceToScreen(val: number): number;
    draw(primitiveType: PrimitiveType, first: number, count: number): void;
    drawInstanced(primitiveType: PrimitiveType, first: number, count: number, numInstances: number): void;
    drawText(text: string, x: number, y: number, color: string): any;
    endCapture(): RenderBundle;
    endFrame(): void;
    executeRenderBundle(renderBundle: RenderBundle): any;
    exitLoop(): void;
    flush(): void;
    frameInfo: FrameInfo;
    getBackBufferHeight(): number;
    getBackBufferWidth(): number;
    getBindGroup(index: number): [BindGroup, Iterable<number>];
    getDeviceCaps(): DeviceCaps;
    getDrawingBufferHeight(): number;
    getDrawingBufferWidth(): number;
    getFramebuffer(): FrameBuffer;
    getFrameBufferSampleCount(): number;
    getGPUObjectById(uid: number): GPUObject;
    getGPUObjects(): GPUObjectList;
    getProgram(): GPUProgram;
    getRenderStates(): RenderStateSet;
    getScale(): number;
    getScissor(): DeviceViewport;
    getVertexAttribFormat(semantic: VertexSemantic, dataType: DataType, componentCount: number): VertexAttribFormat;
    getVertexLayout(): VertexLayout;
    getViewport(): DeviceViewport;
    isContextLost(): boolean;
    isRendering: boolean;
    isWindingOrderReversed(): boolean;
    popDeviceStates(): any;
    programBuilder: ProgramBuilder;
    pushDeviceStates(): any;
    readPixels(index: number, x: number, y: number, w: number, h: number, buffer: TypedArray): Promise<void>;
    readPixelsToBuffer(index: number, x: number, y: number, w: number, h: number, buffer: GPUDataBuffer): void;
    reverseVertexWindingOrder(reverse: boolean): void;
    runLoop(func: (device: AbstractDevice) => void): void;
    runLoopFunction: (device: AbstractDevice) => void;
    runNextFrame(f: () => void): void;
    screenToDevice(val: number): number;
    setBindGroup(index: number, bindGroup: BindGroup, dynamicOffsets?: Iterable<number>): any;
    setFont(fontName: string): any;
    setFramebuffer(rt: FrameBuffer): void;
    setProgram(program: GPUProgram): void;
    setRenderStates(renderStates: RenderStateSet): void;
    setScissor(scissor?: DeviceViewport | number[]): void;
    setVertexLayout(vertexData: VertexLayout): void;
    setViewport(vp?: DeviceViewport | number[]): void;
    type: string;
    videoMemoryUsage: number;
}

// @public
export interface ArrayTypeDetail {
    dimension: number;
    elementType: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo | PBAnyTypeInfo;
}

// @public
export interface AtlasInfo {
    // (undocumented)
    atlasIndex: number;
    // (undocumented)
    height: number;
    // (undocumented)
    uMax: number;
    // (undocumented)
    uMin: number;
    // (undocumented)
    vMax: number;
    // (undocumented)
    vMin: number;
    // (undocumented)
    width: number;
}

// @public
export interface AtomicTypeInfoDetail {
    type: PBPrimitiveType;
}

// @public
export interface BaseCreationOptions {
    dynamic?: boolean;
}

// @public
export abstract class BaseDevice {
    constructor(cvs: HTMLCanvasElement, backend: DeviceBackend);
    // (undocumented)
    addGPUObject(obj: GPUObject): void;
    // (undocumented)
    get backend(): DeviceBackend;
    // (undocumented)
    protected _backend: DeviceBackend;
    // (undocumented)
    abstract beginCapture(): void;
    // (undocumented)
    beginFrame(): boolean;
    // (undocumented)
    protected _beginFrameCounter: number;
    // (undocumented)
    protected _beginFrameTime: number;
    // (undocumented)
    buildComputeProgram(options: PBComputeOptions): GPUProgram;
    // (undocumented)
    buildRenderProgram(options: PBRenderOptions): GPUProgram;
    // (undocumented)
    get canvas(): HTMLCanvasElement;
    // (undocumented)
    protected _canvas: HTMLCanvasElement;
    // (undocumented)
    protected _canvasClientHeight: number;
    // (undocumented)
    protected _canvasClientWidth: number;
    // (undocumented)
    abstract clearFrameBuffer(clearColor: Vector4, clearDepth: number, clearStencil: number): any;
    // (undocumented)
    compute(workgroupCountX: any, workgroupCountY: any, workgroupCountZ: any): void;
    // (undocumented)
    protected abstract _compute(workgroupCountX: number, workgroupCountY: number, workgroupCountZ: number): void;
    // (undocumented)
    protected _cpuTimer: CPUTimer;
    // (undocumented)
    abstract createBindGroup(layout: BindGroupLayout): BindGroup;
    // (undocumented)
    abstract createBuffer(sizeInBytes: number, options: BufferCreationOptions): GPUDataBuffer;
    // (undocumented)
    abstract createCubeTexture(format: TextureFormat, size: number, options?: TextureCreationOptions): TextureCube;
    // (undocumented)
    abstract createCubeTextureFromMipmapData(data: TextureMipmapData, sRGB: boolean, options?: TextureCreationOptions): TextureCube;
    // (undocumented)
    abstract createFrameBuffer(colorAttachments: BaseTexture[], depthAttachment: BaseTexture, options?: FrameBufferOptions): FrameBuffer;
    // (undocumented)
    abstract createGPUProgram(params: GPUProgramConstructParams): GPUProgram;
    // (undocumented)
    abstract createGPUTimer(): ITimer;
    // (undocumented)
    abstract createIndexBuffer(data: Uint16Array | Uint32Array, options?: BufferCreationOptions): IndexBuffer;
    // (undocumented)
    createInterleavedVertexBuffer(attribFormats: VertexAttribFormat[], data: TypedArray, options?: BufferCreationOptions): StructuredBuffer;
    // (undocumented)
    abstract createRenderStateSet(): RenderStateSet;
    // (undocumented)
    abstract createSampler(options: SamplerOptions): TextureSampler;
    // (undocumented)
    abstract createStructuredBuffer(structureType: PBStructTypeInfo, options: BufferCreationOptions, data?: TypedArray): StructuredBuffer;
    // (undocumented)
    abstract createTexture2D(format: TextureFormat, width: number, height: number, options?: TextureCreationOptions): Texture2D;
    // (undocumented)
    abstract createTexture2DArray(format: TextureFormat, width: number, height: number, depth: number, options?: TextureCreationOptions): Texture2DArray;
    // (undocumented)
    abstract createTexture2DArrayFromImages(elements: TextureImageElement[], sRGB: boolean, options?: TextureCreationOptions): Texture2DArray;
    // (undocumented)
    abstract createTexture2DArrayFromMipmapData(data: TextureMipmapData, options?: TextureCreationOptions): Texture2DArray;
    // (undocumented)
    abstract createTexture2DFromImage(element: TextureImageElement, sRGB: boolean, options?: TextureCreationOptions): Texture2D;
    // (undocumented)
    abstract createTexture2DFromMipmapData(data: TextureMipmapData, sRGB: boolean, options?: TextureCreationOptions): Texture2D;
    // (undocumented)
    abstract createTexture3D(format: TextureFormat, width: number, height: number, depth: number, options?: TextureCreationOptions): Texture3D;
    // (undocumented)
    abstract createTextureFromMipmapData<T extends BaseTexture>(data: TextureMipmapData, sRGB: boolean, options?: TextureCreationOptions): T;
    // (undocumented)
    abstract createTextureVideo(el: HTMLVideoElement, samplerOptions?: SamplerOptions): TextureVideo;
    // (undocumented)
    createVertexBuffer(attribFormat: VertexAttribFormat, data: TypedArray, options?: BufferCreationOptions): StructuredBuffer;
    // (undocumented)
    abstract createVertexLayout(options: VertexLayoutOptions): VertexLayout;
    // (undocumented)
    deviceToScreen(val: number): number;
    // (undocumented)
    disposeObject(obj: GPUObject, remove?: boolean): void;
    // (undocumented)
    protected _disposeObjectList: GPUObject[];
    // (undocumented)
    draw(primitiveType: PrimitiveType, first: number, count: number): void;
    // (undocumented)
    protected abstract _draw(primitiveType: PrimitiveType, first: number, count: number): void;
    // (undocumented)
    drawInstanced(primitiveType: PrimitiveType, first: number, count: number, numInstances: number): void;
    // (undocumented)
    protected abstract _drawInstanced(primitiveType: PrimitiveType, first: number, count: number, numInstances: number): void;
    // (undocumented)
    drawText(text: string, x: number, y: number, color: string): void;
    // (undocumented)
    enableGPUTimeRecording(enable: boolean): void;
    // (undocumented)
    abstract endCapture(): RenderBundle;
    // (undocumented)
    endFrame(): void;
    // (undocumented)
    protected _endFrameTime: number;
    // (undocumented)
    abstract executeRenderBundle(renderBundle: RenderBundle): any;
    // (undocumented)
    exitLoop(): void;
    // (undocumented)
    abstract flush(): void;
    // (undocumented)
    protected _fpsCounter: {
        time: number;
        frame: number;
    };
    // (undocumented)
    get frameInfo(): FrameInfo;
    // (undocumented)
    protected _frameInfo: FrameInfo;
    // (undocumented)
    abstract getBackBufferHeight(): number;
    // (undocumented)
    abstract getBackBufferWidth(): number;
    // (undocumented)
    abstract getBindGroup(index: number): [BindGroup, Iterable<number>];
    // (undocumented)
    abstract getDeviceCaps(): DeviceCaps;
    // (undocumented)
    abstract getDrawingBufferHeight(): number;
    // (undocumented)
    abstract getDrawingBufferWidth(): number;
    // (undocumented)
    abstract getFramebuffer(): FrameBuffer;
    // (undocumented)
    abstract getFrameBufferSampleCount(): number;
    // (undocumented)
    getGPUObjectById(uid: number): GPUObject;
    // (undocumented)
    getGPUObjects(): GPUObjectList;
    // (undocumented)
    abstract getProgram(): GPUProgram;
    // (undocumented)
    abstract getRenderStates(): RenderStateSet;
    // (undocumented)
    abstract getScale(): number;
    // (undocumented)
    abstract getScissor(): DeviceViewport;
    // (undocumented)
    getVertexAttribFormat(semantic: VertexSemantic, dataType: DataType, componentCount: number): VertexAttribFormat;
    // (undocumented)
    abstract getVertexLayout(): VertexLayout;
    // (undocumented)
    abstract getViewport(): DeviceViewport;
    // (undocumented)
    protected _gpuMemCost: number;
    // (undocumented)
    protected _gpuObjectList: GPUObjectList;
    // (undocumented)
    protected _gpuTimer: ITimer;
    // (undocumented)
    abstract initContext(): Promise<void>;
    // (undocumented)
    protected invalidateAll(): void;
    // (undocumented)
    abstract isContextLost(): boolean;
    // (undocumented)
    get isRendering(): boolean;
    // (undocumented)
    abstract isWindingOrderReversed(): boolean;
    // (undocumented)
    abstract looseContext(): void;
    // (undocumented)
    protected abstract onBeginFrame(): boolean;
    // (undocumented)
    protected abstract onEndFrame(): void;
    // (undocumented)
    protected parseBufferOptions(options: BufferCreationOptions, defaultUsage?: BufferUsage): number;
    // (undocumented)
    protected parseTextureOptions(options?: TextureCreationOptions): number;
    // (undocumented)
    popDeviceStates(): void;
    // (undocumented)
    get programBuilder(): ProgramBuilder;
    // (undocumented)
    protected _programBuilder: ProgramBuilder;
    // (undocumented)
    pushDeviceStates(): void;
    // (undocumented)
    abstract readPixels(index: number, x: number, y: number, w: number, h: number, buffer: TypedArray): Promise<void>;
    // (undocumented)
    abstract readPixelsToBuffer(index: number, x: number, y: number, w: number, h: number, buffer: GPUDataBuffer): void;
    // (undocumented)
    protected reloadAll(): Promise<void>;
    // (undocumented)
    removeGPUObject(obj: GPUObject): void;
    // (undocumented)
    abstract restoreContext(): void;
    // (undocumented)
    restoreObject(obj: GPUObject): Promise<void>;
    // (undocumented)
    abstract reverseVertexWindingOrder(reverse: boolean): void;
    // (undocumented)
    runLoop(func: (device: AbstractDevice) => void): void;
    // (undocumented)
    protected _runLoopFunc: (device: AbstractDevice) => void;
    // (undocumented)
    get runLoopFunction(): (device: AbstractDevice) => void;
    // (undocumented)
    runNextFrame(f: () => void): void;
    // (undocumented)
    protected _runningLoop: number;
    // (undocumented)
    screenToDevice(val: number): number;
    // (undocumented)
    abstract setBindGroup(index: number, bindGroup: BindGroup, dynamicOffsets?: Iterable<number>): any;
    // (undocumented)
    setFont(fontName: string): void;
    // (undocumented)
    abstract setFramebuffer(rt: FrameBuffer): void;
    // (undocumented)
    abstract setProgram(program: GPUProgram): void;
    // (undocumented)
    abstract setRenderStates(renderStates: RenderStateSet): void;
    // (undocumented)
    abstract setScissor(scissor?: number[] | DeviceViewport): void;
    // (undocumented)
    abstract setVertexLayout(vertexData: VertexLayout): void;
    // (undocumented)
    abstract setViewport(vp?: number[] | DeviceViewport): void;
    // (undocumented)
    get type(): string;
    // (undocumented)
    updateVideoMemoryCost(delta: number): void;
    // (undocumented)
    get videoMemoryUsage(): number;
}

// @public
export interface BaseDevice extends IEventTarget<DeviceEventMap> {
}

// @public
export interface BaseTexture<T = unknown> extends GPUObject<T> {
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    readonly format: TextureFormat;
    // (undocumented)
    generateMipmaps(): void;
    // (undocumented)
    getDefaultSampler(comparison: boolean): TextureSampler;
    // (undocumented)
    readonly height: number;
    // (undocumented)
    init(): void;
    // (undocumented)
    isCompressedFormat(): boolean;
    // (undocumented)
    isDepth(): boolean;
    // (undocumented)
    isFilterable(): boolean;
    // (undocumented)
    isFloatFormat(): boolean;
    // (undocumented)
    isIntegerFormat(): boolean;
    // (undocumented)
    isSignedFormat(): boolean;
    // (undocumented)
    isSRGBFormat(): boolean;
    // (undocumented)
    readonly mipLevelCount: number;
    // (undocumented)
    readPixels(x: number, y: number, w: number, h: number, faceOrLayer: number, mipLevel: number, buffer: TypedArray): Promise<void>;
    // (undocumented)
    readPixelsToBuffer(x: number, y: number, w: number, h: number, faceOrLayer: number, mipLevel: number, buffer: GPUDataBuffer): void;
    // (undocumented)
    samplerOptions: SamplerOptions;
    // (undocumented)
    readonly target: TextureType;
    // (undocumented)
    readonly width: number;
}

// @public
export interface BindGroup extends GPUObject<unknown> {
    // (undocumented)
    getBuffer(name: string): GPUDataBuffer;
    // (undocumented)
    getGPUId(): string;
    // (undocumented)
    getLayout(): BindGroupLayout;
    // (undocumented)
    getTexture(name: string): BaseTexture;
    // (undocumented)
    setBuffer(name: string, buffer: GPUDataBuffer): void;
    // (undocumented)
    setRawData(name: string, byteOffset: number, data: TypedArray, srcPos?: number, srcLength?: number): any;
    // (undocumented)
    setSampler(name: string, sampler: TextureSampler): any;
    // (undocumented)
    setTexture(name: string, texture: BaseTexture, sampler?: TextureSampler): any;
    // (undocumented)
    setTextureView(name: string, value: BaseTexture, level?: number, face?: number, mipCount?: number, sampler?: TextureSampler): any;
    // (undocumented)
    setValue(name: string, value: StructuredValue): any;
}

// @public
export interface BindGroupLayout {
    entries: BindGroupLayoutEntry[];
    label?: string;
    nameMap?: Record<string, string>;
}

// @public
export interface BindGroupLayoutEntry {
    binding: number;
    buffer?: BufferBindingLayout;
    externalTexture?: ExternalTextureBindingLayout;
    name: string;
    sampler?: SamplerBindingLayout;
    storageTexture?: StorageTextureBindingLayout;
    texture?: TextureBindingLayout;
    type: PBTypeInfo;
    visibility: number;
}

// @public
export interface BindPointInfo {
    // (undocumented)
    binding: number;
    // (undocumented)
    group: number;
    // (undocumented)
    type: PBTypeInfo;
}

// @public
export type BlendEquation = 'add' | 'subtract' | 'reverse-subtract' | 'min' | 'max';

// @public
export type BlendFunc = 'zero' | 'one' | 'src-alpha' | 'inv-src-alpha' | 'src-alpha-saturate' | 'dst-alpha' | 'inv-dst-alpha' | 'src-color' | 'inv-src-color' | 'dst-color' | 'inv-dst-color' | 'const-color' | 'inv-const-color' | 'const-alpha' | 'inv-const-alpha';

// @public
export interface BlendingState {
    alphaEquation: BlendEquation;
    alphaToCoverageEnabled: boolean;
    clone(): BlendingState;
    dstBlendAlpha: BlendFunc;
    dstBlendRGB: BlendFunc;
    enable(b: boolean): this;
    enableAlphaToCoverage(b: boolean): this;
    enabled: boolean;
    rgbEquation: BlendEquation;
    setBlendEquation(rgb: BlendEquation, alpha: BlendEquation): this;
    setBlendFunc(src: BlendFunc, dest: BlendFunc): this;
    setBlendFuncAlpha(src: BlendFunc, dest: BlendFunc): this;
    setBlendFuncRGB(src: BlendFunc, dest: BlendFunc): this;
    srcBlendAlpha: BlendFunc;
    srcBlendRGB: BlendFunc;
}

// @public
export interface BufferBindingLayout {
    hasDynamicOffset: boolean;
    minBindingSize?: number;
    type?: 'uniform' | 'storage' | 'read-only-storage';
    uniformLayout: UniformBufferLayout;
}

// @public
export interface BufferCreationOptions extends BaseCreationOptions {
    managed?: boolean;
    storage?: boolean;
    usage?: BufferUsage;
}

// @public
export type BufferUsage = 'vertex' | 'index' | 'uniform' | 'read' | 'write';

// @public
export interface ColorState {
    alphaMask: boolean;
    blueMask: boolean;
    clone(): ColorState;
    greenMask: boolean;
    redMask: boolean;
    setColorMask(r: boolean, g: boolean, b: boolean, a: boolean): this;
}

// @public
export type CompareFunc = 'always' | 'le' | 'ge' | 'lt' | 'gt' | 'eq' | 'ne' | 'never';

// @public
export interface ComputeProgramConstructParams {
    bindGroupLayouts: BindGroupLayout[];
    source: string;
}

// @public
export class CPUTimer implements ITimer {
    constructor();
    // (undocumented)
    begin(): void;
    // (undocumented)
    elapsed(): number;
    // (undocumented)
    end(): void;
    // (undocumented)
    ended(): boolean;
    // (undocumented)
    now(): number;
}

// @public
export type DataType = 'u8' | 'u8norm' | 'i8' | 'i8norm' | 'u16' | 'u16norm' | 'i16' | 'i16norm' | 'u32' | 'i32' | 'f16' | 'f32';

// @public
export interface DepthState {
    clone(): DepthState;
    compareFunc: CompareFunc;
    enableTest(b: boolean): this;
    enableWrite(b: boolean): this;
    setCompareFunc(func: CompareFunc): this;
    testEnabled: boolean;
    writeEnabled: boolean;
}

// @public
export interface DeviceBackend {
    // (undocumented)
    createDevice(cvs: HTMLCanvasElement, options?: DeviceOptions): Promise<AbstractDevice>;
    // (undocumented)
    supported(): boolean;
    // (undocumented)
    typeName(): string;
}

// @public
export interface DeviceCaps {
    framebufferCaps: FramebufferCaps;
    miscCaps: MiscCaps;
    shaderCaps: ShaderCaps;
    textureCaps: TextureCaps;
}

// @public
export type DeviceEventMap = {
    [DeviceResizeEvent.NAME]: DeviceResizeEvent;
    [DeviceLostEvent.NAME]: DeviceLostEvent;
    [DeviceRestoreEvent.NAME]: DeviceRestoreEvent;
    [DeviceGPUObjectAddedEvent.NAME]: DeviceGPUObjectAddedEvent;
    [DeviceGPUObjectRemovedEvent.NAME]: DeviceGPUObjectRemovedEvent;
    [DeviceGPUObjectRenameEvent.NAME]: DeviceGPUObjectRenameEvent;
};

// @public
export class DeviceGPUObjectAddedEvent {
    constructor(obj: GPUObject);
    static readonly NAME: "gpuobject_added";
    // (undocumented)
    object: GPUObject;
    // (undocumented)
    type: "gpuobject_added";
}

// @public
export class DeviceGPUObjectRemovedEvent {
    constructor(obj: GPUObject);
    static readonly NAME: 'gpuobject_removed';
    // (undocumented)
    object: GPUObject;
    // (undocumented)
    type: "gpuobject_removed";
}

// @public
export class DeviceGPUObjectRenameEvent {
    constructor(obj: GPUObject, lastName: string);
    // (undocumented)
    lastName: string;
    static readonly NAME: 'gpuobject_rename';
    // (undocumented)
    object: GPUObject;
    // (undocumented)
    type: "gpuobject_rename";
}

// @public
export class DeviceLostEvent {
    static readonly NAME: "devicelost";
    // (undocumented)
    type: "devicelost";
}

// @public
export interface DeviceOptions {
    dpr?: number;
    msaa?: boolean;
}

// @public
export class DeviceResizeEvent {
    constructor(width: number, height: number);
    // (undocumented)
    height: number;
    static readonly NAME: "resize";
    // (undocumented)
    type: "resize";
    // (undocumented)
    width: number;
}

// @public
export class DeviceRestoreEvent {
    static readonly NAME: "devicerestored";
    // (undocumented)
    type: "devicerestored";
}

// @public
export type DeviceViewport = {
    x: number;
    y: number;
    width: number;
    height: number;
    default: boolean;
};

// @public
export class DrawText {
    static drawText(device: AbstractDevice, text: string, color: string, x: number, y: number): void;
    static setFont(device: AbstractDevice, name: string): void;
}

// @public
export type ExpValueNonArrayType = number | boolean | PBShaderExp;

// @public
export type ExpValueType = ExpValueNonArrayType | Array<ExpValueType>;

// @public
export interface ExternalTextureBindingLayout {
    autoBindSampler: string;
}

// @public
export type FaceMode = 'none' | 'front' | 'back';

// @public
export type FaceWinding = 'cw' | 'ccw';

// @public
export class Font {
    constructor(name: string, scale: number);
    get bottom(): number;
    get bottomScaled(): number;
    equalTo(other: Font): boolean;
    get family(): string;
    static fetchFont(name: string, scale: number): Font;
    get fontName(): string;
    set fontName(name: string);
    get fontNameScaled(): string;
    get maxHeight(): number;
    get maxHeightScaled(): number;
    get size(): number;
    get top(): number;
    get topScaled(): number;
}

// @public
export interface FrameBuffer<T = unknown> extends GPUObject<T> {
    // (undocumented)
    bind(): boolean;
    // (undocumented)
    getColorAttachments(): BaseTexture[];
    // (undocumented)
    getDepthAttachment(): BaseTexture;
    // (undocumented)
    getHash(): string;
    // (undocumented)
    getHeight(): number;
    // (undocumented)
    getSampleCount(): number;
    // (undocumented)
    getWidth(): number;
    // (undocumented)
    setColorAttachmentCubeFace(index: number, face: CubeFace): void;
    // (undocumented)
    setColorAttachmentGenerateMipmaps(index: number, generateMipmaps: boolean): void;
    // (undocumented)
    setColorAttachmentLayer(index: number, layer: number): void;
    // (undocumented)
    setColorAttachmentMipLevel(index: number, level: number): void;
    // (undocumented)
    setDepthAttachmentCubeFace(face: CubeFace): void;
    // (undocumented)
    setDepthAttachmentLayer(layer: number): void;
    // (undocumented)
    unbind(): void;
}

// @public
export interface FramebufferCaps {
    maxColorAttachmentBytesPerSample: number;
    maxDrawBuffers: number;
    supportDepth32float: boolean;
    supportDepth32floatStencil8: boolean;
    supportFloatBlending: boolean;
    supportMultisampledFramebuffer: boolean;
}

// @public
export interface FrameBufferOptions {
    ignoreDepthStencil?: boolean;
    sampleCount?: number;
}

// @public
export interface FrameBufferTextureAttachment {
    face?: number;
    generateMipmaps?: boolean;
    layer?: number;
    level?: number;
    texture?: BaseTexture;
}

// @public
export interface FrameInfo {
    computeCalls: number;
    drawCalls: number;
    elapsedFrame: number;
    elapsedOverall: number;
    elapsedTimeCPU: number;
    elapsedTimeGPU: number;
    FPS: number;
    frameCounter: number;
    frameTimestamp: number;
}

// @public
export interface FunctionTypeDetail {
    argTypes: {
        type: PBTypeInfo;
        byRef?: boolean;
    }[];
    name: string;
    returnType: PBTypeInfo;
}

// @public
export function genDefaultName(obj: GPUObject): "unknown" | "sampler" | "texture_2d" | "texture_2darray" | "texture_3d" | "texture_cube" | "texture_video" | "buffer" | "framebuffer" | "program" | "vbo";

// @public
export function getTextureFormatBlockHeight(format: TextureFormat): number;

// @public
export function getTextureFormatBlockSize(format: TextureFormat): number;

// @public
export function getTextureFormatBlockWidth(format: TextureFormat): number;

// @public
export function getVertexAttribFormat(semantic: VertexSemantic, type: DataType, count: number): VertexAttribFormat;

// @public
export function getVertexBufferAttribType(vertexBufferType: PBStructTypeInfo, attrib: number): PBPrimitiveTypeInfo;

// @public
export function getVertexBufferAttribTypeBySemantic(vertexBufferType: PBStructTypeInfo, semantic: VertexSemantic): PBPrimitiveTypeInfo;

// @public
export function getVertexBufferLength(vertexBufferType: PBStructTypeInfo): number;

// @public
export function getVertexBufferStride(vertexBufferType: PBStructTypeInfo): number;

// @public
export class GlyphManager extends TextureAtlasManager {
    constructor(device: AbstractDevice, binWidth: number, binHeight: number, border: number);
    clipStringToWidth(str: string, width: number, charMargin: number, start: number, font: Font): number;
    getCharWidth(char: string, font: Font): number;
    getGlyphInfo(char: string, font: Font): AtlasInfo;
    measureStringWidth(str: string, charMargin: number, font: Font): number;
}

// @public
export interface GPUDataBuffer<T = unknown> extends GPUObject<T> {
    // (undocumented)
    bufferSubData(dstByteOffset: number, data: TypedArray, srcOffset?: number, srcLength?: number): void;
    // (undocumented)
    readonly byteLength: number;
    // (undocumented)
    getBufferSubData(dstBuffer?: Uint8Array, offsetInBytes?: number, sizeInBytes?: number): Promise<Uint8Array>;
    // (undocumented)
    readonly usage: number;
}

// @public
export interface GPUObject<T = unknown> extends IEventTarget<{
    disposed: null;
}> {
    // (undocumented)
    readonly cid: number;
    // (undocumented)
    destroy(): void;
    readonly device: AbstractDevice;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly disposed: boolean;
    // (undocumented)
    isBindGroup(): this is BindGroup;
    // (undocumented)
    isBuffer(): this is GPUDataBuffer;
    // (undocumented)
    isFramebuffer(): this is FrameBuffer;
    // (undocumented)
    isProgram(): this is GPUProgram;
    // (undocumented)
    isSampler(): this is TextureSampler;
    // (undocumented)
    isTexture(): this is BaseTexture;
    // (undocumented)
    isTexture2D(): this is Texture2D;
    // (undocumented)
    isTexture2DArray(): this is Texture2DArray;
    // (undocumented)
    isTexture3D(): this is Texture3D;
    // (undocumented)
    isTextureCube(): this is TextureCube;
    // (undocumented)
    isTextureVideo(): this is TextureVideo;
    // (undocumented)
    isVertexLayout(): this is VertexLayout;
    // (undocumented)
    name: string;
    readonly object: T;
    // (undocumented)
    reload(): Promise<void>;
    // (undocumented)
    restore(): Promise<void>;
    // (undocumented)
    restoreHandler: (tex: GPUObject) => Promise<void>;
    readonly uid: number;
}

// @public
export interface GPUObjectList {
    bindGroups: BindGroup[];
    buffers: GPUDataBuffer[];
    framebuffers: FrameBuffer[];
    programs: GPUProgram[];
    samplers: TextureSampler[];
    textures: BaseTexture[];
    vertexArrayObjects: VertexLayout[];
}

// @public
export interface GPUProgram<T = unknown> extends GPUObject<T> {
    // (undocumented)
    readonly bindGroupLayouts: BindGroupLayout[];
    // (undocumented)
    createUniformBuffer(uniform: string): StructuredBuffer;
    // (undocumented)
    getBindingInfo(name: string): BindPointInfo;
    // (undocumented)
    getCompileError(): string;
    // (undocumented)
    getShaderSource(kind: ShaderKind): string;
    // (undocumented)
    readonly type: 'render' | 'compute';
    // (undocumented)
    use(): void;
}

// @public
export interface GPUProgramConstructParams {
    label?: string;
    params: RenderProgramConstructParams | ComputeProgramConstructParams;
    type: 'render' | 'compute';
}

// @public
export enum GPUResourceUsageFlags {
    // (undocumented)
    BF_INDEX = 64,
    // (undocumented)
    BF_READ = 128,
    // (undocumented)
    BF_STORAGE = 1024,
    // (undocumented)
    BF_UNIFORM = 512,
    // (undocumented)
    BF_VERTEX = 32,
    // (undocumented)
    BF_WRITE = 256,
    // (undocumented)
    DYNAMIC = 2048,
    // (undocumented)
    MANAGED = 4096,
    // (undocumented)
    TF_LINEAR_COLOR_SPACE = 2,
    // (undocumented)
    TF_NO_GC = 16,
    // (undocumented)
    TF_NO_MIPMAP = 4,
    // (undocumented)
    TF_WRITABLE = 8
}

// @public
export function hasAlphaChannel(format: TextureFormat): boolean;

// @public
export function hasBlueChannel(format: TextureFormat): boolean;

// @public
export function hasDepthChannel(format: TextureFormat): boolean;

// @public
export function hasGreenChannel(format: TextureFormat): boolean;

// @public
export function hasRedChannel(format: TextureFormat): boolean;

// @public
export function hasStencilChannel(format: TextureFormat): boolean;

// @public
export interface IndexBuffer<T = unknown> extends GPUDataBuffer<T> {
    // (undocumented)
    readonly indexType: PBPrimitiveTypeInfo;
    // (undocumented)
    readonly length: number;
}

// @public
export function isCompressedTextureFormat(format: TextureFormat): boolean;

// @public
export function isFloatTextureFormat(format: TextureFormat): boolean;

// @public
export function isIntegerTextureFormat(format: TextureFormat): boolean;

// @public
export function isSignedTextureFormat(format: TextureFormat): boolean;

// @public
export function isSRGBTextureFormat(format: TextureFormat): boolean;

// @public
export interface ITimer {
    // (undocumented)
    begin(): void;
    // (undocumented)
    elapsed(): number;
    // (undocumented)
    end(): void;
    // (undocumented)
    ended(): boolean;
}

// @public
export function linearTextureFormatToSRGB(format: TextureFormat): TextureFormat;

// @public
export function makeVertexBufferType(length: number, ...attributes: VertexAttribFormat[]): PBStructTypeInfo;

// @public
export interface MiscCaps {
    maxBindGroups: number;
    maxTexCoordIndex: number;
    support32BitIndex: boolean;
    supportBlendMinMax: boolean;
    supportOversizedViewport: boolean;
}

// @public
export enum PBAddressSpace {
    // (undocumented)
    FUNCTION = "function",
    // (undocumented)
    PRIVATE = "private",
    // (undocumented)
    STORAGE = "storage",
    // (undocumented)
    UNIFORM = "uniform",
    // (undocumented)
    UNKNOWN = "unknown",
    // (undocumented)
    WORKGROUP = "workgroup"
}

// @public
export class PBAnyTypeInfo extends PBTypeInfo<null> {
    constructor();
    isAnyType(): this is PBAnyTypeInfo;
    isCompatibleType(other: PBTypeInfo<TypeDetailInfo>): boolean;
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export class PBArrayTypeInfo extends PBTypeInfo<ArrayTypeDetail> {
    constructor(elementType: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo | PBAnyTypeInfo, dimension?: number);
    get dimension(): number;
    get elementType(): PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo | PBAnyTypeInfo;
    isArrayType(): this is PBArrayTypeInfo;
    // (undocumented)
    isCompatibleType(other: PBTypeInfo<TypeDetailInfo>): boolean;
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export class PBAtomicI32TypeInfo extends PBTypeInfo<null> {
    constructor();
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export class PBAtomicU32TypeInfo extends PBTypeInfo<null> {
    constructor();
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export interface PBBuiltinScope {
    // (undocumented)
    readonly fragCoord: PBShaderExp;
    // (undocumented)
    fragDepth: PBShaderExp;
    // (undocumented)
    readonly frontFacing: PBShaderExp;
    // (undocumented)
    readonly globalInvocationId: PBShaderExp;
    // (undocumented)
    readonly instanceIndex: PBShaderExp;
    // (undocumented)
    readonly localInvocationId: PBShaderExp;
    // (undocumented)
    readonly numWorkGroups: PBShaderExp;
    // (undocumented)
    pointSize: PBShaderExp | number;
    // (undocumented)
    position: PBShaderExp;
    // (undocumented)
    readonly sampleIndex: PBShaderExp;
    // (undocumented)
    readonly sampleMaskIn: PBShaderExp;
    // (undocumented)
    sampleMaskOut: PBShaderExp;
    // (undocumented)
    readonly vertexIndex: PBShaderExp;
    // (undocumented)
    readonly workGroupId: PBShaderExp;
}

// @public
export class PBBuiltinScope extends PBScope {
    constructor();
}

// @public
export interface PBComputeOptions {
    compute(this: PBGlobalScope, pb: ProgramBuilder): any;
    label?: string;
    workgroupSize: [number, number, number];
}

// @public
export class PBDoWhileScope extends PBInsideFunctionScope {
    // (undocumented)
    $while(condition: ExpValueNonArrayType): void;
}

// @public
export class PBForScope extends PBInsideFunctionScope {
}

// @public
export class PBFunctionScope extends PBInsideFunctionScope {
    // (undocumented)
    $isMain(): boolean;
}

// @public
export class PBFunctionTypeInfo extends PBTypeInfo<FunctionTypeDetail> {
    constructor(name: string, returnType: PBTypeInfo, argTypes: {
        type: PBTypeInfo;
        byRef?: boolean;
    }[]);
    get argHash(): string;
    get argTypes(): {
        type: PBTypeInfo;
        byRef?: boolean;
    }[];
    get name(): string;
    get returnType(): PBTypeInfo;
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export class PBGlobalScope extends PBScope {
}

// @public
export class PBIfScope extends PBInsideFunctionScope {
    $else(body: (this: PBIfScope) => void): void;
    $elseif(condition: ExpValueNonArrayType, body: (this: PBIfScope) => void): PBIfScope;
}

// @public
export class PBInputScope extends PBScope {
}

// @public
export class PBInsideFunctionScope extends PBScope {
    $break(): void;
    $choice(condition: ExpValueNonArrayType, first: ExpValueNonArrayType, second: ExpValueNonArrayType): PBShaderExp;
    $continue(): void;
    $do(body: (this: PBDoWhileScope) => void): PBDoWhileScope;
    $for(counter: PBShaderExp, init: number | PBShaderExp, end: number | PBShaderExp, body: (this: PBForScope) => void): void;
    $if(condition: ExpValueNonArrayType, body: (this: PBIfScope) => void): PBIfScope;
    $return(retval?: ExpValueType): void;
    $scope(body: (this: PBInsideFunctionScope) => void): PBInsideFunctionScope;
    $while(condition: ExpValueNonArrayType, body: (this: PBWhileScope) => void): void;
}

// @public
export class PBLocalScope extends PBScope {
    constructor(scope: PBScope);
    // (undocumented)
    [props: string]: any;
}

// @public
export class PBNakedScope extends PBInsideFunctionScope {
}

// @public
export class PBOutputScope extends PBScope {
    constructor();
}

// @public
export class PBPointerTypeInfo extends PBTypeInfo<PointerTypeDetail> {
    constructor(pointerType: PBTypeInfo, addressSpace: PBAddressSpace);
    get addressSpace(): PBAddressSpace;
    set addressSpace(val: PBAddressSpace);
    isPointerType(): this is PBPointerTypeInfo;
    get pointerType(): PBTypeInfo;
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export enum PBPrimitiveType {
    // (undocumented)
    BOOL,
    // (undocumented)
    BVEC2,
    // (undocumented)
    BVEC3,
    // (undocumented)
    BVEC4,
    // (undocumented)
    F16,
    // (undocumented)
    F16VEC2,
    // (undocumented)
    F16VEC3,
    // (undocumented)
    F16VEC4,
    // (undocumented)
    F32,
    // (undocumented)
    F32VEC2,
    // (undocumented)
    F32VEC3,
    // (undocumented)
    F32VEC4,
    // (undocumented)
    I16,
    // (undocumented)
    I16_NORM,
    // (undocumented)
    I16VEC2,
    // (undocumented)
    I16VEC2_NORM,
    // (undocumented)
    I16VEC3,
    // (undocumented)
    I16VEC3_NORM,
    // (undocumented)
    I16VEC4,
    // (undocumented)
    I16VEC4_NORM,
    // (undocumented)
    I32,
    // (undocumented)
    I32_NORM,
    // (undocumented)
    I32VEC2,
    // (undocumented)
    I32VEC2_NORM,
    // (undocumented)
    I32VEC3,
    // (undocumented)
    I32VEC3_NORM,
    // (undocumented)
    I32VEC4,
    // (undocumented)
    I32VEC4_NORM,
    // (undocumented)
    I8,
    // (undocumented)
    I8_NORM,
    // (undocumented)
    I8VEC2,
    // (undocumented)
    I8VEC2_NORM,
    // (undocumented)
    I8VEC3,
    // (undocumented)
    I8VEC3_NORM,
    // (undocumented)
    I8VEC4,
    // (undocumented)
    I8VEC4_NORM,
    // (undocumented)
    MAT2,
    // (undocumented)
    MAT2x3,
    // (undocumented)
    MAT2x4,
    // (undocumented)
    MAT3,
    // (undocumented)
    MAT3x2,
    // (undocumented)
    MAT3x4,
    // (undocumented)
    MAT4,
    // (undocumented)
    MAT4x2,
    // (undocumented)
    MAT4x3,
    // (undocumented)
    NONE = 0,
    // (undocumented)
    U16,
    // (undocumented)
    U16_NORM,
    // (undocumented)
    U16VEC2,
    // (undocumented)
    U16VEC2_NORM,
    // (undocumented)
    U16VEC3,
    // (undocumented)
    U16VEC3_NORM,
    // (undocumented)
    U16VEC4,
    // (undocumented)
    U16VEC4_NORM,
    // (undocumented)
    U32,
    // (undocumented)
    U32_NORM,
    // (undocumented)
    U32VEC2,
    // (undocumented)
    U32VEC2_NORM,
    // (undocumented)
    U32VEC3,
    // (undocumented)
    U32VEC3_NORM,
    // (undocumented)
    U32VEC4,
    // (undocumented)
    U32VEC4_NORM,
    // (undocumented)
    U8,
    // (undocumented)
    U8_NORM,
    // (undocumented)
    U8VEC2,
    // (undocumented)
    U8VEC2_NORM,
    // (undocumented)
    U8VEC3,
    // (undocumented)
    U8VEC3_NORM,
    // (undocumented)
    U8VEC4,
    // (undocumented)
    U8VEC4_NORM
}

// @public
export class PBPrimitiveTypeInfo extends PBTypeInfo<PrimitiveTypeDetail> {
    constructor(type: PBPrimitiveType);
    get cols(): number;
    static getCachedTypeInfo(primitiveType: PBPrimitiveType): PBPrimitiveTypeInfo;
    isInteger(): boolean;
    isMatrixType(): boolean;
    isPrimitiveType(): this is PBPrimitiveTypeInfo;
    isScalarType(): boolean;
    isVectorType(): boolean;
    get normalized(): boolean;
    get primitiveType(): PBPrimitiveType;
    resizeType(rows: number, cols: number): PBPrimitiveType;
    get rows(): number;
    get scalarType(): PBPrimitiveType;
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export class PBReflection {
    constructor(builder: ProgramBuilder);
    attribute(attrib: VertexSemantic): PBShaderExp;
    clear(): void;
    hasVertexAttribute(attrib: number): boolean;
    tag(name: string): PBShaderExp;
    tag(name: string, getter: PBReflectionTagGetter): void;
    tag(values: Record<string, PBReflectionTagGetter>): void;
    get vertexAttributes(): number[];
}

// @public
export type PBReflectionTagGetter = (scope: PBGlobalScope) => PBShaderExp;

// @public
export interface PBRenderOptions {
    fragment(this: PBGlobalScope, pb: ProgramBuilder): any;
    label?: string;
    vertex(this: PBGlobalScope, pb: ProgramBuilder): any;
}

// @public
export enum PBSamplerAccessMode {
    // (undocumented)
    COMPARISON = 2,
    // (undocumented)
    SAMPLE = 1,
    // (undocumented)
    UNKNOWN = 0
}

// @public
export class PBSamplerTypeInfo extends PBTypeInfo<SamplerTypeDetail> {
    constructor(accessMode: PBSamplerAccessMode);
    get accessMode(): PBSamplerAccessMode;
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export class PBScope extends Proxiable<PBScope> {
    get $builder(): ProgramBuilder;
    get $builtins(): PBBuiltinScope;
    get $g(): PBGlobalScope;
    $getVertexAttrib(semantic: VertexSemantic): PBShaderExp;
    get $inputs(): PBInputScope;
    get $l(): PBLocalScope;
    get $outputs(): PBOutputScope;
    $query(name: string): PBShaderExp;
    // (undocumented)
    [props: string]: any;
}

// @public
export class PBShaderExp extends Proxiable<PBShaderExp> {
    // (undocumented)
    get $group(): number;
    set $group(val: number);
    // (undocumented)
    [name: string]: any;
    at(index: number | PBShaderExp): PBShaderExp;
    attrib(attr: VertexSemantic): PBShaderExp;
    getTypeName(): string;
    highp(): PBShaderExp;
    // (undocumented)
    inout(): PBShaderExp;
    isConstructor(): boolean;
    isVector(): boolean;
    lowp(): PBShaderExp;
    mediump(): PBShaderExp;
    numComponents(): number;
    // (undocumented)
    out(): PBShaderExp;
    sampleType(type: 'float' | 'unfilterable-float' | 'sint' | 'uint' | 'depth'): PBShaderExp;
    setAt(index: number | PBShaderExp, val: number | boolean | PBShaderExp): void;
    storage(group: number): PBShaderExp;
    storageBuffer(group: number, dynamicOffset?: boolean): PBShaderExp;
    tag(...args: ShaderExpTagValue[]): PBShaderExp;
    uniform(group: number): PBShaderExp;
    uniformBuffer(group: number, dynamicOffset?: boolean): PBShaderExp;
    workgroup(): PBShaderExp;
}

// @public
export type PBStructLayout = 'default' | 'std140' | 'std430' | 'packed';

// @public
export class PBStructTypeInfo extends PBTypeInfo<StructTypeDetail> {
    constructor(name: string, layout: PBStructLayout, members: {
        name: string;
        type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBAtomicI32TypeInfo | PBAtomicU32TypeInfo | PBStructTypeInfo;
    }[]);
    extends(name: string, members: {
        name: string;
        type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
    }[]): PBStructTypeInfo;
    isStructType(): this is PBStructTypeInfo;
    get layout(): PBStructLayout;
    get structMembers(): {
        name: string;
        type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo | PBAtomicI32TypeInfo | PBAtomicU32TypeInfo;
        alignment: number;
        size: number;
        defaultAlignment: number;
        defaultSize: number;
    }[];
    get structName(): string;
    set structName(val: string);
    toBufferLayout(offset: number, layout: PBStructLayout): UniformBufferLayout;
}

// @public
export enum PBTextureType {
    // (undocumented)
    ITEX_1D = 513,
    // (undocumented)
    ITEX_2D = 514,
    // (undocumented)
    ITEX_2D_ARRAY = 530,
    // (undocumented)
    ITEX_3D = 516,
    // (undocumented)
    ITEX_CUBE = 520,
    // (undocumented)
    ITEX_CUBE_ARRAY = 536,
    // (undocumented)
    ITEX_MULTISAMPLED_2D = 546,
    // (undocumented)
    TEX_1D = 257,
    // (undocumented)
    TEX_2D = 258,
    // (undocumented)
    TEX_2D_ARRAY = 274,
    // (undocumented)
    TEX_3D = 260,
    // (undocumented)
    TEX_CUBE = 264,
    // (undocumented)
    TEX_CUBE_ARRAY = 280,
    // (undocumented)
    TEX_DEPTH_2D = 130,
    // (undocumented)
    TEX_DEPTH_2D_ARRAY = 146,
    // (undocumented)
    TEX_DEPTH_CUBE = 136,
    // (undocumented)
    TEX_DEPTH_CUBE_ARRAY = 152,
    // (undocumented)
    TEX_DEPTH_MULTISAMPLED_2D = 162,
    // (undocumented)
    TEX_EXTERNAL = 2048,
    // (undocumented)
    TEX_MULTISAMPLED_2D = 290,
    // (undocumented)
    TEX_STORAGE_1D = 65,
    // (undocumented)
    TEX_STORAGE_2D = 66,
    // (undocumented)
    TEX_STORAGE_2D_ARRAY = 82,
    // (undocumented)
    TEX_STORAGE_3D = 68,
    // (undocumented)
    UTEX_1D = 1025,
    // (undocumented)
    UTEX_2D = 1026,
    // (undocumented)
    UTEX_2D_ARRAY = 1042,
    // (undocumented)
    UTEX_3D = 1028,
    // (undocumented)
    UTEX_CUBE = 1032,
    // (undocumented)
    UTEX_CUBE_ARRAY = 1048,
    // (undocumented)
    UTEX_MULTISAMPLED_2D = 1058
}

// @public
export class PBTextureTypeInfo extends PBTypeInfo<TextureTypeDetail> {
    constructor(textureType: PBTextureType, texelFormat?: TextureFormat, readable?: boolean, writable?: boolean);
    is2DTexture(): boolean;
    is3DTexture(): boolean;
    isArrayTexture(): boolean;
    isCubeTexture(): boolean;
    isDepthTexture(): boolean;
    isExternalTexture(): boolean;
    isIntTexture(): boolean;
    isMultisampledTexture(): boolean;
    isStorageTexture(): boolean;
    isUIntTexture(): boolean;
    get readable(): boolean;
    get storageTexelFormat(): TextureFormat;
    get textureType(): PBTextureType;
    toBufferLayout(offset: number): UniformBufferLayout;
    get writable(): boolean;
}

// @public
export abstract class PBTypeInfo<DetailType extends TypeDetailInfo = TypeDetailInfo> {
    isAnyType(): this is PBAnyTypeInfo;
    isArrayType(): this is PBArrayTypeInfo;
    isAtomicI32(): this is PBAtomicI32TypeInfo;
    isAtomicU32(): this is PBAtomicU32TypeInfo;
    isCompatibleType(other: PBTypeInfo): boolean;
    isPointerType(): this is PBPointerTypeInfo;
    isPrimitiveType(): this is PBPrimitiveTypeInfo;
    isSamplerType(): this is PBSamplerTypeInfo;
    isStructType(): this is PBStructTypeInfo;
    isTextureType(): this is PBTextureTypeInfo;
    isVoidType(): this is PBVoidTypeInfo;
    abstract toBufferLayout(offset: number, layout: PBStructLayout): UniformBufferLayout;
    get typeId(): string;
}

// @public
export class PBVoidTypeInfo extends PBTypeInfo<null> {
    constructor();
    isVoidType(): this is PBVoidTypeInfo;
    toBufferLayout(offset: number): UniformBufferLayout;
}

// @public
export class PBWhileScope extends PBInsideFunctionScope {
}

// @public
export interface PointerTypeDetail {
    addressSpace: PBAddressSpace;
    pointerType: PBTypeInfo;
}

// @public
export type PrimitiveType = 'triangle-list' | 'triangle-strip' | 'triangle-fan' | 'line-list' | 'line-strip' | 'point-list';

// @public
export interface PrimitiveTypeDetail {
    // (undocumented)
    primitiveType?: PBPrimitiveType;
}

// @public
export interface ProgramBuilder {
    $query(name: string): PBShaderExp;
    abs(val: number | PBShaderExp): PBShaderExp;
    acos(val: number | PBShaderExp): PBShaderExp;
    acosh(val: number | PBShaderExp): PBShaderExp;
    add(x: number | PBShaderExp, ...rest: (number | PBShaderExp)[]): any;
    add_2(x: number | PBShaderExp, y: number | PBShaderExp): any;
    addressOf(ref: PBShaderExp): PBShaderExp;
    all(x: PBShaderExp): PBShaderExp;
    and(x: PBShaderExp | number | boolean, y: PBShaderExp | number | boolean, ...rest: (PBShaderExp | number | boolean)[]): any;
    and_2(x: PBShaderExp | number | boolean, y: PBShaderExp | number | boolean): PBShaderExp;
    any(x: PBShaderExp): PBShaderExp;
    arrayLength(x: PBShaderExp): PBShaderExp;
    asin(val: number | PBShaderExp): PBShaderExp;
    asinh(val: number | PBShaderExp): PBShaderExp;
    atan(val: number | PBShaderExp): PBShaderExp;
    atan2(y: number | PBShaderExp, x: number | PBShaderExp): PBShaderExp;
    atanh(val: number | PBShaderExp): PBShaderExp;
    atomicAdd(ptr: PBShaderExp, value: number | PBShaderExp): PBShaderExp;
    atomicAnd(ptr: PBShaderExp, value: number | PBShaderExp): PBShaderExp;
    atomicLoad(ptr: PBShaderExp): any;
    atomicMax(ptr: PBShaderExp, value: number | PBShaderExp): PBShaderExp;
    atomicMin(ptr: PBShaderExp, value: number | PBShaderExp): PBShaderExp;
    atomicOr(ptr: PBShaderExp, value: number | PBShaderExp): PBShaderExp;
    atomicStore(ptr: PBShaderExp, value: number | PBShaderExp): any;
    atomicSub(ptr: PBShaderExp, value: number | PBShaderExp): PBShaderExp;
    atomicXor(ptr: PBShaderExp, value: number | PBShaderExp): PBShaderExp;
    bool: {
        (): PBShaderExp;
        (rhs: number | boolean | PBShaderExp | string): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    buildCompute(options: PBComputeOptions): readonly [string, BindGroupLayout[]];
    buildComputeProgram(options: PBComputeOptions): GPUProgram;
    buildRender(options: PBRenderOptions): readonly [string, string, BindGroupLayout[], number[]];
    buildRenderProgram(options: PBRenderOptions): GPUProgram;
    bvec2: {
        (): PBShaderExp;
        (rhs: number | boolean | PBShaderExp | string): PBShaderExp;
        (x: number | boolean | PBShaderExp, y: number | boolean | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    bvec3: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: boolean | PBShaderExp): PBShaderExp;
        (x: boolean | PBShaderExp, y: boolean | PBShaderExp, z: boolean | PBShaderExp): PBShaderExp;
        (x: boolean | PBShaderExp, yz: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: boolean | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    bvec4: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: boolean | PBShaderExp): PBShaderExp;
        (x: boolean | PBShaderExp, y: boolean | PBShaderExp, z: boolean | PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;
        (x: boolean | PBShaderExp, y: boolean | PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (x: boolean | PBShaderExp, yz: PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;
        (x: boolean | PBShaderExp, yzw: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: boolean | PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (xyz: PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    ceil(val: number | PBShaderExp): PBShaderExp;
    clamp(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;
    compAnd(x: PBShaderExp | number, y: PBShaderExp | number): PBShaderExp;
    compEqual(x: PBShaderExp, y: PBShaderExp): PBShaderExp;
    compNotEqual(x: PBShaderExp, y: PBShaderExp): PBShaderExp;
    compOr(x: PBShaderExp | number | boolean, y: PBShaderExp | number | boolean): PBShaderExp;
    compXor(x: PBShaderExp | number, y: PBShaderExp | number): PBShaderExp;
    cos(val: number | PBShaderExp): PBShaderExp;
    cosh(val: number | PBShaderExp): PBShaderExp;
    cross(x: PBShaderExp, y: PBShaderExp): PBShaderExp;
    defineStruct(members: PBShaderExp[], structName?: string): ShaderTypeFunc;
    defineStructByType(structType: PBStructTypeInfo): ShaderTypeFunc;
    degrees(val: number | PBShaderExp): PBShaderExp;
    determinant(mat: PBShaderExp): PBShaderExp;
    discard(): void;
    distance(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    div(x: number | PBShaderExp, y: number | PBShaderExp): any;
    dot(x: PBShaderExp, y: PBShaderExp): PBShaderExp;
    dpdx(x: PBShaderExp): PBShaderExp;
    dpdxCoarse(x: PBShaderExp): PBShaderExp;
    dpdxFine(x: PBShaderExp): PBShaderExp;
    dpdy(x: PBShaderExp): PBShaderExp;
    dpdyCoarse(x: PBShaderExp): PBShaderExp;
    dpdyFine(x: PBShaderExp): PBShaderExp;
    equal(x: PBShaderExp | number, y: PBShaderExp | number): PBShaderExp;
    exp(val: number | PBShaderExp): PBShaderExp;
    exp2(val: number | PBShaderExp): PBShaderExp;
    faceForward(x: PBShaderExp, y: PBShaderExp, z: PBShaderExp): PBShaderExp;
    float: {
        (): PBShaderExp;
        (rhs: number): PBShaderExp;
        (rhs: boolean): PBShaderExp;
        (rhs: PBShaderExp): PBShaderExp;
        (name: string): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    floatBitsToInt(x: number | PBShaderExp): PBShaderExp;
    floatBitsToUint(x: number | PBShaderExp): PBShaderExp;
    floor(val: number | PBShaderExp): PBShaderExp;
    fma(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;
    fract(val: number | PBShaderExp): PBShaderExp;
    frexp(x: number | PBShaderExp): PBShaderExp;
    func(name: string, params: PBShaderExp[], body?: (this: PBFunctionScope) => void): void;
    fwidth(x: PBShaderExp): PBShaderExp;
    getCurrentScope(): PBScope;
    getDevice(): AbstractDevice;
    getGlobalScope(): PBGlobalScope;
    greaterThan(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    greaterThanEqual(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    int: {
        (): PBShaderExp;
        (rhs: number | boolean | PBShaderExp | string): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    intBitsToFloat(x: number | PBShaderExp): PBShaderExp;
    inverse(mat: PBShaderExp): PBShaderExp;
    inverseSqrt(val: number | PBShaderExp): PBShaderExp;
    isinf(x: number | PBShaderExp): PBShaderExp;
    isnan(x: number | PBShaderExp): PBShaderExp;
    itex1D(rhs?: string): PBShaderExp;
    itex2D(rhs?: string): PBShaderExp;
    itex2DArray(rhs?: string): PBShaderExp;
    itex3D(rhs?: string): PBShaderExp;
    itexCube(rhs?: string): PBShaderExp;
    ivec2: {
        (): PBShaderExp;
        (rhs: number | PBShaderExp | string): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    ivec3: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yz: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    ivec4: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yzw: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (xyz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    length(x: number | PBShaderExp): PBShaderExp;
    lessThan(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    lessThanEqual(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    log(val: number | PBShaderExp): PBShaderExp;
    log2(val: number | PBShaderExp): PBShaderExp;
    main(body?: (this: PBFunctionScope) => void): void;
    mat2: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat2x3: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat2x4: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m03: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m13: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat3: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat3x2: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m20: number | PBShaderExp, m21: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat3x4: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m03: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m13: number | PBShaderExp, m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp, m23: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat4: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m03: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m13: number | PBShaderExp, m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp, m23: number | PBShaderExp, m30: number | PBShaderExp, m31: number | PBShaderExp, m32: number | PBShaderExp, m33: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp, m3: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat4x2: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m20: number | PBShaderExp, m21: number | PBShaderExp, m30: number | PBShaderExp, m31: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp, m3: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    mat4x3: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp, m30: number | PBShaderExp, m31: number | PBShaderExp, m32: number | PBShaderExp): PBShaderExp;
        (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp, m3: PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    matrixCompMult(x: PBShaderExp, y: PBShaderExp): PBShaderExp;
    max(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    min(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    mix(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;
    mod(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    mul(x: number | PBShaderExp, ...rest: (number | PBShaderExp)[]): any;
    mul_2(x: number | PBShaderExp, y: number | PBShaderExp): any;
    neg(x: number | PBShaderExp): PBShaderExp;
    normalize(x: PBShaderExp): PBShaderExp;
    not(x: boolean | PBShaderExp): PBShaderExp;
    notEqual(x: PBShaderExp | number, y: PBShaderExp | number): PBShaderExp;
    or(x: PBShaderExp | boolean, y: PBShaderExp | boolean, ...rest: (PBShaderExp | boolean)[]): PBShaderExp;
    or_2(x: PBShaderExp | boolean, y: PBShaderExp | boolean): PBShaderExp;
    outerProduct(x: PBShaderExp, y: PBShaderExp): PBShaderExp;
    pack2x16float(x: PBShaderExp): PBShaderExp;
    pack2x16snorm(x: PBShaderExp): PBShaderExp;
    pack2x16unorm(x: PBShaderExp): PBShaderExp;
    pack4x8snorm(x: PBShaderExp): PBShaderExp;
    pack4x8unorm(x: PBShaderExp): PBShaderExp;
    pow(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    queryGlobal(name: string): PBShaderExp;
    radians(val: number | PBShaderExp): PBShaderExp;
    referenceOf(ptr: PBShaderExp): PBShaderExp;
    reflect(x: PBShaderExp, y: PBShaderExp): PBShaderExp;
    refract(x: PBShaderExp, y: PBShaderExp, z: number | PBShaderExp): PBShaderExp;
    round(val: number | PBShaderExp): PBShaderExp;
    sal(a: number | PBShaderExp, b: number | PBShaderExp): any;
    sampler(rhs?: string): PBShaderExp;
    samplerComparison(rhs?: string): PBShaderExp;
    sar(a: number | PBShaderExp, b: number | PBShaderExp): any;
    select(x: number | PBShaderExp, y: number | PBShaderExp, cond: boolean | PBShaderExp): PBShaderExp;
    sign(val: number | PBShaderExp): PBShaderExp;
    sin(val: number | PBShaderExp): PBShaderExp;
    sinh(val: number | PBShaderExp): PBShaderExp;
    smoothStep(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;
    sqrt(val: number | PBShaderExp): PBShaderExp;
    step(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
    storageBarrier(): void;
    struct(structName: string, instanceName: string): PBShaderExp;
    sub(x: number | PBShaderExp, y: number | PBShaderExp): any;
    tan(val: number | PBShaderExp): PBShaderExp;
    tanh(val: number | PBShaderExp): PBShaderExp;
    tex1D(rhs?: string): PBShaderExp;
    tex2D(rhs?: string): PBShaderExp;
    tex2DArray(rhs?: string): PBShaderExp;
    tex2DArrayShadow(rhs?: string): PBShaderExp;
    tex2DShadow(rhs?: string): PBShaderExp;
    tex3D(rhs?: string): PBShaderExp;
    texCube(rhs?: string): PBShaderExp;
    texCubeShadow(rhs?: string): PBShaderExp;
    texExternal(rhs?: string): PBShaderExp;
    // Warning: (ae-forgotten-export) The symbol "StorageTextureConstructor" needs to be exported by the entry point index.d.ts
    texStorage1D: StorageTextureConstructor;
    texStorage2D: StorageTextureConstructor;
    texStorage2DArray: StorageTextureConstructor;
    texStorage3D: StorageTextureConstructor;
    textureArrayGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp): PBShaderExp;
    textureArrayGather(component: number | PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp): PBShaderExp;
    textureArrayGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;
    textureArrayLoad(tex: PBShaderExp, coords: number | PBShaderExp, arrayIndex: number | PBShaderExp, level: number | PBShaderExp): PBShaderExp;
    textureArraySample(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp): PBShaderExp;
    textureArraySampleBias(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, bias: number | PBShaderExp): PBShaderExp;
    textureArraySampleCompare(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;
    textureArraySampleCompareLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;
    textureArraySampleGrad(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp): PBShaderExp;
    textureArraySampleLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, level: number | PBShaderExp): PBShaderExp;
    textureArrayStore(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, value: PBShaderExp): void;
    textureDimensions(tex: PBShaderExp, level?: number | PBShaderExp): PBShaderExp;
    textureGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp): PBShaderExp;
    textureGather(component: number | PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp): PBShaderExp;
    textureGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;
    textureLoad(tex: PBShaderExp, coords: number | PBShaderExp, levelOrSampleIndex: number | PBShaderExp): PBShaderExp;
    textureNumLayers(tex: PBShaderExp): PBShaderExp;
    textureNumLevels(tex: PBShaderExp): PBShaderExp;
    textureNumSamples(tex: PBShaderExp): PBShaderExp;
    textureSample(tex: PBShaderExp, coords: number | PBShaderExp): PBShaderExp;
    textureSampleBias(tex: PBShaderExp, coords: PBShaderExp, bias: number | PBShaderExp): PBShaderExp;
    textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;
    textureSampleCompareLevel(tex: PBShaderExp, coords: PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;
    textureSampleGrad(tex: PBShaderExp, coords: PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp): PBShaderExp;
    textureSampleLevel(tex: PBShaderExp, coords: PBShaderExp): PBShaderExp;
    textureSampleLevel(tex: PBShaderExp, coords: PBShaderExp, level: number | PBShaderExp): PBShaderExp;
    textureStore(tex: PBShaderExp, coords: number | PBShaderExp, value: PBShaderExp): void;
    transpose(mat: PBShaderExp): PBShaderExp;
    trunc(val: number | PBShaderExp): PBShaderExp;
    uint: {
        (): PBShaderExp;
        (rhs: number | boolean | PBShaderExp | string): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    uintBitsToFloat(x: number | PBShaderExp): PBShaderExp;
    unpack2x16float(x: number | PBShaderExp): PBShaderExp;
    unpack2x16snorm(x: number | PBShaderExp): PBShaderExp;
    unpack2x16unorm(x: number | PBShaderExp): PBShaderExp;
    unpack4x8snorm(x: number | PBShaderExp): PBShaderExp;
    unpack4x8unorm(x: number | PBShaderExp): PBShaderExp;
    utex1D(rhs?: string): PBShaderExp;
    utex2D(rhs?: string): PBShaderExp;
    utex2DArray(rhs?: string): PBShaderExp;
    utex3D(rhs?: string): PBShaderExp;
    utexCube(rhs?: string): PBShaderExp;
    uvec2: {
        (): PBShaderExp;
        (rhs: number | PBShaderExp | string): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    uvec3: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yz: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    uvec4: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yzw: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (xyz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    vec2: {
        (): PBShaderExp;
        (rhs: number | PBShaderExp | string): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    vec3: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yz: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    vec4: {
        (): PBShaderExp;
        (name: string): PBShaderExp;
        (x: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, y: number | PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (x: number | PBShaderExp, yzw: PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;
        (xyz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;
        ptr: ShaderTypeFunc;
        [dim: number]: ShaderTypeFunc;
    };
    workgroupBarrier(): void;
}

// @public
export class ProgramBuilder {
    constructor(device: AbstractDevice);
    // (undocumented)
    get emulateDepthClamp(): boolean;
    set emulateDepthClamp(val: boolean);
    getCurrentFunctionScope(): PBFunctionScope;
    getReflection(): PBReflection;
    get lastError(): string;
    get shaderKind(): ShaderKind;
}

// @public
export abstract class Proxiable<T> {
    // (undocumented)
    get $thisProxy(): T;
    constructor();
}

// @public
export interface RasterizerState {
    clone(): RasterizerState;
    cullMode: FaceMode;
    depthClampEnabled: boolean;
    enableDepthClamp(enable: boolean): this;
    setCullMode(mode: FaceMode): this;
}

// @public
export type RenderBundle = unknown;

// @public
export interface RenderProgramConstructParams {
    bindGroupLayouts: BindGroupLayout[];
    fs: string;
    vertexAttributes: number[];
    vs: string;
}

// @public
export interface RenderStateSet {
    apply(force?: boolean): void;
    readonly blendingState: BlendingState;
    clone(): RenderStateSet;
    readonly colorState: ColorState;
    copyFrom(stateSet: RenderStateSet): void;
    defaultBlendingState(): void;
    defaultColorState(): void;
    defaultDepthState(): void;
    defaultRasterizerState(): void;
    defaultStencilState(): void;
    readonly depthState: DepthState;
    readonly rasterizerState: RasterizerState;
    readonly stencilState: StencilState;
    useBlendingState(state?: BlendingState): BlendingState;
    useColorState(state?: ColorState): ColorState;
    useDepthState(state?: DepthState): DepthState;
    useRasterizerState(state?: RasterizerState): RasterizerState;
    useStencilState(state?: StencilState): StencilState;
}

// @public
export interface SamplerBindingLayout {
    type: 'filtering' | 'non-filtering' | 'comparison';
}

// @public
export interface SamplerOptions {
    // (undocumented)
    addressU?: TextureAddressMode;
    // (undocumented)
    addressV?: TextureAddressMode;
    // (undocumented)
    addressW?: TextureAddressMode;
    // (undocumented)
    compare?: CompareFunc;
    // (undocumented)
    lodMax?: number;
    // (undocumented)
    lodMin?: number;
    // (undocumented)
    magFilter?: TextureFilterMode;
    // (undocumented)
    maxAnisotropy?: number;
    // (undocumented)
    minFilter?: TextureFilterMode;
    // (undocumented)
    mipFilter?: TextureFilterMode;
}

// @public
export interface SamplerTypeDetail {
    accessMode: PBSamplerAccessMode;
}

// @public
export const semanticList: string[];

// @public
export interface ShaderCaps {
    maxUniformBufferSize: number;
    supportFragmentDepth: boolean;
    supportHighPrecisionFloat: boolean;
    supportHighPrecisionInt: boolean;
    supportShaderTextureLod: boolean;
    supportStandardDerivatives: boolean;
    uniformBufferOffsetAlignment: number;
}

// @public (undocumented)
export interface ShaderExpTagRecord {
    // (undocumented)
    [name: string]: ShaderExpTagValue;
}

// @public (undocumented)
export type ShaderExpTagValue = string[] | string | ShaderExpTagRecord;

// @public
export type ShaderKind = 'vertex' | 'fragment' | 'compute';

// @public
export enum ShaderType {
    // (undocumented)
    Compute = 4,
    // (undocumented)
    Fragment = 2,
    // (undocumented)
    Vertex = 1
}

// @public
export type ShaderTypeFunc = {
    (...args: any[]): PBShaderExp;
    ptr: ShaderTypeFunc;
    [dim: number]: ShaderTypeFunc;
};

// @public
export type StencilOp = 'keep' | 'zero' | 'replace' | 'incr' | 'incr-wrap' | 'decr' | 'decr-wrap' | 'invert';

// @public
export interface StencilState {
    clone(): StencilState;
    enable(b: boolean): this;
    enabled: boolean;
    failOp: StencilOp;
    failOpBack: StencilOp;
    func: CompareFunc;
    funcBack: CompareFunc;
    passOp: StencilOp;
    passOpBack: StencilOp;
    readMask: number;
    ref: number;
    setBackCompareFunc(func: CompareFunc): this;
    setBackOp(fail: StencilOp, zfail: StencilOp, pass: StencilOp): this;
    setFrontCompareFunc(func: CompareFunc): this;
    setFrontOp(fail: StencilOp, zfail: StencilOp, pass: StencilOp): this;
    setReadMask(mask: number): this;
    setReference(ref: number): this;
    setWriteMask(mask: number): this;
    writeMask: number;
    zFailOp: StencilOp;
    zFailOpBack: StencilOp;
}

// @public
export interface StorageTextureBindingLayout {
    access: 'write-only';
    format: TextureFormat;
    viewDimension: '1d' | '2d';
}

// @public
export interface StructTypeDetail {
    layout: PBStructLayout;
    structMembers?: {
        name: string;
        type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBAtomicI32TypeInfo | PBAtomicU32TypeInfo | PBStructTypeInfo;
        alignment: number;
        size: number;
    }[];
    structName?: string;
}

// @public
export interface StructuredBuffer<T = unknown> extends GPUDataBuffer<T> {
    // (undocumented)
    set(name: string, value: StructuredValue): any;
    // (undocumented)
    structure: PBStructTypeInfo;
}

// @public
export class StructuredBufferData {
    constructor(layout: UniformBufferLayout, buffer?: StructuredBuffer | ArrayBuffer);
    get buffer(): ArrayBuffer;
    get byteLength(): number;
    set(name: string, value: StructuredValue): void;
    get uniforms(): Record<string, TypedArray>;
}

// @public
export type StructuredValue = number | TypedArray | VectorBase | {
    [name: string]: StructuredValue;
};

// @public
export interface Texture2D<T = unknown> extends BaseTexture<T> {
    // (undocumented)
    createWithMipmapData(data: TextureMipmapData, sRGB: boolean, creationFlags?: number): void;
    // (undocumented)
    loadFromElement(element: TextureImageElement, sRGB: boolean, creationFlags?: number): void;
    // (undocumented)
    update(data: TypedArray, xOffset: number, yOffset: number, width: number, height: number): void;
    // (undocumented)
    updateFromElement(data: TextureImageElement, destX: number, destY: number, srcX: number, srcY: number, width: number, height: number): void;
}

// @public
export interface Texture2DArray<T = unknown> extends BaseTexture<T> {
    // (undocumented)
    createWithMipmapData(data: TextureMipmapData, creationFlags?: number): void;
    // (undocumented)
    update(data: TypedArray, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number): void;
    // (undocumented)
    updateFromElement(data: TextureImageElement, xOffset: number, yOffset: number, layerIndex: number, x: number, y: number, width: number, height: number): void;
}

// @public
export interface Texture3D<T = unknown> extends BaseTexture<T> {
    // (undocumented)
    createWithMipmapData(data: TextureMipmapData, creationFlags?: number): void;
    // (undocumented)
    update(data: TypedArray, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number): void;
}

// @public
export type TextureAddressMode = 'repeat' | 'mirrored-repeat' | 'clamp';

// @public
export class TextureAtlasManager {
    constructor(device: AbstractDevice, binWidth: number, binHeight: number, rectBorderWidth: number, linearSpace?: boolean);
    get atlasTextureRestoreHandler(): (tex: BaseTexture) => Promise<void>;
    set atlasTextureRestoreHandler(f: (tex: BaseTexture) => Promise<void>);
    clear(): void;
    getAtlasInfo(key: string): AtlasInfo;
    getAtlasTexture(index: number): Texture2D;
    isEmpty(): boolean;
    pushBitmap(key: string, bitmap: ImageData | ImageBitmap): AtlasInfo;
    pushCanvas(key: string, ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number): AtlasInfo;
}

// @public
export interface TextureBindingLayout {
    autoBindSampler: string;
    autoBindSamplerComparison: string;
    multisampled: boolean;
    sampleType: 'float' | 'unfilterable-float' | 'depth' | 'sint' | 'uint';
    viewDimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';
}

// @public
export interface TextureCaps {
    getTextureFormatInfo(format: TextureFormat): TextureFormatInfo;
    maxCubeTextureSize: number;
    maxTextureSize: number;
    npo2Mipmapping: boolean;
    npo2Repeating: boolean;
    support3DTexture: boolean;
    supportAnisotropicFiltering: boolean;
    supportDepthTexture: boolean;
    supportFloatBlending: boolean;
    supportFloatColorBuffer: boolean;
    supportFloatTexture: boolean;
    supportHalfFloatColorBuffer: boolean;
    supportHalfFloatTexture: boolean;
    supportLinearFloatTexture: boolean;
    supportLinearHalfFloatTexture: boolean;
    supportS3TC: boolean;
    supportS3TCSRGB: boolean;
    supportSRGBTexture: boolean;
}

// @public
export type TextureColorSpace = 'srgb' | 'linear';

// @public
export interface TextureCreationOptions extends BaseCreationOptions {
    // (undocumented)
    samplerOptions?: SamplerOptions;
    // (undocumented)
    texture?: BaseTexture;
    // (undocumented)
    writable?: boolean;
}

// @public
export interface TextureCube<T = unknown> extends BaseTexture<T> {
    // (undocumented)
    createWithMipmapData(data: TextureMipmapData, sRGB: boolean, creationFlags?: number): void;
    // (undocumented)
    update(data: TypedArray, xOffset: number, yOffset: number, width: number, height: number, face: CubeFace): void;
    // (undocumented)
    updateFromElement(data: TextureImageElement, xOffset: number, yOffset: number, face: number, x: number, y: number, width: number, height: number): void;
}

// @public
export type TextureFilterMode = 'none' | 'nearest' | 'linear';

// @public
export type TextureFormat = 'unknown' | 'r8unorm' | 'r8snorm' | 'r16f' | 'r32f' | 'r8ui' | 'r8i' | 'r16ui' | 'r16i' | 'r32ui' | 'r32i' | 'rg8unorm' | 'rg8snorm' | 'rg16f' | 'rg32f' | 'rg8ui' | 'rg8i' | 'rg16ui' | 'rg16i' | 'rg32ui' | 'rg32i' | 'rgba8unorm' | 'rgba8unorm-srgb' | 'rgba8snorm' | 'bgra8unorm' | 'bgra8unorm-srgb' | 'rgba16f' | 'rgba32f' | 'rgba8ui' | 'rgba8i' | 'rgba16ui' | 'rgba16i' | 'rgba32ui' | 'rgba32i' | 'rg11b10uf' | 'd16' | 'd24' | 'd32f' | 'd24s8' | 'd32fs8' | 'dxt1' | 'dxt1-srgb' | 'dxt3' | 'dxt3-srgb' | 'dxt5' | 'dxt5-srgb';

// @public
export interface TextureFormatInfo {
    compressed: boolean;
    filterable: boolean;
    renderable: boolean;
}

// @public
export type TextureImageElement = ImageBitmap | HTMLCanvasElement;

// @public
export interface TextureMipmapData {
    arraySize: number;
    depth: number;
    format: TextureFormat;
    height: number;
    isArray: boolean;
    isCompressed: boolean;
    isCubemap: boolean;
    isVolume: boolean;
    mipDatas: TextureMipmapLevelData[][];
    mipLevels: number;
    width: number;
}

// @public
export interface TextureMipmapLevelData {
    data: TypedArray;
    height: number;
    width: number;
}

// @public
export interface TextureSampler<T = unknown> extends GPUObject<T> {
    // (undocumented)
    readonly addressModeU: TextureAddressMode;
    // (undocumented)
    readonly addressModeV: TextureAddressMode;
    // (undocumented)
    readonly addressModeW: TextureAddressMode;
    // (undocumented)
    readonly compare: CompareFunc;
    // (undocumented)
    readonly lodMax: number;
    // (undocumented)
    readonly lodMin: number;
    // (undocumented)
    readonly magFilter: TextureFilterMode;
    // (undocumented)
    readonly maxAnisotropy: number;
    // (undocumented)
    readonly minFilter: TextureFilterMode;
    // (undocumented)
    readonly mipFilter: TextureFilterMode;
}

// @public
export type TextureType = '2d' | '3d' | 'cube' | '2darray';

// @public
export interface TextureTypeDetail {
    readable: boolean;
    storageTexelFormat: TextureFormat;
    textureType: PBTextureType;
    writable: boolean;
}

// @public
export interface TextureVideo<T = unknown> extends BaseTexture<T> {
    // (undocumented)
    readonly source: HTMLVideoElement;
    // (undocumented)
    updateVideoFrame(): boolean;
}

// @public
export type TypeDetailInfo = PrimitiveTypeDetail | StructTypeDetail | ArrayTypeDetail | PointerTypeDetail | AtomicTypeInfoDetail | SamplerTypeDetail | TextureTypeDetail | FunctionTypeDetail | null;

// @public
export interface UniformBufferLayout {
    byteSize: number;
    entries: UniformLayout[];
}

// @public
export interface UniformLayout {
    arraySize: number;
    byteSize: number;
    name: string;
    offset: number;
    subLayout: UniformBufferLayout;
    type: PBPrimitiveType;
}

// @public
export type VertexAttribFormat = 'position_u8normx2' | 'position_u8normx4' | 'position_i8normx2' | 'position_i8normx4' | 'position_u16x2' | 'position_u16x4' | 'position_i16x2' | 'position_i16x4' | 'position_u16normx2' | 'position_u16normx4' | 'position_i16normx2' | 'position_i16normx4' | 'position_f16x2' | 'position_f16x4' | 'position_f32' | 'position_f32x2' | 'position_f32x3' | 'position_f32x4' | 'position_i32' | 'position_i32x2' | 'position_i32x3' | 'position_i32x4' | 'position_u32' | 'position_u32x2' | 'position_u32x3' | 'position_u32x4' | 'normal_f16x4' | 'normal_f32x3' | 'normal_f32x4' | 'diffuse_u8normx4' | 'diffuse_u16x4' | 'diffuse_u16normx4' | 'diffuse_f16x4' | 'diffuse_f32x3' | 'diffuse_f32x4' | 'diffuse_u32x3' | 'diffuse_u32x4' | 'tangent_f16x4' | 'tangent_f32x3' | 'tangent_f32x4' | 'tex0_u8normx2' | 'tex0_u8normx4' | 'tex0_i8normx2' | 'tex0_i8normx4' | 'tex0_u16x2' | 'tex0_u16x4' | 'tex0_i16x2' | 'tex0_i16x4' | 'tex0_u16normx2' | 'tex0_u16normx4' | 'tex0_i16normx2' | 'tex0_i16normx4' | 'tex0_f16x2' | 'tex0_f16x4' | 'tex0_f32' | 'tex0_f32x2' | 'tex0_f32x3' | 'tex0_f32x4' | 'tex0_i32' | 'tex0_i32x2' | 'tex0_i32x3' | 'tex0_i32x4' | 'tex0_u32' | 'tex0_u32x2' | 'tex0_u32x3' | 'tex0_u32x4' | 'tex1_u8normx2' | 'tex1_u8normx4' | 'tex1_i8normx2' | 'tex1_i8normx4' | 'tex1_u16x2' | 'tex1_u16x4' | 'tex1_i16x2' | 'tex1_i16x4' | 'tex1_u16normx2' | 'tex1_u16normx4' | 'tex1_i16normx2' | 'tex1_i16normx4' | 'tex1_f16x2' | 'tex1_f16x4' | 'tex1_f32' | 'tex1_f32x2' | 'tex1_f32x3' | 'tex1_f32x4' | 'tex1_i32' | 'tex1_i32x2' | 'tex1_i32x3' | 'tex1_i32x4' | 'tex1_u32' | 'tex1_u32x2' | 'tex1_u32x3' | 'tex1_u32x4' | 'tex2_u8normx2' | 'tex2_u8normx4' | 'tex2_i8normx2' | 'tex2_i8normx4' | 'tex2_u16x2' | 'tex2_u16x4' | 'tex2_i16x2' | 'tex2_i16x4' | 'tex2_u16normx2' | 'tex2_u16normx4' | 'tex2_i16normx2' | 'tex2_i16normx4' | 'tex2_f16x2' | 'tex2_f16x4' | 'tex2_f32' | 'tex2_f32x2' | 'tex2_f32x3' | 'tex2_f32x4' | 'tex2_i32' | 'tex2_i32x2' | 'tex2_i32x3' | 'tex2_i32x4' | 'tex2_u32' | 'tex2_u32x2' | 'tex2_u32x3' | 'tex2_u32x4' | 'tex3_u8normx2' | 'tex3_u8normx4' | 'tex3_i8normx2' | 'tex3_i8normx4' | 'tex3_u16x2' | 'tex3_u16x4' | 'tex3_i16x2' | 'tex3_i16x4' | 'tex3_u16normx2' | 'tex3_u16normx4' | 'tex3_i16normx2' | 'tex3_i16normx4' | 'tex3_f16x2' | 'tex3_f16x4' | 'tex3_f32' | 'tex3_f32x2' | 'tex3_f32x3' | 'tex3_f32x4' | 'tex3_i32' | 'tex3_i32x2' | 'tex3_i32x3' | 'tex3_i32x4' | 'tex3_u32' | 'tex3_u32x2' | 'tex3_u32x3' | 'tex3_u32x4' | 'tex4_u8normx2' | 'tex4_u8normx4' | 'tex4_i8normx2' | 'tex4_i8normx4' | 'tex4_u16x2' | 'tex4_u16x4' | 'tex4_i16x2' | 'tex4_i16x4' | 'tex4_u16normx2' | 'tex4_u16normx4' | 'tex4_i16normx2' | 'tex4_i16normx4' | 'tex4_f16x2' | 'tex4_f16x4' | 'tex4_f32' | 'tex4_f32x2' | 'tex4_f32x3' | 'tex4_f32x4' | 'tex4_i32' | 'tex4_i32x2' | 'tex4_i32x3' | 'tex4_i32x4' | 'tex4_u32' | 'tex4_u32x2' | 'tex4_u32x3' | 'tex4_u32x4' | 'tex5_u8normx2' | 'tex5_u8normx4' | 'tex5_i8normx2' | 'tex5_i8normx4' | 'tex5_u16x2' | 'tex5_u16x4' | 'tex5_i16x2' | 'tex5_i16x4' | 'tex5_u16normx2' | 'tex5_u16normx4' | 'tex5_i16normx2' | 'tex5_i16normx4' | 'tex5_f16x2' | 'tex5_f16x4' | 'tex5_f32' | 'tex5_f32x2' | 'tex5_f32x3' | 'tex5_f32x4' | 'tex5_i32' | 'tex5_i32x2' | 'tex5_i32x3' | 'tex5_i32x4' | 'tex5_u32' | 'tex5_u32x2' | 'tex5_u32x3' | 'tex5_u32x4' | 'tex6_u8normx2' | 'tex6_u8normx4' | 'tex6_i8normx2' | 'tex6_i8normx4' | 'tex6_u16x2' | 'tex6_u16x4' | 'tex6_i16x2' | 'tex6_i16x4' | 'tex6_u16normx2' | 'tex6_u16normx4' | 'tex6_i16normx2' | 'tex6_i16normx4' | 'tex6_f16x2' | 'tex6_f16x4' | 'tex6_f32' | 'tex6_f32x2' | 'tex6_f32x3' | 'tex6_f32x4' | 'tex6_i32' | 'tex6_i32x2' | 'tex6_i32x3' | 'tex6_i32x4' | 'tex6_u32' | 'tex6_u32x2' | 'tex6_u32x3' | 'tex6_u32x4' | 'tex7_u8normx2' | 'tex7_u8normx4' | 'tex7_i8normx2' | 'tex7_i8normx4' | 'tex7_u16x2' | 'tex7_u16x4' | 'tex7_i16x2' | 'tex7_i16x4' | 'tex7_u16normx2' | 'tex7_u16normx4' | 'tex7_i16normx2' | 'tex7_i16normx4' | 'tex7_f16x2' | 'tex7_f16x4' | 'tex7_f32' | 'tex7_f32x2' | 'tex7_f32x3' | 'tex7_f32x4' | 'tex7_i32' | 'tex7_i32x2' | 'tex7_i32x3' | 'tex7_i32x4' | 'tex7_u32' | 'tex7_u32x2' | 'tex7_u32x3' | 'tex7_u32x4' | 'blendweights_f16x4' | 'blendweights_f32x4' | 'blendindices_u16x4' | 'blendindices_f16x4' | 'blendindices_f32x4' | 'blendindices_u32x4';

// @public
export type VertexBufferInfo = {
    buffer: StructuredBuffer;
    offset: number;
    stride: number;
    drawOffset: number;
    type: PBPrimitiveTypeInfo;
    stepMode: VertexStepMode;
};

// @public
export class VertexData {
    constructor();
    clone(): VertexData;
    getDrawOffset(): number;
    getIndexBuffer(): IndexBuffer;
    getVertexBuffer(semantic: VertexSemantic): StructuredBuffer;
    getVertexBufferInfo(semantic: VertexSemantic): VertexBufferInfo;
    get indexBuffer(): IndexBuffer<unknown>;
    removeVertexBuffer(buffer: StructuredBuffer): boolean;
    // (undocumented)
    setDrawOffset(offset: number): void;
    setIndexBuffer(buffer: IndexBuffer): IndexBuffer;
    setVertexBuffer(buffer: StructuredBuffer, stepMode?: VertexStepMode): StructuredBuffer;
    get vertexBuffers(): VertexBufferInfo[];
}

// @public
export interface VertexLayout<T = unknown> extends GPUObject<T> {
    // (undocumented)
    bind(): void;
    // (undocumented)
    draw(primitiveType: PrimitiveType, first: number, count: number): void;
    // (undocumented)
    drawInstanced(primitiveType: PrimitiveType, first: number, count: number, numInstances: number): any;
    // (undocumented)
    getIndexBuffer(): IndexBuffer;
    // (undocumented)
    getVertexBuffer(semantic: VertexSemantic): StructuredBuffer;
    // (undocumented)
    getVertexBufferInfo(semantic: VertexSemantic): VertexBufferInfo;
    // (undocumented)
    readonly indexBuffer: IndexBuffer;
    // (undocumented)
    setDrawOffset(buffer: StructuredBuffer, byteOffset: number): void;
    // (undocumented)
    readonly vertexBuffers: {
        [semantic: number]: {
            buffer: StructuredBuffer;
            offset: number;
        };
    };
}

// @public
export type VertexLayoutOptions = {
    vertexBuffers: {
        buffer: StructuredBuffer;
        stepMode?: VertexStepMode;
    }[];
    indexBuffer?: IndexBuffer;
};

// @public
export type VertexSemantic = 'position' | 'normal' | 'diffuse' | 'tangent' | 'blendIndices' | 'blendWeights' | 'texCoord0' | 'texCoord1' | 'texCoord2' | 'texCoord3' | 'texCoord4' | 'texCoord5' | 'texCoord6' | 'texCoord7';

// @public
export type VertexStepMode = 'vertex' | 'instance';

// @public
export type WebGLContext = WebGLRenderingContext | WebGL2RenderingContext;

// (No @packageDocumentation comment for this package)

```
