## API Report File for "@zephyr3d/scene"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AABB } from '@zephyr3d/base';
import { AbstractDevice } from '@zephyr3d/device';
import { BaseTexture } from '@zephyr3d/device';
import { BindGroup } from '@zephyr3d/device';
import { BindGroupLayout } from '@zephyr3d/device';
import { ClipState } from '@zephyr3d/base';
import { CubeFace } from '@zephyr3d/base';
import { DeviceBackend } from '@zephyr3d/device';
import { DeviceViewport } from '@zephyr3d/device';
import { FrameBuffer } from '@zephyr3d/device';
import { Frustum } from '@zephyr3d/base';
import { GPUProgram } from '@zephyr3d/device';
import { HttpRequest } from '@zephyr3d/base';
import { IndexBuffer } from '@zephyr3d/device';
import { InterpolationMode } from '@zephyr3d/base';
import { InterpolationTarget } from '@zephyr3d/base';
import { Interpolator } from '@zephyr3d/base';
import { Matrix4x4 } from '@zephyr3d/base';
import { ObservableQuaternion } from '@zephyr3d/base';
import { ObservableVector3 } from '@zephyr3d/base';
import { PBFunctionScope } from '@zephyr3d/device';
import { PBGlobalScope } from '@zephyr3d/device';
import { PBInsideFunctionScope } from '@zephyr3d/device';
import { PBShaderExp } from '@zephyr3d/device';
import { Plane } from '@zephyr3d/base';
import { PrimitiveType } from '@zephyr3d/device';
import { ProgramBuilder } from '@zephyr3d/device';
import { Quaternion } from '@zephyr3d/base';
import { Ray } from '@zephyr3d/base';
import { RenderStateSet } from '@zephyr3d/device';
import { SamplerOptions } from '@zephyr3d/device';
import { ShaderTypeFunc } from '@zephyr3d/device';
import { StructuredBuffer } from '@zephyr3d/device';
import { Texture2D } from '@zephyr3d/device';
import { Texture2DArray } from '@zephyr3d/device';
import { TextureCube } from '@zephyr3d/device';
import { TextureFormat } from '@zephyr3d/device';
import { TextureSampler } from '@zephyr3d/device';
import { TextureType } from '@zephyr3d/device';
import { TypedArray } from '@zephyr3d/base';
import { Vector2 } from '@zephyr3d/base';
import { Vector3 } from '@zephyr3d/base';
import { Vector4 } from '@zephyr3d/base';
import { VertexAttribFormat } from '@zephyr3d/device';
import { VertexBufferInfo } from '@zephyr3d/device';
import { VertexLayout } from '@zephyr3d/device';
import { VertexLayoutOptions } from '@zephyr3d/device';
import { VertexSemantic } from '@zephyr3d/device';
import { VertexStepMode } from '@zephyr3d/device';
import * as _zephyr3d_base from '@zephyr3d/base';
import * as _zephyr3d_device from '@zephyr3d/device';

// @public
export class AABBTree {
    constructor();
    constructor(rhs: AABBTree);
    buildFromPrimitives(vertices: number[] | TypedArray, indices: number[] | TypedArray, primitiveType: PrimitiveType): void;
    // @internal (undocumented)
    _buildSubNodes(): void;
    getTopLevelAABB(): AABB;
    rayIntersectionDistance(ray: Ray): number;
    rayIntersectionTest(ray: Ray): boolean;
    transform(matrix: Matrix4x4): void;
    // @internal (undocumented)
    verify(): void;
}

// @public
export abstract class AbstractPostEffect {
    constructor();
    protected addIntermediateFramebuffer(name: string, depth: 'none' | 'current' | 'temporal'): void;
    abstract apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // @internal (undocumented)
    protected createRenderStates(device: AbstractDevice): RenderStateSet;
    // @internal (undocumented)
    protected createVertexLayout(device: AbstractDevice): VertexLayout;
    dispose(): void;
    protected drawFullscreenQuad(renderStateSet?: RenderStateSet): void;
    get enabled(): boolean;
    set enabled(val: boolean);
    // (undocumented)
    protected _enabled: boolean;
    protected getIntermediateFramebuffer(name: string, format: TextureFormat, width: number, height: number): FrameBuffer;
    // (undocumented)
    protected _intermediateFramebuffers: {
        [name: string]: {
            framebuffer: FrameBuffer;
            depth: 'none' | 'current' | 'temporal';
        };
    };
    needFlip(device: AbstractDevice): boolean;
    get opaque(): boolean;
    // (undocumented)
    protected _opaque: boolean;
    // (undocumented)
    protected _outputTexture: Texture2D;
    // (undocumented)
    protected _quadRenderStateSet: RenderStateSet;
    // (undocumented)
    protected _quadVertexLayout: VertexLayout;
    abstract requireDepthAttachment(): boolean;
    abstract requireLinearDepthTexture(): boolean;
}

// @public
export class AnimationClip {
    constructor(name: string, model?: SceneNode);
    addSkeleton(skeleton: Skeleton, meshList: Mesh[], boundingBoxInfo: SkinnedBoundingBox[]): void;
    addTrack(node: SceneNode, track: AnimationTrack): this;
    // @internal (undocumented)
    protected _currentPlayTime: number;
    dispose(): void;
    // @internal (undocumented)
    protected _duration: number;
    isPlaying(): boolean;
    // @internal (undocumented)
    protected _isPlaying: boolean;
    // @internal (undocumented)
    protected _lastUpdateFrame: number;
    // @internal (undocumented)
    protected _model: SceneNode;
    get name(): string;
    // @internal (undocumented)
    protected _name: string;
    play(repeat: number, speedRatio: number): void;
    // @internal (undocumented)
    protected _repeat: number;
    // @internal (undocumented)
    protected _repeatCounter: number;
    rewind(): void;
    // @internal (undocumented)
    protected _skeletons: Map<Skeleton, {
        mesh: Mesh;
        bounding: SkinnedBoundingBox;
        box: BoundingBox;
    }[]>;
    // @internal (undocumented)
    protected _speedRatio: number;
    stop(): void;
    get timeDuration(): number;
    // @internal (undocumented)
    protected _tmpPosition: Vector3;
    // @internal (undocumented)
    protected _tmpRotation: Quaternion;
    // @internal (undocumented)
    protected _tmpScale: Vector3;
    get tracks(): Map<SceneNode, {
        poseTranslation: Vector3;
        poseRotation: Quaternion;
        poseScaling: Vector3;
        tracks: AnimationTrack[];
    }>;
    // @internal (undocumented)
    protected _tracks: Map<SceneNode, {
        poseTranslation: Vector3;
        poseRotation: Quaternion;
        poseScaling: Vector3;
        tracks: AnimationTrack[];
    }>;
    update(): void;
}

// @public
export class AnimationSet {
    constructor(scene: Scene);
    add(animation: AnimationClip): void;
    // (undocumented)
    dispose(): void;
    get(name: string): AnimationClip;
    getAnimationNames(): string[];
    isPlayingAnimation(name?: string): boolean;
    get numAnimations(): number;
    playAnimation(name: string, repeat?: number, speedRatio?: number): void;
    stopAnimation(name: string): void;
    update(): void;
}

// @public
export abstract class AnimationTrack {
    constructor(interpolator: Interpolator);
    abstract apply(node: SceneNode, currentTime: number, duration: number): boolean;
    // @internal (undocumented)
    protected _currentPlayTime: number;
    get interpolator(): Interpolator;
    // @internal (undocumented)
    protected _interpolator: Interpolator;
    get playing(): boolean;
    // @internal (undocumented)
    protected _playing: boolean;
    reset(): void;
    rewind(): void;
    start(): void;
    stop(): void;
}

// Warning: (ae-forgotten-export) The symbol "Application_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Application extends Application_base {
    constructor(opt: Partial<AppOptions>);
    get canRender(): boolean;
    get device(): AbstractDevice;
    get deviceType(): string;
    focus(): void;
    frame(): void;
    // Warning: (ae-forgotten-export) The symbol "InputManager" needs to be exported by the entry point index.d.ts
    get inputManager(): InputManager;
    static get instance(): Application;
    log(text: string, mode?: LogMode): void;
    get logger(): Logger;
    set logger(val: Logger);
    get options(): AppOptions;
    ready(): Promise<void>;
    run(): void;
    stop(): void;
    get timeElapsedInSeconds(): number;
}

// @public (undocumented)
export function applyMaterialMixins<M extends ((target: any) => any)[], T>(target: T, ...mixins: M): ExtractMixinType<M>;

// @public
export type AppOptions = {
    canvas: HTMLCanvasElement;
    backend: DeviceBackend;
    enableMSAA?: boolean;
    pixelRatio?: number;
};

// @public
export class AppResizeEvent {
    constructor(width: number, height: number);
    // (undocumented)
    height: number;
    // (undocumented)
    type: string;
    // (undocumented)
    width: number;
}

// @public
export class AppTickEvent {
    // (undocumented)
    type: string;
}

// @public
export class AssetManager {
    constructor();
    // Warning: (ae-forgotten-export) The symbol "AbstractModelLoader" needs to be exported by the entry point index.d.ts
    addModelLoader(loader: AbstractModelLoader): void;
    // Warning: (ae-forgotten-export) The symbol "AbstractTextureLoader" needs to be exported by the entry point index.d.ts
    addTextureLoader(loader: AbstractTextureLoader): void;
    // @internal (undocumented)
    static _builtinTextureLoaders: {
        [name: string]: (assetManager: AssetManager, texture?: BaseTexture) => Promise<BaseTexture>;
    };
    // @internal (undocumented)
    static _builtinTextures: {
        [name: string]: Promise<BaseTexture>;
    };
    clearCache(): void;
    // @internal (undocumented)
    doLoadTexture(loader: AbstractTextureLoader, url: string, mimeType: string, data: ArrayBuffer, srgb: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture): Promise<BaseTexture>;
    fetchBinaryData(url: string): Promise<ArrayBuffer>;
    fetchBuiltinTexture<T extends BaseTexture>(name: string, texture?: BaseTexture): Promise<T>;
    fetchModel(scene: Scene, url: string, mimeType?: string): Promise<{
        group: SceneNode;
        animationSet: AnimationSet;
    }>;
    // Warning: (ae-forgotten-export) The symbol "SharedModel" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    fetchModelData(scene: Scene, url: string, mimeType?: string): Promise<SharedModel>;
    fetchTextData(url: string): Promise<string>;
    fetchTexture<T extends BaseTexture>(url: string, options?: TextureFetchOptions<T>): Promise<T>;
    get httpRequest(): HttpRequest;
    // @internal (undocumented)
    loadBinaryData(url: string): Promise<ArrayBuffer>;
    // @internal (undocumented)
    loadModel(url: string, mimeType?: string, name?: string): Promise<SharedModel>;
    // @internal (undocumented)
    loadTextData(url: string): Promise<string>;
    // @internal (undocumented)
    loadTexture(url: string, mimeType?: string, srgb?: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture): Promise<BaseTexture>;
    purgeCache(): void;
    static setBuiltinTextureLoader(name: string, loader: (assetManager: AssetManager) => Promise<BaseTexture>): void;
}

// @public
export class BaseCameraController {
    constructor();
    // @internal (undocumented)
    _getCamera(): Camera;
    // @internal (undocumented)
    onKeyDown(evt: KeyboardEvent): boolean;
    protected _onKeyDown(evt: KeyboardEvent): boolean;
    // @internal (undocumented)
    onKeyUp(evt: KeyboardEvent): boolean;
    protected _onKeyUp(evt: KeyboardEvent): boolean;
    // @internal (undocumented)
    onMouseDown(evt: PointerEvent): boolean;
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseMove(evt: PointerEvent): boolean;
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseUp(evt: PointerEvent): boolean;
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseWheel(evt: WheelEvent): boolean;
    protected _onMouseWheel(evt: WheelEvent): boolean;
    reset(): void;
    // @internal (undocumented)
    _setCamera(camera: Camera): void;
    update(): void;
}

// @public
export abstract class BaseLight extends GraphNode {
    constructor(scene: Scene, type: number);
    // @internal (undocumented)
    abstract computeUniforms(): void;
    get diffuseAndIntensity(): Vector4;
    // @internal (undocumented)
    protected _diffuseIntensity: Vector4;
    get directionAndCutoff(): Vector4;
    // @internal (undocumented)
    protected _directionCutoff: Vector4;
    get intensity(): number;
    set intensity(val: number);
    // @internal (undocumented)
    protected _intensity: number;
    // @internal (undocumented)
    invalidateUniforms(): void;
    isDirectionLight(): this is DirectionalLight;
    isLight(): this is BaseLight;
    isPointLight(): this is PointLight;
    isPunctualLight(): this is PunctualLight;
    isSpotLight(): this is SpotLight;
    get lightType(): number;
    get positionAndRange(): Vector4;
    // @internal (undocumented)
    protected _positionRange: Vector4;
    setIntensity(val: number): this;
    // @internal (undocumented)
    protected _type: number;
    get viewMatrix(): Matrix4x4;
    get viewProjMatrix(): Matrix4x4;
}

// @public
export interface BatchDrawable extends Drawable {
    getInstanceId(renderPass: RenderPass): string;
}

// @public (undocumented)
export type BlendMode = 'none' | 'blend' | 'additive';

// Warning: (ae-forgotten-export) The symbol "BlinnMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class BlinnMaterial extends BlinnMaterial_base {
    constructor();
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get shininess(): number;
    set shininess(val: number);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export abstract class Blitter {
    constructor();
    blit(source: Texture2D, dest: Texture2D | FrameBuffer, sampler?: TextureSampler): void;
    blit(source: Texture2D, dest: Texture2DArray, layer: number, sampler?: TextureSampler): void;
    blit(source: Texture2DArray, dest: Texture2DArray, sampler?: TextureSampler): void;
    blit(source: Texture2DArray, dest: Texture2D | FrameBuffer, layer: number, sampler?: TextureSampler): void;
    blit(source: TextureCube, dest: TextureCube, sampler?: TextureSampler): void;
    blit(source: TextureCube, dest: Texture2D | FrameBuffer, face: number, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blit2D(source: Texture2D, dest: FrameBuffer, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blit2DArray(source: Texture2DArray, dest: FrameBuffer, layer: number, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blitCubeMap(source: TextureCube, dest: FrameBuffer, face: CubeFace, sampler?: TextureSampler): void;
    protected abstract calcHash(): string;
    get destRect(): number[];
    set destRect(val: number[]);
    // @internal (undocumented)
    protected _destRect: number[];
    abstract filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampeType: 'float' | 'int' | 'uint'): PBShaderExp;
    // @internal (undocumented)
    protected _flip: boolean;
    get hash(): string;
    // @internal (undocumented)
    protected _hash: string;
    invalidateHash(): void;
    // @internal (undocumented)
    protected _offsetParams: Vector4;
    readTexel(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, uv: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    get renderStates(): RenderStateSet;
    set renderStates(rs: RenderStateSet);
    // @internal (undocumented)
    protected _renderStates: RenderStateSet;
    get scissor(): number[];
    set scissor(val: number[]);
    // @internal (undocumented)
    protected _scissor: number[];
    setUniforms(bindGroup: BindGroup, sourceTex: BaseTexture): void;
    setup(scope: PBGlobalScope, type: BlitType): void;
    get srgbOut(): boolean;
    set srgbOut(val: boolean);
    // @internal (undocumented)
    protected _srgbOut: boolean;
    get viewport(): number[];
    set viewport(val: number[]);
    // @internal (undocumented)
    protected _viewport: number[];
    writeTexel(scope: PBInsideFunctionScope, type: BlitType, uv: PBShaderExp, texel: PBShaderExp): PBShaderExp;
}

// @public
export type BlitType = '2d' | '2d-array' | 'cube';

// @public
export class Bloom extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    dispose(): void;
    // @internal (undocumented)
    downsample(device: AbstractDevice, inputColorTexture: Texture2D, framebuffers: FrameBuffer[]): void;
    get downsampleLimit(): number;
    set downsampleLimit(val: number);
    // @internal (undocumented)
    finalCompose(device: AbstractDevice, srcTexture: Texture2D, bloomTexture: Texture2D): void;
    get intensity(): number;
    set intensity(val: number);
    get maxDownsampleLevel(): number;
    set maxDownsampleLevel(val: number);
    // @internal (undocumented)
    prefilter(device: AbstractDevice, srcTexture: Texture2D, fb: FrameBuffer): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get threshold(): number;
    set threshold(val: number);
    get thresholdKnee(): number;
    set thresholdKnee(val: number);
    // @internal (undocumented)
    upsample(device: AbstractDevice, framebuffers: FrameBuffer[]): void;
}

// @public
export class BoundingBox extends AABB implements BoundingVolume {
    constructor();
    constructor(box: AABB);
    constructor(minPoint: Vector3, maxPoint: Vector3);
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export class BoundingBoxTree extends AABBTree implements BoundingVolume {
    constructor();
    constructor(aabbtree: AABBTree);
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export interface BoundingVolume {
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export interface BoxCreationOptions extends ShapeCreationOptions {
    anchorX?: number;
    anchorY?: number;
    anchorZ?: number;
    size?: number;
    sizeX?: number;
    sizeY?: number;
    sizeZ?: number;
}

// @public
export class BoxFilterBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernelSize: number, blurSize: number);
    // @internal (undocumented)
    protected _blurSize: number;
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    // @internal (undocumented)
    protected _kernelSize: number;
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // @internal (undocumented)
    protected _logSpace: boolean;
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @internal (undocumented)
    protected _logSpaceMultiplier: number;
    // @internal (undocumented)
    protected _phase: 'horizonal' | 'vertical';
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
    // @internal (undocumented)
    protected _sigma: number;
}

// @public
export class BoxFrameShape extends Shape<BoxCreationOptions> {
    constructor(options?: BoxCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], indices: number[], minx: number, miny: number, minz: number, maxx: number, maxy: number, maxz: number): void;
    // @internal (undocumented)
    protected createDefaultOptions(): BoxCreationOptions;
}

// @public
export class BoxShape extends Shape<BoxCreationOptions> {
    constructor(options?: BoxCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[], minx: number, miny: number, minz: number, maxx: number, maxy: number, maxz: number): void;
    // @internal (undocumented)
    protected createDefaultOptions(): BoxCreationOptions;
}

// @public
export const BUILTIN_ASSET_TEST_CUBEMAP = "TEST_Cubemap";

// @public
export const BUILTIN_ASSET_TEXTURE_SHEEN_LUT = "LUT_Sheen";

// @public
export function calculateTBN(scope: PBInsideFunctionScope, worldPosition: PBShaderExp, uv: PBShaderExp, doubleSideLighting: boolean): PBShaderExp;

// @public
export function calculateTBNWithNormal(scope: PBInsideFunctionScope, worldPosition: PBShaderExp, worldNormal: PBShaderExp, uv: PBShaderExp, doubleSideLighting: boolean): PBShaderExp;

// @public
export class Camera extends SceneNode {
    constructor(scene: Scene, projectionMatrix?: Matrix4x4);
    get clearColor(): Vector4;
    set clearColor(val: Vector4);
    // @internal (undocumented)
    protected _clearColor: Vector4;
    get clipMask(): number;
    set clipMask(val: number);
    // @internal (undocumented)
    protected _clipMask: number;
    get clipPlane(): Plane;
    set clipPlane(plane: Plane);
    // @internal (undocumented)
    protected _clipPlane: Plane;
    // @internal (undocumented)
    protected _compute(): void;
    // @internal (undocumented)
    protected _computeProj(): void;
    get controller(): BaseCameraController;
    set controller(controller: BaseCameraController);
    // @internal (undocumented)
    protected _controller: BaseCameraController;
    // @internal (undocumented)
    protected _dirty: boolean;
    dispose(): void;
    get framebuffer(): FrameBuffer;
    set framebuffer(fb: FrameBuffer);
    // @internal (undocumented)
    protected _framebuffer: FrameBuffer;
    get frustum(): Frustum;
    // @internal (undocumented)
    protected _frustum: Frustum;
    // @internal (undocumented)
    protected _frustumV: Frustum;
    // (undocumented)
    get frustumViewSpace(): Frustum;
    getAspect(): number;
    getFarPlane(): number;
    getFOV(): number;
    getNearPlane(): number;
    getProjectionMatrix(): Matrix4x4;
    // (undocumented)
    getRotationMatrix(): Matrix4x4;
    getTanHalfFovy(): number;
    handleEvent(ev: Event, type?: string): boolean;
    // @internal (undocumented)
    protected _invalidate(projectMatrixChanged: boolean): void;
    get invViewProjectionMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _invViewProjMatrix: Matrix4x4;
    isCamera(): this is Camera;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    lookAtCubeFace(face: CubeFace, position?: Vector3): this;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    // @internal (undocumented)
    protected _projMatrix: Matrix4x4;
    // Warning: (ae-forgotten-export) The symbol "RenderLogger" needs to be exported by the entry point index.d.ts
    render(scene: Scene, compositor?: Compositor, logger?: RenderLogger): void;
    resetController(): void;
    // @internal (undocumented)
    protected _rotationMatrix: Matrix4x4;
    get sampleCount(): number;
    set sampleCount(val: number);
    // @internal (undocumented)
    protected _sampleCount: number;
    get scissor(): number[];
    set scissor(rect: number[]);
    // @internal (undocumented)
    protected _scissor: number[];
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    updateController(): void;
    get viewMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _viewMatrix: Matrix4x4;
    get viewport(): number[];
    set viewport(rect: number[]);
    // @internal (undocumented)
    protected _viewport: number[];
    // (undocumented)
    get viewProjectionMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _viewProjMatrix: Matrix4x4;
}

// Warning: (ae-internal-missing-underscore) The name "Clipmap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Clipmap {
    constructor(resolution: number);
    // (undocumented)
    _crossMesh: Primitive;
    // (undocumented)
    _crossMeshAABB: AABB;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(context: ClipmapDrawContext, numMipmaps: number): number;
    // (undocumented)
    _emptyTileMesh: Primitive;
    // (undocumented)
    _emptyTileMeshBBox: AABB;
    // (undocumented)
    _fillerMesh: Primitive;
    // (undocumented)
    _fillerMeshAABB: AABB;
    // (undocumented)
    generateCrossMesh(): void;
    // (undocumented)
    generateEmptyTileMesh(): void;
    // (undocumented)
    generateFillerMesh(): void;
    // (undocumented)
    generateSeamMesh(): void;
    // (undocumented)
    generateTileMesh(): void;
    // (undocumented)
    generateTrimMesh(): void;
    // (undocumented)
    _seamMesh: Primitive;
    // (undocumented)
    _seamMeshAABB: AABB;
    // (undocumented)
    _tileMesh: Primitive;
    // (undocumented)
    _tileMeshBBox: AABB;
    // (undocumented)
    get tileResolution(): number;
    set tileResolution(val: number);
    // (undocumented)
    _tileResolution: number;
    // (undocumented)
    _trimMesh: Primitive;
    // (undocumented)
    _trimMeshAABB: AABB;
}

// Warning: (ae-internal-missing-underscore) The name "ClipmapDrawContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ClipmapDrawContext = {
    camera: Camera;
    position: Vector3;
    gridScale: number;
    minWorldPos: Vector2;
    maxWorldPos: Vector2;
    AABBExtents?: Vector2;
    drawPrimitive(prim: Primitive, modelMatrix: Matrix4x4, offset: Vector2, scale: number, gridScale: number): any;
};

// @public
export class Compositor {
    constructor();
    appendPostEffect(postEffect: AbstractPostEffect): void;
    // @internal (undocumented)
    begin(ctx: DrawContext): void;
    // @internal (undocumented)
    static _blit(device: AbstractDevice, srcTex: Texture2D, srgbOutput: boolean): void;
    // @internal (undocumented)
    drawPostEffects(ctx: DrawContext, opaque: boolean, sceneDepthTexture: Texture2D): void;
    // @internal (undocumented)
    end(ctx: DrawContext): void;
    getPostEffects(): AbstractPostEffect[];
    // @internal (undocumented)
    needDrawPostEffects(): boolean;
    // @internal (undocumented)
    protected _postEffectsOpaque: AbstractPostEffect[];
    // @internal (undocumented)
    protected _postEffectsTransparency: AbstractPostEffect[];
    removePostEffect(postEffect: AbstractPostEffect): void;
    // @internal (undocumented)
    requireLinearDepth(): boolean;
}

// @public
export interface CompositorContext {
    // (undocumented)
    finalFramebuffer: FrameBuffer;
    // (undocumented)
    msFramebuffer?: FrameBuffer;
    // (undocumented)
    pingpongFramebuffers: FrameBuffer[];
    // (undocumented)
    writeIndex: number;
}

// @public
export class CopyBlitter extends Blitter {
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
}

// Warning: (ae-internal-missing-underscore) The name "createProgramFFT2H" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramFFT2H(limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramFFT2V" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramFFT2V(limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramH0" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramH0(): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramHk" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramHk(limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramOcean" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramOcean(impl?: WaterShaderImpl): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramPostFFT2" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramPostFFT2(limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// @public
export class CullVisitor implements Visitor {
    constructor(renderPass: RenderPass, camera: Camera, renderQueue: RenderQueue, primaryCamera: Camera);
    get camera(): Camera;
    set camera(camera: Camera);
    get frustum(): _zephyr3d_base.Frustum;
    // @internal (undocumented)
    protected getClipStateWithAABB(aabb: AABB): ClipState;
    // @internal (undocumented)
    protected getClipStateWithNode(node: GraphNode): ClipState;
    get primaryCamera(): Camera;
    // @internal (undocumented)
    push(camera: Camera, drawable: Drawable, renderOrder: number): void;
    get renderPass(): RenderPass;
    get renderQueue(): RenderQueue;
    visit(target: SceneNode | OctreeNode): unknown;
    // @internal (undocumented)
    visitMesh(node: Mesh): boolean;
    // @internal (undocumented)
    visitOctreeNode(node: OctreeNode): boolean;
    // @internal (undocumented)
    visitPunctualLight(node: PunctualLight): boolean;
    // @internal (undocumented)
    visitTerrain(node: Terrain): boolean;
}

// @public
export interface CylinderCreationOptions extends ShapeCreationOptions {
    anchorX?: number;
    anchorY?: number;
    anchorZ?: number;
    bottomRadius?: number;
    height?: number;
    heightDetail?: number;
    radialDetail?: number;
    topRadius?: number;
}

// @public
export class CylinderShape extends Shape<CylinderCreationOptions> {
    constructor(options?: CylinderCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[]): void;
    // @internal (undocumented)
    protected createDefaultOptions(): CylinderCreationOptions;
}

// @public
export function decode2HalfFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeNormalizedFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeRGBM(scope: PBInsideFunctionScope, rgbm: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// Warning: (ae-internal-missing-underscore) The name "defaultBuildParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const defaultBuildParams: OceanFieldBuildParams;

// @public
export class DepthPass extends RenderPass {
    constructor();
    // @internal (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    // @internal (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
}

// @public
export class DirectionalLight extends PunctualLight {
    constructor(scene: Scene);
    // @internal (undocumented)
    computeBoundingVolume(bv: BoundingVolume): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    // @override
    isDirectionLight(): this is DirectionalLight;
    get sunLight(): boolean;
    set sunLight(val: boolean);
}

// @public
export interface Drawable {
    draw(ctx: DrawContext): any;
    getBoneMatrices(): Texture2D;
    getInstanceColor(): Vector4;
    getInvBindMatrix(): Matrix4x4;
    getName(): string;
    getPickTarget(): GraphNode;
    getQueueType(): number;
    getSortDistance(camera: Camera): number;
    getXForm(): XForm;
    isBatchable(): this is BatchDrawable;
    isUnlit(): boolean;
}

// @public
export interface DrawContext {
    applyFog: boolean;
    camera: Camera;
    // Warning: (ae-forgotten-export) The symbol "ClusteredLight" needs to be exported by the entry point index.d.ts
    clusteredLight?: ClusteredLight;
    compositor?: Compositor;
    compositorContex?: CompositorContext;
    // @internal (undocumented)
    currentShadowLight?: PunctualLight;
    defaultViewport?: boolean;
    depthFormat?: TextureFormat;
    depthTexture?: Texture2D;
    drawEnvLight: boolean;
    env: Environment;
    flip: boolean;
    instanceData?: InstanceData;
    lightBlending: boolean;
    linearDepthTexture?: Texture2D;
    logger?: RenderLogger;
    primaryCamera: Camera;
    queue: number;
    renderPass: RenderPass;
    renderPassHash: string;
    scene: Scene;
    // @internal (undocumented)
    shadowMapInfo?: Map<PunctualLight, ShadowMapParams>;
    sunLight?: DirectionalLight;
    target: Drawable;
    timestamp: number;
    viewportHeight?: number;
    viewportWidth?: number;
    viewportX?: number;
    viewportY?: number;
}

// @public
export function encode2HalfToRGBA(scope: PBInsideFunctionScope, a: PBShaderExp | number, b: PBShaderExp | number): PBShaderExp;

// @public
export function encodeColorOutput(scope: PBInsideFunctionScope, outputColor: PBShaderExp): PBShaderExp;

// @public
export function encodeFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeNormalizedFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeRGBM(scope: PBInsideFunctionScope, rgb: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// @public
export class EnvConstantAmbient extends EnvironmentLighting {
    constructor(ambientColor?: Vector4);
    get ambientColor(): Vector4;
    set ambientColor(ambientColor: Vector4);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @override
    isConstant(): this is EnvConstantAmbient;
    // @internal (undocumented)
    static readonly UNIFORM_NAME_CONSTANT_AMBIENT = "zConstantAmbient";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EnvHemisphericAmbient extends EnvironmentLighting {
    constructor(ambientUp: Vector4, ambientDown: Vector4);
    get ambientDown(): Vector4;
    set ambientDown(color: Vector4);
    get ambientUp(): Vector4;
    set ambientUp(color: Vector4);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @override
    isHemispheric(): this is EnvHemisphericAmbient;
    // @internal (undocumented)
    static readonly UNIFORM_NAME_AMBIENT_DOWN = "zHemisphericAmbientDown";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_AMBIENT_UP = "zHemisphericAmbientUp";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EnvIBL extends EnvironmentLighting {
    constructor(radianceMap?: TextureCube, irradianceMap?: TextureCube);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    get irradianceMap(): TextureCube;
    set irradianceMap(tex: TextureCube);
    // @override
    isIBL(): this is EnvIBL;
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_IRRADIANCE_MAP = "zIBLIrradianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP = "zIBLRadianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD = "zIBLRadianceMapMaxLOD";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class Environment {
    // @internal
    constructor();
    // @internal (undocumented)
    getHash(ctx: DrawContext): string;
    get light(): EnvLightWrapper;
    // @internal (undocumented)
    needSceneDepthTexture(): boolean;
    get sky(): SkyRenderer;
}

// @public
export abstract class EnvironmentLighting {
    abstract getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    abstract getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    abstract getType(): EnvLightType;
    abstract hasIrradiance(): boolean;
    abstract hasRadiance(): boolean;
    abstract initShaderBindings(pb: ProgramBuilder): void;
    isConstant(): this is EnvConstantAmbient;
    isHemispheric(): this is EnvHemisphericAmbient;
    isIBL(): this is EnvIBL;
    abstract updateBindGroup(bg: BindGroup): void;
}

// @public
export type EnvLightType = 'ibl' | 'hemisphere' | 'constant' | 'none';

// @public
export class EnvLightWrapper {
    // @internal
    constructor();
    get ambientColor(): Vector4;
    set ambientColor(val: Vector4);
    get ambientDown(): Vector4;
    set ambientDown(val: Vector4);
    get ambientUp(): Vector4;
    set ambientUp(val: Vector4);
    // @internal (undocumented)
    get envLight(): EnvironmentLighting;
    // @internal (undocumented)
    getHash(ctx: DrawContext): string;
    get irradianceMap(): TextureCube;
    set irradianceMap(tex: TextureCube);
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    get strength(): number;
    set strength(val: number);
    get type(): EnvLightType;
    set type(val: EnvLightType);
}

// Warning: (ae-forgotten-export) The symbol "ShadowImpl" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "ESM" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class ESM extends ShadowImpl {
    constructor(kernelSize?: number, blurSize?: number, depthScale?: number);
    // Warning: (ae-forgotten-export) The symbol "BlurBlitter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _blitterH: BlurBlitter;
    // (undocumented)
    protected _blitterV: BlurBlitter;
    // (undocumented)
    get blur(): boolean;
    set blur(val: boolean);
    // (undocumented)
    protected _blur: boolean;
    // (undocumented)
    get blurSize(): number;
    set blurSize(val: number);
    // (undocumented)
    protected _blurSize: number;
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    protected _depthScale: number;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // (undocumented)
    protected _logSpace: boolean;
    // (undocumented)
    get mipmap(): boolean;
    set mipmap(b: boolean);
    // (undocumented)
    protected _mipmap: boolean;
    // (undocumented)
    postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// @public
export class EulerRotationTrack extends AnimationTrack {
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[]);
    apply(node: SceneNode, currentTime: number, duration: number): boolean;
}

// @public (undocumented)
export type ExtractMixinReturnType<M> = M extends (target: infer A) => infer R ? R : never;

// @public (undocumented)
export type ExtractMixinType<M> = M extends [infer First] ? ExtractMixinReturnType<First> : M extends [infer First, ...infer Rest] ? ExtractMixinReturnType<First> & ExtractMixinType<[...Rest]> : never;

// @public
export type FogType = 'linear' | 'exp' | 'exp2' | 'scatter' | 'none';

// @public
export class FPSCameraController extends BaseCameraController {
    constructor(options?: FPSCameraControllerOptions);
    // @override
    protected _onKeyDown(evt: KeyboardEvent): boolean;
    // @override
    protected _onKeyUp(evt: KeyboardEvent): boolean;
    // @override
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @override
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @override
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: FPSCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface FPSCameraControllerOptions {
    controlKeys?: {
        up: string;
        down: string;
        forward: string;
        backward: string;
        left: string;
        right: string;
    };
    moveSpeed?: number;
    rotateSpeed?: number;
}

// @public
export class FXAA extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    dispose(): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export function gammaToLinear(scope: PBInsideFunctionScope, color: PBShaderExp): PBShaderExp;

// @public
export class GaussianBlurBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernalSize: number, sigma: number, blurSize: number);
    get blurSize(): number;
    set blurSize(val: number);
    // @internal (undocumented)
    protected _blurSize: number;
    // @override
    protected calcHash(): string;
    get depthCutoff(): number;
    set depthCutoff(val: number);
    // @internal (undocumented)
    protected _depthCutoff: number;
    // @internal (undocumented)
    protected _depthTex: Texture2D;
    get depthTexture(): Texture2D;
    set depthTexture(tex: Texture2D);
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    get kernelSize(): number;
    set kernelSize(val: number);
    // @internal (undocumented)
    protected _kernelSize: number;
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // @internal (undocumented)
    protected _logSpace: boolean;
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @internal (undocumented)
    protected _logSpaceMultiplier: number;
    // @internal (undocumented)
    protected _phase: 'horizonal' | 'vertical';
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
    // @internal (undocumented)
    protected _sigma: number;
}

// @public
export class GraphNode extends SceneNode {
    constructor(scene: Scene);
    getBoneMatrices(): Texture2D;
    getInvBindMatrix(): Matrix4x4;
    getName(): string;
    getSortDistance(camera: Camera): number;
    getXForm(): XForm;
    isBatchable(): this is BatchDrawable;
    // @override
    isGraphNode(): this is GraphNode;
    get renderOrder(): number;
    set renderOrder(val: number);
}

// Warning: (ae-forgotten-export) The symbol "GrassMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class GrassMaterial extends GrassMaterial_base {
    constructor(terrainSize: Vector2, normalMap: Texture2D, grassTexture?: Texture2D);
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // @override
    isTransparent(): boolean;
    // @override
    supportLighting(): boolean;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export class Grayscale extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    dispose(): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "HeightField" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class HeightField {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    computeNormals(): Uint8Array;
    // (undocumented)
    computeNormalVectors(): Vector3[];
    // (undocumented)
    getBBoxTree(): HeightfieldBBoxTree;
    // (undocumented)
    getBoundingbox(): BoundingBox;
    // (undocumented)
    getHeight(x: number, z: number): number;
    // (undocumented)
    getHeights(): Float32Array;
    // (undocumented)
    getOffsetX(): number;
    // (undocumented)
    getOffsetZ(): number;
    // (undocumented)
    getRealHeight(x: number, z: number): number;
    // (undocumented)
    getRealNormal(x: number, z: number, normal?: Vector3): Vector3;
    // (undocumented)
    getSizeX(): number;
    // (undocumented)
    getSizeZ(): number;
    // (undocumented)
    getSpacingX(): number;
    // (undocumented)
    getSpacingZ(): number;
    // (undocumented)
    getVerticalScale(): number;
    // (undocumented)
    init(sizeX: number, sizeZ: number, offsetX: number, offsetZ: number, scaleX: number, scaleY: number, scaleZ: number, heights: Float32Array): boolean;
    // (undocumented)
    get normals(): Vector3[];
    // (undocumented)
    rayIntersect(ray: Ray): number | null;
}

// Warning: (ae-internal-missing-underscore) The name "HeightfieldBBoxTree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class HeightfieldBBoxTree {
    constructor(res_x: number, res_y: number, spacing_x: number, spacing_z: number, vertices: Vector4[]);
    // (undocumented)
    allocNode(): HeightfieldBBoxTreeNode;
    // (undocumented)
    computeNodeBoundingBox(node: HeightfieldBBoxTreeNode, bbox: BoundingBox, vertices: Vector4[]): void;
    // (undocumented)
    create(res_x: number, res_y: number, vertices: Vector4[]): boolean;
    // (undocumented)
    createChildNode(node: HeightfieldBBoxTreeNode, x: number, y: number, w: number, h: number, vertices: Vector4[]): boolean;
    // (undocumented)
    getHeight(x: number, y: number): number;
    // (undocumented)
    getHeights(): Float32Array;
    // (undocumented)
    getNormal(x: number, y: number, normal?: Vector3): Vector3;
    // (undocumented)
    getRealHeight(x: number, y: number): number;
    // (undocumented)
    getRealNormal(x: number, y: number, normal?: Vector3): Vector3;
    // (undocumented)
    getRootNode(): HeightfieldBBoxTreeNode;
    // (undocumented)
    rayIntersect(ray: Ray): number | null;
    // (undocumented)
    rayIntersectR(ray: Ray, node: HeightfieldBBoxTreeNode): number | null;
}

// Warning: (ae-internal-missing-underscore) The name "HeightfieldBBoxTreeNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface HeightfieldBBoxTreeNode {
    // (undocumented)
    bbox: BoundingBox;
    // (undocumented)
    h: number[];
    // (undocumented)
    left: HeightfieldBBoxTreeNode;
    // (undocumented)
    rc: {
        x: number;
        y: number;
        w: number;
        h: number;
    };
    // (undocumented)
    right: HeightfieldBBoxTreeNode;
}

// @public (undocumented)
export interface IMaterial {
    // (undocumented)
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean, pass: number): void;
    // (undocumented)
    beginDraw(pass: number, ctx: DrawContext): boolean;
    // (undocumented)
    clearBindGroupCache(): number;
    // (undocumented)
    createHash(renderPassType: number, pass: number): string;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(primitive: Primitive, ctx: DrawContext, numInstances?: number): void;
    // (undocumented)
    endDraw(pass: number): void;
    // (undocumented)
    getMaterialBindGroup(): BindGroup;
    // Warning: (ae-forgotten-export) The symbol "ProgramInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getOrCreateProgram(ctx: DrawContext, pass: number): ProgramInfo;
    // (undocumented)
    getQueueType(): number;
    // (undocumented)
    readonly id: number;
    // (undocumented)
    isBatchable(): boolean;
    // (undocumented)
    isTransparent(pass: number): boolean;
    // (undocumented)
    optionChanged(changeHash: boolean): void;
    // (undocumented)
    stateSet: RenderStateSet;
    // (undocumented)
    supportLighting(): boolean;
}

// @public (undocumented)
export type IMixinAlbedoColor = {
    albedoColor: Vector4;
    calculateAlbedoColor(scope: PBInsideFunctionScope): PBShaderExp;
} & TextureMixinInstanceTypes<['albedo']>;

// @public (undocumented)
export type IMixinLight = {
    normalScale: number;
    normalMapMode: 'tangent-space' | 'object-space';
    doubleSidedLighting: boolean;
    vertexNormal: boolean;
    vertexTangent: boolean;
    needCalculateEnvLight(): boolean;
    getEnvLightIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    getEnvLightRadiance(scope: PBInsideFunctionScope, reflectVec: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    calculateViewVector(scope: PBInsideFunctionScope): PBShaderExp;
    calculateReflectionVector(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp): PBShaderExp;
    calculateNormal(scope: PBInsideFunctionScope): PBShaderExp;
    calculateNormalAndTBN(scope: PBInsideFunctionScope): PBShaderExp;
    calculateLightAttenuation(scope: PBInsideFunctionScope, type: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateLightDirection(scope: PBInsideFunctionScope, type: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateShadow(scope: PBInsideFunctionScope, NoL: PBShaderExp): PBShaderExp;
    forEachLight(scope: PBInsideFunctionScope, callback: (this: PBInsideFunctionScope, type: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp, colorIntensity: PBShaderExp, shadow: boolean) => void): void;
} & TextureMixinInstanceTypes<['normal']> & IMixinAlbedoColor;

// @public (undocumented)
export type IMixinPBRCommon = {
    ior: number;
    emissiveColor: Vector3;
    emissiveStrength: number;
    occlusionStrength: number;
    sheen: boolean;
    sheenColorFactor: Vector3;
    sheenRoughnessFactor: number;
    clearcoat: boolean;
    clearcoatIntensity: number;
    clearcoatRoughnessFactor: number;
    clearcoatNormalScale: number;
    getCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
    fresnelSchlick(scope: PBInsideFunctionScope, cosTheta: PBShaderExp, F0: PBShaderExp): PBShaderExp;
    distributionGGX(scope: PBInsideFunctionScope, NdotH: PBShaderExp, alphaRoughness: PBShaderExp): PBShaderExp;
    visGGX(scope: PBInsideFunctionScope, NdotV: PBShaderExp, NdotL: PBShaderExp, alphaRoughness: PBShaderExp): PBShaderExp;
    getCommonDatasStruct(scope: PBInsideFunctionScope): ShaderTypeFunc;
    calculateEmissiveColor(scope: PBInsideFunctionScope): PBShaderExp;
    getF0(scope: PBInsideFunctionScope): PBShaderExp;
    directLighting(scope: PBInsideFunctionScope, lightDir: PBShaderExp, lightColor: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp): any;
    indirectLighting(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp): any;
} & TextureMixinInstanceTypes<[
'occlusion',
'emissive',
'sheenColor',
'sheenRoughness',
'clearcoatIntensity',
'clearcoatRoughness',
'clearcoatNormal'
]>;

// @public (undocumented)
export type IMixinPBRMetallicRoughness = {
    metallic: number;
    roughness: number;
    specularFactor: Vector4;
    PBRLight(scope: PBFunctionScope, normal: PBShaderExp, TBN: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['metallicRoughness', 'occlusion', 'specular', 'specularColor']>;

// @public (undocumented)
export type IMixinPBRSpecularGlossiness = {
    specularFactor: Vector4;
    glossinessFactor: number;
    PBRLight(scope: PBFunctionScope, normal: PBShaderExp, TBN: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['specular']>;

// @public (undocumented)
export interface IMixinVertexColor {
    // (undocumented)
    getVertexColor(scope: PBInsideFunctionScope): any;
    // (undocumented)
    vertexColor: boolean;
}

// @public
export interface InstanceData {
    // (undocumented)
    hash: string;
    // (undocumented)
    instanceColorList?: Vector4[];
    // (undocumented)
    nodeList?: GraphNode[];
    // (undocumented)
    worldMatrices: Matrix4x4[];
}

// Warning: (ae-forgotten-export) The symbol "LambertMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class LambertMaterial extends LambertMaterial_base {
    constructor();
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export const LIGHT_TYPE_DIRECTIONAL = 1;

// @public
export const LIGHT_TYPE_NONE = 0;

// @public
export const LIGHT_TYPE_POINT = 2;

// @public
export const LIGHT_TYPE_SPOT = 3;

// Warning: (ae-internal-missing-underscore) The name "LightPass" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class LightPass extends RenderPass {
    constructor();
    // (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    // (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
    // (undocumented)
    protected renderLightPass(ctx: DrawContext, items: RenderQueueItem[], lights: PunctualLight[]): void;
    // (undocumented)
    protected _shadowMapHash: string;
}

// @public
export function linearDepthToNonLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;

// @public
export function linearToGamma(scope: PBInsideFunctionScope, color: PBShaderExp): any;

// @public
export interface Logger {
    // (undocumented)
    log(text: string, mode?: LogMode): void;
}

// @public
export type LogMode = 'info' | 'warn' | 'error' | 'debug';

// @public
export class Material implements IMaterial {
    constructor();
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean, pass: number): void;
    protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    beginDraw(pass: number, ctx: DrawContext): boolean;
    // @internal (undocumented)
    static bindGroupGarbageCollect(bindGroup: BindGroup): void;
    // @internal (undocumented)
    clearBindGroupCache(): number;
    // @internal (undocumented)
    createHash(renderPassType: number, pass: number): string;
    protected _createHash(renderPassType: number): string;
    // @internal (undocumented)
    protected createProgram(ctx: DrawContext, pass: number): GPUProgram;
    protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, pass: number): GPUProgram;
    // @internal (undocumented)
    protected createRenderStateSet(): RenderStateSet;
    // (undocumented)
    dispose(): void;
    draw(primitive: Primitive, ctx: DrawContext, numInstances?: number): void;
    drawPrimitive(pass: number, primitive: Primitive, ctx: DrawContext, numInstances: number): void;
    endDraw(pass: number): void;
    static garbageCollect(ts: number): number;
    static getGCOptions(): MaterialGCOptions;
    // @internal (undocumented)
    protected getHash(renderPassType: number, pass: number): string;
    getMaterialBindGroup(): BindGroup;
    getOrCreateProgram(ctx: DrawContext, pass: number): ProgramInfo;
    // @internal (undocumented)
    static getProgramByHashIndex(hash: string, index: number): GPUProgram<unknown>;
    // (undocumented)
    getQueueType(): number;
    // @internal (undocumented)
    protected _hash: string[][];
    get id(): number;
    isBatchable(): boolean;
    isTransparent(pass: number): boolean;
    // (undocumented)
    get numPasses(): number;
    set numPasses(val: number);
    // @internal (undocumented)
    protected _numPasses: number;
    // @internal (undocumented)
    optionChanged(changeHash: boolean): void;
    // @internal (undocumented)
    protected _renderStateSet: RenderStateSet;
    static setGCOptions(opt: MaterialGCOptions): void;
    get stateSet(): RenderStateSet;
    set stateSet(stateset: RenderStateSet);
    supportLighting(): boolean;
}

// @public
export type MaterialGCOptions = {
    disabled?: boolean;
    drawableCountThreshold?: number;
    materialCountThreshold?: number;
    inactiveTimeDuration?: number;
    verbose?: boolean;
};

// @public
export const MAX_CLUSTERED_LIGHTS = 255;

// @public
export class Mesh extends GraphNode implements BatchDrawable {
    constructor(scene: Scene, primitive?: Primitive, material?: Material);
    // @internal (undocumented)
    protected _animatedBoundingBox: BoundingBox;
    // @internal (undocumented)
    protected _batchable: boolean;
    // @internal (undocumented)
    protected _bboxChangeCallback: () => void;
    // @internal (undocumented)
    protected _boneMatrices: Texture2D;
    // @internal (undocumented)
    protected _boundingBoxNode: Mesh;
    get castShadow(): boolean;
    set castShadow(b: boolean);
    // @internal (undocumented)
    protected _castShadow: boolean;
    // @internal (undocumented)
    computeBoundingVolume(bv: BoundingVolume): BoundingVolume;
    dispose(): void;
    draw(ctx: DrawContext): void;
    get drawBoundingBox(): boolean;
    set drawBoundingBox(val: boolean);
    getBoneMatrices(): Texture2D;
    getInstanceColor(): Vector4;
    getInstanceId(renderPass: RenderPass): string;
    getInvBindMatrix(): Matrix4x4;
    getName(): string;
    getPickTarget(): GraphNode;
    getQueueType(): number;
    getXForm(): XForm;
    // @internal (undocumented)
    protected _instanceColor: Vector4;
    // @internal (undocumented)
    protected _instanceHash: string;
    // @internal (undocumented)
    protected _invBindMatrix: Matrix4x4;
    isBatchable(): this is BatchDrawable;
    isMesh(): boolean;
    isUnlit(): boolean;
    get material(): Material;
    set material(m: Material);
    get primitive(): Primitive;
    set primitive(prim: Primitive);
    setAnimatedBoundingBox(bbox: BoundingBox): void;
    setBoneMatrices(matrices: Texture2D): void;
    setInvBindMatrix(matrix: Matrix4x4): void;
}

// @public (undocumented)
export class MeshMaterial extends Material {
    constructor(...args: any[]);
    get alphaCutoff(): number;
    set alphaCutoff(val: number);
    // (undocumented)
    get alphaToCoverage(): boolean;
    set alphaToCoverage(val: boolean);
    // @override
    protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    beginDraw(pass: number, ctx: DrawContext): boolean;
    get blendMode(): BlendMode;
    set blendMode(val: BlendMode);
    // @override
    protected _createHash(renderPassType: number): string;
    // @internal (undocumented)
    protected createProgram(ctx: DrawContext, pass: number): GPUProgram;
    // @override
    protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, pass: number): GPUProgram;
    get drawContext(): DrawContext;
    // (undocumented)
    static readonly FEATURE_ALPHABLEND = 1;
    // (undocumented)
    static readonly FEATURE_ALPHATEST = 0;
    // (undocumented)
    static readonly FEATURE_ALPHATOCOVERAGE = 2;
    featureUsed<T = unknown>(feature: number): T;
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    getQueueType(): number;
    // Warning: (ae-forgotten-export) The symbol "ShaderHelper" needs to be exported by the entry point index.d.ts
    get helper(): typeof ShaderHelper;
    isTransparent(pass: number): boolean;
    needFragmentColor(ctx?: DrawContext): boolean;
    // (undocumented)
    static readonly NEXT_FEATURE_INDEX: number;
    get opacity(): number;
    set opacity(val: number);
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): void;
    get pass(): number;
    protected updateBlendingAndDepthState(pass: number, ctx: DrawContext): void;
    protected updateDepthState(pass: number, ctx: DrawContext): void;
    useFeature(feature: number, use: unknown): void;
    vertexShader(scope: PBFunctionScope): void;
}

// @public (undocumented)
export function mixinAlbedoColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinAlbedoColor);

// @public (undocumented)
export function mixinLight<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinLight);

// @public (undocumented)
export function mixinPBRCommon<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRCommon);

// @public (undocumented)
export function mixinPBRMetallicRoughness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRMetallicRoughness);

// @public (undocumented)
export function mixinPBRSpecularGlossness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRSpecularGlossiness);

// @public (undocumented)
export function mixinTextureProps<U extends string>(name: U): <T extends typeof MeshMaterial>(BaseCls: T, vertex?: boolean) => T & (new (...args: any[]) => TextureProp<U> & TexturePropUniforms<U>);

// @public (undocumented)
export function mixinVertexColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinVertexColor);

// @public
export class Model extends GraphNode {
    constructor(scene: Scene);
    createAnimation(name?: string): AnimationClip;
    deleteAnimation(name: string): void;
    getAnimationNames(): string[];
    isPlayingAnimation(name?: string): boolean;
    playAnimation(name: string, repeat?: number): void;
    stopAnimation(name: string): void;
    update(): void;
}

// @public
export function noise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export function noisef(scope: PBInsideFunctionScope, p: PBShaderExp): any;

// @public
export function nonLinearDepthToLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;

// @public
export function nonLinearDepthToLinearNormalized(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;

// @public
export type NumberTrackHandler = (node: SceneNode, value: Float32Array) => void;

// Warning: (ae-internal-missing-underscore) The name "OceanFieldBuildParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface OceanFieldBuildParams {
    alignment: number;
    cascades: [OceanFieldCascade, OceanFieldCascade, OceanFieldCascade];
    foamParams: Vector2;
    randomSeed: number;
    resolution: number;
    wind: Vector2;
}

// Warning: (ae-internal-missing-underscore) The name "OceanFieldCascade" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface OceanFieldCascade {
    croppiness: number;
    maxWave: number;
    minWave: number;
    size: number;
    strength: number;
}

// @public
export class Octree {
    constructor(scene: Scene, rootSize?: number, leafSize?: number);
    finalize(): void;
    getChunk(level: number): OctreeNodeChunk;
    getLeafSize(): number;
    getNumChunks(): number;
    getRootNode(): OctreeNode;
    getRootSize(): number;
    getScene(): Scene;
    initialize(rootSize: number, leafSize: number): void;
    locateNodeChain(candidate: OctreeNode, center: Vector3, radius: number): OctreeNode;
    placeNode(node: GraphNode): void;
    removeNode(node: GraphNode): void;
}

// @public
export class OctreeNode {
    constructor();
    addNode(node: GraphNode): void;
    clearNodes(): void;
    createChildren(): void;
    getBox(): AABB;
    getBoxLoosed(): AABB;
    getChild(placement: OctreePlacement): OctreeNode;
    getChunk(): OctreeNodeChunk;
    getLevel(): number;
    getMaxPoint(): Vector3;
    getMaxPointLoosed(): Vector3;
    getMinPoint(): Vector3;
    getMinPointLoosed(): Vector3;
    getNodes(): GraphNode[];
    getOrCreateChild(placement: OctreePlacement): OctreeNode;
    getOrCreateParent(): OctreeNode;
    getParent(): OctreeNode;
    getPosition(): number;
    getReference(): number;
    invalidateBox(): void;
    removeNode(node: GraphNode): void;
    setChunk(chunk: OctreeNodeChunk): void;
    setPosition(index: number): void;
    tidy(): boolean;
    traverse(v: Visitor): void;
}

// @public
export class OctreeNodeChunk {
    constructor(octree: Octree);
    clearNodes(): void;
    empty(): boolean;
    freeNode(node: OctreeNode): void;
    freeNodeByIndex(index: number): void;
    getChildIndex(index: number, placement: OctreePlacement): number;
    getDimension(): number;
    getLevel(): number;
    getNext(): OctreeNodeChunk;
    getNode(index: number): OctreeNode;
    getNodeSize(): number;
    getOctree(): Octree;
    getOrCreateNode(index: number): OctreeNode;
    getOrCreateNodeChain(index: number): OctreeNode;
    getParentIndex(index: number): number;
    getPrev(): OctreeNodeChunk;
    getWorldSize(): number;
    setDimension(dimension: number): void;
    setLevel(level: number): void;
    setNext(chunk: OctreeNodeChunk): void;
    setNodeSize(size: number): void;
    setPrev(chunk: OctreeNodeChunk): void;
}

// @public
export enum OctreePlacement {
    // (undocumented)
    NNN = 7,
    // (undocumented)
    NNP = 6,
    // (undocumented)
    NPN = 5,
    // (undocumented)
    NPP = 4,
    // (undocumented)
    PNN = 3,
    // (undocumented)
    PNP = 2,
    // (undocumented)
    PPN = 1,
    // (undocumented)
    PPP = 0
}

// @public
export class OrbitCameraController extends BaseCameraController {
    constructor(options?: OrbitCameraControllerOptions);
    // @override
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @override
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @override
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @override
    protected _onMouseWheel(evt: WheelEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: OrbitCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface OrbitCameraControllerOptions {
    damping?: number;
    distance?: number;
    rotateSpeed?: number;
    zoomSpeed?: number;
}

// @public
export class OrthoCamera extends Camera {
    constructor(scene: Scene, left: number, right: number, bottom: number, top: number, near: number, far: number);
    get bottom(): number;
    set bottom(val: number);
    // @internal (undocumented)
    protected _computeProj(): void;
    get far(): number;
    set far(val: number);
    get left(): number;
    set left(val: number);
    get near(): number;
    set near(val: number);
    get right(): number;
    set right(val: number);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get top(): number;
    set top(val: number);
}

// @public
export function panoramaToCubemap(tex: Texture2D, outputCubeMap: TextureCube): void;

// Warning: (ae-forgotten-export) The symbol "PBRMetallicRoughnessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class PBRMetallicRoughnessMaterial extends PBRMetallicRoughnessMaterial_base {
    constructor();
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// Warning: (ae-forgotten-export) The symbol "PBRSpecularGlossinessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class PBRSpecularGlossinessMaterial extends PBRSpecularGlossinessMaterial_base {
    constructor();
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public (undocumented)
export type PBRTextureNames = [
'occlusion',
'cheenColor',
'sheenRoughness',
'clearcoatIntensity',
'clearcoatNormal',
'clearcoatRoughness'
];

// @public (undocumented)
export type PBRToMixedTextureType<T> = T extends [infer First, ...infer Rest] ? [
First extends string ? ReturnType<typeof mixinTextureProps<First>> : never,
...PBRToMixedTextureType<Rest>
] : [];

// Warning: (ae-internal-missing-underscore) The name "PCFOPT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class PCFOPT extends ShadowImpl {
    constructor(kernelSize?: number);
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    postRenderShadowMap(): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    sampleShadowMap(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleShadowMapCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, split: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    protected _shadowSampler: TextureSampler;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "PCFPD" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class PCFPD extends ShadowImpl {
    constructor(tapCount?: number, sampleRadius?: number);
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    postRenderShadowMap(): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    protected _sampleRadius: number;
    // (undocumented)
    sampleShadowMap(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleShadowMapCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, split: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    protected _shadowSampler: TextureSampler;
    // (undocumented)
    get tapCount(): number;
    set tapCount(val: number);
    // (undocumented)
    protected _tapCount: number;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// @public
export class PerspectiveCamera extends Camera {
    constructor(scene: Scene, fovY: number, aspect: number, near: number, far: number);
    get aspect(): number;
    set aspect(val: number);
    // @internal (undocumented)
    protected _computeProj(): void;
    get far(): number;
    set far(val: number);
    get fovY(): number;
    set fovY(val: number);
    get near(): number;
    set near(val: number);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get window(): number[];
    set window(val: number[]);
}

// @public
export interface PlaneCreationOptions extends ShapeCreationOptions {
    size?: number;
    sizeX?: number;
    sizeY?: number;
}

// @public
export class PlaneShape extends Shape<PlaneCreationOptions> {
    constructor(options?: PlaneCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[], sizeX: number, sizeY: number): void;
    // @internal (undocumented)
    protected createDefaultOptions(): PlaneCreationOptions;
}

// @public
export class PointLight extends PunctualLight {
    constructor(scene: Scene);
    // @internal (undocumented)
    computeBoundingVolume(bv: BoundingVolume): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    // @override
    isPointLight(): this is PointLight;
    get range(): number;
    set range(val: number);
    // @internal (undocumented)
    protected _range: number;
    setRange(val: number): this;
}

// @public
export class PostWater extends AbstractPostEffect {
    constructor(elevation: number);
    // (undocumented)
    get alignment(): number;
    set alignment(val: number);
    get antiReflectanceLeak(): number;
    set antiReflectanceLeak(val: number);
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get boundary(): Vector4;
    set boundary(val: Vector4);
    get depthMulti(): number;
    set depthMulti(val: number);
    get displace(): number;
    set displace(val: number);
    get elevation(): number;
    set elevation(val: number);
    // (undocumented)
    get foamContrast(): number;
    set foamContrast(val: number);
    // (undocumented)
    get foamWidth(): number;
    set foamWidth(val: number);
    get gridScale(): number;
    set gridScale(val: number);
    get refractionStrength(): number;
    set refractionStrength(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    // (undocumented)
    get waveCroppiness0(): number;
    set waveCroppiness0(val: number);
    // (undocumented)
    get waveCroppiness1(): number;
    set waveCroppiness1(val: number);
    // (undocumented)
    get waveCroppiness2(): number;
    set waveCroppiness2(val: number);
    // (undocumented)
    get waveLength0(): number;
    set waveLength0(val: number);
    // (undocumented)
    get waveLength1(): number;
    set waveLength1(val: number);
    // (undocumented)
    get waveLength2(): number;
    set waveLength2(val: number);
    // (undocumented)
    get waveStrength0(): number;
    set waveStrength0(val: number);
    // (undocumented)
    get waveStrength1(): number;
    set waveStrength1(val: number);
    // (undocumented)
    get waveStrength2(): number;
    set waveStrength2(val: number);
    // (undocumented)
    get wind(): Vector2;
    set wind(val: Vector2);
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// Warning: (ae-forgotten-export) The symbol "DistributionType" needs to be exported by the entry point index.d.ts
//
// @public
export function prefilterCubemap(tex: TextureCube, type: DistributionType, destTex: TextureCube, numSamples?: number): void;

// @public
export class Primitive {
    constructor();
    // @internal
    addBoundingboxChangeCallback(cb: () => void): void;
    // @internal (undocumented)
    protected _bbox: BoundingVolume;
    // @internal (undocumented)
    protected _bboxChangeCallback: (() => void)[];
    createAndSetIndexBuffer(data: Uint16Array | Uint32Array, dynamic?: boolean): IndexBuffer;
    createAndSetVertexBuffer(format: VertexAttribFormat, data: TypedArray, stepMode?: VertexStepMode): StructuredBuffer;
    // @internal (undocumented)
    protected _defaultIndexCount: number;
    dispose(): void;
    draw(): void;
    drawInstanced(numInstances: number): void;
    getBoundingVolume(): BoundingVolume;
    getIndexBuffer(): IndexBuffer;
    getVertexBuffer(semantic: VertexSemantic): StructuredBuffer;
    getVertexBufferInfo(semantic: VertexSemantic): VertexBufferInfo;
    // @internal
    get id(): number;
    // @internal (undocumented)
    protected _id: number;
    get indexCount(): number;
    set indexCount(val: number);
    // @internal (undocumented)
    protected _indexCount: number;
    get indexStart(): number;
    set indexStart(val: number);
    // @internal (undocumented)
    protected _indexStart: number;
    get primitiveType(): PrimitiveType;
    set primitiveType(type: PrimitiveType);
    // @internal (undocumented)
    protected _primitiveType: PrimitiveType;
    raycast(ray: Ray): number;
    removeBoundingboxChangeCallback(cb: () => void): void;
    removeVertexBuffer(buffer: StructuredBuffer): void;
    setBoundingVolume(bv: BoundingVolume): void;
    setIndexBuffer(buffer: IndexBuffer): void;
    setVertexBuffer(buffer: StructuredBuffer, stepMode?: VertexStepMode): StructuredBuffer<unknown>;
    // @internal (undocumented)
    protected _vertexLayout: VertexLayout;
    // @internal (undocumented)
    protected _vertexLayoutDirty: boolean;
    // @internal (undocumented)
    protected _vertexLayoutOptions: VertexLayoutOptions;
}

// @public
export function projectCubemap(tex: TextureCube): Promise<Vector3[]>;

// @public
export function projectCubemapCPU(input: TextureCube): Promise<Vector3[]>;

// @public
export abstract class PunctualLight extends BaseLight {
    constructor(scene: Scene, type: number);
    get castShadow(): boolean;
    set castShadow(b: boolean);
    // @internal (undocumented)
    protected _castShadow: boolean;
    get color(): Vector4;
    set color(clr: Vector4);
    // @internal (undocumented)
    protected _color: Vector4;
    // @override
    isPunctualLight(): this is PunctualLight;
    // @internal (undocumented)
    protected _lightViewProjectionMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    setCastShadow(b: boolean): this;
    setColor(color: Vector4): this;
    setLightViewProjectionMatrix(mat: Matrix4x4): this;
    get shadow(): ShadowMapper;
    // @internal (undocumented)
    protected _shadowMapper: ShadowMapper;
    // @override
    get viewProjMatrix(): Matrix4x4;
    set viewProjMatrix(mat: Matrix4x4);
}

// Warning: (ae-internal-missing-underscore) The name "Quadtree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Quadtree {
    constructor(terrain: Terrain);
    // (undocumented)
    build(patchSize: number, rootSizeX: number, rootSizeZ: number, elevations: Float32Array, scaleX: number, scaleY: number, scaleZ: number, vertexCacheSize: number): boolean;
    // (undocumented)
    cull(visitor: CullVisitor, viewPoint: Vector3, worldMatrix: Matrix4x4): number;
    // (undocumented)
    cull_r(visitor: CullVisitor, node: QuadtreeNode, viewPoint: Vector3, worldMatrix: Matrix4x4, frustum: Frustum, cliptest: boolean, ignorePatch: boolean): number;
    // (undocumented)
    getBoundingBox(bbox: BoundingBox): void;
    // (undocumented)
    getElevations(): Float32Array;
    // (undocumented)
    getHeightField(): HeightField;
    // (undocumented)
    getIndices(): IndexBuffer;
    // (undocumented)
    getIndicesWireframe(): IndexBuffer;
    // (undocumented)
    getPatchSize(): number;
    // (undocumented)
    getPrimitiveCount(): number;
    // (undocumented)
    getPrimitiveType(): PrimitiveType;
    // (undocumented)
    getRootSize(): number;
    // (undocumented)
    getRootSizeX(): number;
    // (undocumented)
    getRootSizeZ(): number;
    // (undocumented)
    getScaleX(): number;
    // (undocumented)
    getScaleZ(): number;
    // (undocumented)
    getTerrain(): Terrain;
    // (undocumented)
    line(strip: Uint16Array): Uint16Array;
    // (undocumented)
    get normalMap(): Texture2D;
    // (undocumented)
    get rootNode(): QuadtreeNode;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
    // (undocumented)
    strip(vertexCacheSize: number): Uint16Array;
    // (undocumented)
    get terrain(): Terrain;
}

// Warning: (ae-internal-missing-underscore) The name "QuadtreeNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class QuadtreeNode {
    constructor();
    // (undocumented)
    addGrassCluster(grassCluster: GrassCluster): void;
    // (undocumented)
    getBoundingbox(): BoundingBox;
    // (undocumented)
    getChild(index: number): QuadtreeNode;
    // (undocumented)
    getParent(): QuadtreeNode;
    // (undocumented)
    getPatch(): TerrainPatch;
    // Warning: (ae-forgotten-export) The symbol "GrassCluster" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get grassClusters(): GrassCluster[];
    // (undocumented)
    initialize(quadtree: Quadtree, parent: QuadtreeNode, rowIndex: number, colIndex: number, baseVertices: Float32Array, normals: Vector3[], heightScale: number, elevations: Float32Array): boolean;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
}

// @public
export const QUEUE_OPAQUE = 1;

// @public
export const QUEUE_TRANSPARENT = 2;

// @public
export const RENDER_PASS_TYPE_DEPTH = 2;

// @public
export const RENDER_PASS_TYPE_LIGHT = 0;

// @public
export const RENDER_PASS_TYPE_SHADOWMAP = 1;

// @public
export abstract class RenderPass {
    constructor(type: number);
    // @internal (undocumented)
    applyRenderStates(device: AbstractDevice, stateSet: RenderStateSet, ctx: DrawContext): void;
    get clearColor(): Vector4;
    set clearColor(color: Vector4);
    // @internal (undocumented)
    protected _clearColor: Vector4;
    get clearDepth(): number;
    set clearDepth(depth: number);
    // @internal (undocumented)
    protected _clearDepth: number;
    get clearStencil(): number;
    set clearStencil(stencil: number);
    // @internal (undocumented)
    protected _clearStencil: number;
    cullScene(ctx: DrawContext, cullCamera: Camera): RenderQueue;
    dispose(): void;
    // @internal (undocumented)
    protected drawItem(device: AbstractDevice, item: RenderQueueItem, ctx: DrawContext, reverseWinding: boolean): void;
    // @internal (undocumented)
    protected drawScene(ctx: DrawContext, cullCamera: Camera, renderQueue?: RenderQueue): void;
    // @internal (undocumented)
    getGlobalBindGroupHash(ctx: DrawContext): string;
    // @internal (undocumented)
    protected abstract _getGlobalBindGroupHash(ctx: DrawContext): any;
    // @internal (undocumented)
    protected getGlobalBindGroupInfo(ctx: DrawContext): {
        bindGroup: BindGroup;
        layout: BindGroupLayout;
    };
    // @internal (undocumented)
    protected _globalBindGroups: Record<string, {
        bindGroup: BindGroup;
        layout: BindGroupLayout;
    }>;
    // @internal (undocumented)
    isAutoFlip(): boolean;
    render(ctx: DrawContext, cullCamera?: Camera, renderQueue?: RenderQueue): void;
    // @internal (undocumented)
    protected abstract renderItems(ctx: DrawContext, renderQueue: RenderQueue): any;
    get type(): number;
    // @internal (undocumented)
    protected _type: number;
}

// @public
export class RenderQueue {
    constructor(renderPass: RenderPass);
    clear(): void;
    // @internal
    getMaxBatchSize(): number;
    // Warning: (ae-forgotten-export) The symbol "RenderItemList" needs to be exported by the entry point index.d.ts
    get items(): Record<number, RenderItemList>;
    push(camera: Camera, drawable: Drawable, renderOrder: number): void;
    pushLight(light: PunctualLight): void;
    get renderPass(): RenderPass;
    // (undocumented)
    setInstanceColors(): GraphNode[];
    get shadowedLights(): PunctualLight[];
    sortItems(): void;
    get sunLight(): DirectionalLight;
    set sunLight(light: DirectionalLight);
    get unshadowedLights(): PunctualLight[];
}

// @public
export interface RenderQueueItem {
    // (undocumented)
    drawable: Drawable;
    // (undocumented)
    instanceColor?: Vector4;
    // (undocumented)
    instanceData: InstanceData;
    // (undocumented)
    sortDistance: number;
}

// @public
export abstract class RenderScheme {
    constructor();
    get currentScene(): Scene;
    // @internal (undocumented)
    protected _currentScene: Scene;
    dispose(): void;
    // @internal (undocumented)
    protected abstract _dispose(): void;
    // @internal (undocumented)
    protected _enableDepthPass: boolean;
    getShadowMapFormat(): TextureFormat;
    renderScene(scene: Scene, camera: Camera, compositor?: Compositor): void;
    // @internal (undocumented)
    protected abstract _renderScene(ctx: DrawContext): void;
    get requireDepthPass(): boolean;
    set requireDepthPass(val: boolean);
    // @internal (undocumented)
    abstract setClearParams(color: Vector4, depth: number, stencil: number): void;
    // @internal (undocumented)
    protected _shadowMapFormat: TextureFormat;
}

// @public
export class RotationTrack extends AnimationTrack {
    constructor(interpolator: Interpolator);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Quaternion;
    }[]);
    apply(node: SceneNode, currentTime: number, duration: number): boolean;
}

// @public
export class SAO extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get bias(): number;
    set bias(val: number);
    get blurDepthCutoff(): number;
    set blurDepthCutoff(val: number);
    get blurKernelSize(): number;
    set blurKernelSize(val: number);
    get blurStdDev(): number;
    set blurStdDev(val: number);
    dispose(): void;
    get intensity(): number;
    set intensity(val: number);
    get minResolution(): number;
    set minResolution(val: number);
    get radius(): number;
    set radius(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get scale(): number;
    set scale(val: number);
}

// @public
export class ScaleTrack extends AnimationTrack {
    constructor(interpolator: Interpolator);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[]);
    apply(node: SceneNode, currentTime: number, duration: number): boolean;
}

// Warning: (ae-forgotten-export) The symbol "Scene_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Scene extends Scene_base {
    constructor();
    // @internal (undocumented)
    get animationSet(): AnimationSet[];
    // @internal (undocumented)
    protected _animationSet: AnimationSet[];
    get boundingBox(): AABB;
    constructRay(camera: Camera, viewportWidth: number, viewportHeight: number, screenX: number, screenY: number, invModelMatrix?: Matrix4x4): Ray;
    dispose(): void;
    get env(): Environment;
    // @internal (undocumented)
    protected _env: Environment;
    // @internal (undocumented)
    frameUpdate(): void;
    get id(): number;
    // @internal (undocumented)
    protected _id: number;
    // @internal (undocumented)
    invalidateNodePlacement(node: SceneNode): void;
    // @internal (undocumented)
    protected _nodePlaceList: Set<SceneNode>;
    get octree(): Octree;
    // @internal (undocumented)
    protected _octree: Octree;
    raycast(camera: Camera, screenX: number, screenY: number): {
        node: GraphNode;
        dist: number;
        point: Vector3;
    };
    get rootNode(): SceneNode;
    // @internal (undocumented)
    protected _rootNode: SceneNode;
    // @internal (undocumented)
    protected _updateEvent: SceneUpdateEvent;
    // @internal (undocumented)
    protected _updateFrame: number;
    updateNodePlacement(octree: Octree, list: Set<SceneNode>): void;
    get worldUnit(): number;
    set worldUnit(val: number);
    // @internal (undocumented)
    protected _worldUnit: number;
    // @internal (undocumented)
    _xformChanged(node: SceneNode): void;
}

// @public
export class SceneNode extends XForm<SceneNode> {
    constructor(scene: Scene);
    get attached(): boolean;
    // @internal (undocumented)
    protected _attached(): void;
    // (undocumented)
    static readonly BBOXDRAW_DISABLED = 0;
    // (undocumented)
    static readonly BBOXDRAW_INHERITED = -1;
    // (undocumented)
    static readonly BBOXDRAW_LOCAL = 1;
    // (undocumented)
    static readonly BBOXDRAW_WORLD = 2;
    get boundingBoxDrawMode(): number;
    set boundingBoxDrawMode(mode: number);
    // @internal (undocumented)
    protected _boxDrawMode: number;
    // @internal (undocumented)
    protected _bv: BoundingVolume;
    // @internal (undocumented)
    protected _bvDirty: boolean;
    // @internal (undocumented)
    protected _bvWorld: BoundingVolume;
    // (undocumented)
    static readonly CLIP_DISABLED = 0;
    // (undocumented)
    static readonly CLIP_ENABLED = 1;
    // (undocumented)
    static readonly CLIP_INHERITED = -1;
    get clipMode(): number;
    set clipMode(val: number);
    // @internal (undocumented)
    protected _clipMode: number;
    computeBoundingVolume(bv: BoundingVolume): BoundingVolume;
    get computedBoundingBoxDrawMode(): number;
    get computedClipMode(): number;
    // @internal (undocumented)
    protected _detached(): void;
    dispose(): void;
    getBoundingVolume(): BoundingVolume;
    getWorldBoundingVolume(): BoundingVolume;
    hasChild(child: SceneNode): boolean;
    get hidden(): boolean;
    invalidateBoundingVolume(): void;
    invalidateWorldBoundingVolume(): void;
    isCamera(): this is Camera;
    isGraphNode(): this is GraphNode;
    isLight(): this is BaseLight;
    isMesh(): this is Mesh;
    isParentOf(child: SceneNode): boolean;
    isPunctualLight(): this is PunctualLight;
    isTerrain(): this is Terrain;
    iterate(callback: (node: SceneNode) => void): void;
    get name(): string;
    set name(val: string);
    // @internal (undocumented)
    protected _name: string;
    // @internal (undocumented)
    notifyHiddenChanged(): void;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    // (undocumented)
    static readonly PICK_DISABLED = 0;
    // (undocumented)
    static readonly PICK_ENABLED = 1;
    // (undocumented)
    static readonly PICK_INHERITED = -1;
    get pickable(): boolean;
    get pickMode(): number;
    set pickMode(val: number);
    // @internal (undocumented)
    protected _pickMode: number;
    remove(): this;
    removeChildren(): void;
    // @internal (undocumented)
    protected _renderOrder: number;
    get scene(): Scene;
    // @internal (undocumented)
    protected _scene: Scene;
    setBoundingVolume(bv: BoundingVolume): void;
    // @internal (undocumented)
    protected _setParent(p: SceneNode): void;
    // (undocumented)
    static readonly SHOW_DEFAULT = 1;
    // (undocumented)
    static readonly SHOW_HIDE = 0;
    // (undocumented)
    static readonly SHOW_INHERITED = -1;
    get showState(): number;
    set showState(val: number);
    traverse(v: SceneNodeVisitor, inverse?: boolean): void;
    // @internal (undocumented)
    protected _visible: number;
    // @internal (undocumented)
    protected _visibleChanged(): void;
    // @internal (undocumented)
    protected _willAttach(): void;
    // @internal (undocumented)
    protected _willDetach(): void;
}

// @public
export interface SceneNodeVisitor {
    // (undocumented)
    visit(target: SceneNode): unknown;
}

// Warning: (ae-internal-missing-underscore) The name "SceneRenderer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class SceneRenderer {
    // (undocumented)
    static freeClusteredLight(clusteredLight: ClusteredLight): void;
    // (undocumented)
    static getClusteredLight(): ClusteredLight;
    static renderScene(scene: Scene, camera: Camera, compositor?: Compositor, logger?: RenderLogger): void;
    // (undocumented)
    protected static _renderScene(ctx: DrawContext): void;
    // (undocumented)
    protected static _renderSceneDepth(ctx: DrawContext, renderQueue: RenderQueue, depthFramebuffer: FrameBuffer): void;
    // (undocumented)
    static setClearColor(color: Vector4): void;
}

// @public
export class SceneUpdateEvent {
    constructor(scene: Scene);
    // (undocumented)
    static readonly NAME: "sceneupdate";
    // (undocumented)
    scene: Scene;
    // (undocumented)
    type: "sceneupdate";
}

// @public
export class ShaderFramework {
    // (undocumented)
    static applyFog(scope: PBInsideFunctionScope, color: PBShaderExp, ctx: DrawContext): void;
    // (undocumented)
    static readonly BILLBOARD_SPHERICAL = 1;
    // (undocumented)
    static readonly BILLBOARD_SYLINDRAL = 2;
    // @internal (undocumented)
    static calculateShadowSpaceVertex(scope: PBInsideFunctionScope, cascade?: PBShaderExp | number): PBShaderExp;
    static computeFogFactor(scope: PBInsideFunctionScope, viewDir: PBShaderExp, fogType: PBShaderExp, fogParams: PBShaderExp): PBShaderExp;
    static computeFogFactorForType(scope: PBInsideFunctionScope, viewDir: PBShaderExp, fogParams: PBShaderExp, fogType: 'linear' | 'exp' | 'exp2'): PBShaderExp;
    static discardIfClipped(scope: PBInsideFunctionScope): void;
    // (undocumented)
    static readonly FOG_TYPE_EXP = 2;
    // (undocumented)
    static readonly FOG_TYPE_EXP2 = 3;
    // (undocumented)
    static readonly FOG_TYPE_LINEAR = 1;
    // (undocumented)
    static readonly FOG_TYPE_NONE = 0;
    // (undocumented)
    static readonly FOG_TYPE_SCATTER = 4;
    static ftransform(scope: PBInsideFunctionScope, billboardMode?: number): void;
    static getAerialPerspectiveLUT(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraClipPlane(scope: PBInsideFunctionScope): any;
    static getCameraClipPlaneFlag(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraPosition(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraRotationMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getCascadeDistances(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getClusteredLightIndexTexture(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getClusterParams(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getCountParams(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getDepthBiasScales(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getDepthBiasValues(scope: PBInsideFunctionScope): PBShaderExp;
    static getEnvLightStrength(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogColor(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogType(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getLightColorAndIntensity(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightDirectionAndCutoff(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightPositionAndRange(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightPositionAndRangeForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getLightTypeForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getLightViewMatrixForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getNumLights(scope: PBInsideFunctionScope): PBShaderExp;
    static getProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getShadowCameraParams(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getSkinMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldBinormal(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldNormal(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldPosition(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldTangent(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldUnit(scope: PBInsideFunctionScope): PBShaderExp;
    static prepareFragmentShader(pb: ProgramBuilder, ctx: DrawContext): void;
    static prepareVertexShader(pb: ProgramBuilder, ctx: DrawContext): void;
    // @internal (undocumented)
    static prepareVertexShaderCommon(pb: ProgramBuilder, ctx: DrawContext): void;
    // @internal (undocumented)
    static setCameraUniforms(bindGroup: BindGroup, ctx: DrawContext, linear: boolean): void;
    static setClipSpacePosition(scope: PBInsideFunctionScope, pos: PBShaderExp): void;
    // @internal (undocumented)
    static setFogUniforms(bindGroup: BindGroup, fogType: number, fogColor: Vector4, fogParams: Vector4, aerialPerspectiveLUT?: Texture2D): void;
    // @internal (undocumented)
    static setLightUniforms(bindGroup: BindGroup, ctx: DrawContext, clusterParams: Float32Array, countParams: Int32Array, lightBuffer: StructuredBuffer, lightIndexTexture: Texture2D): void;
    // @internal (undocumented)
    static setLightUniformsShadow(bindGroup: BindGroup, ctx: DrawContext, light: PunctualLight): void;
    // @internal (undocumented)
    static setLightUniformsShadowMap(bindGroup: BindGroup, ctx: DrawContext, light: PunctualLight): void;
    // (undocumented)
    static readonly USAGE_BONE_MATRICIES = "usage_BoneMatrices";
    // (undocumented)
    static readonly USAGE_BONE_TEXTURE_SIZE = "usage_BoneTextureSize";
    // (undocumented)
    static readonly USAGE_INV_BIND_MATRIX = "usage_InvBindMatrix";
    // (undocumented)
    static readonly USAGE_VERTEX_COLOR = "usage_VertexColor";
    // (undocumented)
    static readonly USAGE_WORLD_BINORMAL = "usage_WorldBinormal";
    // (undocumented)
    static readonly USAGE_WORLD_MATRIX = "usage_WorldMatrix";
    // (undocumented)
    static readonly USAGE_WORLD_NORMAL = "usage_WorldNormal";
    // (undocumented)
    static readonly USAGE_WORLD_POSITION = "usage_WorldPosition";
    // (undocumented)
    static readonly USAGE_WORLD_TANGENT = "usage_WorldTangent";
}

// Warning: (ae-internal-missing-underscore) The name "ShadowConfig" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ShadowConfig {
    // (undocumented)
    depthBias?: number;
    // (undocumented)
    nearClip?: number;
    // (undocumented)
    normalBias?: number;
    // (undocumented)
    numCascades?: number;
    // (undocumented)
    shadowMapSize: number;
    // (undocumented)
    splitLambda?: number;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowMapParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ShadowMapParams = {
    lightType: number;
    shaderHash: string;
    numShadowCascades: number;
    depthClampEnabled: boolean;
    cascadeDistances: Vector4;
    depthBiasValues: Vector4[];
    depthBiasScales: Vector4;
    cameraParams: Vector4;
    shadowMatrices: Float32Array;
    shadowMapFramebuffer: FrameBuffer;
    shadowMap: BaseTexture;
    shadowMapSampler: TextureSampler;
    impl: ShadowImpl;
    implData: unknown;
};

// @public
export class ShadowMapPass extends RenderPass {
    constructor();
    // @internal (undocumented)
    applyRenderStates(device: AbstractDevice, stateSet: RenderStateSet, ctx: DrawContext): void;
    // @internal (undocumented)
    protected _currentLight: PunctualLight;
    // @internal (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    get light(): PunctualLight;
    set light(light: PunctualLight);
    // @internal (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
    // @internal (undocumented)
    protected _stateOverriden: RenderStateSet;
}

// @public
export class ShadowMapper {
    constructor(light: PunctualLight);
    // @internal (undocumented)
    protected calcDepthBiasParams(shadowMapCamera: Camera, shadowMapSize: number, depthBias: number, normalBias: number, depthScale: number, result: Vector4): void;
    // @internal (undocumented)
    calcSplitDistances(nearPlane: number, farPlane: number, numCascades: number): number[];
    // @internal (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    static computeShadowBias(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, z: PBShaderExp, NdotL: PBShaderExp, linear: boolean): PBShaderExp;
    // @internal (undocumented)
    static computeShadowBiasCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    protected _config: ShadowConfig;
    // @internal (undocumented)
    protected createLightCameraDirectional(sceneAABB: AABB, sceneCamera: Camera, lightCamera: Camera, cropMatrix?: Matrix4x4, border?: number): void;
    // @internal (undocumented)
    protected createLightCameraPoint(lightCamera: Camera): void;
    // @internal (undocumented)
    protected createLightCameraSpot(lightCamera: Camera): void;
    // @internal (undocumented)
    protected createTexture(target: TextureType, format: TextureFormat, width: number, height: number, depth: number): Texture2D | TextureCube | Texture2DArray;
    get depthBias(): number;
    set depthBias(val: number);
    get esmBlur(): boolean;
    set esmBlur(val: boolean);
    // @internal (undocumented)
    protected _esmBlur: boolean;
    get esmBlurKernelSize(): number;
    set esmBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _esmBlurKernelSize: number;
    get esmBlurRadius(): number;
    set esmBlurRadius(val: number);
    // @internal (undocumented)
    protected _esmBlurRadius: number;
    get esmDepthScale(): number;
    set esmDepthScale(val: number);
    // @internal (undocumented)
    protected _esmDepthScale: number;
    // @internal (undocumented)
    getShaderHash(shadowMapParams: ShadowMapParams): string;
    // @internal (undocumented)
    protected _impl: ShadowImpl;
    // @internal (undocumented)
    protected isTextureInvalid(texture: Texture2D | TextureCube | Texture2DArray, target: TextureType, format: TextureFormat, width: number, height: number): boolean;
    get light(): PunctualLight;
    // @internal (undocumented)
    protected _light: PunctualLight;
    get mode(): ShadowMode;
    set mode(mode: ShadowMode);
    get nearClip(): number;
    set nearClip(val: number);
    get normalBias(): number;
    set normalBias(val: number);
    get numShadowCascades(): number;
    set numShadowCascades(num: number);
    get pcfKernelSize(): number;
    set pcfKernelSize(val: number);
    // @internal (undocumented)
    protected _pcfKernelSize: number;
    get pdSampleCount(): number;
    set pdSampleCount(val: number);
    // @internal (undocumented)
    protected _pdSampleCount: number;
    get pdSampleRadius(): number;
    set pdSampleRadius(val: number);
    // @internal (undocumented)
    protected _pdSampleRadius: number;
    // @internal (undocumented)
    protected postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // @internal (undocumented)
    static releaseTemporalResources(ctx: DrawContext): void;
    // @internal (undocumented)
    render(ctx: DrawContext, renderPass: ShadowMapPass): void;
    // @internal (undocumented)
    protected _resourceDirty: boolean;
    get shadowDistance(): number;
    set shadowDistance(val: number);
    // @internal (undocumented)
    protected _shadowDistance: number;
    get shadowMapSize(): number;
    set shadowMapSize(num: number);
    // @internal (undocumented)
    protected _shadowMode: ShadowMode;
    get splitLambda(): number;
    set splitLambda(val: number);
    // @internal (undocumented)
    protected updateResources(shadowMapParams: ShadowMapParams): void;
    get vsmBlurKernelSize(): number;
    set vsmBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _vsmBlurKernelSize: number;
    get vsmBlurRadius(): number;
    set vsmBlurRadius(val: number);
    // @internal (undocumented)
    protected _vsmBlurRadius: number;
    get vsmDarkness(): number;
    set vsmDarkness(val: number);
    // @internal (undocumented)
    protected _vsmDarkness: number;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowMapType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ShadowMapType = Texture2D | TextureCube | Texture2DArray;

// @public
export type ShadowMode = 'hard' | 'vsm' | 'esm' | 'pcf-pd' | 'pcf-opt';

// @public
export abstract class Shape<T extends ShapeCreationOptions = ShapeCreationOptions> extends Primitive {
    constructor(options?: T);
    // @internal (undocumented)
    create(options?: T): boolean;
    // @internal (undocumented)
    protected abstract _create(): boolean;
    // @internal (undocumented)
    protected createDefaultOptions(): T;
    // @internal (undocumented)
    protected _options: T;
}

// @public
export interface ShapeCreationOptions {
    needNormal?: boolean;
    needTangent?: boolean;
    needUV?: boolean;
}

// @public
export class Skeleton {
    constructor(joints: SceneNode[], inverseBindMatrices: Matrix4x4[], bindPoseMatrices: Matrix4x4[]);
    // @internal (undocumented)
    protected _bindPoseMatrices: Matrix4x4[];
    // @internal (undocumented)
    computeBindPose(): void;
    // @internal (undocumented)
    computeBoundingBox(info: SkinnedBoundingBox, invWorldMatrix: Matrix4x4): void;
    // @internal (undocumented)
    computeJoints(): void;
    dispose(): void;
    // @internal (undocumented)
    protected _inverseBindMatrices: Matrix4x4[];
    get jointMatrices(): Matrix4x4[];
    // @internal (undocumented)
    protected _jointMatrices: Matrix4x4[];
    // @internal (undocumented)
    protected _jointMatrixArray: Float32Array;
    // @internal (undocumented)
    protected _joints: SceneNode[];
    get jointTexture(): Texture2D;
    // @internal (undocumented)
    protected _jointTexture: Texture2D;
    // @internal (undocumented)
    updateJointMatrices(jointTransforms?: Matrix4x4[]): void;
}

// @public
export interface SkinnedBoundingBox {
    // (undocumented)
    boundingBox: BoundingBox;
    // (undocumented)
    boundingVertexBlendIndices: Float32Array;
    // (undocumented)
    boundingVertexJointWeights: Float32Array;
    // (undocumented)
    boundingVertices: Vector3[];
}

// @public
export class SkyRenderer {
    constructor();
    get autoUpdateIBLMaps(): boolean;
    set autoUpdateIBLMaps(val: boolean);
    get cloudIntensity(): number;
    set cloudIntensity(val: number);
    get cloudy(): number;
    set cloudy(val: number);
    // @internal (undocumented)
    drawScatteredFog(ctx: DrawContext): boolean;
    get fogColor(): Vector4;
    set fogColor(val: Vector4);
    get fogDensity(): number;
    set fogDensity(val: number);
    get fogEnd(): number;
    set fogEnd(val: number);
    // @internal (undocumented)
    get fogParams(): Vector4;
    set fogParams(val: Vector4);
    get fogStart(): number;
    set fogStart(val: number);
    get fogTop(): number;
    set fogTop(val: number);
    get fogType(): FogType;
    set fogType(val: FogType);
    // @internal (undocumented)
    getAerialPerspectiveLUT(ctx: DrawContext): _zephyr3d_device.Texture2D<unknown>;
    // @internal (undocumented)
    getHash(ctx: DrawContext): string;
    invalidateIBLMaps(): void;
    get irradianceMap(): TextureCube;
    // @internal (undocumented)
    get mappedFogType(): number;
    get radianceMap(): TextureCube;
    // @internal (undocumented)
    renderFog(ctx: DrawContext): void;
    // @internal (undocumented)
    renderSky(ctx: DrawContext): void;
    get skyboxTexture(): TextureCube;
    set skyboxTexture(tex: TextureCube);
    get skyColor(): Vector4;
    set skyColor(val: Vector4);
    get skyType(): SkyType;
    set skyType(val: SkyType);
    // @internal (undocumented)
    get skyWorldMatrix(): Matrix4x4;
    set skyWorldMatrix(val: Matrix4x4);
    updateIBLMaps(sunDir: Vector3): void;
    get wind(): Vector2;
    set wind(val: Vector2);
}

// @public
export type SkyType = 'color' | 'skybox' | 'scatter' | 'scatter-nocloud' | 'none';

// @public
export function smoothNoise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export interface SphereCreationOptions extends ShapeCreationOptions {
    horizonalDetail?: number;
    radius?: number;
    verticalDetail?: number;
}

// @public
export class SphereShape extends Shape<SphereCreationOptions> {
    constructor(options?: SphereCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected createDefaultOptions(): SphereCreationOptions;
    // @override
    raycast(ray: Ray): number;
}

// @public
export class SpotLight extends PunctualLight {
    constructor(scene: Scene);
    // @internal (undocumented)
    computeBoundingVolume(bv: BoundingVolume): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    get cutoff(): number;
    set cutoff(val: number);
    // @internal (undocumented)
    protected _cutoff: number;
    // @override
    isSpotLight(): this is SpotLight;
    get range(): number;
    set range(val: number);
    // @internal (undocumented)
    protected _range: number;
    setCutoff(val: number): this;
    setRange(val: number): this;
}

// Warning: (ae-internal-missing-underscore) The name "TemporalCache" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class TemporalCache {
    // (undocumented)
    static _cachedFrameBuffers: Record<string, Map<BaseTexture, Record<string, FrameBuffer[]>>>;
    // (undocumented)
    static getFramebuffer(width: number, height: number, numLayers: number, colorFmt: TextureFormat, depthFmt: TextureFormat, colorType: TextureType, depthType: TextureType, mipmapping: boolean, variant: boolean, sampleCount: number): FrameBuffer;
    // (undocumented)
    static getFramebufferFixedSize(width: number, height: number, numLayers: number, colorFmt: TextureFormat, depthFmt: TextureFormat, colorType: TextureType, depthType: TextureType, mipmapping: boolean, sampleCount?: number): FrameBuffer<unknown>;
    // (undocumented)
    static getFramebufferFixedSizeWithDepth(depthTex: BaseTexture, numLayers: number, colorFmt: TextureFormat, colorType: TextureType, mipmapping: boolean, sampleCount?: number): FrameBuffer<unknown>;
    // (undocumented)
    static getFramebufferVariantSize(width: number, height: number, numLayers: number, colorFmt: TextureFormat, depthFmt: TextureFormat, colorType: TextureType, depthType: TextureType, mipmapping: boolean, sampleCount?: number): FrameBuffer<unknown>;
    // (undocumented)
    static getFramebufferVariantSizeWithDepth(depthTex: BaseTexture, numLayers: number, colorFmt: TextureFormat, colorType: TextureType, mipmapping: boolean, sampleCount?: number): FrameBuffer<unknown>;
    // (undocumented)
    static getFramebufferWithDepth(depth: BaseTexture, numLayers: number, colorFmt: TextureFormat, colorType: TextureType, mipmapping: boolean, variant: boolean, sampleCount: number): FrameBuffer;
    // (undocumented)
    static _ownDepthTextures: Set<BaseTexture>;
    // (undocumented)
    static releaseFramebuffer(fb: FrameBuffer): void;
    // (undocumented)
    static _releaseFuncs: Map<FrameBuffer, (fb: FrameBuffer) => void>;
    // (undocumented)
    static _variantHeight: number;
    // (undocumented)
    static _variantWidth: number;
}

// @public
export class Terrain extends GraphNode {
    constructor(scene: Scene);
    get castShadow(): boolean;
    set castShadow(val: boolean);
    // @override
    computeBoundingVolume(bv: BoundingVolume): BoundingVolume;
    create(sizeX: number, sizeZ: number, elevations: Float32Array, scale: Vector3, patchSize: number, options?: TerrainMaterialOptions): boolean;
    createGrass(density: number[][], bladeWidth: number, bladeHeight: number, offset: number, grassTexture: Texture2D): void;
    // @internal (undocumented)
    cull(cullVisitor: CullVisitor): number;
    getElevation(x: number, z: number): number;
    getInstanceColor(): Vector4;
    getName(): string;
    getNormal(x: number, z: number, normal?: Vector3): Vector3;
    get grassMaterial(): GrassMaterial;
    get height(): number;
    get heightFieldScale(): Vector3;
    // @override
    isTerrain(): this is Terrain;
    get LODCamera(): Camera;
    set LODCamera(camera: Camera);
    get material(): TerrainMaterial;
    get maxPixelError(): number;
    set maxPixelError(val: number);
    get normalMap(): Texture2D;
    // @internal (undocumented)
    get overridenStateSet(): RenderStateSet;
    // @internal (undocumented)
    get patchSize(): number;
    // @internal (undocumented)
    get quadtree(): Quadtree;
    rayIntersect(ray: Ray): number | null;
    get scaledHeight(): number;
    get scaledWidth(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "traverseQuadtree" is marked as @public, but its signature references "QuadtreeNode" which is marked as @internal
    traverseQuadtree(callback: (node: QuadtreeNode) => void): void;
    get width(): number;
    get wireframe(): boolean;
    set wireframe(b: boolean);
}

// @public (undocumented)
export type TerrainDetailMapInfo = {
    albedoTextures: Texture2DArray | Texture2D[];
    uvScale: number[];
    metallic?: number[];
    roughness?: number[];
    normalScale?: number[];
    normalTextures?: Texture2DArray | Texture2D[];
    albedoTexCoordIndex?: number | number[];
    normalTexCoordIndex?: number | number[];
    grass?: {
        texture?: Texture2D;
        bladeWidth?: number;
        bladeHeigh?: number;
        density?: number;
        offset?: number;
    }[][];
};

// Warning: (ae-forgotten-export) The symbol "TerrainMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class TerrainMaterial extends TerrainMaterial_base {
    constructor(options?: TerrainMaterialOptions);
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    calculateAlbedoColor(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    calculateNormalAndTBN(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    generateMetallicRoughnessMap(): Texture2D;
    getAlbedoTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    getMetallicRoughnessTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    getNormalTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    // @override
    isBatchable(): boolean;
    // @override
    isTransparent(): boolean;
    // (undocumented)
    sampleNormalMapWithTBN(scope: PBInsideFunctionScope, tex: PBShaderExp, texCoord: PBShaderExp, normalScale: PBShaderExp, TBN: PBShaderExp): PBShaderExp;
    // @override
    supportLighting(): boolean;
    // (undocumented)
    get terrainInfo(): Vector4;
    set terrainInfo(val: Vector4);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public (undocumented)
export type TerrainMaterialOptions = {
    splatMap?: Texture2D;
    splatMapTexCoordIndex?: number;
    detailMaps?: TerrainDetailMapInfo;
};

// Warning: (ae-internal-missing-underscore) The name "TerrainPatch" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class TerrainPatch implements Drawable {
    constructor(terrain: Terrain);
    // (undocumented)
    computeBoundingBox(box: BoundingBox): void;
    // (undocumented)
    computeErrorMetric(other: TerrainPatch): number;
    // (undocumented)
    computeHeightBound(): [number, number];
    // (undocumented)
    computeLodDistance(viewportH: number, tanHalfFovy: number, maxPixelError: number): number;
    // (undocumented)
    computeMaxError(): number;
    // (undocumented)
    computeSkirtLength(): number;
    // (undocumented)
    draw(ctx: DrawContext): void;
    // (undocumented)
    getBoneMatrices(): Texture2D<unknown>;
    // (undocumented)
    getBoundingBox(): BoundingBox;
    // (undocumented)
    getGeometry(): Primitive;
    // (undocumented)
    getGeometryWireframe(): Primitive;
    // (undocumented)
    getHeight(x: number, z: number): number;
    // (undocumented)
    getInstanceColor(): Vector4;
    // (undocumented)
    getInvBindMatrix(): Matrix4x4;
    // (undocumented)
    getLODDistance(): number;
    // (undocumented)
    getMipLevel(): number;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getOffsetScale(): Vector4;
    // (undocumented)
    getOffsetX(): number;
    // (undocumented)
    getOffsetZ(): number;
    // (undocumented)
    getPickTarget(): GraphNode;
    // (undocumented)
    getQueueType(): number;
    // (undocumented)
    getSortDistance(camera: Camera): number;
    // (undocumented)
    getStep(): number;
    // (undocumented)
    getXForm(): XForm<XForm<any>>;
    // (undocumented)
    initialize(quadtree: Quadtree, parent: TerrainPatch, rowIndex: number, colIndex: number, baseVertices: Float32Array, normals: Vector3[], heightScale: number, elevations: Float32Array): boolean;
    // (undocumented)
    isBatchable(): this is BatchDrawable;
    // (undocumented)
    isDummy(): boolean;
    // (undocumented)
    isUnlit(): boolean;
    // (undocumented)
    setBoundingBox(bbox: BoundingBox): void;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
    // (undocumented)
    setupVertices(skirtLength: number, baseVertices: Float32Array, normalVectors: Vector3[], heightScale: number, elevations: Float32Array): void;
    // (undocumented)
    sqrDistancePointToTriangle(P: Vector3, t0: Vector3, t1: Vector3, t2: Vector3): number;
    // (undocumented)
    sqrDistanceToPoint(point: Vector3): number;
}

// @public
export type TextureFetchOptions<T extends BaseTexture> = {
    mimeType?: string;
    linearColorSpace?: boolean;
    texture?: T;
    samplerOptions?: SamplerOptions;
};

// @public (undocumented)
export type TextureMixinInstanceTypes<T> = TextureMixinTypes<T> extends {
    new (...args: any[]): infer U;
} ? U : never;

// @public (undocumented)
export type TextureMixinTypes<T> = ReturnType<typeof applyMaterialMixins<PBRToMixedTextureType<T>, typeof MeshMaterial>>;

// @public (undocumented)
export type TextureProp<U extends string> = {
    [P in 'Texture' | 'TextureSampler' | 'TexCoordIndex' | 'TexCoordMatrix' as `${U}${P}`]: P extends 'Texture' ? Texture2D : P extends 'TextureSampler' ? TextureSampler : P extends 'TexCoordIndex' ? number : P extends 'TexCoordMatrix' ? Matrix4x4 : never;
};

// @public (undocumented)
export type TexturePropUniforms<U extends string> = {
    [P in 'TextureUniform' | 'TexCoord' as `get${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope) => PBShaderExp;
} & {
    [P in 'Texture' as `sample${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope) => PBShaderExp;
};

// @public
export class Tonemap extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    dispose(): void;
    get exposure(): number;
    set exposure(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export interface TorusCreationOptions extends ShapeCreationOptions {
    innerRadius?: number;
    numSegments?: number;
    numSlices?: number;
    outerRadius?: number;
    radialDetail?: number;
}

// @public
export class TorusShape extends Shape<TorusCreationOptions> {
    constructor(options?: TorusCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[]): void;
    // @internal (undocumented)
    protected createDefaultOptions(): TorusCreationOptions;
}

// @public
export class TranslationTrack extends AnimationTrack {
    constructor(interpolator: Interpolator);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[]);
    apply(node: SceneNode, currentTime: number, duration: number): boolean;
}

// @public (undocumented)
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

// Warning: (ae-forgotten-export) The symbol "UnlitMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class UnlitMaterial extends UnlitMaterial_base {
    constructor();
    // (undocumented)
    static readonly FEATURE_VERTEX_COLOR = "um_vertexcolor";
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export class UserTrack extends AnimationTrack {
    constructor(mode: InterpolationMode, target: InterpolationTarget, keyFrames: {
        time: number;
        value: number | Float32Array;
    }[], handler: NumberTrackHandler);
    apply(node: SceneNode, currentTime: number, duration: number): boolean;
}

// @public
export interface Visitor {
    // (undocumented)
    visit(target: unknown): unknown;
}

// Warning: (ae-internal-missing-underscore) The name "VSM" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class VSM extends ShadowImpl {
    constructor(kernelSize?: number, blurSize?: number, darkness?: number);
    // Warning: (ae-forgotten-export) The symbol "VSMBlitter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _blitterH: VSMBlitter;
    // (undocumented)
    protected _blitterV: VSMBlitter;
    // (undocumented)
    get blur(): boolean;
    set blur(val: boolean);
    // (undocumented)
    protected _blur: boolean;
    // (undocumented)
    get blurSize(): number;
    set blurSize(val: number);
    // (undocumented)
    protected _blurSize: number;
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    protected _darkness: number;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    get mipmap(): boolean;
    set mipmap(b: boolean);
    // (undocumented)
    protected _mipmap: boolean;
    // (undocumented)
    postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "WaterMesh" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class WaterMesh {
    constructor(device: AbstractDevice, impl?: WaterShaderImpl);
    // (undocumented)
    get alignment(): number;
    set alignment(val: number);
    // (undocumented)
    get bindGroup(): BindGroup;
    // (undocumented)
    disposeInstanceData(): void;
    // (undocumented)
    get foamContrast(): number;
    set foamContrast(val: number);
    // (undocumented)
    get foamWidth(): number;
    set foamWidth(val: number);
    // (undocumented)
    getWaveCroppiness(cascade: number): number;
    // (undocumented)
    getWaveLength(cascade: number): number;
    // (undocumented)
    getWaveStrength(cascade: number): number;
    // (undocumented)
    get gridScale(): number;
    set gridScale(val: number);
    // (undocumented)
    get level(): number;
    set level(val: number);
    // (undocumented)
    get params(): OceanFieldBuildParams;
    // (undocumented)
    get regionMax(): Vector2;
    set regionMax(val: Vector2);
    // (undocumented)
    get regionMin(): Vector2;
    set regionMin(val: Vector2);
    // (undocumented)
    render(camera: Camera, flip?: boolean): void;
    // (undocumented)
    setWaveCroppiness(cascade: number, croppiness: number): void;
    // (undocumented)
    setWaveLength(cascade: number, size: number): void;
    // (undocumented)
    setWaveStrength(cascade: number, strength: number): void;
    // (undocumented)
    get tileSize(): number;
    set tileSize(val: number);
    // (undocumented)
    update(device: AbstractDevice, time: number): void;
    // (undocumented)
    get wind(): Vector2;
    set wind(val: Vector2);
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// Warning: (ae-internal-missing-underscore) The name "WaterShaderImpl" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface WaterShaderImpl {
    // (undocumented)
    setupUniforms(scope: PBGlobalScope): void;
    // (undocumented)
    shading(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal: PBShaderExp, foamFactor: PBShaderExp): PBShaderExp;
}

// @public
export function worleyFBM(scope: PBInsideFunctionScope, p: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// @public
export function worleyNoise(scope: PBInsideFunctionScope, uv: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// @public
export class XForm<T extends XForm<T> = XForm<any>> {
    constructor();
    get children(): T[];
    // @internal (undocumented)
    protected _children: T[];
    // @internal (undocumented)
    getTag(): number;
    getWorldPosition(): Vector3;
    get invWorldMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _invWorldMatrix: Matrix4x4;
    get localMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _localMatrix: Matrix4x4;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    moveBy(delta: Vector3): this;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    otherToThis(other: XForm, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    otherToThis(other: XForm, v: Vector4, result?: Vector4): Vector4;
    get parent(): T;
    set parent(p: T);
    // @internal (undocumented)
    protected _parent: T;
    get position(): Vector3;
    set position(val: Vector3);
    // @internal (undocumented)
    protected _position: ObservableVector3;
    reparent(p?: T): this;
    resetTransform(): this;
    get rotation(): Quaternion;
    set rotation(val: Quaternion);
    // @internal (undocumented)
    protected _rotation: ObservableQuaternion;
    get scale(): Vector3;
    set scale(val: Vector3);
    scaleBy(factor: Vector3): this;
    // @internal (undocumented)
    protected _scaling: ObservableVector3;
    setLocalTransform(m: Matrix4x4): this;
    // @internal (undocumented)
    protected _setParent(p: T): void;
    thisToOther(other: XForm, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToOther(other: XForm, v: Vector4, result?: Vector4): Vector4;
    thisToWorld(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToWorld(v: Vector4, result?: Vector4): Vector4;
    // @internal (undocumented)
    protected _tmpLocalMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _tmpWorldMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _transformTag: number;
    get worldMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _worldMatrix: Matrix4x4;
    get worldMatrixDet(): number;
    // @internal (undocumented)
    protected _worldMatrixDet: number;
    worldToThis(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    worldToThis(v: Vector4, result?: Vector4): Vector4;
}

// (No @packageDocumentation comment for this package)

```
