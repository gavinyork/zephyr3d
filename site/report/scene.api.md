## API Report File for "@zephyr3d/scene"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AABB } from '@zephyr3d/base';
import { AbstractDevice } from '@zephyr3d/device';
import { BaseTexture } from '@zephyr3d/device';
import { BindGroup } from '@zephyr3d/device';
import { BindGroupLayout } from '@zephyr3d/device';
import { ClipState } from '@zephyr3d/base';
import { ColorState } from '@zephyr3d/device';
import { CubeFace } from '@zephyr3d/base';
import { DecoderModule } from 'draco3d';
import { DeviceBackend } from '@zephyr3d/device';
import { FaceMode } from '@zephyr3d/device';
import { FrameBuffer } from '@zephyr3d/device';
import { Frustum } from '@zephyr3d/base';
import { GPUDataBuffer } from '@zephyr3d/device';
import { GPUProgram } from '@zephyr3d/device';
import { HttpRequest } from '@zephyr3d/base';
import { IndexBuffer } from '@zephyr3d/device';
import { InterpolationMode } from '@zephyr3d/base';
import { Interpolator } from '@zephyr3d/base';
import { Matrix4x4 } from '@zephyr3d/base';
import { ObservableQuaternion } from '@zephyr3d/base';
import { ObservableVector3 } from '@zephyr3d/base';
import { PBFunctionScope } from '@zephyr3d/device';
import { PBGlobalScope } from '@zephyr3d/device';
import { PBInsideFunctionScope } from '@zephyr3d/device';
import { PBShaderExp } from '@zephyr3d/device';
import { Plane } from '@zephyr3d/base';
import { PrimitiveType } from '@zephyr3d/device';
import { ProgramBuilder } from '@zephyr3d/device';
import { Quaternion } from '@zephyr3d/base';
import { Ray } from '@zephyr3d/base';
import { RenderStateSet } from '@zephyr3d/device';
import { SamplerOptions } from '@zephyr3d/device';
import { ShaderTypeFunc } from '@zephyr3d/device';
import { StructuredBuffer } from '@zephyr3d/device';
import { Texture2D } from '@zephyr3d/device';
import { Texture2DArray } from '@zephyr3d/device';
import { TextureCube } from '@zephyr3d/device';
import { TextureFormat } from '@zephyr3d/device';
import { TextureSampler } from '@zephyr3d/device';
import { TextureType } from '@zephyr3d/device';
import { TypedArray } from '@zephyr3d/base';
import { Vector2 } from '@zephyr3d/base';
import { Vector3 } from '@zephyr3d/base';
import { Vector4 } from '@zephyr3d/base';
import { VertexAttribFormat } from '@zephyr3d/device';
import { VertexBufferInfo } from '@zephyr3d/device';
import { VertexLayout } from '@zephyr3d/device';
import { VertexLayoutOptions } from '@zephyr3d/device';
import { VertexSemantic } from '@zephyr3d/device';
import { VertexStepMode } from '@zephyr3d/device';
import * as _zephyr3d_base from '@zephyr3d/base';
import * as _zephyr3d_device from '@zephyr3d/device';

// @public
export class AABBTree {
    constructor();
    constructor(rhs: AABBTree);
    buildFromPrimitives(vertices: number[] | TypedArray, indices: number[] | TypedArray, primitiveType: PrimitiveType): void;
    // @internal (undocumented)
    _buildSubNodes(): void;
    getTopLevelAABB(): AABB;
    rayIntersectionDistance(ray: Ray): number;
    rayIntersectionTest(ray: Ray): boolean;
    transform(matrix: Matrix4x4): void;
    // @internal (undocumented)
    verify(): void;
}

// @public
export abstract class AbstractPostEffect<ClassName extends string> {
    constructor();
    abstract apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // (undocumented)
    static readonly className: string;
    // @internal (undocumented)
    protected createRenderStates(device: AbstractDevice): RenderStateSet;
    // @internal (undocumented)
    protected createVertexLayout(device: AbstractDevice): VertexLayout;
    dispose(): void;
    protected drawFullscreenQuad(renderStateSet?: RenderStateSet): void;
    get enabled(): boolean;
    set enabled(val: boolean);
    // (undocumented)
    protected _enabled: boolean;
    getClassName(): ClassName;
    needFlip(device: AbstractDevice): boolean;
    get opaque(): boolean;
    // (undocumented)
    protected _opaque: boolean;
    // (undocumented)
    protected _outputTexture: Texture2D;
    // (undocumented)
    protected _quadRenderStateSet: RenderStateSet;
    // (undocumented)
    protected _quadVertexLayout: VertexLayout;
    abstract requireDepthAttachment(ctx: DrawContext): boolean;
    abstract requireLinearDepthTexture(ctx: DrawContext): boolean;
}

// @public
export class ABufferOIT extends OIT {
    constructor(numLayers?: number);
    applyUniforms(ctx: DrawContext, bindGroup: BindGroup): void;
    begin(ctx: DrawContext): number;
    beginPass(ctx: DrawContext, pass: number): boolean;
    calculateHash(): string;
    dispose(): void;
    end(ctx: DrawContext): void;
    endPass(ctx: DrawContext, pass: number): void;
    getType(): string;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): void;
    setupFragmentOutput(scope: PBGlobalScope): void;
    supportDevice(deviceType: string): boolean;
    static readonly type = "ab";
}

// @public
export class AnimationClip {
    constructor(name: string);
    addSkeleton(skeleton: Skeleton): void;
    addTrack(node: SceneNode, track: AnimationTrack): this;
    dispose(): void;
    // @internal (undocumented)
    protected _duration: number;
    get name(): string;
    // @internal (undocumented)
    protected _name: string;
    get skeletons(): Set<Skeleton>;
    // @internal (undocumented)
    protected _skeletons: Set<Skeleton>;
    get timeDuration(): number;
    get tracks(): Map<SceneNode, AnimationTrack<unknown>[]>;
    // @internal (undocumented)
    protected _tracks: Map<SceneNode, AnimationTrack[]>;
}

// @public
export class AnimationSet {
    constructor(scene: Scene, model: SceneNode);
    add(animation: AnimationClip): void;
    // (undocumented)
    dispose(): void;
    get(name: string): AnimationClip;
    getAnimationNames(): string[];
    getAnimationWeight(name: string): number;
    isPlayingAnimation(name?: string): boolean;
    get numAnimations(): number;
    playAnimation(name: string, options?: PlayAnimationOptions): void;
    setAnimationWeight(name: string, weight: number): void;
    stopAnimation(name: string, options?: StopAnimationOptions): void;
    update(): void;
}

// @public
export abstract class AnimationTrack<StateType = unknown> {
    constructor(interpolator: Interpolator);
    get animation(): AnimationClip;
    set animation(ani: AnimationClip);
    // @internal (undocumented)
    protected _animation: AnimationClip;
    abstract applyState(node: SceneNode, state: StateType): any;
    abstract calculateState(currentTime: number): StateType;
    abstract getBlendId(): unknown;
    get interpolator(): Interpolator;
    // @internal (undocumented)
    protected _interpolator: Interpolator;
    abstract mixState(a: StateType, b: StateType, t: number): StateType;
    reset(node: SceneNode): void;
}

// Warning: (ae-forgotten-export) The symbol "Application_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Application extends Application_base {
    constructor(opt: Partial<AppOptions>);
    get device(): AbstractDevice;
    get deviceType(): string;
    focus(): void;
    frame(): void;
    // Warning: (ae-forgotten-export) The symbol "InputManager" needs to be exported by the entry point index.d.ts
    get inputManager(): InputManager;
    static get instance(): Application;
    log(text: string, mode?: LogMode): void;
    get logger(): Logger;
    set logger(val: Logger);
    get options(): AppOptions;
    ready(): Promise<void>;
    run(): void;
    stop(): void;
    get timeElapsedInSeconds(): number;
}

// @public
export function applyMaterialMixins<M extends ((target: any) => any)[], T>(target: T, ...mixins: M): ExtractMixinType<M>;

// @public
export type AppOptions = {
    canvas: HTMLCanvasElement;
    backend: DeviceBackend;
    enableMSAA?: boolean;
    pixelRatio?: number;
};

// @public
export class AppResizeEvent {
    constructor(width: number, height: number);
    // (undocumented)
    height: number;
    // (undocumented)
    type: string;
    // (undocumented)
    width: number;
}

// @public
export class AppTickEvent {
    // (undocumented)
    type: string;
}

// @public
export interface AssetAnimationData {
    // (undocumented)
    name: string;
    // (undocumented)
    nodes: AssetHierarchyNode[];
    // (undocumented)
    skeletons: AssetSkeleton[];
    // (undocumented)
    tracks: AssetAnimationTrack[];
}

// @public
export interface AssetAnimationTrack {
    // (undocumented)
    defaultMorphWeights?: number[];
    // (undocumented)
    interpolator: Interpolator;
    // (undocumented)
    node: AssetHierarchyNode;
    // (undocumented)
    type: 'translation' | 'scale' | 'rotation' | 'weights';
}

// @public
export class AssetHierarchyNode extends NamedObject {
    constructor(name: string, parent?: AssetHierarchyNode);
    addChild(child: AssetHierarchyNode): void;
    attachToSkeleton(skeleton: AssetSkeleton, index: number): void;
    get children(): AssetHierarchyNode[];
    // @internal (undocumented)
    computeTransforms(parentTransform: Matrix4x4): void;
    get instances(): {
        t: Vector3;
        s: Vector3;
        r: Quaternion;
    }[];
    get matrix(): Matrix4x4;
    get mesh(): AssetMeshData;
    set mesh(data: AssetMeshData);
    get meshAttached(): boolean;
    get parent(): AssetHierarchyNode;
    get position(): Vector3;
    set position(val: Vector3);
    removeChild(child: AssetHierarchyNode): void;
    get rotation(): Quaternion;
    set rotation(val: Quaternion);
    get scaling(): Vector3;
    set scaling(val: Vector3);
    get skeleton(): AssetSkeleton;
    set skeleton(skeleton: AssetSkeleton);
    get skeletonAttached(): Set<AssetSkeleton>;
    get weights(): number[];
    set weights(val: number[]);
    get worldMatrix(): Matrix4x4;
}

// @public
export class AssetManager {
    constructor();
    // Warning: (ae-forgotten-export) The symbol "AbstractModelLoader" needs to be exported by the entry point index.d.ts
    addModelLoader(loader: AbstractModelLoader): void;
    // Warning: (ae-forgotten-export) The symbol "AbstractTextureLoader" needs to be exported by the entry point index.d.ts
    addTextureLoader(loader: AbstractTextureLoader): void;
    // @internal (undocumented)
    static _builtinTextureLoaders: {
        [name: string]: (assetManager: AssetManager, texture?: BaseTexture) => Promise<BaseTexture>;
    };
    // @internal (undocumented)
    static _builtinTextures: {
        [name: string]: Promise<BaseTexture>;
    };
    clearCache(): void;
    // @internal (undocumented)
    doLoadTexture(loader: AbstractTextureLoader, url: string, mimeType: string, data: ArrayBuffer, srgb: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture): Promise<BaseTexture>;
    fetchBinaryData(url: string, postProcess?: (data: ArrayBuffer) => ArrayBuffer): Promise<ArrayBuffer>;
    fetchBuiltinTexture<T extends BaseTexture>(name: string, texture?: BaseTexture): Promise<T>;
    fetchModel(scene: Scene, url: string, options?: ModelFetchOptions): Promise<ModelInfo>;
    // @internal (undocumented)
    fetchModelData(scene: Scene, url: string, options?: ModelFetchOptions): Promise<SharedModel>;
    fetchTextData(url: string, postProcess?: (text: string) => string): Promise<string>;
    fetchTexture<T extends BaseTexture>(url: string, options?: TextureFetchOptions<T>): Promise<T>;
    get httpRequest(): HttpRequest;
    // @internal (undocumented)
    loadBinaryData(url: string, postProcess?: (data: ArrayBuffer) => ArrayBuffer): Promise<ArrayBuffer>;
    // @internal (undocumented)
    loadModel(url: string, options?: ModelFetchOptions): Promise<SharedModel>;
    // @internal (undocumented)
    loadTextData(url: string, postProcess?: (text: string) => string): Promise<string>;
    // @internal (undocumented)
    loadTexture(url: string, mimeType?: string, srgb?: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture): Promise<BaseTexture>;
    purgeCache(): void;
    static setBuiltinTextureLoader(name: string, loader: (assetManager: AssetManager) => Promise<BaseTexture>): void;
}

// @public
export interface AssetMaterial {
    // (undocumented)
    common: AssetMaterialCommon;
    // (undocumented)
    type: string;
}

// @public
export interface AssetMaterialClearcoat {
    // (undocumented)
    clearCoatFactor?: number;
    // (undocumented)
    clearCoatIntensityMap?: MaterialTextureInfo;
    // (undocumented)
    clearCoatNormalMap?: MaterialTextureInfo;
    // (undocumented)
    clearCoatRoughnessFactor?: number;
    // (undocumented)
    clearCoatRoughnessMap?: MaterialTextureInfo;
}

// @public
export interface AssetMaterialCommon {
    // (undocumented)
    alphaCutoff?: number;
    // (undocumented)
    alphaMode?: 'blend' | 'mask';
    // (undocumented)
    bumpScale?: number;
    // (undocumented)
    doubleSided?: boolean;
    // (undocumented)
    emissiveColor?: Vector3;
    // (undocumented)
    emissiveMap?: MaterialTextureInfo;
    // (undocumented)
    emissiveStrength?: number;
    // (undocumented)
    normalMap?: MaterialTextureInfo;
    // (undocumented)
    occlusionMap?: MaterialTextureInfo;
    // (undocumented)
    occlusionStrength?: number;
    // (undocumented)
    useTangent?: boolean;
    // (undocumented)
    vertexColor?: boolean;
    // (undocumented)
    vertexNormal?: boolean;
}

// @public
export interface AssetMaterialIridescence {
    // (undocumented)
    iridescenceFactor?: number;
    // (undocumented)
    iridescenceIor?: number;
    // (undocumented)
    iridescenceMap?: MaterialTextureInfo;
    // (undocumented)
    iridescenceThicknessMap?: MaterialTextureInfo;
    // (undocumented)
    iridescenceThicknessMaximum?: number;
    // (undocumented)
    iridescenceThicknessMinimum?: number;
}

// @public
export interface AssetMaterialSheen {
    // (undocumented)
    sheenColorFactor?: Vector3;
    // (undocumented)
    sheenColorMap?: MaterialTextureInfo;
    // (undocumented)
    sheenRoughnessFactor?: number;
    // (undocumented)
    sheenRoughnessMap?: MaterialTextureInfo;
}

// @public
export interface AssetMaterialTransmission {
    // (undocumented)
    attenuationColor?: Vector3;
    // (undocumented)
    attenuationDistance?: number;
    // (undocumented)
    thicknessFactor?: number;
    // (undocumented)
    thicknessMap?: MaterialTextureInfo;
    // (undocumented)
    transmissionFactor?: number;
    // (undocumented)
    transmissionMap?: MaterialTextureInfo;
}

// @public
export interface AssetMeshData {
    // (undocumented)
    morphWeights?: number[];
    // (undocumented)
    subMeshes: AssetSubMeshData[];
}

// @public
export interface AssetPBRMaterialCommon extends AssetUnlitMaterial {
    // (undocumented)
    ior?: number;
}

// @public
export interface AssetPBRMaterialMR extends AssetPBRMaterialCommon {
    // (undocumented)
    clearcoat?: AssetMaterialClearcoat;
    // (undocumented)
    iridescence?: AssetMaterialIridescence;
    // (undocumented)
    metallic?: number;
    // (undocumented)
    metallicIndex?: number;
    // (undocumented)
    metallicMap?: MaterialTextureInfo;
    // (undocumented)
    roughness?: number;
    // (undocumented)
    roughnessIndex?: number;
    // (undocumented)
    sheen?: AssetMaterialSheen;
    // (undocumented)
    specularColorMap?: MaterialTextureInfo;
    // (undocumented)
    specularFactor?: Vector4;
    // (undocumented)
    specularMap?: MaterialTextureInfo;
    // (undocumented)
    transmission?: AssetMaterialTransmission;
}

// @public
export interface AssetPBRMaterialSG extends AssetPBRMaterialCommon {
    // (undocumented)
    glossness?: number;
    // (undocumented)
    specular?: Vector3;
    // (undocumented)
    specularGlossnessMap?: MaterialTextureInfo;
}

// @public
export interface AssetRotationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Quaternion[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export interface AssetScaleTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Vector3[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export class AssetScene extends NamedObject {
    constructor(name: string);
    rootNodes: AssetHierarchyNode[];
}

// @public
export interface AssetSkeletalAnimationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, {
        translation: Vector3;
        rotation: Quaternion;
        scale: Vector3;
    }[]>;
    // (undocumented)
    skeleton: AssetSkeleton;
}

// @public
export class AssetSkeleton extends NamedObject {
    constructor(name: string);
    addJoint(joint: AssetHierarchyNode, inverseBindMatrix: Matrix4x4): void;
    bindPoseMatrices: Matrix4x4[];
    inverseBindMatrices: Matrix4x4[];
    joints: AssetHierarchyNode[];
    pivot: AssetHierarchyNode;
}

// @public
export interface AssetSubMeshData {
    // (undocumented)
    material: MeshMaterial;
    // (undocumented)
    mesh?: Mesh;
    // (undocumented)
    morphAttribCount?: number;
    // (undocumented)
    name: string;
    // (undocumented)
    numTargets: number;
    // (undocumented)
    primitive: Primitive;
    // (undocumented)
    rawBlendIndices: TypedArray;
    // (undocumented)
    rawJointWeights: TypedArray;
    // (undocumented)
    rawPositions: Float32Array;
    // (undocumented)
    targetBox?: BoundingBox[];
    // (undocumented)
    targets?: Partial<Record<number, {
        numComponents: number;
        data: Float32Array[];
    }>>;
}

// @public
export interface AssetTranslationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Vector3[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export interface AssetUnlitMaterial extends AssetMaterial {
    // (undocumented)
    diffuse?: Vector4;
    // (undocumented)
    diffuseMap?: MaterialTextureInfo;
}

// @public
export class BaseCameraController {
    constructor();
    // @internal (undocumented)
    _getCamera(): Camera;
    // @internal (undocumented)
    onKeyDown(evt: KeyboardEvent): boolean;
    protected _onKeyDown(evt: KeyboardEvent): boolean;
    // @internal (undocumented)
    onKeyUp(evt: KeyboardEvent): boolean;
    protected _onKeyUp(evt: KeyboardEvent): boolean;
    // @internal (undocumented)
    onMouseDown(evt: PointerEvent): boolean;
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseMove(evt: PointerEvent): boolean;
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseUp(evt: PointerEvent): boolean;
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseWheel(evt: WheelEvent): boolean;
    protected _onMouseWheel(evt: WheelEvent): boolean;
    reset(): void;
    // @internal (undocumented)
    _setCamera(camera: Camera): void;
    update(): void;
}

// @public
export abstract class BaseLight extends GraphNode {
    constructor(scene: Scene, type: number);
    // @internal (undocumented)
    abstract computeUniforms(): void;
    get diffuseAndIntensity(): Vector4;
    // @internal (undocumented)
    protected _diffuseIntensity: Vector4;
    get directionAndCutoff(): Vector4;
    // @internal (undocumented)
    protected _directionCutoff: Vector4;
    get intensity(): number;
    set intensity(val: number);
    // @internal (undocumented)
    protected _intensity: number;
    // @internal (undocumented)
    invalidateUniforms(): void;
    isDirectionLight(): this is DirectionalLight;
    isLight(): this is BaseLight;
    isPointLight(): this is PointLight;
    isPunctualLight(): this is PunctualLight;
    isSpotLight(): this is SpotLight;
    get lightType(): number;
    get positionAndRange(): Vector4;
    // @internal (undocumented)
    protected _positionRange: Vector4;
    setIntensity(val: number): this;
    // @internal (undocumented)
    protected _type: number;
    get viewMatrix(): Matrix4x4;
    get viewProjMatrix(): Matrix4x4;
}

// @public
export interface BatchDrawable extends Drawable {
    // (undocumented)
    applyInstanceOffsetAndStride(renderQueue: RenderQueue, stride: number, offset: number): void;
    // Warning: (ae-incompatible-release-tags) The symbol "applyMaterialUniforms" is marked as @public, but its signature references "DrawableInstanceInfo" which is marked as @internal
    //
    // (undocumented)
    applyMaterialUniforms(instanceInfo: DrawableInstanceInfo): any;
    getInstanceId(renderPass: RenderPass): string;
    getInstanceUniforms(): Float32Array;
}

// @public
export class BatchGroup extends GraphNode {
    constructor(scene: Scene);
    // @internal (undocumented)
    protected _attached(): void;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    cull(cullVisitor: CullVisitor): void;
    // @internal (undocumented)
    protected _detached(): void;
    getName(): string;
    invalidate(): void;
    isBatchGroup(): this is BatchGroup;
    // @internal (undocumented)
    setBoundingVolume(bv: BoundingVolume): void;
}

// @public
export type BlendMode = 'none' | 'blend' | 'additive';

// Warning: (ae-forgotten-export) The symbol "BlinnMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BlinnMaterial extends BlinnMaterial_base {
    constructor();
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// @public
export abstract class Blitter {
    constructor();
    blit(source: Texture2D, dest: Texture2D | FrameBuffer, sampler?: TextureSampler): void;
    blit(source: Texture2D, dest: Texture2DArray, layer: number, sampler?: TextureSampler): void;
    blit(source: Texture2DArray, dest: Texture2DArray, sampler?: TextureSampler): void;
    blit(source: Texture2DArray, dest: Texture2D | FrameBuffer, layer: number, sampler?: TextureSampler): void;
    blit(source: TextureCube, dest: TextureCube, sampler?: TextureSampler): void;
    blit(source: TextureCube, dest: Texture2D | FrameBuffer, face: number, sampler?: TextureSampler): void;
    // (undocumented)
    blit(source: BaseTexture, dest: BaseTexture | FrameBuffer, layer?: number | TextureSampler, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blit2D(source: Texture2D, dest: FrameBuffer, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blit2DArray(source: Texture2DArray, dest: FrameBuffer, layer: number, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blitCubeMap(source: TextureCube, dest: FrameBuffer, face: CubeFace, sampler?: TextureSampler): void;
    protected abstract calcHash(): string;
    get destRect(): number[];
    set destRect(val: number[]);
    // @internal (undocumented)
    protected _destRect: number[];
    abstract filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampeType: 'float' | 'int' | 'uint' | 'depth'): PBShaderExp;
    // @internal (undocumented)
    protected _flip: boolean;
    get hash(): string;
    // @internal (undocumented)
    protected _hash: string;
    invalidateHash(): void;
    // @internal (undocumented)
    protected _offsetParams: Vector4;
    readTexel(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, uv: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint' | 'depth'): PBShaderExp;
    get renderStates(): RenderStateSet;
    set renderStates(rs: RenderStateSet);
    // @internal (undocumented)
    protected _renderStates: RenderStateSet;
    get scissor(): number[];
    set scissor(val: number[]);
    // @internal (undocumented)
    protected _scissor: number[];
    setUniforms(bindGroup: BindGroup, sourceTex: BaseTexture): void;
    setup(scope: PBGlobalScope, type: BlitType): void;
    get srgbOut(): boolean;
    set srgbOut(val: boolean);
    // @internal (undocumented)
    protected _srgbOut: boolean;
    get viewport(): number[];
    set viewport(val: number[]);
    // @internal (undocumented)
    protected _viewport: number[];
    writeTexel(scope: PBInsideFunctionScope, type: BlitType, uv: PBShaderExp, texel: PBShaderExp): PBShaderExp;
}

// @public
export type BlitType = '2d' | '2d-array' | 'cube';

// @public
export class Bloom extends AbstractPostEffect<'Bloom'> {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // (undocumented)
    static readonly className: "Bloom";
    dispose(): void;
    // @internal (undocumented)
    downsample(device: AbstractDevice, inputColorTexture: Texture2D, textures: Texture2D[]): void;
    get downsampleLimit(): number;
    set downsampleLimit(val: number);
    // @internal (undocumented)
    finalCompose(device: AbstractDevice, srcTexture: Texture2D, bloomTexture: Texture2D): void;
    get intensity(): number;
    set intensity(val: number);
    get maxDownsampleLevel(): number;
    set maxDownsampleLevel(val: number);
    // @internal (undocumented)
    prefilter(device: AbstractDevice, srcTexture: Texture2D, rt: Texture2D): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get threshold(): number;
    set threshold(val: number);
    get thresholdKnee(): number;
    set thresholdKnee(val: number);
    // @internal (undocumented)
    upsample(device: AbstractDevice, textures: Texture2D[]): void;
}

// @public
export class BoundingBox extends AABB implements BoundingVolume {
    constructor();
    constructor(box: AABB);
    constructor(minPoint: Vector3, maxPoint: Vector3);
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export interface BoundingVolume {
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export interface BoxCreationOptions extends ShapeCreationOptions {
    size?: number;
    sizeX?: number;
    sizeY?: number;
    sizeZ?: number;
}

// @public
export class BoxFilterBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernelSize: number, blurSize: number);
    // @internal (undocumented)
    protected _blurSize: number;
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    // @internal (undocumented)
    protected _kernelSize: number;
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // @internal (undocumented)
    protected _logSpace: boolean;
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @internal (undocumented)
    protected _logSpaceMultiplier: number;
    // @internal (undocumented)
    protected _phase: 'horizonal' | 'vertical';
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
    // @internal (undocumented)
    protected _sigma: number;
}

// @public
export class BoxFrameShape extends Shape<BoxCreationOptions> {
    constructor(options?: BoxCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], indices: number[], minx: number, miny: number, minz: number, maxx: number, maxy: number, maxz: number): void;
    // @internal (undocumented)
    protected createDefaultOptions(): BoxCreationOptions;
}

// @public
export class BoxShape extends Shape<BoxCreationOptions> {
    constructor(options?: BoxCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[], minx: number, miny: number, minz: number, maxx: number, maxy: number, maxz: number): void;
    // @internal (undocumented)
    protected createDefaultOptions(): BoxCreationOptions;
    get depth(): number;
    get height(): number;
    get width(): number;
}

// @public
export const BUILTIN_ASSET_TEST_CUBEMAP = "TEST_Cubemap";

// @public
export const BUILTIN_ASSET_TEXTURE_SHEEN_LUT = "LUT_Sheen";

// Warning: (ae-internal-missing-underscore) The name "CachedBindGroup" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type CachedBindGroup = {
    bindGroup: BindGroup;
    buffer: Float32Array;
    offset: number;
    dirty: boolean;
};

// @public
export class Camera extends SceneNode {
    constructor(scene: Scene, projectionMatrix?: Matrix4x4);
    get clearColor(): Vector4;
    set clearColor(val: Vector4);
    // @internal (undocumented)
    protected _clearColor: Vector4;
    get clipMask(): number;
    set clipMask(val: number);
    // @internal (undocumented)
    protected _clipMask: number;
    get clipPlane(): Plane;
    set clipPlane(plane: Plane);
    // @internal (undocumented)
    protected _clipPlane: Plane;
    get commandBufferReuse(): boolean;
    set commandBufferReuse(val: boolean);
    // @internal (undocumented)
    protected _commandBufferReuse: boolean;
    // @internal (undocumented)
    protected _compute(): void;
    // @internal (undocumented)
    protected _computeProj(): void;
    constructRay(x: number, y: number): Ray;
    get controller(): BaseCameraController;
    set controller(controller: BaseCameraController);
    // @internal (undocumented)
    protected _controller: BaseCameraController;
    get depthPrePass(): boolean;
    set depthPrePass(val: boolean);
    // @internal (undocumented)
    protected _depthPrePass: boolean;
    // @internal (undocumented)
    protected _dirty: boolean;
    dispose(): void;
    get enablePicking(): boolean;
    set enablePicking(enable: boolean);
    get framebuffer(): FrameBuffer;
    set framebuffer(fb: FrameBuffer);
    // @internal (undocumented)
    protected _framebuffer: FrameBuffer;
    get frustum(): Frustum;
    // @internal (undocumented)
    protected _frustum: Frustum;
    // @internal (undocumented)
    protected _frustumV: Frustum;
    // (undocumented)
    get frustumViewSpace(): Frustum;
    getAspect(): number;
    getFarPlane(): number;
    getFOV(): number;
    getNearPlane(): number;
    getProjectionMatrix(): Matrix4x4;
    // (undocumented)
    getRotationMatrix(): Matrix4x4;
    getTanHalfFovy(): number;
    handleEvent(ev: Event, type?: string): boolean;
    get HiZ(): boolean;
    set HiZ(val: boolean);
    // @internal (undocumented)
    protected _HiZ: boolean;
    // @internal (undocumented)
    protected _invalidate(projectMatrixChanged: boolean): void;
    get invViewProjectionMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _invViewProjMatrix: Matrix4x4;
    isCamera(): this is Camera;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    lookAtCubeFace(face: CubeFace, position?: Vector3): this;
    get oit(): OIT;
    set oit(val: OIT);
    // @internal (undocumented)
    protected _oit: OIT;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    // @internal (undocumented)
    protected _picking: boolean;
    get pickPosX(): number;
    set pickPosX(val: number);
    // @internal (undocumented)
    protected _pickPosX: number;
    get pickPosY(): number;
    set pickPosY(val: number);
    // @internal (undocumented)
    protected _pickPosY: number;
    get pickResult(): PickResult;
    set pickResult(val: PickResult);
    // @internal (undocumented)
    protected _pickResult: PickResult;
    // @internal (undocumented)
    get pickResultAsync(): Promise<PickResult>;
    set pickResultAsync(val: Promise<PickResult>);
    // @internal (undocumented)
    protected _pickResultPromise: Promise<PickResult>;
    // @internal (undocumented)
    protected _projMatrix: Matrix4x4;
    render(scene: Scene, compositor?: Compositor): void;
    resetController(): void;
    // @internal (undocumented)
    protected _rotationMatrix: Matrix4x4;
    get sampleCount(): number;
    set sampleCount(val: number);
    // @internal (undocumented)
    protected _sampleCount: number;
    get scissor(): number[];
    set scissor(rect: number[]);
    // @internal (undocumented)
    protected _scissor: number[];
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get SSR(): boolean;
    set SSR(val: boolean);
    // @internal (undocumented)
    protected _SSR: boolean;
    get ssrBlurDepthCutoff(): number;
    set ssrBlurDepthCutoff(val: number);
    // @internal (undocumented)
    protected _ssrBlurDepthCutoff: number;
    get ssrBlurKernelSize(): number;
    set ssrBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _ssrBlurKernelSize: number;
    // @internal (undocumented)
    protected _ssrBlurriness: number;
    get ssrBlurScale(): number;
    set ssrBlurScale(val: number);
    get ssrBlurStdDev(): number;
    set ssrBlurStdDev(val: number);
    // @internal (undocumented)
    protected _ssrBlurStdDev: number;
    get ssrCalcThickness(): boolean;
    set ssrCalcThickness(val: boolean);
    // @internal (undocumented)
    protected _ssrCalcThickness: boolean;
    get ssrIterations(): number;
    set ssrIterations(val: number);
    get ssrMaxDistance(): number;
    set ssrMaxDistance(val: number);
    get ssrMaxRoughness(): number;
    set ssrMaxRoughness(val: number);
    // @internal (undocumented)
    protected _ssrMaxRoughness: number;
    // @internal (undocumented)
    get ssrParams(): Vector4;
    // @internal (undocumented)
    protected _ssrParams: Vector4;
    get ssrRoughnessFactor(): number;
    set ssrRoughnessFactor(val: number);
    // @internal (undocumented)
    protected _ssrRoughnessFactor: number;
    get ssrStride(): number;
    set ssrStride(val: number);
    // @internal (undocumented)
    protected _ssrStride: number;
    get ssrThickness(): number;
    set ssrThickness(val: number);
    updateController(): void;
    get viewMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _viewMatrix: Matrix4x4;
    get viewport(): number[];
    set viewport(rect: number[]);
    // @internal (undocumented)
    protected _viewport: number[];
    // (undocumented)
    get viewProjectionMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _viewProjMatrix: Matrix4x4;
}

// Warning: (ae-internal-missing-underscore) The name "Clipmap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Clipmap {
    constructor(resolution: number);
    // (undocumented)
    _crossMesh: Primitive;
    // (undocumented)
    _crossMeshAABB: AABB;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(context: ClipmapDrawContext, numMipmaps: number): number;
    // (undocumented)
    _emptyTileMesh: Primitive;
    // (undocumented)
    _emptyTileMeshBBox: AABB;
    // (undocumented)
    _fillerMesh: Primitive;
    // (undocumented)
    _fillerMeshAABB: AABB;
    // (undocumented)
    generateCrossMesh(): void;
    // (undocumented)
    generateEmptyTileMesh(): void;
    // (undocumented)
    generateFillerMesh(): void;
    // (undocumented)
    generateSeamMesh(): void;
    // (undocumented)
    generateTileMesh(): void;
    // (undocumented)
    generateTrimMesh(): void;
    // (undocumented)
    _seamMesh: Primitive;
    // (undocumented)
    _seamMeshAABB: AABB;
    // (undocumented)
    _tileMesh: Primitive;
    // (undocumented)
    _tileMeshBBox: AABB;
    // (undocumented)
    get tileResolution(): number;
    set tileResolution(val: number);
    // (undocumented)
    _tileResolution: number;
    // (undocumented)
    _trimMesh: Primitive;
    // (undocumented)
    _trimMeshAABB: AABB;
}

// Warning: (ae-internal-missing-underscore) The name "ClipmapDrawContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ClipmapDrawContext = {
    camera: Camera;
    position: Vector3;
    gridScale: number;
    minMaxWorldPos: Vector4;
    userData: unknown;
    calcAABB(userData: unknown, minX: number, maxX: number, minZ: number, maxZ: number, outAABB: AABB): any;
    drawPrimitive(prim: Primitive, modelMatrix: Matrix4x4, offset: Vector2, scale: number, gridScale: number): any;
};

// @public
export class Compositor {
    constructor();
    appendPostEffect(postEffect: AbstractPostEffect<any>): void;
    // @internal (undocumented)
    begin(ctx: DrawContext): void;
    // @internal (undocumented)
    static _blit(device: AbstractDevice, srcTex: Texture2D, srgbOutput: boolean): void;
    clear(): void;
    // @internal (undocumented)
    drawPostEffects(ctx: DrawContext, opaque: boolean, sceneDepthTexture: Texture2D): void;
    // @internal (undocumented)
    end(ctx: DrawContext): void;
    getPostEffects(): AbstractPostEffect<any>[];
    // @internal (undocumented)
    needDrawPostEffects(): boolean;
    // @internal (undocumented)
    protected _postEffectsOpaque: AbstractPostEffect<any>[];
    // @internal (undocumented)
    protected _postEffectsTransparency: AbstractPostEffect<any>[];
    removePostEffect(postEffect: AbstractPostEffect<any>): void;
    // @internal (undocumented)
    requireLinearDepth(ctx: DrawContext): boolean;
}

// @public
export interface CompositorContext {
    // (undocumented)
    finalFramebuffer: FrameBuffer;
    // (undocumented)
    msTexture?: FrameBuffer;
    // (undocumented)
    pingpongFramebuffers: FrameBuffer[];
    // (undocumented)
    writeIndex: number;
}

// @public
export class CopyBlitter extends Blitter {
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
}

// Warning: (ae-internal-missing-underscore) The name "createProgramFFT2H" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramFFT2H(useComputeShader: boolean, threadGroupSize: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramFFT2V" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramFFT2V(useComputeShader: boolean, threadGroupSize: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramH0" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramH0(useComputeShader?: boolean, threadGroupSize?: number, targetFormat?: TextureFormat): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramHk" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramHk(useComputeShader?: boolean, threadGroupSize?: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramOcean" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramOcean(waveGenerator: WaveGenerator, shadingImpl: WaterShaderImpl): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramPostFFT2" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramPostFFT2(useComputeShader: boolean, threadGroupSize: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// @public
export class CullVisitor implements Visitor<SceneNode | OctreeNode> {
    constructor(renderPass: RenderPass, camera: Camera, renderQueue: RenderQueue, primaryCamera: Camera);
    get camera(): Camera;
    set camera(camera: Camera);
    get frustum(): _zephyr3d_base.Frustum;
    get frustumCulling(): boolean;
    set frustumCulling(val: boolean);
    // @internal (undocumented)
    protected getClipStateWithAABB(aabb: AABB): ClipState;
    // @internal (undocumented)
    protected getClipStateWithNode(node: GraphNode): ClipState;
    get primaryCamera(): Camera;
    // @internal (undocumented)
    push(camera: Camera, drawable: Drawable): void;
    // @internal (undocumented)
    pushRenderQueue(renderQueue: RenderQueue): void;
    get renderPass(): RenderPass;
    get renderQueue(): RenderQueue;
    set renderQueue(renderQueue: RenderQueue);
    visit(target: SceneNode | OctreeNode): unknown;
    // @internal (undocumented)
    visitBatchGroup(node: BatchGroup): boolean;
    // @internal (undocumented)
    visitMesh(node: Mesh): boolean;
    // @internal (undocumented)
    visitOctreeNode(node: OctreeNode): boolean;
    // @internal (undocumented)
    visitPunctualLight(node: PunctualLight): boolean;
    // @internal (undocumented)
    visitTerrain(node: Terrain): boolean;
}

// @public
export interface CylinderCreationOptions extends ShapeCreationOptions {
    bottomRadius?: number;
    height?: number;
    heightDetail?: number;
    radialDetail?: number;
    topRadius?: number;
}

// @public
export class CylinderShape extends Shape<CylinderCreationOptions> {
    constructor(options?: CylinderCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[]): void;
    // @internal (undocumented)
    protected createDefaultOptions(): CylinderCreationOptions;
}

// @public
export function decode2HalfFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeNormalizedFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeRGBM(scope: PBInsideFunctionScope, rgbm: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// @public
export class DepthPass extends RenderPass {
    constructor();
    // (undocumented)
    get encodeDepth(): boolean;
    set encodeDepth(val: boolean);
    // @internal (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    // (undocumented)
    get renderBackface(): boolean;
    set renderBackface(val: boolean);
    // @internal (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
}

// @public
export class DirectionalLight extends PunctualLight {
    constructor(scene: Scene);
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    // @override
    isDirectionLight(): this is DirectionalLight;
    get sunLight(): boolean;
    set sunLight(val: boolean);
}

// @public
export interface Drawable {
    applyTransformUniforms(renderQueue: RenderQueue): void;
    draw(ctx: DrawContext): any;
    getBoneMatrices(): Texture2D;
    getId(): number;
    getInstanceColor(): Vector4;
    getMaterial(): MeshMaterial;
    getMorphData(): Texture2D;
    getMorphInfo(): GPUDataBuffer;
    getName(): string;
    getObjectColor(): Vector4;
    getPickTarget(): GraphNode;
    getQueueType(): number;
    getSortDistance(camera: Camera): number;
    getXForm(): XForm;
    isBatchable(): this is BatchDrawable;
    isUnlit(): boolean;
    needSceneColor(): boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "pushRenderQueueRef" is marked as @public, but its signature references "RenderQueueRef" which is marked as @internal
    pushRenderQueueRef(ref: RenderQueueRef): any;
}

// Warning: (ae-internal-missing-underscore) The name "DrawableInstanceInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface DrawableInstanceInfo {
    // (undocumented)
    bindGroup: CachedBindGroup;
    // (undocumented)
    offset: number;
}

// @public
export interface DrawContext {
    applyFog: FogType;
    camera: Camera;
    // Warning: (ae-forgotten-export) The symbol "ClusteredLight" needs to be exported by the entry point index.d.ts
    clusteredLight?: ClusteredLight;
    compositor?: Compositor;
    compositorContex?: CompositorContext;
    // @internal (undocumented)
    currentShadowLight?: PunctualLight;
    defaultViewport?: boolean;
    depthFormat?: TextureFormat;
    depthTexture?: Texture2D;
    device: AbstractDevice;
    drawEnvLight: boolean;
    env: Environment;
    flip: boolean;
    forceColorState?: ColorState;
    forceCullMode?: FaceMode;
    // Warning: (ae-forgotten-export) The symbol "GlobalBindGroupAllocator" needs to be exported by the entry point index.d.ts
    globalBindGroupAllocator: GlobalBindGroupAllocator;
    HiZ: boolean;
    HiZTexture: Texture2D;
    instanceData?: InstanceData;
    lightBlending: boolean;
    linearDepthTexture?: Texture2D;
    materialFlags: number;
    oit: OIT;
    picking: boolean;
    primaryCamera: Camera;
    queue: number;
    renderPass: RenderPass;
    renderPassHash: string;
    renderQueue?: RenderQueue;
    scene: Scene;
    sceneColorTexture?: Texture2D;
    // @internal (undocumented)
    shadowMapInfo?: Map<PunctualLight, ShadowMapParams>;
    sunLight?: DirectionalLight;
    timestamp: number;
    viewportHeight?: number;
    viewportWidth?: number;
    viewportX?: number;
    viewportY?: number;
}

// @public
export function encode2HalfToRGBA(scope: PBInsideFunctionScope, a: PBShaderExp | number, b: PBShaderExp | number): PBShaderExp;

// @public
export function encodeFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeNormalizedFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeRGBM(scope: PBInsideFunctionScope, rgb: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// @public
export class EnvConstantAmbient extends EnvironmentLighting {
    constructor(ambientColor?: Vector4);
    get ambientColor(): Vector4;
    set ambientColor(ambientColor: Vector4);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @internal (undocumented)
    static readonly UNIFORM_NAME_CONSTANT_AMBIENT = "zConstantAmbient";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EnvHemisphericAmbient extends EnvironmentLighting {
    constructor(ambientUp: Vector4, ambientDown: Vector4);
    get ambientDown(): Vector4;
    set ambientDown(color: Vector4);
    get ambientUp(): Vector4;
    set ambientUp(color: Vector4);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @internal (undocumented)
    static readonly UNIFORM_NAME_AMBIENT_DOWN = "zHemisphericAmbientDown";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_AMBIENT_UP = "zHemisphericAmbientUp";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EnvIBL extends EnvironmentLighting {
    constructor(radianceMap?: TextureCube, irradianceMap?: TextureCube);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    get irradianceMap(): TextureCube;
    set irradianceMap(tex: TextureCube);
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_IRRADIANCE_MAP = "zIBLIrradianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP = "zIBLRadianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD = "zIBLRadianceMapMaxLOD";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class Environment {
    // @internal
    constructor();
    // @internal (undocumented)
    getHash(ctx: DrawContext): string;
    get light(): EnvLightWrapper;
    // @internal (undocumented)
    needSceneDepthTexture(): boolean;
    get sky(): SkyRenderer;
}

// @public
export abstract class EnvironmentLighting {
    abstract getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    abstract getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    abstract getType(): EnvLightType;
    abstract hasIrradiance(): boolean;
    abstract hasRadiance(): boolean;
    abstract initShaderBindings(pb: ProgramBuilder): void;
    abstract updateBindGroup(bg: BindGroup): void;
}

// @public
export type EnvLightType = 'ibl' | 'ibl-sh' | 'hemisphere' | 'constant' | 'none';

// @public
export class EnvLightWrapper {
    // @internal
    constructor();
    get ambientColor(): Vector4;
    set ambientColor(val: Vector4);
    get ambientDown(): Vector4;
    set ambientDown(val: Vector4);
    get ambientUp(): Vector4;
    set ambientUp(val: Vector4);
    // @internal (undocumented)
    get envLight(): EnvironmentLighting;
    // @internal (undocumented)
    getHash(ctx?: DrawContext): string;
    get irradianceMap(): TextureCube;
    set irradianceMap(tex: TextureCube);
    get irradianceSH(): Float32Array;
    set irradianceSH(value: Float32Array);
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    get strength(): number;
    set strength(val: number);
    get type(): EnvLightType;
    set type(val: EnvLightType);
}

// @public
export class EnvShIBL extends EnvironmentLighting {
    constructor(radianceMap?: TextureCube, irradianceSH?: (Vector4 | Vector3)[] | Float32Array);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    get irradianceSH(): Float32Array;
    set irradianceSH(value: Float32Array);
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_IRRADIANCE_SH = "zIBLIrradianceSH";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP = "zIBLRadianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD = "zIBLRadianceMapMaxLOD";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// Warning: (ae-forgotten-export) The symbol "ShadowImpl" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "ESM" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class ESM extends ShadowImpl {
    constructor(kernelSize?: number, blurSize?: number, depthScale?: number);
    // Warning: (ae-forgotten-export) The symbol "BlurBlitter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _blitterH: BlurBlitter;
    // (undocumented)
    protected _blitterV: BlurBlitter;
    // (undocumented)
    get blur(): boolean;
    set blur(val: boolean);
    // (undocumented)
    protected _blur: boolean;
    // (undocumented)
    get blurSize(): number;
    set blurSize(val: number);
    // (undocumented)
    protected _blurSize: number;
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    protected _depthScale: number;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // (undocumented)
    protected _logSpace: boolean;
    // (undocumented)
    get mipmap(): boolean;
    set mipmap(b: boolean);
    // (undocumented)
    protected _mipmap: boolean;
    // (undocumented)
    postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// @public
export class EulerRotationTrack extends AnimationTrack<Quaternion> {
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[]);
    // (undocumented)
    applyState(node: SceneNode, state: Quaternion): void;
    // (undocumented)
    calculateState(currentTime: number): Quaternion;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    mixState(a: Quaternion, b: Quaternion, t: number): Quaternion;
}

// @public
export type ExtractMixinReturnType<M> = M extends (target: infer A) => infer R ? R : never;

// @public
export type ExtractMixinType<M> = M extends [infer First] ? ExtractMixinReturnType<First> : M extends [infer First, ...infer Rest] ? ExtractMixinReturnType<First> & ExtractMixinType<[...Rest]> : never;

// @public (undocumented)
export function fetchNormalizedFloatForDevice(scope: PBInsideFunctionScope, tex: PBShaderExp, uv: PBShaderExp, level?: PBShaderExp | number): PBShaderExp;

// @public (undocumented)
export class FFTWaveGenerator extends WaveGenerator {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "OceanFieldBuildParams" which is marked as @internal
    constructor(params?: OceanFieldBuildParams);
    // (undocumented)
    get alignment(): number;
    set alignment(val: number);
    // (undocumented)
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    // (undocumented)
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    // (undocumented)
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    disposeInstanceData(): void;
    // (undocumented)
    disposeNTextures(texture: Texture2D[] | Texture2DArray): void;
    // (undocumented)
    get foamContrast(): number;
    set foamContrast(val: number);
    // (undocumented)
    get foamWidth(): number;
    set foamWidth(val: number);
    // (undocumented)
    getHash(): string;
    // (undocumented)
    getWaveCroppiness(cascade: number): number;
    // (undocumented)
    getWaveLength(cascade: number): number;
    // (undocumented)
    getWaveStrength(cascade: number): number;
    // (undocumented)
    isOk(): boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "params" is marked as @public, but its signature references "OceanFieldBuildParams" which is marked as @internal
    //
    // (undocumented)
    get params(): OceanFieldBuildParams;
    // Warning: (ae-incompatible-release-tags) The symbol "params" is marked as @public, but its signature references "OceanFieldBuildParams" which is marked as @internal
    set params(val: OceanFieldBuildParams);
    // (undocumented)
    setupUniforms(scope: PBGlobalScope): void;
    // (undocumented)
    setWaveCroppiness(cascade: number, croppiness: number): void;
    // (undocumented)
    setWaveLength(cascade: number, size: number): void;
    // (undocumented)
    setWaveStrength(cascade: number, strength: number): void;
    // (undocumented)
    update(time: number): void;
    // (undocumented)
    get wind(): Vector2;
    set wind(val: Vector2);
}

// @public
export type FogType = 'linear' | 'exp' | 'exp2' | 'scatter' | 'none';

// @public
export class FPSCameraController extends BaseCameraController {
    constructor(options?: FPSCameraControllerOptions);
    // @override
    protected _onKeyDown(evt: KeyboardEvent): boolean;
    // @override
    protected _onKeyUp(evt: KeyboardEvent): boolean;
    // @override
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @override
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @override
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: FPSCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface FPSCameraControllerOptions {
    controlKeys?: {
        up: string;
        down: string;
        forward: string;
        backward: string;
        left: string;
        right: string;
    };
    moveSpeed?: number;
    rotateSpeed?: number;
}

// @public
export class FXAA extends AbstractPostEffect<'FXAA'> {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // (undocumented)
    static readonly className: "FXAA";
    dispose(): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export function gammaToLinear(scope: PBInsideFunctionScope, color: PBShaderExp): PBShaderExp;

// @public
export class GaussianBlurBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernalSize: number, sigma: number, blurSize: number);
    get blurSize(): number;
    set blurSize(val: number);
    // @internal (undocumented)
    protected _blurSize: number;
    // @override
    protected calcHash(): string;
    get depthCutoff(): number;
    set depthCutoff(val: number);
    // @internal (undocumented)
    protected _depthCutoff: number;
    // @internal (undocumented)
    protected _depthTex: Texture2D;
    get depthTexture(): Texture2D;
    set depthTexture(tex: Texture2D);
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    get kernelSize(): number;
    set kernelSize(val: number);
    // @internal (undocumented)
    protected _kernelSize: number;
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // @internal (undocumented)
    protected _logSpace: boolean;
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @internal (undocumented)
    protected _logSpaceMultiplier: number;
    // @internal (undocumented)
    protected _phase: 'horizonal' | 'vertical';
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
    // @internal (undocumented)
    protected _sigma: number;
}

// @public (undocumented)
export class GerstnerWaveGenerator extends WaveGenerator {
    constructor();
    // (undocumented)
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    // (undocumented)
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    // (undocumented)
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    dispose(): void;
    // @internal (undocumented)
    gerstnerWave(scope: PBInsideFunctionScope, waveParam: PBShaderExp, omniParam: PBShaderExp, time: PBShaderExp, inPos: PBShaderExp, outNormal: PBShaderExp): PBShaderExp;
    // (undocumented)
    getHash(device: AbstractDevice): string;
    // (undocumented)
    getOriginX(waveIndex: number): number;
    // (undocumented)
    getOriginZ(waveIndex: number): number;
    // (undocumented)
    getWaveAmplitude(waveIndex: number): number;
    // (undocumented)
    getWaveDirection(waveIndex: number): number;
    // (undocumented)
    getWaveLength(waveIndex: number): number;
    // (undocumented)
    getWaveSteepness(waveIndex: number): number;
    // (undocumented)
    isOk(): boolean;
    // (undocumented)
    isOmniWave(waveIndex: number): boolean;
    // (undocumented)
    get numWaves(): number;
    set numWaves(val: number);
    // (undocumented)
    setOmniWave(waveIndex: number, isOmni: boolean): void;
    // (undocumented)
    setOrigin(waveIndex: number, x: number, z: number): void;
    // (undocumented)
    setupUniforms(scope: PBGlobalScope): void;
    // (undocumented)
    setWaveAmplitude(waveIndex: number, val: number): void;
    // (undocumented)
    setWaveDirection(waveIndex: number, angle: number): void;
    // (undocumented)
    setWaveLength(waveIndex: number, val: number): void;
    // (undocumented)
    setWaveSteepness(waveIndex: number, steepness: number): void;
    // (undocumented)
    update(timeInSeconds: number): void;
}

// Warning: (ae-internal-missing-underscore) The name "getDefaultBuildParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getDefaultBuildParams(): OceanFieldBuildParams;

// @public
export class GraphNode extends SceneNode {
    constructor(scene: Scene);
    getBoneMatrices(): Texture2D;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "getInvBindMatrix"
    //
    // (undocumented)
    getInvBindMatrix(): Matrix4x4;
    getName(): string;
    getSortDistance(camera: Camera): number;
    getXForm(): XForm;
    isBatchable(): this is BatchDrawable;
    // @override
    isGraphNode(): this is GraphNode;
    // @internal (undocumented)
    get octreeNode(): OctreeNode;
    set octreeNode(node: OctreeNode);
    // @internal (undocumented)
    protected _visibleChanged(): void;
}

// Warning: (ae-forgotten-export) The symbol "GrassMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class GrassMaterial extends GrassMaterial_base {
    constructor(terrainSize: Vector2, normalMap: Texture2D, grassTexture?: Texture2D);
    // (undocumented)
    apply(ctx: DrawContext): boolean;
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // @override
    isTransparentPass(pass: number): boolean;
    // @override
    supportInstancing(): boolean;
    // @override
    supportLighting(): boolean;
    // (undocumented)
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export class Grayscale extends AbstractPostEffect<'Grayscale'> {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // (undocumented)
    static readonly className: "Grayscale";
    dispose(): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "HeightField" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class HeightField {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    computeNormals(): Uint8Array;
    // (undocumented)
    computeNormalVectors(): Vector3[];
    // (undocumented)
    getBBoxTree(): HeightfieldBBoxTree;
    // (undocumented)
    getBoundingbox(): BoundingBox;
    // (undocumented)
    getHeight(x: number, z: number): number;
    // (undocumented)
    getHeights(): Float32Array;
    // (undocumented)
    getOffsetX(): number;
    // (undocumented)
    getOffsetZ(): number;
    // (undocumented)
    getRealHeight(x: number, z: number): number;
    // (undocumented)
    getRealNormal(x: number, z: number, normal?: Vector3): Vector3;
    // (undocumented)
    getSizeX(): number;
    // (undocumented)
    getSizeZ(): number;
    // (undocumented)
    getSpacingX(): number;
    // (undocumented)
    getSpacingZ(): number;
    // (undocumented)
    getVerticalScale(): number;
    // (undocumented)
    init(sizeX: number, sizeZ: number, offsetX: number, offsetZ: number, scaleX: number, scaleY: number, scaleZ: number, heights: Float32Array): boolean;
    // (undocumented)
    get normals(): Vector3[];
    // (undocumented)
    rayIntersect(ray: Ray): number | null;
}

// Warning: (ae-internal-missing-underscore) The name "HeightfieldBBoxTree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class HeightfieldBBoxTree {
    constructor(res_x: number, res_y: number, spacing_x: number, spacing_z: number, vertices: Vector4[]);
    // (undocumented)
    allocNode(): HeightfieldBBoxTreeNode;
    // (undocumented)
    computeNodeBoundingBox(node: HeightfieldBBoxTreeNode, bbox: BoundingBox, vertices: Vector4[]): void;
    // (undocumented)
    create(res_x: number, res_y: number, vertices: Vector4[]): boolean;
    // (undocumented)
    createChildNode(node: HeightfieldBBoxTreeNode, x: number, y: number, w: number, h: number, vertices: Vector4[]): boolean;
    // (undocumented)
    getHeight(x: number, y: number): number;
    // (undocumented)
    getHeights(): Float32Array;
    // (undocumented)
    getNormal(x: number, y: number, normal?: Vector3): Vector3;
    // (undocumented)
    getRealHeight(x: number, y: number): number;
    // (undocumented)
    getRealNormal(x: number, y: number, normal?: Vector3): Vector3;
    // (undocumented)
    getRootNode(): HeightfieldBBoxTreeNode;
    // (undocumented)
    rayIntersect(ray: Ray): number | null;
    // (undocumented)
    rayIntersectLeaf(ray: Ray, node: HeightfieldBBoxTreeNode): number | null;
    // (undocumented)
    rayIntersectRecursive(ray: Ray): number | null;
}

// Warning: (ae-internal-missing-underscore) The name "HeightfieldBBoxTreeNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface HeightfieldBBoxTreeNode {
    // (undocumented)
    bbox: BoundingBox;
    // (undocumented)
    left: HeightfieldBBoxTreeNode;
    // (undocumented)
    rc: {
        x: number;
        y: number;
        w: number;
        h: number;
    };
    // (undocumented)
    right: HeightfieldBBoxTreeNode;
}

// @public
export type IMixinAlbedoColor = {
    albedoColor: Vector4;
    calculateAlbedoColor(scope: PBInsideFunctionScope, uv?: PBShaderExp): PBShaderExp;
} & TextureMixinInstanceTypes<['albedo']>;

// @public
export type IMixinBlinnPhong = {
    shininess: number;
    blinnPhongLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
} & IMixinLight;

// @public
export interface IMixinFoliage {
    // (undocumented)
    calculateFoliageAlbedo(scope: PBInsideFunctionScope, albedoColor: PBShaderExp, texelCoord: PBShaderExp): PBShaderExp;
}

// @public
export type IMixinLambert = {
    lambertLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, albedo: PBShaderExp): PBShaderExp;
} & IMixinLight;

// @public
export type IMixinLight = {
    normalScale: number;
    normalMapMode: 'tangent-space' | 'object-space';
    doubleSidedLighting: boolean;
    needCalculateEnvLight(): boolean;
    getEnvLightIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    getEnvLightRadiance(scope: PBInsideFunctionScope, reflectVec: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    calculateViewVector(scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    calculateReflectionVector(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp): PBShaderExp;
    calculateTBN(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateNormal(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateNormalAndTBN(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateLightAttenuation(scope: PBInsideFunctionScope, type: PBShaderExp, worldPos: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateLightDirection(scope: PBInsideFunctionScope, type: PBShaderExp, worldPos: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateShadow(scope: PBInsideFunctionScope, worldPos: PBShaderExp, NoL: PBShaderExp): PBShaderExp;
    forEachLight(scope: PBInsideFunctionScope, callback: (this: PBInsideFunctionScope, type: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp, colorIntensity: PBShaderExp, shadow: boolean) => void): void;
} & TextureMixinInstanceTypes<['normal']> & IMixinAlbedoColor;

// @public
export type IMixinPBRCommon = {
    ior: number;
    emissiveColor: Vector3;
    emissiveStrength: number;
    occlusionStrength: number;
    transmission: boolean;
    transmissionFactor: number;
    thicknessFactor: number;
    attenuationColor: Vector3;
    attenuationDistance: number;
    sheen: boolean;
    sheenColorFactor: Vector3;
    sheenRoughnessFactor: number;
    clearcoat: boolean;
    clearcoatIntensity: number;
    clearcoatRoughnessFactor: number;
    clearcoatNormalScale: number;
    iridescence: boolean;
    iridescenceFactor: number;
    iridescenceIor: number;
    iridescenceThicknessMin: number;
    iridescenceThicknessMax: number;
    getCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
    fresnelSchlick(scope: PBInsideFunctionScope, cosTheta: PBShaderExp, F0: PBShaderExp): PBShaderExp;
    distributionGGX(scope: PBInsideFunctionScope, NdotH: PBShaderExp, alphaRoughness: PBShaderExp): PBShaderExp;
    visGGX(scope: PBInsideFunctionScope, NdotV: PBShaderExp, NdotL: PBShaderExp, alphaRoughness: PBShaderExp): PBShaderExp;
    getCommonDatasStruct(scope: PBInsideFunctionScope): ShaderTypeFunc;
    calculateEmissiveColor(scope: PBInsideFunctionScope): PBShaderExp;
    getF0(scope: PBInsideFunctionScope): PBShaderExp;
    directLighting(scope: PBInsideFunctionScope, lightDir: PBShaderExp, lightColor: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp): any;
    indirectLighting(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp, outRoughness?: PBShaderExp): any;
} & TextureMixinInstanceTypes<[
'occlusion',
'emissive',
'sheenColor',
'sheenRoughness',
'clearcoatIntensity',
'clearcoatRoughness',
'clearcoatNormal',
'transmission',
'thickness',
'iridescence',
'iridescenceThickness'
]>;

// @public
export type IMixinPBRMetallicRoughness = {
    metallic: number;
    roughness: number;
    specularFactor: Vector4;
    PBRLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, TBN: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['metallicRoughness', 'occlusion', 'specular', 'specularColor']>;

// @public
export type IMixinPBRSpecularGlossiness = {
    specularFactor: Vector4;
    glossinessFactor: number;
    PBRLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, TBN: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['specular']>;

// @public
export interface IMixinVertexColor {
    // (undocumented)
    getVertexColor(scope: PBInsideFunctionScope): any;
    // (undocumented)
    vertexColor: boolean;
}

// Warning: (ae-internal-missing-underscore) The name "InstanceBindGroupAllocator" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class InstanceBindGroupAllocator {
    constructor();
    // (undocumented)
    allocateInstanceBindGroup(framestamp: number, sizeInFloats: number): CachedBindGroup;
    // (undocumented)
    _bindGroupList: CachedBindGroup[];
}

// @public
export interface InstanceData {
    // Warning: (ae-incompatible-release-tags) The symbol "bindGroup" is marked as @public, but its signature references "CachedBindGroup" which is marked as @internal
    //
    // (undocumented)
    bindGroup: CachedBindGroup;
    // (undocumented)
    numInstances: number;
    // (undocumented)
    offset: number;
    // (undocumented)
    stride: number;
}

// Warning: (ae-internal-missing-underscore) The name "InstanceUniformType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type InstanceUniformType = 'float' | 'vec2' | 'vec3' | 'vec4';

// @public
export function interleavedGradientNoise(scope: PBInsideFunctionScope, c: PBShaderExp): PBShaderExp;

// Warning: (ae-forgotten-export) The symbol "LambertMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class LambertMaterial extends LambertMaterial_base {
    constructor();
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// @public
export const LIGHT_TYPE_DIRECTIONAL = 1;

// @public
export const LIGHT_TYPE_NONE = 0;

// @public
export const LIGHT_TYPE_POINT = 2;

// @public
export const LIGHT_TYPE_SPOT = 3;

// Warning: (ae-internal-missing-underscore) The name "LightPass" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class LightPass extends RenderPass {
    constructor();
    // (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    // (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
    // (undocumented)
    protected renderLightPass(ctx: DrawContext, itemList: RenderItemListBundle, lights: PunctualLight[], flags: any): void;
    // (undocumented)
    protected _shadowMapHash: string;
    // (undocumented)
    get transmission(): boolean;
    set transmission(val: boolean);
    // (undocumented)
    protected _transmission: boolean;
}

// @public
export function linearToGamma(scope: PBInsideFunctionScope, color: PBShaderExp): any;

// @public
export interface Logger {
    // (undocumented)
    log(text: string, mode?: LogMode): void;
}

// @public
export type LogMode = 'info' | 'warn' | 'error' | 'debug';

// @public
export class Material {
    // @internal
    get $instanceUniforms(): Float32Array;
    // @internal
    get $isInstance(): boolean;
    constructor();
    apply(ctx: DrawContext): boolean;
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean, pass: number): void;
    protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // @internal (undocumented)
    bind(device: AbstractDevice, pass: number): boolean;
    // @internal (undocumented)
    get coreMaterial(): this;
    // @internal (undocumented)
    createHash(pass: number): string;
    protected _createHash(): string;
    // @internal (undocumented)
    protected createProgram(ctx: DrawContext, pass: number): GPUProgram;
    protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, pass: number): GPUProgram;
    // @internal
    draw(primitive: Primitive, ctx: DrawContext, numInstances?: number): void;
    drawPrimitive(pass: number, primitive: Primitive, ctx: DrawContext, numInstances: number): void;
    // @internal (undocumented)
    protected getHash(pass: number): string;
    // (undocumented)
    getQueueType(): number;
    // @internal (undocumented)
    protected _hash: string[];
    get instanceId(): number;
    isBatchable(): boolean;
    isTransparentPass(pass: number): boolean;
    needSceneColor(): boolean;
    // (undocumented)
    get numPasses(): number;
    set numPasses(val: number);
    // @internal (undocumented)
    protected _numPasses: number;
    // @internal (undocumented)
    optionChanged(changeHash: boolean): void;
    passToHash(pass: number): string;
    supportInstancing(): boolean;
    supportLighting(): boolean;
    protected updateRenderStates(pass: number, renderStates: RenderStateSet, ctx: DrawContext): void;
}

// @public
export interface MaterialTextureInfo {
    // (undocumented)
    sampler: TextureSampler;
    // (undocumented)
    texCoord: number;
    // (undocumented)
    texture: Texture2D;
    // (undocumented)
    transform: Matrix4x4;
}

// @public
export const enum MaterialVaryingFlags {
    // (undocumented)
    INSTANCING = 4,
    // (undocumented)
    MORPH_ANIMATION = 1,
    // (undocumented)
    SKIN_ANIMATION = 2,
    // (undocumented)
    SSR_STORE_ROUGHNESS = 8
}

// @public
export const MAX_CLUSTERED_LIGHTS = 255;

// Warning: (ae-internal-missing-underscore) The name "MAX_MORPH_ATTRIBUTES" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MAX_MORPH_ATTRIBUTES = 8;

// Warning: (ae-internal-missing-underscore) The name "MAX_MORPH_TARGETS" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MAX_MORPH_TARGETS = 256;

// Warning: (ae-forgotten-export) The symbol "Mesh_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Mesh extends Mesh_base implements BatchDrawable {
    constructor(scene: Scene, primitive?: Primitive, material?: MeshMaterial);
    // @internal (undocumented)
    protected _animatedBoundingBox: BoundingBox;
    // @internal (undocumented)
    protected _batchable: boolean;
    // @internal (undocumented)
    protected _bboxChangeCallback: () => void;
    // @internal (undocumented)
    protected _boneMatrices: Texture2D;
    // @internal (undocumented)
    protected _boundingBoxNode: Mesh;
    get castShadow(): boolean;
    set castShadow(b: boolean);
    // @internal (undocumented)
    protected _castShadow: boolean;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    dispose(): void;
    draw(ctx: DrawContext): void;
    get drawBoundingBox(): boolean;
    set drawBoundingBox(val: boolean);
    getBoneMatrices(): Texture2D;
    getInstanceColor(): Vector4;
    getInstanceId(renderPass: RenderPass): string;
    getInstanceUniforms(): Float32Array;
    getMaterial(): MeshMaterial;
    getMorphData(): Texture2D;
    getMorphInfo(): GPUDataBuffer<unknown>;
    getName(): string;
    getPickTarget(): GraphNode;
    getQueueType(): number;
    getXForm(): XForm;
    // @internal (undocumented)
    protected _instanceColor: Vector4;
    // @internal (undocumented)
    protected _instanceHash: string;
    isBatchable(): this is BatchDrawable;
    isMesh(): this is Mesh;
    isUnlit(): boolean;
    get material(): MeshMaterial;
    set material(m: MeshMaterial);
    // @internal (undocumented)
    protected _morphData: Texture2D;
    // @internal (undocumented)
    protected _morphInfo: GPUDataBuffer;
    needSceneColor(): boolean;
    get primitive(): Primitive;
    set primitive(prim: Primitive);
    setAnimatedBoundingBox(bbox: BoundingBox): void;
    setBoneMatrices(matrices: Texture2D): void;
    setMorphData(data: Texture2D): void;
    setMorphInfo(info: GPUDataBuffer): void;
}

// @public
export class MeshMaterial extends Material {
    constructor(...args: any[]);
    get alphaCutoff(): number;
    set alphaCutoff(val: number);
    // (undocumented)
    get alphaToCoverage(): boolean;
    set alphaToCoverage(val: boolean);
    // @internal @override
    protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    get blendMode(): BlendMode;
    set blendMode(val: BlendMode);
    // @internal @override
    protected _createHash(): string;
    createInstance(): this;
    // @internal (undocumented)
    protected createProgram(ctx: DrawContext, pass: number): GPUProgram;
    // @internal @override
    protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, pass: number): GPUProgram;
    get cullMode(): FaceMode;
    set cullMode(val: FaceMode);
    static defineFeature(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "defineInstanceUniform" is marked as @public, but its signature references "InstanceUniformType" which is marked as @internal
    static defineInstanceUniform(prop: string, type: InstanceUniformType): number;
    // (undocumented)
    doAlphaTest(scope: PBInsideFunctionScope, color: PBShaderExp): void;
    get drawContext(): DrawContext;
    featureUsed<T = unknown>(feature: number): T;
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    getInstancedUniform(scope: PBInsideFunctionScope, uniformIndex: number): PBShaderExp;
    getQueueType(): number;
    // @internal (undocumented)
    static INSTANCE_UNIFORMS: [string, InstanceUniformType][];
    isTransparentPass(pass: number): boolean;
    needFragmentColor(ctx?: DrawContext): boolean;
    // @internal (undocumented)
    static NEXT_FEATURE_INDEX: number;
    // @internal (undocumented)
    static OBJECT_COLOR_UNIFORM: number;
    get objectColor(): Vector4;
    set objectColor(val: Vector4);
    get opacity(): number;
    set opacity(val: number);
    outputFragmentColor(scope: PBInsideFunctionScope, worldPos: PBShaderExp, color: PBShaderExp, ssrRoughness?: PBShaderExp, ssrNormal?: PBShaderExp): void;
    get pass(): number;
    supportLighting(): boolean;
    uniformChanged(): void;
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    useFeature(feature: number, use: unknown): void;
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export function mixinAlbedoColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinAlbedoColor);

// @public
export function mixinBlinnPhong<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinBlinnPhong);

// @public
export function mixinFoliage<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinFoliage);

// @public
export function mixinLambert<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinLambert);

// @public
export function mixinLight<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinLight);

// @public
export function mixinPBRCommon<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRCommon);

// @public
export function mixinPBRMetallicRoughness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRMetallicRoughness);

// @public
export function mixinPBRSpecularGlossness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRSpecularGlossiness);

// @public
export function mixinTextureProps<U extends string>(name: U): <T extends typeof MeshMaterial>(BaseCls: T, vertex?: boolean) => T & (new (...args: any[]) => TextureProp<U> & TexturePropUniforms<U>);

// @public
export function mixinVertexColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinVertexColor);

// @public
export type ModelFetchOptions = {
    mimeType?: string;
    dracoDecoderModule?: DecoderModule;
    enableInstancing?: boolean;
    postProcess?: (model: SharedModel) => SharedModel;
};

// @public
export type ModelInfo = {
    group: SceneNode;
    animationSet: AnimationSet;
};

// Warning: (ae-internal-missing-underscore) The name "MORPH_ATTRIBUTE_VECTOR_COUNT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_ATTRIBUTE_VECTOR_COUNT: number;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_COLOR" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_COLOR = 3;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_NORMAL" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_NORMAL = 1;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_POSITION" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_POSITION = 0;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TANGENT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TANGENT = 2;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX0" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX0 = 4;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX1" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX1 = 5;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX2" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX2 = 6;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX3" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX3 = 7;

// Warning: (ae-internal-missing-underscore) The name "MORPH_WEIGHTS_VECTOR_COUNT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_WEIGHTS_VECTOR_COUNT: number;

// @public
export class NamedObject {
    constructor(name: string);
    // (undocumented)
    name: string;
}

// @public
export function noise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export function noisef(scope: PBInsideFunctionScope, p: PBShaderExp): any;

// Warning: (ae-internal-missing-underscore) The name "OceanFieldBuildParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface OceanFieldBuildParams {
    alignment: number;
    cascades: [OceanFieldCascade, OceanFieldCascade, OceanFieldCascade];
    foamParams: Vector2;
    randomSeed: number;
    resolution: number;
    wind: Vector2;
}

// Warning: (ae-internal-missing-underscore) The name "OceanFieldCascade" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface OceanFieldCascade {
    croppiness: number;
    maxWave: number;
    minWave: number;
    size: number;
    strength: number;
}

// @public
export class Octree {
    constructor(scene: Scene, rootSize?: number, leafSize?: number);
    finalize(): void;
    getChunk(level: number): OctreeNodeChunk;
    getLeafSize(): number;
    getNumChunks(): number;
    getRootNode(): OctreeNode;
    getRootSize(): number;
    getScene(): Scene;
    initialize(rootSize: number, leafSize: number): void;
    locateNodeChain(candidate: OctreeNode, center: Vector3, radius: number): OctreeNode;
    placeNode(node: GraphNode): void;
    removeNode(node: GraphNode): void;
    // (undocumented)
    resize(size: number): void;
}

// @public
export class OctreeNode {
    constructor();
    addNode(node: GraphNode): void;
    clearNodes(): void;
    createChildren(): void;
    getBox(): AABB;
    getBoxLoosed(): AABB;
    getChild(placement: OctreePlacement): OctreeNode;
    getChunk(): OctreeNodeChunk;
    getLevel(): number;
    getMaxPoint(): Vector3;
    getMaxPointLoosed(): Vector3;
    getMinPoint(): Vector3;
    getMinPointLoosed(): Vector3;
    getNodes(): GraphNode[];
    getOrCreateChild(placement: OctreePlacement): OctreeNode;
    getOrCreateParent(): OctreeNode;
    getParent(): OctreeNode;
    getPosition(): number;
    removeNode(node: GraphNode): void;
    setChunk(chunk: OctreeNodeChunk): void;
    setPosition(index: number): void;
    traverse(v: Visitor<OctreeNode>): void;
}

// @public
export class OctreeNodeChunk {
    constructor(octree: Octree);
    clearNodes(): void;
    empty(): boolean;
    getChildIndex(index: number, placement: OctreePlacement): number;
    getDimension(): number;
    getLevel(): number;
    getNext(): OctreeNodeChunk;
    getNode(index: number): OctreeNode;
    getNodeSize(): number;
    getOctree(): Octree;
    getOrCreateNode(index: number): OctreeNode;
    getOrCreateNodeChain(index: number): OctreeNode;
    getParentIndex(index: number): number;
    getPrev(): OctreeNodeChunk;
    getWorldSize(): number;
    // @internal (undocumented)
    get nodeMap(): Map<number, OctreeNode>;
    setDimension(dimension: number): void;
    setLevel(level: number): void;
    setNext(chunk: OctreeNodeChunk): void;
    setNodeSize(size: number): void;
    setPrev(chunk: OctreeNodeChunk): void;
}

// @public
export enum OctreePlacement {
    // (undocumented)
    NNN = 7,
    // (undocumented)
    NNP = 6,
    // (undocumented)
    NPN = 5,
    // (undocumented)
    NPP = 4,
    // (undocumented)
    PNN = 3,
    // (undocumented)
    PNP = 2,
    // (undocumented)
    PPN = 1,
    // (undocumented)
    PPP = 0
}

// @public
export abstract class OIT {
    abstract applyUniforms(ctx: DrawContext, bindGroup: BindGroup): any;
    abstract begin(ctx: DrawContext): number;
    abstract beginPass(ctx: DrawContext, pass: number): boolean;
    abstract calculateHash(): string;
    abstract dispose(): void;
    abstract end(ctx: DrawContext): any;
    abstract endPass(ctx: DrawContext, pass: number): any;
    abstract getType(): string;
    abstract outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    abstract setRenderStates(rs: RenderStateSet): any;
    abstract setupFragmentOutput(scope: PBGlobalScope): any;
    abstract supportDevice(deviceType: string): boolean;
}

// @public
export class OrbitCameraController extends BaseCameraController {
    constructor(options?: OrbitCameraControllerOptions);
    get center(): Vector3;
    set center(val: Vector3);
    // @override
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @override
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @override
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @override
    protected _onMouseWheel(evt: WheelEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: OrbitCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface OrbitCameraControllerOptions {
    center: Vector3;
    damping?: number;
    distance?: number;
    rotateSpeed?: number;
    zoomSpeed?: number;
}

// @public
export class OrthoCamera extends Camera {
    constructor(scene: Scene, left: number, right: number, bottom: number, top: number, near: number, far: number);
    get bottom(): number;
    set bottom(val: number);
    // @internal (undocumented)
    protected _computeProj(): void;
    get far(): number;
    set far(val: number);
    get left(): number;
    set left(val: number);
    get near(): number;
    set near(val: number);
    get right(): number;
    set right(val: number);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get top(): number;
    set top(val: number);
}

// @public
export function panoramaToCubemap(tex: Texture2D, outputCubeMap: TextureCube): void;

// Warning: (ae-forgotten-export) The symbol "PBRMetallicRoughnessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class PBRMetallicRoughnessMaterial extends PBRMetallicRoughnessMaterial_base {
    constructor();
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// Warning: (ae-forgotten-export) The symbol "PBRSpecularGlossinessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class PBRSpecularGlossinessMaterial extends PBRSpecularGlossinessMaterial_base {
    constructor();
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// Warning: (ae-internal-missing-underscore) The name "PCFOPT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class PCFOPT extends ShadowImpl {
    constructor(kernelSize?: number);
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    postRenderShadowMap(): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    sampleShadowMap(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleShadowMapCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, split: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    protected _shadowSampler: TextureSampler;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "PCFPD" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class PCFPD extends ShadowImpl {
    constructor(tapCount?: number, sampleRadius?: number);
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    postRenderShadowMap(): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    protected _sampleRadius: number;
    // (undocumented)
    sampleShadowMap(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleShadowMapCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, split: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    protected _shadowSampler: TextureSampler;
    // (undocumented)
    get tapCount(): number;
    set tapCount(val: number);
    // (undocumented)
    protected _tapCount: number;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// @public
export class PerspectiveCamera extends Camera {
    constructor(scene: Scene, fovY: number, aspect: number, near: number, far: number);
    get aspect(): number;
    set aspect(val: number);
    // @internal (undocumented)
    protected _computeProj(): void;
    get far(): number;
    set far(val: number);
    get fovY(): number;
    set fovY(val: number);
    get near(): number;
    set near(val: number);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get window(): number[];
    set window(val: number[]);
}

// @public
export type PickResult = {
    drawable: Drawable;
    node: GraphNode;
};

// @public
export interface PlaneCreationOptions extends ShapeCreationOptions {
    size?: number;
    sizeX?: number;
    sizeY?: number;
}

// @public
export class PlaneShape extends Shape<PlaneCreationOptions> {
    constructor(options?: PlaneCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[], sizeX: number, sizeY: number): void;
    // @internal (undocumented)
    protected createDefaultOptions(): PlaneCreationOptions;
}

// @public
export type PlayAnimationOptions = {
    repeat?: number;
    speedRatio?: number;
    weight?: number;
    fadeIn?: number;
};

// @public
export class PointLight extends PunctualLight {
    constructor(scene: Scene);
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    // @override
    isPointLight(): this is PointLight;
    get range(): number;
    set range(val: number);
    // @internal (undocumented)
    protected _range: number;
    setRange(val: number): this;
}

// @public
export class PostWater extends AbstractPostEffect<'PostWater'> {
    constructor(elevation: number, waveGenerator: WaveGenerator);
    get antiReflectanceLeak(): number;
    set antiReflectanceLeak(val: number);
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get boundary(): Vector4;
    set boundary(val: Vector4);
    // (undocumented)
    get causticsFalloff(): number;
    set causticsFalloff(val: number);
    // (undocumented)
    get causticsIntensity(): number;
    set causticsIntensity(val: number);
    // (undocumented)
    get causticsSlopeMax(): number;
    set causticsSlopeMax(val: number);
    // (undocumented)
    get causticsSlopeMin(): number;
    set causticsSlopeMin(val: number);
    // (undocumented)
    static readonly className: "PostWater";
    get depthMulti(): number;
    set depthMulti(val: number);
    get displace(): number;
    set displace(val: number);
    get elevation(): number;
    set elevation(val: number);
    get envMap(): TextureCube;
    set envMap(tex: TextureCube);
    get gridScale(): number;
    set gridScale(val: number);
    get refractionStrength(): number;
    set refractionStrength(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get speed(): number;
    set speed(val: number);
    get ssr(): boolean;
    set ssr(val: boolean);
    // (undocumented)
    get ssrIterations(): number;
    set ssrIterations(val: number);
    // (undocumented)
    get ssrMaxDistance(): number;
    set ssrMaxDistance(val: number);
    // (undocumented)
    get ssrThickness(): number;
    set ssrThickness(val: number);
    // (undocumented)
    get waveGenerator(): WaveGenerator;
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// Warning: (ae-forgotten-export) The symbol "DistributionType" needs to be exported by the entry point index.d.ts
//
// @public
export function prefilterCubemap(tex: TextureCube, type: DistributionType, destTex: TextureCube, numSamples?: number): void;

// @public
export class Primitive {
    constructor();
    // @internal
    addBoundingboxChangeCallback(cb: () => void): void;
    // @internal (undocumented)
    protected _bbox: BoundingVolume;
    // @internal (undocumented)
    protected _bboxChangeCallback: (() => void)[];
    createAndSetIndexBuffer(data: Uint16Array | Uint32Array, dynamic?: boolean): IndexBuffer;
    createAndSetVertexBuffer(format: VertexAttribFormat, data: TypedArray, stepMode?: VertexStepMode): StructuredBuffer;
    // @internal (undocumented)
    protected _defaultIndexCount: number;
    dispose(): void;
    draw(): void;
    drawInstanced(numInstances: number): void;
    getBoundingVolume(): BoundingVolume;
    getIndexBuffer(): IndexBuffer;
    getNumFaces(): number;
    getNumVertices(): number;
    getVertexBuffer(semantic: VertexSemantic): StructuredBuffer;
    getVertexBufferInfo(semantic: VertexSemantic): VertexBufferInfo;
    // @internal
    get id(): number;
    // @internal (undocumented)
    protected _id: number;
    get indexCount(): number;
    set indexCount(val: number);
    // @internal (undocumented)
    protected _indexCount: number;
    get indexStart(): number;
    set indexStart(val: number);
    // @internal (undocumented)
    protected _indexStart: number;
    get primitiveType(): PrimitiveType;
    set primitiveType(type: PrimitiveType);
    // @internal (undocumented)
    protected _primitiveType: PrimitiveType;
    raycast(ray: Ray): number;
    removeBoundingboxChangeCallback(cb: () => void): void;
    removeVertexBuffer(buffer: StructuredBuffer): void;
    setBoundingVolume(bv: BoundingVolume): void;
    setIndexBuffer(buffer: IndexBuffer): void;
    setVertexBuffer(buffer: StructuredBuffer, stepMode?: VertexStepMode): StructuredBuffer<unknown>;
    // @internal (undocumented)
    protected _vertexLayout: VertexLayout;
    // @internal (undocumented)
    protected _vertexLayoutDirty: boolean;
    // @internal (undocumented)
    protected _vertexLayoutOptions: VertexLayoutOptions;
}

// @public
export function projectCubemap(tex: TextureCube): Promise<Vector3[]>;

// @public
export function projectCubemapCPU(input: TextureCube): Promise<Vector3[]>;

// @public
export abstract class PunctualLight extends BaseLight {
    constructor(scene: Scene, type: number);
    get castShadow(): boolean;
    set castShadow(b: boolean);
    // @internal (undocumented)
    protected _castShadow: boolean;
    get color(): Vector4;
    set color(clr: Vector4);
    // @internal (undocumented)
    protected _color: Vector4;
    // @override
    isPunctualLight(): this is PunctualLight;
    // @internal (undocumented)
    protected _lightViewProjectionMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    setCastShadow(b: boolean): this;
    setColor(color: Vector4): this;
    setLightViewProjectionMatrix(mat: Matrix4x4): this;
    get shadow(): ShadowMapper;
    // @internal (undocumented)
    protected _shadowMapper: ShadowMapper;
    // @override
    get viewProjMatrix(): Matrix4x4;
    set viewProjMatrix(mat: Matrix4x4);
}

// Warning: (ae-internal-missing-underscore) The name "Quadtree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Quadtree {
    constructor(terrain: Terrain);
    // (undocumented)
    build(patchSize: number, rootSizeX: number, rootSizeZ: number, elevations: Float32Array, scaleX: number, scaleY: number, scaleZ: number, vertexCacheSize: number): boolean;
    // (undocumented)
    cull(visitor: CullVisitor, viewPoint: Vector3, worldMatrix: Matrix4x4): number;
    // (undocumented)
    cull_r(visitor: CullVisitor, node: QuadtreeNode, viewPoint: Vector3, worldMatrix: Matrix4x4, frustum: Frustum, cliptest: boolean, ignorePatch: boolean): number;
    // (undocumented)
    getBoundingBox(bbox: BoundingBox): void;
    // (undocumented)
    getElevations(): Float32Array;
    // (undocumented)
    getHeightField(): HeightField;
    // (undocumented)
    getIndices(): IndexBuffer;
    // (undocumented)
    getIndicesWireframe(): IndexBuffer;
    // (undocumented)
    getPatchSize(): number;
    // (undocumented)
    getPrimitiveCount(): number;
    // (undocumented)
    getPrimitiveType(): PrimitiveType;
    // (undocumented)
    getRootSize(): number;
    // (undocumented)
    getRootSizeX(): number;
    // (undocumented)
    getRootSizeZ(): number;
    // (undocumented)
    getScaleX(): number;
    // (undocumented)
    getScaleZ(): number;
    // (undocumented)
    getTerrain(): Terrain;
    // (undocumented)
    line(strip: Uint16Array): Uint16Array;
    // (undocumented)
    get normalMap(): Texture2D;
    // (undocumented)
    get rootNode(): QuadtreeNode;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
    // (undocumented)
    strip(vertexCacheSize: number): Uint16Array;
    // (undocumented)
    get terrain(): Terrain;
}

// Warning: (ae-internal-missing-underscore) The name "QuadtreeNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class QuadtreeNode {
    constructor();
    // (undocumented)
    addGrassCluster(grassCluster: GrassCluster): void;
    // (undocumented)
    getBoundingbox(): BoundingBox;
    // (undocumented)
    getChild(index: number): QuadtreeNode;
    // (undocumented)
    getParent(): QuadtreeNode;
    // (undocumented)
    getPatch(): TerrainPatch;
    // Warning: (ae-forgotten-export) The symbol "GrassCluster" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get grassClusters(): GrassCluster[];
    // (undocumented)
    initialize(quadtree: Quadtree, parent: QuadtreeNode, rowIndex: number, colIndex: number, baseVertices: Float32Array, normals: Vector3[], heightScale: number, elevations: Float32Array): boolean;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
}

// @public
export const QUEUE_OPAQUE = 1;

// @public
export const QUEUE_TRANSPARENT = 2;

// @public
export const RENDER_PASS_TYPE_DEPTH = 2;

// @public
export const RENDER_PASS_TYPE_LIGHT = 0;

// @public
export const RENDER_PASS_TYPE_OBJECT_COLOR = 3;

// @public
export const RENDER_PASS_TYPE_SHADOWMAP = 1;

// Warning: (ae-internal-missing-underscore) The name "RenderItemList" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RenderItemList {
    // (undocumented)
    opaque: RenderItemListBundle;
    // (undocumented)
    transmission: RenderItemListBundle;
    // (undocumented)
    transmission_trans: RenderItemListBundle;
    // (undocumented)
    transparent: RenderItemListBundle;
}

// Warning: (ae-internal-missing-underscore) The name "RenderItemListBundle" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface RenderItemListBundle {
    // (undocumented)
    lit: RenderItemListInfo[];
    // (undocumented)
    unlit: RenderItemListInfo[];
}

// Warning: (ae-internal-missing-underscore) The name "RenderItemListInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface RenderItemListInfo {
    // (undocumented)
    instanceItemList: RenderQueueItem[];
    // (undocumented)
    instanceList: Record<string, BatchDrawable[]>;
    // (undocumented)
    instanceRenderBundle?: RenderBundleWrapper;
    // (undocumented)
    itemList: RenderQueueItem[];
    // (undocumented)
    materialList: Set<Material>;
    // (undocumented)
    morphItemList: RenderQueueItem[];
    // (undocumented)
    morphRenderBundle?: RenderBundleWrapper;
    // Warning: (ae-forgotten-export) The symbol "RenderBundleWrapper" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    renderBundle?: RenderBundleWrapper;
    // (undocumented)
    renderQueue: RenderQueue;
    // (undocumented)
    skinAndMorphItemList: RenderQueueItem[];
    // (undocumented)
    skinAndMorphRenderBundle?: RenderBundleWrapper;
    // (undocumented)
    skinItemList: RenderQueueItem[];
    // (undocumented)
    skinRenderBundle?: RenderBundleWrapper;
}

// @public
export abstract class RenderPass {
    constructor(type: number);
    get clearColor(): Vector4;
    set clearColor(color: Vector4);
    // @internal (undocumented)
    protected _clearColor: Vector4;
    get clearDepth(): number;
    set clearDepth(depth: number);
    // @internal (undocumented)
    protected _clearDepth: number;
    get clearStencil(): number;
    set clearStencil(stencil: number);
    // @internal (undocumented)
    protected _clearStencil: number;
    cullScene(ctx: DrawContext, cullCamera: Camera): RenderQueue;
    dispose(): void;
    // @internal (undocumented)
    protected drawItem(device: AbstractDevice, item: RenderQueueItem, ctx: DrawContext, reverseWinding: boolean): void;
    // @internal (undocumented)
    protected drawItemList(itemList: RenderItemListInfo, ctx: DrawContext, reverseWinding: boolean): void;
    // @internal (undocumented)
    protected drawScene(ctx: DrawContext, cullCamera: Camera, renderQueue?: RenderQueue): void;
    // @internal (undocumented)
    protected getGlobalBindGroup(ctx: DrawContext): BindGroup;
    // @internal (undocumented)
    getGlobalBindGroupHash(ctx: DrawContext): string;
    // @internal (undocumented)
    protected abstract _getGlobalBindGroupHash(ctx: DrawContext): any;
    // @internal (undocumented)
    protected _globalBindGroups: Record<string, BindGroup>;
    // @internal (undocumented)
    isAutoFlip(ctx: DrawContext): boolean;
    render(ctx: DrawContext, cullCamera?: Camera, renderQueue?: RenderQueue): void;
    // @internal (undocumented)
    protected abstract renderItems(ctx: DrawContext, renderQueue: RenderQueue): any;
    get type(): number;
    // @internal (undocumented)
    protected _type: number;
}

// @public
export class RenderQueue {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "InstanceBindGroupAllocator" which is marked as @internal
    constructor(renderPass: RenderPass, bindGroupAllocator?: InstanceBindGroupAllocator);
    // Warning: (ae-incompatible-release-tags) The symbol "binaryInsert" is marked as @public, but its signature references "RenderQueueItem" which is marked as @internal
    //
    // (undocumented)
    binaryInsert(itemList: RenderQueueItem[], item: RenderQueueItem): void;
    // @internal (undocumented)
    dispose(): void;
    get drawTransparent(): boolean;
    // @internal (undocumented)
    end(camera: Camera, createRenderBundles?: boolean): this;
    // @internal (undocumented)
    getDrawableByColor(c: Uint8Array): Drawable;
    // Warning: (ae-incompatible-release-tags) The symbol "getInstanceInfo" is marked as @public, but its signature references "DrawableInstanceInfo" which is marked as @internal
    getInstanceInfo(drawable: Drawable): DrawableInstanceInfo;
    // @internal
    getMaxBatchSize(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "itemList" is marked as @public, but its signature references "RenderItemList" which is marked as @internal
    get itemList(): RenderItemList;
    get needSceneColor(): boolean;
    push(camera: Camera, drawable: Drawable): void;
    pushLight(light: PunctualLight): void;
    pushRenderQueue(queue: RenderQueue): void;
    // Warning: (ae-incompatible-release-tags) The symbol "ref" is marked as @public, but its signature references "RenderQueueRef" which is marked as @internal
    get ref(): RenderQueueRef;
    get renderPass(): RenderPass;
    reset(): void;
    get shadowedLights(): PunctualLight[];
    sortTransparentItems(cameraPos: Vector3): void;
    get sunLight(): DirectionalLight;
    set sunLight(light: DirectionalLight);
    get unshadowedLights(): PunctualLight[];
}

// Warning: (ae-internal-missing-underscore) The name "RenderQueueItem" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RenderQueueItem {
    // (undocumented)
    drawable: Drawable;
    // (undocumented)
    instanceColor?: Vector4;
    // (undocumented)
    instanceData: InstanceData;
    // (undocumented)
    sortDistance: number;
}

// Warning: (ae-internal-missing-underscore) The name "RenderQueueRef" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RenderQueueRef {
    // (undocumented)
    ref: RenderQueue;
}

// @public
export class RotationTrack extends AnimationTrack<Quaternion> {
    constructor(interpolator: Interpolator);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Quaternion;
    }[]);
    // (undocumented)
    applyState(node: SceneNode, state: Quaternion): void;
    // (undocumented)
    calculateState(currentTime: number): Quaternion;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    mixState(a: Quaternion, b: Quaternion, t: number): Quaternion;
}

// @public
export class SAO extends AbstractPostEffect<'SAO'> {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get bias(): number;
    set bias(val: number);
    get blurDepthCutoff(): number;
    set blurDepthCutoff(val: number);
    get blurKernelSize(): number;
    set blurKernelSize(val: number);
    get blurStdDev(): number;
    set blurStdDev(val: number);
    // (undocumented)
    static readonly className: "SAO";
    dispose(): void;
    get intensity(): number;
    set intensity(val: number);
    get minResolution(): number;
    set minResolution(val: number);
    get radius(): number;
    set radius(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get scale(): number;
    set scale(val: number);
}

// @public
export class ScaleTrack extends AnimationTrack<Vector3> {
    constructor(interpolator: Interpolator);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[]);
    // (undocumented)
    applyState(node: SceneNode, state: Vector3): void;
    // (undocumented)
    calculateState(currentTime: number): Vector3;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    mixState(a: Vector3, b: Vector3, t: number): Vector3;
}

// Warning: (ae-forgotten-export) The symbol "Scene_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Scene extends Scene_base {
    constructor();
    // @internal (undocumented)
    get animationSet(): AnimationSet[];
    // @internal (undocumented)
    protected _animationSet: AnimationSet[];
    get boundingBox(): AABB;
    constructRay(camera: Camera, viewportWidth: number, viewportHeight: number, screenX: number, screenY: number, invModelMatrix?: Matrix4x4): Ray;
    dispose(): void;
    get env(): Environment;
    // @internal (undocumented)
    protected _env: Environment;
    // @internal (undocumented)
    frameUpdate(): void;
    get id(): number;
    // @internal (undocumented)
    protected _id: number;
    // @internal (undocumented)
    invalidateNodePlacement(node: GraphNode): void;
    // @internal (undocumented)
    protected _nodePlaceList: Set<GraphNode>;
    get octree(): Octree;
    // @internal (undocumented)
    protected _octree: Octree;
    raycast(ray: Ray, length?: number): {
        node: GraphNode;
        dist: number;
        point: Vector3;
    };
    get rootNode(): SceneNode;
    // @internal (undocumented)
    protected _rootNode: SceneNode;
    // @internal (undocumented)
    protected _updateEvent: SceneUpdateEvent;
    // @internal (undocumented)
    protected _updateFrame: number;
    updateNodePlacement(octree: Octree, list: Set<GraphNode>): void;
}

// @public
export class SceneNode extends XForm<SceneNode> {
    constructor(scene: Scene);
    get attached(): boolean;
    // @internal (undocumented)
    protected _attached(): void;
    // (undocumented)
    static readonly BBOXDRAW_DISABLED = 0;
    // (undocumented)
    static readonly BBOXDRAW_INHERITED = -1;
    // (undocumented)
    static readonly BBOXDRAW_LOCAL = 1;
    // (undocumented)
    static readonly BBOXDRAW_WORLD = 2;
    get boundingBoxDrawMode(): number;
    set boundingBoxDrawMode(mode: number);
    // @internal (undocumented)
    protected _boxDrawMode: number;
    // @internal (undocumented)
    protected _bv: BoundingVolume;
    // @internal (undocumented)
    protected _bvDirty: boolean;
    // @internal (undocumented)
    protected _bvWorld: BoundingVolume;
    // @internal (undocumented)
    protected _clipMode: boolean;
    get clipTestEnabled(): boolean;
    set clipTestEnabled(val: boolean);
    computeBoundingVolume(): BoundingVolume;
    get computedBoundingBoxDrawMode(): number;
    // @internal (undocumented)
    protected _detached(): void;
    dispose(): void;
    getBoundingVolume(): BoundingVolume;
    getWorldBoundingVolume(): BoundingVolume;
    hasChild(child: SceneNode): boolean;
    get hidden(): boolean;
    invalidateBoundingVolume(): void;
    invalidateWorldBoundingVolume(transformChanged: boolean): void;
    isBatchGroup(): this is BatchGroup;
    isCamera(): this is Camera;
    isGraphNode(): this is GraphNode;
    isLight(): this is BaseLight;
    isMesh(): this is Mesh;
    isParentOf(child: SceneNode): boolean;
    isPunctualLight(): this is PunctualLight;
    isTerrain(): this is Terrain;
    iterate(callback: (node: SceneNode) => void): void;
    get name(): string;
    set name(val: string);
    // @internal (undocumented)
    protected _name: string;
    // @internal (undocumented)
    notifyHiddenChanged(): void;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    get pickable(): boolean;
    set pickable(val: boolean);
    // @internal (undocumented)
    protected _pickMode: boolean;
    // @internal (undocumented)
    get placeToOctree(): boolean;
    set placeToOctree(val: boolean);
    remove(): this;
    removeChildren(): void;
    get scene(): Scene;
    // @internal (undocumented)
    protected _scene: Scene;
    setBoundingVolume(bv: BoundingVolume): void;
    // @internal (undocumented)
    protected _setParent(p: SceneNode): void;
    get showState(): SceneNodeVisible;
    set showState(val: SceneNodeVisible);
    traverse(v: Visitor<SceneNode>, inverse?: boolean): void;
    // @internal (undocumented)
    protected _visible: SceneNodeVisible;
    // @internal (undocumented)
    protected _visibleChanged(): void;
    // @internal (undocumented)
    protected _willAttach(): void;
    // @internal (undocumented)
    protected _willDetach(): void;
}

// @public
export type SceneNodeVisible = 'visible' | 'inherit' | 'hidden';

// Warning: (ae-internal-missing-underscore) The name "SceneRenderer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class SceneRenderer {
    static get depthRenderPass(): DepthPass;
    // (undocumented)
    static freeClusteredLight(clusteredLight: ClusteredLight): void;
    // (undocumented)
    static getClusteredLight(): ClusteredLight;
    static renderScene(scene: Scene, camera: Camera, compositor?: Compositor): void;
    // (undocumented)
    protected static _renderScene(ctx: DrawContext): void;
    // (undocumented)
    protected static _renderSceneDepth(ctx: DrawContext, renderQueue: RenderQueue, depthFramebuffer: FrameBuffer, renderBackfaceDepth?: boolean): void;
    static get sceneRenderPass(): LightPass;
    // (undocumented)
    static setClearColor(color: Vector4): void;
    static get shadowMapRenderPass(): ShadowMapPass;
}

// @public
export class SceneUpdateEvent {
    constructor(scene: Scene);
    // (undocumented)
    static readonly NAME: "sceneupdate";
    // (undocumented)
    scene: Scene;
    // (undocumented)
    type: "sceneupdate";
}

// @public
export class ShaderHelper {
    // (undocumented)
    static applyFog(scope: PBInsideFunctionScope, worldPos: PBShaderExp, color: PBShaderExp, ctx: DrawContext): void;
    // (undocumented)
    static readonly BILLBOARD_SPHERICAL = 1;
    // (undocumented)
    static readonly BILLBOARD_SYLINDRAL = 2;
    // (undocumented)
    static calculateMorphDelta(scope: PBInsideFunctionScope, attrib: number): PBShaderExp;
    static calculateShadow(scope: PBInsideFunctionScope, worldPos: PBShaderExp, NoL: PBShaderExp, ctx: DrawContext): PBShaderExp;
    // @internal (undocumented)
    static calculateShadowSpaceVertex(scope: PBInsideFunctionScope, worldPos: PBShaderExp, cascade?: PBShaderExp | number): PBShaderExp;
    static calculateSkinMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static computeFogFactor(scope: PBInsideFunctionScope, viewDir: PBShaderExp, fogType: PBShaderExp, fogParams: PBShaderExp): PBShaderExp;
    static computeFogFactorForType(scope: PBInsideFunctionScope, viewDir: PBShaderExp, fogParams: PBShaderExp, fogType: 'linear' | 'exp' | 'exp2'): PBShaderExp;
    // @internal (undocumented)
    static defaultSunDir: Vector3;
    static discardIfClipped(scope: PBInsideFunctionScope, worldPos: PBShaderExp): void;
    static encodeColorOutput(scope: PBInsideFunctionScope, outputColor: PBShaderExp): PBShaderExp;
    // (undocumented)
    static readonly FOG_TYPE_EXP = 2;
    // (undocumented)
    static readonly FOG_TYPE_EXP2 = 3;
    // (undocumented)
    static readonly FOG_TYPE_LINEAR = 1;
    // (undocumented)
    static readonly FOG_TYPE_NONE = 0;
    // (undocumented)
    static readonly FOG_TYPE_SCATTER = 4;
    static getAerialPerspectiveLUT(scope: PBInsideFunctionScope): PBShaderExp;
    static getAPDensity(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getBoneInvBindMatrixUniformName(): string;
    // (undocumented)
    static getBoneMatricesUniformName(): string;
    // (undocumented)
    static getBoneTextureSizeUniformName(): string;
    static getCameraClipPlane(scope: PBInsideFunctionScope): any;
    static getCameraClipPlaneFlag(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraPosition(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraRoughnessFactor(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getCascadeDistances(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getClusteredLightIndexTexture(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getClusterParams(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getCountParams(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getDepthBiasScales(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getDepthBiasValues(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getDrawableBindGroupLayout(skinning: boolean, morphing: boolean, instancing: boolean): BindGroupLayout;
    static getEnvLightStrength(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogColor(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogType(scope: PBInsideFunctionScope): PBShaderExp;
    static getGlobalUniforms(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getInstanceDataOffsetUniformName(): string;
    // (undocumented)
    static getInstanceDataStrideUniformName(): string;
    // (undocumented)
    static getInstanceDataUniformName(): string;
    static getInstancedUniform(scope: PBInsideFunctionScope, uniformIndex: number): PBShaderExp;
    // (undocumented)
    static getLightBufferUniformName(): string;
    // @internal (undocumented)
    static getLightColorAndIntensity(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightDirectionAndCutoff(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightPositionAndRange(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightPositionAndRangeForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getLightTypeForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getLightViewMatrixForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getMorphDataUniformName(): string;
    // (undocumented)
    static getMorphInfoUniformName(): string;
    static getNormalMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getNumLights(scope: PBInsideFunctionScope): PBShaderExp;
    static getProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getShadowCameraParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getShadowMap(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getSunLightDir(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getWorldMatrixUniformName(): string;
    static hasMorphing(scope: PBInsideFunctionScope): boolean;
    static hasSkinning(scope: PBInsideFunctionScope): boolean;
    static linearDepthToNonLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    static nonLinearDepthToLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    static nonLinearDepthToLinearNormalized(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    static prepareFragmentShader(pb: ProgramBuilder, ctx: DrawContext): void;
    static prepareVertexShader(pb: ProgramBuilder, ctx: DrawContext): void;
    // @internal (undocumented)
    static prepareVertexShaderCommon(pb: ProgramBuilder, ctx: DrawContext): void;
    static resolveVertexNormal(scope: PBInsideFunctionScope, normal?: PBShaderExp): PBShaderExp;
    static resolveVertexPosition(scope: PBInsideFunctionScope, pos?: PBShaderExp): PBShaderExp;
    static resolveVertexTangent(scope: PBInsideFunctionScope, tangent?: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    static setCameraUniforms(bindGroup: BindGroup, camera: Camera, flip: boolean, linear: boolean): void;
    static setClipSpacePosition(scope: PBInsideFunctionScope, pos: PBShaderExp): void;
    // @internal (undocumented)
    static setFogUniforms(bindGroup: BindGroup, fogType: number, fogColor: Vector4, fogParams: Vector4, apDensity: number, aerialPerspectiveLUT?: Texture2D): void;
    // @internal (undocumented)
    static setLightUniforms(bindGroup: BindGroup, ctx: DrawContext, clusterParams: Float32Array, countParams: Int32Array, lightBuffer: StructuredBuffer, lightIndexTexture: Texture2D): void;
    // @internal (undocumented)
    static setLightUniformsShadow(bindGroup: BindGroup, ctx: DrawContext, light: PunctualLight): void;
    // @internal (undocumented)
    static setLightUniformsShadowMap(bindGroup: BindGroup, ctx: DrawContext, light: PunctualLight): void;
    static vertexShaderDrawableStuff(scope: PBGlobalScope, skinning: boolean, morphing: boolean, instanced: boolean): void;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowConfig" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ShadowConfig {
    // (undocumented)
    depthBias?: number;
    // (undocumented)
    nearClip?: number;
    // (undocumented)
    normalBias?: number;
    // (undocumented)
    numCascades?: number;
    // (undocumented)
    shadowMapSize: number;
    // (undocumented)
    splitLambda?: number;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowMapParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ShadowMapParams = {
    lightType: number;
    shaderHash: string;
    numShadowCascades: number;
    depthClampEnabled: boolean;
    cascadeDistances: Vector4;
    depthBiasValues: Vector4[];
    depthBiasScales: Vector4;
    cameraParams: Vector4;
    shadowMatrices: Float32Array;
    shadowMapFramebuffer: FrameBuffer;
    shadowMap: BaseTexture;
    shadowMapSampler: TextureSampler;
    impl: ShadowImpl;
    implData: unknown;
};

// @public
export class ShadowMapPass extends RenderPass {
    constructor();
    // @internal (undocumented)
    protected _currentLight: PunctualLight;
    // @internal (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    get light(): PunctualLight;
    set light(light: PunctualLight);
    // @internal (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
}

// @public
export class ShadowMapper {
    constructor(light: PunctualLight);
    // @internal (undocumented)
    protected calcDepthBiasParams(camera: Camera, shadowMapSize: number, depthBias: number, normalBias: number, depthScale: number, result: Vector4): void;
    // @internal (undocumented)
    calcSplitDistances(nearPlane: number, farPlane: number, numCascades: number): number[];
    // @internal (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    static computeShadowBias(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, z: PBShaderExp, NdotL: PBShaderExp, linear: boolean): PBShaderExp;
    // @internal (undocumented)
    static computeShadowBiasCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    protected _config: ShadowConfig;
    // @internal (undocumented)
    protected createLightCameraDirectional(sceneAABB: AABB, sceneCamera: Camera, lightCamera: Camera, cropMatrix?: Matrix4x4, border?: number): void;
    // @internal (undocumented)
    protected createLightCameraPoint(lightCamera: Camera): void;
    // @internal (undocumented)
    protected createLightCameraSpot(lightCamera: Camera): void;
    // @internal (undocumented)
    protected createTexture(target: TextureType, format: TextureFormat, width: number, height: number, depth: number): Texture2D | TextureCube | Texture2DArray;
    get depthBias(): number;
    set depthBias(val: number);
    get esmBlur(): boolean;
    set esmBlur(val: boolean);
    // @internal (undocumented)
    protected _esmBlur: boolean;
    get esmBlurKernelSize(): number;
    set esmBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _esmBlurKernelSize: number;
    get esmBlurRadius(): number;
    set esmBlurRadius(val: number);
    // @internal (undocumented)
    protected _esmBlurRadius: number;
    get esmDepthScale(): number;
    set esmDepthScale(val: number);
    // @internal (undocumented)
    protected _esmDepthScale: number;
    // @internal (undocumented)
    static fetchTemporalFramebuffer(autoRelease: boolean, lightType: number, numCascades: number, width: number, height: number, colorFormat: TextureFormat, depthFormat: TextureFormat, mipmapping?: boolean): FrameBuffer<unknown>;
    // @internal (undocumented)
    getShaderHash(shadowMapParams: ShadowMapParams): string;
    // @internal (undocumented)
    protected _impl: ShadowImpl;
    // @internal (undocumented)
    protected isTextureInvalid(texture: Texture2D | TextureCube | Texture2DArray, target: TextureType, format: TextureFormat, width: number, height: number): boolean;
    get light(): PunctualLight;
    // @internal (undocumented)
    protected _light: PunctualLight;
    get mode(): ShadowMode;
    set mode(mode: ShadowMode);
    get nearClip(): number;
    set nearClip(val: number);
    get normalBias(): number;
    set normalBias(val: number);
    get numShadowCascades(): number;
    set numShadowCascades(num: number);
    get pcfKernelSize(): number;
    set pcfKernelSize(val: number);
    // @internal (undocumented)
    protected _pcfKernelSize: number;
    get pdSampleCount(): number;
    set pdSampleCount(val: number);
    // @internal (undocumented)
    protected _pdSampleCount: number;
    get pdSampleRadius(): number;
    set pdSampleRadius(val: number);
    // @internal (undocumented)
    protected _pdSampleRadius: number;
    // @internal (undocumented)
    protected postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // @internal (undocumented)
    static releaseTemporalResources(ctx: DrawContext): void;
    // @internal (undocumented)
    render(ctx: DrawContext, renderPass: ShadowMapPass): void;
    // @internal (undocumented)
    protected _resourceDirty: boolean;
    get shadowDistance(): number;
    set shadowDistance(val: number);
    // @internal (undocumented)
    protected _shadowDistance: number;
    get shadowMapSize(): number;
    set shadowMapSize(num: number);
    // @internal (undocumented)
    protected _shadowMode: ShadowMode;
    get shadowRegion(): AABB;
    set shadowRegion(region: AABB);
    // @internal (undocumented)
    protected _shadowRegion: AABB;
    get splitLambda(): number;
    set splitLambda(val: number);
    // @internal (undocumented)
    protected updateResources(shadowMapParams: ShadowMapParams): void;
    get vsmBlurKernelSize(): number;
    set vsmBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _vsmBlurKernelSize: number;
    get vsmBlurRadius(): number;
    set vsmBlurRadius(val: number);
    // @internal (undocumented)
    protected _vsmBlurRadius: number;
    get vsmDarkness(): number;
    set vsmDarkness(val: number);
    // @internal (undocumented)
    protected _vsmDarkness: number;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowMapType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ShadowMapType = Texture2D | TextureCube | Texture2DArray;

// @public
export type ShadowMode = 'hard' | 'vsm' | 'esm' | 'pcf-pd' | 'pcf-opt';

// @public
export abstract class Shape<T extends ShapeCreationOptions = ShapeCreationOptions> extends Primitive {
    constructor(options?: T);
    // @internal (undocumented)
    create(options?: T): boolean;
    // @internal (undocumented)
    protected abstract _create(): boolean;
    // @internal (undocumented)
    protected createDefaultOptions(): T;
    get options(): T;
    // @internal (undocumented)
    protected _options: T;
}

// @public
export interface ShapeCreationOptions {
    needNormal?: boolean;
    needTangent?: boolean;
    needUV?: boolean;
}

// @public
export class SharedModel {
    constructor(name?: string);
    get activeScene(): number;
    set activeScene(val: number);
    addAnimation(animation: AssetAnimationData): void;
    addNode(parent: AssetHierarchyNode, index: number, name: string): AssetHierarchyNode;
    addSkeleton(skeleton: AssetSkeleton): void;
    get animations(): AssetAnimationData[];
    get name(): string;
    set name(val: string);
    get nodes(): AssetHierarchyNode[];
    get scenes(): AssetScene[];
    get skeletons(): AssetSkeleton[];
}

// @public
export class Skeleton {
    constructor(joints: SceneNode[], inverseBindMatrices: Matrix4x4[], bindPoseMatrices: Matrix4x4[], meshes: Mesh[], bounding: AssetSubMeshData[]);
    // @internal (undocumented)
    apply(): void;
    // @internal (undocumented)
    protected _bindPoseMatrices: Matrix4x4[];
    // @internal (undocumented)
    computeBindPose(model: SceneNode): void;
    // @internal (undocumented)
    computeBoundingBox(info: SkinnedBoundingBox, invWorldMatrix: Matrix4x4): void;
    // @internal (undocumented)
    computeJoints(): void;
    dispose(): void;
    // @internal (undocumented)
    protected _inverseBindMatrices: Matrix4x4[];
    get jointMatrices(): Matrix4x4[];
    // @internal (undocumented)
    protected _jointMatrices: Matrix4x4[];
    // @internal (undocumented)
    protected _jointMatrixArray: Float32Array;
    // @internal (undocumented)
    protected _joints: SceneNode[];
    get jointTexture(): Texture2D;
    // @internal (undocumented)
    protected _jointTexture: Texture2D;
    // @internal (undocumented)
    protected _meshes: {
        mesh: Mesh;
        bounding: SkinnedBoundingBox;
        box: BoundingBox;
    }[];
    // @internal (undocumented)
    reset(model: SceneNode): void;
    // @internal (undocumented)
    updateJointMatrices(jointTransforms?: Matrix4x4[], worldMatrix?: Matrix4x4): void;
}

// @public
export class SkyRenderer {
    constructor();
    get aerialPerspectiveDensity(): number;
    set aerialPerspectiveDensity(val: number);
    get autoUpdateIBLMaps(): boolean;
    set autoUpdateIBLMaps(val: boolean);
    get bakedSkyTexture(): TextureCube;
    get cloudIntensity(): number;
    set cloudIntensity(val: number);
    get cloudy(): number;
    set cloudy(val: number);
    get drawGround(): boolean;
    set drawGround(val: boolean);
    // @internal (undocumented)
    drawScatteredFog(ctx: DrawContext): boolean;
    get fogColor(): Vector4;
    set fogColor(val: Vector4);
    get fogDensity(): number;
    set fogDensity(val: number);
    get fogEnd(): number;
    set fogEnd(val: number);
    // @internal (undocumented)
    get fogParams(): Vector4;
    set fogParams(val: Vector4);
    get fogStart(): number;
    set fogStart(val: number);
    get fogTop(): number;
    set fogTop(val: number);
    get fogType(): FogType;
    set fogType(val: FogType);
    // @internal (undocumented)
    getAerialPerspectiveLUT(ctx: DrawContext): _zephyr3d_device.Texture2D<unknown>;
    // @internal (undocumented)
    getHash(ctx: DrawContext): string;
    invalidateIBLMaps(): void;
    get irradianceMap(): TextureCube;
    // @internal (undocumented)
    get mappedFogType(): number;
    get radianceMap(): TextureCube;
    // @internal (undocumented)
    renderFog(ctx: DrawContext): void;
    // @internal (undocumented)
    renderSky(ctx: DrawContext): void;
    get skyboxTexture(): TextureCube;
    set skyboxTexture(tex: TextureCube);
    get skyColor(): Vector4;
    set skyColor(val: Vector4);
    get skyType(): SkyType;
    set skyType(val: SkyType);
    // @internal (undocumented)
    get skyWorldMatrix(): Matrix4x4;
    set skyWorldMatrix(val: Matrix4x4);
    updateIBLMaps(sunDir: Vector3): void;
    get wind(): Vector2;
    set wind(val: Vector2);
}

// @public
export type SkyType = 'color' | 'skybox' | 'scatter' | 'scatter-nocloud' | 'none';

// @public
export function smoothNoise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export interface SphereCreationOptions extends ShapeCreationOptions {
    horizonalDetail?: number;
    radius?: number;
    verticalDetail?: number;
}

// @public
export class SphereShape extends Shape<SphereCreationOptions> {
    constructor(options?: SphereCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected createDefaultOptions(): SphereCreationOptions;
    get radius(): number;
    // @override
    raycast(ray: Ray): number;
}

// @public
export class SpotLight extends PunctualLight {
    constructor(scene: Scene);
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    get cutoff(): number;
    set cutoff(val: number);
    // @internal (undocumented)
    protected _cutoff: number;
    // @override
    isSpotLight(): this is SpotLight;
    get range(): number;
    set range(val: number);
    // @internal (undocumented)
    protected _range: number;
    setCutoff(val: number): this;
    setRange(val: number): this;
}

// @public
export type StopAnimationOptions = {
    fadeOut?: number;
};

// @public
export class Terrain extends GraphNode {
    constructor(scene: Scene);
    get castShadow(): boolean;
    set castShadow(val: boolean);
    // @override
    computeBoundingVolume(): BoundingVolume;
    create(sizeX: number, sizeZ: number, elevations: Float32Array, scale: Vector3, patchSize: number, options?: TerrainMaterialOptions): boolean;
    createGrass(density: number[][], bladeWidth: number, bladeHeight: number, offset: number, grassTexture: Texture2D): void;
    // @internal (undocumented)
    cull(cullVisitor: CullVisitor): number;
    getElevation(x: number, z: number): number;
    getInstanceColor(): Vector4;
    getName(): string;
    getNormal(x: number, z: number, normal?: Vector3): Vector3;
    get grassMaterial(): GrassMaterial;
    get height(): number;
    get heightFieldScale(): Vector3;
    // @override
    isTerrain(): this is Terrain;
    get LODCamera(): Camera;
    set LODCamera(camera: Camera);
    get material(): TerrainMaterial;
    get maxPixelError(): number;
    set maxPixelError(val: number);
    get normalMap(): Texture2D;
    // @internal (undocumented)
    get patchSize(): number;
    // @internal (undocumented)
    get quadtree(): Quadtree;
    rayIntersect(ray: Ray): number | null;
    get scaledHeight(): number;
    get scaledWidth(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "traverseQuadtree" is marked as @public, but its signature references "QuadtreeNode" which is marked as @internal
    traverseQuadtree(callback: (node: QuadtreeNode) => void): void;
    get width(): number;
    get wireframe(): boolean;
    set wireframe(b: boolean);
}

// @public
export type TerrainDetailMapInfo = {
    albedoTextures: Texture2DArray | Texture2D[];
    uvScale: number[];
    metallic?: number[];
    roughness?: number[];
    normalScale?: number[];
    normalTextures?: Texture2DArray | Texture2D[];
    albedoTexCoordIndex?: number | number[];
    normalTexCoordIndex?: number | number[];
    grass?: {
        texture?: Texture2D;
        bladeWidth?: number;
        bladeHeigh?: number;
        density?: number;
        offset?: number;
    }[][];
};

// Warning: (ae-forgotten-export) The symbol "TerrainMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class TerrainMaterial extends TerrainMaterial_base {
    constructor(options?: TerrainMaterialOptions);
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    calculateAlbedoColor(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    generateMetallicRoughnessMap(): Texture2D;
    getAlbedoTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    getMetallicRoughnessTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    getNormalTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    // @override
    isBatchable(): boolean;
    // @override
    isTransparentPass(pass: number): boolean;
    // (undocumented)
    sampleDetailNormalMap(scope: PBInsideFunctionScope, tex: PBShaderExp, texCoord: PBShaderExp, normalScale: PBShaderExp, TBN: PBShaderExp): PBShaderExp;
    // @override
    supportInstancing(): boolean;
    // @override
    supportLighting(): boolean;
    // (undocumented)
    get terrainInfo(): Vector4;
    set terrainInfo(val: Vector4);
    // (undocumented)
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export type TerrainMaterialOptions = {
    splatMap?: Texture2D;
    splatMapTexCoordIndex?: number;
    detailMaps?: TerrainDetailMapInfo;
};

// Warning: (ae-forgotten-export) The symbol "TerrainPatch_base" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "TerrainPatch" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class TerrainPatch extends TerrainPatch_base implements Drawable {
    constructor(terrain: Terrain);
    // (undocumented)
    computeBoundingBox(box: BoundingBox): void;
    // (undocumented)
    computeErrorMetric(other: TerrainPatch): number;
    // (undocumented)
    computeHeightBound(): [number, number];
    // (undocumented)
    computeLodDistance(viewportH: number, tanHalfFovy: number, maxPixelError: number): number;
    // (undocumented)
    computeMaxError(): number;
    // (undocumented)
    computeSkirtLength(): number;
    // (undocumented)
    draw(ctx: DrawContext): void;
    // (undocumented)
    getBoneMatrices(): Texture2D<unknown>;
    // (undocumented)
    getBoundingBox(): BoundingBox;
    // (undocumented)
    getGeometry(): Primitive;
    // (undocumented)
    getGeometryWireframe(): Primitive;
    // (undocumented)
    getHeight(x: number, z: number): number;
    // (undocumented)
    getInstanceColor(): Vector4;
    // (undocumented)
    getLODDistance(): number;
    // (undocumented)
    getMaterial(): MeshMaterial;
    // (undocumented)
    getMipLevel(): number;
    // (undocumented)
    getMorphData(): Texture2D;
    // (undocumented)
    getMorphInfo(): GPUDataBuffer;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getOffsetScale(): Vector4;
    // (undocumented)
    getOffsetX(): number;
    // (undocumented)
    getOffsetZ(): number;
    // (undocumented)
    getPickTarget(): GraphNode;
    // (undocumented)
    getQueueType(): number;
    // (undocumented)
    getSortDistance(camera: Camera): number;
    // (undocumented)
    getStep(): number;
    // (undocumented)
    initialize(quadtree: Quadtree, parent: TerrainPatch, rowIndex: number, colIndex: number, baseVertices: Float32Array, normals: Vector3[], heightScale: number, elevations: Float32Array): boolean;
    // (undocumented)
    isBatchable(): this is BatchDrawable;
    // (undocumented)
    isDummy(): boolean;
    // (undocumented)
    isUnlit(): boolean;
    // (undocumented)
    needSceneColor(): boolean;
    // (undocumented)
    setBoundingBox(bbox: BoundingBox): void;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
    // (undocumented)
    setupVertices(skirtLength: number, baseVertices: Float32Array, normalVectors: Vector3[], heightScale: number, elevations: Float32Array): void;
    // (undocumented)
    sqrDistancePointToTriangle(P: Vector3, t0: Vector3, t1: Vector3, t2: Vector3): number;
    // (undocumented)
    sqrDistanceToPoint(point: Vector3): number;
}

// Warning: (ae-internal-missing-underscore) The name "TerrainPatchBase" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class TerrainPatchBase {
    constructor(terrain: Terrain);
    // (undocumented)
    getXForm(): XForm<XForm<any>>;
    // (undocumented)
    protected _terrain: Terrain;
}

// @public
export type TextureFetchOptions<T extends BaseTexture> = {
    mimeType?: string;
    linearColorSpace?: boolean;
    texture?: T;
    samplerOptions?: SamplerOptions;
};

// @public
export type TextureMixinInstanceTypes<T> = TextureMixinTypes<T> extends {
    new (...args: any[]): infer U;
} ? U : never;

// @public
export type TextureMixinTypes<T> = ReturnType<typeof applyMaterialMixins<ToMixedTextureType<T>, typeof MeshMaterial>>;

// @public
export type TextureProp<U extends string> = {
    [P in 'Texture' | 'TextureSampler' | 'TexCoordIndex' | 'TexCoordMatrix' as `${U}${P}`]: P extends 'Texture' ? Texture2D : P extends 'TextureSampler' ? TextureSampler : P extends 'TexCoordIndex' ? number : P extends 'TexCoordMatrix' ? Matrix4x4 : never;
};

// @public
export type TexturePropUniforms<U extends string> = {
    [P in 'TextureUniform' | 'TexCoord' as `get${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope) => PBShaderExp;
} & {
    [P in 'Texture' as `sample${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope, texCoord?: PBShaderExp) => PBShaderExp;
};

// @public
export type ToMixedTextureType<T> = T extends [infer First, ...infer Rest] ? [First extends string ? ReturnType<typeof mixinTextureProps<First>> : never, ...ToMixedTextureType<Rest>] : [];

// @public
export class Tonemap extends AbstractPostEffect<'Tonemap'> {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // (undocumented)
    static readonly className: "Tonemap";
    dispose(): void;
    get exposure(): number;
    set exposure(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export interface TorusCreationOptions extends ShapeCreationOptions {
    innerRadius?: number;
    numSegments?: number;
    numSlices?: number;
    outerRadius?: number;
    radialDetail?: number;
}

// @public
export class TorusShape extends Shape<TorusCreationOptions> {
    constructor(options?: TorusCreationOptions);
    // @internal (undocumented)
    protected _create(): boolean;
    // @internal (undocumented)
    protected _createArrays(vertices: number[], normals: number[], uvs: number[], indices: number[]): void;
    // @internal (undocumented)
    protected createDefaultOptions(): TorusCreationOptions;
}

// @public
export class TranslationTrack extends AnimationTrack<Vector3> {
    constructor(interpolator: Interpolator);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[]);
    // (undocumented)
    applyState(node: SceneNode, state: Vector3): void;
    // (undocumented)
    calculateState(currentTime: number): Vector3;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    mixState(a: Vector3, b: Vector3, t: number): Vector3;
}

// Warning: (ae-forgotten-export) The symbol "UnlitMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class UnlitMaterial extends UnlitMaterial_base {
    constructor();
    // (undocumented)
    static readonly FEATURE_VERTEX_COLOR = "um_vertexcolor";
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export interface Visitor<T> {
    // (undocumented)
    visit(target: T): unknown;
}

// Warning: (ae-internal-missing-underscore) The name "VSM" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class VSM extends ShadowImpl {
    constructor(kernelSize?: number, blurSize?: number, darkness?: number);
    // Warning: (ae-forgotten-export) The symbol "VSMBlitter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _blitterH: VSMBlitter;
    // (undocumented)
    protected _blitterV: VSMBlitter;
    // (undocumented)
    get blur(): boolean;
    set blur(val: boolean);
    // (undocumented)
    protected _blur: boolean;
    // (undocumented)
    get blurSize(): number;
    set blurSize(val: number);
    // (undocumented)
    protected _blurSize: number;
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    protected _darkness: number;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    get mipmap(): boolean;
    set mipmap(b: boolean);
    // (undocumented)
    protected _mipmap: boolean;
    // (undocumented)
    postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    releaseTemporalResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "WaterMesh" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class WaterMesh {
    constructor();
    // (undocumented)
    getClipmapBindGroup(device: AbstractDevice): BindGroup;
    // (undocumented)
    getWaterBindGroup(device: AbstractDevice): BindGroup;
    // (undocumented)
    get gridScale(): number;
    set gridScale(val: number);
    // (undocumented)
    get level(): number;
    set level(val: number);
    // (undocumented)
    prepareForRender(device: AbstractDevice): boolean;
    // (undocumented)
    get region(): Vector4;
    set region(val: Vector4);
    // (undocumented)
    render(device: AbstractDevice, camera: Camera, flip?: boolean): void;
    // (undocumented)
    get shadingImpl(): WaterShaderImpl;
    set shadingImpl(val: WaterShaderImpl);
    // (undocumented)
    get speed(): number;
    set speed(val: number);
    // (undocumented)
    get tileSize(): number;
    set tileSize(val: number);
    // (undocumented)
    get waveImpl(): WaveGenerator;
    set waveImpl(val: WaveGenerator);
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// @public (undocumented)
export type WaterSetupUniformFunc = (this: WaterShaderImpl, scope: PBGlobalScope) => void;

// @public (undocumented)
export class WaterShaderImpl {
    constructor(setupUniformsFunc: WaterSetupUniformFunc, vertexFunc: WaterVertexFunc, shadingFunc: WaterShadingFunc);
    // (undocumented)
    getVertexNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, useComputeShader: boolean): PBShaderExp;
    // (undocumented)
    setupUniforms(scope: PBGlobalScope): void;
    // (undocumented)
    shading(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal: PBShaderExp, foamFactor: PBShaderExp, discardable: PBShaderExp, waveGenerator: WaveGenerator): PBShaderExp;
    // (undocumented)
    vertex(scope: PBInsideFunctionScope, pos: PBShaderExp, xz: PBShaderExp, waveGenerator: WaveGenerator): void;
}

// @public (undocumented)
export type WaterShadingFunc = (scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal: PBShaderExp, foamFactor: PBShaderExp, discardable: PBShaderExp, waveGenerator: WaveGenerator) => PBShaderExp;

// @public (undocumented)
export type WaterVertexFunc = (this: WaterShaderImpl, scope: PBInsideFunctionScope, pos: PBShaderExp, xz: PBShaderExp, waveGenerator: WaveGenerator) => void;

// @public (undocumented)
export abstract class WaveGenerator {
    // (undocumented)
    abstract applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    abstract calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): any;
    // (undocumented)
    abstract calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    // (undocumented)
    abstract calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    // (undocumented)
    abstract calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    abstract dispose(): void;
    // (undocumented)
    abstract getHash(device: AbstractDevice): string;
    // (undocumented)
    abstract isOk(device: AbstractDevice): boolean;
    // (undocumented)
    abstract setupUniforms(scope: PBGlobalScope): void;
    // (undocumented)
    abstract update(timeInSeconds: number): void;
}

// @public
export class WeightedBlendedOIT extends OIT {
    constructor();
    applyUniforms(ctx: DrawContext, bindGroup: BindGroup): void;
    begin(ctx: DrawContext): number;
    beginPass(ctx: DrawContext, pass: number): boolean;
    calculateHash(): string;
    dispose(): void;
    end(ctx: DrawContext): void;
    endPass(ctx: DrawContext, pass: number): void;
    getType(): string;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): void;
    setupFragmentOutput(scope: PBGlobalScope): void;
    supportDevice(deviceType: string): boolean;
    static readonly type = "wb";
}

// @public
export function worleyFBM(scope: PBInsideFunctionScope, p: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// @public
export function worleyNoise(scope: PBInsideFunctionScope, uv: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// Warning: (ae-forgotten-export) The symbol "XForm_base" needs to be exported by the entry point index.d.ts
//
// @public
export class XForm<T extends XForm<T> = XForm<any>> extends XForm_base {
    constructor();
    get children(): T[];
    // @internal (undocumented)
    protected _children: T[];
    getWorldPosition(): Vector3;
    get invWorldMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _invWorldMatrix: Matrix4x4;
    get localMatrix(): Matrix4x4;
    set localMatrix(matrix: Matrix4x4);
    // @internal (undocumented)
    protected _localMatrix: Matrix4x4;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    moveBy(delta: Vector3): this;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    otherToThis(other: XForm, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    otherToThis(other: XForm, v: Vector4, result?: Vector4): Vector4;
    get parent(): T;
    set parent(p: T);
    // @internal (undocumented)
    protected _parent: T;
    get position(): Vector3;
    set position(val: Vector3);
    // @internal (undocumented)
    protected _position: ObservableVector3;
    reparent(p?: T): this;
    get rotation(): Quaternion;
    set rotation(val: Quaternion);
    // @internal (undocumented)
    protected _rotation: ObservableQuaternion;
    get scale(): Vector3;
    set scale(val: Vector3);
    scaleBy(factor: Vector3): this;
    // @internal (undocumented)
    protected _scaling: ObservableVector3;
    setLocalTransform(matrix: Matrix4x4): this;
    // @internal (undocumented)
    protected _setParent(p: T): void;
    thisToOther(other: XForm, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToOther(other: XForm, v: Vector4, result?: Vector4): Vector4;
    thisToWorld(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToWorld(v: Vector4, result?: Vector4): Vector4;
    // @internal (undocumented)
    protected _tmpLocalMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _tmpWorldMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _transformChangeCallback: () => void;
    // @internal (undocumented)
    get transformTag(): number;
    // @internal (undocumented)
    protected _transformTag: number;
    get worldMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _worldMatrix: Matrix4x4;
    get worldMatrixDet(): number;
    // @internal (undocumented)
    protected _worldMatrixDet: number;
    worldToThis(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    worldToThis(v: Vector4, result?: Vector4): Vector4;
}

// Warnings were encountered during analysis:
//
// dist/index.d.ts:5714:9 - (ae-forgotten-export) The symbol "SkinnedBoundingBox" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
