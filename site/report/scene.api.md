## API Report File for "@zephyr3d/scene"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AABB } from '@zephyr3d/base';
import { AbstractDevice } from '@zephyr3d/device';
import { BaseTexture } from '@zephyr3d/device';
import { BindGroup } from '@zephyr3d/device';
import { BindGroupLayout } from '@zephyr3d/device';
import { ClipState } from '@zephyr3d/base';
import { Clonable } from '@zephyr3d/base';
import { ColorState } from '@zephyr3d/device';
import { CompareFunc } from '@zephyr3d/device';
import { CubeFace } from '@zephyr3d/base';
import { DecoderModule } from 'draco3d';
import { DeviceBackend } from '@zephyr3d/device';
import { FaceMode } from '@zephyr3d/device';
import { FrameBuffer } from '@zephyr3d/device';
import { Frustum } from '@zephyr3d/base';
import { GenericConstructor } from '@zephyr3d/base';
import { GPUDataBuffer } from '@zephyr3d/device';
import { GPUProgram } from '@zephyr3d/device';
import { HttpRequest } from '@zephyr3d/base';
import { IndexBuffer } from '@zephyr3d/device';
import { InterpolationMode } from '@zephyr3d/base';
import { Interpolator } from '@zephyr3d/base';
import { Matrix4x4 } from '@zephyr3d/base';
import { ObservableQuaternion } from '@zephyr3d/base';
import { ObservableVector3 } from '@zephyr3d/base';
import { PBFunctionScope } from '@zephyr3d/device';
import { PBGlobalScope } from '@zephyr3d/device';
import { PBInsideFunctionScope } from '@zephyr3d/device';
import { PBShaderExp } from '@zephyr3d/device';
import { Plane } from '@zephyr3d/base';
import { PrimitiveType } from '@zephyr3d/device';
import { ProgramBuilder } from '@zephyr3d/device';
import { Quaternion } from '@zephyr3d/base';
import { Ray } from '@zephyr3d/base';
import { RenderBundle } from '@zephyr3d/device';
import { RenderStateSet } from '@zephyr3d/device';
import { SamplerOptions } from '@zephyr3d/device';
import { ShaderTypeFunc } from '@zephyr3d/device';
import { StructuredBuffer } from '@zephyr3d/device';
import { Texture2D } from '@zephyr3d/device';
import { Texture2DArray } from '@zephyr3d/device';
import { TextureCube } from '@zephyr3d/device';
import { TextureFormat } from '@zephyr3d/device';
import { TextureSampler } from '@zephyr3d/device';
import { TextureType } from '@zephyr3d/device';
import { TypedArray } from '@zephyr3d/base';
import { Vector2 } from '@zephyr3d/base';
import { Vector3 } from '@zephyr3d/base';
import { Vector4 } from '@zephyr3d/base';
import { VertexAttribFormat } from '@zephyr3d/device';
import { VertexBufferInfo } from '@zephyr3d/device';
import { VertexLayout } from '@zephyr3d/device';
import { VertexLayoutOptions } from '@zephyr3d/device';
import { VertexSemantic } from '@zephyr3d/device';
import { VertexStepMode } from '@zephyr3d/device';
import * as _zephyr3d_base from '@zephyr3d/base';
import * as _zephyr3d_device from '@zephyr3d/device';

// @public
export class AABBTree {
    constructor();
    constructor(rhs: AABBTree);
    buildFromPrimitives(vertices: number[] | TypedArray, indices: number[] | TypedArray, primitiveType: PrimitiveType): void;
    // @internal (undocumented)
    _buildSubNodes(): void;
    getTopLevelAABB(): AABB;
    rayIntersectionDistance(ray: Ray): number;
    rayIntersectionTest(ray: Ray): boolean;
    transform(matrix: Matrix4x4): void;
    // @internal (undocumented)
    verify(): void;
}

// @public
export class AbstractPostEffect implements Disposable {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // @internal (undocumented)
    protected createRenderStates(device: AbstractDevice): RenderStateSet;
    // @internal (undocumented)
    protected createVertexLayout(device: AbstractDevice): VertexLayout;
    // @internal (undocumented)
    protected destroy(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    protected _disposed: boolean;
    protected drawFullscreenQuad(renderStateSet?: RenderStateSet): void;
    get enabled(): boolean;
    set enabled(val: boolean);
    // (undocumented)
    protected _enabled: boolean;
    // @internal (undocumented)
    static getDefaultRenderState(ctx: DrawContext, compareFunc: CompareFunc): any;
    get layer(): PostEffectLayer;
    // (undocumented)
    protected _layer: PostEffectLayer;
    needFlip(device: AbstractDevice): boolean;
    // (undocumented)
    protected passThrough(ctx: DrawContext, inputColorTexture: Texture2D, srgbOutput: boolean, renderStates?: RenderStateSet): void;
    requireDepthAttachment(ctx: DrawContext): boolean;
    requireLinearDepthTexture(ctx: DrawContext): boolean;
}

// @public
export class ABufferOIT implements OIT {
    constructor(numLayers?: number);
    applyUniforms(ctx: DrawContext, bindGroup: BindGroup): void;
    begin(ctx: DrawContext): number;
    beginPass(ctx: DrawContext, pass: number): boolean;
    calculateHash(): string;
    dispose(): void;
    get disposed(): boolean;
    end(ctx: DrawContext): void;
    endPass(ctx: DrawContext, pass: number): void;
    getType(): string;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): void;
    setupFragmentOutput(scope: PBGlobalScope): void;
    supportDevice(deviceType: string): boolean;
    static readonly type = "ab";
    // (undocumented)
    static readonly usePremultipliedAlpha = true;
    wantsPremultipliedAlpha(): boolean;
}

// @public (undocumented)
export function aerialPerspective(scope: PBInsideFunctionScope, f2UV: PBShaderExp, stParams: PBShaderExp, f3CameraPos: PBShaderExp, f3WorldPos: PBShaderExp, fAPDistance: PBShaderExp, f3Dim: PBShaderExp, f4Debug: PBShaderExp, texAerialPerspectiveLut: PBShaderExp): any;

// @public (undocumented)
export function aerialPerspectiveLut(scope: PBInsideFunctionScope, stParams: PBShaderExp, f2UV: PBShaderExp, f3VoxelDim: PBShaderExp, texTransmittanceLut: PBShaderExp, texMultiScatteringLut: PBShaderExp): any;

// @public
export class AnimationClip {
    constructor(name: string, animationSet: AnimationSet, embedded?: boolean);
    addSkeleton(skeleton: Skeleton): void;
    addTrack(target: object, track: AnimationTrack): this;
    get animationSet(): AnimationSet;
    // @internal (undocumented)
    protected _animationSet: AnimationSet;
    get autoPlay(): boolean;
    set autoPlay(val: boolean);
    // @internal (undocumented)
    protected _autoPlay: boolean;
    deleteTrack(track: AnimationTrack): this;
    dispose(): void;
    // @internal (undocumented)
    protected _duration: number;
    get embedded(): boolean;
    // @internal (undocumented)
    protected _embedded: boolean;
    get name(): string;
    // @internal (undocumented)
    protected _name: string;
    get skeletons(): Set<Skeleton>;
    // @internal (undocumented)
    protected _skeletons: Set<Skeleton>;
    get timeDuration(): number;
    set timeDuration(val: number);
    get tracks(): Map<object, AnimationTrack<unknown>[]>;
    // @internal (undocumented)
    protected _tracks: Map<object, AnimationTrack[]>;
    get weight(): number;
    set weight(val: number);
    // (undocumented)
    protected _weight: number;
}

// @public
export class AnimationSet implements Disposable {
    constructor(model: SceneNode);
    createAnimation(name: string, embedded?: boolean): AnimationClip;
    deleteAnimation(name: string): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    get(name: string): AnimationClip;
    getAnimationClip(name: string): AnimationClip | null;
    getAnimationNames(): string[];
    isPlayingAnimation(name?: string): boolean;
    get model(): SceneNode;
    get numAnimations(): number;
    playAnimation(name: string, options?: PlayAnimationOptions): void;
    setAnimationWeight(name: string, weight: number): void;
    stopAnimation(name: string, options?: StopAnimationOptions): void;
    update(deltaInSeconds: number): void;
}

// @public
export abstract class AnimationTrack<StateType = unknown> {
    constructor(embedded?: boolean);
    get animation(): AnimationClip;
    set animation(ani: AnimationClip);
    // @internal (undocumented)
    protected _animation: AnimationClip;
    abstract applyState(target: object, state: StateType): any;
    abstract calculateState(target: object, currentTime: number): StateType;
    get embedded(): boolean;
    // @internal (undocumented)
    protected _embedded: boolean;
    abstract getBlendId(): unknown;
    abstract getDuration(): number;
    abstract mixState(a: StateType, b: StateType, t: number): StateType;
    get name(): string;
    set name(val: string);
    // @internal (undocumented)
    protected _name: string;
    reset(target: object): void;
}

// Warning: (ae-forgotten-export) The symbol "Application_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Application extends Application_base {
    constructor(opt: Partial<AppOptions>);
    get device(): AbstractDevice;
    get deviceType(): string;
    focus(): void;
    frame(): void;
    get inputManager(): InputManager;
    static get instance(): Application;
    log(text: string, mode?: LogMode): void;
    get logger(): Logger;
    set logger(val: Logger);
    get options(): AppOptions;
    ready(): Promise<void>;
    run(): void;
    stop(): void;
    get timeElapsedInSeconds(): number;
}

// @public
export function applyMaterialMixins<M extends ((target: any) => any)[], T>(target: T, ...mixins: M): ExtractMixinType<M> & T;

// @public
export type AppOptions = {
    canvas: HTMLCanvasElement;
    backend: DeviceBackend;
    enableMSAA?: boolean;
    pixelRatio?: number;
};

// @public
export interface AssetAnimationData {
    // (undocumented)
    name: string;
    // (undocumented)
    nodes: AssetHierarchyNode[];
    // (undocumented)
    skeletons: AssetSkeleton[];
    // (undocumented)
    tracks: AssetAnimationTrack[];
}

// @public
export interface AssetAnimationTrack {
    // (undocumented)
    defaultMorphWeights?: number[];
    // (undocumented)
    interpolator: Interpolator;
    // (undocumented)
    node: AssetHierarchyNode;
    // (undocumented)
    type: 'translation' | 'scale' | 'rotation' | 'weights';
}

// @public
export class AssetHierarchyNode extends NamedObject {
    constructor(name: string, parent?: AssetHierarchyNode);
    addChild(child: AssetHierarchyNode): void;
    attachToSkeleton(skeleton: AssetSkeleton, index: number): void;
    get children(): AssetHierarchyNode[];
    // @internal (undocumented)
    computeTransforms(parentTransform: Matrix4x4): void;
    get instances(): {
        t: Vector3;
        s: Vector3;
        r: Quaternion;
    }[];
    get matrix(): Matrix4x4;
    get mesh(): AssetMeshData;
    set mesh(data: AssetMeshData);
    get meshAttached(): boolean;
    get parent(): AssetHierarchyNode;
    get position(): Vector3;
    set position(val: Vector3);
    removeChild(child: AssetHierarchyNode): void;
    get rotation(): Quaternion;
    set rotation(val: Quaternion);
    get scaling(): Vector3;
    set scaling(val: Vector3);
    get skeleton(): AssetSkeleton;
    set skeleton(skeleton: AssetSkeleton);
    get skeletonAttached(): Set<AssetSkeleton>;
    get weights(): number[];
    set weights(val: number[]);
    get worldMatrix(): Matrix4x4;
}

// @public
export interface AssetInfo {
    id: string;
    name: string;
    path: string;
    textureOptions?: TextureFetchOptions<any>;
    type: AssetType;
}

// @public
export class AssetManager {
    constructor();
    // Warning: (ae-forgotten-export) The symbol "AbstractModelLoader" needs to be exported by the entry point index.d.ts
    static addModelLoader(loader: AbstractModelLoader): void;
    // Warning: (ae-forgotten-export) The symbol "AbstractTextureLoader" needs to be exported by the entry point index.d.ts
    static addTextureLoader(loader: AbstractTextureLoader): void;
    // @internal (undocumented)
    doLoadTexture(loader: AbstractTextureLoader, mimeType: string, data: ArrayBuffer, srgb: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture): Promise<BaseTexture>;
    fetchBinaryData(url: string, postProcess?: (data: ArrayBuffer) => ArrayBuffer, httpRequest?: HttpRequest): Promise<ArrayBuffer>;
    fetchBuiltinTexture<T extends BaseTexture>(name: string, texture?: T): T;
    fetchJsonData<T = any>(url: string, postProcess?: (json: T) => T, httpRequest?: HttpRequest): Promise<T>;
    fetchModel(scene: Scene, url: string, options?: ModelFetchOptions, httpRequest?: HttpRequest): Promise<ModelInfo>;
    // @internal (undocumented)
    fetchModelData(url: string, options?: ModelFetchOptions, httpRequest?: HttpRequest): Promise<SharedModel>;
    fetchTextData(url: string, postProcess?: (text: string) => string, httpRequest?: HttpRequest): Promise<string>;
    fetchTexture<T extends BaseTexture>(url: string, options?: TextureFetchOptions<T>, httpRequest?: HttpRequest): Promise<T>;
    get httpRequest(): HttpRequest;
    // @internal (undocumented)
    loadBinaryData(url: string, postProcess?: (data: ArrayBuffer) => ArrayBuffer, httpRequest?: HttpRequest): Promise<ArrayBuffer>;
    // @internal (undocumented)
    loadJsonData(url: string, postProcess?: (json: any) => any, httpRequest?: HttpRequest): Promise<string>;
    // @internal (undocumented)
    loadModel(url: string, options?: ModelFetchOptions, httpRequest?: HttpRequest): Promise<SharedModel>;
    // @internal (undocumented)
    loadTextData(url: string, postProcess?: (text: string) => string, httpRequest?: HttpRequest): Promise<string>;
    // @internal (undocumented)
    loadTexture(url: string, mimeType?: string, srgb?: boolean, samplerOptions?: SamplerOptions, texture?: BaseTexture, httpRequest?: HttpRequest): Promise<BaseTexture>;
    static setBuiltinTextureLoader(name: string, loader: (assetManager: AssetManager) => BaseTexture): void;
}

// @public
export interface AssetMaterial {
    // (undocumented)
    common: AssetMaterialCommon;
    // (undocumented)
    type: string;
}

// @public
export interface AssetMaterialClearcoat {
    // (undocumented)
    clearCoatFactor?: number;
    // (undocumented)
    clearCoatIntensityMap?: MaterialTextureInfo;
    // (undocumented)
    clearCoatNormalMap?: MaterialTextureInfo;
    // (undocumented)
    clearCoatRoughnessFactor?: number;
    // (undocumented)
    clearCoatRoughnessMap?: MaterialTextureInfo;
}

// @public
export interface AssetMaterialCommon {
    // (undocumented)
    alphaCutoff?: number;
    // (undocumented)
    alphaMode?: 'blend' | 'mask';
    // (undocumented)
    bumpScale?: number;
    // (undocumented)
    doubleSided?: boolean;
    // (undocumented)
    emissiveColor?: Vector3;
    // (undocumented)
    emissiveMap?: MaterialTextureInfo;
    // (undocumented)
    emissiveStrength?: number;
    // (undocumented)
    normalMap?: MaterialTextureInfo;
    // (undocumented)
    occlusionMap?: MaterialTextureInfo;
    // (undocumented)
    occlusionStrength?: number;
    // (undocumented)
    useTangent?: boolean;
    // (undocumented)
    vertexColor?: boolean;
    // (undocumented)
    vertexNormal?: boolean;
}

// @public
export interface AssetMaterialIridescence {
    // (undocumented)
    iridescenceFactor?: number;
    // (undocumented)
    iridescenceIor?: number;
    // (undocumented)
    iridescenceMap?: MaterialTextureInfo;
    // (undocumented)
    iridescenceThicknessMap?: MaterialTextureInfo;
    // (undocumented)
    iridescenceThicknessMaximum?: number;
    // (undocumented)
    iridescenceThicknessMinimum?: number;
}

// @public
export interface AssetMaterialSheen {
    // (undocumented)
    sheenColorFactor?: Vector3;
    // (undocumented)
    sheenColorMap?: MaterialTextureInfo;
    // (undocumented)
    sheenRoughnessFactor?: number;
    // (undocumented)
    sheenRoughnessMap?: MaterialTextureInfo;
}

// @public
export interface AssetMaterialTransmission {
    // (undocumented)
    attenuationColor?: Vector3;
    // (undocumented)
    attenuationDistance?: number;
    // (undocumented)
    thicknessFactor?: number;
    // (undocumented)
    thicknessMap?: MaterialTextureInfo;
    // (undocumented)
    transmissionFactor?: number;
    // (undocumented)
    transmissionMap?: MaterialTextureInfo;
}

// @public
export interface AssetMeshData {
    // (undocumented)
    morphWeights?: number[];
    // (undocumented)
    subMeshes: AssetSubMeshData[];
}

// @public
export interface AssetPBRMaterialCommon extends AssetUnlitMaterial {
    // (undocumented)
    ior?: number;
}

// @public
export interface AssetPBRMaterialMR extends AssetPBRMaterialCommon {
    // (undocumented)
    clearcoat?: AssetMaterialClearcoat;
    // (undocumented)
    iridescence?: AssetMaterialIridescence;
    // (undocumented)
    metallic?: number;
    // (undocumented)
    metallicIndex?: number;
    // (undocumented)
    metallicMap?: MaterialTextureInfo;
    // (undocumented)
    roughness?: number;
    // (undocumented)
    roughnessIndex?: number;
    // (undocumented)
    sheen?: AssetMaterialSheen;
    // (undocumented)
    specularColorMap?: MaterialTextureInfo;
    // (undocumented)
    specularFactor?: Vector4;
    // (undocumented)
    specularMap?: MaterialTextureInfo;
    // (undocumented)
    transmission?: AssetMaterialTransmission;
}

// @public
export interface AssetPBRMaterialSG extends AssetPBRMaterialCommon {
    // (undocumented)
    glossness?: number;
    // (undocumented)
    specular?: Vector3;
    // (undocumented)
    specularGlossnessMap?: MaterialTextureInfo;
}

// @public
export class AssetRegistry {
    constructor(baseUrl?: string);
    // (undocumented)
    get assetManager(): AssetManager;
    // (undocumented)
    deserialize(json: any): void;
    // (undocumented)
    protected doFetchBinary(name: string, request?: HttpRequest): Promise<ArrayBuffer>;
    // (undocumented)
    protected doFetchModel(name: string, scene: Scene, options?: ModelFetchOptions, request?: HttpRequest): Promise<ModelInfo>;
    // (undocumented)
    protected doFetchTexture<T extends Texture2D | TextureCube>(name: string, options?: TextureFetchOptions<T>, request?: HttpRequest): Promise<T>;
    // (undocumented)
    fetchBinary(id: string, request?: HttpRequest): Promise<ArrayBuffer>;
    // (undocumented)
    fetchModel(id: string, scene: Scene, options?: ModelFetchOptions, request?: HttpRequest): Promise<ModelInfo>;
    // (undocumented)
    fetchTexture<T extends Texture2D | TextureCube>(id: string, options?: TextureFetchOptions<T>, request?: HttpRequest): Promise<T>;
    // (undocumented)
    getAssetId(asset: any): string;
    // (undocumented)
    getAssetInfo(id: string): AssetInfo;
    // (undocumented)
    loadFromURL(url: string): Promise<void>;
    // (undocumented)
    putEmbeddedAssets(assets: EmbeddedAssetInfo[]): Promise<void>;
    // (undocumented)
    registerAsset(id: string, type: AssetType, path: string, name: string): void;
    // (undocumented)
    renameAsset(id: string, name: string): void;
    // (undocumented)
    serialize(): {
        assets: Record<string, {
            id: string;
            name: string;
            type: AssetType;
            path: string;
        }>;
    };
}

// @public
export interface AssetRotationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Quaternion[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export interface AssetScaleTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Vector3[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export class AssetScene extends NamedObject {
    constructor(name: string);
    rootNodes: AssetHierarchyNode[];
}

// @public
export interface AssetSkeletalAnimationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, {
        translation: Vector3;
        rotation: Quaternion;
        scale: Vector3;
    }[]>;
    // (undocumented)
    skeleton: AssetSkeleton;
}

// @public
export class AssetSkeleton extends NamedObject {
    constructor(name: string);
    addJoint(joint: AssetHierarchyNode, inverseBindMatrix: Matrix4x4): void;
    bindPoseMatrices: Matrix4x4[];
    inverseBindMatrices: Matrix4x4[];
    joints: AssetHierarchyNode[];
    pivot: AssetHierarchyNode;
}

// @public
export interface AssetSubMeshData {
    // (undocumented)
    material: DRef<MeshMaterial>;
    // (undocumented)
    mesh?: Mesh;
    // (undocumented)
    morphAttribCount?: number;
    // (undocumented)
    name: string;
    // (undocumented)
    numTargets: number;
    // (undocumented)
    primitive: DRef<Primitive>;
    // (undocumented)
    rawBlendIndices: TypedArray;
    // (undocumented)
    rawJointWeights: TypedArray;
    // (undocumented)
    rawPositions: Float32Array;
    // (undocumented)
    targetBox?: BoundingBox[];
    // (undocumented)
    targets?: Partial<Record<number, {
        numComponents: number;
        data: Float32Array[];
    }>>;
}

// @public
export interface AssetTranslationTrack extends AssetAnimationTrack {
    // (undocumented)
    keyFrames: Record<number, Vector3[]>;
    // (undocumented)
    nodes: number[];
}

// @public
export type AssetType = 'model' | 'texture' | 'binary';

// @public
export interface AssetUnlitMaterial extends AssetMaterial {
    // (undocumented)
    diffuse?: Vector4;
    // (undocumented)
    diffuseMap?: MaterialTextureInfo;
}

// @public (undocumented)
export type AtmosphereParams = {
    plantRadius: number;
    atmosphereHeight: number;
    rayleighScatteringHeight: number;
    mieScatteringHeight: number;
    mieAnstropy: number;
    ozoneCenter: number;
    ozoneWidth: number;
    apDistance: number;
    cameraWorldMatrix: Matrix4x4;
    lightDir: Vector3;
    lightColor: Vector4;
    cameraAspect: number;
    cameraHeightScale: number;
};

// @public
export class BaseCameraController {
    constructor();
    // @internal (undocumented)
    _getCamera(): Camera;
    // (undocumented)
    lookAt(from: Vector3, to: Vector3, up: Vector3): void;
    // @internal (undocumented)
    onKeyDown(evt: KeyboardEvent): boolean;
    protected _onKeyDown(evt: KeyboardEvent): boolean;
    // @internal (undocumented)
    onKeyUp(evt: KeyboardEvent): boolean;
    protected _onKeyUp(evt: KeyboardEvent): boolean;
    // @internal (undocumented)
    onMouseDown(evt: PointerEvent): boolean;
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseMove(evt: PointerEvent): boolean;
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseUp(evt: PointerEvent): boolean;
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @internal (undocumented)
    onMouseWheel(evt: WheelEvent): boolean;
    protected _onMouseWheel(evt: WheelEvent): boolean;
    reset(): void;
    // @internal (undocumented)
    _setCamera(camera: Camera): void;
    update(): void;
}

// @public
export abstract class BaseLight extends GraphNode {
    constructor(scene: Scene, type: number);
    // @internal (undocumented)
    abstract computeUniforms(): void;
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    get diffuseAndIntensity(): Vector4;
    // @internal (undocumented)
    protected _diffuseIntensity: Vector4;
    get directionAndCutoff(): Vector4;
    // @internal (undocumented)
    protected _directionCutoff: Vector4;
    get intensity(): number;
    set intensity(val: number);
    // @internal (undocumented)
    protected _intensity: number;
    // @internal (undocumented)
    invalidateUniforms(): void;
    isDirectionLight(): this is DirectionalLight;
    isLight(): this is BaseLight;
    isPointLight(): this is PointLight;
    isPunctualLight(): this is PunctualLight;
    isSpotLight(): this is SpotLight;
    get lightType(): number;
    get positionAndRange(): Vector4;
    // @internal (undocumented)
    protected _positionRange: Vector4;
    setIntensity(val: number): this;
    // @internal (undocumented)
    protected _type: number;
    get viewMatrix(): Matrix4x4;
}

// @public
export interface BatchDrawable extends Drawable {
    // @internal
    applyInstanceOffsetAndStride(renderQueue: RenderQueue, stride: number, offset: number): void;
    // @internal
    applyMaterialUniforms(instanceInfo: DrawableInstanceInfo): any;
    // @internal
    applyMaterialUniformsAll(): any;
    // @internal
    getInstanceId(renderPass: RenderPass): string;
    // @internal
    getInstanceUniforms(): Float32Array;
}

// @public
export class BatchGroup extends GraphNode implements NodeClonable<BatchGroup> {
    constructor(scene: Scene);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): BatchGroup;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    cull(cullVisitor: CullVisitor): void;
    getName(): string;
    invalidate(): void;
    isBatchGroup(): this is BatchGroup;
    // @internal (undocumented)
    protected _onAttached(): void;
    // @internal (undocumented)
    protected _onDetached(): void;
    // @internal (undocumented)
    setBoundingVolume(bv: BoundingVolume): void;
}

// @public
export type BlendMode = 'none' | 'blend' | 'additive';

// Warning: (ae-forgotten-export) The symbol "BlinnMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BlinnMaterial extends BlinnMaterial_base implements Clonable<BlinnMaterial> {
    constructor();
    // (undocumented)
    clone(): BlinnMaterial;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// @public
export abstract class Blitter {
    constructor();
    blit(source: Texture2D, dest: FrameBuffer, sampler?: TextureSampler): void;
    blit(source: Texture2D, dest: Texture2D, sampler?: TextureSampler): void;
    blit(source: Texture2D, dest: Texture2DArray, layer: number, sampler?: TextureSampler): void;
    blit(source: Texture2DArray, dest: Texture2DArray, sampler?: TextureSampler): void;
    blit(source: Texture2DArray, dest: FrameBuffer, layer: number, sampler?: TextureSampler): void;
    blit(source: Texture2DArray, dest: Texture2D, layer: number, sampler?: TextureSampler): void;
    blit(source: TextureCube, dest: TextureCube, sampler?: TextureSampler): void;
    blit(source: TextureCube, dest: FrameBuffer, face: number, sampler?: TextureSampler): void;
    blit(source: TextureCube, dest: Texture2D, face: number, sampler?: TextureSampler): void;
    // (undocumented)
    blit(source: BaseTexture, dest: BaseTexture | FrameBuffer, layer?: number | TextureSampler, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blit2D(source: Texture2D, dest: FrameBuffer, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blit2DArray(source: Texture2DArray, dest: FrameBuffer, layer: number, sampler?: TextureSampler): void;
    // @internal (undocumented)
    protected blitCubeMap(source: TextureCube, dest: FrameBuffer, face: CubeFace, sampler?: TextureSampler): void;
    protected abstract calcHash(): string;
    get destRect(): number[];
    set destRect(val: number[]);
    // @internal (undocumented)
    protected _destRect: number[];
    abstract filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampeType: 'float' | 'int' | 'uint' | 'depth'): PBShaderExp;
    // @internal (undocumented)
    protected _flip: boolean;
    get hash(): string;
    // @internal (undocumented)
    protected _hash: string;
    invalidateHash(): void;
    // @internal (undocumented)
    protected _offsetParams: Vector4;
    readTexel(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, uv: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint' | 'depth'): PBShaderExp;
    get renderStates(): RenderStateSet;
    set renderStates(rs: RenderStateSet);
    // @internal (undocumented)
    protected _renderStates: RenderStateSet;
    get scissor(): number[];
    set scissor(val: number[]);
    // @internal (undocumented)
    protected _scissor: number[];
    setUniforms(bindGroup: BindGroup, sourceTex: BaseTexture): void;
    setup(scope: PBGlobalScope, type: BlitType): void;
    get srgbOut(): boolean;
    set srgbOut(val: boolean);
    // @internal (undocumented)
    protected _srgbOut: boolean;
    get viewport(): number[];
    set viewport(val: number[]);
    // @internal (undocumented)
    protected _viewport: number[];
    writeTexel(scope: PBInsideFunctionScope, type: BlitType, uv: PBShaderExp, texel: PBShaderExp): PBShaderExp;
}

// @public
export type BlitType = '2d' | '2d-array' | 'cube';

// @public
export class Bloom extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // (undocumented)
    static readonly className: "Bloom";
    // @internal (undocumented)
    downsample(device: AbstractDevice, inputColorTexture: Texture2D, textures: Texture2D[]): void;
    get downsampleLimit(): number;
    set downsampleLimit(val: number);
    // @internal (undocumented)
    finalCompose(device: AbstractDevice, srcTexture: Texture2D, bloomTexture: Texture2D): void;
    get intensity(): number;
    set intensity(val: number);
    get maxDownsampleLevel(): number;
    set maxDownsampleLevel(val: number);
    // @internal (undocumented)
    prefilter(device: AbstractDevice, srcTexture: Texture2D, rt: Texture2D): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get threshold(): number;
    set threshold(val: number);
    get thresholdKnee(): number;
    set thresholdKnee(val: number);
    // @internal (undocumented)
    upsample(device: AbstractDevice, textures: Texture2D[]): void;
}

// @public
export class BoundingBox extends AABB implements BoundingVolume {
    constructor();
    constructor(box: AABB);
    constructor(minPoint: Vector3, maxPoint: Vector3);
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export interface BoundingVolume {
    behindPlane(plane: Plane): boolean;
    clone(): BoundingVolume;
    outsideFrustum(frustum: Frustum | Matrix4x4): boolean;
    toAABB(): AABB;
    transform(matrix: Matrix4x4): BoundingVolume;
}

// @public
export interface BoxCreationOptions extends ShapeCreationOptions {
    anchor?: number;
    anchorX?: number;
    anchorY?: number;
    anchorZ?: number;
    size?: number;
    sizeX?: number;
    sizeY?: number;
    sizeZ?: number;
}

// @public
export class BoxFilterBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernelSize: number, blurSize: number);
    // @internal (undocumented)
    protected _blurSize: number;
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    // @internal (undocumented)
    protected _kernelSize: number;
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // @internal (undocumented)
    protected _logSpace: boolean;
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @internal (undocumented)
    protected _logSpaceMultiplier: number;
    // @internal (undocumented)
    protected _phase: 'horizonal' | 'vertical';
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
    // @internal (undocumented)
    protected _sigma: number;
}

// @public
export class BoxFrameShape extends Shape<BoxCreationOptions> implements Clonable<BoxFrameShape> {
    constructor(options?: BoxCreationOptions);
    // (undocumented)
    clone(): BoxFrameShape;
    // (undocumented)
    static _defaultOptions: {
        size: number;
        anchor: number;
        needNormal: boolean;
        needUV: boolean;
    };
    static generateData(options: BoxCreationOptions, vertices: number[], normals: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): PrimitiveType;
    // (undocumented)
    get type(): string;
}

// @public
export class BoxShape extends Shape<BoxCreationOptions> implements Clonable<BoxShape> {
    constructor(options?: BoxCreationOptions);
    // (undocumented)
    clone(): BoxShape;
    // (undocumented)
    static _defaultOptions: {
        size: number;
        anchor: number;
        needNormal: boolean;
        needUV: boolean;
    };
    get depth(): number;
    static generateData(options: BoxCreationOptions, vertices: number[], normals: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): PrimitiveType;
    get height(): number;
    // (undocumented)
    get type(): string;
    get width(): number;
}

// @public
export const BUILTIN_ASSET_TEST_CUBEMAP = "TEST_Cubemap";

// @public
export const BUILTIN_ASSET_TEXTURE_SHEEN_LUT = "LUT_Sheen";

// Warning: (ae-internal-missing-underscore) The name "CachedBindGroup" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type CachedBindGroup = {
    bindGroup: BindGroup;
    buffer: Float32Array;
    offset: number;
    dirty: boolean;
};

// @public
export class Camera extends SceneNode implements NodeClonable<Camera> {
    constructor(scene: Scene, projectionMatrix?: Matrix4x4);
    get bloom(): boolean;
    set bloom(val: boolean);
    // @internal (undocumented)
    protected _bloom: boolean;
    get bloomDownsampleLimit(): number;
    set bloomDownsampleLimit(val: number);
    // @internal (undocumented)
    protected _bloomDownsampleLimit: number;
    get bloomIntensity(): number;
    set bloomIntensity(val: number);
    // @internal (undocumented)
    protected _bloomIntensity: number;
    get bloomMaxDownsampleLevels(): number;
    set bloomMaxDownsampleLevels(val: number);
    // @internal (undocumented)
    protected _bloomMaxDownsampleLevels: number;
    get bloomThreshold(): number;
    set bloomThreshold(val: number);
    // @internal (undocumented)
    protected _bloomThreshold: number;
    get bloomThresholdKnee(): number;
    set bloomThresholdKnee(val: number);
    // @internal (undocumented)
    protected _bloomThresholdKnee: number;
    get clearColor(): Vector4;
    set clearColor(val: Vector4);
    // @internal (undocumented)
    protected _clearColor: Vector4;
    clearHistoryData(): void;
    get clipMask(): number;
    set clipMask(val: number);
    // @internal (undocumented)
    protected _clipMask: number;
    get clipPlane(): Plane;
    set clipPlane(plane: Plane);
    // @internal (undocumented)
    protected _clipPlane: Plane;
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): Camera;
    get commandBufferReuse(): boolean;
    set commandBufferReuse(val: boolean);
    // @internal (undocumented)
    protected _commandBufferReuse: boolean;
    get compositor(): Compositor;
    // @internal (undocumented)
    protected _compositor: Compositor;
    // @internal (undocumented)
    protected _compute(): void;
    // @internal (undocumented)
    protected _computeProj(): void;
    constructRay(x: number, y: number): Ray;
    get controller(): BaseCameraController;
    set controller(controller: BaseCameraController);
    // @internal (undocumented)
    protected _controller: BaseCameraController;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    get depthPrePass(): boolean;
    set depthPrePass(val: boolean);
    // @internal (undocumented)
    protected _depthPrePass: boolean;
    // @internal (undocumented)
    protected _dirty: boolean;
    dispose(): void;
    get frustum(): Frustum;
    // @internal (undocumented)
    protected _frustum: Frustum;
    // @internal (undocumented)
    protected _frustumV: Frustum;
    // (undocumented)
    get frustumViewSpace(): Frustum;
    get FXAA(): boolean;
    set FXAA(val: boolean);
    // @internal (undocumented)
    protected _FXAA: boolean;
    getAspect(): number;
    getFarPlane(): number;
    getFOV(): number;
    getHistoryData(): CameraHistoryData;
    getInvProjectionMatrix(): Matrix4x4;
    getNearPlane(): number;
    // @internal (undocumented)
    getPickPosX(): number;
    // @internal (undocumented)
    getPickPosY(): number;
    // @internal (undocumented)
    getPickResultResolveFunc(): (result: PickResult) => void;
    getProjectionMatrix(): Matrix4x4;
    // (undocumented)
    getRotationMatrix(): Matrix4x4;
    getTanHalfFovy(): number;
    handleEvent(ev: Event, type?: string): boolean;
    get HiZ(): boolean;
    set HiZ(val: boolean);
    // @internal (undocumented)
    protected _HiZ: boolean;
    // @internal (undocumented)
    protected _invalidate(projectMatrixChanged: boolean): void;
    // @internal (undocumented)
    protected _invProjMatrix: Matrix4x4;
    get invViewProjectionMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _invViewProjMatrix: Matrix4x4;
    isCamera(): this is Camera;
    isOrtho(): boolean;
    isPerspective(): boolean;
    // @internal (undocumented)
    get jitteredInvVPMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _jitteredInvVPMatrix: Matrix4x4;
    // @internal (undocumented)
    get jitteredVPMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _jitteredVPMatrix: Matrix4x4;
    // @internal (undocumented)
    get jitterValue(): Vector2;
    // @internal (undocumented)
    protected _jitterValue: Vector2;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    lookAtCubeFace(face: CubeFace, position?: Vector3): this;
    get motionBlur(): boolean;
    set motionBlur(val: boolean);
    // @internal (undocumented)
    protected _motionBlur: boolean;
    get motionBlurStrength(): number;
    set motionBlurStrength(val: number);
    // @internal (undocumented)
    protected _motionBlurStrength: number;
    get oit(): OIT;
    set oit(val: OIT);
    // @internal (undocumented)
    protected _oit: DRef<OIT>;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    // (undocumented)
    pickAsync(posX: number, posY: number): Promise<PickResult>;
    // @internal (undocumented)
    protected _pickPosX: number;
    // @internal (undocumented)
    protected _pickPosY: number;
    // @internal (undocumented)
    protected _pickResult: PickResult;
    // @internal (undocumented)
    protected _pickResultPromise: Promise<PickResult>;
    // @internal (undocumented)
    protected _pickResultResolve: (result: PickResult) => void;
    // @internal (undocumented)
    protected _postEffectBloom: DRef<Bloom>;
    // @internal (undocumented)
    protected _postEffectFXAA: DRef<FXAA>;
    // Warning: (ae-forgotten-export) The symbol "MotionBlur" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    protected _postEffectMotionBlur: DRef<MotionBlur>;
    // @internal (undocumented)
    protected _postEffectSSAO: DRef<SAO>;
    // Warning: (ae-forgotten-export) The symbol "SSR" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    protected _postEffectSSR: DRef<SSR>;
    // @internal (undocumented)
    protected _postEffectTAA: DRef<TAA>;
    // @internal (undocumented)
    protected _postEffectTonemap: DRef<Tonemap>;
    // @internal (undocumented)
    get prevJitteredVPMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _prevJitteredVPMatrix: Matrix4x4;
    // @internal (undocumented)
    get prevJitterValue(): Vector2;
    // @internal (undocumented)
    protected _prevJitterValue: Vector2;
    // @internal (undocumented)
    get prevPosition(): Vector3;
    // @internal (undocumented)
    protected _prevPosition: Vector3;
    // @internal (undocumented)
    get prevVPMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _prevVPMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _projMatrix: Matrix4x4;
    render(scene: Scene): void;
    resetController(): void;
    // @internal (undocumented)
    protected _rotationMatrix: Matrix4x4;
    get scissor(): number[];
    set scissor(rect: number[]);
    // @internal (undocumented)
    protected _scissor: number[];
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get SSAO(): boolean;
    set SSAO(val: boolean);
    // @internal (undocumented)
    protected _SSAO: boolean;
    get SSAOBias(): number;
    set SSAOBias(val: number);
    // @internal (undocumented)
    protected _SSAOBias: number;
    get SSAOBlurDepthCutoff(): number;
    set SSAOBlurDepthCutoff(val: number);
    // @internal (undocumented)
    protected _SSAOBlurDepthCutoff: number;
    get SSAOIntensity(): number;
    set SSAOIntensity(val: number);
    // @internal (undocumented)
    protected _SSAOIntensity: number;
    get SSAORadius(): number;
    set SSAORadius(val: number);
    // @internal (undocumented)
    protected _SSAORadius: number;
    get SSAOScale(): number;
    set SSAOScale(val: number);
    // @internal (undocumented)
    protected _SSAOScale: number;
    get SSR(): boolean;
    set SSR(val: boolean);
    // @internal (undocumented)
    protected _SSR: boolean;
    get ssrBlurDepthCutoff(): number;
    set ssrBlurDepthCutoff(val: number);
    // @internal (undocumented)
    protected _ssrBlurDepthCutoff: number;
    get ssrBlurKernelSize(): number;
    set ssrBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _ssrBlurKernelSize: number;
    // @internal (undocumented)
    protected _ssrBlurriness: number;
    get ssrBlurScale(): number;
    set ssrBlurScale(val: number);
    get ssrBlurStdDev(): number;
    set ssrBlurStdDev(val: number);
    // @internal (undocumented)
    protected _ssrBlurStdDev: number;
    get ssrCalcThickness(): boolean;
    set ssrCalcThickness(val: boolean);
    // @internal (undocumented)
    protected _ssrCalcThickness: boolean;
    get ssrIterations(): number;
    set ssrIterations(val: number);
    get ssrMaxDistance(): number;
    set ssrMaxDistance(val: number);
    get ssrMaxRoughness(): number;
    set ssrMaxRoughness(val: number);
    // @internal (undocumented)
    protected _ssrMaxRoughness: number;
    // @internal (undocumented)
    get ssrParams(): Vector4;
    // @internal (undocumented)
    protected _ssrParams: Vector4;
    get ssrRoughnessFactor(): number;
    set ssrRoughnessFactor(val: number);
    // @internal (undocumented)
    protected _ssrRoughnessFactor: number;
    get ssrStride(): number;
    set ssrStride(val: number);
    // @internal (undocumented)
    protected _ssrStride: number;
    get ssrThickness(): number;
    set ssrThickness(val: number);
    get TAA(): boolean;
    set TAA(val: boolean);
    // @internal (undocumented)
    protected _TAA: boolean;
    get TAABlendFactor(): number;
    set TAABlendFactor(val: number);
    // @internal (undocumented)
    protected _TAABlendFactor: number;
    get TAADebug(): number;
    set TAADebug(val: number);
    // @internal (undocumented)
    protected _TAADebug: number;
    get toneMap(): boolean;
    set toneMap(val: boolean);
    // @internal (undocumented)
    protected _toneMap: boolean;
    get toneMapExposure(): number;
    set toneMapExposure(val: number);
    // @internal (undocumented)
    protected _tonemapExposure: number;
    updateController(): void;
    get viewMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _viewMatrix: Matrix4x4;
    get viewport(): number[];
    set viewport(rect: number[]);
    // @internal (undocumented)
    protected _viewport: number[];
    // (undocumented)
    get viewProjectionMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _viewProjMatrix: Matrix4x4;
}

// @public (undocumented)
export const CAMERA_POS_Y = 1;

// @public
export type CameraHistoryData = {
    prevColorTex: BaseTexture;
    prevMotionVectorTex: BaseTexture;
};

// Warning: (ae-internal-missing-underscore) The name "Clipmap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Clipmap {
    constructor(resolution: number, extraInstanceBuffers: VertexAttribFormat[], maxMipLevels?: number);
    // (undocumented)
    calcLevelAABB(camera: Camera, minMaxWorldPos: Vector4, gridScale: number): AABB[];
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(context: ClipmapDrawContext): number;
    // (undocumented)
    gather(context: ClipmapGatherContext): PrimitiveInstanceInfo[];
    // (undocumented)
    generateCrossMesh(): void;
    // (undocumented)
    generateFillerMesh(): void;
    // (undocumented)
    generateSeamMesh(): void;
    // (undocumented)
    generateTileMesh(): void;
    // (undocumented)
    generateTrimMesh(): void;
    // (undocumented)
    get tileResolution(): number;
    set tileResolution(val: number);
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// Warning: (ae-internal-missing-underscore) The name "ClipmapDrawContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ClipmapDrawContext extends ClipmapGatherContext {
    // (undocumented)
    drawPrimitive(prim: Primitive, rotation: number, offset: Vector2, scale: number, gridScale: number, level: number): any;
}

// Warning: (ae-internal-missing-underscore) The name "ClipmapGatherContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ClipmapGatherContext {
    // (undocumented)
    calcAABB(userData: unknown, minX: number, maxX: number, minZ: number, maxZ: number, outAABB: AABB, level: number): any;
    // (undocumented)
    camera: Camera;
    // (undocumented)
    gridScale: number;
    // (undocumented)
    minMaxWorldPos: Vector4;
    // (undocumented)
    userData: unknown;
}

// Warning: (ae-forgotten-export) The symbol "ClipmapTerrain_base" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class ClipmapTerrain extends ClipmapTerrain_base implements Drawable, NodeClonable<ClipmapTerrain> {
    constructor(scene: Scene, sizeX?: number, sizeZ?: number, clipMapTileSize?: number);
    // (undocumented)
    calculateLocalTransform(outMatrix: Matrix4x4): void;
    // (undocumented)
    calculateWorldTransform(outMatrix: Matrix4x4): void;
    get castShadow(): boolean;
    set castShadow(val: boolean);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): ClipmapTerrain;
    computeBoundingVolume(): BoundingVolume;
    computeWorldBoundingVolume(): BoundingVolume;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    // (undocumented)
    createHeightMapTexture(width: number, height: number): Texture2D<unknown>;
    // (undocumented)
    dispose(): void;
    draw(ctx: DrawContext): void;
    getMaterial(): MeshMaterial;
    getMorphData(): Texture2D;
    getMorphInfo(): GPUDataBuffer<unknown>;
    getPickTarget(): PickTarget;
    getPrimitive(): Primitive;
    getQueueType(): number;
    // (undocumented)
    get grassAssetId(): string;
    set grassAssetId(val: string);
    // (undocumented)
    get grassRenderer(): GrassRenderer;
    // (undocumented)
    get heightMap(): Texture2D;
    set heightMap(val: Texture2D);
    // (undocumented)
    get heightMapAssetId(): string;
    set heightMapAssetId(val: string);
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "isClipmapTerrain"
    //
    // (undocumented)
    isClipmapTerrain(): this is ClipmapTerrain;
    isUnlit(): boolean;
    // (undocumented)
    get material(): ClipmapTerrainMaterial;
    // (undocumented)
    get MAX_DETAIL_MAP_COUNT(): number;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    // (undocumented)
    get numDetailMaps(): number;
    set numDetailMaps(val: number);
    // (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    // (undocumented)
    setSize(sizeX: number, sizeZ: number): void;
    // (undocumented)
    get sizeX(): number;
    set sizeX(val: number);
    // (undocumented)
    get sizeZ(): number;
    set sizeZ(val: number);
    // (undocumented)
    get splatMap(): Texture2DArray;
    // (undocumented)
    get splatMapAssetId(): string;
    set splatMapAssetId(val: string);
    // (undocumented)
    updateBoundingBox(tmpTexture?: Texture2D): void;
    // (undocumented)
    updatePerCamera(camera: Camera, elapsedInSeconds: number, deltaInSeconds: number): void;
    // (undocumented)
    updateRegion(): void;
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
    get worldRegion(): Vector4;
}

// Warning: (ae-forgotten-export) The symbol "ClipmapTerrainMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class ClipmapTerrainMaterial extends ClipmapTerrainMaterial_base {
    constructor(heightMap: Texture2D);
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    calculateAlbedoColor(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    calculateDetailNormal(scope: PBInsideFunctionScope, TBN: PBShaderExp): any;
    // (undocumented)
    calculateTerrainTBN(scope: PBInsideFunctionScope, clipmapPos: PBShaderExp, uv: PBShaderExp, texSize: PBShaderExp, scale: PBShaderExp, levelStart: PBShaderExp, levelDiff: PBShaderExp, tangent: PBShaderExp, bitangent: PBShaderExp, normal: PBShaderExp): PBShaderExp;
    // (undocumented)
    get debugMode(): TerrainDebugMode;
    set debugMode(mode: TerrainDebugMode);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    static getDefaultDetailMap(): Texture2D<unknown>;
    // (undocumented)
    static getDefaultNormalMap(): Texture2D<unknown>;
    // (undocumented)
    getDetailMap(index: number): Texture2D;
    // (undocumented)
    getDetailMapRoughness(index: number): number;
    // (undocumented)
    getDetailMapUVScale(index: number): number;
    // (undocumented)
    getDetailNormalMap(index: number): Texture2D;
    // (undocumented)
    getNormalTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    getSplatMap(): Texture2DArray<unknown>;
    // (undocumented)
    get heightMap(): Texture2D;
    set heightMap(val: Texture2D);
    // (undocumented)
    static get MAX_DETAIL_MAP_COUNT(): number;
    // (undocumented)
    needSceneColor(): boolean;
    // (undocumented)
    needSceneDepth(): boolean;
    // (undocumented)
    get numDetailMaps(): number;
    set numDetailMaps(val: number);
    // @internal (undocumented)
    get region(): Vector4;
    set region(val: Vector4);
    // (undocumented)
    sampleDetailNormalMap(scope: PBInsideFunctionScope, index: number, texCoord: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleHeightMap(scope: PBInsideFunctionScope, uv: PBShaderExp, pos: PBShaderExp, levelStart: PBShaderExp, levelDiff: PBShaderExp): any;
    // (undocumented)
    setClipmapGridInfo(gridScale: number, gridOffsetX: number, gridOffsetY: number): void;
    // (undocumented)
    setDetailMap(index: number, albedoMap: Texture2D): void;
    // (undocumented)
    setDetailMapRoughness(index: number, val: number): void;
    // (undocumented)
    setDetailMapUVScale(index: number, scale: number): void;
    // (undocumented)
    setDetailNormalMap(index: number, normalMap: Texture2D): void;
    // @internal (undocumented)
    setLevelData(data: Float32Array, length: number): void;
    // (undocumented)
    setSplatMap(tex: Texture2DArray): void;
    // (undocumented)
    supportInstancing(): boolean;
    // (undocumented)
    supportLighting(): boolean;
    // @internal (undocumented)
    get terrainScale(): Vector3;
    set terrainScale(val: Vector3);
    // @internal (undocumented)
    update(region: Vector4, terrainScale: Vector3): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export class Compositor {
    constructor();
    appendPostEffect(postEffect: AbstractPostEffect): void;
    // @internal (undocumented)
    begin(ctx: DrawContext): void;
    // @internal (undocumented)
    static _blit(device: AbstractDevice, srcTex: Texture2D, srgbOutput: boolean): void;
    clear(): void;
    // @internal (undocumented)
    drawPostEffects(ctx: DrawContext, layer: PostEffectLayer, sceneDepthTexture: Texture2D): void;
    // @internal (undocumented)
    end(ctx: DrawContext): void;
    // @internal (undocumented)
    protected _postEffects: DRef<AbstractPostEffect>[][];
    removePostEffect(postEffect: AbstractPostEffect): void;
    // @internal (undocumented)
    requireLinearDepth(ctx: DrawContext): boolean;
}

// @public
export interface CompositorContext {
    // (undocumented)
    finalFramebuffer: FrameBuffer;
    // (undocumented)
    pingpongFramebuffers: FrameBuffer[];
    // (undocumented)
    writeIndex: number;
}

// @public
export class CopyBlitter extends Blitter {
    // @override
    protected calcHash(): string;
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
}

// Warning: (ae-internal-missing-underscore) The name "copyTexture" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function copyTexture(src: BaseTexture, dest: BaseTexture | FrameBuffer, sampler?: TextureSampler, renderState?: RenderStateSet, layer?: number, srgbOut?: boolean): void;

// Warning: (ae-internal-missing-underscore) The name "createGradientNoiseTexture" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createGradientNoiseTexture(device: AbstractDevice, size: number, uvscale: number, mono?: boolean, seed?: number): _zephyr3d_device.Texture2D<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramFFT2H" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramFFT2H(useComputeShader: boolean, threadGroupSize: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramFFT2V" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramFFT2V(useComputeShader: boolean, threadGroupSize: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramH0" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramH0(useComputeShader?: boolean, threadGroupSize?: number, targetFormat?: TextureFormat): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramHk" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramHk(useComputeShader?: boolean, threadGroupSize?: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramOcean" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramOcean(waveGenerator: WaveGenerator, shadingImpl: WaterShaderImpl): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createProgramPostFFT2" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createProgramPostFFT2(useComputeShader: boolean, threadGroupSize: number, targetFormat?: TextureFormat, limit?: 4 | 2): _zephyr3d_device.GPUProgram<unknown>;

// Warning: (ae-internal-missing-underscore) The name "createRandomNoiseTexture" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function createRandomNoiseTexture(device: AbstractDevice, size: number): _zephyr3d_device.Texture2D<unknown>;

// @public
export class CullVisitor implements Visitor<SceneNode | OctreeNode> {
    constructor(renderPass: RenderPass, camera: Camera, renderQueue: RenderQueue, primaryCamera: Camera);
    get camera(): Camera;
    set camera(camera: Camera);
    get frustum(): _zephyr3d_base.Frustum;
    get frustumCulling(): boolean;
    set frustumCulling(val: boolean);
    // @internal (undocumented)
    protected getClipStateWithAABB(aabb: AABB): ClipState;
    // @internal (undocumented)
    protected getClipStateWithNode(node: GraphNode): ClipState;
    get primaryCamera(): Camera;
    // @internal (undocumented)
    push(camera: Camera, drawable: Drawable): void;
    // @internal (undocumented)
    pushRenderQueue(renderQueue: RenderQueue): void;
    get renderPass(): RenderPass;
    get renderQueue(): RenderQueue;
    set renderQueue(renderQueue: RenderQueue);
    visit(target: SceneNode | OctreeNode): unknown;
    // @internal (undocumented)
    visitBatchGroup(node: BatchGroup): boolean;
    // @internal (undocumented)
    visitClipmapTerrain(node: ClipmapTerrain): boolean;
    // @internal (undocumented)
    visitMesh(node: Mesh): boolean;
    // @internal (undocumented)
    visitOctreeNode(node: OctreeNode): boolean;
    // @internal (undocumented)
    visitParticleSystem(node: ParticleSystem): boolean;
    // @internal (undocumented)
    visitPunctualLight(node: PunctualLight): boolean;
    // @internal (undocumented)
    visitTerrain(node: Terrain): boolean;
    // @internal (undocumented)
    visitWater(node: Water): boolean;
}

// @public
export interface CylinderCreationOptions extends ShapeCreationOptions {
    anchor?: number;
    bottomCap?: boolean;
    bottomRadius?: number;
    height?: number;
    heightDetail?: number;
    radialDetail?: number;
    topCap?: boolean;
    topRadius?: number;
}

// @public
export class CylinderShape extends Shape<CylinderCreationOptions> implements Clonable<CylinderShape> {
    constructor(options?: CylinderCreationOptions);
    // (undocumented)
    clone(): CylinderShape;
    // (undocumented)
    static _defaultOptions: {
        topCap: boolean;
        bottomCap: boolean;
        bottomRadius: number;
        topRadius: number;
        heightDetail: number;
        radialDetail: number;
        height: number;
        anchor: number;
        needNormal: boolean;
        needUV: boolean;
    };
    static generateData(options: CylinderCreationOptions, vertices: number[], normals: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): PrimitiveType;
    // (undocumented)
    get type(): string;
}

// Warning: (ae-internal-missing-underscore) The name "debugTexture" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function debugTexture(tex: BaseTexture, label: string): void;

// @public
export function decode2HalfFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeNormalizedFloatFromRGBA(scope: PBInsideFunctionScope, value: PBShaderExp): PBShaderExp;

// @public
export function decodeRGBM(scope: PBInsideFunctionScope, rgbm: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// @public (undocumented)
export const defaultAtmosphereParams: Readonly<AtmosphereParams>;

// @public
export class DepthPass extends RenderPass {
    constructor();
    // (undocumented)
    get encodeDepth(): boolean;
    set encodeDepth(val: boolean);
    // @internal (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    // (undocumented)
    get renderBackface(): boolean;
    set renderBackface(val: boolean);
    // @internal (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
    // (undocumented)
    get transmission(): boolean;
    set transmission(val: boolean);
}

// @public (undocumented)
export function deserializeObject<T extends object>(ctx: any, json: object, manager: SerializationManager): Promise<T>;

// @public (undocumented)
export function deserializeObjectProps<T extends object>(obj: T, cls: SerializableClass, json: object, manager: SerializationManager): Promise<void>;

// @public (undocumented)
export function deserializeSceneFromURL(url: string, manager: SerializationManager): Promise<{
    scene: Scene;
    meta: any;
}>;

// @public
export class DirectionalLight extends PunctualLight implements NodeClonable<DirectionalLight> {
    constructor(scene: Scene);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): DirectionalLight;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    // (undocumented)
    static getSunLight(scene: Scene): DirectionalLight;
    // @override
    isDirectionLight(): this is DirectionalLight;
    // (undocumented)
    static setSunLight(scene: Scene, light: DirectionalLight): void;
    get sunLight(): boolean;
    set sunLight(val: boolean);
}

// @public
export interface Disposable {
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly disposed: boolean;
}

// @public
export interface Drawable {
    applyTransformUniforms(renderQueue: RenderQueue): void;
    dispose(): void;
    draw(ctx: DrawContext, hash?: string): any;
    getBoneMatrices(): Texture2D;
    getDrawableId(): number;
    getMaterial(): MeshMaterial;
    getMorphData(): Texture2D;
    getMorphInfo(): GPUDataBuffer;
    getName(): string;
    getNode(): SceneNode;
    getObjectColor(): Vector4;
    getPickTarget(): PickTarget;
    getPrimitive(): Primitive;
    getQueueType(): number;
    getSortDistance(camera: Camera): number;
    isBatchable(): this is BatchDrawable;
    isUnlit(): boolean;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "pushRenderQueueRef" is marked as @public, but its signature references "RenderQueueRef" which is marked as @internal
    pushRenderQueueRef(ref: RenderQueueRef): any;
}

// Warning: (ae-internal-missing-underscore) The name "DrawableInstanceInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface DrawableInstanceInfo {
    // (undocumented)
    bindGroup: CachedBindGroup;
    // (undocumented)
    offset: number;
}

// @public
export interface DrawContext {
    applyFog: FogType;
    camera: Camera;
    // Warning: (ae-forgotten-export) The symbol "ClusteredLight" needs to be exported by the entry point index.d.ts
    clusteredLight?: ClusteredLight;
    colorFormat?: TextureFormat;
    compositor?: Compositor;
    // @internal (undocumented)
    currentShadowLight?: PunctualLight;
    depthFormat?: TextureFormat;
    depthTexture?: Texture2D;
    device: AbstractDevice;
    drawEnvLight: boolean;
    env: Environment;
    finalFramebuffer: FrameBuffer;
    flip: boolean;
    forceColorState?: ColorState;
    forceCullMode?: FaceMode;
    // Warning: (ae-forgotten-export) The symbol "GlobalBindGroupAllocator" needs to be exported by the entry point index.d.ts
    globalBindGroupAllocator: GlobalBindGroupAllocator;
    HiZ: boolean;
    HiZTexture: Texture2D;
    instanceData?: InstanceData;
    intermediateFramebuffer: FrameBuffer;
    lightBlending: boolean;
    linearDepthTexture?: Texture2D;
    materialFlags: number;
    motionVectors: boolean;
    motionVectorTexture?: Texture2D;
    oit: OIT;
    picking: boolean;
    primaryCamera: Camera;
    queue: number;
    renderHeight: number;
    renderPass: RenderPass;
    renderPassHash: string;
    renderQueue?: RenderQueue;
    renderWidth: number;
    scene: Scene;
    sceneColorTexture?: Texture2D;
    // @internal (undocumented)
    shadowMapInfo?: Map<PunctualLight, ShadowMapParams>;
    SSR: boolean;
    SSRCalcThickness: boolean;
    SSRNormalTexture: Texture2D;
    SSRRoughnessTexture: Texture2D;
    sunLight?: DirectionalLight;
    TAA: boolean;
    timestamp: number;
}

// @public
export class DRef<T extends Disposable> {
    constructor(obj?: T);
    dispose(): void;
    get(): T;
    set(obj: T): void;
}

// @public
export class DWeakRef<T extends Disposable> {
    constructor(obj?: T);
    dispose(): void;
    get(): T;
    set(obj: T): void;
}

// @public
export type EmbeddedAssetInfo = {
    assetType: AssetType;
    assetId: string;
    pkgId: string;
    path: string;
    data: Blob;
};

// @public
export type EmitterBehavior = 'surface' | 'volume';

// @public
export type EmitterShape = 'point' | 'sphere' | 'box' | 'cylinder' | 'cone';

// @public
export function encode2HalfToRGBA(scope: PBInsideFunctionScope, a: PBShaderExp | number, b: PBShaderExp | number): PBShaderExp;

// @public
export function encodeFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeNormalizedFloatToRGBA(scope: PBInsideFunctionScope, value: PBShaderExp | number): PBShaderExp;

// @public
export function encodeRGBM(scope: PBInsideFunctionScope, rgb: PBShaderExp, maxRange: PBShaderExp | number): PBShaderExp;

// @public
export class EnvConstantAmbient extends EnvironmentLighting {
    constructor(ambientColor?: Vector4);
    get ambientColor(): Vector4;
    set ambientColor(ambientColor: Vector4);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @internal (undocumented)
    static readonly UNIFORM_NAME_CONSTANT_AMBIENT = "zConstantAmbient";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EnvHemisphericAmbient extends EnvironmentLighting {
    constructor(ambientUp: Vector4, ambientDown: Vector4);
    get ambientDown(): Vector4;
    set ambientDown(color: Vector4);
    get ambientUp(): Vector4;
    set ambientUp(color: Vector4);
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    // @internal (undocumented)
    static readonly UNIFORM_NAME_AMBIENT_DOWN = "zHemisphericAmbientDown";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_AMBIENT_UP = "zHemisphericAmbientUp";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class EnvIBL extends EnvironmentLighting {
    constructor(radianceMap?: TextureCube, irradianceMap?: TextureCube);
    // @override
    dispose(): void;
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    get irradianceMap(): TextureCube;
    set irradianceMap(tex: TextureCube);
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_IRRADIANCE_MAP = "zIBLIrradianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP = "zIBLRadianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD = "zIBLRadianceMapMaxLOD";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// @public
export class Environment {
    // @internal
    constructor();
    // @internal (undocumented)
    dispose(): void;
    // @internal (undocumented)
    getHash(ctx: DrawContext): string;
    get light(): EnvLightWrapper;
    // @internal (undocumented)
    needSceneDepthTexture(): boolean;
    get sky(): SkyRenderer;
}

// @public
export abstract class EnvironmentLighting {
    dispose(): void;
    abstract getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    abstract getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    abstract getType(): EnvLightType;
    abstract hasIrradiance(): boolean;
    abstract hasRadiance(): boolean;
    abstract initShaderBindings(pb: ProgramBuilder): void;
    abstract updateBindGroup(bg: BindGroup): void;
}

// @public
export type EnvLightType = 'ibl' | 'ibl-sh' | 'hemisphere' | 'constant' | 'none';

// @public
export class EnvLightWrapper {
    // @internal
    constructor();
    get ambientColor(): Vector4;
    set ambientColor(val: Vector4);
    get ambientDown(): Vector4;
    set ambientDown(val: Vector4);
    get ambientUp(): Vector4;
    set ambientUp(val: Vector4);
    // @internal (undocumented)
    dispose(): void;
    // @internal (undocumented)
    get envLight(): EnvironmentLighting;
    // @internal (undocumented)
    getHash(ctx?: DrawContext): string;
    get irradianceMap(): TextureCube;
    set irradianceMap(tex: TextureCube);
    get irradianceSH(): Float32Array;
    set irradianceSH(value: Float32Array);
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    get strength(): number;
    set strength(val: number);
    get type(): EnvLightType;
    set type(val: EnvLightType);
}

// @public
export class EnvShIBL extends EnvironmentLighting {
    constructor(radianceMap?: TextureCube, irradianceSH?: (Vector4 | Vector3)[] | Float32Array);
    // @override
    dispose(): void;
    // @override
    getIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    // @override
    getRadiance(scope: PBInsideFunctionScope, refl: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    // @override
    getType(): EnvLightType;
    // @override
    hasIrradiance(): boolean;
    // @override
    hasRadiance(): boolean;
    // @override
    initShaderBindings(pb: ProgramBuilder): void;
    get irradianceSH(): Float32Array;
    set irradianceSH(value: Float32Array);
    get radianceMap(): TextureCube;
    set radianceMap(tex: TextureCube);
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_IRRADIANCE_SH = "zIBLIrradianceSH";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP = "zIBLRadianceMap";
    // @internal (undocumented)
    static readonly UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD = "zIBLRadianceMapMaxLOD";
    // @override
    updateBindGroup(bg: BindGroup): void;
}

// Warning: (ae-forgotten-export) The symbol "ShadowImpl" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "ESM" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class ESM extends ShadowImpl {
    constructor(kernelSize?: number, blurSize?: number, depthScale?: number);
    // Warning: (ae-forgotten-export) The symbol "BlurBlitter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _blitterH: BlurBlitter;
    // (undocumented)
    protected _blitterV: BlurBlitter;
    // (undocumented)
    get blur(): boolean;
    set blur(val: boolean);
    // (undocumented)
    protected _blur: boolean;
    // (undocumented)
    get blurSize(): number;
    set blurSize(val: number);
    // (undocumented)
    protected _blurSize: number;
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    protected _depthScale: number;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    fetchTemporalFramebuffer(autoRelease: boolean, lightType: number, numCascades: number, width: number, height: number, colorFormat: TextureFormat, depthFormat: TextureFormat, mipmapping?: boolean): FrameBuffer<unknown>;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // (undocumented)
    protected _logSpace: boolean;
    // (undocumented)
    get mipmap(): boolean;
    set mipmap(b: boolean);
    // (undocumented)
    protected _mipmap: boolean;
    // (undocumented)
    postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// @public
export type ExtractMixinReturnType<M> = M extends (target: infer A) => infer R ? R : never;

// @public
export type ExtractMixinType<M> = M extends [infer First] ? ExtractMixinReturnType<First> : M extends [infer First, ...infer Rest] ? ExtractMixinReturnType<First> & ExtractMixinType<[...Rest]> : never;

// @public
export class FBMWaveGenerator implements WaveGenerator {
    constructor();
    get amplitude(): number;
    set amplitude(val: number);
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    clone(): this;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "dispose"
    //
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    get frequency(): number;
    set frequency(val: number);
    getHash(): string;
    isOk(): boolean;
    needUpdate(): boolean;
    get numOctaves(): number;
    set numOctaves(val: number);
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    update(): void;
    // (undocumented)
    get version(): number;
    get wind(): Vector2;
    set wind(val: Vector2);
}

// Warning: (ae-internal-missing-underscore) The name "fetchNormalizedFloatForDevice" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function fetchNormalizedFloatForDevice(scope: PBInsideFunctionScope, tex: PBShaderExp, uv: PBShaderExp, level?: PBShaderExp | number): PBShaderExp;

// @public
export function fetchSampler(type: SamplerType): TextureSampler;

// @public
export class FFTWaveGenerator implements WaveGenerator {
    // Warning: (ae-forgotten-export) The symbol "OceanFieldBuildParams" needs to be exported by the entry point index.d.ts
    constructor(params?: OceanFieldBuildParams);
    get alignment(): number;
    set alignment(val: number);
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    clone(): this;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "dispose"
    //
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    get foamContrast(): number;
    set foamContrast(val: number);
    get foamWidth(): number;
    set foamWidth(val: number);
    getHash(): string;
    getWaveCroppiness(cascade: number): number;
    getWaveLength(cascade: number): number;
    getWaveStrength(cascade: number): number;
    isOk(): boolean;
    needUpdate(): boolean;
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    setWaveCroppiness(cascade: number, croppiness: number): void;
    setWaveLength(cascade: number, length: number): void;
    setWaveStrength(cascade: number, strength: number): void;
    update(time: number): void;
    // (undocumented)
    get version(): number;
    get wind(): Vector2;
    set wind(val: Vector2);
}

// @public
export function flushPendingDisposals(): void;

// @public
export type FogType = 'linear' | 'exp' | 'exp2' | 'scatter' | 'none';

// @public
export class FPSCameraController extends BaseCameraController {
    constructor(options?: FPSCameraControllerOptions);
    // @override
    protected _onKeyDown(evt: KeyboardEvent): boolean;
    // @override
    protected _onKeyUp(evt: KeyboardEvent): boolean;
    // @override
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @override
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @override
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: FPSCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface FPSCameraControllerOptions {
    controlKeys?: {
        up: string;
        down: string;
        forward: string;
        backward: string;
        left: string;
        right: string;
    };
    moveSpeed?: number;
    rotateSpeed?: number;
}

// @public
export class FXAA extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export function gammaToLinear(scope: PBInsideFunctionScope, color: PBShaderExp): PBShaderExp;

// @public (undocumented)
export class GatherVisitor implements Visitor<SceneNode> {
    constructor();
    // (undocumented)
    get materialSet(): Set<Material>;
    // (undocumented)
    get nodeList(): SceneNode[];
    // (undocumented)
    get primitiveSet(): Set<Primitive>;
    // (undocumented)
    visit(target: SceneNode): unknown;
    // @internal (undocumented)
    visitMesh(node: Mesh): boolean;
    // @internal (undocumented)
    visitParticleSystem(node: ParticleSystem): boolean;
}

// @public
export class GaussianBlurBlitter extends Blitter {
    constructor(phase: 'horizonal' | 'vertical', kernalSize: number, sigma: number, blurSize: number);
    get blurSize(): number;
    set blurSize(val: number);
    // @internal (undocumented)
    protected _blurSize: number;
    // @override
    protected calcHash(): string;
    get depthCutoff(): number;
    set depthCutoff(val: number);
    // @internal (undocumented)
    protected _depthCutoff: number;
    // @internal (undocumented)
    protected _depthTex: Texture2D;
    get depthTexture(): Texture2D;
    set depthTexture(tex: Texture2D);
    // @override
    filter(scope: PBInsideFunctionScope, type: BlitType, srcTex: PBShaderExp, srcUV: PBShaderExp, srcLayer: PBShaderExp, sampleType: 'float' | 'int' | 'uint'): PBShaderExp;
    get kernelSize(): number;
    set kernelSize(val: number);
    // @internal (undocumented)
    protected _kernelSize: number;
    get logSpace(): boolean;
    set logSpace(val: boolean);
    // @internal (undocumented)
    protected _logSpace: boolean;
    get logSpaceMultiplier(): number;
    set logSpaceMultiplier(val: number);
    // @internal (undocumented)
    protected _logSpaceMultiplier: number;
    // @internal (undocumented)
    protected _phase: 'horizonal' | 'vertical';
    // @override
    setUniforms(bindGroup: BindGroup): void;
    // @override
    setup(scope: PBGlobalScope, type: BlitType): void;
    // @internal (undocumented)
    protected _sigma: number;
}

// @public
export class GerstnerWaveGenerator implements WaveGenerator {
    constructor();
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): void;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    // (undocumented)
    clone(): this;
    deleteWave(index: number): void;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "dispose"
    //
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    getHash(): string;
    getOriginX(waveIndex: number): number;
    getOriginZ(waveIndex: number): number;
    getWaveAmplitude(waveIndex: number): number;
    getWaveDirection(waveIndex: number): number;
    getWaveLength(waveIndex: number): number;
    getWaveSteepness(waveIndex: number): number;
    insertWave(index: number): void;
    isOk(): boolean;
    isOmniWave(waveIndex: number): boolean;
    needUpdate(): boolean;
    get numWaves(): number;
    set numWaves(val: number);
    // @internal (undocumented)
    randomWave(i: number): void;
    // @internal (undocumented)
    static randomWaveData(array: Float32Array, offset: number): void;
    setOmniWave(waveIndex: number, isOmni: boolean): void;
    setOrigin(waveIndex: number, x: number, z: number): void;
    // @internal (undocumented)
    setRaw(data: Float32Array, index: number): void;
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    setWaveAmplitude(waveIndex: number, val: number): void;
    setWaveDirection(waveIndex: number, angle: number): void;
    setWaveLength(waveIndex: number, val: number): void;
    setWaveSteepness(waveIndex: number, steepness: number): void;
    update(): void;
    // (undocumented)
    get version(): number;
}

// @public (undocumented)
export function getAerialPerspectiveLut(): Texture2D<unknown>;

// @public (undocumented)
export function getAtmosphereParamsStruct(pb: ProgramBuilder): _zephyr3d_device.ShaderTypeFunc;

// @public (undocumented)
export function getBatchGroupClass(): SerializableClass;

// @public (undocumented)
export function getCameraClass(): SerializableClass;

// @public (undocumented)
export function getDirectionalLightClass(): SerializableClass;

// @public (undocumented)
export function getGraphNodeClass(): SerializableClass;

// @public (undocumented)
export function getMeshClass(): SerializableClass;

// @public (undocumented)
export function getMultiScattering(scope: PBInsideFunctionScope, stParams: PBShaderExp, f3Pos: PBShaderExp, texMultiScatteringLut: PBShaderExp): any;

// @public (undocumented)
export function getMultiScatteringLut(): Texture2D<unknown>;

// @public (undocumented)
export function getNodeHierarchyClass(): SerializableClass;

// @public (undocumented)
export function getOrthoCameraClass(): SerializableClass;

// @public (undocumented)
export function getParticleNodeClass(): SerializableClass;

// @public (undocumented)
export function getPerspectiveCameraClass(): SerializableClass;

// @public (undocumented)
export function getPointLightClass(): SerializableClass;

// @public (undocumented)
export function getPunctualLightClass(): SerializableClass;

// @public (undocumented)
export function getSceneNodeClass(manager: SerializationManager): SerializableClass;

// @public (undocumented)
export function getSkyView(scope: PBInsideFunctionScope, stParams: PBShaderExp, f3EyePos: PBShaderExp, f3ViewDir: PBShaderExp, fMaxDis: PBShaderExp, texTransmittanceLut: PBShaderExp, texMultiScatteringLut: PBShaderExp, withGround?: boolean): any;

// @public (undocumented)
export function getSkyViewLut(): Texture2D<unknown>;

// @public (undocumented)
export function getSpotLightClass(): SerializableClass;

// @public (undocumented)
export function getTransmittanceLut(): Texture2D<unknown>;

// @public
export function gradient(scope: PBInsideFunctionScope, p: PBShaderExp, t: PBShaderExp | number): any;

// @public
export class GraphNode extends SceneNode implements NodeClonable<GraphNode> {
    constructor(scene: Scene);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): GraphNode;
    getBoneMatrices(): Texture2D;
    getName(): string;
    getNode(): SceneNode;
    getSortDistance(camera: Camera): number;
    isBatchable(): this is BatchDrawable;
    // @override
    isGraphNode(): this is GraphNode;
    // @internal (undocumented)
    get octreeNode(): OctreeNode;
    set octreeNode(node: OctreeNode);
    // @internal (undocumented)
    protected _visibleChanged(): void;
}

// @public
export type GrassInstanceInfo = {
    x: number;
    y: number;
    angle: number;
};

// Warning: (ae-internal-missing-underscore) The name "GrassInstances" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class GrassInstances implements Disposable {
    constructor(baseVertexBuffer: StructuredBuffer, indexBuffer: IndexBuffer);
    // (undocumented)
    addInstances(instances: GrassInstanceInfo[]): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    draw(): void;
    // (undocumented)
    get instanceBuffer(): StructuredBuffer;
    // (undocumented)
    get numInstances(): number;
    // (undocumented)
    removeInstances(minX: number, minZ: number, maxX: number, maxZ: number, num: number): number;
    // (undocumented)
    setBaseVertexBuffer(baseVertexBuffer: StructuredBuffer): void;
    // (undocumented)
    updateBuffers(): void;
}

// @public
export class GrassLayer implements Disposable {
    constructor(terrain: ClipmapTerrain, bladeWidth: number, bladeHeight: number, albedoMap?: Texture2D);
    addInstances(instances: GrassInstanceInfo[]): void;
    get bladeHeight(): number;
    set bladeHeight(val: number);
    get bladeWidth(): number;
    set bladeWidth(val: number);
    // @internal (undocumented)
    dispose(): void;
    get disposed(): boolean;
    // @internal (undocumented)
    draw(ctx: DrawContext, region: Vector4, minY: number, maxY: number): void;
    getAlbedoMap(): Texture2D<unknown>;
    // @internal (undocumented)
    get quadtree(): GrassQuadtreeNode;
    removeInstances(minX: number, minZ: number, maxX: number, maxZ: number, numInstances: number): void;
    setAlbedoMap(albedoMap: Texture2D): void;
    setBladeSize(width: number, height: number): void;
    // @internal (undocumented)
    updateMaterial(): void;
}

// Warning: (ae-forgotten-export) The symbol "GrassMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class GrassMaterial extends GrassMaterial_base implements Clonable<GrassMaterial> {
    constructor(terrainSize: Vector2, normalMap: Texture2D, grassTexture?: Texture2D);
    // (undocumented)
    apply(ctx: DrawContext): boolean;
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    clone(): GrassMaterial;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // @override
    isTransparentPass(pass: number): boolean;
    // @override
    supportInstancing(): boolean;
    // @override
    supportLighting(): boolean;
    // (undocumented)
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// Warning: (ae-internal-missing-underscore) The name "GrassQuadtreeNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class GrassQuadtreeNode implements Disposable {
    constructor(baseVertexBuffer: StructuredBuffer, indexBuffer: IndexBuffer);
    // (undocumented)
    addInstances(instances: GrassInstanceInfo[]): number;
    // (undocumented)
    get children(): GrassQuadtreeNode[];
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    draw(camera: Camera, region: Vector4, minY: number, maxY: number, skipClipTest: boolean): void;
    // (undocumented)
    get grassInstances(): GrassInstances;
    // (undocumented)
    removeInstances(minX: number, minZ: number, maxX: number, maxZ: number, numInstances: number): number;
    // (undocumented)
    setBaseVertexBuffer(baseVertexBuffer: StructuredBuffer): void;
}

// @public
export class GrassRenderer implements Disposable {
    constructor(terrain: ClipmapTerrain);
    addInstances(layer: number, instances: GrassInstanceInfo[]): void;
    addLayer(bladeWidth: number, bladeHeight: number, albedoMap?: Texture2D): number;
    // @internal (undocumented)
    dispose(): void;
    get disposed(): boolean;
    // @internal (undocumented)
    draw(ctx: DrawContext): void;
    getBladeHeight(layer: number): number;
    getBladeWidth(layer: number): number;
    getGrassTexture(layer: number): Texture2D<unknown>;
    getLayer(index: number): GrassLayer;
    get numLayers(): number;
    removeInstances(layer: number, minX: number, minZ: number, maxX: number, maxZ: number, num: number): void;
    setBladeSize(layer: number, width: number, height: number): void;
    setGrassTexture(layer: number, texture: Texture2D): void;
    // @internal (undocumented)
    updateMaterial(): void;
}

// @public
export class Grayscale extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export function hash(scope: PBInsideFunctionScope, p: PBShaderExp): any;

// Warning: (ae-internal-missing-underscore) The name "HeightField" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class HeightField {
    constructor();
    // (undocumented)
    clear(): void;
    // (undocumented)
    computeNormals(): Uint8Array;
    // (undocumented)
    computeNormalVectors(): Vector3[];
    // (undocumented)
    getBBoxTree(): HeightfieldBBoxTree;
    // (undocumented)
    getBoundingbox(): BoundingBox;
    // (undocumented)
    getHeight(x: number, z: number): number;
    // (undocumented)
    getHeights(): Float32Array;
    // (undocumented)
    getOffsetX(): number;
    // (undocumented)
    getOffsetZ(): number;
    // (undocumented)
    getRealHeight(x: number, z: number): number;
    // (undocumented)
    getRealNormal(x: number, z: number, normal?: Vector3): Vector3;
    // (undocumented)
    getSizeX(): number;
    // (undocumented)
    getSizeZ(): number;
    // (undocumented)
    getSpacingX(): number;
    // (undocumented)
    getSpacingZ(): number;
    // (undocumented)
    getVerticalScale(): number;
    // (undocumented)
    init(sizeX: number, sizeZ: number, scale: Vector3, heights: Float32Array): boolean;
    // (undocumented)
    get normals(): Vector3[];
    // (undocumented)
    rayIntersect(ray: Ray): number | null;
}

// Warning: (ae-internal-missing-underscore) The name "HeightfieldBBoxTree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class HeightfieldBBoxTree {
    constructor(res_x: number, res_y: number, spacing_x: number, spacing_z: number, vertices: number[]);
    // (undocumented)
    allocNode(): HeightfieldBBoxTreeNode;
    // (undocumented)
    computeNodeBoundingBox(node: HeightfieldBBoxTreeNode, bbox: BoundingBox, vertices: Vector4[]): void;
    // (undocumented)
    create(): boolean;
    // (undocumented)
    createChildNode(node: HeightfieldBBoxTreeNode, x: number, y: number, w: number, h: number): boolean;
    // (undocumented)
    getHeight(x: number, y: number): number;
    // (undocumented)
    getHeights(): Float32Array;
    // (undocumented)
    getNormal(x: number, y: number, normal?: Vector3): Vector3;
    // (undocumented)
    getRealHeight(x: number, y: number): number;
    // (undocumented)
    getRealNormal(x: number, y: number, normal?: Vector3): Vector3;
    // (undocumented)
    rayIntersect(ray: Ray): number | null;
    // (undocumented)
    rayIntersectDDA(ray: Ray, x: number, y: number, w: number, h: number): number | null;
    // (undocumented)
    rayIntersectLeaf(ray: Ray, node: HeightfieldBBoxTreeNode): number | null;
    // (undocumented)
    rayIntersectRecursive(ray: Ray): number | null;
}

// Warning: (ae-internal-missing-underscore) The name "HeightfieldBBoxTreeNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface HeightfieldBBoxTreeNode {
    // (undocumented)
    bbox: BoundingBox;
    // (undocumented)
    left: HeightfieldBBoxTreeNode;
    // (undocumented)
    rc: {
        x: number;
        y: number;
        w: number;
        h: number;
    };
    // (undocumented)
    right: HeightfieldBBoxTreeNode;
}

// @public
export type IMixinAlbedoColor = {
    albedoColor: Vector4;
    calculateAlbedoColor(scope: PBInsideFunctionScope, uv?: PBShaderExp): PBShaderExp;
} & TextureMixinInstanceTypes<['albedo']>;

// @public
export type IMixinBlinnPhong = {
    shininess: number;
    blinnPhongLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
} & IMixinLight;

// @public
export interface IMixinFoliage {
    // (undocumented)
    calculateFoliageAlbedo(scope: PBInsideFunctionScope, albedoColor: PBShaderExp, texelCoord: PBShaderExp): PBShaderExp;
}

// @public
export type IMixinLambert = {
    lambertLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, albedo: PBShaderExp): PBShaderExp;
} & IMixinLight;

// @public
export type IMixinLight = {
    normalScale: number;
    normalMapMode: 'tangent-space' | 'object-space';
    doubleSidedLighting: boolean;
    needCalculateEnvLight(): boolean;
    getUniformNormalScale(scope: PBInsideFunctionScope): PBShaderExp;
    getEnvLightIrradiance(scope: PBInsideFunctionScope, normal: PBShaderExp): PBShaderExp;
    getEnvLightRadiance(scope: PBInsideFunctionScope, reflectVec: PBShaderExp, roughness: PBShaderExp): PBShaderExp;
    calculateViewVector(scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    calculateReflectionVector(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp): PBShaderExp;
    calculateTBN(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateNormal(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateNormalAndTBN(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    calculateLightAttenuation(scope: PBInsideFunctionScope, type: PBShaderExp, worldPos: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateLightDirection(scope: PBInsideFunctionScope, type: PBShaderExp, worldPos: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp): PBShaderExp;
    calculateShadow(scope: PBInsideFunctionScope, worldPos: PBShaderExp, NoL: PBShaderExp): PBShaderExp;
    forEachLight(scope: PBInsideFunctionScope, callback: (this: PBInsideFunctionScope, type: PBShaderExp, posRange: PBShaderExp, dirCutoff: PBShaderExp, colorIntensity: PBShaderExp, shadow: boolean) => void): void;
} & TextureMixinInstanceTypes<['normal']> & IMixinAlbedoColor;

// @public
export type IMixinPBRCommon = {
    ior: number;
    emissiveColor: Vector3;
    emissiveStrength: number;
    occlusionStrength: number;
    transmission: boolean;
    transmissionFactor: number;
    thicknessFactor: number;
    attenuationColor: Vector3;
    attenuationDistance: number;
    sheen: boolean;
    sheenColorFactor: Vector3;
    sheenRoughnessFactor: number;
    clearcoat: boolean;
    clearcoatIntensity: number;
    clearcoatRoughnessFactor: number;
    iridescence: boolean;
    iridescenceFactor: number;
    iridescenceIor: number;
    iridescenceThicknessMin: number;
    iridescenceThicknessMax: number;
    getCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
    fresnelSchlick(scope: PBInsideFunctionScope, cosTheta: PBShaderExp, F0: PBShaderExp): PBShaderExp;
    distributionGGX(scope: PBInsideFunctionScope, NdotH: PBShaderExp, alphaRoughness: PBShaderExp): PBShaderExp;
    visGGX(scope: PBInsideFunctionScope, NdotV: PBShaderExp, NdotL: PBShaderExp, alphaRoughness: PBShaderExp): PBShaderExp;
    getCommonDatasStruct(scope: PBInsideFunctionScope): ShaderTypeFunc;
    calculateEmissiveColor(scope: PBInsideFunctionScope): PBShaderExp;
    getF0(scope: PBInsideFunctionScope): PBShaderExp;
    directLighting(scope: PBInsideFunctionScope, lightDir: PBShaderExp, lightColor: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp): any;
    indirectLighting(scope: PBInsideFunctionScope, normal: PBShaderExp, viewVec: PBShaderExp, commonData: PBShaderExp, outColor: PBShaderExp, outRoughness?: PBShaderExp): any;
} & TextureMixinInstanceTypes<[
'occlusion',
'emissive',
'sheenColor',
'sheenRoughness',
'clearcoatIntensity',
'clearcoatRoughness',
'clearcoatNormal',
'transmission',
'thickness',
'iridescence',
'iridescenceThickness'
]>;

// @public
export type IMixinPBRMetallicRoughness = {
    metallic: number;
    roughness: number;
    specularFactor: Vector4;
    PBRLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, TBN: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
    calculateMetallic(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp): PBShaderExp;
    calculateRoughness(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp): PBShaderExp;
    calculateSpecularFactor(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp): any;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['metallicRoughness', 'occlusion', 'specular', 'specularColor']>;

// @public
export type IMixinPBRSpecularGlossiness = {
    specularFactor: Vector3;
    glossinessFactor: number;
    PBRLight(scope: PBInsideFunctionScope, worldPos: PBShaderExp, normal: PBShaderExp, viewVec: PBShaderExp, albedo: PBShaderExp, TBN: PBShaderExp, outRoughness?: PBShaderExp): PBShaderExp;
    calculateCommonData(scope: PBInsideFunctionScope, albedo: PBShaderExp, viewVec: PBShaderExp, TBN: PBShaderExp, data: PBShaderExp): void;
} & IMixinPBRCommon & IMixinLight & TextureMixinInstanceTypes<['specular']>;

// @public
export interface IMixinVertexColor {
    // (undocumented)
    getVertexColor(scope: PBInsideFunctionScope): any;
    // (undocumented)
    vertexColor: boolean;
}

// @public
export type InputEventHandler = (ev: Event, type?: string) => boolean;

// @public
export class InputManager {
    constructor(app: Application);
    static log(ev: Event, type?: string): boolean;
    // @internal (undocumented)
    start(): void;
    // @internal (undocumented)
    stop(): void;
    use(handler: InputEventHandler): this;
}

// Warning: (ae-internal-missing-underscore) The name "InstanceBindGroupAllocator" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class InstanceBindGroupAllocator {
    constructor();
    // (undocumented)
    allocateInstanceBindGroup(framestamp: number, sizeInFloats: number): CachedBindGroup;
    // (undocumented)
    _bindGroupList: CachedBindGroup[];
}

// @public
export interface InstanceData {
    // Warning: (ae-incompatible-release-tags) The symbol "bindGroup" is marked as @public, but its signature references "CachedBindGroup" which is marked as @internal
    //
    // (undocumented)
    bindGroup: CachedBindGroup;
    // (undocumented)
    numInstances: number;
    // (undocumented)
    offset: number;
    // (undocumented)
    stride: number;
}

// Warning: (ae-internal-missing-underscore) The name "InstanceUniformType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type InstanceUniformType = 'float' | 'vec2' | 'vec3' | 'vec4' | 'rgb' | 'rgba';

// @public (undocumented)
export function integralMultiScattering(scope: PBInsideFunctionScope, stParams: PBShaderExp, f3LightDir: PBShaderExp, f3SamplePoint: PBShaderExp, texTransmittanceLut: PBShaderExp): any;

// @public
export function interleavedGradientNoise(scope: PBInsideFunctionScope, c: PBShaderExp): PBShaderExp;

// Warning: (ae-forgotten-export) The symbol "LambertMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class LambertMaterial extends LambertMaterial_base implements Clonable<LambertMaterial> {
    constructor();
    // (undocumented)
    clone(): LambertMaterial;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// @public
export const LIGHT_TYPE_DIRECTIONAL = 1;

// @public
export const LIGHT_TYPE_NONE = 0;

// @public
export const LIGHT_TYPE_POINT = 2;

// @public
export const LIGHT_TYPE_SPOT = 3;

// Warning: (ae-internal-missing-underscore) The name "LightPass" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class LightPass extends RenderPass {
    constructor();
    // (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    // (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
    // (undocumented)
    protected renderLightPass(ctx: DrawContext, itemList: RenderItemListBundle, lights: PunctualLight[], flags: any): void;
    // (undocumented)
    protected _shadowMapHash: string;
    // (undocumented)
    get transmission(): boolean;
    set transmission(val: boolean);
    // (undocumented)
    protected _transmission: boolean;
}

// @public
export function linearToGamma(scope: PBInsideFunctionScope, color: PBShaderExp): any;

// @public
export interface Logger {
    // (undocumented)
    log(text: string, mode?: LogMode): void;
}

// @public
export type LogMode = 'info' | 'warn' | 'error' | 'debug';

// @public
export class Material implements Clonable<Material> {
    // @internal
    get $instanceUniforms(): Float32Array;
    // @internal
    get $isInstance(): boolean;
    constructor();
    apply(ctx: DrawContext): boolean;
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean, pass: number): void;
    protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // @internal (undocumented)
    bind(device: AbstractDevice, pass: number): boolean;
    get changeTag(): number;
    // (undocumented)
    clone(): Material;
    // (undocumented)
    copyFrom(other: this): void;
    // @internal (undocumented)
    get coreMaterial(): this;
    // @internal (undocumented)
    createHash(pass: number): string;
    protected _createHash(): string;
    createInstance(): this;
    // @internal (undocumented)
    protected createProgram(ctx: DrawContext, pass: number): GPUProgram;
    protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, pass: number): GPUProgram;
    dispose(): void;
    get disposed(): boolean;
    // @internal
    draw(primitive: Primitive, ctx: DrawContext, numInstances?: number): void;
    drawPrimitive(pass: number, primitive: Primitive, ctx: DrawContext, numInstances: number): void;
    // @internal (undocumented)
    static findMaterialById(id: string): Material;
    // @internal (undocumented)
    protected getHash(pass: number): string;
    // (undocumented)
    getQueueType(): number;
    // @internal (undocumented)
    protected _hash: string[];
    get instanceId(): number;
    isBatchable(): boolean;
    isTransparentPass(pass: number): boolean;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    // (undocumented)
    get numPasses(): number;
    set numPasses(val: number);
    // @internal (undocumented)
    protected _numPasses: number;
    // @internal (undocumented)
    optionChanged(changeHash: boolean): void;
    passToHash(pass: number): string;
    get persistentId(): string;
    set persistentId(val: string);
    // @internal (undocumented)
    protected static _registry: Map<string, DWeakRef<Material>>;
    supportInstancing(): boolean;
    supportLighting(): boolean;
    protected updateRenderStates(pass: number, renderStates: RenderStateSet, ctx: DrawContext): void;
}

// @public
export interface MaterialTextureInfo {
    // (undocumented)
    sampler: TextureSampler;
    // (undocumented)
    texCoord: number;
    // (undocumented)
    texture: Texture2D;
    // (undocumented)
    transform: Matrix4x4;
}

// @public
export const enum MaterialVaryingFlags {
    // (undocumented)
    INSTANCING = 4,
    // (undocumented)
    MORPH_ANIMATION = 1,
    // (undocumented)
    SKIN_ANIMATION = 2,
    // (undocumented)
    SSR_STORE_ROUGHNESS = 8
}

// @public
export const MAX_CLUSTERED_LIGHTS = 255;

// Warning: (ae-internal-missing-underscore) The name "MAX_GERSTNER_WAVE_COUNT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MAX_GERSTNER_WAVE_COUNT = 16;

// Warning: (ae-internal-missing-underscore) The name "MAX_MORPH_ATTRIBUTES" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MAX_MORPH_ATTRIBUTES = 8;

// Warning: (ae-internal-missing-underscore) The name "MAX_MORPH_TARGETS" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MAX_MORPH_TARGETS = 256;

// Warning: (ae-internal-missing-underscore) The name "MAX_TERRAIN_MIPMAP_LEVELS" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MAX_TERRAIN_MIPMAP_LEVELS = 64;

// Warning: (ae-forgotten-export) The symbol "Mesh_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Mesh extends Mesh_base implements BatchDrawable, NodeClonable<Mesh> {
    constructor(scene: Scene, primitive?: Primitive, material?: MeshMaterial);
    // @internal (undocumented)
    protected _animatedBoundingBox: BoundingBox;
    // @internal (undocumented)
    protected _batchable: boolean;
    // @internal (undocumented)
    protected _bboxChangeCallback: () => void;
    // @internal (undocumented)
    protected _boneMatrices: Texture2D;
    // @internal (undocumented)
    protected _boundingBoxNode: Mesh;
    get castShadow(): boolean;
    set castShadow(b: boolean);
    // @internal (undocumented)
    protected _castShadow: boolean;
    clone(method: NodeCloneMethod, recursive: boolean): Mesh;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    dispose(): void;
    draw(ctx: DrawContext, hash?: string): void;
    get drawBoundingBox(): boolean;
    set drawBoundingBox(val: boolean);
    getBoneMatrices(): Texture2D;
    getInstanceId(renderPass: RenderPass): string;
    getInstanceUniforms(): Float32Array;
    getMaterial(): MeshMaterial;
    getMorphData(): Texture2D;
    getMorphInfo(): GPUDataBuffer<unknown>;
    getName(): string;
    getNode(): SceneNode;
    getPickTarget(): PickTarget;
    getPrimitive(): Primitive;
    getQueueType(): number;
    // @internal (undocumented)
    protected _instanceHash: string;
    isBatchable(): this is BatchDrawable;
    isMesh(): this is Mesh;
    isUnlit(): boolean;
    get material(): MeshMaterial;
    set material(m: MeshMaterial);
    // @internal (undocumented)
    protected _materialChangeTag: number;
    // @internal (undocumented)
    get morphAnimation(): boolean;
    set morphAnimation(val: boolean);
    // @internal (undocumented)
    protected _morphAnimation: boolean;
    // @internal (undocumented)
    protected _morphData: Texture2D;
    // @internal (undocumented)
    protected _morphInfo: GPUDataBuffer;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    // @internal (undocumented)
    protected _pickTarget: PickTarget;
    get primitive(): Primitive;
    set primitive(prim: Primitive);
    // @internal (undocumented)
    protected _primitiveChangeTag: number;
    // @internal (undocumented)
    protected _renderBundle: Record<string, RenderBundle>;
    setAnimatedBoundingBox(bbox: BoundingBox): void;
    setBoneMatrices(matrices: Texture2D): void;
    setMorphData(data: Texture2D): void;
    setMorphInfo(info: GPUDataBuffer): void;
    // (undocumented)
    setPickTarget(node: SceneNode, label?: string): void;
    // @internal (undocumented)
    get skinAnimation(): boolean;
    set skinAnimation(val: boolean);
    // @internal (undocumented)
    protected _skinAnimation: boolean;
    // @internal (undocumented)
    protected _useRenderBundle: boolean;
}

// @public
export class MeshMaterial extends Material implements Clonable<MeshMaterial> {
    constructor();
    get alphaCutoff(): number;
    set alphaCutoff(val: number);
    // (undocumented)
    get alphaToCoverage(): boolean;
    set alphaToCoverage(val: boolean);
    // @internal @override
    protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    get blendMode(): BlendMode;
    set blendMode(val: BlendMode);
    // (undocumented)
    clone(): MeshMaterial;
    // (undocumented)
    copyFrom(other: this): void;
    // @internal @override
    protected _createHash(): string;
    createInstance(): this;
    // @internal (undocumented)
    protected createProgram(ctx: DrawContext, pass: number): GPUProgram;
    // @internal @override
    protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, pass: number): GPUProgram;
    get cullMode(): FaceMode;
    set cullMode(val: FaceMode);
    static defineFeature(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "defineInstanceUniform" is marked as @public, but its signature references "InstanceUniformType" which is marked as @internal
    static defineInstanceUniform(prop: string, type: InstanceUniformType): number;
    get drawContext(): DrawContext;
    featureUsed<T = unknown>(feature: number): T;
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    getInstancedUniform(scope: PBInsideFunctionScope, uniformIndex: number): PBShaderExp;
    getInstancedUniforms(): {
        prop: string;
        type: InstanceUniformType;
        offset: number;
    }[];
    getQueueType(): number;
    // @internal (undocumented)
    static INSTANCE_UNIFORMS: {
        prop: string;
        type: InstanceUniformType;
        offset: number;
    }[];
    isTransparentPass(pass: number): boolean;
    needFragmentColor(ctx?: DrawContext): boolean;
    // @internal (undocumented)
    static NEXT_FEATURE_INDEX: number;
    // @internal (undocumented)
    static OBJECT_COLOR_UNIFORM: number;
    get objectColor(): Vector4;
    set objectColor(val: Vector4);
    get opacity(): number;
    set opacity(val: number);
    // @internal (undocumented)
    static OPACITY_UNIFORM: number;
    outputFragmentColor(scope: PBInsideFunctionScope, worldPos: PBShaderExp, color: PBShaderExp, ssrRoughness?: PBShaderExp, ssrNormal?: PBShaderExp): void;
    // @internal
    get pass(): number;
    supportLighting(): boolean;
    get TAADisabled(): boolean;
    set TAADisabled(val: boolean);
    get TAAStrength(): number;
    set TAAStrength(val: number);
    uniformChanged(): void;
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    useFeature(feature: number, use: unknown): void;
    vertexShader(scope: PBFunctionScope): void;
}

// @public (undocumented)
export function mieAbsorption(scope: PBInsideFunctionScope, fMieScatteringHeight: PBShaderExp, fH: PBShaderExp): any;

// @public (undocumented)
export function mieCoefficient(scope: PBInsideFunctionScope, fMieScatteringHeight: PBShaderExp, fH: PBShaderExp): any;

// @public (undocumented)
export function miePhase(scope: PBInsideFunctionScope, fMieAnstropy: PBShaderExp, fCosTheta: PBShaderExp): any;

// @public
export function mixinAlbedoColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinAlbedoColor);

// @public
export function mixinBlinnPhong<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinBlinnPhong);

// @public
export function mixinFoliage<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinFoliage);

// @public
export function mixinLambert<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinLambert);

// @public
export function mixinLight<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinLight);

// @public
export function mixinPBRCommon<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRCommon);

// @public
export function mixinPBRMetallicRoughness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRMetallicRoughness);

// @public
export function mixinPBRSpecularGlossness<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinPBRSpecularGlossiness);

// @public
export function mixinTextureProps<U extends string>(name: U): <T extends typeof MeshMaterial>(BaseCls: T, vertex?: boolean) => T & (new (...args: any[]) => TextureProp<U> & TexturePropUniforms<U>);

// @public
export function mixinVertexColor<T extends typeof MeshMaterial>(BaseCls: T): T & (new (...args: any[]) => IMixinVertexColor);

// @public
export type ModelFetchOptions = {
    mimeType?: string;
    dracoDecoderModule?: DecoderModule;
    enableInstancing?: boolean;
    postProcess?: (model: SharedModel) => SharedModel;
};

// @public
export type ModelInfo = {
    group: SceneNode;
    animationSet: AnimationSet;
};

// Warning: (ae-internal-missing-underscore) The name "MORPH_ATTRIBUTE_VECTOR_COUNT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_ATTRIBUTE_VECTOR_COUNT: number;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_COLOR" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_COLOR = 3;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_NORMAL" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_NORMAL = 1;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_POSITION" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_POSITION = 0;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TANGENT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TANGENT = 2;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX0" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX0 = 4;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX1" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX1 = 5;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX2" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX2 = 6;

// Warning: (ae-internal-missing-underscore) The name "MORPH_TARGET_TEX3" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_TARGET_TEX3 = 7;

// Warning: (ae-internal-missing-underscore) The name "MORPH_WEIGHTS_VECTOR_COUNT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const MORPH_WEIGHTS_VECTOR_COUNT: number;

// @public (undocumented)
export function multiScatteringLut(scope: PBInsideFunctionScope, stParams: PBShaderExp, f2UV: PBShaderExp, texTransmittanceLut: PBShaderExp): any;

// @public
export class NamedObject {
    constructor(name: string);
    // (undocumented)
    name: string;
}

// @public
export interface NodeClonable<T extends SceneNode> {
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): T;
}

// @public
export type NodeCloneMethod = 'deep' | 'instance';

// @public
export class NodeEulerRotationTrack extends AnimationTrack<Quaternion> {
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[], embedded?: boolean);
    // (undocumented)
    applyState(node: SceneNode, state: Quaternion): void;
    // (undocumented)
    calculateState(target: object, currentTime: number): Quaternion;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    getDuration(): number;
    // (undocumented)
    mixState(a: Quaternion, b: Quaternion, t: number): Quaternion;
}

// @public (undocumented)
export class NodeHierarchy {
    constructor(scene: Scene, node?: SceneNode);
    // (undocumented)
    get materialList(): Material[];
    // (undocumented)
    get primitiveList(): Primitive[];
    // (undocumented)
    get rootNode(): SceneNode;
    set rootNode(node: SceneNode);
    // (undocumented)
    get scene(): Scene;
}

// @public
export type NodeIterateFunc = ((node: SceneNode) => boolean) | ((node: SceneNode) => void);

// @public
export class NodeRotationTrack extends AnimationTrack<Quaternion> {
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Quaternion;
    }[], embedded?: boolean);
    // (undocumented)
    applyState(node: SceneNode, state: Quaternion): void;
    // (undocumented)
    calculateState(target: object, currentTime: number): Quaternion;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    getDuration(): number;
    // (undocumented)
    mixState(a: Quaternion, b: Quaternion, t: number): Quaternion;
}

// @public
export class NodeScaleTrack extends AnimationTrack<Vector3> {
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[], embedded?: boolean);
    // (undocumented)
    applyState(node: SceneNode, state: Vector3): void;
    // (undocumented)
    calculateState(target: object, currentTime: number): Vector3;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    getDuration(): number;
    // (undocumented)
    mixState(a: Vector3, b: Vector3, t: number): Vector3;
}

// @public
export class NodeTranslationTrack extends AnimationTrack<Vector3> {
    constructor(interpolator: Interpolator, embedded?: boolean);
    constructor(mode: InterpolationMode, keyFrames: {
        time: number;
        value: Vector3;
    }[], embedded?: boolean);
    // (undocumented)
    applyState(node: SceneNode, state: Vector3): void;
    // (undocumented)
    calculateState(target: object, currentTime: number): Vector3;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    getDuration(): number;
    // (undocumented)
    mixState(a: Vector3, b: Vector3, t: number): Vector3;
}

// @public
export function noise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export class Octree {
    constructor(scene: Scene, rootSize?: number, leafSize?: number, maxRootSize?: number);
    finalize(): void;
    getChunk(level: number): OctreeNodeChunk;
    getLeafSize(): number;
    getNumChunks(): number;
    getRootNode(): OctreeNode;
    getRootSize(): number;
    getScene(): Scene;
    initialize(rootSize: number, leafSize: number): void;
    locateNodeChain(candidate: OctreeNode, center: Vector3, radius: number): OctreeNode;
    placeNode(node: GraphNode): void;
    // (undocumented)
    prune(): void;
    removeNode(node: GraphNode): void;
    // (undocumented)
    resize(size: number): void;
}

// @public
export class OctreeNode {
    constructor();
    addNode(node: GraphNode): void;
    clearNodes(): void;
    createChildren(): void;
    getBox(): AABB;
    getBoxLoosed(): AABB;
    getChild(placement: OctreePlacement): OctreeNode;
    getChunk(): OctreeNodeChunk;
    getLevel(): number;
    getMaxPoint(): Vector3;
    getMaxPointLoosed(): Vector3;
    getMinPoint(): Vector3;
    getMinPointLoosed(): Vector3;
    getNodes(): GraphNode[];
    getOrCreateChild(placement: OctreePlacement): OctreeNode;
    getOrCreateParent(): OctreeNode;
    getParent(): OctreeNode;
    getPosition(): number;
    removeNode(node: GraphNode): void;
    setChunk(chunk: OctreeNodeChunk): void;
    setPosition(index: number): void;
    traverse(v: Visitor<OctreeNode>): void;
}

// @public
export class OctreeNodeChunk {
    constructor(octree: Octree);
    clearNodes(): void;
    empty(): boolean;
    getChildIndex(index: number, placement: OctreePlacement): number;
    getDimension(): number;
    getLevel(): number;
    getNext(): OctreeNodeChunk;
    getNode(index: number): OctreeNode;
    getNodeSize(): number;
    getOctree(): Octree;
    getOrCreateNode(index: number): OctreeNode;
    getOrCreateNodeChain(index: number): OctreeNode;
    getParentIndex(index: number): number;
    getPrev(): OctreeNodeChunk;
    getWorldSize(): number;
    // @internal (undocumented)
    get nodeMap(): Map<number, OctreeNode>;
    setDimension(dimension: number): void;
    setLevel(level: number): void;
    setNext(chunk: OctreeNodeChunk): void;
    setNodeSize(size: number): void;
    setPrev(chunk: OctreeNodeChunk): void;
}

// @public
export enum OctreePlacement {
    // (undocumented)
    NNN = 7,
    // (undocumented)
    NNP = 6,
    // (undocumented)
    NPN = 5,
    // (undocumented)
    NPP = 4,
    // (undocumented)
    PNN = 3,
    // (undocumented)
    PNP = 2,
    // (undocumented)
    PPN = 1,
    // (undocumented)
    PPP = 0
}

// @public
export interface OIT {
    applyUniforms(ctx: DrawContext, bindGroup: BindGroup): any;
    begin(ctx: DrawContext): number;
    beginPass(ctx: DrawContext, pass: number): boolean;
    calculateHash(): string;
    dispose(): void;
    readonly disposed: boolean;
    end(ctx: DrawContext): any;
    endPass(ctx: DrawContext, pass: number): any;
    getType(): string;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): any;
    setupFragmentOutput(scope: PBGlobalScope): any;
    supportDevice(deviceType: string): boolean;
    wantsPremultipliedAlpha(): boolean;
}

// @public
export class OrbitCameraController extends BaseCameraController {
    constructor(options?: Partial<OrbitCameraControllerOptions>);
    get center(): Vector3;
    set center(val: Vector3);
    // (undocumented)
    lookAt(from: Vector3, to: Vector3, up: Vector3): void;
    // @override
    protected _onMouseDown(evt: PointerEvent): boolean;
    // @override
    protected _onMouseMove(evt: PointerEvent): boolean;
    // @override
    protected _onMouseUp(evt: PointerEvent): boolean;
    // @override
    protected _onMouseWheel(evt: WheelEvent): boolean;
    // @override
    reset(): void;
    setOptions(opt?: OrbitCameraControllerOptions): void;
    // @override
    update(): void;
}

// @public
export interface OrbitCameraControllerOptions {
    center: Vector3;
    // (undocumented)
    controls?: {
        rotate?: {
            button: number;
            shiftKey: boolean;
            ctrlKey: boolean;
            altKey: boolean;
            metaKey: boolean;
        };
        pan?: {
            button: number;
            shiftKey: boolean;
            ctrlKey: boolean;
            altKey: boolean;
            metaKey: boolean;
        };
        zoom?: {
            button: number;
            shiftKey: boolean;
            ctrlKey: boolean;
            altKey: boolean;
            metaKey: boolean;
        };
        zoomWheel?: boolean;
    };
    damping?: number;
    panSpeed?: number;
    rotateSpeed?: number;
    zoomSpeed?: number;
}

// @public
export class OrthoCamera extends Camera implements NodeClonable<OrthoCamera> {
    constructor(scene: Scene, left?: number, right?: number, bottom?: number, top?: number, near?: number, far?: number);
    get bottom(): number;
    set bottom(val: number);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): OrthoCamera;
    // @internal (undocumented)
    protected _computeProj(): void;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    get far(): number;
    set far(val: number);
    get left(): number;
    set left(val: number);
    get near(): number;
    set near(val: number);
    get right(): number;
    set right(val: number);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get top(): number;
    set top(val: number);
    get window(): number[];
    set window(val: number[]);
}

// @public (undocumented)
export function ozoneAbsorption(scope: PBInsideFunctionScope, fOzoneLevelCenterHeight: PBShaderExp, fOzoneLevelWidth: PBShaderExp, fH: PBShaderExp): any;

// @public
export function panoramaToCubemap(tex: Texture2D, outputCubeMap: TextureCube): void;

// @public
export class ParticleMaterial extends MeshMaterial implements Clonable<ParticleMaterial> {
    constructor();
    // (undocumented)
    get alphaMap(): Texture2D;
    set alphaMap(tex: Texture2D);
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    get aspect(): number;
    set aspect(val: number);
    // (undocumented)
    clone(): ParticleMaterial;
    // (undocumented)
    copyFrom(other: this): void;
    // (undocumented)
    get directional(): boolean;
    set directional(b: boolean);
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    get jitterPower(): number;
    set jitterPower(val: number);
    // (undocumented)
    get rampMap(): Texture2D;
    set rampMap(tex: Texture2D);
    // (undocumented)
    supportInstancing(): boolean;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// Warning: (ae-forgotten-export) The symbol "ParticleSystem_base" needs to be exported by the entry point index.d.ts
//
// @public
export class ParticleSystem extends ParticleSystem_base implements Drawable, NodeClonable<ParticleSystem> {
    constructor(scene: Scene);
    get airResistence(): boolean;
    set airResistence(value: boolean);
    get aspect(): number;
    set aspect(value: number);
    clone(method: NodeCloneMethod, recursive: boolean): ParticleSystem;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    get directional(): boolean;
    set directional(val: boolean);
    dispose(): void;
    draw(ctx: DrawContext): void;
    get emitCount(): number;
    set emitCount(value: number);
    get emitInterval(): number;
    set emitInterval(value: number);
    get emitterBehavior(): EmitterBehavior;
    set emitterBehavior(value: EmitterBehavior);
    get emitterConeRadiusMax(): number;
    set emitterConeRadiusMax(value: number);
    get emitterConeRadiusMin(): number;
    set emitterConeRadiusMin(value: number);
    get emitterShape(): EmitterShape;
    set emitterShape(value: EmitterShape);
    get emitterShapeSizeMax(): Vector3;
    set emitterShapeSizeMax(value: Vector3);
    get emitterShapeSizeMin(): Vector3;
    set emitterShapeSizeMin(value: Vector3);
    // @internal (undocumented)
    get flags(): number;
    set flags(value: number);
    getMaterial(): MeshMaterial;
    getMorphData(): Texture2D;
    getMorphInfo(): GPUDataBuffer<unknown>;
    getPickTarget(): PickTarget;
    getPrimitive(): Primitive;
    getQueueType(): number;
    get gravity(): Vector3;
    set gravity(value: Vector3);
    isParticleSystem(): this is ParticleSystem;
    isUnlit(): boolean;
    get jitterPower(): number;
    set jitterPower(value: number);
    get jitterSpeed(): number;
    set jitterSpeed(value: number);
    get material(): ParticleMaterial;
    set material(material: ParticleMaterial);
    get maxParticleCount(): number;
    set maxParticleCount(value: number);
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    // (undocumented)
    newParticle(num: number, worldMatrix: Matrix4x4): void;
    // (undocumented)
    protected _onAttached(): void;
    // (undocumented)
    protected _onDetached(): void;
    get particleAccelMax(): number;
    set particleAccelMax(value: number);
    get particleAccelMin(): number;
    set particleAccelMin(value: number);
    get particleLifeMax(): number;
    set particleLifeMax(value: number);
    get particleLifeMin(): number;
    set particleLifeMin(value: number);
    get particleRotationMax(): number;
    set particleRotationMax(value: number);
    get particleRotationMin(): number;
    set particleRotationMin(value: number);
    get particleSize1Max(): number;
    set particleSize1Max(value: number);
    get particleSize1Min(): number;
    set particleSize1Min(value: number);
    get particleSize2Max(): number;
    set particleSize2Max(value: number);
    get particleSize2Min(): number;
    set particleSize2Min(value: number);
    get particleVelocityMax(): number;
    set particleVelocityMax(value: number);
    get particleVelocityMin(): number;
    set particleVelocityMin(value: number);
    // (undocumented)
    resizeVertexBuffers(device: AbstractDevice): void;
    get scalar(): number;
    set scalar(value: number);
    // (undocumented)
    update(): void;
    get wind(): Vector3;
    set wind(value: Vector3);
    get worldSpace(): boolean;
    set worldSpace(value: boolean);
}

// Warning: (ae-forgotten-export) The symbol "PBRMetallicRoughnessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class PBRMetallicRoughnessMaterial extends PBRMetallicRoughnessMaterial_base implements Clonable<PBRMetallicRoughnessMaterial> {
    constructor();
    // (undocumented)
    clone(): PBRMetallicRoughnessMaterial;
    // (undocumented)
    copyFrom(other: this): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// Warning: (ae-forgotten-export) The symbol "PBRSpecularGlossinessMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class PBRSpecularGlossinessMaterial extends PBRSpecularGlossinessMaterial_base implements Clonable<PBRSpecularGlossinessMaterial> {
    constructor();
    // (undocumented)
    clone(): PBRSpecularGlossinessMaterial;
    // (undocumented)
    copyFrom(other: this): void;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    get vertexNormal(): boolean;
    set vertexNormal(val: boolean);
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
    get vertexTangent(): boolean;
    set vertexTangent(val: boolean);
}

// Warning: (ae-internal-missing-underscore) The name "PCFOPT" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class PCFOPT extends ShadowImpl {
    constructor(kernelSize?: number);
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    postRenderShadowMap(): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    sampleShadowMap(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleShadowMapCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, split: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    protected _shadowSampler: TextureSampler;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "PCFPD" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class PCFPD extends ShadowImpl {
    constructor(tapCount?: number, sampleRadius?: number);
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    postRenderShadowMap(): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    protected _sampleRadius: number;
    // (undocumented)
    sampleShadowMap(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    sampleShadowMapCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, coords: PBShaderExp, split: PBShaderExp, z: PBShaderExp, bias: PBShaderExp): PBShaderExp;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    protected _shadowSampler: TextureSampler;
    // (undocumented)
    get tapCount(): number;
    set tapCount(val: number);
    // (undocumented)
    protected _tapCount: number;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// @public
export function perlinNoise2D(scope: PBInsideFunctionScope, p: PBShaderExp): any;

// @public
export function perlinNoise3D(scope: PBInsideFunctionScope, p: PBShaderExp): any;

// @public
export class PerspectiveCamera extends Camera implements NodeClonable<PerspectiveCamera> {
    constructor(scene: Scene, fovY?: number, aspect?: number, near?: number, far?: number);
    get aspect(): number;
    set aspect(val: number);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): PerspectiveCamera;
    // @internal (undocumented)
    protected _computeProj(): void;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    get far(): number;
    set far(val: number);
    get fovY(): number;
    set fovY(val: number);
    get near(): number;
    set near(val: number);
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
    setPerspective(fovY: number, aspect: number, zNear: number, zFar: number): this;
    setProjectionMatrix(matrix: Matrix4x4): void;
    get window(): number[];
    set window(val: number[]);
}

// @public
export type PickResult = {
    distance: number;
    intersectedPoint: Vector3;
    drawable: Drawable;
    target: PickTarget;
};

// @public
export type PickTarget = {
    node: SceneNode;
    label?: string;
};

// @public
export interface PlaneCreationOptions extends ShapeCreationOptions {
    anchor?: number;
    anchorX?: number;
    anchorY?: number;
    resolution?: number;
    resolutionX?: number;
    resolutionY?: number;
    size?: number;
    sizeX?: number;
    sizeY?: number;
    twoSided?: boolean;
}

// @public
export class PlaneShape extends Shape<PlaneCreationOptions> implements Clonable<PlaneShape> {
    constructor(options?: PlaneCreationOptions);
    // (undocumented)
    clone(): PlaneShape;
    // (undocumented)
    static _defaultOptions: {
        size: number;
        resolution: number;
        twoSided: boolean;
        anchor: number;
        needNormal: boolean;
        needUV: boolean;
    };
    static generateData(options: PlaneCreationOptions, vertices: number[], normals: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): PrimitiveType;
    // (undocumented)
    get type(): string;
}

// @public
export type PlayAnimationOptions = {
    repeat?: number;
    speedRatio?: number;
    fadeIn?: number;
};

// @public
export class PointLight extends PunctualLight implements NodeClonable<PointLight> {
    constructor(scene: Scene);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): PointLight;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    // @override
    isPointLight(): this is PointLight;
    get range(): number;
    set range(val: number);
    // @internal (undocumented)
    protected _range: number;
    setRange(val: number): this;
}

// @public (undocumented)
export enum PostEffectLayer {
    // (undocumented)
    end = 2,
    // (undocumented)
    opaque = 0,
    // (undocumented)
    transparent = 1
}

// @public
export class PostWater extends AbstractPostEffect {
    constructor(elevation: number, waveGenerator: WaveGenerator);
    get antiReflectanceLeak(): number;
    set antiReflectanceLeak(val: number);
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get boundary(): Vector4;
    set boundary(val: Vector4);
    // (undocumented)
    get causticsFalloff(): number;
    set causticsFalloff(val: number);
    // (undocumented)
    get causticsIntensity(): number;
    set causticsIntensity(val: number);
    // (undocumented)
    get causticsSlopeMax(): number;
    set causticsSlopeMax(val: number);
    // (undocumented)
    get causticsSlopeMin(): number;
    set causticsSlopeMin(val: number);
    get depthMulti(): number;
    set depthMulti(val: number);
    get displace(): number;
    set displace(val: number);
    get elevation(): number;
    set elevation(val: number);
    get envMap(): TextureCube;
    set envMap(tex: TextureCube);
    get gridScale(): number;
    set gridScale(val: number);
    get refractionStrength(): number;
    set refractionStrength(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get speed(): number;
    set speed(val: number);
    get ssr(): boolean;
    set ssr(val: boolean);
    // (undocumented)
    get ssrIterations(): number;
    set ssrIterations(val: number);
    // (undocumented)
    get ssrMaxDistance(): number;
    set ssrMaxDistance(val: number);
    // (undocumented)
    get ssrThickness(): number;
    set ssrThickness(val: number);
    // (undocumented)
    get waveGenerator(): WaveGenerator;
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// Warning: (ae-forgotten-export) The symbol "DistributionType" needs to be exported by the entry point index.d.ts
//
// @public
export function prefilterCubemap(tex: TextureCube, type: DistributionType, destTexture: TextureCube | FrameBuffer, numSamples?: number): void;

// @public
export class Primitive implements Clonable<Primitive> {
    constructor();
    // @internal
    addBoundingboxChangeCallback(cb: () => void): void;
    // @internal (undocumented)
    protected _bbox: BoundingVolume;
    // @internal (undocumented)
    protected _bboxChangeCallback: (() => void)[];
    get changeTag(): number;
    // (undocumented)
    clone(): Primitive;
    // (undocumented)
    copyFrom(other: this): void;
    createAndSetIndexBuffer(data: Uint16Array | Uint32Array, dynamic?: boolean): IndexBuffer;
    createAndSetVertexBuffer(format: VertexAttribFormat[] | VertexAttribFormat, data: TypedArray, stepMode?: VertexStepMode): StructuredBuffer;
    // @internal (undocumented)
    protected _defaultIndexCount: number;
    dispose(): void;
    get disposed(): boolean;
    // @internal (undocumented)
    protected _disposed: boolean;
    draw(): void;
    drawInstanced(numInstances: number): void;
    // @internal (undocumented)
    static findPrimitiveById(id: string): Primitive;
    getBoundingVolume(): BoundingVolume;
    getIndexBuffer(): IndexBuffer;
    getNumFaces(): number;
    getNumVertices(): number;
    getVertexBuffer(semantic: VertexSemantic): StructuredBuffer;
    getVertexBufferInfo(semantic: VertexSemantic): VertexBufferInfo;
    // @internal
    get id(): number;
    // @internal (undocumented)
    protected _id: number;
    get indexCount(): number;
    set indexCount(val: number);
    // @internal (undocumented)
    protected _indexCount: number;
    get indexStart(): number;
    set indexStart(val: number);
    // @internal (undocumented)
    protected _indexStart: number;
    get persistentId(): string;
    set persistentId(val: string);
    // @internal (undocumented)
    protected _persistentId: string;
    get primitiveType(): PrimitiveType;
    set primitiveType(type: PrimitiveType);
    // @internal (undocumented)
    protected _primitiveType: PrimitiveType;
    raycast(ray: Ray): number;
    removeBoundingboxChangeCallback(cb: () => void): void;
    removeVertexBuffer(semantic: VertexSemantic): void;
    setBoundingVolume(bv: BoundingVolume): void;
    setIndexBuffer(buffer: IndexBuffer): void;
    setVertexBuffer(buffer: StructuredBuffer, stepMode?: VertexStepMode): StructuredBuffer<unknown>;
    // @internal (undocumented)
    protected _vertexLayout: VertexLayout;
    // @internal (undocumented)
    protected _vertexLayoutDirty: boolean;
    // @internal (undocumented)
    protected _vertexLayoutOptions: VertexLayoutOptions;
}

// Warning: (ae-internal-missing-underscore) The name "PrimitiveInstanceInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type PrimitiveInstanceInfo = {
    primitive: Primitive;
    numInstances: number;
    instanceDatas: Float32Array;
    mipLevels: Float32Array;
    maxMiplevel: number;
};

// @public
export function projectCubemap(tex: TextureCube): Promise<Vector3[]>;

// @public
export function projectCubemapCPU(input: TextureCube): Promise<Vector3[]>;

// @public (undocumented)
export type PropEdit = 'aabb' | 'quaternion' | 'proptrack';

// @public (undocumented)
export type PropertyAccessor<T = object> = {
    type: PropertyType;
    name: string;
    label?: string;
    group?: string;
    phase?: number;
    options?: {
        minValue: number;
        maxValue: number;
        speed?: number;
    };
    enum?: {
        labels: string[];
        values: (number | string)[];
    };
    instance?: boolean;
    objectTypes?: GenericConstructor[];
    readonly?: boolean;
    default?: any;
    animatable?: boolean;
    persistent?: boolean;
    edit?: PropEdit;
    get: (this: T, value: PropertyValue) => void;
    set?: (this: T, value: PropertyValue, index?: number) => void | Promise<void>;
    create?: (this: T, ctor: GenericConstructor, index: number) => object;
    delete?: (this: T, index: number) => object;
    add?: (this: T, value: PropertyValue, index?: number) => void | Promise<void>;
    isValid?: (this: T) => boolean;
    isNullable?: (this: T, index: number) => boolean;
    isHidden?: (this: T, index: number) => boolean;
    command?: (this: T, index: number) => boolean;
    getDefaultValue?: (this: T) => any;
};

// @public
export class PropertyTrack extends AnimationTrack<PropertyValue> {
    constructor(prop: PropertyAccessor, value?: number[], embedded?: boolean);
    // (undocumented)
    applyState(target: object, state: PropertyValue): void;
    // (undocumented)
    calculateState(target: unknown, currentTime: number): PropertyValue;
    // (undocumented)
    getBlendId(): unknown;
    // (undocumented)
    getDuration(): number;
    // (undocumented)
    getProp(): PropertyAccessor;
    // (undocumented)
    get interpolator(): Interpolator;
    set interpolator(interpolator: Interpolator);
    // (undocumented)
    get interpolatorAlpha(): Interpolator;
    set interpolatorAlpha(interpolator: Interpolator);
    // (undocumented)
    mixState(a: PropertyValue, b: PropertyValue, t: number): PropertyValue;
    // (undocumented)
    get target(): string;
    set target(val: string);
}

// @public (undocumented)
export type PropertyType = 'bool' | 'int' | 'float' | 'vec2' | 'vec3' | 'vec4' | 'int2' | 'int3' | 'int4' | 'string' | 'rgb' | 'rgba' | 'object' | 'object_array' | 'command';

// @public (undocumented)
export type PropertyValue = {
    num?: number[];
    str?: string[];
    bool?: boolean[];
    object?: object[];
};

// @public
export class PunctualLight extends BaseLight {
    constructor(scene: Scene, type: number);
    get castShadow(): boolean;
    set castShadow(b: boolean);
    // @internal (undocumented)
    protected _castShadow: boolean;
    get color(): Vector4;
    set color(clr: Vector4);
    // @internal (undocumented)
    protected _color: Vector4;
    // @internal (undocumented)
    computeUniforms(): void;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    // @override
    isPunctualLight(): this is PunctualLight;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    setCastShadow(b: boolean): this;
    setColor(color: Vector4): this;
    get shadow(): ShadowMapper;
    // @internal (undocumented)
    protected _shadowMapper: ShadowMapper;
}

// Warning: (ae-internal-missing-underscore) The name "Quadtree" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Quadtree {
    constructor(terrain: Terrain);
    // (undocumented)
    build(patchSize: number, rootSizeX: number, rootSizeZ: number, elevations: Float32Array, scale: Vector3, vertexCacheSize: number): boolean;
    // (undocumented)
    cull(visitor: CullVisitor, viewPoint: Vector3, worldMatrix: Matrix4x4): number;
    // (undocumented)
    cull_r(visitor: CullVisitor, node: QuadtreeNode, viewPoint: Vector3, worldMatrix: Matrix4x4, frustum: Frustum, cliptest: boolean, ignorePatch: boolean): number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    // (undocumented)
    getBoundingBox(bbox: BoundingBox): void;
    // (undocumented)
    getElevations(): Float32Array;
    // (undocumented)
    getHeightField(): HeightField;
    // (undocumented)
    getIndices(): IndexBuffer;
    // (undocumented)
    getIndicesWireframe(): IndexBuffer;
    // (undocumented)
    getPatchSize(): number;
    // (undocumented)
    getPrimitiveCount(): number;
    // (undocumented)
    getPrimitiveType(): PrimitiveType;
    // (undocumented)
    getRootSize(): number;
    // (undocumented)
    getRootSizeX(): number;
    // (undocumented)
    getRootSizeZ(): number;
    // (undocumented)
    getScaleX(): number;
    // (undocumented)
    getScaleZ(): number;
    // (undocumented)
    getTerrain(): Terrain;
    // (undocumented)
    line(strip: Uint16Array): Uint16Array;
    // (undocumented)
    get normalMap(): Texture2D;
    // (undocumented)
    get rootNode(): QuadtreeNode;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
    // (undocumented)
    strip(vertexCacheSize: number): Uint16Array;
    // (undocumented)
    get terrain(): Terrain;
}

// Warning: (ae-internal-missing-underscore) The name "QuadtreeNode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class QuadtreeNode {
    constructor();
    // (undocumented)
    addGrassCluster(grassCluster: GrassCluster): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getBoundingbox(): BoundingBox;
    // (undocumented)
    getChild(index: number): QuadtreeNode;
    // (undocumented)
    getParent(): QuadtreeNode;
    // (undocumented)
    getPatch(): TerrainPatch;
    // Warning: (ae-forgotten-export) The symbol "GrassCluster" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get grassClusters(): GrassCluster[];
    // (undocumented)
    initialize(quadtree: Quadtree, parent: QuadtreeNode, rowIndex: number, colIndex: number, baseVertices: Float32Array, normals: Vector3[], heightScale: number, elevations: Float32Array): boolean;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
}

// @public
export const QUEUE_OPAQUE = 1;

// @public
export const QUEUE_TRANSPARENT = 2;

// @public (undocumented)
export function rayIntersectSphere(scope: PBInsideFunctionScope, f3Center: PBShaderExp, fRadius: PBShaderExp, f3RayStart: PBShaderExp, f3RayDir: PBShaderExp): PBShaderExp;

// @public (undocumented)
export function rayleighCoefficient(scope: PBInsideFunctionScope, fRayleighScatteringHeight: PBShaderExp, fH: PBShaderExp): any;

// @public (undocumented)
export function rayleighPhase(scope: PBInsideFunctionScope, fCosTheta: PBShaderExp): any;

// @public
export function releaseObject(obj: Disposable): void;

// @public
export const RENDER_PASS_TYPE_DEPTH = 2;

// @public
export const RENDER_PASS_TYPE_LIGHT = 0;

// @public
export const RENDER_PASS_TYPE_OBJECT_COLOR = 3;

// @public
export const RENDER_PASS_TYPE_SHADOWMAP = 1;

// @public (undocumented)
export function renderAPLut(params: AtmosphereParams): void;

// @public (undocumented)
export function renderAtmosphereLUTs(params?: Partial<AtmosphereParams>): void;

// Warning: (ae-internal-missing-underscore) The name "RenderItemList" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RenderItemList {
    // (undocumented)
    opaque: RenderItemListBundle;
    // (undocumented)
    transmission: RenderItemListBundle;
    // (undocumented)
    transmission_trans: RenderItemListBundle;
    // (undocumented)
    transparent: RenderItemListBundle;
}

// Warning: (ae-internal-missing-underscore) The name "RenderItemListBundle" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface RenderItemListBundle {
    // (undocumented)
    lit: RenderItemListInfo[];
    // (undocumented)
    unlit: RenderItemListInfo[];
}

// Warning: (ae-internal-missing-underscore) The name "RenderItemListInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface RenderItemListInfo {
    // (undocumented)
    instanceItemList: RenderQueueItem[];
    // (undocumented)
    instanceList: Record<string, BatchDrawable[]>;
    // (undocumented)
    instanceRenderBundle?: RenderBundleWrapper;
    // (undocumented)
    itemList: RenderQueueItem[];
    // (undocumented)
    materialList: Set<Material>;
    // (undocumented)
    morphItemList: RenderQueueItem[];
    // (undocumented)
    morphRenderBundle?: RenderBundleWrapper;
    // Warning: (ae-forgotten-export) The symbol "RenderBundleWrapper" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    renderBundle?: RenderBundleWrapper;
    // (undocumented)
    renderQueue: RenderQueue;
    // (undocumented)
    skinAndMorphItemList: RenderQueueItem[];
    // (undocumented)
    skinAndMorphRenderBundle?: RenderBundleWrapper;
    // (undocumented)
    skinItemList: RenderQueueItem[];
    // (undocumented)
    skinRenderBundle?: RenderBundleWrapper;
}

// @public (undocumented)
export function renderMultiScatteringLut(params: AtmosphereParams): void;

// @public
export abstract class RenderPass {
    constructor(type: number);
    get clearColor(): Vector4;
    set clearColor(color: Vector4);
    // @internal (undocumented)
    protected _clearColor: Vector4;
    get clearDepth(): number;
    set clearDepth(depth: number);
    // @internal (undocumented)
    protected _clearDepth: number;
    get clearStencil(): number;
    set clearStencil(stencil: number);
    // @internal (undocumented)
    protected _clearStencil: number;
    cullScene(ctx: DrawContext, cullCamera: Camera): RenderQueue;
    dispose(): void;
    // @internal (undocumented)
    protected drawItemList(itemList: RenderItemListInfo, ctx: DrawContext, reverseWinding: boolean): void;
    // @internal (undocumented)
    protected drawScene(ctx: DrawContext, cullCamera: Camera, renderQueue?: RenderQueue): void;
    // @internal (undocumented)
    protected getGlobalBindGroup(ctx: DrawContext): BindGroup;
    // @internal (undocumented)
    getGlobalBindGroupHash(ctx: DrawContext): string;
    // @internal (undocumented)
    protected abstract _getGlobalBindGroupHash(ctx: DrawContext): any;
    // @internal (undocumented)
    protected _globalBindGroups: Record<string, BindGroup>;
    // @internal (undocumented)
    isAutoFlip(ctx: DrawContext): boolean;
    render(ctx: DrawContext, cullCamera?: Camera, renderQueue?: RenderQueue): void;
    // @internal (undocumented)
    protected abstract renderItems(ctx: DrawContext, renderQueue: RenderQueue): any;
    get type(): number;
    // @internal (undocumented)
    protected _type: number;
}

// @public
export class RenderQueue {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "InstanceBindGroupAllocator" which is marked as @internal
    constructor(renderPass: RenderPass, bindGroupAllocator?: InstanceBindGroupAllocator);
    // Warning: (ae-incompatible-release-tags) The symbol "binaryInsert" is marked as @public, but its signature references "RenderQueueItem" which is marked as @internal
    //
    // (undocumented)
    binaryInsert(itemList: RenderQueueItem[], item: RenderQueueItem): void;
    // @internal (undocumented)
    dispose(): void;
    get disposed(): boolean;
    get drawTransparent(): boolean;
    // @internal (undocumented)
    end(camera: Camera, createRenderBundles?: boolean): this;
    // @internal (undocumented)
    getDrawableByColor(c: Uint8Array): Drawable;
    // Warning: (ae-incompatible-release-tags) The symbol "getInstanceInfo" is marked as @public, but its signature references "DrawableInstanceInfo" which is marked as @internal
    getInstanceInfo(drawable: Drawable): DrawableInstanceInfo;
    // @internal
    getMaxBatchSize(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "itemList" is marked as @public, but its signature references "RenderItemList" which is marked as @internal
    get itemList(): RenderItemList;
    // @internal (undocumented)
    needSceneColor(): boolean;
    // @internal (undocumented)
    needSceneColorWithDepth(): boolean;
    // @internal (undocumented)
    needSceneDepth(): boolean;
    push(camera: Camera, drawable: Drawable): void;
    pushLight(light: PunctualLight): void;
    pushRenderQueue(queue: RenderQueue): void;
    // Warning: (ae-incompatible-release-tags) The symbol "ref" is marked as @public, but its signature references "RenderQueueRef" which is marked as @internal
    get ref(): RenderQueueRef;
    get renderPass(): RenderPass;
    reset(): void;
    get shadowedLights(): PunctualLight[];
    sortTransparentItems(cameraPos: Vector3): void;
    get sunLight(): DirectionalLight;
    set sunLight(light: DirectionalLight);
    get unshadowedLights(): PunctualLight[];
}

// Warning: (ae-internal-missing-underscore) The name "RenderQueueItem" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RenderQueueItem {
    // (undocumented)
    drawable: Drawable;
    // (undocumented)
    instanceColor?: Vector4;
    // (undocumented)
    instanceData: InstanceData;
    // (undocumented)
    sortDistance: number;
}

// Warning: (ae-internal-missing-underscore) The name "RenderQueueRef" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface RenderQueueRef {
    // (undocumented)
    ref: RenderQueue;
}

// @public (undocumented)
export function renderSkyViewLut(params: AtmosphereParams): void;

// @public (undocumented)
export function renderTransmittanceLut(params: AtmosphereParams): void;

// @public
export function retainObject(obj: Disposable): void;

// @public
export type SamplerType = 'clamp_linear' | 'clamp_linear_nomip' | 'clamp_nearest' | 'clamp_nearest_nomip' | 'repeat_linear' | 'repeat_linear_nomip' | 'repeat_nearest' | 'repeat_nearest_nomip';

// @public
export class SAO extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get bias(): number;
    set bias(val: number);
    get blurDepthCutoff(): number;
    set blurDepthCutoff(val: number);
    get blurKernelSize(): number;
    set blurKernelSize(val: number);
    get blurStdDev(): number;
    set blurStdDev(val: number);
    get intensity(): number;
    set intensity(val: number);
    get minResolution(): number;
    set minResolution(val: number);
    get radius(): number;
    set radius(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
    get scale(): number;
    set scale(val: number);
}

// @public (undocumented)
export function scattering(scope: PBInsideFunctionScope, stParams: PBShaderExp, f3Pos: PBShaderExp, f3ViewDir: PBShaderExp): PBShaderExp;

// Warning: (ae-forgotten-export) The symbol "Scene_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Scene extends Scene_base {
    constructor(name?: string);
    get boundingBox(): AABB;
    constructRay(camera: Camera, viewportWidth: number, viewportHeight: number, screenX: number, screenY: number, invModelMatrix?: Matrix4x4): Ray;
    dispose(): void;
    get env(): Environment;
    // @internal (undocumented)
    protected _env: Environment;
    findNodeById<T extends SceneNode>(id: string): T;
    // @internal (undocumented)
    frameUpdate(): void;
    // @internal (undocumented)
    frameUpdatePerCamera(camera: Camera): void;
    // @internal (undocumented)
    getRenderer(): typeof SceneRenderer;
    get id(): number;
    // @internal (undocumented)
    protected _id: number;
    // @internal (undocumented)
    invalidateNodePlacement(node: GraphNode): void;
    get name(): string;
    set name(val: string);
    // @internal (undocumented)
    protected _name: string;
    // @internal (undocumented)
    protected _nodePlaceList: Set<GraphNode>;
    // @internal (undocumented)
    protected _nodeUpdateQueue: DWeakRef<SceneNode>[];
    get octree(): Octree;
    // @internal (undocumented)
    protected _octree: Octree;
    // @internal (undocumented)
    protected _perCameraUpdateQueue: DWeakRef<SceneNode>[];
    queuePerCameraUpdateNode(node: SceneNode): void;
    queueUpdateNode(node: SceneNode): void;
    raycast(ray: Ray, length?: number): {
        target: PickTarget;
        dist: number;
        point: Vector3;
    };
    get rootNode(): SceneNode;
    // @internal (undocumented)
    protected _rootNode: DRef<SceneNode>;
    // @internal (undocumented)
    protected _updateFrame: number;
    updateNodePlacement(octree: Octree, list: Set<GraphNode>): void;
}

// Warning: (ae-forgotten-export) The symbol "SceneNode_base" needs to be exported by the entry point index.d.ts
//
// @public
export class SceneNode extends SceneNode_base implements NodeClonable<SceneNode> {
    constructor(scene: Scene);
    // (undocumented)
    get animationSet(): AnimationSet;
    // @internal (undocumented)
    protected _animationSet: DRef<AnimationSet>;
    get attached(): boolean;
    // @internal (undocumented)
    protected _attached(): void;
    // (undocumented)
    static readonly BBOXDRAW_DISABLED = 0;
    // (undocumented)
    static readonly BBOXDRAW_INHERITED = -1;
    // (undocumented)
    static readonly BBOXDRAW_LOCAL = 1;
    // (undocumented)
    static readonly BBOXDRAW_WORLD = 2;
    get boundingBoxDrawMode(): number;
    set boundingBoxDrawMode(mode: number);
    // @internal (undocumented)
    protected _boxDrawMode: number;
    // @internal (undocumented)
    protected _bv: BoundingVolume;
    // @internal (undocumented)
    protected _bvDirty: boolean;
    // @internal (undocumented)
    protected _bvWorld: BoundingVolume;
    calculateLocalTransform(outMatrix: Matrix4x4): void;
    calculateWorldTransform(outMatrix: Matrix4x4): void;
    get children(): DRef<SceneNode>[];
    // @internal (undocumented)
    protected _children: DRef<SceneNode>[];
    // @internal (undocumented)
    protected _clipMode: boolean;
    get clipTestEnabled(): boolean;
    set clipTestEnabled(val: boolean);
    clone(method: NodeCloneMethod, recursive: boolean): SceneNode;
    computeBoundingVolume(): BoundingVolume;
    get computedBoundingBoxDrawMode(): number;
    computeWorldBoundingVolume(localBV: BoundingVolume): BoundingVolume;
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    // @internal (undocumented)
    protected _detached(): void;
    dispose(): void;
    get disposed(): boolean;
    // @internal (undocumented)
    protected _disposed: boolean;
    getBoundingVolume(): BoundingVolume;
    getWorldBoundingVolume(): BoundingVolume;
    getWorldPosition(outPos?: Vector3): Vector3;
    get gpuPickable(): boolean;
    set gpuPickable(val: boolean);
    // @internal (undocumented)
    protected _gpuPickable: boolean;
    hasChild(child: SceneNode): boolean;
    get hidden(): boolean;
    // @internal (undocumented)
    protected _id: string;
    invalidateBoundingVolume(): void;
    invalidateWorldBoundingVolume(transformChanged: boolean): void;
    get invWorldMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _invWorldMatrix: Matrix4x4;
    isBatchGroup(): this is BatchGroup;
    isCamera(): this is Camera;
    isClipmapTerrain(): this is ClipmapTerrain;
    isGraphNode(): this is GraphNode;
    isLight(): this is BaseLight;
    isMesh(): this is Mesh;
    isParentOf(child: SceneNode): boolean;
    isParticleSystem(): this is ParticleSystem;
    isPunctualLight(): this is PunctualLight;
    isTerrain(): this is Terrain;
    isWater(): this is Water;
    iterate(callback: NodeIterateFunc): boolean;
    iterateBottomToTop(callback: NodeIterateFunc): boolean;
    get localMatrix(): Matrix4x4;
    set localMatrix(matrix: Matrix4x4);
    // @internal (undocumented)
    protected _localMatrix: Matrix4x4;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    moveBy(delta: Vector3): this;
    get name(): string;
    set name(val: string);
    // @internal (undocumented)
    protected _name: string;
    // @internal (undocumented)
    notifyHiddenChanged(): void;
    protected _onAttached(): void;
    protected _onDetached(): void;
    // @internal (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    otherToThis(other: SceneNode, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    otherToThis(other: SceneNode, v: Vector4, result?: Vector4): Vector4;
    get parent(): SceneNode;
    set parent(p: SceneNode);
    // @internal (undocumented)
    protected _parent: SceneNode;
    get persistentId(): string;
    set persistentId(id: string);
    get pickable(): boolean;
    set pickable(val: boolean);
    // @internal (undocumented)
    protected _pickable: boolean;
    // @internal (undocumented)
    get placeToOctree(): boolean;
    set placeToOctree(val: boolean);
    get position(): Vector3;
    set position(val: Vector3);
    // @internal (undocumented)
    protected _position: ObservableVector3;
    remove(): this;
    removeChildren(): void;
    reparent(p?: SceneNode): this;
    get rotation(): Quaternion;
    set rotation(val: Quaternion);
    // @internal (undocumented)
    protected _rotation: ObservableQuaternion;
    get scale(): Vector3;
    set scale(val: Vector3);
    scaleBy(factor: Vector3): this;
    // @internal (undocumented)
    protected _scaling: ObservableVector3;
    get scene(): Scene;
    // @internal (undocumented)
    protected _scene: Scene;
    get sealed(): boolean;
    set sealed(val: boolean);
    setBoundingVolume(bv: BoundingVolume): void;
    setLocalTransform(matrix: Matrix4x4): this;
    // @internal (undocumented)
    protected _setParent(p: SceneNode): void;
    // (undocumented)
    get sharedModel(): SharedModel;
    set sharedModel(model: SharedModel);
    // @internal (undocumented)
    protected _sharedModel: DRef<SharedModel>;
    get showState(): SceneNodeVisible;
    set showState(val: SceneNodeVisible);
    thisToOther(other: SceneNode, v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToOther(other: SceneNode, v: Vector4, result?: Vector4): Vector4;
    thisToWorld(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    thisToWorld(v: Vector4, result?: Vector4): Vector4;
    // @internal (undocumented)
    protected _tmpLocalMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _tmpWorldMatrix: Matrix4x4;
    // @internal (undocumented)
    protected _transformChangeCallback: () => void;
    // @internal (undocumented)
    get transformTag(): number;
    // @internal (undocumented)
    protected _transformTag: number;
    traverse(v: Visitor<SceneNode>): void;
    update(frameId: number, elapsedInSeconds: number, deltaInSeconds: number): void;
    updatePerCamera(camera: Camera, elapsedInSeconds: number, deltaInSeconds: number): void;
    // @internal (undocumented)
    protected _visible: SceneNodeVisible;
    // @internal (undocumented)
    protected _visibleChanged(): void;
    get worldMatrix(): Matrix4x4;
    // @internal (undocumented)
    protected _worldMatrix: Matrix4x4;
    get worldMatrixDet(): number;
    // @internal (undocumented)
    protected _worldMatrixDet: number;
    worldToThis(v: Vector3, result?: Vector3): Vector3;
    // (undocumented)
    worldToThis(v: Vector4, result?: Vector4): Vector4;
}

// @public
export type SceneNodeVisible = 'visible' | 'inherit' | 'hidden';

// Warning: (ae-internal-missing-underscore) The name "SceneRenderer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class SceneRenderer {
    static get depthRenderPass(): DepthPass;
    // (undocumented)
    static freeClusteredLight(clusteredLight: ClusteredLight): void;
    // (undocumented)
    static getClusteredLight(): ClusteredLight;
    static renderScene(scene: Scene, camera: Camera): void;
    // (undocumented)
    protected static _renderScene(ctx: DrawContext): void;
    static get sceneRenderPass(): LightPass;
    // (undocumented)
    static setClearColor(color: Vector4): void;
    static get shadowMapRenderPass(): ShadowMapPass;
}

// @public (undocumented)
export type SerializableClass = {
    ctor: GenericConstructor;
    parent?: GenericConstructor;
    createFunc?: (ctx?: any, init?: any) => {
        obj: any;
        loadProps?: boolean;
    } | Promise<{
        obj: any;
        loadProps?: boolean;
    }>;
    getInitParams?: (obj: any) => any;
    getProps: () => PropertyAccessor<any>[];
    getAssets?: (obj: any) => string[];
    getEmbeddedAssets?: (obj: any) => (EmbeddedAssetInfo | Promise<EmbeddedAssetInfo>)[];
};

// @public (undocumented)
export type SerializationInfo = SerializableClass[];

// @public (undocumented)
export class SerializationManager {
    constructor(assetRegistry: AssetRegistry);
    // (undocumented)
    get assetRegistry(): AssetRegistry;
    // (undocumented)
    findAnimationTarget(node: SceneNode, track: PropertyTrack): object;
    // (undocumented)
    getClassByConstructor(ctor: GenericConstructor): SerializableClass;
    // (undocumented)
    getClassByName(className: string): SerializableClass;
    // (undocumented)
    getClassByObject(obj: object): SerializableClass;
    // (undocumented)
    getClassByProperty(prop: PropertyAccessor): SerializableClass;
    // (undocumented)
    getClasses(): SerializableClass[];
    // (undocumented)
    getPropertiesByClass(cls: SerializableClass): PropertyAccessor[];
    // (undocumented)
    getPropertyByClass(cls: SerializableClass, name: string): PropertyAccessor;
    // (undocumented)
    getPropertyByName(name: string): PropertyAccessor;
    // (undocumented)
    getPropertyName(prop: PropertyAccessor): string;
    // (undocumented)
    registerClass(cls: SerializableClass): void;
}

// @public (undocumented)
export function serializeObject(obj: any, manager: SerializationManager, json?: any, assetList?: Set<string>, embeddedAssetList?: Promise<EmbeddedAssetInfo>[]): any;

// @public (undocumented)
export function serializeObjectProps<T extends object>(obj: T, cls: SerializableClass, json: object, manager: SerializationManager, assetList?: Set<string>, embeddedAssetList?: Promise<EmbeddedAssetInfo>[]): void;

// @public
export class ShaderHelper {
    // (undocumented)
    static applyFog(scope: PBInsideFunctionScope, worldPos: PBShaderExp, color: PBShaderExp, ctx: DrawContext): void;
    // (undocumented)
    static readonly BILLBOARD_SPHERICAL = 1;
    // (undocumented)
    static readonly BILLBOARD_SYLINDRAL = 2;
    // (undocumented)
    static calculateMorphDelta(scope: PBInsideFunctionScope, attrib: number): PBShaderExp;
    static calculateShadow(scope: PBInsideFunctionScope, worldPos: PBShaderExp, NoL: PBShaderExp, ctx: DrawContext): PBShaderExp;
    // @internal (undocumented)
    static calculateShadowSpaceVertex(scope: PBInsideFunctionScope, worldPos: PBShaderExp, cascade?: PBShaderExp | number): PBShaderExp;
    static calculateSkinMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static computeFogFactor(scope: PBInsideFunctionScope, viewDir: PBShaderExp, fogType: PBShaderExp, fogParams: PBShaderExp): PBShaderExp;
    static computeFogFactorForType(scope: PBInsideFunctionScope, viewDir: PBShaderExp, fogParams: PBShaderExp, fogType: 'linear' | 'exp' | 'exp2'): PBShaderExp;
    // @internal (undocumented)
    static defaultSunDir: Vector3;
    static discardIfClipped(scope: PBInsideFunctionScope, worldPos: PBShaderExp): void;
    static encodeColorOutput(scope: PBInsideFunctionScope, outputColor: PBShaderExp): PBShaderExp;
    // (undocumented)
    static readonly FOG_TYPE_EXP = 2;
    // (undocumented)
    static readonly FOG_TYPE_EXP2 = 3;
    // (undocumented)
    static readonly FOG_TYPE_LINEAR = 1;
    // (undocumented)
    static readonly FOG_TYPE_NONE = 0;
    // (undocumented)
    static readonly FOG_TYPE_SCATTER = 4;
    static getAerialPerspectiveLUT(scope: PBInsideFunctionScope): PBShaderExp;
    static getAPDensity(scope: PBInsideFunctionScope): PBShaderExp;
    static getBakedSkyTexture(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getBoneInvBindMatrixUniformName(): string;
    // (undocumented)
    static getBoneMatricesUniformName(): string;
    // (undocumented)
    static getBoneTextureSizeUniformName(): string;
    static getCameraClipPlane(scope: PBInsideFunctionScope): any;
    static getCameraClipPlaneFlag(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraPosition(scope: PBInsideFunctionScope): PBShaderExp;
    static getCameraRoughnessFactor(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getCascadeDistances(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getClusteredLightIndexTexture(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getClusterParams(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getCountParams(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getDepthBiasScales(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getDepthBiasValues(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getDrawableBindGroupLayout(skinning: boolean, morphing: boolean, instancing: boolean): BindGroupLayout;
    static getElapsedTime(scope: PBInsideFunctionScope): PBShaderExp;
    static getElapsedTimeFrame(scope: PBInsideFunctionScope): PBShaderExp;
    static getEnvLightStrength(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogColor(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getFogType(scope: PBInsideFunctionScope): PBShaderExp;
    static getFramestamp(scope: PBInsideFunctionScope): PBShaderExp;
    static getGlobalUniforms(scope: PBInsideFunctionScope): PBShaderExp;
    static getHiZDepthTexture(scope: PBInsideFunctionScope): PBShaderExp;
    static getHiZDepthTextureMipLevelCount(scope: PBInsideFunctionScope): PBShaderExp;
    static getHiZDepthTextureSize(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getInstanceDataOffsetUniformName(): string;
    // (undocumented)
    static getInstanceDataStrideUniformName(): string;
    // (undocumented)
    static getInstanceDataUniformName(): string;
    static getInstancedUniform(scope: PBInsideFunctionScope, uniformIndex: number): PBShaderExp;
    static getInvProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getInvViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getJitteredInvVPMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getLightBufferUniformName(): string;
    // @internal (undocumented)
    static getLightColorAndIntensity(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightDirectionAndCutoff(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightPositionAndRange(scope: PBInsideFunctionScope, lightIndex: PBShaderExp | number): PBShaderExp;
    // @internal (undocumented)
    static getLightPositionAndRangeForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getLightTypeForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getLightViewMatrixForShadow(scope: PBInsideFunctionScope): PBShaderExp;
    static getLinearDepthTexture(scope: PBInsideFunctionScope): PBShaderExp;
    static getLinearDepthTextureSize(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getMorphDataUniformName(): string;
    // (undocumented)
    static getMorphInfoUniformName(): string;
    static getNormalMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getNumLights(scope: PBInsideFunctionScope): PBShaderExp;
    static getPrevUnjitteredViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getPrevWorldMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getPrevWorldMatrixFrameUniformName(): string;
    // (undocumented)
    static getPrevWorldMatrixUniformName(): string;
    static getProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getProjectionMatrixJitterValue(scope: PBInsideFunctionScope): PBShaderExp;
    static getRenderSize(scope: PBInsideFunctionScope): PBShaderExp;
    static getSceneColorTexture(scope: PBInsideFunctionScope): PBShaderExp;
    static getSceneColorTextureSize(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getShadowCameraParams(scope: PBInsideFunctionScope): PBShaderExp;
    static getShadowMap(scope: PBInsideFunctionScope): PBShaderExp;
    // @internal (undocumented)
    static getSunLightDir(scope: PBInsideFunctionScope): PBShaderExp;
    static getUnjitteredViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getViewProjectionMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    static getWorldMatrix(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    static getWorldMatrixUniformName(): string;
    static hasMorphing(scope: PBInsideFunctionScope): boolean;
    static hasSkinning(scope: PBInsideFunctionScope): boolean;
    static linearDepthToNonLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    // (undocumented)
    static readonly MATERIAL_INSTANCE_DATA_OFFSET = 9;
    static nonLinearDepthToLinear(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    static nonLinearDepthToLinearNormalized(scope: PBInsideFunctionScope, depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    static prepareFragmentShader(pb: ProgramBuilder, ctx: DrawContext): void;
    // @internal (undocumented)
    static prepareSkinAnimation(scope: PBInsideFunctionScope): void;
    static prepareVertexShader(pb: ProgramBuilder, ctx: DrawContext): void;
    // @internal (undocumented)
    static prepareVertexShaderCommon(pb: ProgramBuilder, ctx: DrawContext): void;
    static resolveMotionVector(scope: PBInsideFunctionScope, worldPos: PBShaderExp, prevWorldPos: PBShaderExp): void;
    static resolveVertexNormal(scope: PBInsideFunctionScope, normal?: PBShaderExp): PBShaderExp;
    static resolveVertexPosition(scope: PBInsideFunctionScope): PBShaderExp;
    static resolveVertexTangent(scope: PBInsideFunctionScope, tangent?: PBShaderExp): PBShaderExp;
    static sampleLinearDepth(scope: PBInsideFunctionScope, tex: PBShaderExp, uv: PBShaderExp, level: PBShaderExp | number): PBShaderExp;
    static sampleLinearDepthWithBackface(scope: PBInsideFunctionScope, tex: PBShaderExp, uv: PBShaderExp, level: PBShaderExp | number): PBShaderExp;
    // (undocumented)
    static samplePositionFromDepth(scope: PBInsideFunctionScope, depthTex: PBShaderExp, uv: PBShaderExp, mat: PBShaderExp, cameraNearFar: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    static setCameraUniforms(bindGroup: BindGroup, ctx: DrawContext, linear: boolean): void;
    static setClipSpacePosition(scope: PBInsideFunctionScope, pos: PBShaderExp): void;
    // @internal (undocumented)
    static setFogUniforms(bindGroup: BindGroup, fogType: number, fogColor: Vector4, fogParams: Vector4, apDensity: number, aerialPerspectiveLUT?: Texture2D): void;
    // @internal (undocumented)
    static setLightUniforms(bindGroup: BindGroup, ctx: DrawContext, clusterParams: Float32Array, countParams: Int32Array, lightBuffer: StructuredBuffer, lightIndexTexture: Texture2D): void;
    // @internal (undocumented)
    static setLightUniformsShadow(bindGroup: BindGroup, ctx: DrawContext, light: PunctualLight): void;
    // @internal (undocumented)
    static setLightUniformsShadowMap(bindGroup: BindGroup, ctx: DrawContext, light: PunctualLight): void;
    static vertexShaderDrawableStuff(scope: PBGlobalScope, skinning: boolean, morphing: boolean, instanced: boolean): void;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowConfig" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ShadowConfig {
    // (undocumented)
    depthBias?: number;
    // (undocumented)
    nearClip?: number;
    // (undocumented)
    normalBias?: number;
    // (undocumented)
    numCascades?: number;
    // (undocumented)
    shadowMapSize: number;
    // (undocumented)
    splitLambda?: number;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowMapParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ShadowMapParams = {
    lightType: number;
    shaderHash: string;
    numShadowCascades: number;
    depthClampEnabled: boolean;
    cascadeDistances: Vector4;
    depthBiasValues: Vector4[];
    depthBiasScales: Vector4;
    cameraParams: Vector4;
    shadowMatrices: Float32Array;
    shadowMapFramebuffer: FrameBuffer;
    shadowMap: BaseTexture;
    shadowMapSampler: TextureSampler;
    impl: ShadowImpl;
    implData: unknown;
};

// @public
export class ShadowMapPass extends RenderPass {
    constructor();
    // @internal (undocumented)
    protected _currentLight: PunctualLight;
    // @internal (undocumented)
    protected _getGlobalBindGroupHash(ctx: DrawContext): string;
    get light(): PunctualLight;
    set light(light: PunctualLight);
    // @internal (undocumented)
    protected renderItems(ctx: DrawContext, renderQueue: RenderQueue): void;
}

// @public
export class ShadowMapper {
    constructor(light: PunctualLight);
    // @internal (undocumented)
    protected calcDepthBiasParams(camera: Camera, shadowMapSize: number, depthBias: number, normalBias: number, depthScale: number, result: Vector4): void;
    // @internal (undocumented)
    calcSplitDistances(nearPlane: number, farPlane: number, numCascades: number): number[];
    // @internal (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    static computeShadowBias(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, z: PBShaderExp, NdotL: PBShaderExp, linear: boolean): PBShaderExp;
    // @internal (undocumented)
    static computeShadowBiasCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // @internal (undocumented)
    protected _config: ShadowConfig;
    // (undocumented)
    copyFrom(other: ShadowMapper): void;
    // @internal (undocumented)
    protected createLightCameraDirectional(sceneAABB: AABB, sceneCamera: Camera, lightCamera: Camera, cropMatrix?: Matrix4x4, border?: number): void;
    // @internal (undocumented)
    protected createLightCameraPoint(lightCamera: Camera): void;
    // @internal (undocumented)
    protected createLightCameraSpot(lightCamera: Camera): void;
    // @internal (undocumented)
    protected createTexture(target: TextureType, format: TextureFormat, width: number, height: number, depth: number): Texture2D | TextureCube | Texture2DArray;
    get depthBias(): number;
    set depthBias(val: number);
    get esmBlur(): boolean;
    set esmBlur(val: boolean);
    // @internal (undocumented)
    protected _esmBlur: boolean;
    get esmBlurKernelSize(): number;
    set esmBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _esmBlurKernelSize: number;
    get esmBlurRadius(): number;
    set esmBlurRadius(val: number);
    // @internal (undocumented)
    protected _esmBlurRadius: number;
    get esmDepthScale(): number;
    set esmDepthScale(val: number);
    // @internal (undocumented)
    protected _esmDepthScale: number;
    // @internal (undocumented)
    static fetchTemporalFramebuffer(autoRelease: boolean, lightType: number, numCascades: number, width: number, height: number, colorFormat: TextureFormat, depthFormat: TextureFormat, mipmapping?: boolean): FrameBuffer<unknown>;
    // @internal (undocumented)
    getShaderHash(shadowMapParams: ShadowMapParams): string;
    // @internal (undocumented)
    protected _impl: ShadowImpl;
    // @internal (undocumented)
    protected isTextureInvalid(texture: Texture2D | TextureCube | Texture2DArray, target: TextureType, format: TextureFormat, width: number, height: number): boolean;
    get light(): PunctualLight;
    // @internal (undocumented)
    protected _light: PunctualLight;
    get mode(): ShadowMode;
    set mode(mode: ShadowMode);
    get nearClip(): number;
    set nearClip(val: number);
    get normalBias(): number;
    set normalBias(val: number);
    get numShadowCascades(): number;
    set numShadowCascades(num: number);
    get pcfKernelSize(): number;
    set pcfKernelSize(val: number);
    // @internal (undocumented)
    protected _pcfKernelSize: number;
    get pdSampleCount(): number;
    set pdSampleCount(val: number);
    // @internal (undocumented)
    protected _pdSampleCount: number;
    get pdSampleRadius(): number;
    set pdSampleRadius(val: number);
    // @internal (undocumented)
    protected _pdSampleRadius: number;
    // @internal (undocumented)
    protected postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // @internal (undocumented)
    static releaseTemporalResources(ctx: DrawContext): void;
    // @internal (undocumented)
    render(ctx: DrawContext, renderPass: ShadowMapPass): void;
    // @internal (undocumented)
    protected _resourceDirty: boolean;
    get shadowDistance(): number;
    set shadowDistance(val: number);
    // @internal (undocumented)
    protected _shadowDistance: number;
    get shadowMapSize(): number;
    set shadowMapSize(num: number);
    // @internal (undocumented)
    protected _shadowMode: ShadowMode;
    get shadowRegion(): AABB;
    set shadowRegion(region: AABB);
    // @internal (undocumented)
    protected _shadowRegion: AABB;
    get splitLambda(): number;
    set splitLambda(val: number);
    // @internal (undocumented)
    protected updateResources(shadowMapParams: ShadowMapParams): void;
    get vsmBlurKernelSize(): number;
    set vsmBlurKernelSize(val: number);
    // @internal (undocumented)
    protected _vsmBlurKernelSize: number;
    get vsmBlurRadius(): number;
    set vsmBlurRadius(val: number);
    // @internal (undocumented)
    protected _vsmBlurRadius: number;
    get vsmDarkness(): number;
    set vsmDarkness(val: number);
    // @internal (undocumented)
    protected _vsmDarkness: number;
}

// Warning: (ae-internal-missing-underscore) The name "ShadowMapType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ShadowMapType = Texture2D | TextureCube | Texture2DArray;

// @public
export type ShadowMode = 'hard' | 'vsm' | 'esm' | 'pcf-pd' | 'pcf-opt';

// @public
export abstract class Shape<T extends ShapeCreationOptions = ShapeCreationOptions> extends Primitive implements Clonable<Shape<T>> {
    constructor(options?: T);
    // (undocumented)
    abstract clone(): Shape<T>;
    // @internal (undocumented)
    protected _create(options?: T): boolean;
    // (undocumented)
    static _defaultOptions: {
        needNormal: boolean;
        needUV: boolean;
    };
    normalizeOptions(options?: T): T;
    get options(): T;
    set options(options: T);
    // (undocumented)
    protected _options: T;
    // @internal (undocumented)
    protected static _transform(matrix: Matrix4x4, vertices: number[], normals: number[], offset: number): void;
    abstract get type(): string;
}

// @public
export interface ShapeCreationOptions {
    needNormal?: boolean;
    needUV?: boolean;
    transform?: Matrix4x4;
}

// @public (undocumented)
export type ShapeOptionType<ST extends ShapeType> = ST extends Shape<infer U> ? U : never;

// @public (undocumented)
export type ShapeType = BoxShape | BoxFrameShape | SphereShape | CylinderShape | PlaneShape | TorusShape;

// @public
export class SharedModel {
    constructor(name?: string);
    get activeScene(): number;
    set activeScene(val: number);
    addAnimation(animation: AssetAnimationData): void;
    addNode(parent: AssetHierarchyNode, index: number, name: string): AssetHierarchyNode;
    addSkeleton(skeleton: AssetSkeleton): void;
    get animations(): AssetAnimationData[];
    // (undocumented)
    createSceneNode(scene: Scene, instancing: boolean): SceneNode;
    dispose(): void;
    get disposed(): boolean;
    get name(): string;
    set name(val: string);
    get nodes(): AssetHierarchyNode[];
    get scenes(): AssetScene[];
    get skeletons(): AssetSkeleton[];
}

// @public
export class Skeleton {
    constructor(joints: SceneNode[], inverseBindMatrices: Matrix4x4[], bindPoseMatrices: Matrix4x4[], meshes: Mesh[], bounding: AssetSubMeshData[]);
    // @internal (undocumented)
    apply(): void;
    // @internal (undocumented)
    protected _bindPoseMatrices: Matrix4x4[];
    // @internal (undocumented)
    computeBindPose(model: SceneNode): void;
    // @internal (undocumented)
    computeBoundingBox(info: SkinnedBoundingBox, invWorldMatrix: Matrix4x4): void;
    // @internal (undocumented)
    computeJoints(): void;
    dispose(): void;
    // @internal (undocumented)
    protected _inverseBindMatrices: Matrix4x4[];
    // @internal (undocumented)
    protected _jointMatrices: Matrix4x4[];
    // @internal (undocumented)
    protected _jointMatrixArray: Float32Array;
    // @internal (undocumented)
    protected _jointOffsets: Float32Array;
    // @internal (undocumented)
    protected _joints: SceneNode[];
    get jointTexture(): Texture2D;
    // @internal (undocumented)
    protected _jointTexture: Texture2D;
    // @internal (undocumented)
    protected _meshes: {
        mesh: Mesh;
        bounding: SkinnedBoundingBox;
        box: BoundingBox;
    }[];
    // @internal (undocumented)
    reset(): void;
    // @internal (undocumented)
    updateJointMatrices(jointTransforms?: Matrix4x4[], worldMatrix?: Matrix4x4): void;
}

// @public (undocumented)
export function skyBox(scope: PBInsideFunctionScope, stParams: PBShaderExp, f4SunColor: PBShaderExp, f3SkyBoxWorldPos: PBShaderExp, fSunSolidAngle: PBShaderExp, texSkyViewLut: PBShaderExp): any;

// @public
export class SkyRenderer {
    constructor();
    // @internal (undocumented)
    get aerialPerspectiveDebug(): number;
    set aerialPerspectiveDebug(val: number);
    get aerialPerspectiveDistance(): number;
    set aerialPerspectiveDistance(val: number);
    get atmosphereExposure(): number;
    set atmosphereExposure(val: number);
    get autoUpdateIBLMaps(): boolean;
    set autoUpdateIBLMaps(val: boolean);
    get bakedSkyTexture(): TextureCube;
    get cameraHeightScale(): number;
    set cameraHeightScale(val: number);
    get cloudIntensity(): number;
    set cloudIntensity(val: number);
    get cloudy(): number;
    set cloudy(val: number);
    // @internal (undocumented)
    dispose(): void;
    get drawGround(): boolean;
    set drawGround(val: boolean);
    // @internal (undocumented)
    drawScatteredFog(ctx: DrawContext): boolean;
    get fogColor(): Vector4;
    set fogColor(val: Vector4);
    get fogDensity(): number;
    set fogDensity(val: number);
    get fogEnd(): number;
    set fogEnd(val: number);
    // @internal (undocumented)
    get fogParams(): Vector4;
    set fogParams(val: Vector4);
    get fogStart(): number;
    set fogStart(val: number);
    get fogTop(): number;
    set fogTop(val: number);
    get fogType(): FogType;
    set fogType(val: FogType);
    // @internal (undocumented)
    getAerialPerspectiveLUT(ctx: DrawContext): _zephyr3d_device.Texture2D<unknown>;
    // @internal (undocumented)
    getHash(ctx: DrawContext): string;
    invalidate(): void;
    // @internal (undocumented)
    get irradianceFramebuffer(): FrameBuffer<unknown>;
    get irradianceMap(): TextureCube;
    // @internal (undocumented)
    get mappedFogType(): number;
    // @internal (undocumented)
    get panoramaTextureAsset(): string;
    set panoramaTextureAsset(id: string);
    // @internal (undocumented)
    get radianceFramebuffer(): FrameBuffer<unknown>;
    get radianceMap(): TextureCube;
    // (undocumented)
    renderAtmosphereLUTs(ctx: DrawContext): void;
    // @internal (undocumented)
    renderAtmosphericFog(ctx: DrawContext): void;
    // @internal (undocumented)
    renderFog(ctx: DrawContext): void;
    // @internal (undocumented)
    renderLegacyFog(ctx: DrawContext): void;
    // @internal (undocumented)
    renderSky(ctx: DrawContext): void;
    get skyboxTexture(): TextureCube;
    set skyboxTexture(tex: TextureCube);
    get skyColor(): Vector4;
    set skyColor(val: Vector4);
    get skyType(): SkyType;
    set skyType(val: SkyType);
    // @internal (undocumented)
    get skyWorldMatrix(): Matrix4x4;
    set skyWorldMatrix(val: Matrix4x4);
    // @internal (undocumented)
    sunTransmittance(sunLight: DirectionalLight): Vector3;
    // (undocumented)
    update(ctx: DrawContext): void;
    // (undocumented)
    updateBakedSkyMap(sunDir: Vector3, sunColor: Vector4): void;
    get wind(): Vector2;
    set wind(val: Vector2);
}

// @public
export type SkyType = 'color' | 'skybox' | 'scatter' | 'scatter-nocloud' | 'none';

// @public (undocumented)
export function skyViewLut(scope: PBInsideFunctionScope, stParams: PBShaderExp, f2UV: PBShaderExp, texTransmittanceLut: PBShaderExp, texMultiScatteringLut: PBShaderExp): any;

// @public
export function smoothNoise3D(scope: PBInsideFunctionScope, p: PBShaderExp): PBShaderExp;

// @public
export interface SphereCreationOptions extends ShapeCreationOptions {
    horizonalDetail?: number;
    radius?: number;
    verticalDetail?: number;
}

// @public
export class SphereShape extends Shape<SphereCreationOptions> implements Clonable<SphereShape> {
    constructor(options?: SphereCreationOptions);
    // (undocumented)
    clone(): SphereShape;
    // (undocumented)
    static _defaultOptions: {
        radius: number;
        verticalDetail: number;
        horizonalDetail: number;
        needNormal: boolean;
        needUV: boolean;
    };
    static generateData(options: SphereCreationOptions, vertices: number[], normals: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): PrimitiveType;
    get radius(): number;
    // @override
    raycast(ray: Ray): number;
    // (undocumented)
    get type(): string;
}

// @public
export class SpotLight extends PunctualLight implements NodeClonable<SpotLight> {
    constructor(scene: Scene);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): SpotLight;
    // @internal (undocumented)
    computeBoundingVolume(): BoundingVolume;
    // @internal (undocumented)
    computeUniforms(): void;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: any): void;
    get cutoff(): number;
    set cutoff(val: number);
    // @internal (undocumented)
    protected _cutoff: number;
    // @override
    isSpotLight(): this is SpotLight;
    get range(): number;
    set range(val: number);
    // @internal (undocumented)
    protected _range: number;
    setCutoff(val: number): this;
    setRange(val: number): this;
}

// @public
export type StopAnimationOptions = {
    fadeOut?: number;
};

// Warning: (ae-internal-missing-underscore) The name "TAA" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class TAA extends AbstractPostEffect {
    constructor();
    // (undocumented)
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    // (undocumented)
    renderSkyMotionVectors(ctx: DrawContext): void;
    // (undocumented)
    requireDepthAttachment(ctx: DrawContext): boolean;
    // (undocumented)
    requireLinearDepthTexture(ctx: DrawContext): boolean;
}

// @public (undocumented)
export const TAA_DEBUG_ALAPH = 5;

// @public (undocumented)
export const TAA_DEBUG_CURRENT_COLOR = 1;

// @public (undocumented)
export const TAA_DEBUG_EDGE = 4;

// @public (undocumented)
export const TAA_DEBUG_HISTORY_COLOR = 2;

// @public (undocumented)
export const TAA_DEBUG_MOTION_VECTOR = 6;

// @public (undocumented)
export const TAA_DEBUG_NONE = 0;

// @public (undocumented)
export const TAA_DEBUG_VELOCITY = 3;

// @public (undocumented)
export function temporalResolve(scope: PBInsideFunctionScope, currentColorTex: PBShaderExp, historyColorTex: PBShaderExp, currentDepthTex: PBShaderExp, motionVectorTex: PBShaderExp, prevMotionVectorTex: PBShaderExp, uv: PBShaderExp, workSize: PBShaderExp, bf: PBShaderExp, debug?: number): PBShaderExp;

// @public
export class Terrain extends GraphNode implements NodeClonable<Terrain> {
    constructor(scene: Scene);
    get castShadow(): boolean;
    set castShadow(val: boolean);
    // (undocumented)
    clone(method: NodeCloneMethod, recursive: boolean): Terrain;
    // @override
    computeBoundingVolume(): BoundingVolume;
    // (undocumented)
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    create(sizeX: number, sizeZ: number, elevations: Float32Array, scale: Vector3, patchSize: number, options?: TerrainMaterialOptions): boolean;
    createGrass(density: number[][], bladeWidth: number, bladeHeight: number, offset: number, grassTexture: Texture2D): void;
    // @internal (undocumented)
    cull(cullVisitor: CullVisitor): number;
    // (undocumented)
    dispose(): void;
    getElevation(x: number, z: number): number;
    getName(): string;
    getNormal(x: number, z: number, normal?: Vector3): Vector3;
    get height(): number;
    get heightFieldScale(): Vector3;
    // @override
    isTerrain(): this is Terrain;
    get LODCamera(): Camera;
    set LODCamera(camera: Camera);
    get material(): TerrainMaterial;
    get maxPixelError(): number;
    set maxPixelError(val: number);
    get normalMap(): Texture2D;
    // @internal (undocumented)
    get patchSize(): number;
    // @internal (undocumented)
    get quadtree(): Quadtree;
    rayIntersect(ray: Ray): number | null;
    get scaledHeight(): number;
    get scaledWidth(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "traverseQuadtree" is marked as @public, but its signature references "QuadtreeNode" which is marked as @internal
    traverseQuadtree(callback: (node: QuadtreeNode) => void): void;
    get width(): number;
}

// @public
export type TerrainDebugMode = 'none' | 'vertex_normal' | 'detail_normal' | 'tangent' | 'uv' | 'bitangent' | 'albedo';

// @public
export type TerrainDetailMapInfo = {
    albedoTextures: Texture2DArray | Texture2D[];
    uvScale: number[];
    metallic?: number[];
    roughness?: number[];
    normalScale?: number[];
    normalTextures?: Texture2DArray | Texture2D[];
    albedoTexCoordIndex?: number | number[];
    normalTexCoordIndex?: number | number[];
    grass?: {
        texture?: Texture2D;
        bladeWidth?: number;
        bladeHeigh?: number;
        density?: number;
        offset?: number;
    }[][];
};

// Warning: (ae-forgotten-export) The symbol "TerrainMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class TerrainMaterial extends TerrainMaterial_base implements Clonable<TerrainMaterial> {
    constructor(options?: TerrainMaterialOptions);
    // (undocumented)
    applyUniformValues(bindGroup: BindGroup, ctx: DrawContext, pass: number): void;
    // (undocumented)
    calculateAlbedoColor(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    clone(): TerrainMaterial;
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    generateMetallicRoughnessMap(): Texture2D;
    // (undocumented)
    getAlbedoTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    getMetallicRoughnessTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    // (undocumented)
    getNormalTexCoord(scope: PBInsideFunctionScope): PBShaderExp;
    // @override
    isBatchable(): boolean;
    // @override
    isTransparentPass(pass: number): boolean;
    // (undocumented)
    sampleDetailNormalMap(scope: PBInsideFunctionScope, tex: PBShaderExp, texCoord: PBShaderExp, normalScale: PBShaderExp, TBN: PBShaderExp): PBShaderExp;
    // @override
    supportInstancing(): boolean;
    // @override
    supportLighting(): boolean;
    // (undocumented)
    get terrainInfo(): Vector4;
    set terrainInfo(val: Vector4);
    // (undocumented)
    protected updateRenderStates(pass: number, stateSet: RenderStateSet, ctx: DrawContext): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public
export type TerrainMaterialOptions = {
    splatMap?: Texture2D;
    splatMapTexCoordIndex?: number;
    detailMaps?: TerrainDetailMapInfo;
};

// Warning: (ae-forgotten-export) The symbol "TerrainPatch_base" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "TerrainPatch" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class TerrainPatch extends TerrainPatch_base implements Drawable {
    constructor(terrain: Terrain);
    // (undocumented)
    computeBoundingBox(box: BoundingBox): void;
    // (undocumented)
    computeErrorMetric(other: TerrainPatch): number;
    // (undocumented)
    computeHeightBound(): [number, number];
    // (undocumented)
    computeLodDistance(viewportH: number, tanHalfFovy: number, maxPixelError: number): number;
    // (undocumented)
    computeMaxError(): number;
    // (undocumented)
    computeSkirtLength(): number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(ctx: DrawContext): void;
    // (undocumented)
    getBoneMatrices(): Texture2D<unknown>;
    // (undocumented)
    getBoundingBox(): BoundingBox;
    // (undocumented)
    getGeometry(): Primitive;
    // (undocumented)
    getHeight(x: number, z: number): number;
    // (undocumented)
    getLODDistance(): number;
    // (undocumented)
    getMaterial(): MeshMaterial;
    // (undocumented)
    getMipLevel(): number;
    // (undocumented)
    getMorphData(): Texture2D;
    // (undocumented)
    getMorphInfo(): GPUDataBuffer;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getOffsetScale(): Vector4;
    // (undocumented)
    getOffsetX(): number;
    // (undocumented)
    getOffsetZ(): number;
    // (undocumented)
    getPickTarget(): PickTarget;
    // (undocumented)
    getPrimitive(): Primitive;
    // (undocumented)
    getQueueType(): number;
    // (undocumented)
    getSortDistance(camera: Camera): number;
    // (undocumented)
    getStep(): number;
    // (undocumented)
    initialize(quadtree: Quadtree, parent: TerrainPatch, rowIndex: number, colIndex: number, baseVertices: Float32Array, normals: Vector3[], heightScale: number, elevations: Float32Array): boolean;
    // (undocumented)
    isBatchable(): this is BatchDrawable;
    // (undocumented)
    isDummy(): boolean;
    // (undocumented)
    isUnlit(): boolean;
    // (undocumented)
    needSceneColor(): boolean;
    // (undocumented)
    needSceneDepth(): boolean;
    // (undocumented)
    setBoundingBox(bbox: BoundingBox): void;
    // (undocumented)
    setupCamera(viewportH: number, tanHalfFovy: number, maxPixelError: number): void;
    // (undocumented)
    setupVertices(skirtLength: number, baseVertices: Float32Array, normalVectors: Vector3[], heightScale: number, elevations: Float32Array): void;
    // (undocumented)
    sqrDistancePointToTriangle(P: Vector3, t0: Vector3, t1: Vector3, t2: Vector3): number;
    // (undocumented)
    sqrDistanceToPoint(point: Vector3): number;
}

// Warning: (ae-internal-missing-underscore) The name "TerrainPatchBase" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class TerrainPatchBase {
    constructor(terrain: Terrain);
    // (undocumented)
    getNode(): SceneNode;
    // (undocumented)
    protected _terrain: Terrain;
}

// @public
export type TextureFetchOptions<T extends BaseTexture> = {
    mimeType?: string;
    linearColorSpace?: boolean;
    texture?: T;
    samplerOptions?: SamplerOptions;
};

// @public
export type TextureMixinInstanceTypes<T> = TextureMixinTypes<T> extends {
    new (...args: any[]): infer U;
} ? U : never;

// @public
export type TextureMixinTypes<T> = ReturnType<typeof applyMaterialMixins<ToMixedTextureType<T>, typeof MeshMaterial>>;

// @public
export type TextureProp<U extends string> = {
    [P in 'Texture' | 'TextureSampler' | 'TexCoordIndex' | 'TexCoordMatrix' as `${U}${P}`]: P extends 'Texture' ? Texture2D : P extends 'TextureSampler' ? TextureSampler : P extends 'TexCoordIndex' ? number : P extends 'TexCoordMatrix' ? Matrix4x4 : never;
};

// @public
export type TexturePropUniforms<U extends string> = {
    [P in 'TextureUniform' | 'TexCoord' as `get${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope) => PBShaderExp;
} & {
    [P in 'Texture' as `sample${Capitalize<U>}${P}`]: (scope: PBInsideFunctionScope, texCoord?: PBShaderExp) => PBShaderExp;
};

// @public
export type ToMixedTextureType<T> = T extends [infer First, ...infer Rest] ? [First extends string ? ReturnType<typeof mixinTextureProps<First>> : never, ...ToMixedTextureType<Rest>] : [];

// @public
export class Tonemap extends AbstractPostEffect {
    constructor();
    apply(ctx: DrawContext, inputColorTexture: Texture2D, sceneDepthTexture: Texture2D, srgbOutput: boolean): void;
    get exposure(): number;
    set exposure(val: number);
    requireDepthAttachment(): boolean;
    requireLinearDepthTexture(): boolean;
}

// @public
export interface TorusCreationOptions extends ShapeCreationOptions {
    innerRadius?: number;
    numSegments?: number;
    numSlices?: number;
    outerRadius?: number;
    radialDetail?: number;
}

// @public
export class TorusShape extends Shape<TorusCreationOptions> implements Clonable<TorusShape> {
    constructor(options?: TorusCreationOptions);
    // (undocumented)
    clone(): TorusShape;
    // (undocumented)
    static _defaultOptions: {
        numSlices: number;
        numSegments: number;
        outerRadius: number;
        innerRadius: number;
        radialDetail: number;
        needNormal: boolean;
        needUV: boolean;
    };
    static generateData(options: TorusCreationOptions, vertices: number[], normals: number[], uvs: number[], indices: number[], bbox?: AABB, indexOffset?: number, vertexCallback?: (index: number, x: number, y: number, z: number) => void): PrimitiveType;
    // (undocumented)
    get type(): string;
}

// @public (undocumented)
export function transmittance(scope: PBInsideFunctionScope, stParams: PBShaderExp, f3P1: PBShaderExp, f3P2: PBShaderExp): PBShaderExp;

// @public (undocumented)
export function transmittanceLut(scope: PBInsideFunctionScope, stParams: PBShaderExp, f2UV: PBShaderExp): any;

// @public (undocumented)
export function transmittanceLutToUV(scope: PBInsideFunctionScope, fBottomRadius: PBShaderExp, fTopRadius: PBShaderExp, fMu: PBShaderExp, fR: PBShaderExp): any;

// @public (undocumented)
export function transmittanceToSky(scope: PBInsideFunctionScope, stParams: PBShaderExp, f3Pos: PBShaderExp, f3Dir: PBShaderExp, texLut: PBShaderExp): any;

// Warning: (ae-forgotten-export) The symbol "UnlitMaterial_base" needs to be exported by the entry point index.d.ts
//
// @public
export class UnlitMaterial extends UnlitMaterial_base implements Clonable<UnlitMaterial> {
    constructor();
    // (undocumented)
    clone(): UnlitMaterial;
    // (undocumented)
    static readonly FEATURE_VERTEX_COLOR = "um_vertexcolor";
    // (undocumented)
    fragmentShader(scope: PBFunctionScope): void;
    // (undocumented)
    vertexShader(scope: PBFunctionScope): void;
}

// @public (undocumented)
export function uvToTransmittanceLut(scope: PBInsideFunctionScope, f2UV: PBShaderExp, fBottomRadius: PBShaderExp, fTopRadius: PBShaderExp): PBShaderExp;

// @public (undocumented)
export function uvToViewDir(scope: PBInsideFunctionScope, f2UV: PBShaderExp): any;

// @public (undocumented)
export function viewDirToUV(scope: PBInsideFunctionScope, f3ViewDir: PBShaderExp): any;

// @public
export interface Visitor<T> {
    // (undocumented)
    visit(target: T): unknown;
}

// Warning: (ae-internal-missing-underscore) The name "VSM" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class VSM extends ShadowImpl {
    constructor(kernelSize?: number, blurSize?: number, darkness?: number);
    // Warning: (ae-forgotten-export) The symbol "VSMBlitter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _blitterH: VSMBlitter;
    // (undocumented)
    protected _blitterV: VSMBlitter;
    // (undocumented)
    get blur(): boolean;
    set blur(val: boolean);
    // (undocumented)
    protected _blur: boolean;
    // (undocumented)
    get blurSize(): number;
    set blurSize(val: number);
    // (undocumented)
    protected _blurSize: number;
    // (undocumented)
    computeShadow(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowCSM(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, shadowVertex: PBShaderExp, NdotL: PBShaderExp, split: PBShaderExp): PBShaderExp;
    // (undocumented)
    computeShadowMapDepth(shadowMapParams: ShadowMapParams, scope: PBInsideFunctionScope, worldPos: PBShaderExp): PBShaderExp;
    // (undocumented)
    protected _darkness: number;
    // (undocumented)
    doUpdateResources(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    fetchTemporalFramebuffer(autoRelease: boolean, lightType: number, numCascades: number, width: number, height: number, colorFormat: TextureFormat, depthFormat: TextureFormat, mipmapping?: boolean): FrameBuffer<unknown>;
    // (undocumented)
    getDepthScale(): number;
    // (undocumented)
    getShaderHash(): string;
    // (undocumented)
    getShadowMap(shadowMapParams: ShadowMapParams): ShadowMapType;
    // (undocumented)
    getShadowMapBorder(shadowMapParams: ShadowMapParams): number;
    // (undocumented)
    getShadowMapColorFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getShadowMapDepthFormat(shadowMapParams: ShadowMapParams): TextureFormat;
    // (undocumented)
    getType(): ShadowMode;
    // (undocumented)
    get kernelSize(): number;
    set kernelSize(val: number);
    // (undocumented)
    protected _kernelSize: number;
    // (undocumented)
    get mipmap(): boolean;
    set mipmap(b: boolean);
    // (undocumented)
    protected _mipmap: boolean;
    // (undocumented)
    postRenderShadowMap(shadowMapParams: ShadowMapParams): void;
    // (undocumented)
    resourceDirty(): boolean;
    // (undocumented)
    setDepthScale(val: number): void;
    // (undocumented)
    useNativeShadowMap(shadowMapParams: ShadowMapParams): boolean;
}

// Warning: (ae-forgotten-export) The symbol "Water_base" needs to be exported by the entry point index.d.ts
//
// @public
export class Water extends Water_base implements Drawable, NodeClonable<Water> {
    constructor(scene: Scene);
    get animationSpeed(): number;
    set animationSpeed(val: number);
    // (undocumented)
    calculateLocalTransform(outMatrix: Matrix4x4): void;
    // (undocumented)
    calculateWorldTransform(outMatrix: Matrix4x4): void;
    clone(method: NodeCloneMethod, recursive: boolean): Water;
    computeBoundingVolume(): BoundingVolume;
    computeWorldBoundingVolume(): BoundingVolume;
    copyFrom(other: this, method: NodeCloneMethod, recursive: boolean): void;
    dispose(): void;
    draw(ctx: DrawContext): void;
    getMaterial(): MeshMaterial;
    getMorphData(): Texture2D;
    getMorphInfo(): GPUDataBuffer<unknown>;
    getPickTarget(): PickTarget;
    getPrimitive(): Primitive;
    getQueueType(): number;
    get gridScale(): number;
    set gridScale(val: number);
    isUnlit(): boolean;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "isWater"
    //
    // (undocumented)
    isWater(): this is Water;
    // Warning: (ae-forgotten-export) The symbol "WaterMaterial" needs to be exported by the entry point index.d.ts
    get material(): WaterMaterial;
    needSceneColor(): boolean;
    needSceneDepth(): boolean;
    // (undocumented)
    protected _onTransformChanged(invalidateLocal: boolean): void;
    get TAAStrength(): number;
    set TAAStrength(val: number);
    update(frameId: number, elapsedInSeconds: number): void;
    updatePerCamera(camera: Camera, elapsedInSeconds: number, deltaInSeconds: number): void;
    get waveGenerator(): WaveGenerator;
    set waveGenerator(waveGenerator: WaveGenerator);
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// Warning: (ae-internal-missing-underscore) The name "WaterMesh" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class WaterMesh {
    constructor();
    // (undocumented)
    getClipmapBindGroup(device: AbstractDevice): BindGroup;
    // (undocumented)
    getWaterBindGroup(device: AbstractDevice): BindGroup;
    // (undocumented)
    get gridScale(): number;
    set gridScale(val: number);
    // (undocumented)
    get level(): number;
    set level(val: number);
    // (undocumented)
    prepareForRender(device: AbstractDevice): boolean;
    // (undocumented)
    get region(): Vector4;
    set region(val: Vector4);
    // (undocumented)
    render(device: AbstractDevice, camera: Camera, flip?: boolean): void;
    // (undocumented)
    get shadingImpl(): WaterShaderImpl;
    set shadingImpl(val: WaterShaderImpl);
    // (undocumented)
    get speed(): number;
    set speed(val: number);
    // (undocumented)
    get tileSize(): number;
    set tileSize(val: number);
    // (undocumented)
    get waveImpl(): WaveGenerator;
    set waveImpl(val: WaveGenerator);
    // (undocumented)
    get wireframe(): boolean;
    set wireframe(val: boolean);
}

// Warning: (ae-internal-missing-underscore) The name "WaterSetupUniformFunc" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type WaterSetupUniformFunc = (this: WaterShaderImpl, scope: PBGlobalScope) => void;

// Warning: (ae-internal-missing-underscore) The name "WaterShaderImpl" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class WaterShaderImpl {
    constructor(setupUniformsFunc: WaterSetupUniformFunc, vertexFunc: WaterVertexFunc, shadingFunc: WaterShadingFunc);
    // (undocumented)
    getVertexNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, useComputeShader: boolean): PBShaderExp;
    // (undocumented)
    setupUniforms(scope: PBGlobalScope): void;
    // (undocumented)
    shading(scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal: PBShaderExp, foamFactor: PBShaderExp, discardable: PBShaderExp, waveGenerator: WaveGenerator): PBShaderExp;
    // (undocumented)
    vertex(scope: PBInsideFunctionScope, pos: PBShaderExp, xz: PBShaderExp, waveGenerator: WaveGenerator): void;
}

// Warning: (ae-internal-missing-underscore) The name "WaterShadingFunc" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type WaterShadingFunc = (scope: PBInsideFunctionScope, worldPos: PBShaderExp, worldNormal: PBShaderExp, foamFactor: PBShaderExp, discardable: PBShaderExp, waveGenerator: WaveGenerator) => PBShaderExp;

// Warning: (ae-internal-missing-underscore) The name "WaterVertexFunc" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type WaterVertexFunc = (this: WaterShaderImpl, scope: PBInsideFunctionScope, pos: PBShaderExp, xz: PBShaderExp, waveGenerator: WaveGenerator) => void;

// @public
export interface WaveGenerator extends Disposable {
    applyWaterBindGroup(bindGroup: BindGroup): void;
    // (undocumented)
    calcClipmapTileAABB(minX: number, maxX: number, minZ: number, maxZ: number, y: number, outAABB: AABB): any;
    // (undocumented)
    calcFragmentNormal(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    calcFragmentNormalAndFoam(scope: PBInsideFunctionScope, xz: PBShaderExp, vertexNormal: PBShaderExp): PBShaderExp;
    calcVertexPositionAndNormal(scope: PBInsideFunctionScope, inPos: PBShaderExp, outPos: PBShaderExp, outNormal: PBShaderExp): void;
    clone(): this;
    getHash(): string;
    isOk(device: AbstractDevice): boolean;
    needUpdate(): boolean;
    setupUniforms(scope: PBGlobalScope, uniformGroup: number): void;
    update(timeInSeconds: number): void;
    // @internal
    version: number;
}

// @public
export class WeightedBlendedOIT implements OIT {
    constructor();
    applyUniforms(ctx: DrawContext, bindGroup: BindGroup): void;
    begin(ctx: DrawContext): number;
    beginPass(ctx: DrawContext, pass: number): boolean;
    calculateHash(): string;
    dispose(): void;
    get disposed(): boolean;
    end(ctx: DrawContext): void;
    endPass(ctx: DrawContext, pass: number): void;
    getType(): string;
    outputFragmentColor(scope: PBInsideFunctionScope, color: PBShaderExp): boolean;
    setRenderStates(rs: RenderStateSet): void;
    setupFragmentOutput(scope: PBGlobalScope): void;
    supportDevice(deviceType: string): boolean;
    static readonly type = "wb";
    wantsPremultipliedAlpha(): boolean;
}

// @public
export function worleyFBM(scope: PBInsideFunctionScope, p: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// @public
export function worleyNoise(scope: PBInsideFunctionScope, uv: PBShaderExp, freq: PBShaderExp | number): PBShaderExp;

// Warnings were encountered during analysis:
//
// dist/index.d.ts:2379:9 - (ae-incompatible-release-tags) The symbol "type" is marked as @public, but its signature references "InstanceUniformType" which is marked as @internal
// dist/index.d.ts:9876:9 - (ae-forgotten-export) The symbol "SkinnedBoundingBox" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
