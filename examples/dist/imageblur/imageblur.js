const colorNames = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32',
    transparent: 'rgba(0,0,0,0)'
};
/**
 * parse a css color value to RGBA color type.
 * @param input - The css color value.
 * @returns The RGBA color value.
 * @public
 */ function parseColor(input) {
    input = input.trim().toLowerCase();
    input = colorNames[input] || input;
    let v = null;
    if (input[0] === '#') {
        const collen = (input.length - 1) / 3;
        const fact = [
            17,
            1,
            0.062272
        ][collen - 1];
        v = {
            r: parseInt(input.substring(1, 1 + collen), 16) * fact / 255,
            g: parseInt(input.substring(1 + collen, 1 + 2 * collen), 16) * fact / 255,
            b: parseInt(input.substring(1 + 2 * collen, 1 + 3 * collen), 16) * fact / 255,
            a: 1
        };
    } else {
        let m;
        if (m = input.match(/^\s*rgb\s*\(\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\s*,\s*(\d\.?\d*)\s*\)\s*$/i)) {
            v = {
                r: Number(m[1]) / 255,
                g: Number(m[2]) / 255,
                b: Number(m[3]) / 255,
                a: 1
            };
        } else if (m = input.match(/^\s*rgba\s*\(\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\s*,\s*([\d*.?\d*]+)\s*,\s*(\d*\.?\d*)\s*\)\s*$/i)) {
            v = {
                r: Number(m[1]) / 255,
                g: Number(m[2]) / 255,
                b: Number(m[3]) / 255,
                a: Number(m[4])
            };
        }
    }
    if (!v || Number.isNaN(v.r) || Number.isNaN(v.g) || Number.isNaN(v.b) || Number.isNaN(v.a)) {
        throw new Error(`parseColor(): invalid color '${input}'`);
    }
    // the RGB color values in CSS are in sRGB color space, convert them to linear color space
    v.r = Math.pow(Math.min(1, v.r), 2.2);
    v.g = Math.pow(Math.min(1, v.g), 2.2);
    v.b = Math.pow(Math.min(1, v.b), 2.2);
    v.a = Math.min(1, v.a);
    return v;
}

/**
 * This mixin make a class an event target
 * @param cls - the class to make
 * @returns - The event target class
 * @public
 */ function makeEventTarget(cls) {
    return function _() {
        return class E extends cls {
            /** @internal */ _listeners;
            constructor(...args){
                super(...args);
                this._listeners = null;
            }
            /**
       * {@inheritDoc IEventTarget.on}
       */ on(type, listener, context) {
                this._listeners = this._internalAddEventListener(this._listeners, type, listener, {
                    context
                });
            }
            /**
       * {@inheritDoc IEventTarget.once}
       */ once(type, listener, context) {
                this._listeners = this._internalAddEventListener(this._listeners, type, listener, {
                    context,
                    once: true
                });
            }
            /**
       * {@inheritDoc IEventTarget.off}
       */ off(type, listener) {
                this._internalRemoveEventListener(this._listeners, type, listener);
            }
            /**
       * {@inheritDoc IEventTarget.dispatchEvent}
       */ dispatchEvent(evt, type) {
                this._invokeLocalListeners(evt, type);
            }
            /** @internal */ _internalAddEventListener(listenerMap, type, listener, options) {
                if (typeof type !== 'string') {
                    return;
                }
                if (!listenerMap) {
                    listenerMap = {};
                }
                const l = listener;
                const o = {
                    once: !!options?.once,
                    context: options?.context
                };
                let handlers = listenerMap[type];
                if (!handlers) {
                    listenerMap[type] = handlers = [];
                }
                handlers.push({
                    handler: l,
                    options: o,
                    removed: false
                });
                return listenerMap;
            }
            /** @internal */ _internalRemoveEventListener(listenerMap, type, listener) {
                if (typeof type !== 'string' || !listenerMap) {
                    return;
                }
                const l = listener;
                const handlers = listenerMap[type];
                if (handlers) {
                    for(let i = 0; i < handlers.length; i++){
                        const handler = handlers[i];
                        if (handler.handler === l) {
                            handlers.splice(i, 1);
                            break;
                        }
                    }
                }
                if (handlers.length === 0) {
                    delete listenerMap[type];
                }
            }
            /** @internal */ _invokeLocalListeners(evt, type) {
                if (!this._listeners) {
                    return;
                }
                const handlers = this._listeners[type ?? evt?.type];
                if (handlers && handlers.length > 0) {
                    const handlersCopy = handlers.slice();
                    for (const handler of handlersCopy){
                        handler.handler.call(handler.options?.context || this, evt);
                        if (handler.options.once) {
                            handler.removed = true;
                        }
                    }
                    for(let i = handlers.length - 1; i >= 0; i--){
                        if (handlers[i].removed) {
                            handlers.splice(i, 1);
                        }
                    }
                }
            }
        };
    };
}

/**
 * Enumerator used to refer to a box side
 * @public
 */ var BoxSide;
(function(BoxSide) {
    BoxSide[BoxSide[/** Left side (-x) */ "LEFT"] = 0] = "LEFT";
    BoxSide[BoxSide[/** Right side (+x) */ "RIGHT"] = 1] = "RIGHT";
    BoxSide[BoxSide[/** Bottom side (-y) */ "BOTTOM"] = 2] = "BOTTOM";
    BoxSide[BoxSide[/** Top side (+y) */ "TOP"] = 3] = "TOP";
    BoxSide[BoxSide[/** Front side (+z) */ "FRONT"] = 4] = "FRONT";
    BoxSide[BoxSide[/** Back side (-z) */ "BACK"] = 5] = "BACK";
})(BoxSide || (BoxSide = {}));
var ClipState;
(function(ClipState) {
    ClipState[ClipState[/** A does not intersect with B */ "NOT_CLIPPED"] = 0] = "NOT_CLIPPED";
    ClipState[ClipState[/** A is inside B */ "A_INSIDE_B"] = 1] = "A_INSIDE_B";
    ClipState[ClipState[/** B is inside A */ "B_INSIDE_A"] = 2] = "B_INSIDE_A";
    ClipState[ClipState[/** A and B partially overlap */ "CLIPPED"] = 2] = "CLIPPED";
})(ClipState || (ClipState = {}));
var CubeFace;
(function(CubeFace) {
    CubeFace[CubeFace["PX"] = 0] = "PX";
    CubeFace[CubeFace["NX"] = 1] = "NX";
    CubeFace[CubeFace["PY"] = 2] = "PY";
    CubeFace[CubeFace["NY"] = 3] = "NY";
    CubeFace[CubeFace["PZ"] = 4] = "PZ";
    CubeFace[CubeFace["NZ"] = 5] = "NZ";
})(CubeFace || (CubeFace = {}));

const IDENT_MATRIX3x3 = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
]);
const IDENT_MATRIX4x4 = new Float32Array([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
]);
/**
 * Base class for vector and matrix types.
 *
 * @public
 */ class VectorBase extends Float32Array {
    /**
   * Check if all data is close enough to another
   * @param other - The data to be compared with.
   * @param epsilon - The minimal error allowd.
   * @returns true if close enough, otherwise false.
   */ equalsTo(other, epsl) {
        if (!other || this.length !== other.length) {
            return false;
        }
        if (this === other) {
            return true;
        }
        for(let i = 0; i < this.length; i++){
            const a = this[i];
            const b = other[i];
            const e = epsl ?? 0.0001 * Math.max(1, Math.abs(a), Math.abs(b));
            if (Math.abs(a - b) > e) {
                return false;
            }
        }
        return true;
    }
    /**
   * Convert this to string object.
   */ toString() {
        const elements = [
            ...this
        ].map((val)=>val.toFixed(3));
        return `${this.constructor.name}{${elements.join(',')}}`;
    }
    /**
   * Check the data for the presence of NaN.
   *
   * @returns true if NaN is present, otherwise false.
   */ isNaN() {
        for(let i = 0; i < this.length; i++){
            if (Number.isNaN(this[i])) {
                return true;
            }
        }
        return false;
    }
}
/**
 * 2 dimentional vector
 * @public
 */ class Vector2 extends VectorBase {
    constructor(arg0, arg1){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 2);
        } else {
            super(2);
            if (typeof arg0 === 'number' && typeof arg1 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 2) {
                this[0] = arg0[0];
                this[1] = arg0[1];
            } else if (arg0 !== void 0) {
                throw new Error(`Vector2.constructor(): invalid arguments`);
            }
        }
    }
    /**
   * Creates a new Vector2 initialized with values from this vector.
   * @returns The new Vector2.
   */ clone() {
        return new Vector2(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1];
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @returns self
   */ setXY(x, y) {
        this[0] = x;
        this[1] = y;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @returns self
   */ setAndNormalize(x, y) {
        const mag = Math.sqrt(x * x + y * y);
        return this.setXY(x / mag, y / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector2.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector2.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector2.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector2.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector2.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector2.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector2.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector2.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector2.max(this, other, this);
    }
    /**
   * Creates a new Vector2 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector2(0, 0);
    }
    /**
   * Creates a new Vector2 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector2(1, 1);
    }
    /**
   * Creates a new Vector2 pointing in the positive direction of the X axis, i.e. vec2(1, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector2(1, 0);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the X axis, i.e. vec2(-1, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector2(-1, 0);
    }
    /**
   * Creates a new Vector2 pointing in the positive direction of the Y axis, i.e. vec2(0, 1)
   * @returns The new vector
   */ static axisPY() {
        return new Vector2(0, 1);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the Y axis, i.e. vec2(0, -1)
   * @returns The new vector
   */ static axisNY() {
        return new Vector2(0, -1);
    }
    /**
   * Calculates the distance between two Vector2's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns distance between v1 and v2
   */ static distance(v1, v2) {
        return Math.sqrt(this.distanceSq(v1, v2));
    }
    /**
   * Calculates the squared distance between two Vector2's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns squared distance between v1 and v2
   */ static distanceSq(v1, v2) {
        const dx = v1.x - v2.x;
        const dy = v1.y - v2.y;
        return dx * dx + dy * dy;
    }
    /**
   * Normalize a Vector2
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Inverse a Vector2
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Subtract two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Add two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Multiply two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Divide two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Scale a Vector2 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the minimum of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the maximum of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the absolute values of a Vector2.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the dot product of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y;
    }
    /**
   * Calculates the cross product of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns z component of the cross product of the two vectors.
   */ static cross(a, b) {
        return a.x * b.y - a.y * b.x;
    }
}
/**
 * 3 dimentional vector
 * @public
 */ class Vector3 extends VectorBase {
    constructor(arg0, arg1, arg2){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 3);
        } else {
            super(3);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 3) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
            } else if (arg0 !== void 0) {
                throw new Error('Vector3.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Vector3 initialized with values from this vector.
   * @returns The new vector.
   */ clone() {
        return new Vector3(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2];
    }
    /**
   * Creates a new Vector2 initialized with x, y component of this vector.
   * @returns The new vector
   */ xy() {
        return new Vector2(this.x, this.y);
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @returns self
   */ setXYZ(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @returns self
   */ setAndNormalize(x, y, z) {
        const mag = Math.sqrt(x * x + y * y + z * z);
        return this.setXYZ(x / mag, y / mag, z / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector3.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector3.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector3.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector3.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector3.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector3.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector3.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector3.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector3.max(this, other, this);
    }
    /**
   * Creates a new Vector3 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector3(0, 0, 0);
    }
    /**
   * Creates a new Vector3 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector3(1, 1, 1);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the X axis, i.e. vec3(1, 0, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector3(1, 0, 0);
    }
    /**
   * Creates a new Vector3 pointing in the negative direction of the X axis, i.e. vec3(-1, 0, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector3(-1, 0, 0);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the Y axis, i.e. vec3(0, 1, 0)
   * @returns The new vector
   */ static axisPY() {
        return new Vector3(0, 1, 0);
    }
    /**
   * Creates a new Vector3 pointing in the negative direction of the Y axis, i.e. vec3(0, -1, 0)
   * @returns The new vector
   */ static axisNY() {
        return new Vector3(0, -1, 0);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the Z axis, i.e. vec3(0, 0, 1)
   * @returns The new vector
   */ static axisPZ() {
        return new Vector3(0, 0, 1);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the Z axis, i.e. vec3(0, 0, -1)
   * @returns The new vector
   */ static axisNZ() {
        return new Vector3(0, 0, -1);
    }
    /**
   * Calculates the distance between two Vector3's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns distance between v1 and v2
   */ static distance(v1, v2) {
        return Math.sqrt(this.distanceSq(v1, v2));
    }
    /**
   * Calculates the squared distance between two Vector3's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns squared distance between v1 and v2
   */ static distanceSq(v1, v2) {
        const dx = v1.x - v2.x;
        const dy = v1.y - v2.y;
        const dz = v1.z - v2.z;
        return dx * dx + dy * dy + dz * dz;
    }
    /**
   * Normalize a Vector3
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        const z = v.z / len;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Inverse a Vector3
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        const z = 1 / v.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Subtract two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = a.z - b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Add two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        const z = a.z + b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Multiply two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        const z = a.z * b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Divide two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        const z = a.z / b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Scale a Vector3 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        const z = a.z * b;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the minimum of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        const z = a.z < b.z ? a.z : b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the maximum of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        const z = a.z > b.z ? a.z : b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the absolute values of a Vector3.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        const z = a.z < 0 ? -a.z : a.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the dot product of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }
    /**
   * Calculates the cross product of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns the cross product of the two vectors.
   */ static cross(a, b, result) {
        const x = a.y * b.z - a.z * b.y;
        const y = a.z * b.x - a.x * b.z;
        const z = a.x * b.y - a.y * b.x;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
}
/**
 * 4 dimentional vector
 * @public
 */ class Vector4 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 4);
        } else {
            super(4);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[3];
            } else if (arg0 !== void 0) {
                throw new Error('Vector4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Vector4 initialized with values from this vector.
   * @returns The new vector.
   */ clone() {
        return new Vector4(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the w component value. */ get w() {
        return this[3];
    }
    set w(v) {
        this[3] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3];
    }
    /**
   * Creates a new Vector2 initialized with x, y component of this vector.
   * @returns The new vector
   */ xy() {
        return new Vector2(this.x, this.y);
    }
    /**
   * Creates a new Vector3 initialized with x, y, z component of this vector.
   * @returns The new vector
   */ xyz() {
        return new Vector3(this.x, this.y, this.z);
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setXYZW(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setAndNormalize(x, y, z, w) {
        const mag = Math.sqrt(x * x + y * y + z * z + w * w);
        return this.setXYZW(x / mag, y / mag, z / mag, w / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector4.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector4.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector4.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector4.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector4.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector4.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector4.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector4.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector4.max(this, other, this);
    }
    /**
   * Creates a new Vector4 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector4(0, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector4(1, 1, 1, 1);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the X axis, i.e. vec4(1, 0, 0, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector4(1, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the X axis, i.e. vec4(-1, 0, 0, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector4(-1, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the Y axis, i.e. vec4(0, 1, 0, 0)
   * @returns The new vector
   */ static axisPY() {
        return new Vector4(0, 1, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the Y axis, i.e. vec4(0, -1, 0, 0)
   * @returns The new vector
   */ static axisNY() {
        return new Vector4(0, -1, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the Z axis, i.e. vec4(0, 0, 1, 0)
   * @returns The new vector
   */ static axisPZ() {
        return new Vector4(0, 0, 1, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the Z axis, i.e. vec4(0, 0, -1, 0)
   * @returns The new vector
   */ static axisNZ() {
        return new Vector4(0, 0, -1, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the W axis, i.e. vec4(0, 0, 0, 1)
   * @returns The new vector
   */ static axisPW() {
        return new Vector4(0, 0, 0, 1);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the W axis, i.e. vec4(0, 0, 0, -1)
   * @returns The new vector
   */ static axisNW() {
        return new Vector4(0, 0, 0, -1);
    }
    /**
   * Normalize a Vector4
   * @param v - The input vector
   * @param result - The output vector (can be the same as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        const z = v.z / len;
        const w = v.w / len;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Inverse a Vector4
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        const z = 1 / v.z;
        const w = 1 / v.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Subtract two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = a.z - b.z;
        const w = a.w - b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Add two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        const z = a.z + b.z;
        const w = a.w + b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Multiply two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        const z = a.z * b.z;
        const w = a.w * b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Divide two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        const z = a.z / b.z;
        const w = a.w / b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Scale a Vector4 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        const z = a.z * b;
        const w = a.w * b;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the minimum of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        const z = a.z < b.z ? a.z : b.z;
        const w = a.w < b.w ? a.w : b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the maximum of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        const z = a.z > b.z ? a.z : b.z;
        const w = a.w > b.w ? a.w : b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the absolute values of a Vector4.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        const z = a.z < 0 ? -a.z : a.z;
        const w = a.w < 0 ? -a.w : a.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the dot product of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
    }
}
/**
 * Quaternion
 * @public
 */ class Quaternion extends VectorBase {
    constructor(arg0, arg1, arg2, arg3){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 4);
        } else {
            super(4);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
            } else if (arg0 instanceof Matrix3x3 || arg0 instanceof Matrix4x4) {
                this.fromRotationMatrix(arg0);
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[3];
            } else if (arg0 === void 0) {
                this[0] = 0;
                this[1] = 0;
                this[2] = 0;
                this[3] = 1;
            } else {
                throw new Error('Quaternion.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Quaternion initialized with values from this quaternion.
   * @returns The new quaternion.
   */ clone() {
        return new Quaternion(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the w component value. */ get w() {
        return this[3];
    }
    set w(v) {
        this[3] = v;
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setXYZW(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this;
    }
    /**
   * Scale this quaternion by a scalar number.
   * @param f - amount to scale this quaternion by.
   * @returns self
   */ scaleBy(f) {
        return Quaternion.scale(this, f, this);
    }
    /**
   * Set component values and then normalize the quaternion.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setAndNormalize(x, y, z, w) {
        const mag = Math.sqrt(x * x + y * y + z * z + w * w);
        return this.setXYZW(x / mag, y / mag, z / mag, w / mag);
    }
    /** Get the length of the quaternion. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3]);
    }
    /** Get the squared length of the quaternion. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3];
    }
    /** Make this quaternion an identity quaternion */ identity() {
        return Quaternion.identity(this);
    }
    /**
   * Normalize this quaternion inplace.
   * @returns self
   */ inplaceNormalize() {
        return Quaternion.normalize(this, this);
    }
    /**
   * Calculates the conjugate of this quaternion inplace.
   * @returns self
   */ inplaceConjugate() {
        return Quaternion.conjugate(this, this);
    }
    /**
   * Multiply this quaternion by another quaternion at the right side inplace.
   * @param other - The quaternion that to be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Quaternion.multiply(this, other, this);
    }
    /**
   * Multiply this quaternion by another quaternion at the left side inplace.
   * @param other - The quaternion that to be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Quaternion.multiply(other, this, this);
    }
    /**
   * Make a quaternion used to rotate a unit vector to another inplace.
   * @param from - The unit vector to be rotated.
   * @param to - The destination unit vector.
   * @returns self
   */ unitVectorToUnitVector(from, to) {
        return Quaternion.unitVectorToUnitVector(from, to, this);
    }
    /**
   * Calculates the quaternion from an euler angle in specific order inplace.
   * @param x - Angle to rotate around X axis in radians.
   * @param y - Angle to rotate around Y axis in radians.
   * @param z - Angle to rotate around Z axis in radians.
   * @param order - Intrinsic order for conversion.
   * @returns self
   */ fromEulerAngle(x, y, z, order) {
        return Quaternion.fromEulerAngle(x, y, z, order, this);
    }
    /**
   * Calculates the quaternion from the given angle and rotation axis inplace.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle.
   * @returns self
   */ fromAxisAngle(axis, angle) {
        return Quaternion.fromAxisAngle(axis, angle, this);
    }
    /**
   * Calculates the rotation axis and angle for this quaternion
   * @param axis - A vector that receives the rotation axis.
   * @returns - The rotation angle
   */ toAxisAngle(axis) {
        const rad = Math.acos(this[3]) * 2;
        const s = Math.sin(rad / 2);
        if (s > 0.000001) {
            axis.setXYZ(this[0] / s, this[1] / 2, this[2] / s);
        } else {
            axis.setXYZ(1, 0, 0);
        }
        return rad;
    }
    /**
   * Convert this rotation to euler angles in ZYX order
   * @param angles - A vector that receives the euler angles. If not given, a new vector will be created.
   * @returns The vector that holds the euler angles.
   */ toEulerAngles(angles) {
        angles = angles ?? new Vector3();
        const t0 = 2 * (this.w * this.x + this.y * this.z);
        const t1 = 1 - 2 * (this.x * this.x + this.y * this.y);
        const roll = Math.atan2(t0, t1);
        const t2 = Math.max(-1, Math.min(1, 2 * (this.w * this.y - this.z * this.x)));
        const pitch = Math.asin(t2);
        const t3 = 2 * (this.w * this.z + this.x * this.y);
        const t4 = 1 - 2 * (this.y * this.y + this.z * this.z);
        const yaw = Math.atan2(t3, t4);
        return angles.setXYZ(roll, pitch, yaw);
    }
    /**
   * Calculates the quaternion from a rotation matrix inplace.
   * @param matrix - The rotation matrix.
   * @returns self
   */ fromRotationMatrix(matrix) {
        return Quaternion.fromRotationMatrix(matrix, this);
    }
    /**
   * Convert this quaternion to a 3x3 rotation matrix.
   * @param matrix - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix.
   */ toMatrix3x3(matrix) {
        const m = matrix || new Matrix3x3();
        this.toMatrix(m);
        return m;
    }
    /**
   * Convert this quaternion to a 4x4 rotation matrix.
   *
   * @remarks
   * Only left top 3x3 part of the matrix will be changed.
   *
   * @param matrix - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix.
   */ toMatrix4x4(matrix) {
        const m = matrix || Matrix4x4.identity();
        this.toMatrix(m);
        return m;
    }
    /**
   * Get the direction of axis x
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis x
   */ getDirectionX(result) {
        result = result ?? new Vector3();
        return result.setXYZ(1 - 2 * (this.y * this.y + this.z * this.z), 2 * (this.x * this.y + this.z * this.w), 2 * (this.z * this.x - this.y * this.w));
    }
    /**
   * Get the direction of axis y
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis y
   */ getDirectionY(result) {
        result = result ?? new Vector3();
        return result.setXYZ(2 * (this.x * this.y - this.z * this.w), 1 - 2 * (this.z * this.z + this.x * this.x), 2 * (this.y * this.z + this.x * this.w));
    }
    /**
   * Get the direction of axis z
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis z
   */ getDirectionZ(result) {
        result = result ?? new Vector3();
        return result.setXYZ(2 * (this.z * this.x + this.y * this.w), 2 * (this.y * this.z - this.x * this.w), 1 - 2 * (this.y * this.y + this.x * this.x));
    }
    /**
   * Get the rotate angle and the rotation axis for this quaternion.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns An vector4 that the x, y, z component presents the axis and the w component presents the angle.
   */ getAxisAngle(result) {
        result = result ?? new Vector4();
        const sign = this.w < 0 ? -1 : 1;
        const x = this.x * sign;
        const y = this.y * sign;
        const z = this.z * sign;
        const w = this.w * sign;
        const halfAngle = Math.acos(w);
        const sinHalf = Math.sin(halfAngle);
        return result.setXYZW(x / sinHalf, y / sinHalf, z / sinHalf, 2 * halfAngle);
    }
    /**
   * Rotate a vector
   * @param v - The vector to be rotated.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The rotation result.
   */ transform(v, result) {
        result = result || new Vector3();
        const x = this.x * 2;
        const y = this.y * 2;
        const z = this.z * 2;
        const xx = this.x * x;
        const yy = this.y * y;
        const zz = this.z * z;
        const xy = this.x * y;
        const xz = this.x * z;
        const yz = this.y * z;
        const wx = this.w * x;
        const wy = this.w * y;
        const wz = this.w * z;
        return result.setXYZ((1 - yy - zz) * v.x + (xy - wz) * v.y + (xz + wy) * v.z, (xy + wz) * v.x + (1 - xx - zz) * v.y + (yz - wx) * v.z, (xz - wy) * v.x + (yz + wx) * v.y + (1 - xx - yy) * v.z);
    }
    /**
   * Scale a Quaternion by a scalar number.
   * @param a - The quaternion to be scaled.
   * @param b - The scalar number.
   * @param result - The output quaternion (can be the same quaternion as a). if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static scale(q, t, result) {
        result = result || q;
        return result.setXYZW(q.x * t, q.y * t, q.z * t, q.w * t);
    }
    /**
   * Calculates the dot product of two Quaternion's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
    }
    /**
   * Create an identity quaternion
   * @param q - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static identity(q) {
        return (q || new Quaternion()).setXYZW(0, 0, 0, 1);
    }
    /**
   * Normalize a quaternion
   * @param q - The input quaternion
   * @param result - The output quaternion (can be the same as q), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static normalize(q, result) {
        const mag = q.magnitude;
        return (result || new Quaternion()).setXYZW(q.x / mag, q.y / mag, q.z / mag, q.w / mag);
    }
    /**
   * Gets the conjugate of a quaternion
   * @param q - The input quaternion
   * @param result - The output quaternion (can be the same as q), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static conjugate(q, result) {
        return (result || new Quaternion()).setXYZW(-q.x, -q.y, -q.z, q.w);
    }
    /**
   * Multiply two Quaternion's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output quaternion (can be the same as a or b). if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static multiply(a, b, result) {
        result = result || new Quaternion();
        const x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
        const y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
        const z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
        const w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        return result.setXYZW(x, y, z, w);
    }
    /**
   * Performs a spherical linear interpolation between two quat.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param t - The interpolation amount, in the range [0-1].
   * @param result - The output quaternion (can be the same as a or b), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static slerp(a, b, t, result) {
        result = result || new Quaternion();
        if (t <= 0) {
            return result.setXYZW(a.x, a.y, a.z, a.w);
        }
        if (t >= 1) {
            return result.setXYZW(b.x, b.y, b.z, b.w);
        }
        const halfCos1 = this.dot(a, b);
        const inv = halfCos1 < 0 ? -1 : 1;
        const ax = a.x;
        const ay = a.y;
        const az = a.z;
        const aw = a.w;
        const bx = b.x * inv;
        const by = b.y * inv;
        const bz = b.z * inv;
        const bw = b.w * inv;
        const halfCos = halfCos1 * inv;
        if (halfCos >= 1) {
            return result.setXYZW(ax, ay, az, aw);
        }
        const halfSinSqr = 1 - halfCos * halfCos;
        if (halfSinSqr <= Number.EPSILON) {
            const s = 1 - t;
            return result.setAndNormalize(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t, a.w * s + b.w * t);
        }
        const halfSin = Math.sqrt(halfSinSqr);
        const halfTheta = Math.atan2(halfSin, halfCos);
        const ratioA = Math.sin((1 - t) * halfTheta) / halfSin;
        const ratioB = Math.sin(t * halfTheta) / halfSin;
        return result.setXYZW(ax * ratioA + bx * ratioB, ay * ratioA + by * ratioB, az * ratioA + bz * ratioB, aw * ratioA + bw * ratioB);
    }
    /**
   * Gets the angular distance between two unit quaternions.
   * @param a - The origin quaternion
   * @param b - The destination quaternion
   * @returns - The angle in radians
   */ static angleBetween(a, b) {
        const x = this.dot(a, b);
        const clamped = x < -1 ? -1 : x > 1 ? 1 : x;
        return 2 * Math.acos(Math.abs(clamped));
    }
    /**
   * Creates a quaternion used to rotate a unit vector to another.
   * @param from - The unit vector to be rotated.
   * @param to - The destination unit vector.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static unitVectorToUnitVector(from, to, result) {
        // assume from and to are unit vectors
        result = result || new Quaternion();
        let r = Vector3.dot(from, to) + 1;
        if (r < 0.000001) {
            r = 0;
            if (Math.abs(from.x) > Math.abs(from.z)) {
                return result.setAndNormalize(-from.y, from.x, 0, r);
            } else {
                return result.setAndNormalize(0, -from.z, from.y, r);
            }
        } else {
            return result.setAndNormalize(from.y * to.z - from.z * to.y, from.z * to.x - from.x * to.z, from.x * to.y - from.y * to.x, r);
        }
    }
    /**
   * Creates a quaternion from an euler angle in specific order.
   * @param x - Angle to rotate around X axis in radians.
   * @param y - Angle to rotate around Y axis in radians.
   * @param z - Angle to rotate around Z axis in radians.
   * @param order - Intrinsic order for conversion.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static fromEulerAngle(a, b, c, order, result) {
        result = result || new Quaternion();
        const c1 = Math.cos(a / 2);
        const c2 = Math.cos(b / 2);
        const c3 = Math.cos(c / 2);
        const s1 = Math.sin(a / 2);
        const s2 = Math.sin(b / 2);
        const s3 = Math.sin(c / 2);
        switch(order){
            case 'XYZ':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'YXZ':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
            case 'ZXY':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'ZYX':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
            case 'YZX':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'XZY':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
        }
    }
    /**
   * Creates a quaternion from the given angle and rotation axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static fromAxisAngle(axis, angle, result) {
        // assume axis is normalized
        result = result || new Quaternion();
        const halfAngle = angle / 2;
        const s = Math.sin(halfAngle);
        return result.setXYZW(axis.x * s, axis.y * s, axis.z * s, Math.cos(halfAngle));
    }
    /**
   * Creates a quaternion from a rotation matrix.
   * @param matrix - The rotation matrix.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns self
   */ static fromRotationMatrix(matrix, result) {
        // assume matrix contains rotation without scaling
        result = result || new Quaternion();
        const trace = matrix.m00 + matrix.m11 + matrix.m22;
        let s;
        if (trace > 0) {
            s = 0.5 / Math.sqrt(trace + 1);
            result.setXYZW((matrix.m21 - matrix.m12) * s, (matrix.m02 - matrix.m20) * s, (matrix.m10 - matrix.m01) * s, 0.25 / s);
        } else if (matrix.m00 > matrix.m11 && matrix.m00 > matrix.m22) {
            s = 2 * Math.sqrt(1 + matrix.m00 - matrix.m11 - matrix.m22);
            result.setXYZW(0.25 * s, (matrix.m01 + matrix.m10) / s, (matrix.m02 + matrix.m20) / s, (matrix.m21 - matrix.m12) / s);
        } else if (matrix.m11 > matrix.m22) {
            s = 2 * Math.sqrt(1 - matrix.m00 + matrix.m11 - matrix.m22);
            result.setXYZW((matrix.m10 + matrix.m01) / s, 0.25 * s, (matrix.m21 + matrix.m12) / s, (matrix.m02 - matrix.m20) / s);
        } else {
            s = 2 * Math.sqrt(1 - matrix.m00 - matrix.m11 + matrix.m22);
            result.setXYZW((matrix.m02 + matrix.m20) / s, (matrix.m12 + matrix.m21) / s, 0.25 * s, (matrix.m10 - matrix.m01) / s);
        }
        return result;
    }
    /** @internal */ toMatrix(matrix) {
        const xx = this.x * this.x;
        const yy = this.y * this.y;
        const zz = this.z * this.z;
        const xy = this.x * this.y;
        const zw = this.z * this.w;
        const zx = this.z * this.x;
        const yw = this.y * this.w;
        const yz = this.y * this.z;
        const xw = this.x * this.w;
        matrix.m00 = 1 - 2 * (yy + zz);
        matrix.m10 = 2 * (xy + zw);
        matrix.m20 = 2 * (zx - yw);
        matrix.m01 = 2 * (xy - zw);
        matrix.m11 = 1 - 2 * (zz + xx);
        matrix.m21 = 2 * (yz + xw);
        matrix.m02 = 2 * (zx + yw);
        matrix.m12 = 2 * (yz - xw);
        matrix.m22 = 1 - 2 * (yy + xx);
    }
}
/**
 * 3x3 Matrix
 *
 * @remarks
 * The matrix is column-major:
 * | m00, m10, m20 |
 * | m01, m11, m21 |
 * | m02, m12, m22 |
 *
 * @public
 */ class Matrix3x3 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 9);
        } else {
            super(9);
            if (typeof arg0 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
                this[4] = arg4;
                this[5] = arg5;
                this[6] = arg6;
                this[7] = arg7;
                this[8] = arg8;
            } else if (arg0 instanceof Quaternion) {
                arg0.toMatrix3x3(this);
            } else if (arg0 instanceof Matrix4x4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[4];
                this[4] = arg0[5];
                this[5] = arg0[6];
                this[6] = arg0[8];
                this[7] = arg0[9];
                this[8] = arg0[10];
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 9) {
                this.set(arg0);
            } else if (arg0 === void 0) {
                this.identity();
            } else {
                throw new Error('Matrix3x4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Matrix3x3 initialized with values from this matrix.
   * @returns The new matrix.
   */ clone() {
        return new Matrix3x3(this);
    }
    /** Get the element at row 0, column 0 */ get m00() {
        return this[0];
    }
    set m00(v) {
        this[0] = v;
    }
    /** Get the element at row 0, column 1 */ get m10() {
        return this[1];
    }
    set m10(v) {
        this[1] = v;
    }
    /** Get the element at row 0, column 2 */ get m20() {
        return this[2];
    }
    set m20(v) {
        this[2] = v;
    }
    /** Get the element at row 1, column 0 */ get m01() {
        return this[3];
    }
    set m01(v) {
        this[3] = v;
    }
    /** Get the element at row 1, column 1 */ get m11() {
        return this[4];
    }
    set m11(v) {
        this[4] = v;
    }
    /** Get the element at row 1, column 2 */ get m21() {
        return this[5];
    }
    set m21(v) {
        this[5] = v;
    }
    /** Get the element at row 2, column 0 */ get m02() {
        return this[6];
    }
    set m02(v) {
        this[6] = v;
    }
    /** Get the element at row 2, column 1 */ get m12() {
        return this[7];
    }
    set m12(v) {
        this[7] = v;
    }
    /** Get the element at row 2, column 2 */ get m22() {
        return this[8];
    }
    set m22(v) {
        this[8] = v;
    }
    /**
   * Get the values in a row as a Vector3
   * @param row - The row index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getRow(row, result) {
        return (result || new Vector3()).setXYZ(this[row * 3], this[row * 3 + 1], this[row * 3 + 2]);
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param v - The values to be set
   * @returns - self
   */ setRow(row, v) {
        this[row * 3] = v.x;
        this[row * 3 + 1] = v.y;
        this[row * 3 + 2] = v.z;
        return this;
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param x - The first value of the row to be set
   * @param y - The second value of the row to be set
   * @param z - The third value of the row to be set
   * @returns - self
   */ setRowXYZ(row, x, y, z) {
        this[row * 3] = x;
        this[row * 3 + 1] = y;
        this[row * 3 + 2] = z;
        return this;
    }
    /**
   * Get the values in a column as a Vector3
   * @param col - The column index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getCol(col, result) {
        return (result || new Vector3()).setXYZ(this[col], this[3 + col], this[6 + col]);
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param v - The values to be set.
   * @returns self
   */ setCol(col, v) {
        this[col] = v.x;
        this[3 + col] = v.y;
        this[6 + col] = v.z;
        return this;
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param x - The first value of the column to be set.
   * @param y - The second value of the column to be set.
   * @param z - The third value of the column to be set.
   * @returns self
   */ setColXYZ(col, x, y, z) {
        this[col] = x;
        this[3 + col] = y;
        this[6 + col] = z;
        return this;
    }
    /**
   * Adds two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static add(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] + b[i];
        }
        return result;
    }
    /**
   * Subtracts two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns
   */ static sub(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] - b[i];
        }
        return result;
    }
    /**
   * Multiplys two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static mul(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] * b[i];
        }
        return result;
    }
    /**
   * Divides two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static div(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] / b[i];
        }
        return result;
    }
    /**
   * Scales a Matrix3x3 by a scalar number component-wise.
   * @param a - The matrix to be scaled.
   * @param f - The scalar number.
   * @param result - The output matrix (can be the same as a), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scale(a, f, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] * f;
        }
        return result;
    }
    /**
   * Creates an identity Matrix3x3.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static identity(result) {
        result = result || new Matrix3x3();
        result.set(IDENT_MATRIX3x3);
        return result;
    }
    /**
   * Transpose a Matrix3x3.
   * @param matrix - The matrix to be transposed.
   * @param result - The output matrix (can be the same as matrix), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static transpose(matrix, result) {
        result = result || new Matrix3x3();
        if (matrix === result) {
            [result[1], result[3]] = [
                result[3],
                result[1]
            ];
            [result[2], result[6]] = [
                result[6],
                result[2]
            ];
            [result[5], result[7]] = [
                result[7],
                result[5]
            ];
        } else {
            result[0] = matrix[0];
            result[1] = matrix[3];
            result[2] = matrix[6];
            result[3] = matrix[1];
            result[4] = matrix[4];
            result[5] = matrix[7];
            result[6] = matrix[2];
            result[7] = matrix[5];
            result[8] = matrix[8];
        }
        return result;
    }
    /**
   * Inverts a Matrix3x3
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invert(matrix, result) {
        result = result || new Matrix3x3();
        const m00 = matrix[0];
        const m01 = matrix[1];
        const m02 = matrix[2];
        const m10 = matrix[3];
        const m11 = matrix[4];
        const m12 = matrix[5];
        const m20 = matrix[6];
        const m21 = matrix[7];
        const m22 = matrix[8];
        const tmp_0 = m22 * m11 - m12 * m21;
        const tmp_1 = m12 * m20 - m22 * m10;
        const tmp_2 = m21 * m10 - m20 * m11;
        const d = 1 / (m00 * tmp_0 + m01 * tmp_1 + m02 * tmp_2);
        result[0] = tmp_0 * d;
        result[1] = (m02 * m21 - m22 * m01) * d;
        result[2] = (m12 * m01 - m02 * m11) * d;
        result[3] = tmp_1 * d;
        result[4] = (m22 * m00 - m02 * m20) * d;
        result[5] = (m02 * m10 - m12 * m00) * d;
        result[6] = tmp_2 * d;
        result[7] = (m01 * m20 - m21 * m00) * d;
        result[8] = (m11 * m00 - m01 * m10) * d;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around x axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationX(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = c;
        result[5] = s;
        result[6] = 0;
        result[7] = -s;
        result[8] = c;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around y axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationY(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = 0;
        result[2] = -s;
        result[3] = 0;
        result[4] = 1;
        result[5] = 0;
        result[6] = s;
        result[7] = 0;
        result[8] = c;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around z axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationZ(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = s;
        result[2] = 0;
        result[3] = -s;
        result[4] = c;
        result[5] = 0;
        result[6] = 0;
        result[7] = 0;
        result[8] = 1;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around a given axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotation(axis, angle, result) {
        result = result || new Matrix3x3();
        let x = axis.x;
        let y = axis.y;
        let z = axis.z;
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const oneMinusCosine = 1 - c;
        result[0] = xx + (1 - xx) * c;
        result[1] = x * y * oneMinusCosine + z * s;
        result[2] = x * z * oneMinusCosine - y * s;
        result[3] = x * y * oneMinusCosine - z * s;
        result[4] = yy + (1 - yy) * c;
        result[5] = y * z * oneMinusCosine + x * s;
        result[6] = x * z * oneMinusCosine + y * s;
        result[7] = y * z * oneMinusCosine - x * s;
        result[8] = zz + (1 - zz) * c;
        return result;
    }
    /**
   * Multiplies two Matrix3x3's
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiply(m1, m2, result) {
        result = result || new Matrix3x3();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a10 = m1[3];
        const a11 = m1[4];
        const a12 = m1[5];
        const a20 = m1[6];
        const a21 = m1[7];
        const a22 = m1[8];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b10 = m2[3];
        const b11 = m2[4];
        const b12 = m2[5];
        const b20 = m2[6];
        const b21 = m2[7];
        const b22 = m2[8];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = a00 * b10 + a10 * b11 + a20 * b12;
        result[4] = a01 * b10 + a11 * b11 + a21 * b12;
        result[5] = a02 * b10 + a12 * b11 + a22 * b12;
        result[6] = a00 * b20 + a10 * b21 + a20 * b22;
        result[7] = a01 * b20 + a11 * b21 + a21 * b22;
        result[8] = a02 * b20 + a12 * b21 + a22 * b22;
        return result;
    }
    /**
   * Subtract a matrix from this matrix component-wise.
   * @param other - The matrix that will be subtract.
   * @returns self
   */ subBy(other) {
        return Matrix3x3.sub(this, other, this);
    }
    /**
   * Add a matrix to this matrix component-wise.
   * @param other - The matrix that will be added.
   * @returns self
   */ addBy(other) {
        return Matrix3x3.add(this, other, this);
    }
    /**
   * Multiplies this matrix by a matrix component-wise.
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Matrix3x3.mul(this, other, this);
    }
    /**
   * Divide this matrix by a matrix component-wise.
   * @param other - The matrix that will be divide by.
   * @returns self
   */ divBy(other) {
        return Matrix3x3.div(this, other, this);
    }
    /**
   * Scale this matrix by a scalar number component-wise.
   * @param f - amount to scale this matrix by.
   * @returns self
   */ scaleBy(f) {
        return Matrix3x3.scale(this, f, this);
    }
    /**
   * Make this matrix identity.
   * @returns self
   */ identity() {
        return Matrix3x3.identity(this);
    }
    /**
   * Calculate the inverse of this matrix inplace.
   * @returns self
   */ inplaceInvert() {
        return Matrix3x3.invert(this, this);
    }
    /**
   * Calculate the transpose of this matrix inplace.
   * @returns self
   */ transpose() {
        return Matrix3x3.transpose(this, this);
    }
    /**
   * Post-multiply by a matrix inplace.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Matrix3x3.multiply(this, other, this);
    }
    /**
   * Pre-multiply by a matrix inplace.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Matrix3x3.multiply(other, this, this);
    }
    /**
   * Calculates a rotation around x axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationX(angle) {
        return Matrix3x3.rotationX(angle, this);
    }
    /**
   * Calculates a rotation around y axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationY(angle) {
        return Matrix3x3.rotationY(angle, this);
    }
    /**
   * Calculates a rotation around z axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationZ(angle) {
        return Matrix3x3.rotationZ(angle, this);
    }
    /**
   * Calculates a rotation around a given axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotation(axis, angle) {
        return Matrix3x3.rotation(axis, angle, this);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transform(vec, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * vec[0] + this[3] * vec[1] + this[6] * vec[2], this[1] * vec[0] + this[4] * vec[1] + this[7] * vec[2], this[2] * vec[0] + this[5] * vec[1] + this[8] * vec[2]);
    }
    /**
   * {@inheritDoc Matrix3x3.transform}
   */ transformPoint(vec, result) {
        return this.transform(vec, result);
    }
    /**
   * {@inheritDoc Matrix3x3.transform}
   */ transformVector(vec, result) {
        return this.transform(vec, result);
    }
}
/**
 * 4x4 Matrix
 *
 * @remarks
 * The matrix is column-major:
 * | m00, m10, m20, m30 |
 * | m01, m11, m21, m31 |
 * | m02, m12, m22, m32 |
 * | m03, m13, m23, m33 |
 *
 * @public
 */ class Matrix4x4 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 16);
        } else {
            super(16);
            if (typeof arg0 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
                this[4] = arg4;
                this[5] = arg5;
                this[6] = arg6;
                this[7] = arg7;
                this[8] = arg8;
                this[9] = arg9;
                this[10] = arg10;
                this[11] = arg11;
                this[12] = arg12;
                this[13] = arg13;
                this[14] = arg14;
                this[15] = arg15;
            } else if (arg0 instanceof Quaternion) {
                arg0.toMatrix4x4(this);
                this.m03 = 0;
                this.m13 = 0;
                this.m23 = 0;
                this.m30 = 0;
                this.m31 = 0;
                this.m32 = 0;
                this.m33 = 1;
            } else if (arg0 instanceof Matrix3x3) {
                this.m00 = arg0.m00;
                this.m01 = arg0.m01;
                this.m02 = arg0.m02;
                this.m03 = 0;
                this.m10 = arg0.m10;
                this.m11 = arg0.m11;
                this.m12 = arg0.m12;
                this.m13 = 0;
                this.m20 = arg0.m20;
                this.m21 = arg0.m21;
                this.m22 = arg0.m22;
                this.m23 = 0;
                this.m30 = 0;
                this.m31 = 0;
                this.m32 = 0;
                this.m33 = 1;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 16) {
                this.set(arg0);
            } else if (arg0 === void 0) {
                this.identity();
            } else {
                throw new Error('Matrix4x4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Matrix4x4 initialized with values from this matrix.
   * @returns The new matrix.
   */ clone() {
        return new Matrix4x4(this);
    }
    /** Get the element at row 0, column 0 */ get m00() {
        return this[0];
    }
    set m00(v) {
        this[0] = v;
    }
    /** Get the element at row 0, column 1 */ get m10() {
        return this[1];
    }
    set m10(v) {
        this[1] = v;
    }
    /** Get the element at row 0, column 2 */ get m20() {
        return this[2];
    }
    set m20(v) {
        this[2] = v;
    }
    /** Get the element at row 0, column 3 */ get m30() {
        return this[3];
    }
    set m30(v) {
        this[3] = v;
    }
    /** Get the element at row 1, column 0 */ get m01() {
        return this[4];
    }
    set m01(v) {
        this[4] = v;
    }
    /** Get the element at row 1, column 1 */ get m11() {
        return this[5];
    }
    set m11(v) {
        this[5] = v;
    }
    /** Get the element at row 1, column 2 */ get m21() {
        return this[6];
    }
    set m21(v) {
        this[6] = v;
    }
    /** Get the element at row 1, column 3 */ get m31() {
        return this[7];
    }
    set m31(v) {
        this[7] = v;
    }
    /** Get the element at row 2, column 0 */ get m02() {
        return this[8];
    }
    set m02(v) {
        this[8] = v;
    }
    /** Get the element at row 2, column 1 */ get m12() {
        return this[9];
    }
    set m12(v) {
        this[9] = v;
    }
    /** Get the element at row 2, column 2 */ get m22() {
        return this[10];
    }
    set m22(v) {
        this[10] = v;
    }
    /** Get the element at row 2, column 3 */ get m32() {
        return this[11];
    }
    set m32(v) {
        this[11] = v;
    }
    /** Get the element at row 3, column 0 */ get m03() {
        return this[12];
    }
    set m03(v) {
        this[12] = v;
    }
    /** Get the element at row 3, column 1 */ get m13() {
        return this[13];
    }
    set m13(v) {
        this[13] = v;
    }
    /** Get the element at row 3, column 2 */ get m23() {
        return this[14];
    }
    set m23(v) {
        this[14] = v;
    }
    /** Get the element at row 3, column 3 */ get m33() {
        return this[15];
    }
    set m33(v) {
        this[15] = v;
    }
    /**
   * Get the values in a row as a Vector4
   * @param row - The row index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getRow(row, result) {
        return (result || new Vector4()).setXYZW(this[row * 4], this[row * 4 + 1], this[row * 4 + 2], this[row * 4 + 3]);
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param v - The values to be set
   * @returns - self
   */ setRow(row, v) {
        this[row * 4] = v.x;
        this[row * 4 + 1] = v.y;
        this[row * 4 + 2] = v.z;
        this[row * 4 + 3] = v.w;
        return this;
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param x - The first value of the row to be set
   * @param y - The second value of the row to be set
   * @param z - The third value of the row to be set
   * @param w - The fourth value of the row to be set
   * @returns - self
   */ setRowXYZW(row, x, y, z, w) {
        this[row * 4] = x;
        this[row * 4 + 1] = y;
        this[row * 4 + 2] = z;
        this[row * 4 + 3] = w;
        return this;
    }
    /**
   * Get the values in a column as a Vector4
   * @param col - The column index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getCol(col, result) {
        return (result || new Vector4()).setXYZW(this[col], this[4 + col], this[8 + col], this[12 + col]);
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param v - The values to be set.
   * @returns self
   */ setCol(col, v) {
        this[col] = v.x;
        this[4 + col] = v.y;
        this[8 + col] = v.z;
        this[12 + col] = v.w;
        return this;
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param x - The first value of the column to be set.
   * @param y - The second value of the column to be set.
   * @param z - The third value of the column to be set.
   * @param w - The fourth value of the column to be set.
   * @returns self
   */ setColXYZW(col, x, y, z, w) {
        this[col] = x;
        this[4 + col] = y;
        this[8 + col] = z;
        this[12 + col] = w;
        return this;
    }
    /**
   * Adds two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static add(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] + b[i];
        }
        return result;
    }
    /**
   * Subtracts two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns
   */ static sub(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] - b[i];
        }
        return result;
    }
    /**
   * Multiplys two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static mul(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] * b[i];
        }
        return result;
    }
    /**
   * Divides two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static div(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] / b[i];
        }
        return result;
    }
    /**
   * Scales a Matrix4x4 by a scalar number component-wise.
   * @param a - The matrix to be scaled.
   * @param f - The scalar number.
   * @param result - The output matrix (can be the same as a), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scale(a, f, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] * f;
        }
        return result;
    }
    /**
   * Creates an identity Matrix4x4.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static identity(result) {
        result = result || new Matrix4x4();
        result.set(IDENT_MATRIX4x4);
        return result;
    }
    /**
   * Creates an orthogonal projection matrix from a given frustum.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static ortho(left, right, bottom, top, near, far, result) {
        result = result || new Matrix4x4();
        result[0] = 2 / (right - left);
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 2 / (top - bottom);
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 2 / (near - far);
        result[11] = 0;
        result[12] = (left + right) / (left - right);
        result[13] = (bottom + top) / (bottom - top);
        result[14] = (near + far) / (near - far);
        result[15] = 1;
        return result;
    }
    /**
   * Creates a reflection matrix from a plane.
   * @param nx - The x component of the plane normal.
   * @param ny - The y component of the plane normal.
   * @param nz - The z component of the plane normal.
   * @param d - The plane distance.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static reflection(nx, ny, nz, d, result) {
        result = result || new Matrix4x4();
        result.m00 = 1 - 2 * nx * nx;
        result.m01 = -2 * nx * ny;
        result.m02 = -2 * nx * nz;
        result.m03 = -2 * nx * d;
        result.m10 = -2 * nx * ny;
        result.m11 = 1 - 2 * ny * ny;
        result.m12 = -2 * ny * nz;
        result.m13 = -2 * ny * d;
        result.m20 = -2 * nx * nz;
        result.m21 = -2 * ny * nz;
        result.m22 = 1 - 2 * nz * nz;
        result.m23 = -2 * nz * d;
        result.m30 = 0;
        result.m31 = 0;
        result.m32 = 0;
        result.m33 = 1;
        return result;
    }
    /**
   * Creates a right-handed perspective projection matrix.
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio.
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static perspective(fovY, aspect, znear, zfar, result) {
        const h = znear * Math.tan(fovY * 0.5);
        const w = h * aspect;
        return this.frustum(-w, w, -h, h, znear, zfar, result);
    }
    static obliqueProjection(projectionMatrix, clipPlane) {
        const result = new Matrix4x4(projectionMatrix);
        const q = Matrix4x4.invert(projectionMatrix).transform(new Vector4(clipPlane.a > 0 ? 1 : -1, clipPlane.b > 0 ? 1 : -1, 1, 1));
        const s = 2 / (q.x * clipPlane.a + q.y * clipPlane.b + q.z * clipPlane.c + q.w * clipPlane.d);
        result[2] = clipPlane.a * s - result[3];
        result[6] = clipPlane.b * s - result[7];
        result[10] = clipPlane.c * s - result[11];
        result[14] = clipPlane.d * s - result[15];
        return result;
    }
    static obliquePerspective(perspectiveMatrix, nearPlane) {
        const result = new Matrix4x4(perspectiveMatrix);
        const q = new Vector4(((nearPlane.x > 0 ? 1 : nearPlane.x < 0 ? -1 : 0) + perspectiveMatrix.m02) / perspectiveMatrix.m00, ((nearPlane.y > 0 ? 1 : nearPlane.y < 0 ? -1 : 0) + perspectiveMatrix.m12) / perspectiveMatrix.m11, -1, (1 + perspectiveMatrix.m22) / perspectiveMatrix.m23);
        const c = Vector4.scale(nearPlane, 2 / Vector4.dot(nearPlane, q));
        result.m20 = c.x;
        result.m21 = c.y;
        result.m22 = c.z + 1;
        result.m23 = c.w;
        return result;
    /*
        float       matrix[16];
        Vector4D    q;

        // Grab the current projection matrix from OpenGL
        glGetFloatv(GL_PROJECTION_MATRIX, matrix);

        // Calculate the clip-space corner point opposite the clipping plane
        // as (sgn(clipPlane.x), sgn(clipPlane.y), 1, 1) and
        // transform it into camera space by multiplying it
        // by the inverse of the projection matrix

        q.x = (sgn(clipPlane.x) + matrix[8]) / matrix[0];
        q.y = (sgn(clipPlane.y) + matrix[9]) / matrix[5];
        q.z = -1.0F;
        q.w = (1.0F + matrix[10]) / matrix[14];

        // Calculate the scaled plane vector
        Vector4D c = clipPlane * (2.0F / Dot(clipPlane, q));

        // Replace the third row of the projection matrix
        matrix[2] = c.x;
        matrix[6] = c.y;
        matrix[10] = c.z + 1.0F;
        matrix[14] = c.w;

        // Load it back into OpenGL
        glMatrixMode(GL_PROJECTION);
        glLoadMatrix(matrix);
    }
    */ }
    /**
   * Creates a perspective projection matrix from a frustum.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param znear - Near bound of the frustum.
   * @param zfar - Far bound of the frustum.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static frustum(left, right, bottom, top, znear, zfar, result) {
        result = result || new Matrix4x4();
        const dx = right - left;
        const dy = top - bottom;
        const dz = znear - zfar;
        result[0] = 2 * znear / dx;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 2 * znear / dy;
        result[6] = 0;
        result[7] = 0;
        result[8] = (left + right) / dx;
        result[9] = (top + bottom) / dy;
        result[10] = (znear + zfar) / dz;
        result[11] = -1;
        result[12] = 0;
        result[13] = 0;
        result[14] = 2 * znear * zfar / dz;
        result[15] = 0;
        return result;
    }
    /**
   * Transpose a Matrix4x4.
   * @param matrix - The matrix to be transposed.
   * @param result - The output matrix (can be the same as matrix), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static transpose(matrix, result) {
        result = result || new Matrix4x4();
        if (matrix === result) {
            [result[1], result[4]] = [
                result[4],
                result[1]
            ];
            [result[2], result[8]] = [
                result[8],
                result[2]
            ];
            [result[3], result[12]] = [
                result[12],
                result[3]
            ];
            [result[6], result[9]] = [
                result[9],
                result[6]
            ];
            [result[7], result[13]] = [
                result[13],
                result[7]
            ];
            [result[11], result[14]] = [
                result[14],
                result[11]
            ];
        } else {
            result[0] = matrix[0];
            result[1] = matrix[4];
            result[2] = matrix[8];
            result[3] = matrix[12];
            result[4] = matrix[1];
            result[5] = matrix[5];
            result[6] = matrix[9];
            result[7] = matrix[13];
            result[8] = matrix[2];
            result[9] = matrix[6];
            result[10] = matrix[10];
            result[11] = matrix[14];
            result[12] = matrix[3];
            result[13] = matrix[7];
            result[14] = matrix[11];
            result[15] = matrix[15];
        }
        return result;
    }
    /**
   * Inverts a Matrix4x4
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invert(matrix, result) {
        result = result || new Matrix4x4();
        const m00 = matrix[0 * 4 + 0];
        const m01 = matrix[0 * 4 + 1];
        const m02 = matrix[0 * 4 + 2];
        const m03 = matrix[0 * 4 + 3];
        const m10 = matrix[1 * 4 + 0];
        const m11 = matrix[1 * 4 + 1];
        const m12 = matrix[1 * 4 + 2];
        const m13 = matrix[1 * 4 + 3];
        const m20 = matrix[2 * 4 + 0];
        const m21 = matrix[2 * 4 + 1];
        const m22 = matrix[2 * 4 + 2];
        const m23 = matrix[2 * 4 + 3];
        const m30 = matrix[3 * 4 + 0];
        const m31 = matrix[3 * 4 + 1];
        const m32 = matrix[3 * 4 + 2];
        const m33 = matrix[3 * 4 + 3];
        const tmp_0 = m22 * m33;
        const tmp_1 = m32 * m23;
        const tmp_2 = m12 * m33;
        const tmp_3 = m32 * m13;
        const tmp_4 = m12 * m23;
        const tmp_5 = m22 * m13;
        const tmp_6 = m02 * m33;
        const tmp_7 = m32 * m03;
        const tmp_8 = m02 * m23;
        const tmp_9 = m22 * m03;
        const tmp_10 = m02 * m13;
        const tmp_11 = m12 * m03;
        const tmp_12 = m20 * m31;
        const tmp_13 = m30 * m21;
        const tmp_14 = m10 * m31;
        const tmp_15 = m30 * m11;
        const tmp_16 = m10 * m21;
        const tmp_17 = m20 * m11;
        const tmp_18 = m00 * m31;
        const tmp_19 = m30 * m01;
        const tmp_20 = m00 * m21;
        const tmp_21 = m20 * m01;
        const tmp_22 = m00 * m11;
        const tmp_23 = m10 * m01;
        const t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
        const t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
        const t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
        const t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
        const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        result[0] = d * t0;
        result[1] = d * t1;
        result[2] = d * t2;
        result[3] = d * t3;
        result[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
        result[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
        result[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
        result[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
        result[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
        result[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
        result[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
        result[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
        result[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
        result[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
        result[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
        result[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));
        return result;
    }
    /**
   * Inverts a Matrix4x4 which presents an affine transformation.
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invertAffine(matrix, result) {
        result = result || new Matrix4x4();
        const m00 = matrix[0 * 4 + 0];
        const m01 = matrix[0 * 4 + 1];
        const m02 = matrix[0 * 4 + 2];
        const m10 = matrix[1 * 4 + 0];
        const m11 = matrix[1 * 4 + 1];
        const m12 = matrix[1 * 4 + 2];
        const m20 = matrix[2 * 4 + 0];
        const m21 = matrix[2 * 4 + 1];
        const m22 = matrix[2 * 4 + 2];
        const m30 = matrix[3 * 4 + 0];
        const m31 = matrix[3 * 4 + 1];
        const m32 = matrix[3 * 4 + 2];
        const t0 = m22 * m11 - m12 * m21;
        const t1 = m02 * m21 - m22 * m01;
        const t2 = m12 * m01 - m02 * m11;
        const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2);
        result[0] = d * t0;
        result[1] = d * t1;
        result[2] = d * t2;
        result[3] = 0;
        result[4] = d * (m12 * m20 - m22 * m10);
        result[5] = d * (m22 * m00 - m02 * m20);
        result[6] = d * (m02 * m10 - m12 * m00);
        result[7] = 0;
        result[8] = d * (m10 * m21 - m20 * m11);
        result[9] = d * (m20 * m01 - m00 * m21);
        result[10] = d * (m00 * m11 - m10 * m01);
        result[11] = 0;
        result[12] = d * (m10 * m31 * m22 + m20 * m11 * m32 + m30 * m21 * m12 - (m10 * m21 * m32 + m20 * m31 * m12 + m30 * m11 * m22));
        result[13] = d * (m00 * m21 * m32 + m20 * m31 * m02 + m30 * m01 * m22 - (m00 * m31 * m22 + m20 * m01 * m32 + m30 * m21 * m02));
        result[14] = d * (m00 * m31 * m12 + m10 * m01 * m32 + m30 * m11 * m02 - (m00 * m11 * m32 + m10 * m31 * m02 + m30 * m01 * m12));
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a translation.
   * @param t - The translate vector.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translation(t, result) {
        result = result || new Matrix4x4();
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 1;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 1;
        result[11] = 0;
        result[12] = t.x;
        result[13] = t.y;
        result[14] = t.z;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a scaling.
   * @param s - The scale vector.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaling(s, result) {
        result = result || new Matrix4x4();
        result[0] = s.x;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = s.y;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = s.z;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the x axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationX(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = c;
        result[6] = s;
        result[7] = 0;
        result[8] = 0;
        result[9] = -s;
        result[10] = c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the y axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationY(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = 0;
        result[2] = -s;
        result[3] = 0;
        result[4] = 0;
        result[5] = 1;
        result[6] = 0;
        result[7] = 0;
        result[8] = s;
        result[9] = 0;
        result[10] = c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the z axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationZ(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = s;
        result[2] = 0;
        result[3] = 0;
        result[4] = -s;
        result[5] = c;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 1;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around a given axis.
   * @param axis - The axis vector.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotation(axis, angle, result) {
        result = result || new Matrix4x4();
        let x = axis.x;
        let y = axis.y;
        let z = axis.z;
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const oneMinusCosine = 1 - c;
        result[0] = xx + (1 - xx) * c;
        result[1] = x * y * oneMinusCosine + z * s;
        result[2] = x * z * oneMinusCosine - y * s;
        result[3] = 0;
        result[4] = x * y * oneMinusCosine - z * s;
        result[5] = yy + (1 - yy) * c;
        result[6] = y * z * oneMinusCosine + x * s;
        result[7] = 0;
        result[8] = x * z * oneMinusCosine + y * s;
        result[9] = y * z * oneMinusCosine - x * s;
        result[10] = zz + (1 - zz) * c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a look-at matrix.
   * @param eye - Position of the eye.
   * @param target - The point that the eye is looking at.
   * @param up - The up vector.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static lookAt(eye, target, up, result) {
        result = result || new Matrix4x4();
        const zAxis = Vector3.normalize(Vector3.sub(eye, target));
        const xAxis = Vector3.normalize(Vector3.cross(up, zAxis));
        const yAxis = Vector3.normalize(Vector3.cross(zAxis, xAxis));
        result[0] = xAxis.x;
        result[1] = xAxis.y;
        result[2] = xAxis.z;
        result[3] = 0;
        result[4] = yAxis.x;
        result[5] = yAxis.y;
        result[6] = yAxis.z;
        result[7] = 0;
        result[8] = zAxis.x;
        result[9] = zAxis.y;
        result[10] = zAxis.z;
        result[11] = 0;
        result[12] = eye.x;
        result[13] = eye.y;
        result[14] = eye.z;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a matrix, which presents a transform of looking at given cube face.
   * @param face - The cube face to be looked at.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static lookAtCubeFace(face, pos, result) {
        switch(face){
            case CubeFace.PX:
                return this.lookAt(pos, new Vector3(pos.x + 1, pos.y, pos.z), new Vector3(0, -1, 0), result);
            case CubeFace.NX:
                return this.lookAt(pos, new Vector3(pos.x - 1, pos.y, pos.z), new Vector3(0, -1, 0), result);
            case CubeFace.PY:
                return this.lookAt(pos, new Vector3(pos.x, pos.y + 1, pos.z), new Vector3(0, 0, 1), result);
            case CubeFace.NY:
                return this.lookAt(pos, new Vector3(pos.x, pos.y - 1, pos.z), new Vector3(0, 0, -1), result);
            case CubeFace.PZ:
                return this.lookAt(pos, new Vector3(pos.x, pos.y, pos.z + 1), new Vector3(0, -1, 0), result);
            case CubeFace.NZ:
                return this.lookAt(pos, new Vector3(pos.x, pos.y, pos.z - 1), new Vector3(0, -1, 0), result);
            default:
                return null;
        }
    }
    /**
   * Multiplies two Matrix4x4's
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiply(m1, m2, result) {
        result = result || new Matrix4x4();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a03 = m1[3];
        const a10 = m1[4];
        const a11 = m1[5];
        const a12 = m1[6];
        const a13 = m1[7];
        const a20 = m1[8];
        const a21 = m1[9];
        const a22 = m1[10];
        const a23 = m1[11];
        const a30 = m1[12];
        const a31 = m1[13];
        const a32 = m1[14];
        const a33 = m1[15];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b03 = m2[3];
        const b10 = m2[4];
        const b11 = m2[5];
        const b12 = m2[6];
        const b13 = m2[7];
        const b20 = m2[8];
        const b21 = m2[9];
        const b22 = m2[10];
        const b23 = m2[11];
        const b30 = m2[12];
        const b31 = m2[13];
        const b32 = m2[14];
        const b33 = m2[15];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
        result[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
        result[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
        result[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
        result[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
        return result;
    }
    /**
   * Multiplies two Matrix4x4's which present affine transformations.
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiplyAffine(m1, m2, result) {
        result = result || new Matrix4x4();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a10 = m1[4];
        const a11 = m1[5];
        const a12 = m1[6];
        const a20 = m1[8];
        const a21 = m1[9];
        const a22 = m1[10];
        const a30 = m1[12];
        const a31 = m1[13];
        const a32 = m1[14];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b10 = m2[4];
        const b11 = m2[5];
        const b12 = m2[6];
        const b20 = m2[8];
        const b21 = m2[9];
        const b22 = m2[10];
        const b30 = m2[12];
        const b31 = m2[13];
        const b32 = m2[14];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = 0;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = 0;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = 0;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32;
        result[15] = 1;
        return result;
    }
    /**
   * Post-translate a Matrix4x4 by a vector.
   *
   * @remarks
   * result = m * (translate matrix for t)
   *
   * @param m - The matrix that will be translated.
   * @param t - The translate vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translateRight(m, t, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0];
            result[1] = m[1];
            result[2] = m[2];
            result[3] = m[3];
            result[4] = m[4];
            result[5] = m[5];
            result[6] = m[6];
            result[7] = m[7];
            result[8] = m[8];
            result[9] = m[9];
            result[10] = m[10];
            result[11] = m[11];
            result[12] = m[0] * t.x + m[4] * t.y + m[8] * t.z + m[12];
            result[13] = m[1] * t.x + m[5] * t.y + m[9] * t.z + m[13];
            result[14] = m[2] * t.x + m[6] * t.y + m[10] * t.z + m[14];
            result[15] = m[15];
        } else {
            const x = m[0] * t.x + m[4] * t.y + m[8] * t.z + m[12];
            const y = m[1] * t.x + m[5] * t.y + m[9] * t.z + m[13];
            const z = m[2] * t.x + m[6] * t.y + m[10] * t.z + m[14];
            result[12] = x;
            result[13] = y;
            result[14] = z;
        }
        return result;
    }
    /**
   * Pre-translate a Matrix4x4 by a vector.
   *
   * @remarks
   * result = (translate matrix for t) * m
   *
   * @param m - The matrix that will be translated.
   * @param t - The translate vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translateLeft(m, t, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0];
            result[1] = m[1];
            result[2] = m[2];
            result[3] = m[3];
            result[4] = m[4];
            result[5] = m[5];
            result[6] = m[6];
            result[7] = m[7];
            result[8] = m[8];
            result[9] = m[9];
            result[10] = m[10];
            result[11] = m[11];
            result[12] = m[12] + t.x;
            result[13] = m[13] + t.y;
            result[14] = m[14] + t.z;
            result[15] = m[15];
        } else {
            result[12] += t.x;
            result[13] += t.y;
            result[14] += t.z;
        }
        return result;
    }
    /**
   * Post-scale a Matrix4x4 by a vector.
   *
   * @remarks
   * result = m * (scale matrix for s)
   *
   * @param m - The matrix that will be scaled.
   * @param s - The scale vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaleRight(m, s, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0] * s.x;
            result[1] = m[1] * s.x;
            result[2] = m[2] * s.x;
            result[3] = m[3] * s.x;
            result[4] = m[4] * s.y;
            result[5] = m[5] * s.y;
            result[6] = m[6] * s.y;
            result[7] = m[7] * s.y;
            result[8] = m[8] * s.z;
            result[9] = m[9] * s.z;
            result[10] = m[10] * s.z;
            result[11] = m[11] * s.z;
            result[12] = m[12];
            result[13] = m[13];
            result[14] = m[14];
            result[15] = m[15];
        } else {
            result[0] *= s.x;
            result[1] *= s.x;
            result[2] *= s.x;
            result[3] *= s.x;
            result[4] *= s.y;
            result[5] *= s.y;
            result[6] *= s.y;
            result[7] *= s.y;
            result[8] *= s.z;
            result[9] *= s.z;
            result[10] *= s.z;
            result[11] *= s.z;
        }
        return result;
    }
    /**
   * Pre-scale a Matrix4x4 by a vector.
   *
   * @remarks
   * result = (scale matrix for s) * m
   *
   * @param m - The matrix that will be translated.
   * @param s - The scale vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaleLeft(m, s, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0] * s.x;
            result[1] = m[1] * s.y;
            result[2] = m[2] * s.z;
            result[3] = m[3];
            result[4] = m[4] * s.x;
            result[5] = m[5] * s.y;
            result[6] = m[6] * s.z;
            result[7] = m[7];
            result[8] = m[8] * s.x;
            result[9] = m[9] * s.y;
            result[10] = m[10] * s.z;
            result[11] = m[11];
            result[12] = m[12] * s.x;
            result[13] = m[13] * s.y;
            result[14] = m[14] * s.z;
            result[15] = m[15];
        } else {
            result[0] *= s.x;
            result[1] *= s.y;
            result[2] *= s.z;
            result[4] *= s.x;
            result[5] *= s.y;
            result[6] *= s.z;
            result[8] *= s.x;
            result[9] *= s.y;
            result[10] *= s.z;
            result[12] *= s.x;
            result[13] *= s.y;
            result[14] *= s.z;
        }
        return result;
    }
    /**
   * Post-rotate a Matrix4x4 by a rotation matrix or quaternion.
   *
   * @remarks
   * result = m * r
   *
   * @param m - The matrix that will be translated.
   * @param r - The rotate matrix or quaternion.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotateRight(m, r, result) {
        result = result || new Matrix4x4();
        const b = r instanceof Quaternion ? new Matrix3x3(r) : r;
        const a00 = m[0];
        const a01 = m[1];
        const a02 = m[2];
        const a03 = m[3];
        const a10 = m[4];
        const a11 = m[5];
        const a12 = m[6];
        const a13 = m[7];
        const a20 = m[8];
        const a21 = m[9];
        const a22 = m[10];
        const a23 = m[11];
        const a30 = m[12];
        const a31 = m[13];
        const a32 = m[14];
        const a33 = m[15];
        const b00 = b.m00;
        const b01 = b.m10;
        const b02 = b.m20;
        const b10 = b.m01;
        const b11 = b.m11;
        const b12 = b.m21;
        const b20 = b.m02;
        const b21 = b.m12;
        const b22 = b.m22;
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = a03 * b00 + a13 * b01 + a23 * b02;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = a03 * b10 + a13 * b11 + a23 * b12;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = a03 * b20 + a13 * b21 + a23 * b22;
        result[12] = a30;
        result[13] = a31;
        result[14] = a32;
        result[15] = a33;
        return result;
    }
    /**
   * Pre-rotate a Matrix4x4 by a rotation matrix or quaternion.
   *
   * @remarks
   * result = r * m
   *
   * @param m - The matrix that will be translated.
   * @param r - The rotate matrix or quaternion.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotateLeft(m, r, result) {
        result = result || new Matrix4x4();
        const a = r instanceof Quaternion ? new Matrix3x3(r) : r;
        const a00 = a.m00;
        const a01 = a.m10;
        const a02 = a.m20;
        const a10 = a.m01;
        const a11 = a.m11;
        const a12 = a.m21;
        const a20 = a.m02;
        const a21 = a.m12;
        const a22 = a.m22;
        const b00 = m[0];
        const b01 = m[1];
        const b02 = m[2];
        const b03 = m[3];
        const b10 = m[4];
        const b11 = m[5];
        const b12 = m[6];
        const b13 = m[7];
        const b20 = m[8];
        const b21 = m[9];
        const b22 = m[10];
        const b23 = m[11];
        const b30 = m[12];
        const b31 = m[13];
        const b32 = m[14];
        const b33 = m[15];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = b03;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = b13;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = b23;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32;
        result[15] = b33;
        return result;
    }
    /**
   * Subtract a matrix from this matrix component-wise.
   * @param other - The matrix that will be subtract.
   * @returns self
   */ subBy(other) {
        return Matrix4x4.sub(this, other, this);
    }
    /**
   * Add a matrix to this matrix component-wise.
   * @param other - The matrix that will be added.
   * @returns self
   */ addBy(other) {
        return Matrix4x4.add(this, other, this);
    }
    /**
   * Multiplies this matrix by a matrix component-wise.
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Matrix4x4.mul(this, other, this);
    }
    /**
   * Divide this matrix by a matrix component-wise.
   * @param other - The matrix that will be divide by.
   * @returns self
   */ divBy(other) {
        return Matrix4x4.div(this, other, this);
    }
    /**
   * Scale this matrix by a scalar number component-wise.
   * @param f - amount to scale this matrix by.
   * @returns self
   */ scaleBy(f) {
        return Matrix4x4.scale(this, f, this);
    }
    /**
   * Make this matrix identity.
   * @returns self
   */ identity() {
        return Matrix4x4.identity(this);
    }
    /**
   * Calculates a right-handed perspective projection matrix inplace.
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio.
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @returns self
   */ perspective(fovY, aspect, znear, zfar) {
        return Matrix4x4.perspective(fovY, aspect, znear, zfar, this);
    }
    /**
   * Calculates a perspective projection matrix from a frustum inplace.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param znear - Near bound of the frustum.
   * @param zfar - Far bound of the frustum.
   * @returns self
   */ frustum(left, right, bottom, top, znear, zfar) {
        return Matrix4x4.frustum(left, right, bottom, top, znear, zfar, this);
    }
    /**
   * Calculates an orthogonal projection matrix inplace.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @returns self
   */ ortho(left, right, bottom, top, near, far) {
        return Matrix4x4.ortho(left, right, bottom, top, near, far, this);
    }
    /**
   * Check if this matrix is orthogonal projection matrix.
   *
   * @remarks
   * This method assumes that this is an affine transform matrix or a projection matrix (perspective or orthogonal).
   *
   * @returns true if this is an orthogonal projection matrix, otherwise false
   */ isOrtho() {
        // assum this is a projection matrix
        return this[15] === 1;
    }
    /**
   * Check if this matrix is perspective projection matrix.
   *
   * @remarks
   * This method assumes that this is an affine transform matrix or a projection matrix (perspective or orthogonal).
   *
   * @returns true if this is a perspective projection matrix, otherwise false
   */ isPerspective() {
        // assum this is a projection matrix
        return this[15] === 0;
    }
    /**
   * Get width of the near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Width of the near clip plane
   */ getNearPlaneWidth() {
        if (this.isPerspective()) {
            return 2 * this.getNearPlane() / this[0];
        } else {
            return 2 / this[0];
        }
    }
    /**
   * Get height of the near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Height of the near clip plane
   */ getNearPlaneHeight() {
        if (this.isPerspective()) {
            return 2 * this.getNearPlane() / this[5];
        } else {
            return 2 / this[5];
        }
    }
    /**
   * Get near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns The near clip plane
   */ getNearPlane() {
        if (this.isPerspective()) {
            return this[14] / (this[10] - 1);
        } else {
            return (this[14] + 1) / this[10];
        }
    }
    /**
   * Get width of the far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Width of the far clip plane
   */ getFarPlaneWidth() {
        if (this.isPerspective()) {
            return this.getNearPlaneWidth() * this.getFarPlane() / this.getNearPlane();
        } else {
            return this.getNearPlaneWidth();
        }
    }
    /**
   * Get height of the far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Height of the far clip plane
   */ getFarPlaneHeight() {
        if (this.isPerspective()) {
            return this.getNearPlaneHeight() * this.getFarPlane() / this.getNearPlane();
        } else {
            return this.getNearPlaneHeight();
        }
    }
    /**
   * Get far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns The far clip plane
   */ getFarPlane() {
        if (this.isPerspective()) {
            return this[14] / (this[10] + 1);
        } else {
            return (this[14] - 1) / this[10];
        }
    }
    /**
   * Get the vertical field of view in radians.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns 0 if this is an orthogonal projection matrix, otherwise the vertical field of view
   */ getFov() {
        // assum this is a projection matrix
        return this.isOrtho() ? 0 : Math.atan(1 / this[5]) * 2;
    }
    /**
   * Get tangent value of half of the vertical field of view.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   * If the matrix is orthogonal, 0 is returned.
   *
   * @returns 0 if this is an orthogonal projection matrix, otherwise the tangent value of half of the vertical field of view
   */ getTanHalfFov() {
        // assum this is a projection matrix
        return this.isOrtho() ? 0 : 1 / this[5];
    }
    /**
   * Get the aspect ratio.
   *
   * @remarks
   * This method assumes that the matrix is a perspective projection matrix.
   *
   * @returns The aspect ratio
   */ getAspect() {
        // assum this is a projection matrix
        return this[5] / this[0];
    }
    /**
   * Get the left clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The left clip plane
   */ getLeftPlane() {
        // assum this is an orthogonal projection matrix
        return (-1 - this[12]) / this[0];
    }
    /**
   * Get the right clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The right clip plane
   */ getRightPlane() {
        // assum this is an orthogonal projection matrix
        return (1 - this[12]) / this[0];
    }
    /**
   * Get the top clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The top clip plane
   */ getTopPlane() {
        // assum this is an orthogonal projection matrix
        return (1 - this[13]) / this[5];
    }
    /**
   * Get the bottom clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The bottom clip plane
   */ getBottomPlane() {
        // assum this is an orthogonal projection matrix
        return (-1 - this[13]) / this[5];
    }
    /**
   * Set the near clip plane and far clip plane.
   *
   * @remarks
   * This method assumes that the matrix is a projection matrix (perspective or orthogonal).
   *
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @returns self
   */ setNearFar(znear, zfar) {
        if (this.isPerspective()) {
            this.perspective(this.getFov(), this.getAspect(), znear, zfar);
        } else {
            this[10] = 2 / (znear - zfar);
            this[14] = (znear + zfar) / (znear - zfar);
        }
        return this;
    }
    /**
   * Calculate a translation matrix inplace.
   * @param t - The translate vector.
   * @returns self
   */ translation(t) {
        return Matrix4x4.translation(t, this);
    }
    /**
   * Calculates a scale matrix inplace.
   * @param s - The scale vector.
   * @returns self
   */ scaling(s) {
        return Matrix4x4.scaling(s, this);
    }
    /**
   * Invert this matrix inplace.
   * @returns self
   */ inplaceInvert() {
        return Matrix4x4.invert(this, this);
    }
    /**
   * Invert this matrix inplace, assuming this matrix presents an affine transformation.
   * @returns self
   */ inplaceInvertAffine() {
        return Matrix4x4.invertAffine(this, this);
    }
    /**
   * Calculates the transpose of this matrix inplace.
   * @returns self
   */ transpose() {
        return Matrix4x4.transpose(this, this);
    }
    /**
   * Post-multiply by a matrix inplace.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Matrix4x4.multiply(this, other, this);
    }
    /**
   * Post-multiply by a matrix inplace, assuming both matrices present affine transformations.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRightAffine(other) {
        return Matrix4x4.multiplyAffine(this, other, this);
    }
    /**
   * Pre-multiply by a matrix inplace.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Matrix4x4.multiply(other, this, this);
    }
    /**
   * Pre-multiply by a matrix inplace, assuming both matrices present affine transformations.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeftAffine(other) {
        return Matrix4x4.multiplyAffine(other, this, this);
    }
    /**
   * Calculates a rotation around x axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationX(angle) {
        return Matrix4x4.rotationX(angle, this);
    }
    /**
   * Calculates a rotation around y axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationY(angle) {
        return Matrix4x4.rotationY(angle, this);
    }
    /**
   * Calculates a rotation around z axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationZ(angle) {
        return Matrix4x4.rotationZ(angle, this);
    }
    /**
   * Calculates a rotation around a given axis inplace.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotation(axis, angle) {
        return Matrix4x4.rotation(axis, angle, this);
    }
    /**
   * Post-translate by a vector inplace.
   *
   * @remarks
   * this = this * (translate matrix for t)
   *
   * @param t - The translate vector.
   * @returns self
   */ translateRight(t) {
        return Matrix4x4.translateRight(this, t, this);
    }
    /**
   * Pre-translate by a vector inplace.
   *
   * @remarks
   * this = (translate matrix for t) * this
   *
   * @param t - The translate vector.
   * @returns self
   */ translateLeft(t) {
        return Matrix4x4.translateLeft(this, t, this);
    }
    /**
   * Post-scale by a vector inplace.
   *
   * @remarks
   * this = this * (scale matrix for s)
   *
   * @param s - The scale vector.
   * @returns self
   */ scaleRight(s) {
        return Matrix4x4.scaleRight(this, s, this);
    }
    /**
   * Pre-scale by a vector inplace.
   *
   * @remarks
   * this = (scale matrix for s) * this
   *
   * @param s - The scale vector.
   * @returns self
   */ scaleLeft(s) {
        return Matrix4x4.scaleLeft(this, s, this);
    }
    /**
   * Post-rotate by a rotation matrix or quaternion inplace.
   *
   * @remarks
   * this = this * r
   *
   * @param r - The rotation matrix or quaternion.
   * @returns self
   */ rotateRight(r) {
        return Matrix4x4.rotateRight(this, r, this);
    }
    /**
   * Pre-rotate by a rotation matrix or quaternion inplace.
   *
   * @remarks
   * this = r * this
   *
   * @param r - The rotation matrix or quaternion.
   * @returns self
   */ rotateLeft(r) {
        return Matrix4x4.rotateLeft(this, r, this);
    }
    /**
   * Calculates a look-at matrix inplace.
   * @param eye - Position of the eye.
   * @param target - The point that the eye is looking at.
   * @param up - The up vector.
   * @returns self
   */ lookAt(eye, target, up) {
        return Matrix4x4.lookAt(eye, target, up, this);
    }
    /**
   * Transform a point by this matrix.
   * @param point - The point to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPoint(point, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12], this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13], this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14], this[3] * point[0] + this[7] * point[1] + this[11] * point[2] + this[15]);
    }
    /**
   * Transform a point by this matrix and then do a perspective divide.
   * @param point - The point to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPointP(point, result) {
        result = result || new Vector3();
        const x = this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12];
        const y = this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13];
        const z = this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14];
        const w = this[3] * point[0] + this[7] * point[1] + this[11] * point[2] + this[15];
        return result.setXYZ(x / w, y / w, z / w);
    }
    /**
   * Transform a point by this matrix, assuming this matrix presents an affine transformation.
   * @param point - The point to be transformed.
   * @param result - The output vector (can be the same as point), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPointAffine(point, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12], this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13], this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14]);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformVector(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2], this[3] * vec[0] + this[7] * vec[1] + this[11] * vec[2]);
    }
    /**
   * Transform a vector by this matrix assuming this matrix presents an affine transformation.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformVectorAffine(vec, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2]);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transform(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2] + this[12] * vec[3], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2] + this[13] * vec[3], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2] + this[14] * vec[3], this[3] * vec[0] + this[7] * vec[1] + this[11] * vec[2] + this[15] * vec[3]);
    }
    /**
   * Transform a vector by this matrix, assuming this matrix presents an affine transformation.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformAffine(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2] + this[12] * vec[3], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2] + this[13] * vec[3], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2] + this[14] * vec[3], vec.w);
    }
    /**
   * Calculates the determinant of this matrix.
   * @returns The determinant
   */ det() {
        const m00 = this[0], m01 = this[1], m02 = this[2], m03 = this[3];
        const m10 = this[4], m11 = this[5], m12 = this[6], m13 = this[7];
        const m20 = this[8], m21 = this[9], m22 = this[10], m23 = this[11];
        const m30 = this[12], m31 = this[13], m32 = this[14], m33 = this[15];
        const det_22_33 = m22 * m33 - m32 * m23;
        const det_21_33 = m21 * m33 - m31 * m23;
        const det_21_32 = m21 * m32 - m31 * m22;
        const det_20_33 = m20 * m33 - m30 * m23;
        const det_20_32 = m20 * m32 - m22 * m30;
        const det_20_31 = m20 * m31 - m30 * m21;
        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    }
    /**
   * Decompose this matrix into its rotation, translation and scale components.
   * @param scale - The output scale vector.
   * @param rotation - The output rotation matrix or quaternion.
   * @param translation - The output translation vector.
   * @returns self
   */ decompose(scale, rotation, translation) {
        if (translation) {
            translation.setXYZ(this[12], this[13], this[14]);
        }
        const sign = this.det() <= 0 ? -1 : 1;
        const sx = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        const sy = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]) * sign;
        const sz = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        if (scale) {
            scale.setXYZ(sx, sy, sz);
        }
        if (rotation instanceof Quaternion) {
            const rotationMatrix = new Matrix3x3(this);
            rotationMatrix[0] /= sx;
            rotationMatrix[1] /= sx;
            rotationMatrix[2] /= sx;
            rotationMatrix[3] /= sy;
            rotationMatrix[4] /= sy;
            rotationMatrix[5] /= sy;
            rotationMatrix[6] /= sz;
            rotationMatrix[7] /= sz;
            rotationMatrix[8] /= sz;
            rotation.fromRotationMatrix(rotationMatrix);
        } else if (rotation instanceof Matrix3x3) {
            rotation[0] = this[0] / sx;
            rotation[1] = this[1] / sx;
            rotation[2] = this[2] / sx;
            rotation[3] = this[4] / sy;
            rotation[4] = this[5] / sy;
            rotation[5] = this[6] / sy;
            rotation[6] = this[8] / sz;
            rotation[7] = this[9] / sz;
            rotation[8] = this[10] / sz;
        } else if (rotation instanceof Matrix4x4) {
            rotation[0] = this[0] / sx;
            rotation[1] = this[1] / sx;
            rotation[2] = this[2] / sx;
            rotation[3] = 0;
            rotation[4] = this[4] / sy;
            rotation[5] = this[5] / sy;
            rotation[6] = this[6] / sy;
            rotation[7] = 0;
            rotation[8] = this[8] / sz;
            rotation[9] = this[9] / sz;
            rotation[10] = this[10] / sz;
            rotation[11] = 0;
            rotation[12] = 0;
            rotation[13] = 0;
            rotation[14] = 0;
            rotation[15] = 1;
        }
        return this;
    }
    /**
   * Decompose this matrix into a look-at form.
   * @param eye - The output eye vector.
   * @param target - The output target vector.
   * @param up - The output up vector.
   * @returns self
   */ decomposeLookAt(eye, target, up) {
        eye && eye.setXYZ(this[12], this[13], this[14]);
        up && up.setXYZ(this[4], this[5], this[6]);
        target && target.setXYZ(this[12] - this[8], this[13] - this[9], this[14] - this[10]);
        return this;
    }
    /** @internal */ toDualQuaternion() {
        const t = new Vector3();
        const r = new Quaternion();
        const s = new Vector3();
        this.decompose(s, r, t);
        const translation = new Quaternion(this.m03 * 0.5, this.m13 * 0.5, this.m23 * 0.5, 0);
        const dual = Quaternion.multiply(translation, r);
        return {
            real: r,
            dual: dual,
            scale: s
        };
    }
}

/**
 * The rectangle packer class
 * @public
 */ class RectsPacker {
    /** @internal */ _bins;
    /** @internal */ _maxBins;
    /** @internal */ _width;
    /** @internal */ _height;
    /**
   * @param width - width of image bin
   * @param height - height of image bin
   * @param maxBins - max count of image bins
   */ constructor(width, height, maxBins = 0){
        this._width = width;
        this._height = height;
        this._maxBins = maxBins;
        this._bins = [
            new Bin(this._width, this._height)
        ];
    }
    /** Clear all image bins of the packer */ clear() {
        this._bins = [
            new Bin(this._width, this._height)
        ];
    }
    /**
   * Inserts a new rectangle
   * @param width - Width of the rectangle.
   * @param height - Height of the rectangle.
   * @returns The pack result.
   */ insert(width, height) {
        if (width > this._width || height > this._height) {
            return null;
        }
        const rect = this._bins[this._bins.length - 1].insert(width, height);
        if (rect) {
            return {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                binIndex: this._bins.length - 1
            };
        }
        if (this._maxBins === 0 || this._bins.length < this._maxBins) {
            this._bins.push(new Bin(this._width, this._height));
            const rect = this._bins[this._bins.length - 1].insert(width, height);
            return {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                binIndex: this._bins.length - 1
            };
        }
        return null;
    }
}
class Bin {
    freeRects;
    constructor(width, height){
        this.freeRects = [
            {
                x: 0,
                y: 0,
                width,
                height
            }
        ];
    }
    insert(width, height) {
        const newRect = this.findBestFit(width, height);
        if (!newRect) {
            return null;
        }
        let numRectsToProcess = this.freeRects.length;
        let i = 0;
        while(i < numRectsToProcess){
            if (this.splitFreeRect(this.freeRects[i], newRect)) {
                this.freeRects.splice(i, 1);
                --numRectsToProcess;
                --i;
            }
            ++i;
        }
        this.pruneFreeRects();
        return newRect;
    }
    findBestFit(width, height) {
        let score = Number.MAX_VALUE;
        let rect = null;
        for (const freeRect of this.freeRects){
            if (freeRect.width >= width && freeRect.height >= height) {
                const areaFit = freeRect.width * freeRect.height - width * height;
                if (areaFit < score) {
                    if (!rect) {
                        rect = {
                            width,
                            height
                        };
                    }
                    rect.x = freeRect.x;
                    rect.y = freeRect.y;
                    score = areaFit;
                }
            }
        }
        return rect;
    }
    splitFreeRect(free, used) {
        if (used.x >= free.x + free.width || used.x + used.width <= free.x || used.y >= free.y + free.height || used.y + used.height <= free.y) {
            return false;
        }
        if (used.x < free.x + free.width && used.x + used.width > free.x) {
            if (used.y > free.y && used.y < free.y + free.height) {
                this.freeRects.push({
                    x: free.x,
                    y: free.y,
                    width: free.width,
                    height: used.y - free.y
                });
            }
            if (used.y + used.height < free.y + free.height) {
                this.freeRects.push({
                    x: free.x,
                    y: used.y + used.height,
                    width: free.width,
                    height: free.y + free.height - used.y - used.height
                });
            }
        }
        if (used.y < free.y + free.height && used.y + used.height > free.y) {
            if (used.x > free.x && used.x < free.x + free.width) {
                this.freeRects.push({
                    x: free.x,
                    y: free.y,
                    width: used.x - free.x,
                    height: free.height
                });
            }
            if (used.x + used.width < free.x + free.width) {
                this.freeRects.push({
                    x: used.x + used.width,
                    y: free.y,
                    width: free.x + free.width - used.x - used.width,
                    height: free.height
                });
            }
        }
        return true;
    }
    pruneFreeRects() {
        let i = 0;
        let j = 0;
        let len = this.freeRects.length;
        while(i < len){
            j = i + 1;
            const rect1 = this.freeRects[i];
            while(j < len){
                const rect2 = this.freeRects[j];
                if (this.isRectInRect(rect1, rect2)) {
                    this.freeRects.splice(i, 1);
                    --i;
                    --len;
                    break;
                }
                if (this.isRectInRect(rect2, rect1)) {
                    this.freeRects.splice(j, 1);
                    --j;
                    --len;
                }
                j++;
            }
            i++;
        }
    }
    isRectInRect(test, container) {
        return test.x >= container.x && test.y >= container.y && test.x + test.width <= container.x + container.width && test.y + test.height <= container.y + container.height;
    }
}

const RED_SHIFT = 0;
const GREEN_SHIFT = 1;
const BLUE_SHIFT = 2;
const ALPHA_SHIFT = 3;
const DEPTH_SHIFT = 4;
const STENCIL_SHIFT = 5;
const FLOAT_SHIFT = 6;
const INTEGER_SHIFT = 7;
const SIGNED_SHIFT = 8;
const SRGB_SHIFT = 9;
const BGR_SHIFT = 10;
const BLOCK_SIZE_SHIFT = 11;
const BLOCK_SIZE_MASK = 0x1f << BLOCK_SIZE_SHIFT;
const BLOCK_WIDTH_SHIFT = 16;
const BLOCK_WIDTH_MASK = 0xf << BLOCK_WIDTH_SHIFT;
const BLOCK_HEIGHT_SHIFT = 20;
const BLOCK_HEIGHT_MASK = 0xf << BLOCK_HEIGHT_SHIFT;
const COMPRESSED_FORMAT_SHIFT = 24;
const COMPRESSION_FORMAT_BC1 = 1 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC2 = 2 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC3 = 3 << COMPRESSED_FORMAT_SHIFT;
/*
const COMPRESSION_FORMAT_BC4 = 4 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC5 = 5 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC6 = 6 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC7 = 7 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGB8 = 8 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGB8_A1 = 9 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGBA8 = 10 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_4x4 = 11 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_5x4 = 12 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_5x5 = 13 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_6x5 = 14 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_6x6 = 15 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x5 = 16 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x6 = 17 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x8 = 18 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x5 = 19 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x6 = 20 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x8 = 21 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x10 = 22 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_12x10 = 23 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_12x12 = 24 << COMPRESSED_FORMAT_SHIFT;
*/ const COMPRESSION_FORMAT_BITMASK = 0x1f << COMPRESSED_FORMAT_SHIFT;
const RED_BITMASK = 1 << RED_SHIFT;
const GREEN_BITMASK = 1 << GREEN_SHIFT;
const BLUE_BITMASK = 1 << BLUE_SHIFT;
const ALPHA_BITMASK = 1 << ALPHA_SHIFT;
const DEPTH_BITMASK = 1 << DEPTH_SHIFT;
const STENCIL_BITMASK = 1 << STENCIL_SHIFT;
const FLOAT_BITMASK = 1 << FLOAT_SHIFT;
const INTEGER_BITMASK = 1 << INTEGER_SHIFT;
const SIGNED_BITMASK = 1 << SIGNED_SHIFT;
const SRGB_BITMASK = 1 << SRGB_SHIFT;
const BGR_BITMASK = 1 << BGR_SHIFT;
function makeTextureFormat(compression, r, g, b, a, depth, stencil, float, integer, signed, srgb, bgr, blockWidth, blockHeight, blockSize) {
    const compressionBits = compression;
    const colorBits = (r ? RED_BITMASK : 0) | (g ? GREEN_BITMASK : 0) | (b ? BLUE_BITMASK : 0) | (a ? ALPHA_BITMASK : 0);
    const depthStencilBits = (depth ? DEPTH_BITMASK : 0) | (stencil ? STENCIL_BITMASK : 0);
    const floatBits = float ? FLOAT_BITMASK : 0;
    const integerBits = integer ? INTEGER_BITMASK : 0;
    const signedBits = signed ? SIGNED_BITMASK : 0;
    const srgbBits = srgb ? SRGB_BITMASK : 0;
    const bgrBits = bgr ? BGR_BITMASK : 0;
    const blockBits = blockWidth << BLOCK_WIDTH_SHIFT | blockHeight << BLOCK_HEIGHT_SHIFT | blockSize << BLOCK_SIZE_SHIFT;
    return compressionBits | colorBits | depthStencilBits | floatBits | integerBits | signedBits | srgbBits | bgrBits | blockBits;
}
const textureFormatMap$1 = {
    'unknown': 0,
    'r8unorm': makeTextureFormat(0, true, false, false, false, false, false, false, false, false, false, false, 1, 1, 1),
    'r8snorm': makeTextureFormat(0, true, false, false, false, false, false, false, false, true, false, false, 1, 1, 1),
    'r16f': makeTextureFormat(0, true, false, false, false, false, false, true, false, true, false, false, 1, 1, 2),
    'r32f': makeTextureFormat(0, true, false, false, false, false, false, true, false, true, false, false, 1, 1, 4),
    'r8ui': makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 1),
    'r8i': makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 1),
    'r16ui': makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 2),
    'r16i': makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 2),
    'r32ui': makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 4),
    'r32i': makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 4),
    'rg8unorm': makeTextureFormat(0, true, true, false, false, false, false, false, false, false, false, false, 1, 1, 2),
    'rg8snorm': makeTextureFormat(0, true, true, false, false, false, false, false, false, true, false, false, 1, 1, 2),
    'rg16f': makeTextureFormat(0, true, true, false, false, false, false, true, false, true, false, false, 1, 1, 4),
    'rg32f': makeTextureFormat(0, true, true, false, false, false, false, true, false, true, false, false, 1, 1, 8),
    'rg8ui': makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 2),
    'rg8i': makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 2),
    'rg16ui': makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 4),
    'rg16i': makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 4),
    'rg32ui': makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 8),
    'rg32i': makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 8),
    'rgba8unorm': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, false, false, 1, 1, 4),
    'rgba8unorm-srgb': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, true, false, 1, 1, 4),
    'rgba8snorm': makeTextureFormat(0, true, true, true, true, false, false, false, false, true, false, false, 1, 1, 4),
    'bgra8unorm': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, false, true, 1, 1, 4),
    'bgra8unorm-srgb': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, true, true, 1, 1, 4),
    'rgba16f': makeTextureFormat(0, true, true, true, true, false, false, true, false, true, false, false, 1, 1, 8),
    'rgba32f': makeTextureFormat(0, true, true, true, true, false, false, true, false, true, false, false, 1, 1, 16),
    'rgba8ui': makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 4),
    'rgba8i': makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 4),
    'rgba16ui': makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 8),
    'rgba16i': makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 8),
    'rgba32ui': makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 16),
    'rgba32i': makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 16),
    'rg11b10uf': makeTextureFormat(0, true, true, true, false, false, false, true, false, false, false, false, 1, 1, 4),
    'd16': makeTextureFormat(0, false, false, false, false, true, false, false, false, false, false, false, 1, 1, 2),
    'd24': makeTextureFormat(0, false, false, false, false, true, false, false, false, false, false, false, 0, 0, 0),
    'd32f': makeTextureFormat(0, false, false, false, false, true, false, true, false, true, false, false, 1, 1, 4),
    'd24s8': makeTextureFormat(0, false, false, false, false, true, true, false, false, false, false, false, 1, 1, 4),
    'd32fs8': makeTextureFormat(0, false, false, false, false, true, true, true, false, true, false, false, 1, 1, 5),
    // compressed texture formats
    'dxt1': makeTextureFormat(COMPRESSION_FORMAT_BC1, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 8),
    'dxt1-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC1, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 8),
    'dxt3': makeTextureFormat(COMPRESSION_FORMAT_BC2, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 16),
    'dxt3-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC2, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 16),
    'dxt5': makeTextureFormat(COMPRESSION_FORMAT_BC3, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 16),
    'dxt5-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC3, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 16)
};
/**
 * Converts a non-sRGB texture format to the corresponding sRGB texture format
 * @param format - The texture format to be converted
 * @returns The sRGB texture format
 * @public
 */ function linearTextureFormatToSRGB(format) {
    switch(format){
        case 'rgba8unorm':
            return 'rgba8unorm-srgb';
        case 'bgra8unorm':
            return 'bgra8unorm-srgb';
        case 'dxt1':
            return 'dxt1-srgb';
        case 'dxt3':
            return 'dxt3-srgb';
        case 'dxt5':
            return 'dxt5-srgb';
        default:
            return format;
    }
}
/**
 * Check if a given texture format contains a depth channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a depth channel, otherwise false
 * @public
 */ function hasDepthChannel(format) {
    return !!(textureFormatMap$1[format] & DEPTH_BITMASK);
}
/**
 * Check if a given texture format contains a stencil channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a stencil channel, otherwise false
 * @public
 */ function hasStencilChannel(format) {
    return !!(textureFormatMap$1[format] & STENCIL_BITMASK);
}
/**
 * Check whether a given texture format is floating-point.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is floating-point, otherwise false
 * @public
 */ function isFloatTextureFormat(format) {
    return !!(textureFormatMap$1[format] & FLOAT_BITMASK);
}
/**
 * Check whether a given texture format is integer.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is integer, otherwise false
 * @public
 */ function isIntegerTextureFormat(format) {
    return !!(textureFormatMap$1[format] & INTEGER_BITMASK);
}
/**
 * Check whether a given texture format is signed.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is signed, otherwise false
 * @public
 */ function isSignedTextureFormat(format) {
    return !!(textureFormatMap$1[format] & SIGNED_BITMASK);
}
/**
 * Check whether a given texture format is a compressed format.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is a compressed format, otherwise false
 * @public
 */ function isCompressedTextureFormat(format) {
    return !!(textureFormatMap$1[format] & COMPRESSION_FORMAT_BITMASK);
}
/**
 * Check whether a given texture format is sRGB format.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is sRGB format, otherwise false
 * @public
 */ function isSRGBTextureFormat(format) {
    return !!(textureFormatMap$1[format] & SRGB_BITMASK);
}
/**
 * Get block size of given texture format
 * @param format - The texture format
 * @returns The block size
 * @public
 */ function getTextureFormatBlockSize(format) {
    return (textureFormatMap$1[format] & BLOCK_SIZE_MASK) >> BLOCK_SIZE_SHIFT;
}
/**
 * Get block width of given texture format
 * @param format - The texture format
 * @returns The block width
 * @public
 */ function getTextureFormatBlockWidth(format) {
    return (textureFormatMap$1[format] & BLOCK_WIDTH_MASK) >> BLOCK_WIDTH_SHIFT;
}
/**
 * Get block height of given texture format
 * @param format - The texture format
 * @returns The block height
 * @public
 */ function getTextureFormatBlockHeight(format) {
    return (textureFormatMap$1[format] & BLOCK_HEIGHT_MASK) >> BLOCK_HEIGHT_SHIFT;
}
var ShaderType;
(function(ShaderType) {
    ShaderType[ShaderType["Vertex"] = 1] = "Vertex";
    ShaderType[ShaderType["Fragment"] = 2] = "Fragment";
    ShaderType[ShaderType["Compute"] = 4] = "Compute";
})(ShaderType || (ShaderType = {}));
/**
 * Event that will be fired when size of back buffer has changed
 * @public
 */ class DeviceResizeEvent {
    /** The event name */ static NAME = 'resize';
    width;
    height;
    type = DeviceResizeEvent.NAME;
    constructor(width, height){
        this.width = width;
        this.height = height;
    }
}
/**
 * Event that will be fired when any gpu object is created
 * @public
 */ class DeviceGPUObjectAddedEvent {
    /** the event name */ static NAME = 'gpuobject_added';
    object;
    type = DeviceGPUObjectAddedEvent.NAME;
    constructor(obj){
        this.object = obj;
    }
}
/**
 * Event that will be fired when any gpu object is disposed
 * @public
 */ class DeviceGPUObjectRemovedEvent {
    /** The event name */ static NAME = 'gpuobject_removed';
    object;
    type = DeviceGPUObjectRemovedEvent.NAME;
    constructor(obj){
        this.object = obj;
    }
}
/**
 * Event that will be fired when any gpu object name is changed
 * @public
 */ class DeviceGPUObjectRenameEvent {
    /** The event name */ static NAME = 'gpuobject_rename';
    object;
    lastName;
    type = DeviceGPUObjectRenameEvent.NAME;
    constructor(obj, lastName){
        this.object = obj;
        this.lastName = lastName;
    }
}

const F16_BITMASK = 1;
const F32_BITMASK = 2;
const BOOL_BITMASK = 3;
const I8_BITMASK = 4;
const I16_BITMASK = 5;
const I32_BITMASK = 6;
const U8_BITMASK = 7;
const U16_BITMASK = 8;
const U32_BITMASK = 9;
const SCALAR_TYPE_BITMASK = 15;
const ROWS_BITMASK = 7;
const ROWS_BITSHIFT = 4;
const COLS_BITMASK = 7;
const COLS_BITSHIFT = 7;
const NORM_BITMASK = 1;
const NORM_BITSHIFT = 10;
function align(n, alignment) {
    return n + alignment - 1 & ~(alignment - 1);
}
function getAlignment(type) {
    if (type.isPrimitiveType()) {
        return type.isScalarType() ? 4 : 1 << Math.min(4, type.cols + 1);
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 1 : getAlignment(type.elementType);
    } else {
        let alignment = 0;
        for (const member of type.structMembers){
            alignment = Math.max(alignment, getAlignment(member.type));
        }
        return Math.max(alignment, 16);
    }
}
function getAlignmentPacked(type) {
    return 1;
}
function getSize(type) {
    if (type.isPrimitiveType()) {
        return type.isMatrixType() ? type.rows * getAlignment(PBPrimitiveTypeInfo.getCachedTypeInfo(type.resizeType(1, type.cols))) : 4 * type.cols;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 0 : type.dimension * align(getSize(type.elementType), getAlignment(type.elementType));
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else {
        let size = 0;
        let structAlignment = 0;
        for (const member of type.structMembers){
            const memberAlignment = getAlignment(member.type);
            size = align(size, memberAlignment);
            size += getSize(member.type);
            structAlignment = Math.max(structAlignment, memberAlignment);
        }
        return align(size, structAlignment);
    }
}
function getSizePacked(type) {
    if (type.isPrimitiveType()) {
        let scalarSize;
        switch(type.scalarType){
            case PBPrimitiveType.U8:
            case PBPrimitiveType.U8_NORM:
            case PBPrimitiveType.I8:
            case PBPrimitiveType.I8_NORM:
                scalarSize = 1;
                break;
            case PBPrimitiveType.F16:
            case PBPrimitiveType.I16:
            case PBPrimitiveType.I16_NORM:
            case PBPrimitiveType.U16:
            case PBPrimitiveType.U16_NORM:
                scalarSize = 2;
                break;
            default:
                scalarSize = 4;
                break;
        }
        return type.rows * type.cols * scalarSize;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 0 : type.dimension * getSizePacked(type.elementType);
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else {
        let size = 0;
        for (const member of type.structMembers){
            size += getSizePacked(member.type);
        }
        return size;
    }
}
function makePrimitiveType(scalarTypeMask, rows, cols, norm) {
    return scalarTypeMask | rows << ROWS_BITSHIFT | cols << COLS_BITSHIFT | norm << NORM_BITSHIFT;
}
function typeToTypedArray(type) {
    if (type.isPrimitiveType()) {
        return type.scalarType;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? null : typeToTypedArray(type.elementType);
    } else {
        return PBPrimitiveType.U8;
    }
}
var PBPrimitiveType;
(function(PBPrimitiveType) {
    PBPrimitiveType[PBPrimitiveType["NONE"] = 0] = "NONE";
    PBPrimitiveType[PBPrimitiveType["F16"] = makePrimitiveType(F16_BITMASK, 1, 1, 0)] = "F16";
    PBPrimitiveType[PBPrimitiveType["F16VEC2"] = makePrimitiveType(F16_BITMASK, 1, 2, 0)] = "F16VEC2";
    PBPrimitiveType[PBPrimitiveType["F16VEC3"] = makePrimitiveType(F16_BITMASK, 1, 3, 0)] = "F16VEC3";
    PBPrimitiveType[PBPrimitiveType["F16VEC4"] = makePrimitiveType(F16_BITMASK, 1, 4, 0)] = "F16VEC4";
    PBPrimitiveType[PBPrimitiveType["F32"] = makePrimitiveType(F32_BITMASK, 1, 1, 0)] = "F32";
    PBPrimitiveType[PBPrimitiveType["F32VEC2"] = makePrimitiveType(F32_BITMASK, 1, 2, 0)] = "F32VEC2";
    PBPrimitiveType[PBPrimitiveType["F32VEC3"] = makePrimitiveType(F32_BITMASK, 1, 3, 0)] = "F32VEC3";
    PBPrimitiveType[PBPrimitiveType["F32VEC4"] = makePrimitiveType(F32_BITMASK, 1, 4, 0)] = "F32VEC4";
    PBPrimitiveType[PBPrimitiveType["BOOL"] = makePrimitiveType(BOOL_BITMASK, 1, 1, 0)] = "BOOL";
    PBPrimitiveType[PBPrimitiveType["BVEC2"] = makePrimitiveType(BOOL_BITMASK, 1, 2, 0)] = "BVEC2";
    PBPrimitiveType[PBPrimitiveType["BVEC3"] = makePrimitiveType(BOOL_BITMASK, 1, 3, 0)] = "BVEC3";
    PBPrimitiveType[PBPrimitiveType["BVEC4"] = makePrimitiveType(BOOL_BITMASK, 1, 4, 0)] = "BVEC4";
    PBPrimitiveType[PBPrimitiveType["I8"] = makePrimitiveType(I8_BITMASK, 1, 1, 0)] = "I8";
    PBPrimitiveType[PBPrimitiveType["I8VEC2"] = makePrimitiveType(I8_BITMASK, 1, 2, 0)] = "I8VEC2";
    PBPrimitiveType[PBPrimitiveType["I8VEC3"] = makePrimitiveType(I8_BITMASK, 1, 3, 0)] = "I8VEC3";
    PBPrimitiveType[PBPrimitiveType["I8VEC4"] = makePrimitiveType(I8_BITMASK, 1, 4, 0)] = "I8VEC4";
    PBPrimitiveType[PBPrimitiveType["I8_NORM"] = makePrimitiveType(I8_BITMASK, 1, 1, 1)] = "I8_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC2_NORM"] = makePrimitiveType(I8_BITMASK, 1, 2, 1)] = "I8VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC3_NORM"] = makePrimitiveType(I8_BITMASK, 1, 3, 1)] = "I8VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC4_NORM"] = makePrimitiveType(I8_BITMASK, 1, 4, 1)] = "I8VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["I16"] = makePrimitiveType(I16_BITMASK, 1, 1, 0)] = "I16";
    PBPrimitiveType[PBPrimitiveType["I16VEC2"] = makePrimitiveType(I16_BITMASK, 1, 2, 0)] = "I16VEC2";
    PBPrimitiveType[PBPrimitiveType["I16VEC3"] = makePrimitiveType(I16_BITMASK, 1, 3, 0)] = "I16VEC3";
    PBPrimitiveType[PBPrimitiveType["I16VEC4"] = makePrimitiveType(I16_BITMASK, 1, 4, 0)] = "I16VEC4";
    PBPrimitiveType[PBPrimitiveType["I16_NORM"] = makePrimitiveType(I16_BITMASK, 1, 1, 1)] = "I16_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC2_NORM"] = makePrimitiveType(I16_BITMASK, 1, 2, 1)] = "I16VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC3_NORM"] = makePrimitiveType(I16_BITMASK, 1, 3, 1)] = "I16VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC4_NORM"] = makePrimitiveType(I16_BITMASK, 1, 4, 1)] = "I16VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["I32"] = makePrimitiveType(I32_BITMASK, 1, 1, 0)] = "I32";
    PBPrimitiveType[PBPrimitiveType["I32VEC2"] = makePrimitiveType(I32_BITMASK, 1, 2, 0)] = "I32VEC2";
    PBPrimitiveType[PBPrimitiveType["I32VEC3"] = makePrimitiveType(I32_BITMASK, 1, 3, 0)] = "I32VEC3";
    PBPrimitiveType[PBPrimitiveType["I32VEC4"] = makePrimitiveType(I32_BITMASK, 1, 4, 0)] = "I32VEC4";
    PBPrimitiveType[PBPrimitiveType["I32_NORM"] = makePrimitiveType(I32_BITMASK, 1, 1, 1)] = "I32_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC2_NORM"] = makePrimitiveType(I32_BITMASK, 1, 2, 1)] = "I32VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC3_NORM"] = makePrimitiveType(I32_BITMASK, 1, 3, 1)] = "I32VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC4_NORM"] = makePrimitiveType(I32_BITMASK, 1, 4, 1)] = "I32VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U8"] = makePrimitiveType(U8_BITMASK, 1, 1, 0)] = "U8";
    PBPrimitiveType[PBPrimitiveType["U8VEC2"] = makePrimitiveType(U8_BITMASK, 1, 2, 0)] = "U8VEC2";
    PBPrimitiveType[PBPrimitiveType["U8VEC3"] = makePrimitiveType(U8_BITMASK, 1, 3, 0)] = "U8VEC3";
    PBPrimitiveType[PBPrimitiveType["U8VEC4"] = makePrimitiveType(U8_BITMASK, 1, 4, 0)] = "U8VEC4";
    PBPrimitiveType[PBPrimitiveType["U8_NORM"] = makePrimitiveType(U8_BITMASK, 1, 1, 1)] = "U8_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC2_NORM"] = makePrimitiveType(U8_BITMASK, 1, 2, 1)] = "U8VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC3_NORM"] = makePrimitiveType(U8_BITMASK, 1, 3, 1)] = "U8VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC4_NORM"] = makePrimitiveType(U8_BITMASK, 1, 4, 1)] = "U8VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U16"] = makePrimitiveType(U16_BITMASK, 1, 1, 0)] = "U16";
    PBPrimitiveType[PBPrimitiveType["U16VEC2"] = makePrimitiveType(U16_BITMASK, 1, 2, 0)] = "U16VEC2";
    PBPrimitiveType[PBPrimitiveType["U16VEC3"] = makePrimitiveType(U16_BITMASK, 1, 3, 0)] = "U16VEC3";
    PBPrimitiveType[PBPrimitiveType["U16VEC4"] = makePrimitiveType(U16_BITMASK, 1, 4, 0)] = "U16VEC4";
    PBPrimitiveType[PBPrimitiveType["U16_NORM"] = makePrimitiveType(U16_BITMASK, 1, 1, 1)] = "U16_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC2_NORM"] = makePrimitiveType(U16_BITMASK, 1, 2, 1)] = "U16VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC3_NORM"] = makePrimitiveType(U16_BITMASK, 1, 3, 1)] = "U16VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC4_NORM"] = makePrimitiveType(U16_BITMASK, 1, 4, 1)] = "U16VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U32"] = makePrimitiveType(U32_BITMASK, 1, 1, 0)] = "U32";
    PBPrimitiveType[PBPrimitiveType["U32VEC2"] = makePrimitiveType(U32_BITMASK, 1, 2, 0)] = "U32VEC2";
    PBPrimitiveType[PBPrimitiveType["U32VEC3"] = makePrimitiveType(U32_BITMASK, 1, 3, 0)] = "U32VEC3";
    PBPrimitiveType[PBPrimitiveType["U32VEC4"] = makePrimitiveType(U32_BITMASK, 1, 4, 0)] = "U32VEC4";
    PBPrimitiveType[PBPrimitiveType["U32_NORM"] = makePrimitiveType(U32_BITMASK, 1, 1, 1)] = "U32_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC2_NORM"] = makePrimitiveType(U32_BITMASK, 1, 2, 1)] = "U32VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC3_NORM"] = makePrimitiveType(U32_BITMASK, 1, 3, 1)] = "U32VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC4_NORM"] = makePrimitiveType(U32_BITMASK, 1, 4, 1)] = "U32VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["MAT2"] = makePrimitiveType(F32_BITMASK, 2, 2, 0)] = "MAT2";
    PBPrimitiveType[PBPrimitiveType["MAT2x3"] = makePrimitiveType(F32_BITMASK, 2, 3, 0)] = "MAT2x3";
    PBPrimitiveType[PBPrimitiveType["MAT2x4"] = makePrimitiveType(F32_BITMASK, 2, 4, 0)] = "MAT2x4";
    PBPrimitiveType[PBPrimitiveType["MAT3x2"] = makePrimitiveType(F32_BITMASK, 3, 2, 0)] = "MAT3x2";
    PBPrimitiveType[PBPrimitiveType["MAT3"] = makePrimitiveType(F32_BITMASK, 3, 3, 0)] = "MAT3";
    PBPrimitiveType[PBPrimitiveType["MAT3x4"] = makePrimitiveType(F32_BITMASK, 3, 4, 0)] = "MAT3x4";
    PBPrimitiveType[PBPrimitiveType["MAT4x2"] = makePrimitiveType(F32_BITMASK, 4, 2, 0)] = "MAT4x2";
    PBPrimitiveType[PBPrimitiveType["MAT4x3"] = makePrimitiveType(F32_BITMASK, 4, 3, 0)] = "MAT4x3";
    PBPrimitiveType[PBPrimitiveType["MAT4"] = makePrimitiveType(F32_BITMASK, 4, 4, 0)] = "MAT4";
})(PBPrimitiveType || (PBPrimitiveType = {}));
const primitiveTypeMapWebGL = {
    [PBPrimitiveType.F32]: 'float',
    [PBPrimitiveType.F32VEC2]: 'vec2',
    [PBPrimitiveType.F32VEC3]: 'vec3',
    [PBPrimitiveType.F32VEC4]: 'vec4',
    [PBPrimitiveType.BOOL]: 'bool',
    [PBPrimitiveType.BVEC2]: 'bvec2',
    [PBPrimitiveType.BVEC3]: 'bvec3',
    [PBPrimitiveType.BVEC4]: 'bvec4',
    [PBPrimitiveType.I32]: 'int',
    [PBPrimitiveType.I32VEC2]: 'ivec2',
    [PBPrimitiveType.I32VEC3]: 'ivec3',
    [PBPrimitiveType.I32VEC4]: 'ivec4',
    [PBPrimitiveType.U32]: 'uint',
    [PBPrimitiveType.U32VEC2]: 'uvec2',
    [PBPrimitiveType.U32VEC3]: 'uvec3',
    [PBPrimitiveType.U32VEC4]: 'uvec4',
    [PBPrimitiveType.MAT2]: 'mat2',
    [PBPrimitiveType.MAT2x3]: 'mat2x3',
    [PBPrimitiveType.MAT2x4]: 'mat2x4',
    [PBPrimitiveType.MAT3x2]: 'mat3x2',
    [PBPrimitiveType.MAT3]: 'mat3',
    [PBPrimitiveType.MAT3x4]: 'mat3x4',
    [PBPrimitiveType.MAT4x2]: 'mat4x2',
    [PBPrimitiveType.MAT4x3]: 'mat4x3',
    [PBPrimitiveType.MAT4]: 'mat4'
};
const primitiveTypeMapWGSL = {
    [PBPrimitiveType.F32]: 'f32',
    [PBPrimitiveType.F32VEC2]: 'vec2<f32>',
    [PBPrimitiveType.F32VEC3]: 'vec3<f32>',
    [PBPrimitiveType.F32VEC4]: 'vec4<f32>',
    [PBPrimitiveType.BOOL]: 'bool',
    [PBPrimitiveType.BVEC2]: 'vec2<bool>',
    [PBPrimitiveType.BVEC3]: 'vec3<bool>',
    [PBPrimitiveType.BVEC4]: 'vec4<bool>',
    [PBPrimitiveType.I32]: 'i32',
    [PBPrimitiveType.I32VEC2]: 'vec2<i32>',
    [PBPrimitiveType.I32VEC3]: 'vec3<i32>',
    [PBPrimitiveType.I32VEC4]: 'vec4<i32>',
    [PBPrimitiveType.U32]: 'u32',
    [PBPrimitiveType.U32VEC2]: 'vec2<u32>',
    [PBPrimitiveType.U32VEC3]: 'vec3<u32>',
    [PBPrimitiveType.U32VEC4]: 'vec4<u32>',
    [PBPrimitiveType.MAT2]: 'mat2x2<f32>',
    [PBPrimitiveType.MAT2x3]: 'mat2x3<f32>',
    [PBPrimitiveType.MAT2x4]: 'mat2x4<f32>',
    [PBPrimitiveType.MAT3x2]: 'mat3x2<f32>',
    [PBPrimitiveType.MAT3]: 'mat3x3<f32>',
    [PBPrimitiveType.MAT3x4]: 'mat3x4<f32>',
    [PBPrimitiveType.MAT4x2]: 'mat4x2<f32>',
    [PBPrimitiveType.MAT4x3]: 'mat4x3<f32>',
    [PBPrimitiveType.MAT4]: 'mat4x4<f32>'
};
const BITFLAG_1D = 1 << 0;
const BITFLAG_2D = 1 << 1;
const BITFLAG_3D = 1 << 2;
const BITFLAG_CUBE = 1 << 3;
const BITFLAG_ARRAY = 1 << 4;
const BITFLAG_MULTISAMPLED = 1 << 5;
const BITFLAG_STORAGE = 1 << 6;
const BITFLAG_DEPTH = 1 << 7;
const BITFLAG_FLOAT = 1 << 8;
const BITFLAG_INT = 1 << 9;
const BITFLAG_UINT = 1 << 10;
const BITFLAG_EXTERNAL = 1 << 11;
var PBTextureType;
(function(PBTextureType) {
    PBTextureType[PBTextureType["TEX_1D"] = BITFLAG_1D | BITFLAG_FLOAT] = "TEX_1D";
    PBTextureType[PBTextureType["ITEX_1D"] = BITFLAG_1D | BITFLAG_INT] = "ITEX_1D";
    PBTextureType[PBTextureType["UTEX_1D"] = BITFLAG_1D | BITFLAG_UINT] = "UTEX_1D";
    PBTextureType[PBTextureType["TEX_2D"] = BITFLAG_2D | BITFLAG_FLOAT] = "TEX_2D";
    PBTextureType[PBTextureType["ITEX_2D"] = BITFLAG_2D | BITFLAG_INT] = "ITEX_2D";
    PBTextureType[PBTextureType["UTEX_2D"] = BITFLAG_2D | BITFLAG_UINT] = "UTEX_2D";
    PBTextureType[PBTextureType["TEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_FLOAT | BITFLAG_ARRAY] = "TEX_2D_ARRAY";
    PBTextureType[PBTextureType["ITEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_INT | BITFLAG_ARRAY] = "ITEX_2D_ARRAY";
    PBTextureType[PBTextureType["UTEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_UINT | BITFLAG_ARRAY] = "UTEX_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_3D"] = BITFLAG_3D | BITFLAG_FLOAT] = "TEX_3D";
    PBTextureType[PBTextureType["ITEX_3D"] = BITFLAG_3D | BITFLAG_INT] = "ITEX_3D";
    PBTextureType[PBTextureType["UTEX_3D"] = BITFLAG_3D | BITFLAG_UINT] = "UTEX_3D";
    PBTextureType[PBTextureType["TEX_CUBE"] = BITFLAG_CUBE | BITFLAG_FLOAT] = "TEX_CUBE";
    PBTextureType[PBTextureType["ITEX_CUBE"] = BITFLAG_CUBE | BITFLAG_INT] = "ITEX_CUBE";
    PBTextureType[PBTextureType["UTEX_CUBE"] = BITFLAG_CUBE | BITFLAG_UINT] = "UTEX_CUBE";
    PBTextureType[PBTextureType["TEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_FLOAT | BITFLAG_ARRAY] = "TEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["ITEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_INT | BITFLAG_ARRAY] = "ITEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["UTEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_UINT | BITFLAG_ARRAY] = "UTEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["TEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_FLOAT | BITFLAG_MULTISAMPLED] = "TEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["ITEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_INT | BITFLAG_MULTISAMPLED] = "ITEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["UTEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_UINT | BITFLAG_MULTISAMPLED] = "UTEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["TEX_STORAGE_1D"] = BITFLAG_1D | BITFLAG_STORAGE] = "TEX_STORAGE_1D";
    PBTextureType[PBTextureType["TEX_STORAGE_2D"] = BITFLAG_2D | BITFLAG_STORAGE] = "TEX_STORAGE_2D";
    PBTextureType[PBTextureType["TEX_STORAGE_2D_ARRAY"] = BITFLAG_2D | BITFLAG_ARRAY | BITFLAG_STORAGE] = "TEX_STORAGE_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_STORAGE_3D"] = BITFLAG_3D | BITFLAG_STORAGE] = "TEX_STORAGE_3D";
    PBTextureType[PBTextureType["TEX_DEPTH_2D"] = BITFLAG_2D | BITFLAG_DEPTH] = "TEX_DEPTH_2D";
    PBTextureType[PBTextureType["TEX_DEPTH_2D_ARRAY"] = BITFLAG_2D | BITFLAG_ARRAY | BITFLAG_DEPTH] = "TEX_DEPTH_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_DEPTH_CUBE"] = BITFLAG_CUBE | BITFLAG_DEPTH] = "TEX_DEPTH_CUBE";
    PBTextureType[PBTextureType["TEX_DEPTH_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_ARRAY | BITFLAG_DEPTH] = "TEX_DEPTH_CUBE_ARRAY";
    PBTextureType[PBTextureType["TEX_DEPTH_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_MULTISAMPLED | BITFLAG_DEPTH] = "TEX_DEPTH_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["TEX_EXTERNAL"] = BITFLAG_EXTERNAL] = "TEX_EXTERNAL";
})(PBTextureType || (PBTextureType = {}));
const textureTypeMapWebGL = {
    [PBTextureType.TEX_1D]: 'highp sampler2D',
    [PBTextureType.TEX_2D]: 'highp sampler2D',
    [PBTextureType.TEX_CUBE]: 'highp samplerCube',
    [PBTextureType.TEX_EXTERNAL]: 'highp sampler2D'
};
const textureTypeMapWebGL2 = {
    [PBTextureType.TEX_1D]: 'highp sampler2D',
    [PBTextureType.TEX_2D]: 'highp sampler2D',
    [PBTextureType.ITEX_1D]: 'highp isampler2D',
    [PBTextureType.ITEX_2D]: 'highp isampler2D',
    [PBTextureType.UTEX_1D]: 'highp usampler2D',
    [PBTextureType.UTEX_2D]: 'highp usampler2D',
    [PBTextureType.TEX_2D_ARRAY]: 'highp sampler2DArray',
    [PBTextureType.ITEX_2D_ARRAY]: 'highp isampler2DArray',
    [PBTextureType.UTEX_2D_ARRAY]: 'highp usampler2DArray',
    [PBTextureType.TEX_3D]: 'highp sampler3D',
    [PBTextureType.ITEX_3D]: 'highp isampler3D',
    [PBTextureType.UTEX_3D]: 'highp usampler3D',
    [PBTextureType.TEX_CUBE]: 'highp samplerCube',
    [PBTextureType.ITEX_CUBE]: 'highp isamplerCube',
    [PBTextureType.UTEX_CUBE]: 'highp usamplerCube',
    [PBTextureType.TEX_DEPTH_2D]: 'highp sampler2DShadow',
    [PBTextureType.TEX_DEPTH_2D_ARRAY]: 'highp sampler2DArrayShadow',
    [PBTextureType.TEX_DEPTH_CUBE]: 'highp samplerCubeShadow',
    [PBTextureType.TEX_EXTERNAL]: 'highp sampler2D'
};
const textureTypeMapWGSL = {
    [PBTextureType.TEX_1D]: 'texture_1d<f32>',
    [PBTextureType.ITEX_1D]: 'texture_1d<i32>',
    [PBTextureType.UTEX_1D]: 'texture_1d<u32>',
    [PBTextureType.TEX_2D]: 'texture_2d<f32>',
    [PBTextureType.ITEX_2D]: 'texture_2d<i32>',
    [PBTextureType.UTEX_2D]: 'texture_2d<u32>',
    [PBTextureType.TEX_2D_ARRAY]: 'texture_2d_array<f32>',
    [PBTextureType.ITEX_2D_ARRAY]: 'texture_2d_array<i32>',
    [PBTextureType.UTEX_2D_ARRAY]: 'texture_2d_array<u32>',
    [PBTextureType.TEX_3D]: 'texture_3d<f32>',
    [PBTextureType.ITEX_3D]: 'texture_3d<i32>',
    [PBTextureType.UTEX_3D]: 'texture_3d<u32>',
    [PBTextureType.TEX_CUBE]: 'texture_cube<f32>',
    [PBTextureType.ITEX_CUBE]: 'texture_cube<i32>',
    [PBTextureType.UTEX_CUBE]: 'texture_cube<u32>',
    [PBTextureType.TEX_CUBE_ARRAY]: 'texture_cube_array<f32>',
    [PBTextureType.ITEX_CUBE_ARRAY]: 'texture_cube_array<i32>',
    [PBTextureType.UTEX_CUBE_ARRAY]: 'texture_cube_array<u32>',
    [PBTextureType.TEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<f32>',
    [PBTextureType.ITEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<i32>',
    [PBTextureType.UTEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<u32>',
    [PBTextureType.TEX_STORAGE_1D]: 'texture_storage_1d',
    [PBTextureType.TEX_STORAGE_2D]: 'texture_storage_2d',
    [PBTextureType.TEX_STORAGE_2D_ARRAY]: 'texture_storage_2d_array',
    [PBTextureType.TEX_STORAGE_3D]: 'texture_storage_3d',
    [PBTextureType.TEX_DEPTH_2D]: 'texture_depth_2d',
    [PBTextureType.TEX_DEPTH_2D_ARRAY]: 'texture_depth_2d_array',
    [PBTextureType.TEX_DEPTH_CUBE]: 'texture_depth_cube',
    [PBTextureType.TEX_DEPTH_CUBE_ARRAY]: 'texture_depth_cube_array',
    [PBTextureType.TEX_DEPTH_MULTISAMPLED_2D]: 'texture_depth_multisampled_2d',
    [PBTextureType.TEX_EXTERNAL]: 'texture_external'
};
const storageTexelFormatMap = {
    'rgba8unorm': 'rgba8unorm',
    'rgba8snorm': 'rgba8snorm',
    'bgra8unorm': 'bgra8unorm',
    'rgba8ui': 'rgba8uint',
    'rgba8i': 'rgba8sint',
    'rgba16ui': 'rgba16uint',
    'rgba16i': 'rgba16sint',
    'rgba16f': 'rgba16float',
    'r32f': 'r32float',
    'r32ui': 'r32uint',
    'r32i': 'r32sint',
    'rg32f': 'rg32float',
    'rg32ui': 'rg32uint',
    'rg32i': 'rg32sint',
    'rgba32f': 'rgba32float',
    'rgba32ui': 'rgba32uint',
    'rgba32i': 'rgba32sint'
};
var PBSamplerAccessMode;
(function(PBSamplerAccessMode) {
    PBSamplerAccessMode[PBSamplerAccessMode["UNKNOWN"] = 0] = "UNKNOWN";
    PBSamplerAccessMode[PBSamplerAccessMode["SAMPLE"] = 1] = "SAMPLE";
    PBSamplerAccessMode[PBSamplerAccessMode["COMPARISON"] = 2] = "COMPARISON";
})(PBSamplerAccessMode || (PBSamplerAccessMode = {}));
var PBAddressSpace;
(function(PBAddressSpace) {
    PBAddressSpace["UNKNOWN"] = 'unknown';
    PBAddressSpace["FUNCTION"] = 'function';
    PBAddressSpace["PRIVATE"] = 'private';
    PBAddressSpace["WORKGROUP"] = 'workgroup';
    PBAddressSpace["UNIFORM"] = 'uniform';
    PBAddressSpace["STORAGE"] = 'storage';
})(PBAddressSpace || (PBAddressSpace = {}));
var PBTypeClass;
(function(PBTypeClass) {
    PBTypeClass[PBTypeClass["UNKNOWN"] = 0] = "UNKNOWN";
    PBTypeClass[PBTypeClass["PLAIN"] = 1] = "PLAIN";
    PBTypeClass[PBTypeClass["ARRAY"] = 2] = "ARRAY";
    PBTypeClass[PBTypeClass["POINTER"] = 3] = "POINTER";
    PBTypeClass[PBTypeClass["ATOMIC_I32"] = 4] = "ATOMIC_I32";
    PBTypeClass[PBTypeClass["ATOMIC_U32"] = 5] = "ATOMIC_U32";
    PBTypeClass[PBTypeClass["TEXTURE"] = 6] = "TEXTURE";
    PBTypeClass[PBTypeClass["SAMPLER"] = 7] = "SAMPLER";
    PBTypeClass[PBTypeClass["FUNCTION"] = 8] = "FUNCTION";
    PBTypeClass[PBTypeClass["VOID"] = 9] = "VOID";
    PBTypeClass[PBTypeClass["ANY"] = 10] = "ANY";
})(PBTypeClass || (PBTypeClass = {}));
/**
 * Abstract base class for any type
 * @public
 */ class PBTypeInfo {
    /** @internal */ cls;
    /** @internal */ detail;
    /** @internal */ id;
    /** @internal */ constructor(cls, detail){
        this.cls = cls;
        this.detail = detail;
        this.id = null;
    }
    /** Get unique id for this type */ get typeId() {
        if (!this.id) {
            this.id = this.genTypeId();
        }
        return this.id;
    }
    /** returns true if this is a void type */ isVoidType() {
        return false;
    }
    /** returns true if this is an any type */ isAnyType() {
        return false;
    }
    /** returns true if this is a primitive type */ isPrimitiveType() {
        return false;
    }
    /** returns true if this is a struct type */ isStructType() {
        return false;
    }
    /** returns true if this is an array type */ isArrayType() {
        return false;
    }
    /** returns true if this is a pointer type */ isPointerType() {
        return false;
    }
    /** returns true if this is an atomic int type */ isAtomicI32() {
        return false;
    }
    /** returns true if this is an atomic uint type */ isAtomicU32() {
        return false;
    }
    /** returns true if this is a sampler type */ isSamplerType() {
        return false;
    }
    /** returns true if this is a texture type */ isTextureType() {
        return false;
    }
    /** @internal */ isHostSharable() {
        return false;
    }
    /** @internal */ isConstructible() {
        return false;
    }
    /** @internal */ isStorable() {
        return false;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        return [];
    }
    /**
   * Check whether a given type is compatible with this type
   * @param other - The type to be checked
   * @returns true if the given type is compatible with this type, othewise false
   */ isCompatibleType(other) {
        return other.typeId === this.typeId;
    }
}
/**
 * The void type info
 * @public
 */ class PBVoidTypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.VOID, null);
    }
    /** {@inheritDoc PBTypeInfo.isVoidType} */ isVoidType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        return 'void';
    }
    /** @internal */ genTypeId() {
        return 'void';
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
}
/**
 * The void type info
 * @public
 */ class PBAnyTypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ANY, null);
    }
    /** {@inheritDoc PBTypeInfo.isAnyType} */ isAnyType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        return 'any';
    }
    /** @internal */ genTypeId() {
        return 'any';
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** {@inheritDoc PBTypeInfo.isCompatibleType} */ isCompatibleType(other) {
        return true;
    }
}
/**
 * The primitive type info
 * @public
 */ class PBPrimitiveTypeInfo extends PBTypeInfo {
    /** @internal */ static cachedTypes = {};
    /** @internal */ static cachedCtorOverloads = {};
    constructor(type){
        super(PBTypeClass.PLAIN, {
            primitiveType: type
        });
    }
    /** Get or create a PBPrimitiveTypeInfo instance for a given prmitive type */ static getCachedTypeInfo(primitiveType) {
        let typeinfo = this.cachedTypes[primitiveType];
        if (!typeinfo) {
            typeinfo = new PBPrimitiveTypeInfo(primitiveType);
            this.cachedTypes[primitiveType] = typeinfo;
        }
        return typeinfo;
    }
    /** @internal */ static getCachedOverloads(deviceType, primitiveType) {
        let deviceOverloads = this.cachedCtorOverloads[deviceType];
        if (!deviceOverloads) {
            deviceOverloads = {};
            this.cachedCtorOverloads[deviceType] = deviceOverloads;
        }
        let result = deviceOverloads[primitiveType];
        if (!result) {
            const typeinfo = this.getCachedTypeInfo(primitiveType);
            const name = typeinfo.toTypeName(deviceType);
            result = [
                new PBFunctionTypeInfo(name, typeinfo, [])
            ];
            if (typeinfo.isScalarType()) {
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.F32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.I32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.U32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.BOOL)
                    }
                ]));
            } else if (typeinfo.isVectorType()) {
                const scalarTypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.scalarType)
                };
                const vec2TypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.resizeType(1, 2))
                };
                const vec3TypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.resizeType(1, 3))
                };
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    scalarTypeInfo
                ]));
                switch(typeinfo.cols){
                    case 2:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec2$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec2$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec2$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec2
                            }
                        ]));
                        break;
                    case 3:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec3$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec3$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec3$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec3
                            }
                        ]));
                        break;
                    case 4:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec2TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec3TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec3TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec4$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec4$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec4$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec4
                            }
                        ]));
                }
            } else if (typeinfo.isMatrixType()) {
                const colType = this.getCachedTypeInfo(typeinfo.resizeType(1, typeinfo.cols));
                result.push(new PBFunctionTypeInfo(name, typeinfo, Array.from({
                    length: typeinfo.rows
                }).map(()=>({
                        type: colType
                    }))));
                result.push(new PBFunctionTypeInfo(name, typeinfo, Array.from({
                    length: typeinfo.rows * typeinfo.cols
                }).map(()=>({
                        type: typeF32$1
                    }))));
            }
            deviceOverloads[primitiveType] = result;
        }
        return result;
    }
    /** Get the primitive type */ get primitiveType() {
        return this.detail.primitiveType;
    }
    /** Whether the type is signed or unsigned integer scalar or vector */ isInteger() {
        const st = this.primitiveType & SCALAR_TYPE_BITMASK;
        return st === I8_BITMASK || st === U8_BITMASK || st === I16_BITMASK || st === U16_BITMASK || st === I32_BITMASK || st === U32_BITMASK;
    }
    /** Get the scalar type */ get scalarType() {
        return this.resizeType(1, 1);
    }
    /** Get number of rows */ get rows() {
        return this.primitiveType >> ROWS_BITSHIFT & ROWS_BITMASK;
    }
    /** Get number of columns */ get cols() {
        return this.primitiveType >> COLS_BITSHIFT & COLS_BITMASK;
    }
    /** Get if this is a normalized primitive type */ get normalized() {
        return !!(this.primitiveType >> NORM_BITSHIFT & NORM_BITMASK);
    }
    /** @internal */ getLayoutAlignment(layout) {
        return layout === 'packed' ? 1 : this.isScalarType() ? 4 : 1 << Math.min(4, this.cols + 1);
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        let scalarSize;
        switch(this.scalarType){
            case PBPrimitiveType.BOOL:
            case PBPrimitiveType.I32:
            case PBPrimitiveType.I32_NORM:
            case PBPrimitiveType.U32:
            case PBPrimitiveType.U32_NORM:
            case PBPrimitiveType.F32:
                scalarSize = 4;
                break;
            case PBPrimitiveType.F16:
            case PBPrimitiveType.I16:
            case PBPrimitiveType.I16_NORM:
            case PBPrimitiveType.U16:
            case PBPrimitiveType.U16_NORM:
                scalarSize = 2;
                break;
            default:
                scalarSize = 1;
                break;
        }
        return scalarSize * this.cols * this.rows;
    }
    /**
   * Creates a new primitive type info by changing row and column of this type
   * @param rows - The new value of row
   * @param cols - The new value of column
   * @returns The new primitive type
   */ resizeType(rows, cols) {
        return makePrimitiveType(this.primitiveType & SCALAR_TYPE_BITMASK, rows, cols, this.normalized ? 1 : 0);
    }
    /** Returns true if this is a scalar type */ isScalarType() {
        return this.rows === 1 && this.cols === 1;
    }
    /** Returns true if this is a vector type */ isVectorType() {
        return this.rows === 1 && this.cols > 1;
    }
    /** Returns true if this is a matrix type */ isMatrixType() {
        return this.rows > 1 && this.cols > 1;
    }
    /** {@inheritDoc PBTypeInfo.isPrimitiveType} */ isPrimitiveType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.scalarType !== PBPrimitiveType.BOOL;
    }
    /** @internal */ isConstructible() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        return PBPrimitiveTypeInfo.getCachedOverloads(deviceType, this.primitiveType);
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = primitiveTypeMapWGSL[this.primitiveType];
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            const typename = primitiveTypeMapWebGL[this.primitiveType];
            return varName ? `${typename} ${varName}` : typename;
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `PRIM:${this.primitiveType}`;
    }
}
/**
 * The struct type info
 * @public
 */ class PBStructTypeInfo extends PBTypeInfo {
    constructor(name, layout, members){
        super(PBTypeClass.PLAIN, {
            layout: layout || 'default',
            structName: name,
            structMembers: members.map((val)=>{
                const defaultAlignment = getAlignment(val.type);
                const defaultSize = getSize(val.type);
                return {
                    name: val.name,
                    type: val.type,
                    alignment: defaultAlignment,
                    size: defaultSize,
                    defaultAlignment: defaultAlignment,
                    defaultSize: defaultSize
                };
            })
        });
        if (this.layout === 'std140') {
            this.calcAlignmentAndSizeSTD140();
        } else if (this.layout === 'std430') {
            this.calcAlignmentAndSizePacked();
        }
    }
    /** Get the layout type */ get layout() {
        return this.detail.layout;
    }
    /** Get name of the struct type */ get structName() {
        return this.detail.structName;
    }
    set structName(val) {
        this.detail.structName = val;
    }
    /** Get member types of the struct type */ get structMembers() {
        return this.detail.structMembers;
    }
    /**
   * Creates a new struct type by extending this type
   * @param name - Name of the new struct type
   * @param members - additional struct members
   * @returns The new struct type
   */ extends(name, members) {
        const oldMembers = this.structMembers.map((member)=>({
                name: member.name,
                type: member.type
            }));
        return new PBStructTypeInfo(name, this.layout, [
            ...oldMembers,
            ...members
        ]);
    }
    /** {@inheritDoc PBTypeInfo.isStructType} */ isStructType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.detail.structMembers.every((val)=>val.type.isHostSharable());
    }
    /** @internal */ isConstructible() {
        return this.detail.structMembers.every((val)=>val.type.isConstructible());
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads() {
        const result = [
            new PBFunctionTypeInfo(this.structName, this, [])
        ];
        if (this.isConstructible()) {
            result.push(new PBFunctionTypeInfo(this.structName, this, this.structMembers.map((val)=>({
                    type: val.type
                }))));
        }
        return result;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            return varName ? `${varName}: ${this.structName}` : this.structName;
        } else {
            return varName ? `${this.structName} ${varName}` : this.structName;
        }
    }
    /** @internal */ isWritable() {
        for (const member of this.structMembers){
            if (member.type.isAtomicI32() || member.type.isAtomicU32()) {
                return true;
            }
            if (member.type.isStructType() && member.type.isWritable()) {
                return true;
            }
        }
        return false;
    }
    /** @internal */ getLayoutAlignment(layout) {
        if (layout === 'packed') {
            return 1;
        }
        let alignment = 0;
        for (const member of this.structMembers){
            alignment = Math.max(alignment, member.type.getLayoutAlignment(layout));
        }
        if (layout === 'std140') {
            alignment = align(alignment, 16);
        }
        return alignment;
    }
    /** @internal */ getLayoutSize(layout) {
        let size = 0;
        let structAlignment = 0;
        for (const member of this.structMembers){
            const memberAlignment = member.type.getLayoutAlignment(layout);
            size = align(size, memberAlignment);
            size += member.type.getLayoutSize(layout);
            structAlignment = Math.max(structAlignment, memberAlignment);
        }
        return align(size, structAlignment);
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset, layout) {
        const bufferLayout = {
            byteSize: 0,
            entries: []
        };
        const start = offset;
        for (const member of this.structMembers){
            offset = align(offset, member.type.getLayoutAlignment(layout));
            const size = member.type.getLayoutSize(layout);
            bufferLayout.entries.push({
                name: member.name,
                offset: offset,
                byteSize: size,
                type: typeToTypedArray(member.type),
                subLayout: member.type.isStructType() ? member.type.toBufferLayout(offset, layout) : null,
                arraySize: member.type.isArrayType() ? member.type.dimension : 0
            });
            offset += size;
        }
        bufferLayout.byteSize = layout === 'std140' ? align(offset - start, 16) : offset - start;
        return bufferLayout;
    }
    /** @internal */ clone(newName) {
        return new PBStructTypeInfo(newName || this.structName, this.layout, this.structMembers);
    }
    /** @internal */ reset(name, layout, members) {
        this.detail = {
            layout: layout || 'default',
            structName: name,
            structMembers: members.map((val)=>{
                const defaultAlignment = getAlignment(val.type);
                const defaultSize = getSize(val.type);
                return {
                    name: val.name,
                    type: val.type,
                    alignment: defaultAlignment,
                    size: defaultSize,
                    defaultAlignment: defaultAlignment,
                    defaultSize: defaultSize
                };
            })
        };
        if (this.layout === 'std140') {
            this.calcAlignmentAndSizeSTD140();
        } else if (this.layout === 'std430') {
            this.calcAlignmentAndSizePacked();
        }
        this.id = null;
    }
    /** @internal */ genTypeId() {
        return `STRUCT:${this.structName}:${this.layout}:${this.structMembers.map((val)=>`${val.name}(${val.type.typeId})`).join(':')}`;
    }
    /** @internal */ calcAlignmentAndSizeSTD140() {
        for (const member of this.structMembers){
            if (member.type.isPrimitiveType()) {
                if (member.type.isMatrixType() && member.type.cols === 2) {
                    throw new Error(`matrix${member.type.rows}x${member.type.cols} can not be used in std140 layout`);
                }
            } else if (member.type.isArrayType() && (member.type.elementType.isAnyType() || getAlignment(member.type.elementType) !== 16)) {
                throw new Error('array element must be 16 bytes aligned in std140 layout');
            } else if (member.type.isStructType()) {
                member.alignment = 16;
                member.size = align(member.defaultSize, 16);
            }
        }
    }
    /** @internal */ calcAlignmentAndSizePacked() {
        for (const member of this.structMembers){
            member.alignment = getAlignmentPacked(member.type);
            member.size = getSizePacked(member.type);
        }
    }
}
/**
 * The array type info
 * @public
 */ class PBArrayTypeInfo extends PBTypeInfo {
    constructor(elementType, dimension){
        super(PBTypeClass.ARRAY, {
            elementType: elementType,
            dimension: Number(dimension) || 0
        });
    }
    /** Get the element type */ get elementType() {
        return this.detail.elementType;
    }
    /** Get dimension of the array type */ get dimension() {
        return this.detail.dimension;
    }
    /** {@inheritDoc PBTypeInfo.isArrayType} */ isArrayType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.detail.elementType.isHostSharable();
    }
    /** @internal */ isConstructible() {
        return this.dimension && this.detail.elementType.isConstructible();
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        const name = this.toTypeName(deviceType);
        const result = [
            new PBFunctionTypeInfo(name, this, [])
        ];
        if (deviceType !== 'webgl' && this.isConstructible()) {
            result.push(new PBFunctionTypeInfo(name, this, Array.from({
                length: this.dimension
            }).map(()=>({
                    type: this.elementType
                }))));
        }
        return result;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const elementTypeName = this.elementType.toTypeName(deviceType);
            const typename = `array<${elementTypeName}${this.dimension ? ', ' + this.dimension : ''}>`;
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            console.assert(!!this.dimension, 'runtime-sized array not supported for webgl');
            console.assert(!this.elementType.isArrayType(), 'multi-dimensional arrays not supported for webgl');
            const elementTypeName = this.elementType.toTypeName(deviceType, varName);
            return `${elementTypeName}[${this.dimension}]`;
        }
    }
    /** @internal */ getLayoutAlignment(layout) {
        return layout === 'packed' || this.elementType.isAnyType() ? 1 : layout === 'std430' ? this.elementType.getLayoutAlignment(layout) : align(this.elementType.getLayoutAlignment(layout), 16);
    }
    /** @internal */ getLayoutSize(layout) {
        const elementAlignment = this.elementType.isAnyType() ? 1 : this.elementType.getLayoutAlignment(layout);
        if (layout === 'std140' && !!(elementAlignment & 15)) {
            // array element stride of std140 layout must be multiple of 16
            throw new Error('Error: array element stride of std140 must be multiple of 16');
        }
        return this.elementType.isAnyType() ? 0 : this.dimension * align(this.elementType.getLayoutSize(layout), elementAlignment);
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    isCompatibleType(other) {
        if (!other.isArrayType()) {
            return false;
        }
        if (this.dimension !== 0 && other.dimension !== this.dimension) {
            return false;
        }
        return this.elementType.isCompatibleType(other.elementType);
    }
    /** @internal */ genTypeId() {
        return `ARRAY:(${this.elementType.typeId})[${this.dimension}]`;
    }
}
/**
 * The pointer type info
 * @public
 */ class PBPointerTypeInfo extends PBTypeInfo {
    /** @internal */ writable;
    constructor(pointerType, addressSpace){
        super(PBTypeClass.POINTER, {
            pointerType,
            addressSpace
        });
        console.assert(pointerType.isStorable(), 'the pointee type must be storable');
        this.writable = false;
    }
    /** Get type of the pointer */ get pointerType() {
        return this.detail.pointerType;
    }
    /** Get address space of the pointer */ get addressSpace() {
        return this.detail.addressSpace;
    }
    set addressSpace(val) {
        if (this.detail.addressSpace !== val) {
            this.detail.addressSpace = val;
            this.id = null;
        }
    }
    /** {@inheritDoc PBTypeInfo.isPointerType} */ isPointerType() {
        return true;
    }
    /** @internal */ toTypeName(device, varName) {
        if (device === 'webgpu') {
            const addressSpace = this.addressSpace === PBAddressSpace.UNKNOWN ? PBAddressSpace.FUNCTION : this.addressSpace;
            /*
      const mode = addressSpace === PBAddressSpace.UNIFORM || (addressSpace === PBAddressSpace.STORAGE && !this.writable) ? 'read' : 'read_write'
      const typename = `ptr<${addressSpace}, ${this.pointerType.toTypeName(device)}, ${mode}>`;
      */ /* WGSL spec:
        When writing a variable declaration or a pointer type in WGSL source:
        For the storage address space, the access mode is optional, and defaults to read.
        For other address spaces, the access mode must not be written.
      */ const mode = addressSpace === PBAddressSpace.STORAGE && this.writable ? ', read_write' : '';
            const typename = `ptr<${addressSpace}, ${this.pointerType.toTypeName(device)} ${mode}>`;
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('pointer type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `PTR:(${this.pointerType.typeId})`;
    }
}
/**
 * The atomic int type info
 * @public
 */ class PBAtomicI32TypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ATOMIC_I32, null);
    }
    /** @internal */ isAtomicI32() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = 'atomic<i32>';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('atomic type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ getLayoutAlignment(layout) {
        return 4;
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        return 4;
    }
    /** @internal */ genTypeId() {
        return `ATOMICI32`;
    }
}
/**
 * The atomic int type info
 * @public
 */ class PBAtomicU32TypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ATOMIC_U32, null);
    }
    /** @internal */ isAtomicU32() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = 'atomic<u32>';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('atomic type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ getLayoutAlignment(layout) {
        return 4;
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        return 4;
    }
    /** @internal */ genTypeId() {
        return `ATOMICU32`;
    }
}
/**
 * The sampler type info
 * @public
 */ class PBSamplerTypeInfo extends PBTypeInfo {
    constructor(accessMode){
        super(PBTypeClass.SAMPLER, {
            accessMode: accessMode
        });
    }
    /** Get the access mode */ get accessMode() {
        return this.detail.accessMode;
    }
    /** @internal */ isSamplerType() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = this.accessMode === PBSamplerAccessMode.SAMPLE ? 'sampler' : 'sampler_comparison';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('sampler type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `SAMPLER:${this.accessMode}`;
    }
}
/**
 * The texture type info
 * @public
 */ class PBTextureTypeInfo extends PBTypeInfo {
    constructor(textureType, texelFormat, readable, writable){
        super(PBTypeClass.TEXTURE, {
            textureType: textureType,
            readable,
            writable,
            storageTexelFormat: texelFormat || null
        });
        console.assert(!!textureTypeMapWGSL[textureType], 'unsupported texture type');
        console.assert(!(textureType & BITFLAG_STORAGE) || !!storageTexelFormatMap[texelFormat], 'invalid texel format for storage texture');
    }
    /** Get the texture type */ get textureType() {
        return this.detail.textureType;
    }
    /** Get texture format if this is a storage texture */ get storageTexelFormat() {
        return this.detail.storageTexelFormat;
    }
    /** Returns true if this is a readable storage texture type */ get readable() {
        return this.detail.readable;
    }
    /** Returns true if this is a writable storage texture type */ get writable() {
        return this.detail.writable;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ is1DTexture() {
        return !!(this.detail.textureType & BITFLAG_1D);
    }
    /** Returns true if this is a 2D texture type */ is2DTexture() {
        return !!(this.detail.textureType & BITFLAG_2D);
    }
    /** Returns true if this is a 3D texture type */ is3DTexture() {
        return !!(this.detail.textureType & BITFLAG_3D);
    }
    /** Returns true if this is a cube texture type */ isCubeTexture() {
        return !!(this.detail.textureType & BITFLAG_CUBE);
    }
    /** Returns true if this is an array texture type */ isArrayTexture() {
        return !!(this.detail.textureType & BITFLAG_ARRAY);
    }
    /** Returns true if this is a storage texture type */ isStorageTexture() {
        return !!(this.detail.textureType & BITFLAG_STORAGE);
    }
    /** Return s true if this is a depth texture type */ isDepthTexture() {
        return !!(this.detail.textureType & BITFLAG_DEPTH);
    }
    /** Returns true if this is a multisampled texture type */ isMultisampledTexture() {
        return !!(this.detail.textureType & BITFLAG_MULTISAMPLED);
    }
    /** Returns true if this is an external texture type */ isExternalTexture() {
        return !!(this.detail.textureType & BITFLAG_EXTERNAL);
    }
    /** Returns true if the texture format is of type integer  */ isIntTexture() {
        return !!(this.detail.textureType & BITFLAG_INT);
    }
    /** Returns true if the texture format is of type unsigned integer  */ isUIntTexture() {
        return !!(this.detail.textureType & BITFLAG_UINT);
    }
    /** @internal */ isTextureType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            let typename = textureTypeMapWGSL[this.textureType];
            if (this.isStorageTexture()) {
                const storageTexelFormat = storageTexelFormatMap[this.storageTexelFormat];
                // storage textures currently only support 'write' access control
                const accessMode = 'write'; //this.readable ? (this.writable ? 'read_write' : 'read') : 'write';
                typename = `${typename}<${storageTexelFormat}, ${accessMode}>`;
            }
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            const typename = (deviceType === 'webgl' ? textureTypeMapWebGL : textureTypeMapWebGL2)[this.textureType];
            console.assert(!!typename, 'unsupported texture type');
            return varName ? `${typename} ${varName}` : typename;
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `TEXTURE:${this.textureType}`;
    }
}
/**
 * The function type info
 * @public
 */ class PBFunctionTypeInfo extends PBTypeInfo {
    constructor(name, returnType, argTypes){
        super(PBTypeClass.FUNCTION, {
            name,
            returnType,
            argTypes
        });
    }
    /** Get name of the function */ get name() {
        return this.detail.name;
    }
    /** Get return type of the function */ get returnType() {
        return this.detail.returnType;
    }
    /** Get all the argument types for this function */ get argTypes() {
        return this.detail.argTypes;
    }
    /** Get hash for parameter types */ get argHash() {
        return this.argTypes.map((val)=>val.type.typeId).join(',');
    }
    /** @internal */ genTypeId() {
        return `fn(${this.argHash}):${this.returnType.typeId}`;
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        throw new Error('not supported');
    }
}
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC4);
/** @internal */ const typeF32$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32);
/** @internal */ const typeF32Vec2$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC2);
/** @internal */ const typeF32Vec3$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC3);
/** @internal */ const typeF32Vec4$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4_NORM);
/** @internal */ const typeAtomicI32 = new PBAtomicI32TypeInfo();
/** @internal */ const typeAtomicU32 = new PBAtomicU32TypeInfo();
/** @internal */ const typeI32$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
/** @internal */ const typeI32Vec2$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2);
/** @internal */ const typeI32Vec3$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3);
/** @internal */ const typeI32Vec4$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4_NORM);
/** @internal */ const typeU32$2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
/** @internal */ const typeU32Vec2$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2);
/** @internal */ const typeU32Vec3$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3);
/** @internal */ const typeU32Vec4$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4_NORM);
/** @internal */ const typeBool = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BOOL);
/** @internal */ const typeBVec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC2);
/** @internal */ const typeBVec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC3);
/** @internal */ const typeBVec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC4);
/** @internal */ const typeMat2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2);
/** @internal */ const typeMat2x3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2x3);
/** @internal */ const typeMat2x4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2x4);
/** @internal */ const typeMat3x2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3x2);
/** @internal */ const typeMat3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3);
/** @internal */ const typeMat3x4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3x4);
/** @internal */ const typeMat4x2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4x2);
/** @internal */ const typeMat4x3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4x3);
/** @internal */ const typeMat4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4);
/** @internal */ const typeTex1D = new PBTextureTypeInfo(PBTextureType.TEX_1D);
/** @internal */ const typeITex1D = new PBTextureTypeInfo(PBTextureType.ITEX_1D);
/** @internal */ const typeUTex1D = new PBTextureTypeInfo(PBTextureType.UTEX_1D);
/** @internal */ const typeTex2D = new PBTextureTypeInfo(PBTextureType.TEX_2D);
/** @internal */ const typeITex2D = new PBTextureTypeInfo(PBTextureType.ITEX_2D);
/** @internal */ const typeUTex2D = new PBTextureTypeInfo(PBTextureType.UTEX_2D);
/** @internal */ const typeTex2DArray = new PBTextureTypeInfo(PBTextureType.TEX_2D_ARRAY);
/** @internal */ const typeITex2DArray = new PBTextureTypeInfo(PBTextureType.ITEX_2D_ARRAY);
/** @internal */ const typeUTex2DArray = new PBTextureTypeInfo(PBTextureType.UTEX_2D_ARRAY);
/** @internal */ const typeTex3D = new PBTextureTypeInfo(PBTextureType.TEX_3D);
/** @internal */ const typeITex3D = new PBTextureTypeInfo(PBTextureType.ITEX_3D);
/** @internal */ const typeUTex3D = new PBTextureTypeInfo(PBTextureType.UTEX_3D);
/** @internal */ const typeTexCube = new PBTextureTypeInfo(PBTextureType.TEX_CUBE);
/** @internal */ const typeITexCube = new PBTextureTypeInfo(PBTextureType.ITEX_CUBE);
/** @internal */ const typeUTexCube = new PBTextureTypeInfo(PBTextureType.UTEX_CUBE);
/** @internal */ const typeTexExternal = new PBTextureTypeInfo(PBTextureType.TEX_EXTERNAL);
/** @internal */ const typeTexCubeArray = new PBTextureTypeInfo(PBTextureType.TEX_CUBE_ARRAY);
/** @internal */ const typeITexCubeArray = new PBTextureTypeInfo(PBTextureType.ITEX_CUBE_ARRAY);
/** @internal */ const typeUTexCubeArray = new PBTextureTypeInfo(PBTextureType.UTEX_CUBE_ARRAY);
/** @internal */ const typeTexMultisampled2D = new PBTextureTypeInfo(PBTextureType.TEX_MULTISAMPLED_2D);
/** @internal */ const typeITexMultisampled2D = new PBTextureTypeInfo(PBTextureType.ITEX_MULTISAMPLED_2D);
/** @internal */ const typeUTexMultisampled2D = new PBTextureTypeInfo(PBTextureType.UTEX_MULTISAMPLED_2D);
/** @internal */ const typeTexStorage1D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8unorm');
/** @internal */ const typeTexStorage1D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8unorm');
/** @internal */ const typeTexStorage1D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8ui');
/** @internal */ const typeTexStorage1D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8i');
/** @internal */ const typeTexStorage1D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16ui');
/** @internal */ const typeTexStorage1D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16i');
/** @internal */ const typeTexStorage1D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16f');
/** @internal */ const typeTexStorage1D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32ui');
/** @internal */ const typeTexStorage1D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32i');
/** @internal */ const typeTexStorage1D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32f');
/** @internal */ const typeTexStorage1D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32ui');
/** @internal */ const typeTexStorage1D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32i');
/** @internal */ const typeTexStorage1D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32f');
/** @internal */ const typeTexStorage1D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32ui');
/** @internal */ const typeTexStorage1D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32i');
/** @internal */ const typeTexStorage1D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32f');
/** @internal */ const typeTexStorage2D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8unorm');
/** @internal */ const typeTexStorage2D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'bgra8unorm');
/** @internal */ const typeTexStorage2D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8ui');
/** @internal */ const typeTexStorage2D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8i');
/** @internal */ const typeTexStorage2D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16ui');
/** @internal */ const typeTexStorage2D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16i');
/** @internal */ const typeTexStorage2D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16f');
/** @internal */ const typeTexStorage2D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32ui');
/** @internal */ const typeTexStorage2D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32i');
/** @internal */ const typeTexStorage2D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32f');
/** @internal */ const typeTexStorage2D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32ui');
/** @internal */ const typeTexStorage2D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32i');
/** @internal */ const typeTexStorage2D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32f');
/** @internal */ const typeTexStorage2D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32ui');
/** @internal */ const typeTexStorage2D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32i');
/** @internal */ const typeTexStorage2D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32f');
/** @internal */ const typeTexStorage2DArray_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8unorm');
/** @internal */ const typeTexStorage2DArray_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'bgra8unorm');
/** @internal */ const typeTexStorage2DArray_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8ui');
/** @internal */ const typeTexStorage2DArray_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8i');
/** @internal */ const typeTexStorage2DArray_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16ui');
/** @internal */ const typeTexStorage2DArray_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16i');
/** @internal */ const typeTexStorage2DArray_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16f');
/** @internal */ const typeTexStorage2DArray_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32ui');
/** @internal */ const typeTexStorage2DArray_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32i');
/** @internal */ const typeTexStorage2DArray_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32f');
/** @internal */ const typeTexStorage2DArray_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32ui');
/** @internal */ const typeTexStorage2DArray_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32i');
/** @internal */ const typeTexStorage2DArray_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32f');
/** @internal */ const typeTexStorage2DArray_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32ui');
/** @internal */ const typeTexStorage2DArray_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32i');
/** @internal */ const typeTexStorage2DArray_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32f');
/** @internal */ const typeTexStorage3D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8unorm');
/** @internal */ const typeTexStorage3D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'bgra8unorm');
/** @internal */ const typeTexStorage3D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8ui');
/** @internal */ const typeTexStorage3D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8i');
/** @internal */ const typeTexStorage3D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16ui');
/** @internal */ const typeTexStorage3D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16i');
/** @internal */ const typeTexStorage3D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16f');
/** @internal */ const typeTexStorage3D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32ui');
/** @internal */ const typeTexStorage3D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32i');
/** @internal */ const typeTexStorage3D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32f');
/** @internal */ const typeTexStorage3D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32ui');
/** @internal */ const typeTexStorage3D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32i');
/** @internal */ const typeTexStorage3D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32f');
/** @internal */ const typeTexStorage3D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32ui');
/** @internal */ const typeTexStorage3D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32i');
/** @internal */ const typeTexStorage3D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32f');
/** @internal */ const typeTexDepth2D = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_2D);
/** @internal */ const typeTexDepth2DArray = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_2D_ARRAY);
/** @internal */ const typeTexDepthCube = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_CUBE);
/** @internal */ const typeTexDepthCubeArray = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_CUBE_ARRAY);
/** @internal */ const typeTexDepthMultisampled2D = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_MULTISAMPLED_2D);
/** @internal */ const typeSampler = new PBSamplerTypeInfo(PBSamplerAccessMode.SAMPLE);
/** @internal */ const typeSamplerComparison = new PBSamplerTypeInfo(PBSamplerAccessMode.COMPARISON);
/** @internal */ const typeVoid = new PBVoidTypeInfo();
/** @internal */ new PBAnyTypeInfo();
/** @internal */ const typeFrexpResult = new PBStructTypeInfo('FrexpResult', 'default', [
    {
        name: 'sig',
        type: typeF32$1
    },
    {
        name: 'exp',
        type: typeI32$1
    }
]);
/** @internal */ const typeFrexpResultVec2 = new PBStructTypeInfo('FrexpResultVec2', 'default', [
    {
        name: 'sig',
        type: typeF32Vec2$1
    },
    {
        name: 'exp',
        type: typeI32Vec2$1
    }
]);
/** @internal */ const typeFrexpResultVec3 = new PBStructTypeInfo('FrexpResultVec3', 'default', [
    {
        name: 'sig',
        type: typeF32Vec3$1
    },
    {
        name: 'exp',
        type: typeI32Vec3$1
    }
]);
/** @internal */ const typeFrexpResultVec4 = new PBStructTypeInfo('FrexpResultVec4', 'default', [
    {
        name: 'sig',
        type: typeF32Vec4$1
    },
    {
        name: 'exp',
        type: typeI32Vec4$1
    }
]);

/** @internal */ const MAX_VERTEX_ATTRIBUTES = 16;
/** @internal */ const MAX_BINDING_GROUPS = 4;
/** @internal */ const VERTEX_ATTRIB_POSITION = 0;
/** @internal */ const VERTEX_ATTRIB_NORMAL = 1;
/** @internal */ const VERTEX_ATTRIB_DIFFUSE = 2;
/** @internal */ const VERTEX_ATTRIB_TANGENT = 3;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD0 = 4;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD1 = 5;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD2 = 6;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD3 = 7;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD4 = 8;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD5 = 9;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD6 = 10;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD7 = 11;
/** @internal */ const VERTEX_ATTRIB_BLEND_WEIGHT = 12;
/** @internal */ const VERTEX_ATTRIB_BLEND_INDICES = 13;
const vertexAttribFormatMap = {
    position_u8normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    position_u8normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    position_i8normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    position_i8normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    position_u16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    position_u16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    position_i16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    position_i16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    position_u16normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    position_u16normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    position_i16normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    position_i16normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    position_f16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    position_f16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    position_f32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    position_f32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    position_f32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    position_f32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    position_i32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    position_i32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    position_i32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    position_i32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    position_u32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    position_u32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    position_u32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    position_u32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    normal_f16x4: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    normal_f32x3: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    normal_f32x4: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    diffuse_u8normx4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    diffuse_u16x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    diffuse_u16normx4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    diffuse_f16x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    diffuse_f32x3: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    diffuse_f32x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    diffuse_u32x3: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    diffuse_u32x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tangent_f16x4: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tangent_f32x3: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tangent_f32x4: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex0_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex0_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex0_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex0_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex0_u16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex0_u16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex0_i16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex0_i16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex0_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex0_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex0_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex0_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex0_f16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex0_f16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex0_f32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex0_f32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex0_f32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex0_f32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex0_i32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex0_i32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex0_i32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex0_i32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex0_u32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex0_u32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex0_u32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex0_u32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex1_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex1_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex1_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex1_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex1_u16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex1_u16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex1_i16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex1_i16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex1_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex1_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex1_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex1_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex1_f16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex1_f16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex1_f32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex1_f32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex1_f32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex1_f32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex1_i32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex1_i32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex1_i32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex1_i32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex1_u32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex1_u32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex1_u32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex1_u32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex2_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex2_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex2_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex2_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex2_u16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex2_u16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex2_i16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex2_i16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex2_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex2_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex2_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex2_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex2_f16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex2_f16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex2_f32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex2_f32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex2_f32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex2_f32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex2_i32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex2_i32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex2_i32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex2_i32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex2_u32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex2_u32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex2_u32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex2_u32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex3_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex3_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex3_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex3_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex3_u16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex3_u16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex3_i16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex3_i16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex3_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex3_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex3_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex3_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex3_f16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex3_f16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex3_f32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex3_f32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex3_f32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex3_f32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex3_i32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex3_i32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex3_i32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex3_i32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex3_u32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex3_u32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex3_u32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex3_u32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex4_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex4_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex4_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex4_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex4_u16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex4_u16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex4_i16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex4_i16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex4_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex4_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex4_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex4_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex4_f16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex4_f16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex4_f32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex4_f32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex4_f32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex4_f32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex4_i32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex4_i32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex4_i32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex4_i32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex4_u32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex4_u32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex4_u32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex4_u32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex5_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex5_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex5_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex5_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex5_u16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex5_u16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex5_i16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex5_i16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex5_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex5_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex5_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex5_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex5_f16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex5_f16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex5_f32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex5_f32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex5_f32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex5_f32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex5_i32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex5_i32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex5_i32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex5_i32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex5_u32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex5_u32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex5_u32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex5_u32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex6_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex6_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex6_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex6_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex6_u16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex6_u16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex6_i16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex6_i16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex6_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex6_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex6_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex6_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex6_f16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex6_f16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex6_f32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex6_f32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex6_f32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex6_f32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex6_i32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex6_i32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex6_i32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex6_i32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex6_u32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex6_u32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex6_u32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex6_u32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex7_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex7_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex7_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex7_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex7_u16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex7_u16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex7_i16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex7_i16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex7_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex7_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex7_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex7_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex7_f16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex7_f16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex7_f32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex7_f32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex7_f32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex7_f32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex7_i32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex7_i32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex7_i32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex7_i32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex7_u32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex7_u32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex7_u32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex7_u32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    blendweights_f16x4: [
        VERTEX_ATTRIB_BLEND_WEIGHT,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    blendweights_f32x4: [
        VERTEX_ATTRIB_BLEND_WEIGHT,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    blendindices_u16x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    blendindices_f16x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    blendindices_f32x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    blendindices_u32x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ]
};
const vertexAttribNameMap = {
    position: VERTEX_ATTRIB_POSITION,
    normal: VERTEX_ATTRIB_NORMAL,
    diffuse: VERTEX_ATTRIB_DIFFUSE,
    tangent: VERTEX_ATTRIB_TANGENT,
    blendIndices: VERTEX_ATTRIB_BLEND_INDICES,
    blendWeights: VERTEX_ATTRIB_BLEND_WEIGHT,
    texCoord0: VERTEX_ATTRIB_TEXCOORD0,
    texCoord1: VERTEX_ATTRIB_TEXCOORD1,
    texCoord2: VERTEX_ATTRIB_TEXCOORD2,
    texCoord3: VERTEX_ATTRIB_TEXCOORD3,
    texCoord4: VERTEX_ATTRIB_TEXCOORD4,
    texCoord5: VERTEX_ATTRIB_TEXCOORD5,
    texCoord6: VERTEX_ATTRIB_TEXCOORD6,
    texCoord7: VERTEX_ATTRIB_TEXCOORD7
};
const vertexAttribNameRevMap = {
    [VERTEX_ATTRIB_POSITION]: 'position',
    [VERTEX_ATTRIB_NORMAL]: 'normal',
    [VERTEX_ATTRIB_DIFFUSE]: 'diffuse',
    [VERTEX_ATTRIB_TANGENT]: 'tangent',
    [VERTEX_ATTRIB_BLEND_INDICES]: 'blendIndices',
    [VERTEX_ATTRIB_BLEND_WEIGHT]: 'blendWeights',
    [VERTEX_ATTRIB_TEXCOORD0]: 'texCoord0',
    [VERTEX_ATTRIB_TEXCOORD1]: 'texCoord1',
    [VERTEX_ATTRIB_TEXCOORD2]: 'texCoord2',
    [VERTEX_ATTRIB_TEXCOORD3]: 'texCoord3',
    [VERTEX_ATTRIB_TEXCOORD4]: 'texCoord4',
    [VERTEX_ATTRIB_TEXCOORD5]: 'texCoord5',
    [VERTEX_ATTRIB_TEXCOORD6]: 'texCoord6',
    [VERTEX_ATTRIB_TEXCOORD7]: 'texCoord7'
};
var GPUResourceUsageFlags;
(function(GPUResourceUsageFlags) {
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_LINEAR_COLOR_SPACE"] = 2] = "TF_LINEAR_COLOR_SPACE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_NO_MIPMAP"] = 4] = "TF_NO_MIPMAP";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_WRITABLE"] = 8] = "TF_WRITABLE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_NO_GC"] = 16] = "TF_NO_GC";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_VERTEX"] = 32] = "BF_VERTEX";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_INDEX"] = 64] = "BF_INDEX";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_READ"] = 128] = "BF_READ";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_WRITE"] = 256] = "BF_WRITE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_UNIFORM"] = 512] = "BF_UNIFORM";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_STORAGE"] = 1024] = "BF_STORAGE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["DYNAMIC"] = 2048] = "DYNAMIC";
    GPUResourceUsageFlags[GPUResourceUsageFlags["MANAGED"] = 4096] = "MANAGED";
})(GPUResourceUsageFlags || (GPUResourceUsageFlags = {}));
/**
 * Get vertex attribute index by semantic
 * @internal
 */ function getVertexAttribByName(name) {
    return vertexAttribNameMap[name];
}
/**
 * Get vertex semantic by attribute index
 * @internal
 */ function getVertexAttribName(attrib) {
    return vertexAttribNameRevMap[attrib];
}
/**
 * Get byte size of specified vertex format
 * @internal
 */ function getVertexFormatSize(fmt) {
    return vertexAttribFormatMap[fmt][2];
}
/**
 * Get vertex format by semantic and component type and component count
 * @param semantic - The vertex semantic
 * @param type - Data type of vertex component
 * @param count - The count of vertex components
 * @returns Vertex format
 * @public
 */ function getVertexAttribFormat(semantic, type, count) {
    const loc = getVertexAttribByName(semantic);
    for(const k in vertexAttribFormatMap){
        const v = vertexAttribFormatMap[k];
        if (v[0] === loc && v[3] === type && v[4] === count) {
            return k;
        }
    }
    return null;
}
/**
 * Get byte stride of a vertex buffer by specified structure type of the vertex buffer
 * @param vertexBufferType - The structure type of the vertex buffer
 * @returns The byte stride of the vertex buffer
 * @public
 */ function getVertexBufferStride(vertexBufferType) {
    const vertexType = vertexBufferType.structMembers[0].type.elementType;
    if (vertexType.isStructType()) {
        let stride = 0;
        for (const member of vertexType.structMembers){
            stride += member.type.getSize();
        }
        return stride;
    } else {
        return vertexType.getSize();
    }
}
/**
 * Get primitive type of a vertex attribute by specified vertex semantic
 * @param vertexBufferType - The structure type of the vertex buffer
 * @param semantic - The vertex semantic
 * @returns - The primitive type of the vertex attribute
 * @public
 */ function getVertexBufferAttribTypeBySemantic(vertexBufferType, semantic) {
    const k = vertexBufferType.structMembers[0];
    const vertexType = k.type.elementType;
    if (vertexType.isStructType()) {
        for (const member of vertexType.structMembers){
            if (member.name === semantic) {
                return member.type;
            }
        }
        return null;
    } else {
        return k.name === semantic ? vertexType : null;
    }
}
/**
 * Get primitive type of a vertex attribute by specified vertex attribute index
 * @param vertexBufferType - The structure type of the vertex buffer
 * @param semantic - The vertex attribute index
 * @returns - The primitive type of the vertex attribute
 * @public
 */ function getVertexBufferAttribType(vertexBufferType, attrib) {
    const attribName = getVertexAttribName(attrib);
    if (!attribName) {
        return null;
    }
    return getVertexBufferAttribTypeBySemantic(vertexBufferType, attribName);
}
/**
 * Get the structure type of a vertex buffer by specified vertex attribute formats and the length of the vertex buffer
 * @param length - The length of the vertex buffer
 * @param attributes - The vertex attributes
 * @returns The structure type of the vertex buffer
 * @public
 */ function makeVertexBufferType(length, ...attributes) {
    if (attributes.length === 0) {
        return null;
    }
    if (attributes.length === 1) {
        const format = vertexAttribFormatMap[attributes[0]];
        return new PBStructTypeInfo(null, 'packed', [
            {
                name: getVertexAttribName(format[0]),
                type: new PBArrayTypeInfo(PBPrimitiveTypeInfo.getCachedTypeInfo(format[1]), length)
            }
        ]);
    } else {
        const vertexType = new PBStructTypeInfo(null, 'packed', attributes.map((attrib)=>({
                name: getVertexAttribName(vertexAttribFormatMap[attrib][0]),
                type: PBPrimitiveTypeInfo.getCachedTypeInfo(vertexAttribFormatMap[attrib][1])
            })));
        return new PBStructTypeInfo(null, 'packed', [
            {
                name: 'value',
                type: new PBArrayTypeInfo(vertexType, length)
            }
        ]);
    }
}
/** @internal */ function semanticToAttrib(semantic) {
    switch(semantic){
        case VERTEX_ATTRIB_POSITION:
            return 'a_position';
        case VERTEX_ATTRIB_NORMAL:
            return 'a_normal';
        case VERTEX_ATTRIB_DIFFUSE:
            return 'a_diffuse';
        case VERTEX_ATTRIB_TANGENT:
            return 'a_tangent';
        case VERTEX_ATTRIB_TEXCOORD0:
            return 'a_texcoord0';
        case VERTEX_ATTRIB_TEXCOORD1:
            return 'a_texcoord1';
        case VERTEX_ATTRIB_TEXCOORD2:
            return 'a_texcoord2';
        case VERTEX_ATTRIB_TEXCOORD3:
            return 'a_texcoord3';
        case VERTEX_ATTRIB_TEXCOORD4:
            return 'a_texcoord4';
        case VERTEX_ATTRIB_TEXCOORD5:
            return 'a_texcoord5';
        case VERTEX_ATTRIB_TEXCOORD6:
            return 'a_texcoord6';
        case VERTEX_ATTRIB_TEXCOORD7:
            return 'a_texcoord7';
        case VERTEX_ATTRIB_BLEND_INDICES:
            return 'a_indices';
        case VERTEX_ATTRIB_BLEND_WEIGHT:
            return 'a_weight';
        default:
            return null;
    }
}
/**
 * Creates the default name for the type of given gpu object
 * @param obj - The gpu object
 * @returns The default name
 * @public
 */ function genDefaultName(obj) {
    if (obj.isTexture2D()) {
        return 'texture_2d';
    } else if (obj.isTexture2DArray()) {
        return 'texture_2darray';
    } else if (obj.isTexture3D()) {
        return 'texture_3d';
    } else if (obj.isTextureCube()) {
        return 'texture_cube';
    } else if (obj.isTextureVideo()) {
        return 'texture_video';
    } else if (obj.isBuffer()) {
        return 'buffer';
    } else if (obj.isFramebuffer()) {
        return 'framebuffer';
    } else if (obj.isProgram()) {
        return 'program';
    } else if (obj.isSampler()) {
        return 'sampler';
    } else if (obj.isVertexLayout()) {
        return 'vbo';
    } else {
        return 'unknown';
    }
}

/**
 * The vertex data class
 * @public
 */ class VertexData {
    /** @internal */ _vertexBuffers;
    /** @internal */ _indexBuffer;
    /** @internal */ _drawOffset;
    constructor(){
        this._vertexBuffers = [];
        for(let i = 0; i < MAX_VERTEX_ATTRIBUTES; i++){
            this._vertexBuffers.push(null);
        }
        this._indexBuffer = null;
        this._drawOffset = 0;
    }
    /**
   * Creates a new instance of VertexData by copying from this object
   * @returns New instance of VertexData
   */ clone() {
        const newVertexData = new VertexData();
        newVertexData._vertexBuffers = this._vertexBuffers.slice();
        newVertexData._indexBuffer = this._indexBuffer;
        newVertexData._drawOffset = this._drawOffset;
        return newVertexData;
    }
    /** Vertex buffer information list */ get vertexBuffers() {
        return this._vertexBuffers;
    }
    /** Index buffer */ get indexBuffer() {
        return this._indexBuffer;
    }
    /** Draw offset */ getDrawOffset() {
        return this._drawOffset;
    }
    setDrawOffset(offset) {
        if (offset !== this._drawOffset) {
            this._drawOffset = offset;
        }
    }
    /**
   * Gets the vertex buffer by specific vertex semantic
   * @param semantic - The vertex semantic
   * @returns Vertex buffer of the given semantic
   */ getVertexBuffer(semantic) {
        return this._vertexBuffers[getVertexAttribByName(semantic)]?.buffer ?? null;
    }
    /**
   * Gets the vertex buffer information by specific vertex semantic
   * @param semantic - The vertex semantic
   * @returns Vertex buffer information of the given semantic
   */ getVertexBufferInfo(semantic) {
        return this._vertexBuffers[getVertexAttribByName(semantic)] ?? null;
    }
    /**
   * Gets the index buffer
   * @returns The index buffer
   */ getIndexBuffer() {
        return this._indexBuffer || null;
    }
    /**
   * Sets a vertex buffer
   * @param buffer - The vertex buffer object
   * @param stepMode - Step mode of the buffer
   * @returns The buffer that was set
   */ setVertexBuffer(buffer, stepMode) {
        if (!buffer || !(buffer.usage & GPUResourceUsageFlags.BF_VERTEX)) {
            throw new Error('setVertexBuffer() failed: buffer is null or buffer has not Vertex usage flag');
        }
        stepMode = stepMode || 'vertex';
        const vertexType = buffer.structure.structMembers[0].type.elementType;
        if (vertexType.isStructType()) {
            let offset = 0;
            for (const attrib of vertexType.structMembers){
                const loc = getVertexAttribByName(attrib.name);
                this.internalSetVertexBuffer(loc, buffer, offset, stepMode);
                offset += attrib.size;
            }
        } else {
            const loc = getVertexAttribByName(buffer.structure.structMembers[0].name);
            this.internalSetVertexBuffer(loc, buffer, 0, stepMode);
        }
        return buffer;
    }
    /**
   * Removes a vertex buffer
   * @param buffer - Vertex buffer to be removed
   * @returns true if the buffer was successfully removed, otherwise false
   */ removeVertexBuffer(buffer) {
        let removed = false;
        for(let loc = 0; loc < this._vertexBuffers.length; loc++){
            const info = this._vertexBuffers[loc];
            const remove = info?.buffer === buffer;
            if (remove) {
                this._vertexBuffers[loc] = null;
                removed = true;
            }
        }
        return removed;
    }
    /**
   * Sets the index buffer
   * @param buffer - Index buffer to be set
   * @returns The index buffer that was set
   */ setIndexBuffer(buffer) {
        if (buffer !== this._indexBuffer) {
            this._indexBuffer = buffer || null;
        }
        return buffer;
    }
    /** @internal */ internalSetVertexBuffer(loc, buffer, offset, stepMode) {
        if (loc < 0 || loc >= MAX_VERTEX_ATTRIBUTES) {
            throw new Error(`setVertexBuffer() failed: location out of bounds: ${loc}`);
        }
        offset = Number(offset) || 0;
        stepMode = stepMode || 'vertex';
        const old = this._vertexBuffers[loc];
        if (!old || old.buffer !== buffer || old.offset !== offset || old.stepMode !== stepMode) {
            this._vertexBuffers[loc] = {
                buffer: buffer,
                offset: offset,
                type: getVertexBufferAttribType(buffer.structure, loc),
                stride: getVertexBufferStride(buffer.structure),
                drawOffset: 0,
                stepMode: stepMode
            };
            return buffer;
        }
        return null;
    }
}

/**
 * Abstract timer interface
 * @public
 */ /**
 * CPU timer class
 * @public
 */ class CPUTimer {
    /** @internal */ _cpuTimer;
    /** @internal */ _cpuStart;
    /** @internal */ _cpuTime;
    /** @internal */ _ended;
    constructor(){
        this._cpuTimer = window.performance || window.Date;
        this._cpuTime = null;
        this._ended = false;
    }
    now() {
        return this._cpuTimer.now();
    }
    begin() {
        this._cpuStart = this.now();
        this._cpuTime = null;
        this._ended = false;
    }
    end() {
        this._cpuTime = this.now() - this._cpuStart;
        this._ended = true;
    }
    ended() {
        return this._ended;
    }
    elapsed() {
        return this._cpuTime;
    }
}

/** @internal */ function expValueToString(deviceType, value) {
    if (typeof value === 'number' || typeof value === 'boolean' || Array.isArray(value)) {
        return `${value}`;
    } else {
        return value.$ast?.toString(deviceType);
    }
}
/** @internal */ function expValueTypeToString(deviceType, type) {
    return type?.toTypeName(deviceType);
}
/** @internal */ class PBError extends Error {
}
/** @internal */ class PBValueOutOfRange extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `value out of range: ${this.value}`;
    }
}
/** @internal */ class PBTypeCastError extends PBError {
    value;
    valueType;
    expectedType;
    constructor(value, valueType, expectedType){
        super();
        this.value = value;
        this.valueType = valueType;
        this.expectedType = expectedType;
    }
    getMessage(deviceType) {
        const valueStr = typeof this.value === 'string' ? this.value : expValueToString(deviceType, this.value);
        const valueTypeStr = typeof this.valueType === 'string' ? this.valueType : expValueTypeToString(deviceType, this.valueType);
        const expectedTypeStr = typeof this.expectedType === 'string' ? this.expectedType : expValueTypeToString(deviceType, this.expectedType);
        return `cannot convert '${valueStr}' of type '${valueTypeStr}' to type ${expectedTypeStr}`;
    }
}
/** @internal */ class PBParamLengthError extends PBError {
    func;
    constructor(func){
        super();
        this.func = func;
    }
    getMessage(deviceType) {
        return `wrong argument count for function '${this.func}'`;
    }
}
/** @internal */ class PBParamTypeError extends PBError {
    func;
    param;
    constructor(func, param){
        super();
        this.func = func;
        this.param = param || null;
    }
    getMessage(deviceType) {
        return `parameter type error for function '${this.func}': ${this.param}`;
    }
}
/** @internal */ class PBParamValueError extends PBError {
    func;
    param;
    reason;
    constructor(func, param, reason){
        super();
        this.func = func;
        this.param = param || null;
        this.reason = reason || null;
    }
    getMessage(deviceType) {
        return `invalid parameter value for function '${this.func}'${this.param ? ': ' + this.param : ''}${this.reason ? ': ' + this.reason : ''}}`;
    }
}
/** @internal */ class PBOverloadingMatchError extends PBError {
    func;
    constructor(func){
        super();
        this.func = func;
    }
    getMessage(deviceType) {
        return `No matched overloading found for function '${this.func}'`;
    }
}
/** @internal */ class PBReferenceValueRequired extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `'${expValueToString(deviceType, this.value)}' is not a reference type`;
    }
}
/** @internal */ class PBPointerValueRequired extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `'${expValueToString(deviceType, this.value)}' is not a pointer type`;
    }
}
/** @internal */ class PBDeviceNotSupport extends PBError {
    feature;
    constructor(feature){
        super();
        this.feature = feature;
    }
    getMessage(deviceType) {
        return `feature not support for ${deviceType} device: ${this.feature}`;
    }
}
/** @internal */ class PBNonScopedFunctionCall extends PBError {
    funcName;
    constructor(funcName){
        super();
        this.funcName = funcName;
    }
    getMessage(deviceType) {
        return `function call must be made inside a function scope: ${this.funcName}()`;
    }
}
/** @internal */ class PBASTError extends PBError {
    ast;
    text;
    constructor(ast, text){
        super();
        this.ast = ast;
        this.text = text;
    }
    getMessage(deviceType) {
        return `${this.text}: ${this.ast.toString(deviceType)}`;
    }
}
/** @internal */ class PBInternalError extends PBError {
    constructor(desc){
        super(desc);
    }
    getMessage(deviceType) {
        return `Internal error: ${this.message}`;
    }
}

const BuiltinInputStructNameVS = 'uu_VSInput';
const BuiltinOutputStructNameVS = 'uu_VSOutput';
const BuiltinInputStructNameFS = 'uu_FSInput';
const BuiltinOutputStructNameFS = 'uu_FSOutput';
const BuiltinInputStructNameCS = 'uu_CSInput';
const BuiltinOutputStructNameCS = 'uu_CSOutput';
const BuiltinInputStructInstanceNameVS = 'uu_VSInputCpy';
const BuiltinOutputStructInstanceNameVS = 'uu_VSOutputCpy';
const BuiltinInputStructInstanceNameFS = 'uu_FSInputCpy';
const BuiltinOutputStructInstanceNameFS = 'uu_FSOutputCpy';
const BuiltinInputStructInstanceNameCS = 'uu_CSInputCpy';
const BuiltinOutputStructInstanceNameCS = 'uu_CSOutputCpy';
var DeclareType;
(function(DeclareType) {
    DeclareType[DeclareType["DECLARE_TYPE_NONE"] = 0] = "DECLARE_TYPE_NONE";
    DeclareType[DeclareType["DECLARE_TYPE_IN"] = 1] = "DECLARE_TYPE_IN";
    DeclareType[DeclareType["DECLARE_TYPE_OUT"] = 2] = "DECLARE_TYPE_OUT";
    DeclareType[DeclareType["DECLARE_TYPE_WORKGROUP"] = 3] = "DECLARE_TYPE_WORKGROUP";
    DeclareType[DeclareType["DECLARE_TYPE_UNIFORM"] = 4] = "DECLARE_TYPE_UNIFORM";
    DeclareType[DeclareType["DECLARE_TYPE_STORAGE"] = 5] = "DECLARE_TYPE_STORAGE";
})(DeclareType || (DeclareType = {}));
var ShaderPrecisionType;
(function(ShaderPrecisionType) {
    ShaderPrecisionType[ShaderPrecisionType["NONE"] = 0] = "NONE";
    ShaderPrecisionType[ShaderPrecisionType["HIGH"] = 1] = "HIGH";
    ShaderPrecisionType[ShaderPrecisionType["MEDIUM"] = 2] = "MEDIUM";
    ShaderPrecisionType[ShaderPrecisionType["LOW"] = 3] = "LOW";
})(ShaderPrecisionType || (ShaderPrecisionType = {}));
/** @internal */ function getBuiltinInputStructInstanceName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinInputStructInstanceNameVS;
        case ShaderType.Fragment:
            return BuiltinInputStructInstanceNameFS;
        case ShaderType.Compute:
            return BuiltinInputStructInstanceNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinOutputStructInstanceName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinOutputStructInstanceNameVS;
        case ShaderType.Fragment:
            return BuiltinOutputStructInstanceNameFS;
        case ShaderType.Compute:
            return BuiltinOutputStructInstanceNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinInputStructName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinInputStructNameVS;
        case ShaderType.Fragment:
            return BuiltinInputStructNameFS;
        case ShaderType.Compute:
            return BuiltinInputStructNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinOutputStructName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinOutputStructNameVS;
        case ShaderType.Fragment:
            return BuiltinOutputStructNameFS;
        case ShaderType.Compute:
            return BuiltinOutputStructNameCS;
        default:
            return null;
    }
}
/** @internal */ function getTextureSampleType(type) {
    switch(type.textureType){
        case PBTextureType.TEX_1D:
        case PBTextureType.TEX_STORAGE_1D:
        case PBTextureType.TEX_2D:
        case PBTextureType.TEX_STORAGE_2D:
        case PBTextureType.TEX_2D_ARRAY:
        case PBTextureType.TEX_STORAGE_2D_ARRAY:
        case PBTextureType.TEX_3D:
        case PBTextureType.TEX_STORAGE_3D:
        case PBTextureType.TEX_CUBE:
        case PBTextureType.TEX_EXTERNAL:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4);
        case PBTextureType.TEX_DEPTH_2D_ARRAY:
        case PBTextureType.TEX_DEPTH_2D:
        case PBTextureType.TEX_DEPTH_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.F32);
        case PBTextureType.ITEX_2D_ARRAY:
        case PBTextureType.ITEX_1D:
        case PBTextureType.ITEX_2D:
        case PBTextureType.ITEX_3D:
        case PBTextureType.ITEX_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.I32);
        case PBTextureType.UTEX_2D_ARRAY:
        case PBTextureType.UTEX_1D:
        case PBTextureType.UTEX_2D:
        case PBTextureType.UTEX_3D:
        case PBTextureType.UTEX_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.U32);
        default:
            return null;
    }
}
/** @internal */ function genSamplerName(textureName, comparison) {
    return `ch_auto_sampler_${textureName}${comparison ? '_comparison' : ''}`;
}
/** @internal */ const builtinVariables = {
    webgl: {
        position: {
            name: 'gl_Position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'vertex'
        },
        pointSize: {
            name: 'gl_PointSize',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'vertex'
        },
        fragCoord: {
            name: 'gl_FragCoord',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'fragment'
        },
        frontFacing: {
            name: 'gl_FrontFacing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            stage: 'fragment'
        },
        fragDepth: {
            name: 'gl_FragDepthEXT',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            inOrOut: 'out',
            extension: 'GL_EXT_frag_depth',
            stage: 'fragment'
        }
    },
    webgl2: {
        vertexIndex: {
            name: 'gl_VertexID',
            semantic: 'vertex_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        instanceIndex: {
            name: 'gl_InstanceID',
            semantic: 'instance_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        position: {
            name: 'gl_Position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'vertex'
        },
        pointSize: {
            name: 'gl_PointSize',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'vertex'
        },
        fragCoord: {
            name: 'gl_FragCoord',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'fragment'
        },
        frontFacing: {
            name: 'gl_FrontFacing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            stage: 'fragment'
        },
        fragDepth: {
            name: 'gl_FragDepth',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'fragment'
        }
    },
    webgpu: {
        vertexIndex: {
            name: 'ch_builtin_vertexIndex',
            semantic: 'vertex_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        instanceIndex: {
            name: 'ch_builtin_instanceIndex',
            semantic: 'instance_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        position: {
            name: 'ch_builtin_position',
            semantic: 'position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            inOrOut: 'out',
            stage: 'vertex'
        },
        fragCoord: {
            name: 'ch_builtin_fragCoord',
            semantic: 'position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            inOrOut: 'in',
            stage: 'fragment'
        },
        frontFacing: {
            name: 'ch_builtin_frontFacing',
            semantic: 'front_facing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            inOrOut: 'in',
            stage: 'fragment'
        },
        fragDepth: {
            name: 'ch_builtin_fragDepth',
            semantic: 'frag_depth',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            inOrOut: 'out',
            stage: 'fragment'
        },
        localInvocationId: {
            name: 'ch_builtin_localInvocationId',
            semantic: 'local_invocation_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        globalInvocationId: {
            name: 'ch_builtin_globalInvocationId',
            semantic: 'global_invocation_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        workGroupId: {
            name: 'ch_builtin_workGroupId',
            semantic: 'workgroup_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        numWorkGroups: {
            name: 'ch_builtin_numWorkGroups',
            semantic: 'num_workgroups',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        sampleMaskIn: {
            name: 'ch_builtin_sampleMaskIn',
            semantic: 'sample_mask_in',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'fragment'
        },
        sampleMaskOut: {
            name: 'ch_builtin_sampleMaskOut',
            semantic: 'sample_mask_out',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'out',
            stage: 'fragment'
        },
        sampleIndex: {
            name: 'ch_builtin_sampleIndex',
            semantic: 'sample_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'fragment'
        }
    }
};
function toFixed(n) {
    return n % 1 === 0 ? n.toFixed(1) : String(n);
}
function toInt(n) {
    return String(n | 0);
}
function toUint(n) {
    return String(n >>> 0);
}
function unbracket(e) {
    e = e.trim();
    if (e[0] === '(' && e[e.length - 1] === ')') {
        let match = 0;
        for(let i = 1; i < e.length - 1; i++){
            if (e[i] === '(') {
                match++;
            } else if (e[i] === ')') {
                match--;
                if (match < 0) {
                    break;
                }
            }
        }
        if (match > 0) {
            throw new PBInternalError(`Invalid expression: ${e}`);
        } else if (match === 0) {
            return e.substring(1, e.length - 1);
        }
    }
    return e;
}
/** @internal */ class ShaderAST {
    isReference() {
        return false;
    }
    isPointer() {
        return !!this.getType()?.isPointerType();
    }
    getType() {
        return null;
    }
    toWebGL(indent, ctx) {
        return '';
    }
    toWebGL2(indent, ctx) {
        return '';
    }
    toWGSL(indent, ctx) {
        return '';
    }
    toString(deviceType) {
        return this.constructor.name;
    }
}
/** @internal */ class ASTExpression extends ShaderAST {
}
/** @internal */ class ASTFunctionParameter extends ASTExpression {
    /** @internal */ paramAST;
    /** @internal */ writable;
    constructor(init){
        super();
        this.paramAST = init;
        this.writable = false;
    }
    getType() {
        return this.paramAST.getType();
    }
    markWritable() {
        if (this.paramAST instanceof ASTPrimitive) {
            console.warn(`Write to non-output parameter ${this.paramAST.value.$str}`);
        }
        this.writable = true;
    }
    isWritable() {
        return this.writable;
    }
    getAddressSpace() {
        return this.paramAST.getAddressSpace();
    }
    isConstExp() {
        return this.paramAST.isConstExp();
    }
    isReference() {
        return this.paramAST.isReference();
    }
    toWebGL(indent, ctx) {
        return this.paramAST.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.paramAST.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.paramAST.toWGSL(indent, ctx);
    }
}
/** @internal */ class ASTScope extends ShaderAST {
    statements;
    constructor(){
        super();
        this.statements = [];
    }
    toWebGL(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>stmt.toWebGL(indent, ctx)).join('');
    }
    toWebGL2(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>stmt.toWebGL2(indent, ctx)).join('');
    }
    toWGSL(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>{
            if (stmt instanceof ASTCallFunction) {
                if (!stmt.getType().isVoidType()) {
                    return `${indent}_ = ${stmt.toWGSL('', ctx)}`;
                }
            }
            return stmt.toWGSL(indent, ctx);
        }).join('');
    }
}
/** @internal */ class ASTNakedScope extends ASTScope {
    toWebGL(indent, ctx) {
        return `${indent}{\n${super.toWebGL(indent + ' ', ctx)}${indent}}\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}{\n${super.toWebGL2(indent + ' ', ctx)}${indent}}\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}{\n${super.toWGSL(indent + ' ', ctx)}${indent}}\n`;
    }
}
/** @internal */ class ASTGlobalScope extends ASTScope {
    /** @internal */ uniforms;
    constructor(){
        super();
        this.uniforms = [];
    }
    findFunctions(name) {
        const result = [];
        for (const stmt of this.statements){
            if (stmt instanceof ASTFunction && stmt.name === name) {
                result.push(stmt);
            }
        }
        return result;
    }
    toWebGL(indent, ctx) {
        // TODO: precision
        const precisions = `${indent}precision highp float;\n${indent}precision highp int;\n`;
        const version = `${indent}#version 100\n`;
        const body = ctx.types.map((val)=>val.toWebGL(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWebGL(indent, ctx)).join('') + ctx.inputs.map((input)=>input.toWebGL(indent, ctx)).join('') + ctx.outputs.map((output)=>output.toWebGL(indent, ctx)).join('') + super.toWebGL(indent, ctx);
        for (const k of ctx.builtins){
            const info = builtinVariables.webgl[k];
            if (info.extension) {
                ctx.extensions.add(info.extension);
            }
        }
        const extensions = [
            ...ctx.extensions
        ].map((s)=>`${indent}#extension ${s}: enable\n`).join('');
        const defines = ctx.defines.join('');
        return version + extensions + precisions + defines + body;
    }
    toWebGL2(indent, ctx) {
        const precisions = `${indent}precision highp float;\n${indent}precision highp int;\n`;
        const version = `${indent}#version 300 es\n`;
        const body = ctx.types.map((val)=>val.toWebGL2(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWebGL2(indent, ctx)).join('') + ctx.inputs.map((input)=>input.toWebGL2(indent, ctx)).join('') + ctx.outputs.map((output)=>output.toWebGL2(indent, ctx)).join('') + super.toWebGL2(indent, ctx);
        for (const k of ctx.builtins){
            const info = builtinVariables.webgl2[k];
            if (info.extension) {
                ctx.extensions.add(info.extension);
            }
        }
        const extensions = [
            ...ctx.extensions
        ].map((s)=>`${indent}#extension ${s}: enable\n`).join('');
        const defines = ctx.defines.join('');
        return version + extensions + precisions + defines + body;
    }
    toWGSL(indent, ctx) {
        const structNames = ctx.type === ShaderType.Vertex ? [
            BuiltinInputStructNameVS,
            BuiltinOutputStructNameVS
        ] : ctx.type === ShaderType.Fragment ? [
            BuiltinInputStructNameFS,
            BuiltinOutputStructNameFS
        ] : [
            BuiltinInputStructNameCS
        ];
        const usedBuiltins = [];
        for (const k of ctx.builtins){
            usedBuiltins.push(builtinVariables.webgpu[k].name);
        }
        const allBuiltins = Object.keys(builtinVariables.webgpu).map((val)=>builtinVariables.webgpu[val].name);
        for (const type of ctx.types){
            if (type instanceof ASTStructDefine && structNames.indexOf(type.type.structName) >= 0) {
                for(let i = type.type.structMembers.length - 1; i >= 0; i--){
                    const member = type.type.structMembers[i];
                    if (allBuiltins.indexOf(member.name) >= 0 && usedBuiltins.indexOf(member.name) < 0) {
                        type.type.structMembers.splice(i, 1);
                        type.prefix.splice(i, 1);
                    }
                }
            }
        }
        ctx.types = ctx.types.filter((val)=>!(val instanceof ASTStructDefine) || val.type.structMembers.length > 0);
        return ctx.types.map((val)=>val.toWGSL(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWGSL(indent, ctx)).join('') + super.toWGSL(indent, ctx);
    }
}
/** @internal */ class ASTPrimitive extends ASTExpression {
    /** @internal */ value;
    /** @internal */ ref;
    /** @internal */ writable;
    /** @internal */ constExp;
    constructor(value){
        super();
        this.value = value;
        this.ref = null;
        this.writable = false;
        this.constExp = false;
    }
    get name() {
        return this.value.$str;
    }
    isReference() {
        return true;
    }
    isConstExp() {
        return this.constExp;
    }
    markWritable() {
        this.writable = true;
        this.constExp = false;
        if (this.ref) {
            this.ref.markWritable();
        }
    }
    isWritable() {
        const type = this.getType();
        return this.writable || type.isAtomicI32() || type.isAtomicU32() || type.isStructType() && type.isWritable();
    }
    getAddressSpace() {
        switch(this.value.$declareType){
            case DeclareType.DECLARE_TYPE_UNIFORM:
                return PBAddressSpace.UNIFORM;
            case DeclareType.DECLARE_TYPE_STORAGE:
                return PBAddressSpace.STORAGE;
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
                return null;
            default:
                return this.value.$global ? PBAddressSpace.PRIVATE : PBAddressSpace.FUNCTION;
        }
    }
    getType() {
        return this.value.$typeinfo;
    }
    toWebGL(indent, ctx) {
        return this.name;
    }
    toWebGL2(indent, ctx) {
        return this.name;
    }
    toWGSL(indent, ctx) {
        if (this.value.$declareType === DeclareType.DECLARE_TYPE_IN) {
            const structName = getBuiltinInputStructInstanceName(ctx.type);
            return ctx.global[structName][this.name].$ast.toWGSL(indent, ctx);
        } else if (this.value.$declareType === DeclareType.DECLARE_TYPE_OUT) {
            const structName = getBuiltinOutputStructInstanceName(ctx.type);
            return ctx.global[structName][this.name].$ast.toWGSL(indent, ctx);
        } else {
            return this.name;
        }
    }
    toString(deviceType) {
        return this.name;
    }
}
/** @internal */ class ASTLValue extends ShaderAST {
}
/** @internal */ class ASTLValueScalar extends ASTLValue {
    /** @internal */ value;
    constructor(value){
        super();
        if (value.getAddressSpace() === PBAddressSpace.UNIFORM) {
            throw new PBASTError(value, 'cannot assign to uniform variable');
        }
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        return this.value.getType();
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isReference() {
        return this.value.isReference();
    }
    toWebGL(indent, ctx) {
        return this.value.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.value.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.value.toWGSL(indent, ctx);
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTLValueHash extends ASTLValue {
    /** @internal */ scope;
    /** @internal */ field;
    /** @internal */ type;
    constructor(scope, field, type){
        super();
        this.scope = scope;
        this.field = field;
        this.type = type;
    }
    getType() {
        return this.type;
    }
    markWritable() {
        this.scope.markWritable();
    }
    isWritable() {
        return this.scope.isWritable();
    }
    isReference() {
        return this.scope.isReference();
    }
    toWebGL(indent, ctx) {
        return `${this.scope.toWebGL(indent, ctx)}.${this.field}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.scope.toWebGL2(indent, ctx)}.${this.field}`;
    }
    toWGSL(indent, ctx) {
        const scope = this.scope.isPointer() ? new ASTReferenceOf(this.scope) : this.scope;
        return `${scope.toWGSL(indent, ctx)}.${this.field}`;
    }
    toString(deviceType) {
        const scope = this.scope.isPointer() ? new ASTReferenceOf(this.scope) : this.scope;
        return `${scope.toString(deviceType)}.${this.field}`;
    }
}
/** @internal */ class ASTLValueArray extends ASTLValue {
    /** @internal */ value;
    /** @internal */ index;
    /** @internal */ type;
    constructor(value, index, type){
        super();
        this.value = value;
        this.index = index;
        this.type = type;
        if (this.index instanceof ASTCallFunction) {
            this.index.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isReference() {
        return this.value.isReference();
    }
    toWebGL(indent, ctx) {
        return `${this.value.toWebGL(indent, ctx)}[${this.index.toWebGL(indent, ctx)}]`;
    }
    toWebGL2(indent, ctx) {
        return `${this.value.toWebGL2(indent, ctx)}[${this.index.toWebGL2(indent, ctx)}]`;
    }
    toWGSL(indent, ctx) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${value.toWGSL(indent, ctx)}[${this.index.toWGSL(indent, ctx)}]`;
    }
    toString(deviceType) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${value.toString(deviceType)}[${this.index.toString(deviceType)}]`;
    }
}
/** @internal */ class ASTLValueDeclare extends ASTLValue {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        this.value.constExp = true;
    }
    getType() {
        return this.value.getType();
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isReference() {
        return true;
    }
    toWebGL(indent, ctx) {
        let prefix = '';
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                prefix = this.value.constExp && !this.value.isWritable() && !this.getType().isStructType() ? 'const ' : '';
                break;
        }
        {
            return `${prefix}${this.getType().toTypeName('webgl', this.value.name)}`;
        }
    }
    toWebGL2(indent, ctx) {
        let prefix = '';
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                prefix = this.value.constExp && !this.value.isWritable() && !this.getType().isStructType() ? 'const ' : '';
                break;
        }
        {
            return `${prefix}${this.getType().toTypeName('webgl2', this.value.name)}`;
        }
    }
    toWGSL(indent, ctx) {
        let prefix;
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                {
                    const addressSpace = this.value.getAddressSpace();
                    const readonly = this.getType().isPointerType() || !this.value.isWritable() && (addressSpace === PBAddressSpace.PRIVATE || addressSpace === PBAddressSpace.FUNCTION);
                    const moduleScope = addressSpace === PBAddressSpace.PRIVATE;
                    const storageAccessMode = addressSpace === PBAddressSpace.STORAGE && this.value.isWritable() ? ', read_write' : '';
                    const decorator = addressSpace !== PBAddressSpace.FUNCTION ? `<${addressSpace}${storageAccessMode}>` : '';
                    prefix = readonly ? moduleScope ? 'const ' : 'let ' : `var${decorator} `;
                    break;
                }
        }
        {
            // const decl = this.value.value.$global ? this.getType().toTypeName('webgpu', this.value.name) : this.value.name;
            const type = this.getType();
            if (type.isPointerType() && (this.value.isWritable() || this.value.ref.isWritable())) {
                type.writable = true;
            }
            const decl = type.toTypeName('webgpu', this.value.name);
            return `${prefix}${decl}`;
        }
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTShaderExpConstructor extends ASTExpression {
    /** @internal */ type;
    /** @internal */ args;
    /** @internal */ constExp;
    constructor(type, args){
        super();
        this.type = type;
        this.args = args;
        this.constExp = true;
        for (const arg of args){
            if (arg === null || arg === undefined) {
                throw new Error('invalid constructor argument');
            }
            if (arg instanceof ASTCallFunction) {
                arg.isStatement = false;
            }
            this.constExp &&= !(arg instanceof ASTExpression) || arg.isConstExp();
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.constExp;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        console.assert(!this.type.isArrayType(), 'array constructor not supported in webgl1 device');
        console.assert(this.type.isConstructible(), `type '${this.type.toTypeName('webgl')}' is not constructible`);
        const overloads = this.type.getConstructorOverloads('webgl');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWebGL(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgl')}`);
    }
    toWebGL2(indent, ctx) {
        console.assert(this.type.isConstructible(), `type '${this.type.toTypeName('webgl2')}' is not constructible`, true);
        const overloads = this.type.getConstructorOverloads('webgl2');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWebGL2(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgl2')}`);
    }
    toWGSL(indent, ctx) {
        /*
    console.assert(
      this.type.isConstructible(),
      `type '${this.type.toTypeName('webgpu')}' is not constructible`,
      true
    );
    */ const overloads = this.type.getConstructorOverloads('webgpu');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWGSL(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgpu')}`);
    }
    toString(deviceType) {
        return 'constructor';
    }
}
/** @internal */ class ASTScalar extends ASTExpression {
    /** @internal */ value;
    /** @internal */ type;
    constructor(value, type){
        super();
        this.value = value;
        this.type = type;
        if (typeof value === 'number') {
            if (type.primitiveType === PBPrimitiveType.BOOL) {
                throw new PBTypeCastError(value, typeof value, type);
            }
            if (type.primitiveType === PBPrimitiveType.I32 && (!Number.isInteger(value) || value < 0x80000000 >> 0 || value > 0xffffffff)) {
                throw new PBTypeCastError(value, typeof value, type);
            }
            if (value < 0 && type.primitiveType === PBPrimitiveType.U32 && (!Number.isInteger(value) || value < 0 || value > 0xffffffff)) {
                throw new PBTypeCastError(value, typeof value, type);
            }
        } else if (type.primitiveType !== PBPrimitiveType.BOOL) {
            throw new PBTypeCastError(value, typeof value, type);
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return true;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return toUint(this.value);
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toWebGL2(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return `${toUint(this.value)}u`;
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toWGSL(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return `${toUint(this.value)}u`;
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toString(deviceType) {
        return `${this.value}`;
    }
}
/** @internal */ class ASTHash extends ASTExpression {
    /** @internal */ source;
    /** @internal */ field;
    /** @internal */ type;
    constructor(source, field, type){
        super();
        this.source = source;
        this.field = field;
        this.type = type;
        if (this.source instanceof ASTCallFunction) {
            this.source.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    isReference() {
        return this.source.isReference();
    }
    isConstExp() {
        return this.source.isConstExp();
    }
    markWritable() {
        this.source.markWritable();
    }
    isWritable() {
        return this.source.isWritable();
    }
    getAddressSpace() {
        return this.source.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        return `${this.source.toWebGL(indent, ctx)}.${this.field}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.source.toWebGL2(indent, ctx)}.${this.field}`;
    }
    toWGSL(indent, ctx) {
        const source = this.source.isPointer() ? new ASTReferenceOf(this.source) : this.source;
        return `${source.toWGSL(indent, ctx)}.${this.field}`;
    }
    toString(deviceType) {
        const source = this.source.isPointer() ? new ASTReferenceOf(this.source) : this.source;
        return `${source.toString(deviceType)}.${this.field}`;
    }
}
/** @internal */ class ASTCast extends ASTExpression {
    /** @internal */ sourceValue;
    /** @internal */ castType;
    constructor(source, type){
        super();
        this.sourceValue = source;
        this.castType = type;
        if (this.sourceValue instanceof ASTCallFunction) {
            this.sourceValue.isStatement = false;
        }
    }
    getType() {
        return this.castType;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.sourceValue.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgl')}(${unbracket(this.sourceValue.toWebGL(indent, ctx))})`;
        } else {
            return this.sourceValue.toWebGL(indent, ctx);
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgl2')}(${unbracket(this.sourceValue.toWebGL2(indent, ctx))})`;
        } else {
            return this.sourceValue.toWebGL2(indent, ctx);
        }
    }
    toWGSL(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgpu')}(${unbracket(this.sourceValue.toWGSL(indent, ctx))})`;
        } else {
            return this.sourceValue.toWGSL(indent, ctx);
        }
    }
    toString(deviceType) {
        return `${this.castType.toTypeName(deviceType)}(${unbracket(this.sourceValue.toString(deviceType))})`;
    }
}
/** @internal */ class ASTAddressOf extends ASTExpression {
    /** @internal */ value;
    /** @internal */ type;
    constructor(value){
        super();
        console.assert(value.isReference(), 'no pointer type for non-reference values', true);
        this.value = value;
        this.type = new PBPointerTypeInfo(value.getType(), value.getAddressSpace());
    }
    getType() {
        return this.type;
    }
    isConstExp() {
        return false;
    }
    markWritable() {
        const addressSpace = this.value.getAddressSpace();
        if (addressSpace === PBAddressSpace.UNIFORM) {
            throw new PBASTError(this.value, 'uniforms are not writable');
        }
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    getAddressSpace() {
        return this.value.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        throw new Error('GLSL does not support pointer type');
    }
    toWebGL2(indent, ctx) {
        throw new Error('GLSL does not support pointer type');
    }
    toWGSL(indent, ctx) {
        const ast = this.value instanceof ASTFunctionParameter ? this.value.paramAST : this.value;
        return ast instanceof ASTReferenceOf ? ast.value.toWGSL(indent, ctx) : `(&${ast.toWGSL(indent, ctx)})`;
    }
    toString(deviceType) {
        const ast = this.value instanceof ASTFunctionParameter ? this.value.paramAST : this.value;
        return ast instanceof ASTReferenceOf ? ast.value.toString(deviceType) : `(&${ast.toString(deviceType)})`;
    }
}
/** @internal */ class ASTReferenceOf extends ASTExpression {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        const type = this.value.getType();
        return type.isPointerType() ? type.pointerType : type;
    }
    isReference() {
        return true;
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isConstExp() {
        return false;
    }
    getAddressSpace() {
        return this.value instanceof ASTExpression ? this.value.getAddressSpace() : null;
    }
    toWebGL(indent, ctx) {
        return this.value.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.value.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.value.getType().isPointerType() ? `(*${this.value.toWGSL(indent, ctx)})` : this.value.toWGSL(indent, ctx);
    }
    toString(deviceType) {
        return `*${this.value.toString(deviceType)}`;
    }
}
/** @internal */ class ASTUnaryFunc extends ASTExpression {
    /** @internal */ value;
    /** @internal */ op;
    /** @internal */ type;
    constructor(value, op, type){
        super();
        this.value = value;
        this.op = op;
        this.type = type;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.value.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `${this.op}${this.value.toWebGL(indent, ctx)}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.op}${this.value.toWebGL2(indent, ctx)}`;
    }
    toWGSL(indent, ctx) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${this.op}${value.toWGSL(indent, ctx)}`;
    }
    toString(deviceType) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${this.op}${value.toString(deviceType)}`;
    }
}
/** @internal */ class ASTBinaryFunc extends ASTExpression {
    /** @internal */ left;
    /** @internal */ right;
    /** @internal */ type;
    /** @internal */ op;
    constructor(left, right, op, type){
        super();
        this.left = left;
        this.right = right;
        this.op = op;
        this.type = type;
        if (this.left instanceof ASTCallFunction) {
            this.left.isStatement = false;
        }
        if (this.right instanceof ASTCallFunction) {
            this.right.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.left.isConstExp() && this.right.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `(${this.left.toWebGL(indent, ctx)} ${this.op} ${this.right.toWebGL(indent, ctx)})`;
    }
    toWebGL2(indent, ctx) {
        return `(${this.left.toWebGL2(indent, ctx)} ${this.op} ${this.right.toWebGL2(indent, ctx)})`;
    }
    toWGSL(indent, ctx) {
        const left = this.left.isPointer() ? new ASTReferenceOf(this.left) : this.left;
        const right = this.right.isPointer() ? new ASTReferenceOf(this.right) : this.right;
        return `(${left.toWGSL(indent, ctx)} ${this.op} ${right.toWGSL(indent, ctx)})`;
    }
    toString(deviceType) {
        const left = this.left.isPointer() ? new ASTReferenceOf(this.left) : this.left;
        const right = this.right.isPointer() ? new ASTReferenceOf(this.right) : this.right;
        return `(${left.toString(deviceType)} ${this.op} ${right.toString(deviceType)})`;
    }
}
/** @internal */ class ASTArrayIndex extends ASTExpression {
    /** @internal */ source;
    /** @internal */ index;
    /** @internal */ type;
    constructor(source, index, type){
        super();
        this.source = source;
        this.index = index;
        this.type = type;
        if (this.source instanceof ASTCallFunction) {
            this.source.isStatement = false;
        }
        if (this.index instanceof ASTCallFunction) {
            this.index.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    isReference() {
        return this.source.isReference();
    }
    markWritable() {
        this.source.markWritable();
    }
    isWritable() {
        return this.source.isWritable();
    }
    isConstExp() {
        return this.source.isConstExp() && this.index.isConstExp();
    }
    getAddressSpace() {
        return this.source.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        return `${this.source.toWebGL(indent, ctx)}[${unbracket(this.index.toWebGL(indent, ctx))}]`;
    }
    toWebGL2(indent, ctx) {
        return `${this.source.toWebGL2(indent, ctx)}[${unbracket(this.index.toWebGL2(indent, ctx))}]`;
    }
    toWGSL(indent, ctx) {
        return `${this.source.toWGSL(indent, ctx)}[${unbracket(this.index.toWGSL(indent, ctx))}]`;
    }
    toString(deviceType) {
        return `${this.source.toString(deviceType)}[${unbracket(this.index.toString(deviceType))}]`;
    }
}
/** @internal */ class ASTTouch extends ShaderAST {
    /** @internal */ value;
    constructor(value){
        super();
        if (value.getType().isVoidType()) {
            throw new Error('can not touch void type');
        }
        if (value instanceof ASTCallFunction) {
            value.isStatement = false;
        }
        this.value = value;
    }
    toWebGL(indent, ctx) {
        return `${indent}${this.value.toWebGL('', ctx)};\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}${this.value.toWebGL2('', ctx)};\n`;
    }
    toWGSL(indent, ctx) {
        if (!this.value.getType().isVoidType()) {
            return `${indent}_ = ${this.value.toWGSL('', ctx)};\n`;
        } else {
            return `${indent}${this.value.toWGSL('', ctx)};\n`;
        }
    }
}
/** @internal */ class ASTSelect extends ASTExpression {
    /** @internal */ condition;
    /** @internal */ first;
    /** @internal */ second;
    /** @internal */ type;
    constructor(condition, first, second){
        super();
        this.condition = condition instanceof ASTExpression ? condition : new ASTScalar(condition, typeBool);
        let firstType = null;
        let secondType = null;
        if (first instanceof ASTExpression) {
            firstType = first.getType();
            this.first = first;
            if (first instanceof ASTCallFunction) {
                first.isStatement = false;
            }
        } else if (typeof first === 'number') {
            if (!Number.isInteger(first)) {
                this.first = new ASTScalar(first, typeF32$1);
                firstType = typeF32$1;
            }
        } else if (typeof first === 'boolean') {
            this.first = new ASTScalar(first, typeBool);
            firstType = typeBool;
        } else {
            throw new Error('select: invalid first value');
        }
        if (second instanceof ASTExpression) {
            secondType = second.getType();
            this.second = second;
            if (second instanceof ASTCallFunction) {
                second.isStatement = false;
            }
        } else if (typeof second === 'number') {
            if (!Number.isInteger(second)) {
                this.second = new ASTScalar(second, typeF32$1);
                secondType = typeF32$1;
            }
        } else if (typeof second === 'boolean') {
            this.second = new ASTScalar(second, typeBool);
            secondType = typeBool;
        } else {
            throw new Error('select: invalid second value');
        }
        if (!firstType && !secondType) {
            throw new Error('select: cannot determine the value types');
        }
        if (firstType && secondType) {
            if (!firstType.isCompatibleType(secondType)) {
                throw new Error('select: first value and second value must be the same type');
            } else {
                this.type = firstType;
            }
        } else if (!firstType) {
            if (secondType.typeId === typeF32$1.typeId) {
                this.first = new ASTScalar(first, typeF32$1);
            } else if (secondType.typeId === typeI32$1.typeId) {
                this.first = new ASTScalar(first, typeI32$1);
            } else if (secondType.typeId === typeU32$2.typeId) {
                this.first = new ASTScalar(first, typeU32$2);
            } else {
                throw new Error('select: invalid type of the first value');
            }
            this.type = secondType;
        } else {
            if (firstType.typeId === typeF32$1.typeId) {
                this.second = new ASTScalar(second, typeF32$1);
            } else if (firstType.typeId === typeI32$1.typeId) {
                this.second = new ASTScalar(second, typeI32$1);
            } else if (firstType.typeId === typeU32$2.typeId) {
                this.second = new ASTScalar(second, typeU32$2);
            } else {
                throw new Error('select: invalid type of the second value');
            }
            this.type = firstType;
        }
    }
    getType() {
        return this.type;
    }
    isConstExp() {
        return false;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `${indent}(${this.condition.toWebGL('', ctx)} ? ${this.first.toWebGL('', ctx)} : ${this.second.toWebGL('', ctx)})`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}(${this.condition.toWebGL2('', ctx)} ? ${this.first.toWebGL2('', ctx)} : ${this.second.toWebGL2('', ctx)})`;
    }
    toWGSL(indent, ctx) {
        return `${indent}select(${this.second.toWGSL('', ctx)}, ${this.first.toWGSL('', ctx)}, ${this.condition.toWGSL('', ctx)})`;
    //return `${indent}${this.condition.toWGSL('', ctx)} ? ${this.first.toWGSL('', ctx)} : ${this.second.toWGSL('', ctx)}`;
    }
}
/** @internal */ class ASTAssignment extends ShaderAST {
    /** @internal */ lvalue;
    /** @internal */ rvalue;
    constructor(lvalue, rvalue){
        super();
        if (!lvalue.isReference()) {
            throw new Error('assignment: l-value required');
        }
        this.lvalue = lvalue;
        this.rvalue = rvalue;
        if (!(this.lvalue instanceof ASTLValueDeclare)) {
            if (this.lvalue.getType().isPointerType()) {
                throw new PBASTError(this.lvalue, 'cannot assign to read-only variable');
            }
            this.lvalue.markWritable();
        } else if (this.lvalue.getType().isPointerType()) {
            if (this.rvalue instanceof ASTPrimitive) {
                this.lvalue.value.ref = this.rvalue.ref;
            } else if (this.rvalue instanceof ASTAddressOf) {
                this.lvalue.value.ref = this.rvalue.value;
            } else {
                throw new PBASTError(this.lvalue, 'invalid pointer assignment');
            }
        } else if (this.rvalue instanceof ASTExpression) {
            this.lvalue.value.constExp = this.rvalue.isConstExp();
        }
        if (this.rvalue instanceof ASTCallFunction) {
            this.rvalue.isStatement = false;
        }
    }
    getType() {
        return null;
    }
    toWebGL(indent, ctx) {
        let rhs = null;
        const ltype = this.lvalue.getType();
        const rtype = this.checkScalarType(this.rvalue, ltype);
        if (!ltype.isCompatibleType(rtype)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgl') : `${this.rvalue}`, rtype, ltype);
        }
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWebGL(indent, ctx));
        }
        if (this.lvalue instanceof ASTLValueDeclare) {
            this.lvalue.value.constExp &&= !(this.rvalue instanceof ASTExpression) || this.rvalue.isConstExp();
        }
        return `${indent}${this.lvalue.toWebGL(indent, ctx)} = ${rhs};\n`;
    }
    toWebGL2(indent, ctx) {
        let rhs = null;
        const ltype = this.lvalue.getType();
        const rtype = this.checkScalarType(this.rvalue, ltype);
        if (!ltype.isCompatibleType(rtype)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgl2') : `${this.rvalue}`, rtype, ltype);
        }
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWebGL2(indent, ctx));
        }
        if (this.lvalue instanceof ASTLValueDeclare) {
            this.lvalue.value.constExp &&= !(this.rvalue instanceof ASTExpression) || this.rvalue.isConstExp();
        }
        return `${indent}${this.lvalue.toWebGL2(indent, ctx)} = ${rhs};\n`;
    }
    toWGSL(indent, ctx) {
        const ltype = this.lvalue.getType();
        const [valueTypeLeft, lvalueIsPtr] = ltype.isPointerType() ? [
            ltype.pointerType,
            true
        ] : [
            ltype,
            false
        ];
        const rtype = this.checkScalarType(this.rvalue, valueTypeLeft);
        const rvalueIsPtr = rtype && rtype.isPointerType();
        const valueTypeRight = rvalueIsPtr ? rtype.pointerType : rtype;
        if (!valueTypeLeft.isCompatibleType(valueTypeRight)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgpu') : `${this.rvalue}`, rtype, ltype);
        }
        if (this.lvalue instanceof ASTLValueScalar || this.lvalue instanceof ASTLValueDeclare) {
            const structName = valueTypeLeft.isStructType() ? valueTypeLeft.structName : null;
            if (structName && ctx.types.findIndex((val)=>val instanceof ASTStructDefine && val.type.structName === structName) < 0) {
                return '';
            }
        }
        let rhs;
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWGSL(indent, ctx));
        }
        const name = this.lvalue.toWGSL(indent, ctx);
        if (lvalueIsPtr && !rvalueIsPtr) {
            if (this.lvalue instanceof ASTLValueDeclare) {
                throw new Error(`rvalue must be pointer type: ${rhs}`);
            } else {
                return `${indent}*(${name}) = ${rhs};\n`;
            }
        } else if (rvalueIsPtr && !lvalueIsPtr) {
            return `${indent}${name} = *(${rhs});\n`;
        } else {
            return `${indent}${name} = ${rhs};\n`;
        }
    }
    checkScalarType(value, targetType) {
        if (value instanceof ASTExpression) {
            return value.getType();
        }
        const isBool = typeof value === 'boolean';
        const isInt = typeof value === 'number' && Number.isInteger(value) && value >= 0x80000000 >> 0 && value <= 0x7fffffff;
        const isUint = typeof value === 'number' && Number.isInteger(value) && value >= 0 && value <= 0xffffffff;
        const isFloat = typeof value === 'number';
        if (targetType.isPrimitiveType()) {
            switch(targetType.primitiveType){
                case PBPrimitiveType.BOOL:
                    return isBool ? targetType : isInt ? typeI32$1 : isUint ? typeU32$2 : typeF32$1;
                case PBPrimitiveType.F32:
                    return isFloat ? targetType : typeBool;
                case PBPrimitiveType.I32:
                    return isInt ? targetType : isBool ? typeBool : isUint ? typeU32$2 : typeF32$1;
                case PBPrimitiveType.U32:
                    return isUint ? targetType : isBool ? typeBool : isInt ? typeI32$1 : typeF32$1;
                default:
                    return null;
            }
        } else {
            return isBool ? typeBool : isInt ? typeI32$1 : isUint ? typeU32$2 : typeF32$1;
        }
    }
}
/** @internal */ class ASTDiscard extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}discard;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}discard;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}discard;\n`;
    }
}
/** @internal */ class ASTBreak extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}break;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}break;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}break;\n`;
    }
}
/** @internal */ class ASTContinue extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}continue;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}continue;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}continue;\n`;
    }
}
/** @internal */ class ASTReturn extends ShaderAST {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWebGL(indent, ctx))};\n` : `${indent}return;\n`;
    }
    toWebGL2(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWebGL2(indent, ctx))};\n` : `${indent}return;\n`;
    }
    toWGSL(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWGSL(indent, ctx))};\n` : `${indent}return;\n`;
    }
}
/** @internal */ class ASTCallFunction extends ASTExpression {
    /** @internal */ name;
    /** @internal */ args;
    /** @internal */ retType;
    /** @internal */ func;
    /** @internal */ isStatement;
    constructor(name, args, func, deviceType, retType){
        super();
        this.name = name;
        this.args = args;
        this.retType = func?.returnType ?? retType ?? typeVoid;
        this.func = func;
        this.isStatement = true;
        if (func) {
            if (func.funcType.argTypes.length !== this.args.length) {
                throw new PBInternalError(`ASTCallFunction(): number of parameters mismatch`);
            }
            for(let i = 0; i < this.args.length; i++){
                const funcArg = func.funcType.argTypes[i];
                if (funcArg.byRef) {
                    if (deviceType === 'webgpu') {
                        const argAddressSpace = args[i].getAddressSpace();
                        if (argAddressSpace !== PBAddressSpace.FUNCTION && argAddressSpace !== PBAddressSpace.PRIVATE) {
                            throw new PBParamTypeError(name, 'pointer type of function parameter must be function or private');
                        }
                        const argType = funcArg.type;
                        if (!argType.isPointerType()) {
                            throw new PBInternalError(`ASTCallFunction(): invalid reference type`);
                        }
                        if (argType.addressSpace === PBAddressSpace.UNKNOWN) {
                            argType.addressSpace = argAddressSpace;
                        } else if (argType.addressSpace !== argAddressSpace) {
                            throw new PBParamTypeError(name, `invalid pointer parameter address space '${argAddressSpace}', should be '${argType.addressSpace}`);
                        }
                    }
                    this.args[i].markWritable();
                }
            }
        }
        for (const arg of this.args){
            if (arg instanceof ASTCallFunction) {
                arg.isStatement = false;
            }
        }
    }
    getType() {
        return this.retType;
    }
    isConstExp() {
        return false;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        if (this.name === 'dFdx' || this.name === 'dFdy' || this.name === 'fwidth') {
            ctx.extensions.add('GL_OES_standard_derivatives');
        } else if (this.name === 'texture2DLodEXT' || this.name === 'texture2DProjLodEXT' || this.name === 'textureCubeLodEXT' || this.name === 'texture2DGradEXT' || this.name === 'texture2DProjGradEXT' || this.name === 'textureCubeGradEXT') {
            ctx.extensions.add('GL_EXT_shader_texture_lod');
        }
        const args = this.args.map((arg)=>unbracket(arg.toWebGL(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toWebGL2(indent, ctx) {
        const args = this.args.map((arg)=>unbracket(arg.toWebGL2(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toWGSL(indent, ctx) {
        let thisArgs = this.args.filter((val)=>{
            const type = val.getType();
            if (val instanceof ASTPrimitive && type.isStructType() && ctx.types.findIndex((t)=>t instanceof ASTStructDefine && t.type.structName === type.structName) < 0) {
                return false;
            }
            return true;
        });
        if (this.func) {
            let argsNew;
            const convertedArgs = convertArgs(thisArgs, this.func.funcType);
            if (convertedArgs) {
                argsNew = convertedArgs.args;
            }
            if (!argsNew) {
                throw new Error(`no matching overloading found for function '${this.name}'`);
            }
            thisArgs = argsNew;
        }
        const args = thisArgs.map((arg)=>unbracket(arg.toWGSL(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toString(deviceType) {
        return `${this.name}(...)`;
    }
}
/** @internal */ class ASTDeclareVar extends ShaderAST {
    /** @internal */ value;
    /** @internal */ group;
    /** @internal */ binding;
    /** @internal */ blockName;
    constructor(exp){
        super();
        this.value = exp;
        this.group = 0;
        this.binding = 0;
    }
    isReference() {
        return true;
    }
    isPointer() {
        return this.value.getType().isPointerType();
    }
    toWebGL(indent, ctx) {
        let prefix = '';
        let builtin = false;
        let valueType = this.value.getType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
                if (ctx.type === ShaderType.Vertex) {
                    prefix = 'attribute ';
                    ctx.defines.push(`#define ${this.value.name} ${semanticToAttrib(ctx.vertexAttributes[this.value.value.$location])}\n`);
                } else {
                    prefix = 'varying ';
                // ctx.defines.push(`#define ${this.value.$str} ch_varying_${this.value.$location}\n`);
                }
                break;
            case DeclareType.DECLARE_TYPE_OUT:
                if (ctx.type === ShaderType.Vertex) {
                    prefix = 'varying ';
                // ctx.defines.push(`#define ${this.value.$str} ch_varying_${this.value.$location}\n`);
                } else {
                    builtin = true;
                    if (ctx.mrt) {
                        ctx.defines.push(`#define ${this.value.name} gl_FragData[${this.value.value.$location}]\n`);
                        ctx.extensions.add('GL_EXT_draw_buffers');
                    } else {
                        ctx.defines.push(`#define ${this.value.name} gl_FragColor\n`);
                    }
                }
                break;
            case DeclareType.DECLARE_TYPE_UNIFORM:
                prefix = 'uniform ';
                valueType = ctx.typeReplacement?.get(this.value.value) || valueType;
                break;
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error(`invalid variable declare type: ${this.value.name}`);
        }
        if (!builtin) {
            return `${indent}${prefix}${valueType.toTypeName('webgl', this.value.name)};\n`;
        }
    }
    toWebGL2(indent, ctx) {
        let prefix = '';
        let valueType = this.value.getType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
                if (ctx.type === ShaderType.Fragment && valueType.isPrimitiveType() && valueType.isInteger()) {
                    prefix = 'flat in ';
                } else {
                    prefix = 'in ';
                }
                if (ctx.type === ShaderType.Vertex) {
                    ctx.defines.push(`#define ${this.value.name} ${semanticToAttrib(ctx.vertexAttributes[this.value.value.$location])}\n`);
                }
                break;
            case DeclareType.DECLARE_TYPE_OUT:
                if (ctx.type === ShaderType.Vertex) {
                    if (valueType.isPrimitiveType() && valueType.isInteger()) {
                        prefix = 'flat out ';
                    } else {
                        prefix = 'out ';
                    }
                } else {
                    prefix = `layout(location = ${this.value.value.$location}) out `;
                }
                break;
            case DeclareType.DECLARE_TYPE_UNIFORM:
                if (valueType.isStructType()) {
                    /*
          if (valueType.layout !== 'std140') {
            throw new errors.PBASTError(this, 'uniform buffer layout must be std140');
          }
          */ return `${indent}layout(std140) uniform ${this.blockName} { ${valueType.structName} ${this.value.name}; };\n`;
                } else {
                    valueType = ctx.typeReplacement?.get(this.value.value) || valueType;
                    return `${indent}uniform ${valueType.toTypeName('webgl2', this.value.name)};\n`;
                }
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error(`invalid variable declare type: ${this.value.name}`);
        }
        {
            return `${indent}${prefix}${this.value.getType().toTypeName('webgl2', this.value.name)};\n`;
        }
    }
    toWGSL(indent, ctx) {
        let prefix;
        const isBlock = this.value.getType().isPrimitiveType() || this.value.getType().isStructType() || this.value.getType().isArrayType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
                // prefix = `@location(${this.value.value.$location}) var<out> `;
                throw new Error(`Internal error`);
            case DeclareType.DECLARE_TYPE_UNIFORM:
                if (this.group === undefined) {
                    debugger;
                }
                prefix = `@group(${this.group}) @binding(${this.binding}) var${isBlock ? '<uniform>' : ''} `;
                break;
            case DeclareType.DECLARE_TYPE_STORAGE:
                prefix = `@group(${this.group}) @binding(${this.binding}) var<storage, ${this.value.isWritable() ? 'read_write' : 'read'}> `;
                break;
            case DeclareType.DECLARE_TYPE_WORKGROUP:
                prefix = `var<workgroup> `;
                break;
            default:
                prefix = `${this.value.getType().isPointerType() ? 'let' : 'var'}${this.value.value.$global && !this.value.getType().isPointerType() ? '<private>' : ''} `;
        }
        {
            const type = this.value.getType();
            const structName = type.isStructType() ? type.structName : null;
            if (structName && ctx.types.findIndex((val)=>val instanceof ASTStructDefine && val.type.structName === structName) < 0) {
                return '';
            } else {
                return `${indent}${prefix}${type.toTypeName('webgpu', this.value.name)};\n`;
            }
        }
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTFunction extends ASTScope {
    /** @internal */ name;
    /** @internal */ args;
    /** @internal */ isBuiltin;
    /** @internal */ isMainFunc;
    /** @internal */ funcType;
    /** @internal */ builtins;
    /** @internal */ returnType;
    constructor(name, args, isMainFunc, type, isBuiltin = false){
        super();
        this.name = name;
        this.args = args;
        this.funcType = type;
        this.builtins = [];
        this.isBuiltin = isBuiltin;
        this.isMainFunc = isMainFunc;
        this.returnType = type ? type.returnType : null;
    }
    toWebGL(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [];
            for (const param of this.args){
                let exp;
                let name;
                let qualifier;
                if (param.paramAST instanceof ASTPrimitive) {
                    exp = param.paramAST.value;
                    name = param.paramAST.name;
                    qualifier = '';
                } else {
                    exp = param.paramAST.value.value;
                    name = param.paramAST.value.name;
                    qualifier = `${exp.$inout} `;
                }
                p.push(`${qualifier}${param.getType().toTypeName('webgl', name)}`);
            }
            str += `${indent}${this.returnType.toTypeName('webgl')} ${this.name}(${p.join(',')}) {\n`;
            str += super.toWebGL(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [];
            for (const param of this.args){
                let exp;
                let name;
                let qualifier;
                if (param.paramAST instanceof ASTPrimitive) {
                    exp = param.paramAST.value;
                    name = param.paramAST.name;
                    qualifier = '';
                } else {
                    exp = param.paramAST.value.value;
                    name = param.paramAST.value.name;
                    qualifier = `${exp.$inout} `;
                }
                p.push(`${qualifier}${param.getType().toTypeName('webgl2', name)}`);
            }
            str += `${indent}${this.returnType.toTypeName('webgl2')} ${this.name}(${p.join(',')}) {\n`;
            str += super.toWebGL2(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
    toWGSL(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [
                ...this.builtins
            ];
            for (const param of this.args){
                const name = param.paramAST instanceof ASTPrimitive ? param.paramAST.name : param.paramAST.value.name;
                const paramType = param.paramAST instanceof ASTPrimitive ? param.paramAST.getType() : param.paramAST.value.getType();
                const dataType = paramType.isPointerType() ? paramType.pointerType : paramType;
                if (dataType.isStructType() && ctx.types.findIndex((t)=>t instanceof ASTStructDefine && t.type.structName === dataType.structName) < 0) {
                    continue;
                }
                p.push(`${paramType.toTypeName('webgpu', name)}`);
            }
            let t = '';
            if (this.isMainFunc) {
                switch(ctx.type){
                    case ShaderType.Vertex:
                        t = '@vertex ';
                        break;
                    case ShaderType.Fragment:
                        t = '@fragment ';
                        break;
                    case ShaderType.Compute:
                        t = `@compute @workgroup_size(${ctx.workgroupSize[0]}, ${ctx.workgroupSize[1]}, ${ctx.workgroupSize[2]}) `;
                        break;
                }
            }
            const retName = this.returnType.isVoidType() ? null : this.returnType.toTypeName('webgpu');
            const retStr = retName ? ` -> ${retName}` : '';
            str += `${indent}${t}fn ${this.name}(${p.join(',')})${retStr} {\n`;
            str += super.toWGSL(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
}
/** @internal */ class ASTIf extends ASTScope {
    /** @internal */ keyword;
    /** @internal */ condition;
    /** @internal */ nextElse;
    constructor(keyword, condition){
        super();
        this.keyword = keyword;
        this.condition = condition;
        this.nextElse = null;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWebGL(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWebGL(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWebGL(indent, ctx);
        }
        return str;
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWebGL2(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWebGL2(indent, ctx);
        }
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWGSL(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWGSL(indent, ctx);
        }
        return str;
    }
}
/** @internal */ class ASTRange extends ASTScope {
    /** @internal */ init;
    /** @internal */ start;
    /** @internal */ end;
    /** @internal */ open;
    constructor(init, start, end, open){
        super();
        this.init = init;
        this.start = start;
        this.end = end;
        this.open = open;
        this.statements = [];
        if (this.start instanceof ASTCallFunction) {
            this.start.isStatement = false;
        }
        if (this.end instanceof ASTCallFunction) {
            this.end.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        const init = this.init.getType().toTypeName('webgl', this.init.name);
        const start = unbracket(this.start.toWebGL(indent, ctx));
        const end = unbracket(this.end.toWebGL(indent, ctx));
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name}++) {\n`;
        str += super.toWebGL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWebGL2(indent, ctx) {
        const init = this.init.getType().toTypeName('webgl2', this.init.name);
        const start = unbracket(this.start.toWebGL2(indent, ctx));
        const end = unbracket(this.end.toWebGL2(indent, ctx));
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name}++) {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        const init = `var ${this.init.getType().toTypeName('webgpu', this.init.name)}`;
        const start = unbracket(this.start.toWGSL(indent, ctx));
        const end = unbracket(this.end.toWGSL(indent, ctx));
        const incr = new ASTScalar(1, this.init.getType()).toWGSL(indent, ctx);
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name} = ${this.init.name} + ${incr}) {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
}
/** @internal */ class ASTDoWhile extends ASTScope {
    /** @internal */ condition;
    constructor(condition){
        super();
        this.condition = condition;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        let str = `${indent}do {\n`;
        str += super.toWebGL(indent + ' ', ctx);
        str += `${indent}} while(${unbracket(this.condition.toWebGL(indent, ctx))});\n`;
        return str;
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}do {\n`;
        str += super.toWebGL2(indent + ' ', ctx);
        str += `${indent}} while(${unbracket(this.condition.toWebGL2(indent, ctx))});\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}loop {\n`;
        str += super.toWGSL(indent + ' ', ctx);
        str += `${indent}  if (!(${unbracket(this.condition.toWGSL(indent, ctx))})) { break; }\n`;
        str += `${indent}}\n`;
        return str;
    }
}
/** @internal */ class ASTWhile extends ASTScope {
    /** @internal */ condition;
    constructor(condition){
        super();
        this.condition = condition;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        let str = `${indent}while(${unbracket(this.condition.toWebGL(indent, ctx))}) {\n`;
        str += super.toWebGL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}while(${unbracket(this.condition.toWebGL2(indent, ctx))}) {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}for(;${unbracket(this.condition.toWGSL(indent, ctx))};) {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    /*
    let str = `${indent}loop {\n`;
    const newIndent = indent + '  ';
    str += `${newIndent}if (!(${unbracket(this.condition.toWGSL(indent, ctx))})) { break; }\n`;
    str += super.toWGSL(newIndent, ctx);
    str += `${indent}}\n`;
    return str;
    */ }
}
/** @internal */ class ASTStructDefine extends ShaderAST {
    /** @internal */ type;
    /** @internal */ prefix;
    /** @internal */ builtin;
    constructor(type, builtin){
        super();
        this.prefix = null;
        this.builtin = builtin;
        this.type = type;
    }
    getType() {
        return this.type;
    }
    toWebGL(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            for (const arg of this.type.structMembers){
                str += `${indent}  ${arg.type.toTypeName('webgl', arg.name)};\n`;
            }
            str += `${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            for (const arg of this.type.structMembers){
                str += `${indent}  ${arg.type.toTypeName('webgl2', arg.name)};\n`;
            }
            str += `${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
    toWGSL(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            str += this.type.structMembers.map((arg, i)=>{
                const prefix = this.prefix ? this.prefix[i] : '';
                const sizePrefix = arg.type.getLayoutSize(this.type.layout) !== arg.type.getLayoutSize('default') ? `@size(${arg.type.getLayoutSize(this.type.layout)}) ` : '';
                const alignPrefix = i > 0 && arg.type.getLayoutAlignment(this.type.layout) !== arg.type.getLayoutAlignment('default') ? `@align(${arg.type.getLayoutAlignment(this.type.layout)}) ` : '';
                return `${indent}  ${prefix}${alignPrefix}${sizePrefix}${arg.type.toTypeName('webgpu', arg.name)}`;
            }).join(',\n');
            str += `\n${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
}
function convertArgs(args, overload) {
    if (args.length !== overload.argTypes.length) {
        return null;
    }
    const result = [];
    for(let i = 0; i < args.length; i++){
        const isRef = !!overload.argTypes[i].byRef;
        const argType = isRef ? overload.argTypes[i].type.pointerType : overload.argTypes[i].type;
        const arg = args[i];
        if (typeof arg === 'number') {
            if (!isRef && argType.isPrimitiveType() && argType.isScalarType() && argType.primitiveType !== PBPrimitiveType.BOOL) {
                result.push(new ASTScalar(arg, argType));
            } else {
                return null;
            }
        } else if (typeof arg === 'boolean') {
            if (!isRef && argType.isPrimitiveType() && argType.primitiveType === PBPrimitiveType.BOOL) {
                result.push(new ASTScalar(arg, argType));
            } else {
                return null;
            }
        } else if (argType.isCompatibleType(arg.getType())) {
            if (isRef) {
                arg.markWritable();
                result.push(new ASTAddressOf(arg));
            } else {
                result.push(arg);
            }
        } else {
            return null;
        }
    }
    return {
        name: overload.name,
        args: result
    };
}

/**
 * Reflection interface for program builder
 * @public
 */ class PBReflection {
    /** @internal */ _builder;
    /** @internal */ _tagList;
    /** @internal */ _attribList;
    constructor(builder){
        this._builder = builder;
        this._tagList = {};
        this._attribList = {};
    }
    /** Gets all the vertex attributes that was used by the program */ get vertexAttributes() {
        return this._builder.getVertexAttributes();
    }
    /**
   * Check if specified vertex attribute was used by the program
   * @param attrib - The vertex attribute to check
   */ hasVertexAttribute(attrib) {
        return this.vertexAttributes.indexOf(attrib) >= 0;
    }
    /**
   * Clear all contents
   */ clear() {
        this._tagList = {};
        this._attribList = {};
    }
    tag(arg0, arg1) {
        if (typeof arg0 === 'string') {
            if (arg1 === undefined) {
                return this.getTag(arg0);
            } else {
                this.addTag(arg0, arg1);
            }
        } else {
            for (const k of Object.keys(arg0)){
                this.addTag(k, arg0[k]);
            }
        }
    }
    /**
   * Gets the variable which is the vertex attribute of specified semantic
   * @param attrib - The vertex semantic
   */ attribute(attrib) {
        return this._attribList[attrib] || null;
    }
    /** @internal */ setAttrib(attrib, exp) {
        this._attribList[attrib] = exp;
    }
    /** @internal */ addTag(name, exp) {
        this._tagList[name] = exp;
    }
    /** @internal */ getTag(name) {
        const getter = this._tagList[name];
        return getter ? getter(this._builder.getGlobalScope()) : null;
    }
}

let currentProgramBuilder = null;
const constructorCache = new Map();
/** @internal */ function setCurrentProgramBuilder(pb) {
    currentProgramBuilder = pb;
}
/** @internal */ function getCurrentProgramBuilder() {
    return currentProgramBuilder;
}
/** @internal */ function makeConstructor(typeFunc, elementType) {
    const wrappedTypeFunc = new Proxy(typeFunc, {
        get: function(target, prop) {
            if (typeof prop === 'symbol' || prop in target) {
                return target[prop];
            }
            let entries = constructorCache.get(typeFunc);
            if (!entries) {
                entries = {};
                constructorCache.set(typeFunc, entries);
            }
            let ctor = entries[prop];
            if (!ctor) {
                if (elementType.isPrimitiveType() || elementType.isStructType() || elementType.isArrayType()) {
                    if (prop === 'ptr') {
                        const pointerType = new PBPointerTypeInfo(elementType, PBAddressSpace.FUNCTION);
                        ctor = function pointerCtor(...args) {
                            if (args.length === 1 && typeof args[0] === 'string') {
                                return new PBShaderExp(args[0], pointerType);
                            } else {
                                throw new Error(`Invalid pointer type constructor`);
                            }
                        };
                    } else {
                        const dim = Number(prop);
                        if (Number.isInteger(dim) && dim >= 0) {
                            const arrayType = new PBArrayTypeInfo(elementType, dim);
                            const arrayTypeFunc = function arrayCtor(...args) {
                                if (args.length === 1 && typeof args[0] === 'string') {
                                    return new PBShaderExp(args[0], arrayType);
                                } else {
                                    const exp = new PBShaderExp('', arrayType);
                                    exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, args.map((arg)=>arg instanceof PBShaderExp ? arg.$ast : arg));
                                    return exp;
                                }
                            };
                            ctor = makeConstructor(arrayTypeFunc, arrayType);
                        }
                    }
                }
            }
            if (ctor) {
                entries[prop] = ctor;
            }
            return ctor;
        }
    });
    return wrappedTypeFunc;
}
/**
 * Base class for proxiable object
 * @public
 */ class Proxiable {
    /** @internal */ proxy;
    constructor(){
        this.proxy = new Proxy(this, {
            get: function(target, prop) {
                return typeof prop === 'string' ? target.$get(prop) : undefined;
            },
            set: function(target, prop, value) {
                return typeof prop === 'string' ? target.$set(prop, value) : false;
            }
        });
        return this.proxy;
    }
    get $thisProxy() {
        return this.proxy;
    }
}
let uidExp = 0;
/**
 * Base class for a expression in the shader
 * @public
 */ class PBShaderExp extends Proxiable {
    /** @internal */ $uid;
    /** @internal */ $str;
    /** @internal */ $location;
    /** @internal */ $typeinfo;
    /** @internal */ $global;
    /** @internal */ $sampleType;
    /** @internal */ $precision;
    /** @internal */ $ast;
    /** @internal */ $inout;
    /** @internal */ $memberCache;
    /** @internal */ $attrib;
    /** @internal */ $tags;
    /** @internal */ $_group;
    /** @internal */ $declareType;
    /** @internal */ $isBuffer;
    /** @internal */ constructor(str, typeInfo){
        super();
        if (!str && typeInfo.isPointerType()) {
            throw new Error('no default constructor for pointer type');
        }
        this.$uid = uidExp++;
        this.$str = str || '';
        this.$location = 0;
        this.$global = false;
        this.$typeinfo = typeInfo;
        this.$qualifier = null;
        this.$precision = ShaderPrecisionType.NONE;
        this.$ast = new ASTPrimitive(this);
        this.$inout = null;
        this.$memberCache = {};
        this.$attrib = null;
        this.$tags = [];
        this.$_group = null;
        this.$declareType = DeclareType.DECLARE_TYPE_NONE;
        this.$isBuffer = false;
        if (typeInfo.isTextureType()) {
            if (typeInfo.isDepthTexture()) {
                this.$sampleType = 'depth';
            } else {
                const t = getTextureSampleType(typeInfo);
                if (t.primitiveType === PBPrimitiveType.I32) {
                    this.$sampleType = 'sint';
                } else if (t.primitiveType === PBPrimitiveType.U32) {
                    this.$sampleType = 'uint';
                } else {
                    this.$sampleType = 'float';
                }
            }
        }
    }
    get $group() {
        return this.$_group;
    }
    set $group(val) {
        this.$_group = val;
        if (this.$_group === undefined) {
            debugger;
        }
    }
    /**
   * Point out that the variable should be in uniform address space
   * @param group - The bind group index
   * @returns self
   */ uniform(group) {
        this.$declareType = DeclareType.DECLARE_TYPE_UNIFORM;
        this.$group = group;
        this.$isBuffer = false;
        return this;
    }
    /**
   * Point out that the variable should be an uniform buffer
   * @param group - The bind group index
   * @returns self
   */ uniformBuffer(group) {
        if (!this.$typeinfo.isPrimitiveType() && !this.$typeinfo.isArrayType() && !this.$typeinfo.isStructType()) {
            throw new PBASTError(this.$ast, 'only primitive type, array type or structure type can be set as uniform buffer');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_UNIFORM;
        this.$group = group;
        this.$isBuffer = true;
        return this;
    }
    /**
   * Point out that the variable should be in workgroup address space
   *
   * @remarks
   * WebGPU device only
   *
   * @returns self
   */ workgroup() {
        this.$declareType = DeclareType.DECLARE_TYPE_WORKGROUP;
        return this;
    }
    /**
   * Point out that the variable should be in storage address space
   * @param group - The bind group index
   * @returns self
   */ storage(group) {
        if (!this.$typeinfo.isHostSharable()) {
            throw new PBASTError(this.$ast, 'type cannot be declared in storage address space');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_STORAGE;
        this.$group = group;
        this.$isBuffer = false;
        return this;
    }
    /**
   * Point out that the variable should be a storage buffer
   * @param group - The bind group index
   * @returns self
   */ storageBuffer(group) {
        if (!this.$typeinfo.isPrimitiveType() && !this.$typeinfo.isArrayType() && !this.$typeinfo.isStructType()) {
            throw new PBASTError(this.$ast, 'only primitive type, array type or structure type can be set as storage buffer');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_STORAGE;
        this.$group = group;
        this.$isBuffer = true;
        return this;
    }
    inout() {
        this.$inout = 'inout';
        return this;
    }
    out() {
        this.$inout = 'out';
        return this;
    }
    /**
   * Point out that the variable is a input vertex attribute
   * @param attr - The vertex semantic
   * @returns self
   */ attrib(attr) {
        this.$declareType = DeclareType.DECLARE_TYPE_IN;
        this.$attrib = attr;
        return this;
    }
    /**
   * Create tags for the variable
   * @param args - tags
   * @returns self
   */ tag(...args) {
        args.forEach((val)=>{
            if (this.$tags.indexOf(val) < 0) {
                this.$tags.push(val);
            }
        });
        return this;
    }
    /**
   * Set sample type for the variable if the variable is of type texture
   * @param type - sample type
   * @returns self
   */ sampleType(type) {
        if (type) {
            this.$sampleType = type;
        }
        return this;
    }
    /**
   * Get element in the array by index
   * @param index - index of the element
   * @returns the element variable
   */ at(index) {
        const varType = this.$ast.getType();
        if (!varType.isArrayType() && (!varType.isPrimitiveType() || !varType.isVectorType() && !varType.isMatrixType())) {
            throw new Error('at() function must be used with array types');
        }
        let elementType = null;
        let dimension;
        if (varType.isArrayType()) {
            elementType = varType.elementType;
            dimension = varType.dimension;
        } else if (varType.isVectorType()) {
            elementType = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, 1));
            dimension = varType.cols;
        } else if (varType.isMatrixType()) {
            elementType = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
            dimension = varType.rows;
        }
        const result = new PBShaderExp('', elementType);
        if (typeof index === 'number') {
            if (!Number.isInteger(index)) {
                throw new Error('at() array index must be integer type');
            }
            if (index < 0 || dimension > 0 && index >= dimension) {
                throw new Error('at() array index out of bounds');
            }
            result.$ast = new ASTArrayIndex(this.$ast, new ASTScalar(index, typeI32$1), elementType);
        } else {
            const type = index.$ast.getType();
            if (!type.isPrimitiveType() || !type.isScalarType()) {
                throw new Error('at() array index must be scalar type');
            }
            let ast = index.$ast;
            if (type.scalarType !== PBPrimitiveType.I32 && type.scalarType !== PBPrimitiveType.U32) {
                ast = new ASTCast(ast, typeI32$1);
            }
            result.$ast = new ASTArrayIndex(this.$ast, ast, elementType);
        }
        return result;
    }
    /**
   * Set element in the array by index
   * @param index - index of the element
   * @param val - value to set
   */ setAt(index, val) {
        const varType = this.$ast.getType();
        if (!varType.isArrayType()) {
            throw new Error('setAt() function must be used with array types');
        }
        if (typeof index === 'number') {
            if (!Number.isInteger(index)) {
                throw new Error('setAt() array index must be integer type');
            }
            if (index < 0 || varType.dimension > 0 && index >= varType.dimension) {
                throw new Error('setAt() array index out of bounds');
            }
        }
        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), typeof index === 'number' ? new ASTScalar(index, typeI32$1) : index.$ast, varType.elementType), val instanceof PBShaderExp ? val.$ast : val));
    }
    /**
   * Point out that the variable should be in high precision
   * @returns self
   */ highp() {
        this.$precision = ShaderPrecisionType.HIGH;
        return this;
    }
    /**
   * Points out that the variable should be in medium precision
   * @returns self
   */ mediump() {
        this.$precision = ShaderPrecisionType.MEDIUM;
        return this;
    }
    /**
   * Points out that the variable should be in low precision
   * @returns self
   */ lowp() {
        this.$precision = ShaderPrecisionType.LOW;
        return this;
    }
    /**
   * Determine if this variable is of vector type
   * @returns true if the variable is of vector type, otherwise false
   */ isVector() {
        const varType = this.$ast.getType();
        return varType.isPrimitiveType() && varType.isVectorType();
    }
    /**
   * Get vector component count of the variable if this variable is of vector type
   * @returns the vector component count
   */ numComponents() {
        const varType = this.$ast.getType();
        return varType.isPrimitiveType() ? varType.cols : 0;
    }
    /**
   * Get type name of this variable
   * @returns The type name of this variable
   */ getTypeName() {
        return this.$ast.getType().toTypeName(currentProgramBuilder.getDevice().type);
    }
    /** @internal */ $get(prop) {
        if (typeof prop === 'string') {
            if (prop[0] === '$' || prop in this) {
                return this[prop];
            } else {
                let exp = this.$memberCache[prop];
                if (!exp) {
                    const varType = this.$ast?.getType() || this.$typeinfo;
                    const num = Number(prop);
                    if (Number.isNaN(num)) {
                        if (varType.isStructType()) {
                            const elementIndex = varType.structMembers.findIndex((val)=>val.name === prop);
                            if (elementIndex < 0) {
                                throw new Error(`unknown struct member '${prop}'`);
                            }
                            const element = varType.structMembers[elementIndex];
                            if (element.type.isStructType()) {
                                const ctor = currentProgramBuilder.structInfo.structs[element.type.structName];
                                exp = ctor.call(currentProgramBuilder, `${this.$str}.${prop}`);
                            } else {
                                exp = new PBShaderExp(`${this.$str}.${prop}`, element.type);
                            }
                            exp.$ast = new ASTHash(this.$ast, prop, element.type);
                        } else {
                            if (!varType.isPrimitiveType() || !varType.isVectorType()) {
                                throw new Error(`invalid index operation: ${this.$ast.toString(currentProgramBuilder.getDevice().type)}[${prop}]`);
                            }
                            if (prop.length === 0 || prop.length > 4 || [
                                ...prop
                            ].some((val)=>'xyzw'.slice(0, varType.cols).indexOf(val) < 0) && [
                                ...prop
                            ].some((val)=>'rgba'.slice(0, varType.cols).indexOf(val) < 0)) {
                                throw new Error(`unknown swizzle target: ${this.$ast.toString(currentProgramBuilder.getDevice().type)}[${prop}]`);
                            }
                            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, prop.length));
                            exp = new PBShaderExp('', type);
                            exp.$ast = new ASTHash(this.$ast, prop, type);
                        }
                    } else {
                        if (varType.isArrayType()) {
                            exp = this.at(num);
                        } else if (varType.isPrimitiveType() && varType.isVectorType()) {
                            if (num >= varType.cols) {
                                throw new Error(`component index out of bounds: ${this.$str}[${num}]`);
                            }
                            exp = this.$get('xyzw'[num]);
                        } else if (varType.isPrimitiveType() && varType.isMatrixType()) {
                            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
                            exp = new PBShaderExp('', type);
                            exp.$ast = new ASTArrayIndex(this.$ast, new ASTScalar(num, typeI32$1), type);
                        } else {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                    }
                    this.$memberCache[prop] = exp;
                }
                return exp;
            }
        } else {
            return undefined;
        }
    }
    /** @internal */ $set(prop, value) {
        if (typeof prop === 'string') {
            if (prop[0] === '$' || prop in this) {
                this[prop] = value;
            } else {
                if (typeof value !== 'number' && typeof value !== 'boolean' && !(value instanceof PBShaderExp)) {
                    throw new Error(`Invalid output value assignment`);
                }
                const varType = this.$ast?.getType() || this.$typeinfo;
                const num = Number(prop);
                if (Number.isNaN(num)) {
                    if (varType.isStructType()) {
                        const elementIndex = varType.structMembers.findIndex((val)=>val.name === prop);
                        if (elementIndex < 0) {
                            throw new Error(`unknown struct member '${prop}`);
                        }
                        const element = varType.structMembers[elementIndex];
                        let dstAST;
                        if (typeof value === 'number' || typeof value === 'boolean') {
                            if (!element.type.isPrimitiveType() || !element.type.isScalarType()) {
                                throw new Error(`can not set struct member '${prop}: invalid value type`);
                            }
                            dstAST = new ASTScalar(value, element.type);
                        } else if (value instanceof PBShaderExp) {
                            dstAST = value.$ast;
                        }
                        if (!dstAST) {
                            throw new Error(`can not set struct member '${prop}: invalid value type`);
                        }
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, element.type), dstAST));
                    } else {
                        // FIXME: WGSL does not support l-value swizzling
                        if (prop.length > 1 || 'xyzw'.indexOf(prop) < 0 && 'rgba'.indexOf(prop) < 0) {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                        if (!varType.isPrimitiveType() || !varType.isVectorType()) {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                        const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.scalarType);
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, type), value instanceof PBShaderExp ? value.$ast : value));
                    }
                } else {
                    if (varType.isArrayType()) {
                        this.setAt(num, value);
                    } else if (varType.isPrimitiveType() && varType.isVectorType()) {
                        if (num >= varType.cols) {
                            throw new Error(`component index out of bounds: ${this.$str}[${num}]`);
                        }
                        this.$set('xyzw'[num], value);
                    } else if (varType.isPrimitiveType() && varType.isMatrixType()) {
                        if (!(value instanceof PBShaderExp)) {
                            throw new Error(`invalid matrix column vector assignment: ${this.$str}[${num}]`);
                        }
                        const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), new ASTScalar(num, typeI32$1), type), value.$ast));
                    } else {
                        throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                    }
                }
            }
            return true;
        }
        return false;
    }
}

const genTypeList = [
    [
        typeF32$1,
        typeF32Vec2$1,
        typeF32Vec3$1,
        typeF32Vec4$1
    ],
    [
        typeI32$1,
        typeI32Vec2$1,
        typeI32Vec3$1,
        typeI32Vec4$1
    ],
    [
        typeU32$2,
        typeU32Vec2$1,
        typeU32Vec3$1,
        typeU32Vec4$1
    ],
    [
        typeBool,
        typeBVec2,
        typeBVec3,
        typeBVec4
    ]
];
const genMatrixTypeList = [
    typeMat2,
    typeMat2x3,
    typeMat2x4,
    typeMat3x2,
    typeMat3,
    typeMat3x4,
    typeMat4x2,
    typeMat4x3,
    typeMat4
];
function matchFunctionOverloadings(pb, name, ...args) {
    const bit = pb.getDevice().type === 'webgl' ? MASK_WEBGL1 : pb.getDevice().type === 'webgl2' ? MASK_WEBGL2 : MASK_WEBGPU;
    const overloadings = builtinFunctionsAll?.[name].overloads.filter((val)=>!!(val[1] & bit)).map((val)=>val[0]);
    if (!overloadings || overloadings.length === 0) {
        throw new PBDeviceNotSupport(`builtin shader function '${name}'`);
    }
    const argsNonArray = args.map((val)=>pb.normalizeExpValue(val));
    const matchResult = pb._matchFunctionOverloading(overloadings, argsNonArray);
    if (!matchResult) {
        throw new PBOverloadingMatchError(name);
    }
    return matchResult;
}
function callBuiltinChecked(pb, matchResult) {
    return pb.$callFunction(matchResult[0].name, matchResult[1], matchResult[0]);
}
function callBuiltin(pb, name, ...args) {
    return callBuiltinChecked(pb, matchFunctionOverloadings(pb, name, ...args));
}
function genMatrixType(name, shaderTypeMask, r, args) {
    const result = [];
    for(let i = 0; i < genMatrixTypeList.length; i++){
        const returnType = r || genMatrixTypeList[i];
        const argTypes = args.map((arg)=>{
            return {
                type: arg || genMatrixTypeList[i]
            };
        });
        result.push([
            new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, returnType, argTypes), true),
            shaderTypeMask
        ]);
    }
    return result;
}
function genType(name, shaderTypeMask, r, args, vecOnly) {
    if (args.findIndex((val)=>typeof val === 'number') < 0) {
        return [
            [
                new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, r, args.map((arg)=>({
                        type: arg
                    }))), true),
                shaderTypeMask
            ]
        ];
    } else {
        const result = [];
        let i = vecOnly ? 1 : 0;
        for(; i < 4; i++){
            const returnType = typeof r === 'number' ? genTypeList[r][i] : r;
            const argTypes = args.map((arg)=>{
                if (typeof arg === 'number') {
                    return {
                        type: genTypeList[arg][i]
                    };
                } else {
                    return {
                        type: arg
                    };
                }
            });
            result.push([
                new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, returnType, argTypes), true),
                shaderTypeMask
            ]);
        }
        return result;
    }
}
function unaryFunc(a, op, type) {
    const exp = new PBShaderExp('', type);
    exp.$ast = new ASTUnaryFunc(a, op, type);
    return exp;
}
function binaryFunc(a, b, op, type) {
    const exp = new PBShaderExp('', type);
    exp.$ast = new ASTBinaryFunc(a, b, op, type);
    return exp;
}
const MASK_WEBGL1 = 1 << 0;
const MASK_WEBGL2 = 1 << 1;
const MASK_WEBGPU = 1 << 2;
const MASK_WEBGL = MASK_WEBGL1 | MASK_WEBGL2;
const MASK_ALL = MASK_WEBGL | MASK_WEBGPU;
const builtinFunctionsAll = {
    add_2: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$2,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$2,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$2
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                null
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {
                return args[0] + args[1];
            }
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '+', matchResult[0].returnType);
        }
    },
    add: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('add');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.add_2(result, args[i]);
            }
            return result;
        }
    },
    sub: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$2,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$2,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$2
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                null
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '-', matchResult[0].returnType);
        }
    },
    div: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$2,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$2,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '/', matchResult[0].returnType);
        }
    },
    mul_2: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$2,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$2,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$2
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$2
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                typeF32$1,
                null
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat2,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat2,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat2,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeMat2,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat2x3,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat2x3,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat2x3,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeMat2x3,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec3$1,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat2x4,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat2x4,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat2x4,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeMat2x4,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec4$1,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat3x2,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat3x2,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat3x2,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeMat3x2,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec2$1,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat3,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat3,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat3,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeMat3,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat3x4,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat3x4,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat3x4,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeMat3x4,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec4$1,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat4x2,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat4x2,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat4x2,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeMat4x2,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec2$1,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat4x3,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat4x3,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat4x3,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeMat4x3,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec3$1,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat4,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat4,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat4,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeMat4,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeMat4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '*', matchResult[0].returnType);
        }
    },
    mul: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('mul');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.mul_2(result, args[i]);
            }
            return result;
        }
    },
    mod: {
        overloads: [
            ...genType('mod', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('mod', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('mod', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('mod', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            const isIntegerType = argType.isPrimitiveType() && (argType.scalarType === PBPrimitiveType.I32 || argType.scalarType === PBPrimitiveType.U32);
            if (pb.getDevice().type === 'webgl' && isIntegerType) {
                throw new PBDeviceNotSupport('integer modulus');
            }
            if (pb.getDevice().type === 'webgpu' || isIntegerType) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '%', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    radians: {
        overloads: genType('radians', MASK_ALL, 0, [
            0
        ])
    },
    degrees: {
        overloads: genType('degrees', MASK_ALL, 0, [
            0
        ])
    },
    sin: {
        overloads: genType('sin', MASK_ALL, 0, [
            0
        ])
    },
    cos: {
        overloads: genType('cos', MASK_ALL, 0, [
            0
        ])
    },
    tan: {
        overloads: genType('tan', MASK_ALL, 0, [
            0
        ])
    },
    asin: {
        overloads: genType('asin', MASK_ALL, 0, [
            0
        ])
    },
    acos: {
        overloads: genType('acos', MASK_ALL, 0, [
            0
        ])
    },
    atan: {
        overloads: genType('atan', MASK_ALL, 0, [
            0
        ])
    },
    atan2: {
        overloads: [
            ...genType('atan', MASK_WEBGL, 0, [
                0,
                0
            ]),
            ...genType('atan2', MASK_WEBGPU, 0, [
                0,
                0
            ])
        ]
    },
    sinh: {
        overloads: genType('sinh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    cosh: {
        overloads: genType('cosh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    tanh: {
        overloads: genType('tanh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    asinh: {
        overloads: genType('asinh', MASK_WEBGL2, 0, [
            0
        ])
    },
    acosh: {
        overloads: genType('acosh', MASK_WEBGL2, 0, [
            0
        ])
    },
    atanh: {
        overloads: genType('atanh', MASK_WEBGL2, 0, [
            0
        ])
    },
    pow: {
        overloads: genType('pow', MASK_ALL, 0, [
            0,
            0
        ])
    },
    exp: {
        overloads: genType('exp', MASK_ALL, 0, [
            0
        ])
    },
    exp2: {
        overloads: genType('exp2', MASK_ALL, 0, [
            0
        ])
    },
    log: {
        overloads: genType('log', MASK_ALL, 0, [
            0
        ])
    },
    log2: {
        overloads: genType('log2', MASK_ALL, 0, [
            0
        ])
    },
    sqrt: {
        overloads: genType('sqrt', MASK_ALL, 0, [
            0
        ])
    },
    inverseSqrt: {
        overloads: [
            ...genType('inversesqrt', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('inverseSqrt', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    abs: {
        overloads: [
            ...genType('abs', MASK_ALL, 0, [
                0
            ]),
            ...genType('abs', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1
            ]),
            ...genType('abs', MASK_WEBGPU, 2, [
                2
            ])
        ]
    },
    sign: {
        overloads: [
            ...genType('sign', MASK_ALL, 0, [
                0
            ]),
            ...genType('sign', MASK_WEBGL2, 1, [
                1
            ])
        ]
    },
    floor: {
        overloads: genType('floor', MASK_ALL, 0, [
            0
        ])
    },
    ceil: {
        overloads: genType('ceil', MASK_ALL, 0, [
            0
        ])
    },
    fract: {
        overloads: genType('fract', MASK_ALL, 0, [
            0
        ])
    },
    fma: {
        overloads: genType('fma', MASK_ALL, 0, [
            0,
            0,
            0
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            if (pb.getDevice().type === 'webgpu') {
                return callBuiltinChecked(pb, matchResult);
            } else {
                return pb.add(pb.mul(args[0], args[1]), args[2]);
            }
        }
    },
    round: {
        overloads: genType('round', MASK_WEBGPU, 0, [
            0
        ])
    },
    trunc: {
        overloads: genType('trunc', MASK_WEBGPU, 0, [
            0
        ])
    },
    // TODO: modf
    min: {
        overloads: [
            ...genType('min', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('min', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('min', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ]
    },
    max: {
        overloads: [
            ...genType('max', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('max', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('max', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ]
    },
    clamp: {
        overloads: [
            ...genType('clamp', MASK_ALL, 0, [
                0,
                0,
                0
            ]),
            ...genType('clamp', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1,
                1
            ]),
            ...genType('clamp', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2,
                2
            ])
        ]
    },
    mix: {
        overloads: [
            ...genType('mix', MASK_ALL, 0, [
                0,
                0,
                0
            ]),
            ...genType('mix', MASK_ALL, 0, [
                0,
                0,
                typeF32$1
            ])
        ]
    },
    step: {
        overloads: genType('step', MASK_ALL, 0, [
            0,
            0
        ])
    },
    smoothStep: {
        overloads: genType('smoothstep', MASK_ALL, 0, [
            0,
            0,
            0
        ])
    },
    isnan: {
        overloads: genType('isnan', MASK_WEBGL2, 3, [
            0
        ])
    },
    isinf: {
        overloads: genType('isinf', MASK_WEBGL2, 3, [
            0
        ])
    },
    length: {
        overloads: genType('length', MASK_ALL, typeF32$1, [
            0
        ])
    },
    distance: {
        overloads: genType('distance', MASK_ALL, typeF32$1, [
            0,
            0
        ])
    },
    dot: {
        overloads: [
            ...genType('dot', MASK_ALL, typeF32$1, [
                0,
                0
            ], true),
            ...genType('dot', MASK_WEBGPU, typeI32$1, [
                1,
                1
            ], true),
            ...genType('dot', MASK_WEBGPU, typeU32$2, [
                2,
                2
            ], true)
        ]
    },
    cross: {
        overloads: genType('cross', MASK_ALL, typeF32Vec3$1, [
            typeF32Vec3$1,
            typeF32Vec3$1
        ])
    },
    normalize: {
        overloads: genType('normalize', MASK_ALL, 0, [
            0
        ], true)
    },
    faceForward: {
        overloads: [
            ...genType('faceforward', MASK_WEBGL, 0, [
                0,
                0,
                0
            ], true),
            ...genType('faceForward', MASK_WEBGPU, 0, [
                0,
                0,
                0
            ], true)
        ]
    },
    reflect: {
        overloads: genType('reflect', MASK_ALL, 0, [
            0,
            0
        ], true)
    },
    refract: {
        overloads: genType('refract', MASK_ALL, 0, [
            0,
            0,
            typeF32$1
        ], true)
    },
    frexp: {
        overloads: [
            ...genType('frexp', MASK_WEBGPU, typeFrexpResult, [
                typeF32$1
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec2, [
                typeF32Vec2$1
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec3, [
                typeF32Vec3$1
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec4, [
                typeF32Vec4$1
            ])
        ]
    },
    outerProduct: {
        overloads: [
            ...genType('outerProduct', MASK_WEBGL2, typeMat2, [
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3, [
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4, [
                typeF32Vec4$1,
                typeF32Vec4$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat2x3, [
                typeF32Vec3$1,
                typeF32Vec2$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3x2, [
                typeF32Vec2$1,
                typeF32Vec3$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat2x4, [
                typeF32Vec4$1,
                typeF32Vec2$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4x2, [
                typeF32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3x4, [
                typeF32Vec4$1,
                typeF32Vec3$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4x3, [
                typeF32Vec3$1,
                typeF32Vec4$1
            ])
        ]
    },
    transpose: {
        overloads: [
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2, [
                typeMat2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3, [
                typeMat3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4, [
                typeMat4
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2x3, [
                typeMat3x2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3x2, [
                typeMat2x3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2x4, [
                typeMat4x2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4x2, [
                typeMat2x4
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3x4, [
                typeMat4x3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4x3, [
                typeMat3x4
            ])
        ]
    },
    determinant: {
        overloads: [
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32$1, [
                typeMat2
            ]),
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32$1, [
                typeMat3
            ]),
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32$1, [
                typeMat4
            ])
        ]
    },
    inverse: {
        overloads: [
            ...genType('inverse', MASK_WEBGL2, typeMat2, [
                typeMat2
            ]),
            ...genType('inverse', MASK_WEBGL2, typeMat3, [
                typeMat3
            ]),
            ...genType('inverse', MASK_WEBGL2, typeMat4, [
                typeMat4
            ])
        ]
    },
    lessThan: {
        overloads: [
            ...genType('lessThan', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('lessThan', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('lessThan', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '<', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    lessThanEqual: {
        overloads: [
            ...genType('lessThanEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('lessThanEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('lessThanEqual', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '<=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    greaterThan: {
        overloads: [
            ...genType('greaterThan', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('greaterThan', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('greaterThan', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '>', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    greaterThanEqual: {
        overloads: [
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '>=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    compEqual: {
        overloads: [
            ...genType('equal', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('equal', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('equal', MASK_ALL, 3, [
                2,
                2
            ]),
            ...genType('equal', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '==', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    compNotEqual: {
        overloads: [
            ...genType('notEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                2,
                2
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '!=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    equal: {
        overloads: [
            ...genType('equal', MASK_ALL, typeBool, [
                0,
                0
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                1,
                1
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                2,
                2
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' && argType.isPrimitiveType() && !argType.isScalarType()) {
                return pb.all(pb.compEqual(args[0], args[1]));
            } else {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '==', matchResult[0].returnType);
            }
        }
    },
    notEqual: {
        overloads: [
            ...genType('notEqual', MASK_ALL, typeBool, [
                0,
                0
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                1,
                1
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                2,
                2
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' && argType.isPrimitiveType() && !argType.isScalarType()) {
                return pb.any(pb.compNotEqual(args[0], args[1]));
            } else {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '!=', matchResult[0].returnType);
            }
        }
    },
    any: {
        overloads: genType('any', MASK_ALL, typeBool, [
            3
        ], true)
    },
    all: {
        overloads: genType('all', MASK_ALL, typeBool, [
            3
        ], true)
    },
    not: {
        overloads: genType('not', MASK_ALL, 3, [
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return unaryFunc(matchResult[1][0], '!', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    neg: {
        overloads: [
            ...genType('neg', MASK_ALL, 0, [
                0
            ]),
            ...genType('neg', MASK_ALL, 1, [
                1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return unaryFunc(matchResult[1][0], '-', matchResult[0].returnType);
        }
    },
    or_2: {
        overloads: genType('or', MASK_ALL, typeBool, [
            3,
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '||', matchResult[0].returnType);
        }
    },
    or: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('or');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.or_2(result, args[i]);
            }
            return result;
        }
    },
    compOr: {
        overloads: [
            ...genType('compOr', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compOr', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '|', matchResult[0].returnType);
        }
    },
    and_2: {
        overloads: genType('and', MASK_ALL, typeBool, [
            3,
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '&&', matchResult[0].returnType);
        }
    },
    and: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('and');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.and_2(result, args[i]);
            }
            return result;
        }
    },
    compAnd: {
        overloads: [
            ...genType('compAnd', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compAnd', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '&', matchResult[0].returnType);
        }
    },
    compXor: {
        overloads: [
            ...genType('compXor', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compXor', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '^', matchResult[0].returnType);
        }
    },
    sal: {
        overloads: [
            ...genType('sal', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                2
            ]),
            ...genType('sal', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '<<', matchResult[0].returnType);
        }
    },
    sar: {
        overloads: [
            ...genType('sar', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                2
            ]),
            ...genType('sar', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '>>', matchResult[0].returnType);
        }
    },
    arrayLength: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError('arrayLength');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('arrayLength', 'array');
            }
            const type = args[0].$ast.getType();
            const arrayType = type.isPointerType() ? type.pointerType : type;
            if (!arrayType.isArrayType() || arrayType.dimension !== 0) {
                throw new PBParamTypeError('arrayLength', 'array');
            }
            const arg = type.isArrayType() ? pb.addressOf(args[0]).$ast : args[0].$ast;
            return pb.$callFunctionNoCheck(name, [
                arg
            ], typeU32$2);
        }
    },
    select: {
        overloads: [
            ...genType('select', MASK_WEBGPU, 0, [
                0,
                0,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 1, [
                1,
                1,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 2, [
                2,
                2,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 3, [
                3,
                3,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 0, [
                0,
                0,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 1, [
                1,
                1,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 2, [
                2,
                2,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 3, [
                3,
                3,
                3
            ], true),
            ...genType('mix', MASK_WEBGL2, 0, [
                0,
                0,
                3
            ]),
            ...genType('mix', MASK_WEBGL2, 1, [
                1,
                1,
                3
            ]),
            ...genType('mix', MASK_WEBGL2, 2, [
                2,
                2,
                3
            ])
        ]
    },
    floatBitsToInt: {
        overloads: genType('floatBitsToInt', MASK_WEBGL2, 1, [
            0
        ])
    },
    floatBitsToUint: {
        overloads: genType('floatBitsToUint', MASK_WEBGL2, 2, [
            0
        ])
    },
    intBitsToFloat: {
        overloads: genType('intBitsToFloat', MASK_WEBGL2, 0, [
            1
        ])
    },
    uintBitsToFloat: {
        overloads: genType('uintBitsToFloat', MASK_WEBGL2, 0, [
            2
        ])
    },
    pack4x8snorm: {
        overloads: genType('pack4x8snorm', MASK_WEBGPU, typeU32$2, [
            typeF32Vec4$1
        ])
    },
    unpack4x8snorm: {
        overloads: genType('unpack4x8snorm', MASK_WEBGPU, typeF32Vec4$1, [
            typeU32$2
        ])
    },
    pack4x8unorm: {
        overloads: genType('pack4x8unorm', MASK_WEBGPU, typeU32$2, [
            typeF32Vec4$1
        ])
    },
    unpack4x8unorm: {
        overloads: genType('unpack4x8unorm', MASK_WEBGPU, typeF32Vec4$1, [
            typeU32$2
        ])
    },
    pack2x16snorm: {
        overloads: [
            ...genType('pack2x16snorm', MASK_WEBGPU, typeU32$2, [
                typeF32Vec2$1
            ]),
            ...genType('packSnorm2x16', MASK_WEBGL2, typeU32$2, [
                typeF32Vec2$1
            ])
        ]
    },
    unpack2x16snorm: {
        overloads: [
            ...genType('unpack2x16snorm', MASK_WEBGPU, typeF32Vec2$1, [
                typeU32$2
            ]),
            ...genType('unpackSnorm2x16', MASK_WEBGL2, typeF32Vec2$1, [
                typeU32$2
            ])
        ]
    },
    pack2x16unorm: {
        overloads: [
            ...genType('pack2x16unorm', MASK_WEBGPU, typeU32$2, [
                typeF32Vec2$1
            ]),
            ...genType('packUnorm2x16', MASK_WEBGL2, typeU32$2, [
                typeF32Vec2$1
            ])
        ]
    },
    unpack2x16unorm: {
        overloads: [
            ...genType('unpack2x16unorm', MASK_WEBGPU, typeF32Vec2$1, [
                typeU32$2
            ]),
            ...genType('unpackUnorm2x16', MASK_WEBGL2, typeF32Vec2$1, [
                typeU32$2
            ])
        ]
    },
    pack2x16float: {
        overloads: [
            ...genType('pack2x16float', MASK_WEBGPU, typeU32$2, [
                typeF32Vec2$1
            ]),
            ...genType('packHalf2x16', MASK_WEBGL2, typeU32$2, [
                typeF32Vec2$1
            ])
        ]
    },
    unpack2x16float: {
        overloads: [
            ...genType('unpack2x16float', MASK_WEBGPU, typeF32Vec2$1, [
                typeU32$2
            ]),
            ...genType('unpackHalf2x16', MASK_WEBGL2, typeF32Vec2$1, [
                typeU32$2
            ])
        ]
    },
    matrixCompMult: {
        overloads: genMatrixType('matrixCompMult', MASK_WEBGL, null, [
            null,
            null
        ])
    },
    dpdx: {
        overloads: [
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('dpdx', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    dpdy: {
        overloads: [
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('dpdy', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    fwidth: {
        overloads: genType('fwidth', MASK_ALL, 0, [
            0
        ])
    },
    dpdxCoarse: {
        overloads: [
            ...genType('dpdxCoarse', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdxFine: {
        overloads: [
            ...genType('dpdxFine', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdyCoarse: {
        overloads: [
            ...genType('dpdyCoarse', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdyFine: {
        overloads: [
            ...genType('dpdyFine', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    // textureDimensions(tex: PBShaderExp, level?: number|PBShaderExp);
    textureDimensions: {
        overloads: [
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTex1D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeITex1D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeUTex1D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTex2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITex2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTex2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTex2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITex2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTex2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTex3D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeITex3D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeUTex3D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITexCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTexCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITexCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTexCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepth2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepth2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepthCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepthCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepthMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$2, [
                typeTexStorage1D_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_r32float
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTex1D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTex2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITex1D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITex2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTex1D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTex2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTex2DArray,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITex2DArray,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTex2DArray,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITexCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTexCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3$1, [
                typeTex3D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3$1, [
                typeITex3D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3$1, [
                typeUTex3D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexDepth2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexDepthCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexDepth2DArray,
                typeI32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 1 || args.length > 2) {
                throw new PBParamLengthError('textureDimensions');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('textureDimensions', 'tex');
            }
            const texType = args[0].$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureDimensions', 'tex');
            }
            if (pb.getDevice().type === 'webgpu') {
                if (texType.isMultisampledTexture() || texType.isStorageTexture()) {
                    if (args[1] !== undefined) {
                        throw new PBParamValueError('textureDimensions', 'level');
                    }
                }
                return callBuiltin(pb, name, ...args);
            } else if (pb.getDevice().type === 'webgl2') {
                const tex = args[0];
                const level = args[1] || 0;
                return texType.is1DTexture() ? callBuiltin(pb, name, tex, level).x : callBuiltin(pb, name, tex, level);
            }
        }
    },
    // textureGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp);
    // textureGather(component: number|PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp);
    textureGather: {
        overloads: [
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3$1
            ])
        ]
    },
    // textureArrayGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp);
    // textureArrayGather(component: number|PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp);
    textureArrayGather: {
        overloads: [
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ])
        ]
    },
    // textureGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp);
    textureGatherCompare: {
        overloads: [
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeF32$1
            ])
        ]
    },
    // textureArrayGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp);
    textureArrayGatherCompare: {
        overloads: [
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ])
        ]
    },
    // textureLoad(tex: PBShaderExp, coords: number|PBShaderExp, levelOrSampleIndex: number|PBShaderExp);
    textureLoad: {
        overloads: [
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex1D,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex1D,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex1D,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITexMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTexMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexExternal,
                typeI32Vec2$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32$1, [
                typeTexDepthMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex1D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeTexExternal,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeITex1D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4$1, [
                typeITex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4$1, [
                typeITex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeUTex1D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeUTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeUTex3D,
                typeI32Vec3$1,
                typeI32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length === 0) {
                throw new PBParamLengthError('textureLoad');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('textureLoad', 'tex');
            }
            const texType = args[0].$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureLoad', 'tex');
            }
            if (pb.getDevice().type === 'webgl2') {
                if (args.length !== 3) {
                    throw new PBParamLengthError('textureLoad');
                }
                if (texType.is1DTexture()) {
                    if (typeof args[1] === 'number') {
                        if (!Number.isInteger(args[1])) {
                            throw new PBParamTypeError('textureLoad', 'coord');
                        }
                    } else if (args[1] instanceof PBShaderExp) {
                        const coordType = args[1].$ast.getType();
                        if (!coordType.isPrimitiveType() || !coordType.isScalarType() || coordType.scalarType !== PBPrimitiveType.I32) {
                            throw new PBParamTypeError('textureLoad', 'coord');
                        }
                    } else {
                        throw new PBParamTypeError('textureLoad', 'coord');
                    }
                    args[1] = pb.ivec2(args[1], 0);
                }
            } else if (pb.getDevice().type === 'webgpu' && texType.isExternalTexture()) {
                args = args.slice(0, 2);
            }
            return callBuiltin(pb, name, ...args);
        }
    },
    // textureArrayLoad(tex: PBShaderExp, coords: number|PBShaderExp, arrayIndex: number|PBShaderExp, level: number|PBShaderExp);
    textureArrayLoad: {
        overloads: [
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4$1, [
                typeITex2DArray,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeUTex2DArray,
                typeI32Vec3$1,
                typeI32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (pb.getDevice().type === 'webgl2') {
                if (args.length !== 4) {
                    throw new PBParamLengthError('textureArrayLoad');
                }
                const tex = args[0];
                const coords = pb.ivec3(args[1], args[2]);
                const level = args[3];
                return callBuiltin(pb, name, tex, coords, level);
            } else {
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureStore(tex: PBShaderExp, coords: number|PBShaderExp, value: PBShaderExp);
    textureStore: {
        overloads: [
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8unorm,
                typeU32$2,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8snorm,
                typeU32$2,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8uint,
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8sint,
                typeU32$2,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16uint,
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16sint,
                typeU32$2,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16float,
                typeU32$2,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32uint,
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32sint,
                typeU32$2,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32float,
                typeU32$2,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32uint,
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32sint,
                typeU32$2,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32float,
                typeU32$2,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32uint,
                typeU32$2,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32sint,
                typeU32$2,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32float,
                typeU32$2,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8unorm,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8snorm,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8unorm,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8snorm,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ])
        ]
    },
    // textureArrayStore(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, value: PBShaderExp);
    textureArrayStore: {
        overloads: [
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8unorm,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8snorm,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ])
        ]
    },
    // textureNumLayers(tex: PBShaderExp);
    textureNumLayers: {
        overloads: [
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeITex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeUTex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeITexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeUTexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexDepth2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexDepthCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_r32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_r32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_r32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rg32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rg32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rg32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba16float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba16sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba16uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8snorm
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8unorm
            ])
        ]
    },
    // textureNumLevels(tex: PBShaderExp);
    textureNumLevels: {
        overloads: [
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepth2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepth2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepthCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepthCubeArray
            ])
        ]
    },
    // textureNumSamples(tex: PBShaderExp);
    textureNumSamples: {
        overloads: [
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeTexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeITexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeUTexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeTexDepthMultisampled2D
            ])
        ]
    },
    // textureSample(tex: texture, coords: number|PBShaderExp);
    textureSample: {
        overloads: [
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex1D,
                typeSampler,
                typeF32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureSampleBaseClampToEdge', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexExternal,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex1D,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex1D,
                typeF32Vec2$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError('textureSample');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSample', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSample', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const ret = callBuiltin(pb, name, tex, sampler, coords);
                if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                if (texType.is1DTexture()) {
                    if (args[1] instanceof PBShaderExp) {
                        const coordType = args[1].$ast.getType();
                        if (!coordType.isPrimitiveType() || !coordType.isScalarType() || coordType.scalarType !== PBPrimitiveType.F32) {
                            throw new PBParamTypeError('textureSample', 'coord');
                        }
                    } else if (typeof args[1] !== 'number') {
                        throw new PBParamTypeError('textureSample', 'coord');
                    }
                    args[1] = pb.vec2(args[1], 0);
                }
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySample(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp)
    textureArraySample: {
        overloads: [
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepth2DArray,
                typeF32Vec3$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureArraySample');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySample', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySample', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const ret = callBuiltin(pb, name, tex, sampler, coords, arrayIndex);
                if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const coordsComposit = pb.vec3(coords, pb.float(arrayIndex));
                return callBuiltin(pb, name, tex, coordsComposit);
            }
        }
    },
    // textureSampleBias(tex: PBShaderExp, coords: PBShaderExp, bias: number|PBShaderExp)
    textureSampleBias: {
        overloads: [
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleBias');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleBias', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleBias', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySampleBias(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, bias: number|PBShaderExp)
    textureArraySampleBias: {
        overloads: [
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleBias');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleBias', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySampleBias', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else if (pb.getDevice().type === 'webgl2') {
                pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const coordsComposit = pb.vec3(coords, pb.float(arrayIndex));
                return callBuiltin(pb, name, tex, coordsComposit, args[3]);
            }
        }
    },
    // textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp)
    textureSampleCompare: {
        overloads: [
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2D,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepthCube,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleCompare');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleCompare', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureSampleCompare', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(args[0], true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(args[0], true);
                let coordsComposite;
                if (texType.isCubeTexture() || texType.isArrayTexture()) {
                    coordsComposite = pb.vec4(args[1], args[2]);
                } else {
                    coordsComposite = pb.vec3(args[1], args[2]);
                }
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureArraySampleCompare(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp)
    textureArraySampleCompare: {
        overloads: [
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2DArray,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleCompare');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleCompare', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureArraySampleCompare', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(args[0], true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(args[0], true);
                const coordsComposite = pb.vec4(args[1], pb.float(args[2]), args[3]);
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureSampleLevel(tex: PBShaderExp, coords: PBShaderExp, level: number|PBShaderExp)
    textureSampleLevel: {
        overloads: [
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexExternal,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureCubeLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureCubeLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                if (texType.isExternalTexture()) {
                    return pb.textureLoad(tex, pb.ivec2(args[1]), 0);
                } else {
                    const sampler = pb.getDefaultSampler(tex, false);
                    const level = texType.isDepthTexture() && (typeof args[2] === 'number' || args[2] instanceof PBShaderExp && args[2].$ast.getType().isCompatibleType(typeF32$1)) ? pb.int(args[2]) : args[2];
                    const ret = texType.isExternalTexture() ? callBuiltin(pb, name, tex, sampler, args[1]) : callBuiltin(pb, name, tex, sampler, args[1], level);
                    if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                        return pb.vec4(ret);
                    } else {
                        return ret;
                    }
                }
            } else {
                pb.getDefaultSampler(tex, false);
                return texType.isExternalTexture() ? callBuiltin(pb, name, args[0], args[1], 0) : callBuiltin(pb, name, args[0], args[1], args[2]);
            }
        }
    },
    // textureArraySampleLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, level: number|PBShaderExp)
    textureArraySampleLevel: {
        overloads: [
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySampleLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const level = texType.isDepthTexture() && (typeof args[3] === 'number' || args[3] instanceof PBShaderExp && args[3].$ast.getType().isCompatibleType(typeF32$1)) ? pb.int(args[3]) : args[3];
                const ret = callBuiltin(pb, name, tex, sampler, args[1], args[2], level);
                if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                const coordsComposite = pb.vec3(args[1], pb.float(args[2]));
                return callBuiltin(pb, name, tex, coordsComposite, args[3]);
            }
        }
    },
    // textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp)
    textureSampleCompareLevel: {
        overloads: [
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2D,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepthCube,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleCompareLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleCompareLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureSampleCompareLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(args[0], true);
                let coordsComposite;
                if (texType.isCubeTexture() || texType.isArrayTexture()) {
                    coordsComposite = pb.vec4(args[1], args[2]);
                } else {
                    coordsComposite = pb.vec3(args[1], args[2]);
                }
                return texType.isCubeTexture() ? callBuiltin(pb, name, tex, coordsComposite) : callBuiltin(pb, name, tex, coordsComposite, 0);
            }
        }
    },
    // textureArraySampleCompareLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp)
    textureArraySampleCompareLevel: {
        overloads: [
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2DArray,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleCompareLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleCompareLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureArraySampleCompareLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(args[0], true);
                const coordsComposite = pb.vec4(args[1], pb.float(args[2]), args[3]);
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureSampleGrad(tex: PBShaderExp, coords: PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp)
    textureSampleGrad: {
        overloads: [
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('texture2DGradEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureCubeGradEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureSampleGrad');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleGrad', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleGrad', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySampleGrad(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp)
    textureArraySampleGrad: {
        overloads: [
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 5) {
                throw new PBParamLengthError('textureArraySampleGrad');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleGrad', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isArrayTexture()) {
                throw new PBParamTypeError('textureArraySampleGrad', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3], args[4]);
            } else {
                pb.getDefaultSampler(tex, false);
                const coordsComposite = pb.vec3(args[1], pb.float(args[2]));
                return callBuiltin(pb, name, tex, coordsComposite, args[3], args[4]);
            }
        }
    },
    storageBarrier: {
        overloads: genType('storageBarrier', MASK_WEBGPU, typeVoid, [])
    },
    workgroupBarrier: {
        overloads: genType('workgroupBarrier', MASK_WEBGPU, typeVoid, [])
    },
    atomicLoad: {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError(name);
            }
            const arg = args[0];
            if (!(arg instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg.$ast.getType().typeId === typeAtomicI32.typeId) {
                return pb.$callFunctionNoCheck(name, [
                    new ASTAddressOf(arg.$ast)
                ], typeI32$1);
            } else if (arg.$ast.getType().typeId === typeAtomicU32.typeId) {
                return pb.$callFunctionNoCheck(name, [
                    new ASTAddressOf(arg.$ast)
                ], typeU32$2);
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    },
    atomicStore: {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError(name);
            }
            const arg1 = args[0];
            const arg2 = args[1];
            if (!(arg1 instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg1.$ast.getType().typeId === typeAtomicI32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeI32$1)
                    ], typeVoid);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeI32$1.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeVoid);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else if (arg1.$ast.getType().typeId === typeAtomicU32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeU32$2)
                    ], typeVoid);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeU32$2.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeVoid);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    }
};
for (const name of [
    'atomicAdd',
    'atomicSub',
    'atomicMax',
    'atomicMin',
    'atomicAnd',
    'atomicOr',
    'atomicXor'
]){
    builtinFunctionsAll[name] = {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError(name);
            }
            const arg1 = args[0];
            const arg2 = args[1];
            if (!(arg1 instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg1.$ast.getType().typeId === typeAtomicI32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeI32$1)
                    ], typeI32$1);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeI32$1.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeI32$1);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else if (arg1.$ast.getType().typeId === typeAtomicU32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeU32$2)
                    ], typeU32$2);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeU32$2.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeU32$2);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    };
}
/** @internal */ function setBuiltinFuncs(cls) {
    for (const k of Object.keys(builtinFunctionsAll)){
        cls.prototype[k] = function(...args) {
            const normalizeFunc = builtinFunctionsAll?.[k]?.normalizeFunc || callBuiltin;
            return normalizeFunc(this, k, ...args);
        };
    }
}

const StorageTextureFormatMap = {
    rgba8unorm: 'rgba8unorm',
    rgba8snorm: 'rgba8snorm',
    rgba8uint: 'rgba8ui',
    rgba8sint: 'rgba8i',
    rgba16uint: 'rgba16ui',
    rgba16sint: 'rgba16i',
    rgba16float: 'rgba16f',
    r32float: 'r32f',
    r32uint: 'r32ui',
    r32sint: 'r32i',
    rg32float: 'rg32f',
    rg32uint: 'rg32ui',
    rg32sint: 'rg32i',
    rgba32float: 'rgba32f',
    rgba32uint: 'rgba32ui',
    rgba32sint: 'rgba32i'
};
function vec_n(vecType, ...args) {
    if (this.getDevice().type === 'webgl') {
        if (vecType.scalarType === PBPrimitiveType.U32) {
            throw new PBDeviceNotSupport('unsigned integer type');
        }
        if (vecType.isMatrixType() && vecType.cols !== vecType.rows) {
            throw new PBDeviceNotSupport('non-square matrix type');
        }
    }
    if (args.length === 1 && typeof args[0] === 'string') {
        return new PBShaderExp(args[0], vecType);
    } else {
        const exp = new PBShaderExp('', vecType);
        if (vecType.isScalarType() && args.length === 1 && (typeof args[0] === 'number' || typeof args[0] === 'boolean')) {
            exp.$ast = new ASTScalar(args[0], vecType);
        } else {
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, args.map((arg)=>{
                if (typeof arg === 'string') {
                    throw new PBParamTypeError('vec_n');
                }
                return arg instanceof PBShaderExp ? arg.$ast : arg;
            }));
        }
        return exp;
    }
}
const primitiveCtors = {
    float: typeF32$1,
    int: typeI32$1,
    uint: typeU32$2,
    bool: typeBool,
    vec2: typeF32Vec2$1,
    ivec2: typeI32Vec2$1,
    uvec2: typeU32Vec2$1,
    bvec2: typeBVec2,
    vec3: typeF32Vec3$1,
    ivec3: typeI32Vec3$1,
    uvec3: typeU32Vec3$1,
    bvec3: typeBVec3,
    vec4: typeF32Vec4$1,
    ivec4: typeI32Vec4$1,
    uvec4: typeU32Vec4$1,
    bvec4: typeBVec4,
    mat2: typeMat2,
    mat2x3: typeMat2x3,
    mat2x4: typeMat2x4,
    mat3x2: typeMat3x2,
    mat3: typeMat3,
    mat3x4: typeMat3x4,
    mat4x2: typeMat4x2,
    mat4x3: typeMat4x3,
    mat4: typeMat4
};
const simpleCtors = {
    tex1D: typeTex1D,
    tex2D: typeTex2D,
    tex3D: typeTex3D,
    texCube: typeTexCube,
    tex2DShadow: typeTexDepth2D,
    texCubeShadow: typeTexDepthCube,
    tex2DArray: typeTex2DArray,
    tex2DArrayShadow: typeTexDepth2DArray,
    texExternal: typeTexExternal,
    itex1D: typeITex1D,
    itex2D: typeITex2D,
    itex3D: typeITex3D,
    itexCube: typeITexCube,
    itex2DArray: typeITex2DArray,
    utex1D: typeUTex1D,
    utex2D: typeUTex2D,
    utex3D: typeUTex3D,
    utexCube: typeUTexCube,
    utex2DArray: typeUTex2DArray,
    sampler: typeSampler,
    samplerComparison: typeSamplerComparison
};
function makeStorageTextureCtor(type) {
    const ctor = {};
    for (const k of Object.keys(StorageTextureFormatMap)){
        ctor[k] = function(rhs) {
            return new PBShaderExp(rhs, new PBTextureTypeInfo(type, StorageTextureFormatMap[k]));
        };
    }
    return ctor;
}
const texStorageCtors = {
    texStorage1D: PBTextureType.TEX_STORAGE_1D,
    texStorage2D: PBTextureType.TEX_STORAGE_2D,
    texStorage2DArray: PBTextureType.TEX_STORAGE_2D_ARRAY,
    texStorage3D: PBTextureType.TEX_STORAGE_3D
};
/** @internal */ function setConstructors(cls) {
    Object.keys(primitiveCtors).forEach((k)=>{
        cls.prototype[k] = makeConstructor(function(...args) {
            return vec_n.call(this, primitiveCtors[k], ...args);
        }, primitiveCtors[k]);
    });
    Object.keys(simpleCtors).forEach((k)=>{
        cls.prototype[k] = function(rhs) {
            return new PBShaderExp(rhs, simpleCtors[k]);
        };
    });
    Object.keys(texStorageCtors).forEach((k)=>{
        cls.prototype[k] = makeStorageTextureCtor(texStorageCtors[k]);
    });
    cls.prototype['atomic_int'] = function(...args) {
        if (args.length > 1) {
            throw new PBParamLengthError('atomic_int');
        }
        if (args.length === 1) {
            if (typeof args[0] !== 'string') {
                throw new PBParamTypeError('atomic_int', 'name');
            }
            return new PBShaderExp(args[0], typeAtomicI32);
        } else {
            const exp = new PBShaderExp('', typeAtomicI32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, []);
            return exp;
        }
    };
    cls.prototype['atomic_uint'] = function(...args) {
        if (args.length > 1) {
            throw new PBParamLengthError('atomic_uint');
        }
        if (args.length === 1 && typeof args[0] === 'string') {
            return new PBShaderExp(args[0], typeAtomicU32);
        } else if (args.length === 0) {
            const exp = new PBShaderExp('', typeAtomicU32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, []);
            return exp;
        }
        const arg = args[0];
        if (typeof arg === 'number' && Number.isInteger(arg) || arg instanceof PBShaderExp && arg.$ast.getType().typeId === typeU32$2.typeId) {
            const exp = new PBShaderExp('', typeAtomicU32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, [
                arg instanceof PBShaderExp ? arg.$ast : arg
            ]);
            return exp;
        }
        return null;
    };
} /*
ProgramBuilder.prototype.texStorage1D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_1D);
ProgramBuilder.prototype.texStorage2D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_2D);
ProgramBuilder.prototype.texStorage2DArray = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_2D_ARRAY);
ProgramBuilder.prototype.texStorage3D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_3D);
*/

const COMPUTE_UNIFORM_NAME = 'ch_compute_uniform_block';
const COMPUTE_STORAGE_NAME = 'ch_compute_storage_block';
const VERTEX_UNIFORM_NAME = 'ch_vertex_uniform_block';
const FRAGMENT_UNIFORM_NAME = 'ch_fragment_uniform_block';
const SHARED_UNIFORM_NAME = 'ch_shared_uniform_block';
const VERTEX_STORAGE_NAME = 'ch_vertex_storage_block';
const FRAGMENT_STORAGE_NAME = 'ch_fragment_storage_block';
const SHARED_STORAGE_NAME = 'ch_shared_storage_block';
const input_prefix = 'uu_in_';
const output_prefix_vs = 'uu_vsout_';
const output_prefix_fs = 'uu_fsout_';
/**
 * The program builder class
 * @public
 */ class ProgramBuilder {
    /** @internal */ _device;
    /** @internal */ _workgroupSize;
    /** @internal */ _scopeStack = [];
    /** @internal */ _shaderType = ShaderType.Vertex | ShaderType.Fragment | ShaderType.Compute;
    /** @internal */ _structInfo;
    /** @internal */ _uniforms;
    /** @internal */ _globalScope;
    /** @internal */ _builtinScope;
    /** @internal */ _inputScope;
    /** @internal */ _outputScope;
    /** @internal */ _inputs;
    /** @internal */ _outputs;
    /** @internal */ _vertexAttributes;
    /** @internal */ _depthRangeCorrection;
    /** @internal */ _emulateDepthClamp;
    /** @internal */ _lastError;
    /** @internal */ _reflection;
    /** @internal */ _autoStructureTypeIndex;
    /** @internal */ _nameMap;
    /**
   * Creates a program builder for given device
   * @param device - The device
   */ constructor(device){
        this._device = device;
        this._workgroupSize = null;
        this._structInfo = {};
        this._uniforms = [];
        this._scopeStack = [];
        this._globalScope = null;
        this._builtinScope = null;
        this._inputScope = null;
        this._outputScope = null;
        this._inputs = [];
        this._outputs = [];
        this._vertexAttributes = [];
        this._depthRangeCorrection = device.type === 'webgpu';
        this._emulateDepthClamp = false;
        this._lastError = null;
        this._reflection = new PBReflection(this);
        this._autoStructureTypeIndex = 0;
        this._nameMap = [];
    }
    /** Get last error */ get lastError() {
        return this._lastError;
    }
    /** @internal */ get shaderType() {
        return this._shaderType;
    }
    /** Current shader kind */ get shaderKind() {
        return this._shaderType === ShaderType.Vertex ? 'vertex' : this._shaderType === ShaderType.Fragment ? 'fragment' : this._shaderType === ShaderType.Compute ? 'compute' : null;
    }
    /** Gets the global scope */ getGlobalScope() {
        return this._globalScope;
    }
    /** @internal */ get builtinScope() {
        return this._builtinScope;
    }
    /** @internal */ get inputScope() {
        return this._inputScope;
    }
    /** @internal */ get outputScope() {
        return this._outputScope;
    }
    /** @internal */ get depthRangeCorrection() {
        return this._depthRangeCorrection;
    }
    get emulateDepthClamp() {
        return this._emulateDepthClamp;
    }
    set emulateDepthClamp(val) {
        this._emulateDepthClamp = val;
    }
    /** Get the shader code reflection interface */ getReflection() {
        return this._reflection;
    }
    /** Get the device */ getDevice() {
        return this._device;
    }
    /** @internal */ reset() {
        this._workgroupSize = null;
        this._structInfo = {};
        this._uniforms = [];
        this._scopeStack = [];
        this._globalScope = null;
        this._builtinScope = null;
        this._inputScope = null;
        this._outputScope = null;
        this._inputs = [];
        this._outputs = [];
        this._vertexAttributes = [];
        this._depthRangeCorrection = this._device.type === 'webgpu';
        this._reflection = new PBReflection(this);
        this._autoStructureTypeIndex = 0;
        this._nameMap = [];
    }
    /**
   * Query the global variable by the name
   * @param name - Name of the variable
   * @returns The variable or null if not exists
   */ queryGlobal(name) {
        return this.getReflection().tag(name);
    }
    /** @internal */ pushScope(scope) {
        this._scopeStack.unshift(scope);
    }
    /** @internal */ popScope() {
        return this._scopeStack.shift();
    }
    /** Gets the current scope */ getCurrentScope() {
        return this._scopeStack[0];
    }
    /**
   * Generates shader codes for a render program
   * @param options - The build options
   * @returns a tuple made by vertex shader source, fragment shader source, bind group layouts and vertex attributes used, or null if build faild
   */ buildRender(options) {
        setCurrentProgramBuilder(this);
        this._lastError = null;
        this.defineInternalStructs();
        const ret = this.buildRenderSource(options);
        setCurrentProgramBuilder(null);
        this.reset();
        return ret;
    }
    /**
   * Generates shader code for a compute program
   * @param options - The build programs
   * @returns a tuple made by compute shader source and bind group layouts, or null if build failed
   */ buildCompute(options) {
        setCurrentProgramBuilder(this);
        this._lastError = null;
        this._workgroupSize = options.workgroupSize;
        this.defineInternalStructs();
        const ret = this.buildComputeSource(options);
        setCurrentProgramBuilder(null);
        this.reset();
        return ret;
    }
    /**
   * Creates a shader program for render
   * @param options - The build options
   * @returns The created program or null if build failed
   */ buildRenderProgram(options) {
        const ret = this.buildRender(options);
        return ret ? this._device.createGPUProgram({
            type: 'render',
            label: options.label,
            params: {
                vs: ret[0],
                fs: ret[1],
                bindGroupLayouts: ret[2],
                vertexAttributes: ret[3]
            }
        }) : null;
    }
    /**
   * Creates a shader program for compute
   * @param options - The build options
   * @returns The created program or null if build failed
   */ buildComputeProgram(options) {
        const ret = this.buildCompute(options);
        return ret ? this._device.createGPUProgram({
            type: 'compute',
            params: {
                source: ret[0],
                bindGroupLayouts: ret[1]
            }
        }) : null;
    }
    /**
   * Creates a function
   * @param name - Name of the function
   * @param params - Parameters of the function
   * @param body - The generator function
   */ func(name, params, body) {
        this.getGlobalScope().$createFunctionIfNotExists(name, params, body);
    }
    /**
   * Create the main entry function of the shader
   * @param body - The shader generator function
   */ main(body) {
        this.getGlobalScope().$mainFunc(body);
    }
    /**
   * Create an 'AddressOf' expression for WGSL
   * @param ref - The reference variable
   * @returns the 'AddressOf' expression
   */ addressOf(ref) {
        if (this._device.type !== 'webgpu') {
            throw new PBDeviceNotSupport('pointer shader type');
        }
        if (!ref.$ast.isReference()) {
            throw new PBReferenceValueRequired(ref);
        }
        const exp = new PBShaderExp('', ref.$ast.getType());
        exp.$ast = new ASTAddressOf(ref.$ast);
        return exp;
    }
    /**
   * Creates a 'referenceOf' expression for WGSL
   * @param ptr - The pointer variable
   * @returns the 'referenceOf' expression
   */ referenceOf(ptr) {
        if (this._device.type !== 'webgpu') {
            throw new PBDeviceNotSupport('pointer shader type');
        }
        if (!ptr.$ast.getType().isPointerType()) {
            throw new PBPointerValueRequired(ptr);
        }
        const ast = new ASTReferenceOf(ptr.$ast);
        const exp = new PBShaderExp('', ast.getType());
        exp.$ast = ast;
        return exp;
    }
    /**
   * Creates a structure type variable
   * @param structName - Name of the structure type
   * @param instanceName - Name of the variable
   * @returns the created variable
   */ struct(structName, instanceName) {
        let ctor = null;
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & this._shaderType) {
                const structInfo = this._structInfo[st];
                ctor = structInfo?.structs[structName];
                if (ctor) {
                    break;
                }
            }
        }
        if (!ctor) {
            throw new PBParamValueError('struct', 'structName', `Struct type ${structName} not exists`);
        }
        return ctor.call(this, instanceName);
    }
    /** @internal */ isIdenticalStruct(a, b, checkName) {
        if (checkName && a.structName && b.structName && a.structName !== b.structName) {
            return false;
        }
        if (a.structMembers.length !== b.structMembers.length) {
            return false;
        }
        for(let index = 0; index < a.structMembers.length; index++){
            const val = a.structMembers[index];
            const other = b.structMembers[index];
            if (val.name !== other.name) {
                return false;
            }
            if (val.type.isStructType()) {
                if (!other.type.isStructType()) {
                    return false;
                }
                if (!this.isIdenticalStruct(val.type, other.type, true)) {
                    return false;
                }
            } else if (!val.type.isCompatibleType(other.type)) {
                return false;
            }
        }
        return true;
    }
    /** @internal */ generateStructureName() {
        return `uu_GeneratedStruct${this._autoStructureTypeIndex++}`;
    }
    /** @internal */ getVertexAttributes() {
        return this._vertexAttributes;
    }
    /** @internal */ defineHiddenStruct(type) {
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structInfo = this._structInfo[shaderType];
            if (!structInfo) {
                structInfo = {
                    structs: {},
                    types: []
                };
                this._structInfo[shaderType] = structInfo;
            }
            if (structInfo.structs[type.structName]) {
                throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${type.structName}'`);
            }
            structInfo.types.push(new ASTStructDefine(type, true));
        }
    }
    // /**
    //  * Defines an uniform buffer
    //  * @param name - Name of the uniform buffer
    //  * @param args - Members of the buffer structure
    //  * @returns The structure type constructor
    //  */
    // defineUniformBuffer(name: string, ...args: PBShaderExp[]): ShaderTypeFunc {
    //   return this.defineStructOrUniformBuffer(name, 'std140', ...args);
    // }
    // /**
    //  * Defines a structure type
    //  * @param structName - Name of the type
    //  * @param layout - The structure layout
    //  * @param args - Members of the structure
    //  * @returns The structure type constructor
    //  */
    // defineStruct(structName: string, ...args: PBShaderExp[]): ShaderTypeFunc {
    //   return this.defineStructOrUniformBuffer(structName, 'default', ...args);
    // }
    /**
   * Defines a structure type
   * @param members - Members of the structure
   * @param structName - Name of the type
   * @returns The structure type constructor
   */ defineStruct(members, structName) {
        const layout = 'default';
        const structType = new PBStructTypeInfo(structName ?? '', layout, members.map((arg)=>{
            if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType() && !arg.$typeinfo.isAtomicI32() && !arg.$typeinfo.isAtomicU32()) {
                throw new Error(`invalid struct member type: '${arg.$str}'`);
            }
            return {
                name: arg.$str,
                type: arg.$typeinfo
            };
        }));
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structDef = null;
            let ctor = null;
            const structInfo = this._structInfo[shaderType];
            if (structInfo) {
                if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[structType.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);
                }
                for (const type of structInfo.types){
                    if (!type.builtin && this.isIdenticalStruct(type.getType(), structType, false)) {
                        structDef = type;
                        ctor = structInfo.structs[type.getType().structName];
                        break;
                    }
                }
            }
            if (structDef) {
                if (structDef.type.layout !== layout) {
                    throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);
                }
                if (shaderType !== getCurrentProgramBuilder().shaderType) {
                    if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {
                        this._structInfo[getCurrentProgramBuilder().shaderType] = {
                            structs: {},
                            types: []
                        };
                    }
                    if (this._structInfo[getCurrentProgramBuilder().shaderType].types.indexOf(structDef) < 0) {
                        this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);
                        this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;
                    }
                }
                return ctor;
            }
        }
        return this.internalDefineStruct(structName ?? this.generateStructureName(), layout, this._shaderType, false, ...members);
    }
    /**
   * Defines a structure type
   * @param structType - The structure type info
   * @returns The structure type constructor
   */ defineStructByType(structType) {
        const typeCopy = structType.extends(structType.structName || this.generateStructureName(), []);
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structDef = null;
            let ctor = null;
            const structInfo = this._structInfo[shaderType];
            if (structInfo) {
                if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[typeCopy.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${typeCopy.structName}'`);
                }
                for (const type of structInfo.types){
                    if (!type.builtin && this.isIdenticalStruct(type.getType(), typeCopy, false)) {
                        structDef = type;
                        ctor = structInfo.structs[type.getType().structName];
                        break;
                    }
                }
            }
            if (structDef) {
                if (structDef.type.layout !== typeCopy.layout) {
                    throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);
                }
                if (shaderType !== getCurrentProgramBuilder().shaderType) {
                    if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {
                        this._structInfo[getCurrentProgramBuilder().shaderType] = {
                            structs: {},
                            types: []
                        };
                    }
                    this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);
                    this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;
                }
                return ctor;
            }
        }
        return this.internalDefineStructByType(this._shaderType, false, typeCopy);
    }
    /** @internal */ internalDefineStruct(structName, layout, shaderTypeMask, builtin, ...args) {
        const structType = new PBStructTypeInfo(structName, layout, args.map((arg)=>{
            if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType() && !arg.$typeinfo.isAtomicI32() && !arg.$typeinfo.isAtomicU32()) {
                throw new Error(`invalid struct member type: '${arg.$str}'`);
            }
            return {
                name: arg.$str,
                type: arg.$typeinfo
            };
        }));
        return this.internalDefineStructByType(shaderTypeMask, builtin, structType);
    }
    /** @internal */ internalDefineStructByType(shaderTypeMask, builtin, structType) {
        const struct = makeConstructor(function structConstructor(...blockArgs) {
            let e;
            if (blockArgs.length === 1 && typeof blockArgs[0] === 'string') {
                e = new PBShaderExp(blockArgs[0], structType);
            } else {
                e = new PBShaderExp('', structType);
                e.$ast = new ASTShaderExpConstructor(e.$typeinfo, blockArgs.map((arg)=>arg instanceof PBShaderExp ? arg.$ast : arg));
            }
            return e;
        }, structType);
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (shaderTypeMask & shaderType) {
                let structInfo = this._structInfo[shaderType];
                if (!structInfo) {
                    structInfo = {
                        structs: {},
                        types: []
                    };
                    this._structInfo[shaderType] = structInfo;
                }
                if (structInfo.structs[structType.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);
                }
                structInfo.types.push(new ASTStructDefine(structType, builtin));
                structInfo.structs[structType.structName] = struct;
            }
        }
        // this.changeStructLayout(structType, layout);
        return struct;
    }
    /** @internal */ getFunction(name) {
        return this._globalScope ? this._globalScope.$getFunctions(name) : null;
    }
    /** @internal */ get structInfo() {
        return this._structInfo[this._shaderType];
    }
    /** @internal */ getBlockName(instanceName) {
        return `ch_block_name_${instanceName}`;
    }
    /** @internal */ defineBuiltinStruct(shaderType, inOrOut) {
        const structName = inOrOut === 'in' ? getBuiltinInputStructName(shaderType) : getBuiltinOutputStructName(shaderType);
        const instanceName = inOrOut === 'in' ? getBuiltinInputStructInstanceName(shaderType) : getBuiltinOutputStructInstanceName(shaderType);
        const stage = shaderType === ShaderType.Vertex ? 'vertex' : shaderType === ShaderType.Fragment ? 'fragment' : 'compute';
        const builtinVars = builtinVariables['webgpu'];
        const args = [];
        const prefix = [];
        for(const k in builtinVars){
            if (builtinVars[k].stage === stage && builtinVars[k].inOrOut === inOrOut) {
                args.push({
                    name: builtinVars[k].name,
                    type: builtinVars[k].type
                });
                prefix.push(`@builtin(${builtinVars[k].semantic}) `);
            }
        }
        const inoutList = inOrOut === 'in' ? this._inputs : this._outputs;
        for (const k of inoutList){
            // for debug only
            if (!(k[1] instanceof ASTDeclareVar)) {
                throw new PBInternalError('defineBuiltinStruct() failed: input/output is not declare var ast node');
            }
            const type = k[1].value.getType();
            if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {
                throw new Error(`invalid in/out variable type: '${k[1].value.name}'`);
            }
            args.push({
                name: k[1].value.name,
                type: type
            });
            prefix.push(`@location(${k[1].value.value.$location}) ${type.isPrimitiveType() && type.isInteger() ? '@interpolate(flat) ' : ''}`);
        }
        if (args.length > 0) {
            const st = this.findStructType(structName, shaderType);
            if (st) {
                st.getType().reset(structName, 'default', args);
                st.prefix = prefix;
                return null;
            } else {
                const structType = this.internalDefineStructByType(this._shaderType, false, new PBStructTypeInfo(structName, 'default', args));
                this.findStructType(structName, shaderType).prefix = prefix;
                const structInstance = this.struct(structName, instanceName);
                const structInstanceIN = inOrOut === 'in' ? this.struct(structName, 'uu_AppInput') : structInstance;
                return [
                    structType,
                    structInstance,
                    structName,
                    structInstanceIN
                ];
            }
        } else {
            return null;
        }
    }
    /** @internal */ defineInternalStructs() {
        this.defineHiddenStruct(typeFrexpResult);
        this.defineHiddenStruct(typeFrexpResultVec2);
        this.defineHiddenStruct(typeFrexpResultVec3);
        this.defineHiddenStruct(typeFrexpResultVec4);
    }
    /** @internal */ array(...args) {
        if (args.length === 0) {
            throw new PBParamLengthError('array');
        }
        args = args.map((arg)=>this.normalizeExpValue(arg));
        let typeok = true;
        let type = null;
        let isBool = true;
        let isFloat = true;
        let isInt = true;
        let isUint = true;
        let isComposite = false;
        for (const arg of args){
            if (arg instanceof PBShaderExp) {
                const argType = arg.$ast.getType();
                if (!argType.isConstructible()) {
                    typeok = false;
                    break;
                }
                if (!type) {
                    type = argType;
                } else if (!argType.isCompatibleType(type)) {
                    typeok = false;
                }
            }
        }
        if (typeok) {
            if (type && type.isPrimitiveType() && type.isScalarType()) {
                isBool = type.primitiveType === PBPrimitiveType.BOOL;
                isFloat = type.primitiveType === PBPrimitiveType.F32;
                isUint = type.primitiveType === PBPrimitiveType.U32;
                isInt = type.primitiveType === PBPrimitiveType.I32;
            } else if (type) {
                isBool = false;
                isFloat = false;
                isUint = false;
                isInt = false;
                isComposite = true;
            }
            for (const arg of args){
                if (!(arg instanceof PBShaderExp) && isComposite) {
                    typeok = false;
                    break;
                }
                if (typeof arg === 'number') {
                    isBool = false;
                    if ((arg | 0) === arg) {
                        if (arg < 0) {
                            isUint = false;
                            isInt = isInt && arg >= 0x80000000 >> 0;
                        } else {
                            isUint = isUint && arg <= 0xffffffff;
                            isInt = isInt && arg <= 0x7fffffff;
                        }
                    }
                } else if (typeof arg === 'boolean') {
                    isFloat = false;
                    isInt = false;
                    isUint = false;
                }
            }
        }
        if (typeok && !isComposite) {
            if (isBool) {
                type = typeBool;
            } else if (isInt) {
                type = typeI32$1;
            } else if (isUint) {
                type = typeU32$2;
            } else if (isFloat) {
                type = typeF32$1;
            }
            typeok = !!type;
        }
        if (!typeok) {
            throw new PBParamTypeError('array');
        }
        if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {
            throw new PBParamTypeError('array');
        }
        const arrayType = new PBArrayTypeInfo(type, args.length);
        const exp = new PBShaderExp('', arrayType);
        exp.$ast = new ASTShaderExpConstructor(arrayType, args.map((arg)=>{
            if (arg instanceof PBShaderExp) {
                return arg.$ast;
            }
            if (!type.isPrimitiveType() || !type.isScalarType()) {
                throw new PBTypeCastError(arg, typeof arg, type);
            }
            return new ASTScalar(arg, type);
        }));
        return exp;
    }
    /**
   * Creates a 'discard' statement
   */ discard() {
        this.getCurrentScope().$ast.statements.push(new ASTDiscard());
    }
    /** @internal */ tagShaderExp(getter, tagValue) {
        if (typeof tagValue === 'string') {
            this._reflection.tag(tagValue, getter);
        } else if (Array.isArray(tagValue)) {
            tagValue.forEach((tag)=>this.tagShaderExp(getter, tag));
        } else {
            for (const k of Object.keys(tagValue)){
                this.tagShaderExp((scope)=>{
                    const value = getter(scope);
                    return value[k];
                }, tagValue[k]);
            }
        }
    }
    /** @internal */ in(location, name, variable) {
        if (this._inputs[location]) {
            throw new Error(`input location ${location} already declared`);
        }
        variable.$location = location;
        variable.$declareType = DeclareType.DECLARE_TYPE_IN;
        this._inputs[location] = [
            name,
            new ASTDeclareVar(new ASTPrimitive(variable))
        ];
        Object.defineProperty(this._inputScope, name, {
            get: function() {
                return variable;
            },
            set: function() {
                throw new Error(`cannot assign to readonly variable: ${name}`);
            }
        });
        variable.$tags.forEach((val)=>this.tagShaderExp(()=>variable, val));
    }
    /** @internal */ out(location, name, variable) {
        if (this._outputs[location]) {
            throw new Error(`output location ${location} has already been used`);
        }
        variable.$location = location;
        variable.$declareType = DeclareType.DECLARE_TYPE_OUT;
        this._outputs[location] = [
            name,
            new ASTDeclareVar(new ASTPrimitive(variable))
        ];
        Object.defineProperty(this._outputScope, name, {
            get: function() {
                return variable;
            },
            set: function(v) {
                getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(variable.$ast), v instanceof PBShaderExp ? v.$ast : v));
            }
        });
    }
    /** @internal */ getDefaultSampler(t, comparison) {
        const u = this._uniforms.findIndex((val)=>val.texture?.exp === t);
        if (u < 0) {
            return;
        //throw new Error('invalid texture uniform object');
        }
        const samplerType = comparison ? 'comparison' : 'sample';
        if (this._uniforms[u].texture.autoBindSampler && this._uniforms[u].texture.autoBindSampler !== samplerType) {
            throw new Error('multiple sampler not supported');
        }
        this._uniforms[u].texture.autoBindSampler = samplerType;
        if (this._device.type === 'webgpu') {
            const samplerName = genSamplerName(t.$str, comparison);
            if (!this.getGlobalScope()[samplerName]) {
                throw new Error(`failed to find sampler name ${samplerName}`);
            }
            return this.getGlobalScope()[samplerName];
        } else {
            return null;
        }
    }
    /** @internal */ normalizeExpValue(value) {
        if (Array.isArray(value)) {
            const converted = value.map((val)=>Array.isArray(val) ? this.normalizeExpValue(val) : val);
            return this.array(...converted);
        } else {
            return value;
        }
    }
    /** @internal */ guessExpValueType(value) {
        const val = this.normalizeExpValue(value);
        if (typeof val === 'boolean') {
            return typeBool;
        } else if (typeof val === 'number') {
            if (!Number.isInteger(val)) {
                return typeF32$1;
            } else if (val >= 0x80000000 >> 1 && val <= 0x7fffffff) {
                return typeI32$1;
            } else if (val >= 0 && val <= 0xffffffff) {
                return typeU32$2;
            } else {
                throw new PBValueOutOfRange(val);
            }
        } else if (val instanceof PBShaderExp) {
            return val.$ast?.getType() || val.$typeinfo;
        }
    }
    /** @internal */ findStructType(name, shaderType) {
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & shaderType) {
                const structInfo = this._structInfo[st];
                if (structInfo) {
                    for (const t of structInfo.types){
                        if (t.type.structName === name) {
                            return t;
                        }
                    }
                }
            }
        }
        return null;
    }
    /** @internal */ findStructConstructor(name, shaderType) {
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & shaderType) {
                const structInfo = this._structInfo[st];
                if (structInfo && structInfo.structs?.[name]) {
                    return structInfo.structs[name];
                }
            }
        }
        return null;
    }
    /** @internal */ buildComputeSource(options) {
        try {
            this._lastError = null;
            this._shaderType = ShaderType.Compute;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            this.generate(options.compute);
            // this.removeUnusedSamplerBindings(this._globalScope);
            this.mergeUniformsCompute(this._globalScope);
            this.updateUniformBindings([
                this._globalScope
            ], [
                ShaderType.Compute
            ]);
            return [
                this.generateComputeSource(this._globalScope, this._builtinScope),
                this.createBindGroupLayouts(options.label)
            ];
        } catch (err) {
            if (err instanceof PBError) {
                this._lastError = err.getMessage(this._device.type);
                console.error(this._lastError);
                return null;
            } else if (err instanceof Error) {
                this._lastError = err.toString();
                console.error(this._lastError);
                return null;
            } else {
                this._lastError = Object.prototype.toString.call(err);
                console.log(`Error: ${this._lastError}`);
                return null;
            }
        }
    }
    /** @internal */ buildRenderSource(options) {
        try {
            this._lastError = null;
            this._shaderType = ShaderType.Vertex;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            this.generate(options.vertex);
            const vertexScope = this._globalScope;
            const vertexBuiltinScope = this._builtinScope;
            const vertexInputs = this._inputs;
            const vertexOutputs = this._outputs;
            if (this._device.type === 'webgpu') {
            // this.removeUnusedSamplerBindings(vertexScope);
            }
            this._shaderType = ShaderType.Fragment;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            vertexOutputs.forEach((val, index)=>{
                this.in(index, val[0], new PBShaderExp(val[1].value.name, val[1].value.getType()).tag(...val[1].value.value.$tags));
            });
            this.generate(options.fragment);
            const fragScope = this._globalScope;
            const fragBuiltinScope = this._builtinScope;
            const fragInputs = this._inputs;
            const fragOutputs = this._outputs;
            if (this._device.type === 'webgpu') {
            // this.removeUnusedSamplerBindings(fragScope);
            }
            this.mergeUniforms(vertexScope, fragScope);
            this.updateUniformBindings([
                vertexScope,
                fragScope
            ], [
                ShaderType.Vertex,
                ShaderType.Fragment
            ]);
            return [
                this.generateRenderSource(ShaderType.Vertex, vertexScope, vertexBuiltinScope, vertexInputs.map((val)=>val[1]), vertexOutputs.map((val)=>val[1])),
                this.generateRenderSource(ShaderType.Fragment, fragScope, fragBuiltinScope, fragInputs.map((val)=>val[1]), fragOutputs.map((val)=>val[1])),
                this.createBindGroupLayouts(options.label),
                this._vertexAttributes
            ];
        } catch (err) {
            if (err instanceof PBError) {
                this._lastError = err.getMessage(this._device.type);
                console.error(this._lastError);
                return null;
            } else if (err instanceof Error) {
                this._lastError = err.toString();
                console.error(this._lastError);
                return null;
            } else {
                this._lastError = Object.prototype.toString.call(err);
                console.log(`Error: ${this._lastError}`);
                return null;
            }
        }
    }
    /** @internal */ generate(body) {
        this.pushScope(this._globalScope);
        if (this._emulateDepthClamp && this._shaderType === ShaderType.Vertex) {
            this._globalScope.$outputs.clamppedDepth = this.float().tag('CLAMPPED_DEPTH');
        }
        body && body.call(this._globalScope, this);
        this.popScope();
    }
    /** @internal */ generateRenderSource(shaderType, scope, builtinScope, inputs, outputs) {
        const context = {
            type: shaderType,
            mrt: shaderType === ShaderType.Fragment && outputs.length > 1,
            defines: [],
            extensions: new Set(),
            builtins: [
                ...builtinScope.$_usedBuiltins
            ],
            types: this._structInfo[shaderType]?.types || [],
            typeReplacement: new Map(),
            inputs: inputs,
            outputs: outputs,
            global: scope,
            vertexAttributes: this._vertexAttributes,
            workgroupSize: null
        };
        switch(this._device.type){
            case 'webgl':
                for (const u of this._uniforms){
                    if (u.texture) {
                        const type = u.texture.exp.$ast.getType();
                        if (type.isTextureType() && type.isDepthTexture()) {
                            if (u.texture.autoBindSampler === 'comparison') {
                                throw new PBDeviceNotSupport('depth texture comparison');
                            }
                            if (u.texture.autoBindSampler === 'sample') {
                                if (type.is2DTexture()) {
                                    context.typeReplacement.set(u.texture.exp, typeTex2D);
                                } else if (type.isCubeTexture()) {
                                    context.typeReplacement.set(u.texture.exp, typeTexCube);
                                }
                            }
                        }
                    }
                }
                return scope.$ast.toWebGL('', context);
            case 'webgl2':
                for (const u of this._uniforms){
                    if (u.texture) {
                        const type = u.texture.exp.$ast.getType();
                        if (type.isTextureType() && type.isDepthTexture() && u.texture.autoBindSampler === 'sample') {
                            if (type.is2DTexture()) {
                                context.typeReplacement.set(u.texture.exp, type.isArrayTexture() ? typeTex2DArray : typeTex2D);
                            } else if (type.isCubeTexture()) {
                                context.typeReplacement.set(u.texture.exp, typeTexCube);
                            }
                        }
                    }
                }
                return scope.$ast.toWebGL2('', context);
            case 'webgpu':
                return scope.$ast.toWGSL('', context);
            default:
                return null;
        }
    }
    /** @internal */ generateComputeSource(scope, builtinScope) {
        const context = {
            type: ShaderType.Compute,
            mrt: false,
            defines: [],
            extensions: new Set(),
            builtins: [
                ...builtinScope.$_usedBuiltins
            ],
            types: this._structInfo[ShaderType.Compute]?.types || [],
            typeReplacement: null,
            inputs: [],
            outputs: [],
            global: scope,
            vertexAttributes: [],
            workgroupSize: this._workgroupSize
        };
        return scope.$ast.toWGSL('', context);
    }
    /** @internal */ mergeUniformsCompute(globalScope) {
        const uniformList = [];
        for(let i = 0; i < this._uniforms.length; i++){
            const u = this._uniforms[i];
            if (u.block && (u.block.exp.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || u.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE)) {
                if (u.block.exp.$typeinfo.isStructType() && u.block.exp.$isBuffer) {
                    continue;
                }
                if (!uniformList[u.group]) {
                    uniformList[u.group] = [];
                }
                const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                exp.$declareType = u.block.exp.$declareType;
                exp.$isBuffer = u.block.exp.$isBuffer;
                uniformList[u.group].push({
                    member: exp,
                    uniform: i
                });
            }
        }
        for(const k in uniformList){
            if (uniformList[k].length > 0) {
                const types = [
                    'std140',
                    'std430'
                ];
                const nameList = [
                    COMPUTE_UNIFORM_NAME,
                    COMPUTE_STORAGE_NAME
                ];
                const ulist = [
                    uniformList[k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_UNIFORM),
                    uniformList[k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_STORAGE)
                ];
                for(let i = 0; i < 2; i++){
                    if (ulist[i].length === 0) {
                        continue;
                    }
                    const nonBufferList = ulist[i].filter((val)=>!val.member.$isBuffer);
                    const bufferList = ulist[i].filter((val)=>val.member.$isBuffer);
                    const allLists = [
                        nonBufferList,
                        ...bufferList.map((val)=>[
                                val
                            ])
                    ];
                    for(let p = 0; p < allLists.length; p++){
                        if (allLists[p].length === 0) {
                            continue;
                        }
                        const uname = `${nameList[i]}_${k}_${p}`;
                        const structName = this.generateStructureName();
                        const t = getCurrentProgramBuilder().internalDefineStruct(structName, types[i], ShaderType.Compute, false, ...allLists[p].map((val)=>val.member));
                        const exp = t();
                        if (i === 0) {
                            exp.uniformBuffer(Number(k));
                        } else {
                            exp.storageBuffer(Number(k));
                        }
                        globalScope[uname] = exp;
                        const index = this._uniforms.findIndex((val)=>val.block?.name === uname);
                        this._uniforms[index].mask = ShaderType.Compute;
                        let nameMap = this._nameMap[Number(k)];
                        if (!nameMap) {
                            nameMap = {};
                            this._nameMap[Number(k)] = nameMap;
                        }
                        let writable = false;
                        for(let n = allLists[p].length - 1; n >= 0; n--){
                            const u = allLists[p][n];
                            const exp = this._uniforms[u.uniform].block.exp;
                            nameMap[exp.$str] = uname;
                            exp.$str = `${uname}.${exp.$str}`;
                            writable ||= exp.$ast.isWritable();
                        }
                        if (writable) {
                            globalScope[uname].$ast.markWritable();
                        }
                    }
                }
            }
        }
        this._uniforms = this._uniforms.filter((val)=>{
            return !val.block || val.block.exp.$typeinfo.isStructType() && val.block.exp.$isBuffer;
        //return !val.block || val.block.exp.$isBuffer;
        /*
      if (!val.block || (val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_UNIFORM && val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_STORAGE)) {
        return true;
      }
      const type = val.block.exp.$ast.getType();
      return (
        type.isTextureType() ||
        type.isSamplerType() ||
        (type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430'))
      );
      */ });
    }
    /** @internal */ mergeUniforms(globalScopeVertex, globalScopeFragmet) {
        const vertexUniformList = [];
        const fragUniformList = [];
        const sharedUniformList = [];
        //const vertexUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        //const fragUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        //const sharedUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        for(let i = 0; i < this._uniforms.length; i++){
            const u = this._uniforms[i];
            if (u.block && (u.block.exp.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || u.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE)) {
                if (u.block.exp.$typeinfo.isStructType() && u.block.exp.$isBuffer) {
                    continue;
                }
                const v = !!(u.mask & ShaderType.Vertex);
                const f = !!(u.mask & ShaderType.Fragment);
                if (v && f) {
                    if (!sharedUniformList[u.group]) {
                        sharedUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    sharedUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    });
                //sharedUniformList[u.group].uniforms.push(i);
                } else if (v) {
                    if (!vertexUniformList[u.group]) {
                        vertexUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    vertexUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    });
                //vertexUniformList[u.group].uniforms.push(i);
                } else if (f) {
                    if (!fragUniformList[u.group]) {
                        fragUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    fragUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    }); //members.push(exp);
                //fragUniformList[u.group].uniforms.push(i);
                }
            }
        }
        const uniformLists = [
            vertexUniformList,
            fragUniformList,
            sharedUniformList
        ];
        const nameListUniform = [
            VERTEX_UNIFORM_NAME,
            FRAGMENT_UNIFORM_NAME,
            SHARED_UNIFORM_NAME
        ];
        const nameListStorage = [
            VERTEX_STORAGE_NAME,
            FRAGMENT_STORAGE_NAME,
            SHARED_STORAGE_NAME
        ];
        const maskList = [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Vertex | ShaderType.Fragment
        ];
        for(let i = 0; i < 3; i++){
            for(const k in uniformLists[i]){
                if (uniformLists[i][k]?.length > 0) {
                    const ulist = [
                        uniformLists[i][k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_UNIFORM),
                        uniformLists[i][k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_STORAGE)
                    ];
                    const nameList = [
                        nameListUniform,
                        nameListStorage
                    ];
                    const layoutList = [
                        'std140',
                        'std430'
                    ];
                    for(let j = 0; j < 2; j++){
                        if (ulist[j].length === 0) {
                            continue;
                        }
                        const nonBufferList = ulist[j].filter((val)=>!val.member.$isBuffer);
                        const bufferList = ulist[j].filter((val)=>val.member.$isBuffer);
                        const allLists = [
                            nonBufferList,
                            ...bufferList.map((val)=>[
                                    val
                                ])
                        ];
                        for(let p = 0; p < allLists.length; p++){
                            if (allLists[p].length === 0) {
                                continue;
                            }
                            const uname = `${nameList[j][i]}_${k}_${p}`;
                            const structName = this.generateStructureName();
                            const t = getCurrentProgramBuilder().internalDefineStruct(structName, layoutList[j], maskList[i], false, ...allLists[p].map((val)=>val.member));
                            if (maskList[i] & ShaderType.Vertex) {
                                const exp = t();
                                if (j === 0) {
                                    exp.uniformBuffer(Number(k));
                                } else {
                                    exp.storageBuffer(Number(k));
                                }
                                globalScopeVertex[uname] = exp;
                            }
                            if (maskList[i] & ShaderType.Fragment) {
                                const exp = t();
                                if (j === 0) {
                                    exp.uniformBuffer(Number(k));
                                } else {
                                    exp.storageBuffer(Number(k));
                                }
                                globalScopeFragmet[uname] = exp;
                            }
                            const index = this._uniforms.findIndex((val)=>val.block?.name === uname);
                            this._uniforms[index].mask = maskList[i];
                            let nameMap = this._nameMap[Number(k)];
                            if (!nameMap) {
                                nameMap = {};
                                this._nameMap[Number(k)] = nameMap;
                            }
                            let writable = false;
                            for(let n = allLists[p].length - 1; n >= 0; n--){
                                const u = allLists[p][n];
                                const exp = this._uniforms[u.uniform].block.exp;
                                nameMap[exp.$str] = uname;
                                exp.$str = `${uname}.${exp.$str}`;
                                writable ||= exp.$ast.isWritable();
                            }
                            if (writable) {
                                if (maskList[i] & ShaderType.Vertex) {
                                    globalScopeVertex[uname].$ast.markWritable();
                                } else {
                                    globalScopeFragmet[uname].$ast.markWritable();
                                }
                            }
                        }
                    }
                }
            }
        }
        this._uniforms = this._uniforms.filter((val)=>{
            return !val.block || val.block.exp.$typeinfo.isStructType() && val.block.exp.$isBuffer;
        /*
      if (!val.block) {
        return true;
      }
      const type = val.block.exp.$ast.getType();
      return (
        type.isTextureType() ||
        type.isSamplerType() ||
        (type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430'))
      );
      */ });
    }
    /** @internal */ updateUniformBindings(scopes, shaderTypes) {
        this._uniforms = this._uniforms.filter((val)=>!!val.mask);
        const bindings = Array.from({
            length: MAX_BINDING_GROUPS
        }).fill(0);
        for (const u of this._uniforms){
            u.binding = bindings[u.group]++;
        }
        for(let i = 0; i < scopes.length; i++){
            const scope = scopes[i];
            const type = shaderTypes[i];
            for (const u of this._uniforms){
                if (u.mask & type) {
                    const uniforms = scope.$ast.uniforms;
                    const name = u.block ? u.block.name : u.texture ? u.texture.exp.$str : u.sampler.$str;
                    const index = uniforms.findIndex((val)=>val.value.name === name);
                    if (index < 0) {
                        throw new Error(`updateUniformBindings() failed: unable to find uniform ${name}`);
                    }
                    uniforms[index].binding = u.binding;
                }
            }
        }
    }
    /** @internal */ createBindGroupLayouts(label) {
        const layouts = [];
        for (const uniformInfo of this._uniforms){
            let layout = layouts[uniformInfo.group];
            if (!layout) {
                layout = {
                    label: `${label || 'unknown'}[${uniformInfo.group}]`,
                    entries: []
                };
                if (this._nameMap[uniformInfo.group]) {
                    layout.nameMap = this._nameMap[uniformInfo.group];
                }
                layouts[uniformInfo.group] = layout;
            }
            const entry = {
                binding: uniformInfo.binding,
                visibility: uniformInfo.mask,
                type: null,
                name: ''
            };
            if (uniformInfo.block) {
                entry.type = uniformInfo.block.exp.$typeinfo.clone(this.getBlockName(uniformInfo.block.name));
                const isStorage = uniformInfo.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE;
                entry.buffer = {
                    type: isStorage ? uniformInfo.block.exp.$ast.isWritable() ? 'storage' : 'read-only-storage' : 'uniform',
                    hasDynamicOffset: uniformInfo.block.dynamicOffset,
                    uniformLayout: entry.type.toBufferLayout(0, entry.type.layout)
                };
                entry.name = uniformInfo.block.name;
            } else if (uniformInfo.texture) {
                entry.type = uniformInfo.texture.exp.$typeinfo;
                if (!entry.type.isTextureType()) {
                    throw new Error('internal error');
                }
                if (entry.type.isStorageTexture()) {
                    entry.storageTexture = {
                        access: 'write-only',
                        viewDimension: entry.type.is1DTexture() ? '1d' : '2d',
                        format: entry.type.storageTexelFormat
                    };
                } else if (entry.type.isExternalTexture()) {
                    entry.externalTexture = {
                        autoBindSampler: uniformInfo.texture.autoBindSampler ? genSamplerName(uniformInfo.texture.exp.$str, false) : null
                    };
                } else {
                    const sampleType = this._device.type === 'webgpu' ? uniformInfo.texture.exp.$sampleType : uniformInfo.texture.autoBindSampler && entry.type.isDepthTexture() ? 'float' : uniformInfo.texture.exp.$sampleType;
                    let viewDimension;
                    if (entry.type.isArrayTexture()) {
                        viewDimension = entry.type.isCubeTexture() ? 'cube-array' : '2d-array';
                    } else if (entry.type.is3DTexture()) {
                        viewDimension = '3d';
                    } else if (entry.type.isCubeTexture()) {
                        viewDimension = 'cube';
                    } else if (entry.type.is1DTexture()) {
                        viewDimension = '1d';
                    } else {
                        viewDimension = '2d';
                    }
                    entry.texture = {
                        sampleType: sampleType,
                        viewDimension: viewDimension,
                        multisampled: false,
                        autoBindSampler: null,
                        autoBindSamplerComparison: null
                    };
                    if (this._device.type === 'webgpu' || uniformInfo.texture.autoBindSampler === 'sample') {
                        entry.texture.autoBindSampler = genSamplerName(uniformInfo.texture.exp.$str, false);
                    }
                    if (this._device.type === 'webgpu' && entry.type.isDepthTexture() || uniformInfo.texture.autoBindSampler === 'comparison') {
                        entry.texture.autoBindSamplerComparison = genSamplerName(uniformInfo.texture.exp.$str, true);
                    }
                }
                entry.name = uniformInfo.texture.exp.$str;
            } else if (uniformInfo.sampler) {
                entry.type = uniformInfo.sampler.$typeinfo;
                if (!entry.type.isSamplerType()) {
                    throw new Error('internal error');
                }
                entry.sampler = {
                    type: entry.type.accessMode === PBSamplerAccessMode.SAMPLE ? uniformInfo.sampler.$sampleType === 'float' ? 'filtering' : 'non-filtering' : 'comparison'
                };
                entry.name = uniformInfo.sampler.$str;
            } else {
                throw new PBInternalError('invalid uniform entry type');
            }
            layout.entries.push(entry);
        }
        for(let i = 0; i < layouts.length; i++){
            if (!layouts[i]) {
                layouts[i] = {
                    label: `${label || 'unknown'}[${i}]`,
                    entries: []
                };
            }
        }
        return layouts;
    }
    /** @internal */ _getFunctionOverload(funcName, args) {
        const thisArgs = args.filter((val)=>{
            if (val instanceof PBShaderExp) {
                const type = val.$ast.getType();
                if (type.isStructType() && this._structInfo[this._shaderType]?.types.findIndex((t)=>t.type.structName === type.structName) < 0) {
                    return false;
                }
            }
            return true;
        });
        const fn = this.getGlobalScope().$getFunctions(funcName);
        return fn ? this._matchFunctionOverloading(fn, thisArgs) : null;
    }
    /** @internal */ _matchFunctionOverloading(overloadings, args) {
        for (const overload of overloadings){
            if (args.length !== overload.funcType.argTypes.length) {
                continue;
            }
            const result = [];
            let matches = true;
            for(let i = 0; i < args.length; i++){
                const argInfo = overload.funcType.argTypes[i];
                const argType = argInfo.byRef && argInfo.type instanceof PBPointerTypeInfo ? argInfo.type.pointerType : argInfo.type;
                const arg = args[i];
                if (typeof arg === 'boolean') {
                    if (!argType.isPrimitiveType() || argType.primitiveType !== PBPrimitiveType.BOOL) {
                        matches = false;
                        break;
                    }
                    result.push(new ASTScalar(arg, typeBool));
                } else if (typeof arg === 'number') {
                    if (!argType.isPrimitiveType() || !argType.isScalarType() || argType.scalarType === PBPrimitiveType.BOOL) {
                        matches = false;
                        break;
                    }
                    if (argType.scalarType === PBPrimitiveType.I32) {
                        if (!Number.isInteger(arg) || arg < 0x80000000 >> 0 || arg > 0x7fffffff) {
                            matches = false;
                            break;
                        }
                        result.push(new ASTScalar(arg, typeI32$1));
                    } else if (argType.scalarType === PBPrimitiveType.U32) {
                        if (!Number.isInteger(arg) || arg < 0 || arg > 0xffffffff) {
                            matches = false;
                            break;
                        }
                        result.push(new ASTScalar(arg, typeU32$2));
                    } else {
                        result.push(new ASTScalar(arg, argType));
                    }
                } else {
                    if (!argType.isCompatibleType(arg.$ast.getType())) {
                        matches = false;
                        break;
                    }
                    result.push(arg.$ast);
                }
            }
            if (matches) {
                return [
                    overload,
                    result
                ];
            }
        }
        return null;
    }
    /** @internal */ $callFunction(funcName, args, func) {
        if (this.getCurrentScope() === this.getGlobalScope()) {
            throw new PBNonScopedFunctionCall(funcName);
        }
        const exp = new PBShaderExp('', func.returnType);
        exp.$ast = new ASTCallFunction(funcName, args, func, getCurrentProgramBuilder().getDevice().type);
        this.getCurrentScope().$ast.statements.push(exp.$ast);
        return exp;
    }
    /** @internal */ $callFunctionNoCheck(funcName, args, retType) {
        if (this.getCurrentScope() === this.getGlobalScope()) {
            throw new PBNonScopedFunctionCall(funcName);
        }
        const exp = new PBShaderExp('', retType);
        exp.$ast = new ASTCallFunction(funcName, args, null, getCurrentProgramBuilder().getDevice().type, retType);
        this.getCurrentScope().$ast.statements.push(exp.$ast);
        return exp;
    }
}
/**
 * Base class for scope of the shader program
 * @public
 */ class PBScope extends Proxiable {
    /** @internal */ $_variables;
    /** @internal */ $_parentScope;
    /** @internal */ $_AST;
    /** @internal */ $_localScope;
    /** @internal */ constructor(astScope, parent){
        super();
        this.$_parentScope = parent || null;
        this.$_variables = {};
        this.$_AST = astScope;
        this.$_localScope = null;
    }
    /** Get the program builder */ get $builder() {
        return getCurrentProgramBuilder();
    }
    /** Returns the scope of the builtin variables */ get $builtins() {
        return getCurrentProgramBuilder().builtinScope;
    }
    /** Returns the scope of the input variables */ get $inputs() {
        return getCurrentProgramBuilder().inputScope;
    }
    /** Returns the scope of the output variables */ get $outputs() {
        return getCurrentProgramBuilder().outputScope;
    }
    /** @internal */ get $parent() {
        return this.$_parentScope;
    }
    /** @internal */ get $ast() {
        return this.$_AST;
    }
    /** @internal */ set $ast(ast) {
        this.$_AST = ast;
    }
    /**
   * Get the input vertex attribute by specified semantic
   *
   * @remarks
   * Can only be called only in vertex shader
   *
   * @param semantic - The vertex semantic
   * @returns The input vertex attribute or null if not exists
   */ $getVertexAttrib(semantic) {
        return getCurrentProgramBuilder().getReflection().attribute(semantic);
    }
    /** Get the current local scope */ get $l() {
        return this.$_getLocalScope();
    }
    /** Get the global scope */ get $g() {
        return this.$_getGlobalScope();
    }
    /** @internal */ $local(variable, init) {
        const initNonArray = getCurrentProgramBuilder().normalizeExpValue(init);
        variable.$global = this instanceof PBGlobalScope;
        this.$_declare(variable, initNonArray);
    }
    /** @internal */ $touch(exp) {
        this.$ast.statements.push(new ASTTouch(exp.$ast));
    }
    /**
   * Query the global variable by the name
   * @param name - Name of the variable
   * @returns The variable or null if not exists
   */ $query(name) {
        return this.$builder.getReflection().tag(name);
    }
    /** @internal */ $_declareInternal(variable, init) {
        const key = variable.$str;
        if (this.$_variables[key]) {
            throw new Error(`cannot re-declare variable '${key}'`);
        }
        if (!(variable.$ast instanceof ASTPrimitive)) {
            throw new Error(`invalid variable declaration: '${variable.$ast.toString(getCurrentProgramBuilder().getDevice().type)}'`);
        }
        const varType = variable.$typeinfo;
        if (varType.isPointerType()) {
            if (!init) {
                throw new Error(`cannot declare pointer type variable without initialization: '${variable.$str}'`);
            }
            if (!(init instanceof PBShaderExp)) {
                throw new Error(`invalid initialization for pointer type declaration: '${variable.$str}`);
            }
            const initType = init.$ast.getType();
            if (!initType.isPointerType() || !varType.pointerType.isCompatibleType(initType.pointerType)) {
                throw new Error(`incompatible pointer type assignment: '${variable.$str}'`);
            }
            variable.$typeinfo = initType;
        }
        this.$_registerVar(variable, key);
        if (init === undefined || init === null) {
            return new ASTDeclareVar(variable.$ast);
        } else {
            if (init instanceof PBShaderExp && init.$ast instanceof ASTShaderExpConstructor && init.$ast.args.length === 0) {
                if (!init.$ast.getType().isCompatibleType(variable.$ast.getType())) {
                    throw new PBTypeCastError(init, init.$ast.getType(), variable.$ast.getType());
                }
                return new ASTDeclareVar(variable.$ast);
            } else {
                return new ASTAssignment(new ASTLValueDeclare(variable.$ast), init instanceof PBShaderExp ? init.$ast : init);
            }
        }
    }
    /** @internal */ $_findOrSetUniform(variable) {
        const name = variable.$str;
        const uniformInfo = {
            group: variable.$group,
            binding: 0,
            mask: 0
        };
        if (variable.$typeinfo.isTextureType()) {
            uniformInfo.texture = {
                autoBindSampler: null,
                exp: variable
            };
        } else if (variable.$typeinfo.isSamplerType()) {
            uniformInfo.sampler = variable;
        } else {
            uniformInfo.block = {
                name: name,
                dynamicOffset: false,
                exp: variable
            };
        // throw new Error(`unsupported uniform type: ${name}`);
        }
        let found = false;
        for (const u of getCurrentProgramBuilder()._uniforms){
            if (u.group !== uniformInfo.group) {
                continue;
            }
            if (uniformInfo.block && u.block && u.block.name === uniformInfo.block.name && u.block.exp.$typeinfo.isCompatibleType(uniformInfo.block.exp.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.block.exp;
                // u.block.exp = variable;
                found = true;
                break;
            }
            if (uniformInfo.texture && u.texture && uniformInfo.texture.exp.$str === u.texture.exp.$str && uniformInfo.texture.exp.$typeinfo.isCompatibleType(u.texture.exp.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.texture.exp;
                // u.texture.exp = variable;
                found = true;
                break;
            }
            if (uniformInfo.sampler && u.sampler && uniformInfo.sampler.$str === u.sampler.$str && uniformInfo.sampler.$typeinfo.isCompatibleType(u.sampler.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.sampler;
                // u.sampler = variable;
                found = true;
                break;
            }
        }
        if (!found) {
            uniformInfo.mask = getCurrentProgramBuilder().shaderType;
            getCurrentProgramBuilder()._uniforms.push(uniformInfo);
        }
        if (uniformInfo.texture && !uniformInfo.texture.exp.$typeinfo.isStorageTexture() && getCurrentProgramBuilder().getDevice().type === 'webgpu') {
            // webgpu requires explicit sampler bindings
            const isDepth = variable.$typeinfo.isTextureType() && variable.$typeinfo.isDepthTexture();
            const samplerName = genSamplerName(variable.$str, false);
            const samplerExp = getCurrentProgramBuilder().sampler(samplerName).uniform(uniformInfo.group).sampleType(variable.$sampleType);
            samplerExp.$sampleType = variable.$sampleType;
            this.$local(samplerExp);
            if (isDepth) {
                const samplerNameComp = genSamplerName(variable.$str, true);
                const samplerExpComp = getCurrentProgramBuilder().samplerComparison(samplerNameComp).uniform(uniformInfo.group).sampleType(variable.$sampleType);
                this.$local(samplerExpComp);
            }
        }
        return variable;
    }
    /** @internal */ $_declare(variable, init) {
        if (this.$_variables[variable.$str]) {
            throw new PBASTError(variable.$ast, 'cannot re-declare variable');
        }
        if (variable.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || variable.$declareType === DeclareType.DECLARE_TYPE_STORAGE) {
            const name = variable.$ast.name;
            if (!(this instanceof PBGlobalScope)) {
                throw new Error(`uniform or storage variables can only be declared within global scope: ${name}`);
            }
            if (variable.$declareType === DeclareType.DECLARE_TYPE_UNIFORM && !variable.$typeinfo.isTextureType() && !variable.$typeinfo.isSamplerType() && (!variable.$typeinfo.isConstructible() || !variable.$typeinfo.isHostSharable())) {
                throw new PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDevice().type)}' cannot be declared in uniform address space`);
            }
            if (variable.$declareType === DeclareType.DECLARE_TYPE_STORAGE) {
                if (getCurrentProgramBuilder().getDevice().type !== 'webgpu') {
                    throw new PBDeviceNotSupport('storage buffer binding');
                } else if (!variable.$typeinfo.isHostSharable()) {
                    throw new PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDevice().type)}' cannot be declared in storage address space`);
                }
            }
            /*
      if (
        variable.$declareType === AST.DeclareType.DECLARE_TYPE_STORAGE &&
        (variable.$typeinfo.isPrimitiveType() || variable.$typeinfo.isArrayType() || variable.$typeinfo.isAtomicI32() || variable.$typeinfo.isAtomicU32())
      ) {
        originalType = variable.$typeinfo as PBPrimitiveTypeInfo | PBArrayTypeInfo;
        const wrappedStruct = getCurrentProgramBuilder().defineStruct(null, new PBShaderExp('value', originalType));
        variable.$typeinfo = wrappedStruct().$typeinfo;
      }
      */ variable = this.$_findOrSetUniform(variable);
            const ast = this.$_declareInternal(variable);
            ast.group = variable.$group;
            ast.binding = 0;
            ast.blockName = getCurrentProgramBuilder().getBlockName(name);
            const type = variable.$typeinfo;
            if (type.isStructType() && variable.$isBuffer || type.isTextureType() || type.isSamplerType() || type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430')) {
                this.$ast.uniforms.push(ast);
            }
            variable.$tags.forEach((val)=>{
                getCurrentProgramBuilder().tagShaderExp(()=>variable, val);
            });
        } else {
            const ast = this.$_declareInternal(variable, init);
            this.$ast.statements.push(ast);
        }
    }
    /** @internal */ $_registerVar(variable, name) {
        const key = name || variable.$str;
        const options = {
            configurable: true,
            get: function() {
                return variable;
            },
            set: function(val) {
                getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(variable.$ast), val instanceof PBShaderExp ? val.$ast : val));
            }
        };
        Object.defineProperty(this, key, options);
        this.$_variables[key] = variable;
    }
    /** @internal */ $localGet(prop) {
        if (typeof prop === 'string' && (prop[0] === '$' || prop in this)) {
            return this[prop];
        }
        return undefined;
    }
    /** @internal */ $localSet(prop, value) {
        if (prop[0] === '$' || prop in this) {
            this[prop] = value;
            return true;
        }
        return false;
    }
    /** @internal */ $get(prop) {
        const ret = this.$localGet(prop);
        return ret === undefined && this.$_parentScope ? this.$_parentScope.$thisProxy.$get(prop) : ret;
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
            return true;
        } else {
            let scope = this;
            while(scope && !(prop in scope)){
                scope = scope.$_parentScope;
            }
            if (scope) {
                scope[prop] = value;
                return true;
            } else {
                if (this.$l) {
                    this.$l[prop] = value;
                    return true;
                }
            }
        }
        return false;
    }
    /** @internal */ $_getLocalScope() {
        if (!this.$_localScope) {
            this.$_localScope = new PBLocalScope(this);
        }
        return this.$_localScope;
    }
    /** @internal */ $_getGlobalScope() {
        return this.$builder.getGlobalScope();
    }
}
/**
 * The local scope of a shader
 * @public
 */ class PBLocalScope extends PBScope {
    /** @internal */ $_scope;
    constructor(scope){
        super(null, null);
        this.$_scope = scope;
    }
    /** @internal */ $get(prop) {
        return prop[0] === '$' ? this[prop] : this.$_scope.$localGet(prop);
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
            return true;
        }
        const val = this.$_scope.$localGet(prop);
        if (val === undefined) {
            const type = getCurrentProgramBuilder().guessExpValueType(value);
            if (type.isCompatibleType(typeVoid)) {
                throw new Error(`Cannot assign void type to '${prop}'`);
            }
            const exp = new PBShaderExp(prop, type);
            if (value instanceof PBShaderExp && !this.$_scope.$parent) {
                exp.$declareType = value.$declareType;
                exp.$isBuffer = value.$isBuffer;
                exp.$group = value.$group;
                exp.$attrib = value.$attrib;
                exp.$sampleType = value.$sampleType;
                exp.$precision = value.$precision;
                exp.tag(...value.$tags);
            }
            this.$_scope.$local(exp, value);
            return true;
        } else {
            return this.$_scope.$localSet(prop, value);
        }
    }
    /** @internal */ $_getLocalScope() {
        return this;
    }
}
/**
 * The builtin scope of a shader
 * @public
 */ class PBBuiltinScope extends PBScope {
    /** @internal */ $_usedBuiltins;
    /** @internal */ $_builtinVars;
    constructor(){
        super(null);
        this.$_usedBuiltins = new Set();
        const isWebGPU = getCurrentProgramBuilder().getDevice().type === 'webgpu';
        if (!isWebGPU) {
            this.$_builtinVars = {};
            const v = builtinVariables[getCurrentProgramBuilder().getDevice().type];
            for(const k in v){
                const info = v[k];
                this.$_builtinVars[k] = new PBShaderExp(info.name, info.type);
            }
        }
        const v = builtinVariables[getCurrentProgramBuilder().getDevice().type];
        const that = this;
        for (const k of Object.keys(v)){
            Object.defineProperty(this, k, {
                get: function() {
                    return that.$getBuiltinVar(k);
                },
                set: function(v) {
                    if (typeof v !== 'number' && !(v instanceof PBShaderExp)) {
                        throw new Error(`Invalid output value assignment`);
                    }
                    const exp = that.$getBuiltinVar(k);
                    getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(exp.$ast), v instanceof PBShaderExp ? v.$ast : v));
                }
            });
        }
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $getBuiltinVar(name) {
        const pb = getCurrentProgramBuilder();
        this.$_usedBuiltins.add(name);
        const isWebGPU = pb.getDevice().type === 'webgpu';
        if (isWebGPU) {
            const v = builtinVariables[pb.getDevice().type];
            const info = v[name];
            const inout = info.inOrOut;
            const structName = inout === 'in' ? getBuiltinInputStructInstanceName(pb.shaderType) : getBuiltinOutputStructInstanceName(pb.shaderType);
            const scope = pb.getCurrentScope();
            if (!scope[structName] || !scope[structName][info.name]) {
                throw new Error(`invalid use of builtin variable ${name}`);
            }
            return scope[structName][info.name];
        } else {
            if (pb.getDevice().type === 'webgl2' && (name === 'vertexIndex' || name === 'instanceIndex')) {
                return pb.uint(this.$_builtinVars[name]);
            } else {
                return this.$_builtinVars[name];
            }
        }
    }
}
/**
 * The input scope of a shader
 * @public
 */ class PBInputScope extends PBScope {
    /** @internal */ constructor(){
        super(null);
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
        } else if (prop in this) {
            throw new Error(`Can not assign to shader input variable: "${prop}"`);
        } else {
            const st = getCurrentProgramBuilder().shaderType;
            if (st !== ShaderType.Vertex) {
                throw new Error(`shader input variables can only be declared in vertex shader: "${prop}"`);
            }
            const attrib = getVertexAttribByName(value.$attrib);
            if (attrib === undefined) {
                throw new Error(`can not declare shader input variable: invalid vertex attribute: "${prop}"`);
            }
            if (getCurrentProgramBuilder()._vertexAttributes.indexOf(attrib) >= 0) {
                throw new Error(`can not declare shader input variable: attribute already declared: "${prop}"`);
            }
            if (!(value instanceof PBShaderExp) || !(value.$ast instanceof ASTShaderExpConstructor)) {
                throw new Error(`invalid shader input variable declaration: "${prop}"`);
            }
            const type = value.$ast.getType();
            if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {
                throw new Error(`type cannot be used as pipeline input/output: ${prop}`);
            }
            const location = getCurrentProgramBuilder()._inputs.length;
            const exp = new PBShaderExp(`${input_prefix}${prop}`, type).tag(...value.$tags);
            getCurrentProgramBuilder().in(location, prop, exp);
            getCurrentProgramBuilder()._vertexAttributes.push(attrib);
            getCurrentProgramBuilder().getReflection().setAttrib(value.$attrib, exp);
            // modify input struct for webgpu
            if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                if (getCurrentProgramBuilder().findStructType(getBuiltinInputStructName(st), st)) {
                    getCurrentProgramBuilder().defineBuiltinStruct(st, 'in');
                }
            }
        }
        return true;
    }
}
/**
 * The output scope of a shader
 * @public
 */ class PBOutputScope extends PBScope {
    constructor(){
        super(null);
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$' /* || prop in this*/ ) {
            this[prop] = value;
        } else {
            const pb = getCurrentProgramBuilder();
            if (!(prop in this)) {
                if (pb.getCurrentScope() === pb.getGlobalScope() && (!(value instanceof PBShaderExp) || !(value.$ast instanceof ASTShaderExpConstructor))) {
                    throw new Error(`invalid shader output variable declaration: ${prop}`);
                }
                const type = value.$ast.getType();
                if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {
                    throw new Error(`type cannot be used as pipeline input/output: ${prop}`);
                }
                const location = pb._outputs.length;
                pb.out(location, prop, new PBShaderExp(`${pb.shaderKind === 'vertex' ? output_prefix_vs : output_prefix_fs}${prop}`, type).tag(...value.$tags));
                // modify output struct for webgpu
                if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                    const st = getCurrentProgramBuilder().shaderType;
                    if (getCurrentProgramBuilder().findStructType(getBuiltinInputStructName(st), st)) {
                        getCurrentProgramBuilder().defineBuiltinStruct(st, 'out');
                    }
                }
            }
            if (getCurrentProgramBuilder().getCurrentScope() !== getCurrentProgramBuilder().getGlobalScope()) {
                const ast = value.$ast;
                if (!(ast instanceof ASTShaderExpConstructor) || ast.args.length > 0) {
                    this[prop] = value;
                }
            }
        }
        return true;
    }
}
/**
 * The global scope of a shader
 * @public
 */ class PBGlobalScope extends PBScope {
    /** @internal */ constructor(){
        super(new ASTGlobalScope());
    }
    /** @internal */ $mainFunc(body) {
        const pb = getCurrentProgramBuilder();
        if (pb.getDevice().type === 'webgpu') {
            const inputStruct = pb.defineBuiltinStruct(pb.shaderType, 'in');
            this.$local(inputStruct[1]);
            const isCompute = pb.shaderType === ShaderType.Compute;
            const outputStruct = isCompute ? null : pb.defineBuiltinStruct(pb.shaderType, 'out');
            if (!isCompute) {
                this.$local(outputStruct[1]);
            }
            this.$internalCreateFunction('chMainStub', [], false, body);
            this.$internalCreateFunction('main', inputStruct ? [
                inputStruct[3]
            ] : [], true, function() {
                if (inputStruct) {
                    this[inputStruct[1].$str] = this[inputStruct[3].$str];
                }
                if (pb.shaderType === ShaderType.Fragment && pb.emulateDepthClamp) {
                    this.$builtins.fragDepth = pb.clamp(this.$inputs.clamppedDepth, 0, 1);
                }
                this.chMainStub();
                if (pb.shaderType === ShaderType.Vertex) {
                    if (pb.depthRangeCorrection) {
                        this.$builtins.position.z = pb.mul(pb.add(this.$builtins.position.z, this.$builtins.position.w), 0.5);
                    }
                    if (pb.emulateDepthClamp) {
                        //z = gl_Position.z / gl_Position.w;
                        //z = (gl_DepthRange.diff * z + gl_DepthRange.near + gl_DepthRange.far) * 0.5;
                        this.$outputs.clamppedDepth = pb.div(this.$builtins.position.z, this.$builtins.position.w);
                        this.$builtins.position.z = 0;
                    }
                }
                if (!isCompute) {
                    this.$return(outputStruct[1]);
                }
            });
        } else {
            this.$internalCreateFunction('main', [], true, function() {
                if (pb.shaderType === ShaderType.Fragment && pb.emulateDepthClamp) {
                    this.$builtins.fragDepth = pb.clamp(this.$inputs.clamppedDepth, 0, 1);
                }
                body?.call(this);
                if (pb.shaderType === ShaderType.Vertex && pb.emulateDepthClamp) {
                    this.$outputs.clamppedDepth = pb.div(pb.add(pb.div(this.$builtins.position.z, this.$builtins.position.w), 1), 2);
                    this.$builtins.position.z = 0;
                }
            });
        }
    }
    /** @internal */ $createFunctionIfNotExists(name, params, body) {
        {
            this.$internalCreateFunction(name, params, false, body);
        }
    }
    /** @internal */ $getFunctions(name) {
        return this.$ast.findFunctions(name);
    }
    /** @internal */ $getCurrentFunctionScope() {
        let scope = getCurrentProgramBuilder().getCurrentScope();
        while(scope && !(scope instanceof PBFunctionScope)){
            scope = scope.$parent;
        }
        return scope;
    }
    /** @internal */ $internalCreateFunction(name, params, isMain, body) {
        const pb = getCurrentProgramBuilder();
        params.forEach((param)=>{
            if (!(param.$ast instanceof ASTPrimitive)) {
                throw new Error(`${name}(): invalid function definition`);
            }
            let ast = param.$ast;
            if (param.$inout) {
                if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                    param.$typeinfo = new PBPointerTypeInfo(param.$typeinfo, PBAddressSpace.UNKNOWN);
                }
                ast = new ASTReferenceOf(param.$ast);
            }
            param.$ast = new ASTFunctionParameter(ast);
        });
        const overloads = this.$getFunctions(name);
        const currentFunctionScope = this.$getCurrentFunctionScope();
        const astFunc = new ASTFunction(name, params.map((val)=>val.$ast), isMain, null, false);
        if (currentFunctionScope) {
            const curIndex = this.$ast.statements.indexOf(currentFunctionScope.$ast);
            if (curIndex < 0) {
                throw new Error('Internal error');
            }
            this.$ast.statements.splice(curIndex, 0, astFunc);
        } else {
            this.$ast.statements.push(astFunc);
        }
        new PBFunctionScope(this, params, astFunc, body);
        if (!astFunc.returnType) {
            astFunc.returnType = typeVoid;
        }
        astFunc.funcType = new PBFunctionTypeInfo(astFunc.name, astFunc.returnType, params.map((param)=>{
            const ast = param.$ast;
            return ast.paramAST instanceof ASTReferenceOf ? {
                type: ast.paramAST.value.getType(),
                byRef: ast.paramAST instanceof ASTReferenceOf
            } : {
                type: ast.paramAST.getType(),
                byRef: false
            };
        }));
        for (const overload of overloads){
            if (overload.funcType.argHash === astFunc.funcType.argHash) {
                if (overload.returnType.isCompatibleType(astFunc.returnType)) {
                    // Function signature already exists
                    // console.warn(`Function '${name}' already exists`);
                    this.$ast.statements.splice(this.$ast.statements.indexOf(astFunc), 1);
                    return;
                } else {
                    throw new Error(`Invalid function overloading: ${name}`);
                }
            }
        }
        if (overloads.length === 0) {
            Object.defineProperty(this, name, {
                get: function() {
                    const func = this.$getFunctions(name);
                    if (func.length === 0) {
                        throw new Error(`function ${name} not found`);
                    }
                    return (...args)=>{
                        const argsNonArray = args.map((val)=>pb.normalizeExpValue(val));
                        const funcType = pb._getFunctionOverload(name, argsNonArray);
                        if (!funcType) {
                            throw new Error(`ERROR: no matching overloads for function ${name}`);
                        }
                        return getCurrentProgramBuilder().$callFunction(name, funcType[1], funcType[0]);
                    };
                }
            });
        }
    }
}
/**
 * Scope that is inside a function
 * @public
 */ class PBInsideFunctionScope extends PBScope {
    /** @internal */ constructor(parent){
        super(new ASTScope(), parent);
    }
    /**
   * Creates a 'return' statement
   * @param retval - The return value
   */ $return(retval) {
        const functionScope = this.findOwnerFunction();
        const astFunc = functionScope.$ast;
        let returnType = null;
        const retValNonArray = getCurrentProgramBuilder().normalizeExpValue(retval);
        if (retValNonArray !== undefined && retValNonArray !== null) {
            if (typeof retValNonArray === 'number') {
                if (astFunc.returnType) {
                    if (astFunc.returnType.isPrimitiveType() && astFunc.returnType.isScalarType() && !astFunc.returnType.isCompatibleType(typeBool)) {
                        returnType = astFunc.returnType;
                    }
                }
                if (!returnType) {
                    if (Number.isInteger(retValNonArray)) {
                        if (retValNonArray < 0) {
                            if (retValNonArray < 0x80000000 >> 0) {
                                throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);
                            }
                            returnType = typeI32$1;
                        } else {
                            if (retValNonArray > 0xffffffff) {
                                throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);
                            }
                            returnType = retValNonArray <= 0x7fffffff ? typeI32$1 : typeU32$2;
                        }
                    } else {
                        returnType = typeF32$1;
                    }
                }
            } else if (typeof retValNonArray === 'boolean') {
                returnType = typeBool;
            } else {
                returnType = retValNonArray.$ast.getType();
            }
        } else {
            returnType = typeVoid;
        }
        if (returnType.isPointerType()) {
            throw new Error('function can not return pointer type');
        }
        if (!astFunc.returnType) {
            astFunc.returnType = returnType;
        } else if (!astFunc.returnType.isCompatibleType(returnType)) {
            throw new Error(`function ${astFunc.name}: return type must be ${astFunc.returnType?.toTypeName(getCurrentProgramBuilder().getDevice().type) || 'void'}`);
        }
        let returnValue = null;
        if (retValNonArray !== undefined && retValNonArray !== null) {
            if (retValNonArray instanceof PBShaderExp) {
                returnValue = retValNonArray.$ast;
            } else {
                if (!returnType.isPrimitiveType() || !returnType.isScalarType()) {
                    throw new PBTypeCastError(retValNonArray, typeof retValNonArray, returnType);
                }
                returnValue = new ASTScalar(retValNonArray, returnType);
            }
        }
        this.$ast.statements.push(new ASTReturn(returnValue));
    }
    /**
   * Creates a new scope
   * @param body - Generator function for the scope
   * @returns The created scope
   */ $scope(body) {
        const astScope = new ASTNakedScope();
        this.$ast.statements.push(astScope);
        return new PBNakedScope(this, astScope, body);
    }
    /**
   * Creates an 'if' statement
   * @param condition - Condition expression for the if statement
   * @param body - Generator function for the scope inside the if statement
   * @returns The scope inside the if statement
   */ $if(condition, body) {
        const astIf = new ASTIf('if', condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool));
        this.$ast.statements.push(astIf);
        return new PBIfScope(this, astIf, body);
    }
    /**
   * Creates a select statement: condition ? first : second
   * @param condition - Condition expression
   * @param first - The first value
   * @param second - The second value
   * @returns The first value if condition evaluates to true, otherwise returns the second value
   */ $choice(condition, first, second) {
        const ast = new ASTSelect(condition instanceof PBShaderExp ? condition.$ast : condition, first instanceof PBShaderExp ? first.$ast : first, second instanceof PBShaderExp ? second.$ast : second);
        const exp = new PBShaderExp('', ast.getType());
        exp.$ast = ast;
        return exp;
    }
    /** Creates a 'break' statement */ $break() {
        this.$ast.statements.push(new ASTBreak());
    }
    /** Creates a 'continue' statement */ $continue() {
        this.$ast.statements.push(new ASTContinue());
    }
    /**
   * Creates a 'for' statement
   * @param counter - The repeat counter variable declaration
   * @param init - initial value of the repeat counter variable
   * @param end - end value of the counter exclusive
   * @param body - Generator function for the scope that inside the for statement
   */ $for(counter, init, end, body) {
        const initializerType = counter.$ast.getType();
        if (!initializerType.isPrimitiveType() || !initializerType.isScalarType()) {
            throw new PBASTError(counter.$ast, 'invalid for range initializer type');
        }
        const initval = init instanceof PBShaderExp ? init.$ast : new ASTScalar(init, initializerType);
        const astFor = new ASTRange(counter.$ast, initval, end instanceof PBShaderExp ? end.$ast : new ASTScalar(end, initializerType), true);
        this.$ast.statements.push(astFor);
        new PBForScope(this, counter, end, astFor, body);
    }
    /**
   * Creates a 'do..while' statement
   * @param body - Generator function for the scope that inside the do..while statment
   * @returns The scope that inside the do..while statement
   */ $do(body) {
        const astDoWhile = new ASTDoWhile(null);
        this.$ast.statements.push(astDoWhile);
        return new PBDoWhileScope(this, astDoWhile, body);
    }
    /**
   * Creates a 'while' statement
   * @param condition - Condition expression for the while statement
   * @param body - Generator function for the scope that inside the while statement
   */ $while(condition, body) {
        const astWhile = new ASTWhile(condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool));
        this.$ast.statements.push(astWhile);
        new PBWhileScope(this, astWhile, body);
    }
    /** @internal */ findOwnerFunction() {
        for(let scope = this; scope; scope = scope.$parent){
            if (scope instanceof PBFunctionScope) {
                return scope;
            }
        }
        return null;
    }
}
/**
 * Scope that insides a function
 * @public
 */ class PBFunctionScope extends PBInsideFunctionScope {
    /** @internal */ $typeinfo;
    /** @internal */ constructor(parent, params, ast, body){
        super(parent);
        this.$ast = ast;
        for (const param of params){
            if (this.$_variables[param.$str]) {
                throw new Error('Duplicate function parameter name is not allowed');
            }
            this.$_registerVar(param);
        }
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * Scope that insides a while statement
 * @public
 */ class PBWhileScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * Scope that insides a do..while statement
 * @public
 */ class PBDoWhileScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    $while(condition) {
        this.$ast.condition = condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool);
    }
}
/**
 * Scope that insides a for statement
 * @public
 */ class PBForScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, counter, count, ast, body){
        super(parent);
        this.$ast = ast;
        this.$_registerVar(counter);
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * A naked scope
 * @public
 */ class PBNakedScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * Scope that insides an if statement
 * @public
 */ class PBIfScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    /**
   * Creates an 'else if' branch
   * @param condition - Condition expression for the else if branch
   * @param body - Generator function for the scope that insides the else if statement
   * @returns The scope that insides the else if statement
   */ $elseif(condition, body) {
        const astElseIf = new ASTIf('else if', condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool));
        this.$ast.nextElse = astElseIf;
        return new PBIfScope(this.$_parentScope, astElseIf, body);
    }
    /**
   * Creates an 'else' branch
   * @param body - Generator function for the scope that insides the else statement
   */ $else(body) {
        const astElse = new ASTIf('else', null);
        this.$ast.nextElse = astElse;
        new PBIfScope(this.$_parentScope, astElse, body);
    }
}
setBuiltinFuncs(ProgramBuilder);
setConstructors(ProgramBuilder);

/** @internal */ class FontCanvas {
    static _canvas = null;
    static _context = null;
    static get canvas() {
        this._realize();
        return this._canvas;
    }
    static get context() {
        this._realize();
        return this._context;
    }
    static get font() {
        return this.context.font;
    }
    static set font(font) {
        this.context.font = font;
    }
    static _realize() {
        if (!this._canvas) {
            this._canvas = document.createElement('canvas');
            this._canvas.width = 512;
            this._canvas.height = 512;
            this._canvas.style.left = '-10000px';
            this._canvas.style.position = 'absolute';
            //document.body.appendChild(this._canvas);
            this._context = this._canvas.getContext('2d', {
                willReadFrequently: true
            });
            this._context.textBaseline = 'top';
            this._context.textAlign = 'left';
            this._context.fillStyle = 'transparent';
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
            this._context.fillStyle = '#ffffff';
            this._context.imageSmoothingEnabled = true;
        }
    }
}
/**
   * The font class
   * @public
   */ class Font {
    /** @internal */ static fontCache = {};
    /** @internal */ _name;
    /** @internal */ _nameScaled;
    /** @internal */ _scale;
    /** @internal */ _size;
    /** @internal */ _family;
    /** @internal */ _top;
    /** @internal */ _bottom;
    /** @internal */ _topScaled;
    /** @internal */ _bottomScaled;
    /** @internal */ _div;
    /**
     * Creates a instance of font class from font name and the scale value
     * @param name - The font name
     * @param scale - The scale value
     */ constructor(name, scale){
        this._top = 0;
        this._bottom = 0;
        this._size = 0;
        this._topScaled = 0;
        this._bottomScaled = 0;
        this._family = '';
        this._scale = scale;
        this._name = name;
        this._nameScaled = null;
        this._div = document.createElement('div');
        if (this._name) {
            this._normalizeFont();
        }
    }
    /**
     * Fetch a font from cache
     * @param name - The font name
     * @param scale - The scale value
     * @returns The font object
     */ static fetchFont(name, scale) {
        let fontlist = this.fontCache[name];
        if (!fontlist) {
            fontlist = {};
            this.fontCache[name] = fontlist;
        }
        let font = fontlist[scale];
        if (!font) {
            font = new Font(name, scale);
            fontlist[scale] = font;
        }
        return font;
    }
    /** Gets the font name */ get fontName() {
        return this._name;
    }
    set fontName(name) {
        this._name = name;
        this._normalizeFont();
    }
    /** Gets the scaled font name */ get fontNameScaled() {
        return this._nameScaled;
    }
    /** Gets the font size */ get size() {
        return this._size;
    }
    /** Gets the font family */ get family() {
        return this._family;
    }
    /** Gets top position of the font */ get top() {
        return this._top;
    }
    /** Gets the bottom position of the font */ get bottom() {
        return this._bottom;
    }
    /** Gets the scaled top position of the font */ get topScaled() {
        return this._topScaled;
    }
    /** Gets the scaled bottom position of the font */ get bottomScaled() {
        return this._bottomScaled;
    }
    /** Gets the maximum height of the font */ get maxHeight() {
        return this._bottom - this._top + 1;
    }
    /** Gets the scaled maximum height of the font */ get maxHeightScaled() {
        return this._bottomScaled - this._topScaled + 1;
    }
    /** Tests if two fonts are the same */ equalTo(other) {
        return this._size === other._size && this._family === other._family;
    }
    /** @internal */ _measureFontHeight(fontName) {
        const oldFont = FontCanvas.context.font;
        const oldTextBaseline = FontCanvas.context.textBaseline;
        const oldFillStyle = FontCanvas.context.fillStyle;
        FontCanvas.context.font = fontName;
        this._div.style.font = FontCanvas.context.font;
        const fontSize = this._div.style.fontSize;
        const size = parseInt(fontSize.substring(0, fontSize.length - 2));
        const family = this._div.style.fontFamily;
        const testString = 'bdfghijklpq国美|_~';
        const metric = FontCanvas.context.measureText(testString);
        let top, bottom;
        top = 0;
        bottom = size - 1;
        const extra = 10;
        const halfExtra = extra >> 1;
        const maxWidth = Math.ceil(metric.width) + extra;
        const maxHeight = size + extra;
        FontCanvas.context.clearRect(0, 0, maxWidth, maxHeight);
        FontCanvas.context.textBaseline = 'top';
        FontCanvas.context.fillStyle = '#ffffff';
        FontCanvas.context.fillText(testString, halfExtra, halfExtra);
        const bitmap = FontCanvas.context.getImageData(0, 0, maxWidth, maxHeight);
        const pixels = bitmap.data;
        for(let i = 0; i < maxWidth * maxHeight; i++){
            if (pixels[i * 4 + 3] > 0) {
                top = Math.floor(i / maxWidth);
                break;
            }
        }
        for(let i = maxWidth * maxHeight - 1; i >= 0; i--){
            if (pixels[i * 4 + 3] > 0) {
                bottom = Math.floor(i / maxWidth);
                break;
            }
        }
        top -= halfExtra;
        bottom -= halfExtra;
        FontCanvas.context.font = oldFont;
        FontCanvas.context.textBaseline = oldTextBaseline;
        FontCanvas.context.fillStyle = oldFillStyle;
        return {
            size,
            family,
            top,
            bottom
        };
    }
    /** @internal */ _normalizeFont() {
        const info = this._measureFontHeight(this._name);
        this._nameScaled = `${Math.round(info.size * this._scale)}px ${info.family}`;
        const infoScaled = this._measureFontHeight(this._nameScaled);
        this._size = info.size;
        this._family = info.family;
        this._top = info.top;
        this._bottom = info.bottom;
        this._topScaled = infoScaled.top;
        this._bottomScaled = infoScaled.bottom;
    }
}

/**
 * Texture atlas manager
 * @public
 */ class TextureAtlasManager {
    /** @internal */ static ATLAS_WIDTH = 1024;
    /** @internal */ static ATLAS_HEIGHT = 1024;
    /** @internal */ _packer;
    /** @internal */ _device;
    /** @internal */ _binWidth;
    /** @internal */ _binHeight;
    /** @internal */ _rectBorderWidth;
    /** @internal */ _linearSpace;
    /** @internal */ _atlasList;
    /** @internal */ _atlasInfoMap;
    /** @internal */ _atlasRestoreHandler;
    /**
   * Creates a new texture atlas manager instance
   * @param device - The render device
   * @param binWidth - Width of an atlas bin
   * @param binHeight - Height of an atlas bin
   * @param rectBorderWidth - Border width of an atlas
   * @param linearSpace - true if the texture space is linear
   */ constructor(device, binWidth, binHeight, rectBorderWidth, linearSpace){
        this._device = device;
        this._binWidth = binWidth;
        this._binHeight = binHeight;
        this._rectBorderWidth = rectBorderWidth;
        this._linearSpace = !!linearSpace;
        this._packer = new RectsPacker(this._binWidth, this._binHeight);
        this._atlasList = [];
        this._atlasInfoMap = {};
        this._atlasRestoreHandler = null;
    }
    /**
   * The texture restore handler callback function
   * This callback function will be called whenever the device has been restored
   */ get atlasTextureRestoreHandler() {
        return this._atlasRestoreHandler;
    }
    set atlasTextureRestoreHandler(f) {
        this._atlasRestoreHandler = f;
    }
    /**
   * Gets the atlas texture of a given index
   * @param index - Index of the atlas bin
   * @returns Atlas texture for given index
   */ getAtlasTexture(index) {
        return this._atlasList[index];
    }
    /**
   * Gets the information about specified atlas
   * @param key - Key of the atlas
   * @returns Information of the atlas
   */ getAtlasInfo(key) {
        return this._atlasInfoMap[key] || null;
    }
    /**
   * Check if no atlas has been created
   * @returns true if no atlas has been created
   */ isEmpty() {
        return this._atlasList.length === 0;
    }
    /**
   * Removes all created atlases
   */ clear() {
        this._packer.clear();
        for (const tex of this._atlasList){
            tex.dispose();
        }
        this._atlasList = [];
        this._atlasInfoMap = {};
    }
    /**
   * Inserts a rectangle of a canvas to the atlas texture
   * @param key - Key of the atlas
   * @param ctx - The canvas context
   * @param x - x offset of the rectangle
   * @param y - y offset of the rectangle
   * @param w - width of the rectangle
   * @param h - height of the rectangle
   * @returns The atals info or null if insert failed
   */ pushCanvas(key, ctx, x, y, w, h) {
        const rc = this._packer.insert(w + 2 * this._rectBorderWidth, h + 2 * this._rectBorderWidth);
        if (rc) {
            const atlasX = rc.x + this._rectBorderWidth;
            const atlasY = rc.y + this._rectBorderWidth;
            this._updateAtlasTextureCanvas(rc.binIndex, ctx, atlasX, atlasY, w, h, x, y);
            const info = {
                atlasIndex: rc.binIndex,
                uMin: atlasX / this._binWidth,
                vMin: atlasY / this._binHeight,
                uMax: (atlasX + w) / this._binWidth,
                vMax: (atlasY + h) / this._binHeight,
                width: w,
                height: h
            };
            this._atlasInfoMap[key] = info;
            return info;
        }
        return null;
    }
    /**
   * Inserts a bitmap to the atlas texture
   * @param key - Key of the atlas
   * @param bitmap - The bitmap object
   * @returns The atals info or null if insert failed
   */ pushBitmap(key, bitmap) {
        const rc = this._packer.insert(bitmap.width + 2 * this._rectBorderWidth, bitmap.height + 2 * this._rectBorderWidth);
        if (rc) {
            const atlasX = rc.x + this._rectBorderWidth;
            const atlasY = rc.y + this._rectBorderWidth;
            this._updateAtlasTexture(rc.binIndex, bitmap, atlasX, atlasY);
            const info = {
                atlasIndex: rc.binIndex,
                uMin: atlasX / this._binWidth,
                vMin: atlasY / this._binHeight,
                uMax: (atlasX + bitmap.width) / this._binWidth,
                vMax: (atlasY + bitmap.height) / this._binHeight,
                width: bitmap.width,
                height: bitmap.height
            };
            this._atlasInfoMap[key] = info;
            return info;
        }
        return null;
    }
    /** @internal */ _createAtlasTexture() {
        const tex = this._device.createTexture2D('rgba8unorm', this._binWidth, this._binHeight, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        tex.update(new Uint8Array(tex.width * tex.height * 4), 0, 0, tex.width, tex.height);
        tex.restoreHandler = async ()=>{
            tex.update(new Uint8Array(tex.width * tex.height * 4), 0, 0, tex.width, tex.height);
            this._atlasRestoreHandler && await this._atlasRestoreHandler(tex);
        };
        return tex;
    }
    /** @internal */ _updateAtlasTextureCanvas(atlasIndex, ctx, x, y, w, h, xOffset, yOffset) {
        let textureAtlas = null;
        if (atlasIndex === this._atlasList.length) {
            textureAtlas = this._createAtlasTexture();
            this._atlasList.push(textureAtlas);
        } else {
            textureAtlas = this._atlasList[atlasIndex];
        }
        textureAtlas.updateFromElement(ctx.canvas, x, y, xOffset, yOffset, w, h);
    }
    /** @internal */ _updateAtlasTexture(atlasIndex, bitmap, x, y) {
        let textureAtlas = null;
        if (atlasIndex === this._atlasList.length) {
            textureAtlas = this._createAtlasTexture();
            this._atlasList.push(textureAtlas);
        } else {
            textureAtlas = this._atlasList[atlasIndex];
        }
        if (bitmap instanceof ImageBitmap) {
            textureAtlas.updateFromElement(bitmap, x, y, 0, 0, bitmap.width, bitmap.height);
        } else {
            const originValues = new Uint8Array(bitmap.data.buffer);
            textureAtlas.update(originValues, x, y, bitmap.width, bitmap.height);
        }
    }
}

/**
 * Manager of texture glyphs
 * @public
 */ class GlyphManager extends TextureAtlasManager {
    /**
   * Creates a new glyph manager instance
   * @param device - The render device
   * @param binWidth - Width of an atlas bin
   * @param binHeight - Height of an atlas bin
   * @param border - Border width of an atlas
   */ constructor(device, binWidth, binHeight, border){
        super(device, binWidth, binHeight, border, true);
        this.atlasTextureRestoreHandler = async ()=>{
            if (!this.isEmpty()) {
                this.clear();
            }
        };
    }
    /**
   * Gets the atlas information for given character
   * @param char - The character
   * @param font - Font of the character
   * @returns Atlas information for the glyph
   */ getGlyphInfo(char, font) {
        if (!char || !font) {
            return null;
        }
        let glyphInfo = this.getAtlasInfo(this._hash(char, font));
        if (!glyphInfo) {
            glyphInfo = this._cacheGlyph(char, font);
            glyphInfo.width = Math.round(glyphInfo.width * (font.maxHeight / font.maxHeightScaled));
            glyphInfo.height = font.maxHeight;
        }
        return glyphInfo;
    }
    /**
   * Measuring the width of a string
   * @param str - The string to be measured
   * @param charMargin - margin size between characters
   * @param font - Font of the string
   * @returns Width of the string
   */ measureStringWidth(str, charMargin, font) {
        let w = 0;
        for (const ch of str){
            w += charMargin + this.getCharWidth(ch, font);
        }
        return w;
    }
    /**
   * Clips a string so that it's width is not larger than the given value
   * @param str - The string to be clipped
   * @param width - The desired maximum width
   * @param charMargin - Margin size between characters
   * @param start - Start index of the string to be clipped
   * @param font - Font of the string
   * @returns 
   */ clipStringToWidth(str, width, charMargin, start, font) {
        let sum = 0;
        let i = start;
        for(; i < str.length; i++){
            sum += charMargin + this.getCharWidth(str[i], font);
            if (sum > width) {
                break;
            }
        }
        return i - start;
    }
    /** @internal */ _hash(char, font) {
        return `${font.family}@${font.size}&${char}`;
    }
    /** @internal */ _cacheGlyph(char, font) {
        const bitmap = this._getGlyphBitmap(char, font);
        return this.pushBitmap(this._hash(char, font), bitmap);
    }
    /**
   * Measuring width of a character
   * @param char - The character to be measured
   * @param font - Font of the character
   * @returns Width of the character
   */ getCharWidth(char, font) {
        if (!font) {
            return 0;
        }
        FontCanvas.font = font.fontNameScaled;
        const metric = FontCanvas.context.measureText(char);
        let w = metric.width;
        if (w === 0) {
            return 0;
        }
        if (typeof metric.actualBoundingBoxRight === 'number') {
            w = Math.floor(Math.max(w, metric.actualBoundingBoxRight) + 0.8);
        }
        w = Math.round(w * (font.maxHeight / font.maxHeightScaled));
        return w;
    }
    /** @internal */ _getGlyphBitmap(char, font) {
        if (!font) {
            return null;
        }
        FontCanvas.font = font.fontNameScaled;
        const metric = FontCanvas.context.measureText(char);
        let w = metric.width;
        if (w === 0) {
            return null;
        }
        if (typeof metric.actualBoundingBoxRight === 'number') {
            w = Math.floor(Math.max(w, metric.actualBoundingBoxRight) + 0.8);
        }
        const h = font.maxHeightScaled;
        FontCanvas.context.fillStyle = '#fff';
        FontCanvas.context.clearRect(0, 0, w + 2, h);
        FontCanvas.context.fillText(char, 0, -font.topScaled);
        return FontCanvas.context.getImageData(0, 0, w, h);
    }
}

const MAX_GLYPH_COUNT = 1024;
/**
 * Helper class to draw some text onto the screen
 * @public
 */ class DrawText {
    /** @internal */ static GLYPH_COUNT = MAX_GLYPH_COUNT;
    /** @internal */ static glyphManager = null;
    /** @internal */ static prepared = false;
    /** @internal */ static textVertexBuffer = null;
    /** @internal */ static textVertexLayout = null;
    /** @internal */ static textProgram = null;
    /** @internal */ static textBindGroup = null;
    /** @internal */ static textRenderStates = null;
    /** @internal */ static textOffset = 0;
    /** @internal */ static textMatrix = new Matrix4x4();
    /** @internal */ static font = null;
    /** @internal */ static vertexCache = null;
    /** @internal */ static colorValue = new Vector4();
    /** @internal */ static calculateTextMatrix(device, matrix) {
        const viewport = device.getViewport();
        const projectionMatrix = Matrix4x4.ortho(0, viewport.width, 0, viewport.height, 1, 100);
        const flipMatrix = Matrix4x4.translation(new Vector3(0, viewport.height, 0)).scaleRight(new Vector3(1, -1, 1));
        Matrix4x4.multiply(projectionMatrix, flipMatrix, matrix);
    }
    /**
   * Set the font that will be used to draw strings
   * @param device - The render device
   * @param name - The font name
   */ static setFont(device, name) {
        this.font = Font.fetchFont(name, device.getScale()) || Font.fetchFont('12px arial', device.getScale());
    }
    /**
   * Draw text onto the screen
   * @param device - The render device
   * @param text - The text to be drawn
   * @param color - The text color
   * @param x - X coordinate of the text
   * @param y - Y coordinate of the text
   */ static drawText(device, text, color, x, y) {
        if (text.length > 0) {
            device.pushDeviceStates();
            this.prepareDrawText(device);
            this.calculateTextMatrix(device, this.textMatrix);
            const colorValue = parseColor(color);
            this.colorValue.x = colorValue.r;
            this.colorValue.y = colorValue.g;
            this.colorValue.z = colorValue.b;
            this.colorValue.w = colorValue.a;
            this.textBindGroup.setValue('flip', device.type === 'webgpu' && device.getFramebuffer() ? 1 : 0);
            this.textBindGroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
            this.textBindGroup.setValue('textMatrix', this.textMatrix);
            this.textBindGroup.setValue('textColor', this.colorValue);
            device.setProgram(this.textProgram);
            device.setVertexLayout(this.textVertexLayout);
            device.setRenderStates(this.textRenderStates);
            device.setBindGroup(0, this.textBindGroup);
            let drawn = 0;
            const total = text.length;
            while(drawn < total){
                const count = Math.min(total - drawn, this.GLYPH_COUNT - this.textOffset);
                if (count > 0) {
                    x = this.drawTextNoOverflow(device, text, drawn, count, x, y);
                    drawn += count;
                    this.textOffset += count;
                }
                if (this.GLYPH_COUNT === this.textOffset) {
                    this.textOffset = 0;
                    device.flush();
                }
            }
            device.popDeviceStates();
        }
    }
    /** @internal */ static drawTextNoOverflow(device, text, start, count, x, y) {
        let drawn = 0;
        let atlasIndex = -1;
        let i = 0;
        for(; i < count; i++){
            const glyph = this.glyphManager.getGlyphInfo(text[i + start], this.font) || this.glyphManager.getGlyphInfo('?', this.font);
            if (atlasIndex >= 0 && glyph.atlasIndex !== atlasIndex) {
                this.textVertexBuffer.bufferSubData((this.textOffset + drawn) * 16 * 4, this.vertexCache, (this.textOffset + drawn) * 16, (i - drawn) * 16);
                this.textBindGroup.setTexture('tex', this.glyphManager.getAtlasTexture(atlasIndex));
                device.draw('triangle-list', (this.textOffset + drawn) * 6, (i - drawn) * 6);
                drawn = i;
            }
            atlasIndex = glyph.atlasIndex;
            const base = (this.textOffset + i) * 16;
            this.vertexCache[base + 0] = x;
            this.vertexCache[base + 1] = y;
            this.vertexCache[base + 2] = glyph.uMin;
            this.vertexCache[base + 3] = glyph.vMin;
            this.vertexCache[base + 4] = x + glyph.width;
            this.vertexCache[base + 5] = y;
            this.vertexCache[base + 6] = glyph.uMax;
            this.vertexCache[base + 7] = glyph.vMin;
            this.vertexCache[base + 8] = x + glyph.width;
            this.vertexCache[base + 9] = y + glyph.height;
            this.vertexCache[base + 10] = glyph.uMax;
            this.vertexCache[base + 11] = glyph.vMax;
            this.vertexCache[base + 12] = x;
            this.vertexCache[base + 13] = y + glyph.height;
            this.vertexCache[base + 14] = glyph.uMin;
            this.vertexCache[base + 15] = glyph.vMax;
            x += glyph.width;
        }
        this.textVertexBuffer.bufferSubData((this.textOffset + drawn) * 16 * 4, this.vertexCache, (this.textOffset + drawn) * 16, (i - drawn) * 16);
        this.textBindGroup.setTexture('tex', this.glyphManager.getAtlasTexture(atlasIndex));
        device.draw('triangle-list', (this.textOffset + drawn) * 6, (i - drawn) * 6);
        return x;
    }
    /** @internal */ static prepareDrawText(device) {
        if (!this.prepared) {
            this.prepared = true;
            this.font = this.font || Font.fetchFont('16px arial', device.getScale());
            this.glyphManager = new GlyphManager(device, 1024, 1024, 1);
            this.vertexCache = new Float32Array(this.GLYPH_COUNT * 16);
            this.textVertexBuffer = device.createInterleavedVertexBuffer([
                'position_f32x2',
                'tex0_f32x2'
            ], this.vertexCache, {
                dynamic: true
            });
            const indices = new Uint16Array(this.GLYPH_COUNT * 6);
            for(let i = 0; i < this.GLYPH_COUNT; i++){
                const base = i * 4;
                indices[i * 6 + 0] = base + 0;
                indices[i * 6 + 1] = base + 1;
                indices[i * 6 + 2] = base + 2;
                indices[i * 6 + 3] = base + 0;
                indices[i * 6 + 4] = base + 2;
                indices[i * 6 + 5] = base + 3;
            }
            const textIndexBuffer = device.createIndexBuffer(indices);
            this.textVertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: this.textVertexBuffer
                    }
                ],
                indexBuffer: textIndexBuffer
            });
            this.textOffset = 0;
            this.textProgram = device.buildRenderProgram({
                vertex (pb) {
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$inputs.uv = pb.vec2().attrib('texCoord0');
                    this.$outputs.uv = pb.vec2();
                    this.flip = pb.int(0).uniform(0);
                    this.textMatrix = pb.mat4().uniform(0);
                    pb.main(function() {
                        this.$builtins.position = pb.mul(this.textMatrix, pb.vec4(this.$inputs.pos, -50, 1));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                        this.$outputs.uv = this.$inputs.uv;
                    });
                },
                fragment (pb) {
                    this.$outputs.color = pb.vec4();
                    this.textColor = pb.vec4().uniform(0);
                    this.tex = pb.tex2D().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    pb.main(function() {
                        this.alpha = pb.mul(pb.textureSample(this.tex, this.$inputs.uv).a, this.textColor.a);
                        this.$if(pb.notEqual(this.srgbOut, 0), function() {
                            this.$outputs.color = pb.vec4(pb.mul(pb.pow(this.textColor.rgb, pb.vec3(1 / 2.2)), this.alpha), this.alpha);
                        }).$else(function() {
                            this.$outputs.color = pb.vec4(pb.mul(this.textColor.rgb, this.alpha), this.alpha);
                        });
                    });
                }
            });
            this.textBindGroup = device.createBindGroup(this.textProgram.bindGroupLayouts[0]);
            this.textRenderStates = device.createRenderStateSet();
            this.textRenderStates.useBlendingState().enable(true).setBlendFuncRGB('one', 'inv-src-alpha').setBlendFuncAlpha('zero', 'one');
            this.textRenderStates.useDepthState().enableTest(false).enableWrite(false);
            this.textRenderStates.useRasterizerState().setCullMode('none');
        }
    }
}

/**
 * Base class for rendering device
 * @public
 */ class BaseDevice {
    _canvas;
    _canvasClientWidth;
    _canvasClientHeight;
    _gpuObjectList;
    _gpuMemCost;
    _disposeObjectList;
    _beginFrameTime;
    _endFrameTime;
    _frameInfo;
    _cpuTimer;
    _gpuTimer;
    _runningLoop;
    _fpsCounter;
    _runLoopFunc;
    _backend;
    _beginFrameCounter;
    _programBuilder;
    _stateStack;
    constructor(cvs, backend){
        this._backend = backend;
        this._gpuObjectList = {
            textures: [],
            samplers: [],
            buffers: [],
            programs: [],
            framebuffers: [],
            vertexArrayObjects: [],
            bindGroups: []
        };
        this._canvas = cvs;
        this._canvas.setAttribute('tabindex', '1');
        this._canvasClientWidth = cvs.clientWidth;
        this._canvasClientHeight = cvs.clientHeight;
        this._gpuMemCost = 0;
        this._disposeObjectList = [];
        this._beginFrameTime = 0;
        this._endFrameTime = 0;
        this._runLoopFunc = null;
        this._frameInfo = {
            frameCounter: 0,
            frameTimestamp: 0,
            elapsedTimeCPU: 0,
            elapsedTimeGPU: 0,
            elapsedFrame: 0,
            elapsedOverall: 0,
            FPS: 0,
            drawCalls: 0,
            computeCalls: 0,
            nextFrameCall: []
        };
        this._programBuilder = new ProgramBuilder(this);
        this._cpuTimer = new CPUTimer();
        this._gpuTimer = null;
        this._runningLoop = null;
        this._fpsCounter = {
            time: 0,
            frame: 0
        };
        this._stateStack = [];
        this._beginFrameCounter = 0;
        this._registerEventHandlers();
    }
    get backend() {
        return this._backend;
    }
    get videoMemoryUsage() {
        return this._gpuMemCost;
    }
    get frameInfo() {
        return this._frameInfo;
    }
    get isRendering() {
        return this._runningLoop !== null;
    }
    get canvas() {
        return this._canvas;
    }
    get type() {
        return this._backend.typeName();
    }
    get runLoopFunction() {
        return this._runLoopFunc;
    }
    get programBuilder() {
        return this._programBuilder;
    }
    setFont(fontName) {
        DrawText.setFont(this, fontName);
    }
    drawText(text, x, y, color) {
        DrawText.drawText(this, text, color, x, y);
    }
    disposeObject(obj, remove = true) {
        if (obj) {
            if (remove) {
                this.removeGPUObject(obj);
            }
            if (!obj.disposed) {
                if (this.isContextLost()) {
                    obj.destroy();
                } else {
                    this._disposeObjectList.push(obj);
                }
            }
            obj.dispatchEvent(null, 'disposed');
        }
    }
    async restoreObject(obj) {
        if (obj && obj.disposed && !this.isContextLost()) {
            await obj.restore();
            if (obj.restoreHandler) {
                await obj.restoreHandler(obj);
            }
        }
    }
    enableGPUTimeRecording(enable) {
        if (enable && !this._gpuTimer) {
            this._gpuTimer = this.createGPUTimer();
        } else if (!enable) {
            this._gpuTimer?.end();
            this._gpuTimer = null;
        }
    }
    beginFrame() {
        if (this._beginFrameCounter === 0) {
            for (const obj of this._disposeObjectList){
                obj.destroy();
            }
            this._disposeObjectList = [];
        }
        this._beginFrameCounter++;
        this._beginFrameTime = this._cpuTimer.now();
        this.updateFrameInfo();
        return this.onBeginFrame();
    }
    endFrame() {
        if (this._beginFrameCounter > 0) {
            this._beginFrameCounter--;
            if (this._beginFrameCounter === 0) {
                this._endFrameTime = this._cpuTimer.now();
                this.onEndFrame();
            }
        }
    }
    getVertexAttribFormat(semantic, dataType, componentCount) {
        return getVertexAttribFormat(semantic, dataType, componentCount);
    }
    createInterleavedVertexBuffer(attribFormats, data, options) {
        if (options && options.usage && options.usage !== 'vertex') {
            console.error(`createVertexBuffer() failed: options.usage must be 'vertex' or not set`);
            return null;
        }
        let size = 0;
        for (const format of attribFormats){
            size += getVertexFormatSize(format);
        }
        const vertexBufferType = makeVertexBufferType(data.byteLength / size >> 0, ...attribFormats);
        const opt = Object.assign({
            usage: 'vertex',
            dynamic: false,
            managed: true,
            storage: false
        }, options || {});
        if (opt.storage) {
            opt.dynamic = false;
            opt.managed = false;
        }
        if (opt.dynamic) {
            opt.managed = false;
        }
        return this.createStructuredBuffer(vertexBufferType, opt, data);
    }
    createVertexBuffer(attribFormat, data, options) {
        if (options && options.usage && options.usage !== 'vertex') {
            console.error(`createVertexBuffer() failed: options.usage must be 'vertex' or not set`);
            return null;
        }
        const count = getVertexFormatSize(attribFormat);
        const vertexBufferType = makeVertexBufferType(data.byteLength / count >> 0, attribFormat);
        const opt = Object.assign({
            usage: 'vertex',
            dynamic: false,
            managed: true,
            storage: false
        }, options || {});
        if (opt.storage) {
            opt.dynamic = false;
            opt.managed = false;
        }
        if (opt.dynamic) {
            opt.managed = false;
        }
        return this.createStructuredBuffer(vertexBufferType, opt, data);
    }
    draw(primitiveType, first, count) {
        this._frameInfo.drawCalls++;
        this._draw(primitiveType, first, count);
    }
    drawInstanced(primitiveType, first, count, numInstances) {
        this._frameInfo.drawCalls++;
        this._drawInstanced(primitiveType, first, count, numInstances);
    }
    compute(workgroupCountX, workgroupCountY, workgroupCountZ) {
        this._frameInfo.computeCalls++;
        this._compute(workgroupCountX, workgroupCountY, workgroupCountZ);
    }
    runNextFrame(f) {
        if (f) {
            this._frameInfo.nextFrameCall.push(f);
        }
    }
    cancelNextFrameCall(f) {
        const index = this._frameInfo.nextFrameCall.indexOf(f);
        if (index >= 0) {
            this._frameInfo.nextFrameCall.splice(index, 1);
        }
    }
    exitLoop() {
        if (this._runningLoop) {
            cancelAnimationFrame(this._runningLoop);
            this._runningLoop = null;
        }
    }
    runLoop(func) {
        if (this._runningLoop !== null) {
            console.error('Device.runLoop() can not be nested');
            return;
        }
        if (!func) {
            console.error('Device.runLoop() argment error');
            return;
        }
        const that = this;
        that._runLoopFunc = func;
        (function entry() {
            that._runningLoop = requestAnimationFrame(entry);
            if (that.beginFrame()) {
                that._runLoopFunc(that);
                that.endFrame();
            }
        })();
    }
    pushDeviceStates() {
        this._stateStack.push({
            windowOrderReversed: this.isWindingOrderReversed(),
            framebuffer: this.getFramebuffer(),
            viewport: this.getViewport(),
            scissor: this.getScissor(),
            program: this.getProgram(),
            renderStateSet: this.getRenderStates(),
            vertexLayout: this.getVertexLayout(),
            bindGroups: [
                this.getBindGroup(0),
                this.getBindGroup(1),
                this.getBindGroup(2),
                this.getBindGroup(3)
            ]
        });
    }
    popDeviceStates() {
        if (this._stateStack.length === 0) {
            console.error('Device.popDeviceStates(): stack is empty');
        } else {
            const top = this._stateStack.pop();
            this.setFramebuffer(top.framebuffer);
            this.setViewport(top.viewport);
            this.setScissor(top.scissor);
            this.setProgram(top.program);
            this.setRenderStates(top.renderStateSet);
            this.setVertexLayout(top.vertexLayout);
            this.setBindGroup(0, ...top.bindGroups[0]);
            this.setBindGroup(1, ...top.bindGroups[1]);
            this.setBindGroup(2, ...top.bindGroups[2]);
            this.setBindGroup(3, ...top.bindGroups[3]);
            this.reverseVertexWindingOrder(top.windowOrderReversed);
        }
    }
    getGPUObjects() {
        return this._gpuObjectList;
    }
    getGPUObjectById(uid) {
        for (const list of [
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.buffers,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.programs,
            this._gpuObjectList.vertexArrayObjects
        ]){
            for (const obj of list){
                if (obj.uid === uid) {
                    return obj;
                }
            }
        }
        return null;
    }
    screenToDevice(val) {
        return this.getFramebuffer() ? val : Math.round(val * this.getScale());
    }
    deviceToScreen(val) {
        return this.getFramebuffer() ? val : Math.round(val / this.getScale());
    }
    buildRenderProgram(options) {
        return this._programBuilder.buildRenderProgram(options);
    }
    buildComputeProgram(options) {
        return this._programBuilder.buildComputeProgram(options);
    }
    addGPUObject(obj) {
        const list = this.getGPUObjectList(obj);
        if (list && list.indexOf(obj) < 0) {
            list.push(obj);
            this.dispatchEvent(new DeviceGPUObjectAddedEvent(obj));
        }
    }
    removeGPUObject(obj) {
        const list = this.getGPUObjectList(obj);
        if (list) {
            const index = list.indexOf(obj);
            if (index >= 0) {
                list.splice(index, 1);
                this.dispatchEvent(new DeviceGPUObjectRemovedEvent(obj));
            }
        }
    }
    updateVideoMemoryCost(delta) {
        this._gpuMemCost += delta;
    }
    _onresize() {
        if (this._canvasClientWidth !== this._canvas.clientWidth || this._canvasClientHeight !== this._canvas.clientHeight) {
            this._canvasClientWidth = this._canvas.clientWidth;
            this._canvasClientHeight = this._canvas.clientHeight;
            this.dispatchEvent(new DeviceResizeEvent(this._canvasClientWidth, this._canvasClientHeight));
        }
    }
    _registerEventHandlers() {
        const canvas = this._canvas;
        const that = this;
        if (window.ResizeObserver) {
            new window.ResizeObserver((entries)=>{
                that._onresize();
            }).observe(canvas, {});
        } else {
            if (window.MutationObserver) {
                new MutationObserver(function(mutations) {
                    if (mutations.length > 0) {
                        that._onresize();
                    }
                }).observe(canvas, {
                    attributes: true,
                    attributeFilter: [
                        'style'
                    ]
                });
            }
            window.addEventListener('resize', ()=>{
                this._onresize();
            });
        }
    }
    updateFrameInfo() {
        this._frameInfo.frameCounter++;
        this._frameInfo.drawCalls = 0;
        this._frameInfo.computeCalls = 0;
        const now = this._beginFrameTime;
        if (this._frameInfo.frameTimestamp === 0) {
            this._frameInfo.frameTimestamp = now;
            this._frameInfo.elapsedTimeCPU = 0;
            this._frameInfo.elapsedTimeGPU = 0;
            this._frameInfo.elapsedFrame = 0;
            this._frameInfo.elapsedOverall = 0;
            this._frameInfo.FPS = 0;
            this._fpsCounter.time = now;
            this._fpsCounter.frame = this._frameInfo.frameCounter;
            if (this._gpuTimer) {
                this._gpuTimer.begin();
            }
        } else {
            this._frameInfo.elapsedFrame = now - this._frameInfo.frameTimestamp;
            this._frameInfo.elapsedOverall += this._frameInfo.elapsedFrame;
            let gpuTime = 0;
            let cpuTime = 0;
            if (this._endFrameTime !== 0) {
                gpuTime = now - this._endFrameTime;
                cpuTime = this._endFrameTime - this._frameInfo.frameTimestamp;
            }
            this._frameInfo.frameTimestamp = now;
            if (now >= this._fpsCounter.time + 1000) {
                this._frameInfo.FPS = (this._frameInfo.frameCounter - this._fpsCounter.frame) * 1000 / (now - this._fpsCounter.time);
                this._fpsCounter.time = now;
                this._fpsCounter.frame = this._frameInfo.frameCounter;
                this._frameInfo.elapsedTimeGPU = gpuTime;
                this._frameInfo.elapsedTimeCPU = cpuTime;
            }
        }
        for (const f of this._frameInfo.nextFrameCall){
            f();
        }
        this._frameInfo.nextFrameCall.length = 0;
    }
    getGPUObjectList(obj) {
        let list = null;
        if (obj.isTexture()) {
            list = this._gpuObjectList.textures;
        } else if (obj.isSampler()) {
            list = this._gpuObjectList.samplers;
        } else if (obj.isBuffer()) {
            list = this._gpuObjectList.buffers;
        } else if (obj.isFramebuffer()) {
            list = this._gpuObjectList.framebuffers;
        } else if (obj.isProgram()) {
            list = this._gpuObjectList.programs;
        } else if (obj.isVertexLayout()) {
            list = this._gpuObjectList.vertexArrayObjects;
        } else if (obj.isBindGroup()) {
            list = this._gpuObjectList.bindGroups;
        }
        return list;
    }
    invalidateAll() {
        for (const list of [
            this._gpuObjectList.buffers,
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.programs,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.vertexArrayObjects,
            this._gpuObjectList.bindGroups
        ]){
            for (const obj of list){
                this.disposeObject(obj, false);
            }
        }
        if (this.isContextLost()) {
            for (const obj of this._disposeObjectList){
                obj.destroy();
            }
            this._disposeObjectList = [];
        }
    }
    async reloadAll() {
        const promises = [];
        for (const list of [
            this._gpuObjectList.buffers,
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.programs,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.vertexArrayObjects,
            this._gpuObjectList.bindGroups
        ]){
            // obj.reload() may change the list, so make a copy first
            for (const obj of list.slice()){
                promises.push(obj.reload());
            }
        }
        Promise.all(promises);
        return;
    }
    parseTextureOptions(options) {
        const noMipmapFlag = options?.samplerOptions?.mipFilter === 'none' ? GPUResourceUsageFlags.TF_NO_MIPMAP : 0;
        const writableFlag = options?.writable ? GPUResourceUsageFlags.TF_WRITABLE : 0;
        const dynamicFlag = options?.dynamic ? GPUResourceUsageFlags.DYNAMIC : 0;
        return noMipmapFlag | writableFlag | dynamicFlag;
    }
    parseBufferOptions(options, defaultUsage) {
        const usage = options?.usage || defaultUsage;
        let usageFlag;
        switch(usage){
            case 'uniform':
                usageFlag = GPUResourceUsageFlags.BF_UNIFORM;
                options.managed = false;
                options.dynamic = options.dynamic ?? true;
                break;
            case 'vertex':
                usageFlag = GPUResourceUsageFlags.BF_VERTEX;
                break;
            case 'index':
                usageFlag = GPUResourceUsageFlags.BF_INDEX;
                break;
            case 'read':
                usageFlag = GPUResourceUsageFlags.BF_READ;
                options.managed = false;
                break;
            case 'write':
                usageFlag = GPUResourceUsageFlags.BF_WRITE;
                options.managed = false;
                break;
            default:
                usageFlag = 0;
                break;
        }
        const storageFlag = options?.storage ?? false ? GPUResourceUsageFlags.BF_STORAGE : 0;
        const dynamicFlag = options?.dynamic ?? false ? GPUResourceUsageFlags.DYNAMIC : 0;
        const managedFlag = dynamicFlag === 0 && (options?.managed ?? true) ? GPUResourceUsageFlags.MANAGED : 0;
        return usageFlag | storageFlag | dynamicFlag | managedFlag;
    }
}

/**
 * Structured buffer data
 * @public
 */ class StructuredBufferData {
    /** @internal */ _cache;
    /** @internal */ _buffer;
    /** @internal */ _size;
    /** @internal */ _uniformMap;
    /** @internal */ _uniformPositions;
    /**
   * Creates a new structured buffer data
   * @param layout - Layout of the structure
   * @param buffer - Buffer that holds the data
   */ constructor(layout, buffer){
        this._size = layout.byteSize + 15 & ~15;
        if (this._size <= 0) {
            throw new Error(`UniformBuffer(): invalid uniform buffer byte size: ${this._size}`);
        }
        // this._cache = new ArrayBuffer(size);
        this._uniformMap = {};
        this._uniformPositions = {};
        this._cache = buffer instanceof ArrayBuffer ? buffer : null;
        this._buffer = buffer instanceof ArrayBuffer ? null : buffer;
        this.init(layout, 0, '');
    }
    /** The buffer size in bytes */ get byteLength() {
        return this._size;
    }
    /** Get the data cache buffer */ get buffer() {
        return this._cache;
    }
    /** Get all the uniform datas */ get uniforms() {
        return this._uniformMap;
    }
    /**
   * Sets the value of a structure member
   * @param name - Name of the member
   * @param value - Value to set
   */ set(name, value) {
        if (value !== undefined) {
            const view = this._uniformMap[name];
            if (view) {
                if (this._cache) {
                    if (typeof value === 'number') {
                        view[0] = value;
                    } else if (value?._v) {
                        view.set(value._v);
                    } else if (typeof value?.length === 'number') {
                        view.set(value);
                    } else {
                        throw new Error('invalid uniform value');
                    }
                } else {
                    const size = this._uniformPositions[name][1];
                    if (typeof value === 'number') {
                        view[0] = value;
                        this._buffer.bufferSubData(this._uniformPositions[name][0], view);
                    } else if (value['BYTES_PER_ELEMENT'] && size <= value['byteLength']) {
                        const arr = value;
                        this._buffer.bufferSubData(this._uniformPositions[name][0], arr, 0, size / arr.BYTES_PER_ELEMENT >> 0);
                    } else {
                        throw new Error('invalid uniform value');
                    }
                }
            } else {
                const proto = Object.getPrototypeOf(value);
                if (proto === Object.getPrototypeOf({})) {
                    this.setStruct(name, value);
                } else {
                    throw new Error('invalid uniform value');
                }
            }
        }
    }
    /** @internal */ setStruct(name, value) {
        for(const k in value){
            this.set(`${name}.${k}`, value[k]);
        }
    }
    /** @internal */ init(layout, offset, prefix) {
        for (const entry of layout.entries){
            if (entry.subLayout) {
                offset = this.init(entry.subLayout, offset, `${prefix}${entry.name}.`);
            } else {
                const name = `${prefix}${entry.name}`;
                if (this._uniformPositions[name]) {
                    throw new Error(`UniformBuffer(): duplicate uniform name: ${name}`);
                }
                if (entry.offset < offset || entry.byteSize < 0) {
                    throw new Error('UniformBuffer(): invalid layout');
                }
                this._uniformPositions[name] = [
                    entry.offset,
                    entry.byteSize
                ];
                let viewCtor = null;
                switch(entry.type){
                    case PBPrimitiveType.F32:
                        viewCtor = Float32Array;
                        break;
                    case PBPrimitiveType.U32:
                    case PBPrimitiveType.BOOL:
                        viewCtor = Uint32Array;
                        break;
                    case PBPrimitiveType.I32:
                        viewCtor = Int32Array;
                        break;
                    case PBPrimitiveType.U16:
                    case PBPrimitiveType.U16_NORM:
                    case PBPrimitiveType.F16:
                        viewCtor = Uint16Array;
                        break;
                    case PBPrimitiveType.I16:
                    case PBPrimitiveType.I16_NORM:
                        viewCtor = Int16Array;
                        break;
                    case PBPrimitiveType.U8:
                    case PBPrimitiveType.U8_NORM:
                        viewCtor = Uint8Array;
                        break;
                    case PBPrimitiveType.I8:
                    case PBPrimitiveType.I8_NORM:
                        viewCtor = Int8Array;
                        break;
                }
                if (!viewCtor) {
                    throw new Error(`UniformBuffer(): invalid data type for uniform: ${name}`);
                }
                if (entry.byteSize % viewCtor.BYTES_PER_ELEMENT) {
                    throw new Error(`UniformBuffer(): invalid byte size for uniform: ${name}`);
                }
                if (this._cache) {
                    this._uniformMap[name] = new viewCtor(this._cache, entry.offset, entry.byteSize / viewCtor.BYTES_PER_ELEMENT);
                } else {
                    this._uniformMap[name] = new viewCtor(1);
                }
                offset = entry.offset + entry.byteSize;
            }
        }
        return offset;
    }
}

let _uniqueId = 0;
class WebGPUObject extends makeEventTarget(Object)() {
    _device;
    _object;
    _uid;
    _cid;
    _name;
    _queueState;
    _restoreHandler;
    constructor(device){
        super();
        this._device = device;
        this._object = null;
        this._uid = ++_uniqueId;
        this._cid = 1;
        this._name = `${genDefaultName(this)}#${this._uid}`;
        this._queueState = 0;
        this._restoreHandler = null;
        this._device.addGPUObject(this);
    }
    get device() {
        return this._device;
    }
    get object() {
        return this._object;
    }
    get uid() {
        return this._uid;
    }
    get cid() {
        return this._cid;
    }
    get disposed() {
        return !this._object;
    }
    get restoreHandler() {
        return this._restoreHandler;
    }
    set restoreHandler(handler) {
        this._restoreHandler = handler;
    }
    get name() {
        return this._name;
    }
    set name(val) {
        if (val !== this._name) {
            const evt = new DeviceGPUObjectRenameEvent(this, this._name);
            this._name = val;
            this._device.dispatchEvent(evt);
        }
    }
    get queueState() {
        return this._queueState;
    }
    set queueState(val) {
        this._queueState = val;
    }
    isVertexLayout() {
        return false;
    }
    isFramebuffer() {
        return false;
    }
    isSampler() {
        return false;
    }
    isTexture() {
        return false;
    }
    isTexture2D() {
        return false;
    }
    isTexture2DArray() {
        return false;
    }
    isTexture3D() {
        return false;
    }
    isTextureCube() {
        return false;
    }
    isTextureVideo() {
        return false;
    }
    isProgram() {
        return false;
    }
    isBuffer() {
        return false;
    }
    isBindGroup() {
        return false;
    }
    dispose() {
        if (!this.disposed) {
            this._device.disposeObject(this, true);
        }
    }
    async reload() {
        if (this.disposed) {
            const p = this._device.restoreObject(this);
            this._cid++;
            return p;
        }
    }
    destroy() {
        throw new Error('Abstract function call: dispose()');
    }
    async restore() {
        throw new Error('Abstract function call: restore()');
    }
}

class WebGPUProgram extends WebGPUObject {
    static _hashCounter = 0;
    _type;
    _vs;
    _fs;
    _cs;
    _label;
    _hash;
    _error;
    _bindGroupLayouts;
    _vertexAttributes;
    _csModule;
    _vsModule;
    _fsModule;
    _pipelineLayout;
    constructor(device, params){
        super(device);
        this._type = params.type;
        this._label = params.label;
        this._bindGroupLayouts = [
            ...params.params.bindGroupLayouts
        ];
        this._error = '';
        if (params.type === 'render') {
            const renderParams = params.params;
            this._vs = renderParams.vs;
            this._fs = renderParams.fs;
            this._vertexAttributes = renderParams.vertexAttributes ? renderParams.vertexAttributes.join(':') : '';
        } else {
            const computeParams = params.params;
            this._cs = computeParams.source;
        }
        this._load();
        this._hash = String(++WebGPUProgram._hashCounter);
    }
    get type() {
        return this._type;
    }
    get label() {
        return this._label;
    }
    getCompileError() {
        return this._error;
    }
    getShaderSource(kin) {
        switch(kin){
            case 'vertex':
                return this._vs;
            case 'fragment':
                return this._fs;
            case 'compute':
                return this._cs;
        }
    }
    getBindingInfo(name) {
        for(let group = 0; group < this._bindGroupLayouts.length; group++){
            const layout = this._bindGroupLayouts[group];
            const bindName = layout.nameMap?.[name] ?? name;
            for(let binding = 0; binding < layout.entries.length; binding++){
                const bindingPoint = layout.entries[binding];
                if (bindingPoint.name === bindName) {
                    return {
                        group: group,
                        binding: binding,
                        type: bindingPoint.type
                    };
                }
            }
        }
        return null;
    }
    get bindGroupLayouts() {
        return this._bindGroupLayouts;
    }
    get vertexAttributes() {
        return this._vertexAttributes;
    }
    get hash() {
        return this._hash;
    }
    getPipelineLayout() {
        return this._pipelineLayout;
    }
    getShaderModule() {
        return {
            vsModule: this._vsModule,
            fsModule: this._fsModule,
            csModule: this._csModule,
            pipelineLayout: this._pipelineLayout
        };
    }
    get fsModule() {
        return this._fsModule;
    }
    destroy() {
        this._vsModule = null;
        this._fsModule = null;
        this._pipelineLayout = null;
        this._object = null;
    }
    async restore() {
        if (!this._object) {
            this._load();
        }
    }
    isProgram() {
        return true;
    }
    createUniformBuffer(uniform) {
        const type = this.getBindingInfo(uniform)?.type;
        return type ? this.device.createStructuredBuffer(type, {
            usage: 'uniform'
        }) : null;
    }
    _load() {
        if (this._type === 'render') {
            this._vsModule = this.createShaderModule(this._vs);
            this._fsModule = this.createShaderModule(this._fs);
        } else {
            this._csModule = this.createShaderModule(this._cs);
        }
        this._pipelineLayout = this.createPipelineLayout(this._bindGroupLayouts);
        this._object = {};
    }
    createPipelineLayout(bindGroupLayouts) {
        const layouts = [];
        bindGroupLayouts.forEach((val)=>{
            layouts.push(this._device.fetchBindGroupLayout(val));
        });
        return this._device.device.createPipelineLayout({
            bindGroupLayouts: layouts
        });
    }
    createShaderModule(code) {
        let sm = this._device.device.createShaderModule({
            code
        });
        if (sm) {
            const func = sm.compilationInfo || sm.getCompilationInfo;
            if (!func) {
                return sm;
            }
            func.call(sm).then((compilationInfo)=>{
                let err = false;
                if (compilationInfo?.messages?.length > 0) {
                    let msg = '';
                    for (const message of compilationInfo.messages){
                        if (message.type === 'error') {
                            err = true;
                        }
                        msg += `Line ${message.lineNum}:${message.linePos} - ${code.slice(message.offset, message.offset + message.length)}\n`;
                        msg += `${message.message}\n`;
                        if (message.type === 'error') {
                            err = true;
                            console.error(msg);
                        } else if (message.type === 'warning') {
                            console.warn(msg);
                        } else {
                            console.log(msg);
                        }
                        this._error += msg;
                    }
                }
                if (err) {
                    sm = null;
                }
            });
        }
        return sm;
    }
    use() {
        this._device.setProgram(this);
    }
}

class UploadRingBuffer {
    _device;
    _bufferList;
    _defaultSize;
    _unmappedBufferList;
    constructor(device, defaultSize = 64 * 1024){
        this._device = device;
        this._bufferList = [];
        this._defaultSize = defaultSize;
        this._unmappedBufferList = [];
    }
    uploadBuffer(src, dst, srcOffset, dstOffset, uploadSize, allowOverlap) {
        const size = uploadSize + 3 & ~3;
        const mappedBuffer = this.fetchBufferMapped(size, !!allowOverlap);
        if (src) {
            const mappedRange = mappedBuffer.mappedRange; //mappedBuffer.buffer.getMappedRange(mappedBuffer.offset, size);
            new Uint8Array(mappedRange, mappedBuffer.offset, size).set(new Uint8Array(src, srcOffset, uploadSize));
        }
        const upload = {
            mappedBuffer: {
                ...mappedBuffer
            },
            uploadSize: size,
            uploadBuffer: dst,
            uploadOffset: dstOffset
        };
        mappedBuffer.offset += size;
        mappedBuffer.offset = mappedBuffer.offset + 7 & ~7;
        return upload;
    }
    beginUploads() {
        for(let i = this._bufferList.length - 1; i >= 0; i--){
            const buffer = this._bufferList[i];
            if (buffer.used) {
                buffer.buffer.unmap();
                this._unmappedBufferList.push(buffer);
                this._bufferList.splice(i, 1);
                buffer.mappedRange = null;
            }
        }
        return this._unmappedBufferList.length;
    }
    endUploads() {
        for (const buffer of this._unmappedBufferList){
            buffer.buffer.mapAsync(GPUMapMode.WRITE).then(()=>{
                buffer.offset = 0;
                buffer.used = false;
                buffer.mappedRange = buffer.buffer.getMappedRange();
                this._bufferList.push(buffer);
            });
        }
        this._unmappedBufferList = [];
    }
    purge() {
        for(let i = this._bufferList.length - 1; i >= 0; i--){
            const buffer = this._bufferList[i];
            if (buffer.mappedRange) {
                buffer.buffer.unmap();
                buffer.buffer.destroy();
            }
        }
        this._bufferList = [];
        for (const buffer of this._unmappedBufferList){
            buffer.buffer.destroy();
        }
        this._unmappedBufferList = [];
    }
    fetchBufferMapped(size, allowOverlap) {
        for (const buffer of this._bufferList){
            if (allowOverlap || buffer.size - buffer.offset >= size) {
                buffer.used = true;
                return buffer;
            }
        }
        const bufferSize = Math.max(size, this._defaultSize) + 3 & ~3;
        const buf = this._device.device.createBuffer({
            label: `StagingRingBuffer${this._bufferList.length}:${bufferSize}`,
            size: bufferSize,
            usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
            mappedAtCreation: true
        });
        this._bufferList.push({
            buffer: buf,
            size: bufferSize,
            offset: 0,
            used: true,
            mappedRange: buf.getMappedRange()
        });
        return this._bufferList[this._bufferList.length - 1];
    }
}

class WebGPUBuffer extends WebGPUObject {
    _size;
    _usage;
    _gpuUsage;
    _memCost;
    _ringBuffer;
    _pendingUploads;
    constructor(device, usage, data){
        super(device);
        this._object = null;
        this._memCost = 0;
        this._usage = usage;
        this._gpuUsage = 0;
        this._size = typeof data === 'number' ? data : data.byteLength;
        if (this._size <= 0) {
            throw new Error('can not create buffer with zero size');
        }
        this._ringBuffer = new UploadRingBuffer(device, this._size + 15 & ~15);
        this._pendingUploads = [];
        this.load(typeof data === 'number' ? null : data);
    }
    get hash() {
        return this._object ? this._device.gpuGetObjectHash(this._object) : 0;
    }
    get byteLength() {
        return this._size;
    }
    get usage() {
        return this._usage;
    }
    get gpuUsage() {
        return this._gpuUsage;
    }
    getPendingUploads() {
        return this._pendingUploads;
    }
    clearPendingUploads() {
        if (this._pendingUploads.length > 0) {
            this._pendingUploads = [];
            this.beginSyncChanges(null);
            this.endSyncChanges();
        }
    }
    bufferSubData(dstByteOffset, data, srcOffset, srcLength) {
        srcOffset = Number(srcOffset) || 0;
        dstByteOffset = Number(dstByteOffset) || 0;
        srcLength = Number(srcLength) || data.length - srcOffset;
        if (srcOffset + srcLength > data.length) {
            throw new Error('bufferSubData() failed: source buffer is too small');
        }
        if (dstByteOffset + srcLength * data.BYTES_PER_ELEMENT > this.byteLength) {
            throw new Error('bufferSubData() failed: dest buffer is too small');
        }
        let uploadSize = srcLength * data.BYTES_PER_ELEMENT;
        if ((dstByteOffset & 3) !== 0 || (uploadSize & 3) !== 0) {
            throw new Error('bufferSubData() failed: destination byte offset or upload size must be 4 bytes aligned');
        }
        const uploadOffset = data.byteOffset + srcOffset * data.BYTES_PER_ELEMENT;
        const writeOffset = dstByteOffset;
        const writeSize = uploadSize;
        if (this._pendingUploads.length === 0) {
            this.pushUpload(this._pendingUploads, data.buffer, uploadOffset, dstByteOffset, uploadSize);
        } else {
            let newPendings = [];
            let added = false;
            for(let i = 0; i < this._pendingUploads.length; i++){
                const upload = this._pendingUploads[i];
                if (upload.uploadOffset + upload.uploadSize < dstByteOffset) {
                    // current upload in front of new upload
                    newPendings.push(upload);
                } else if (upload.uploadOffset > dstByteOffset + uploadSize) {
                    // current upload behind of new upload
                    if (!added) {
                        added = true;
                        this.pushUpload(newPendings, null, 0, dstByteOffset, uploadSize);
                    }
                    newPendings.push(upload);
                } else {
                    const start = Math.min(dstByteOffset, upload.uploadOffset);
                    const end = Math.max(dstByteOffset + uploadSize, upload.uploadOffset + upload.uploadSize);
                    if (end - start < uploadSize + upload.uploadSize && this._device.currentPass?.isBufferUploading(this)) {
                        // data overlaps and previous data is in use, refresh data by restarting current render pass or compute pass
                        this._device.currentPass.end();
                        // now, the pending uploads should be cleared
                        newPendings = [];
                        break;
                    }
                    dstByteOffset = start;
                    uploadSize = end - start;
                }
            }
            if (!added) {
                this.pushUpload(newPendings, null, 0, dstByteOffset, uploadSize);
            }
            this._pendingUploads = newPendings;
            new Uint8Array(this._pendingUploads[0].mappedBuffer.mappedRange, writeOffset, writeSize).set(new Uint8Array(data.buffer, uploadOffset, writeSize));
        }
    }
    async getBufferSubData(dstBuffer, offsetInBytes, sizeInBytes) {
        if (!(this._usage & GPUResourceUsageFlags.BF_READ)) {
            throw new Error('getBufferSubData() failed: buffer does not have BF_READ flag set');
        }
        this.sync();
        offsetInBytes = Number(offsetInBytes) || 0;
        sizeInBytes = Number(sizeInBytes) || this.byteLength - offsetInBytes;
        if (offsetInBytes < 0 || offsetInBytes + sizeInBytes > this.byteLength) {
            throw new Error('data query range out of bounds');
        }
        if (dstBuffer && dstBuffer.byteLength < sizeInBytes) {
            throw new Error('no enough space for querying buffer data');
        }
        dstBuffer = dstBuffer || new Uint8Array(sizeInBytes);
        await this._object.mapAsync(GPUMapMode.READ);
        const range = this._object.getMappedRange();
        dstBuffer.set(new Uint8Array(range, offsetInBytes, sizeInBytes));
        this._object.unmap();
        return dstBuffer;
    }
    async restore() {
        if (!this._device.isContextLost()) {
            this.load();
        }
    }
    destroy() {
        if (this._object) {
            this._object.destroy();
            this._object = null;
            this._gpuUsage = 0;
            this._memCost = 0;
        }
    }
    isBuffer() {
        return true;
    }
    beginSyncChanges(encoder) {
        if (this._pendingUploads.length > 0) {
            const cmdEncoder = encoder || this._device.device.createCommandEncoder();
            for (const upload of this._pendingUploads){
                cmdEncoder.copyBufferToBuffer(upload.mappedBuffer.buffer, upload.mappedBuffer.offset, this._object, upload.uploadOffset, upload.uploadSize);
            }
            if (!encoder) {
                this._device.device.queue.submit([
                    cmdEncoder.finish()
                ]);
            }
            this._pendingUploads.length = 0;
            this._ringBuffer.beginUploads();
        }
    }
    endSyncChanges() {
        if (this._usage & GPUResourceUsageFlags.DYNAMIC) {
            this._ringBuffer.endUploads();
        } else {
            this._ringBuffer.purge();
        }
    }
    load(data) {
        if (this._device.isContextLost()) {
            return;
        }
        this._memCost = 0;
        if (!this._device.isContextLost()) {
            if (!this._object) {
                this._gpuUsage = 0;
                let label = '';
                if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                    this._gpuUsage |= GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST;
                    label += '[vertex]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                    this._gpuUsage |= GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
                    label += '[index]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                    this._gpuUsage |= GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
                    label += '[uniform]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_STORAGE) {
                    this._gpuUsage |= GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
                    label += '[storage]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_READ) {
                    this._gpuUsage |= GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;
                    label += '[mapRead]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_WRITE) {
                    this._gpuUsage |= GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;
                    label += '[mapWrite]';
                }
                if (data) {
                    this._object = this._device.gpuCreateBuffer({
                        label: label,
                        size: data.byteLength + 15 & ~15,
                        usage: this._gpuUsage,
                        mappedAtCreation: true
                    });
                    const range = this._object.getMappedRange();
                    new data.constructor(range).set(data);
                    this._object.unmap();
                } else {
                    this._object = this._device.gpuCreateBuffer({
                        label: label,
                        size: this.byteLength + 15 & ~15,
                        usage: this._gpuUsage
                    });
                }
                const memCost = this.byteLength;
                this._device.updateVideoMemoryCost(memCost - this._memCost);
                this._memCost = memCost;
            }
        }
    }
    sync() {
        if (this._pendingUploads) {
            if (this._device.isBufferUploading(this)) {
                this._device.currentPass.end();
            } else {
                this.beginSyncChanges(null);
                this.endSyncChanges();
            }
        }
    }
    pushUpload(pending, data, srcByteOffset, dstByteOffset, byteSize) {
        const bufferMapped = this._ringBuffer.fetchBufferMapped(byteSize, true);
        if (data) {
            new Uint8Array(bufferMapped.mappedRange, dstByteOffset, byteSize).set(new Uint8Array(data, srcByteOffset, byteSize));
        }
        pending.push({
            mappedBuffer: {
                buffer: bufferMapped.buffer,
                size: bufferMapped.size,
                offset: dstByteOffset,
                used: bufferMapped.used,
                mappedRange: bufferMapped.mappedRange
            },
            uploadSize: byteSize,
            uploadOffset: dstByteOffset,
            uploadBuffer: this._object
        });
    }
}

const typeU8Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2_NORM);
const typeU8Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4_NORM);
const typeI8Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2_NORM);
const typeI8Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4_NORM);
const typeU16Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2);
const typeU16Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4);
const typeI16Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2);
const typeI16Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4);
const typeU16Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2_NORM);
const typeU16Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4_NORM);
const typeI16Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2_NORM);
const typeI16Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4_NORM);
const typeF16Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC2);
const typeF16Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC4);
const typeF32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32);
const typeF32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC2);
const typeF32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC3);
const typeF32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC4);
const typeU32$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
const typeU32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2);
const typeU32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3);
const typeU32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4);
const typeI32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
const typeI32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2);
const typeI32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3);
const typeI32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4);
const vertexFormatTable = {
    [typeU8Vec2_Norm.typeId]: 'unorm8x2',
    [typeU8Vec4_Norm.typeId]: 'unorm8x4',
    [typeI8Vec2_Norm.typeId]: 'snorm8x2',
    [typeI8Vec4_Norm.typeId]: 'snorm8x4',
    [typeU16Vec2.typeId]: 'uint16x2',
    [typeU16Vec4.typeId]: 'uint16x4',
    [typeI16Vec2.typeId]: 'sint16x2',
    [typeI16Vec4.typeId]: 'sint16x4',
    [typeU16Vec2_Norm.typeId]: 'unorm16x2',
    [typeU16Vec4_Norm.typeId]: 'unorm16x4',
    [typeI16Vec2_Norm.typeId]: 'snorm16x2',
    [typeI16Vec4_Norm.typeId]: 'snorm16x4',
    [typeF16Vec2.typeId]: 'float16x2',
    [typeF16Vec4.typeId]: 'float16x4',
    [typeF32.typeId]: 'float32',
    [typeF32Vec2.typeId]: 'float32x2',
    [typeF32Vec3.typeId]: 'float32x3',
    [typeF32Vec4.typeId]: 'float32x4',
    [typeU32$1.typeId]: 'uint32',
    [typeU32Vec2.typeId]: 'uint32x2',
    [typeU32Vec3.typeId]: 'uint32x3',
    [typeU32Vec4.typeId]: 'uint32x4',
    [typeI32.typeId]: 'sint32',
    [typeI32Vec2.typeId]: 'sint32x2',
    [typeI32Vec3.typeId]: 'sint32x3',
    [typeI32Vec4.typeId]: 'sint32x4'
};
class WebGPUStructuredBuffer extends WebGPUBuffer {
    _structure;
    _data;
    constructor(device, structure, usage, source){
        if (!structure?.isStructType()) {
            throw new Error('invalid structure type');
        }
        if (usage & GPUResourceUsageFlags.BF_INDEX) {
            throw new Error('structured buffer must not have Index usage flag');
        }
        if (usage & GPUResourceUsageFlags.BF_READ || usage & GPUResourceUsageFlags.BF_WRITE) {
            throw new Error('structured buffer must not have Read or Write usage flags');
        }
        if (usage & GPUResourceUsageFlags.BF_VERTEX) {
            if (structure.structMembers.length !== 1 || !structure.structMembers[0].type.isArrayType()) {
                throw new Error('structured buffer for vertex usage must have only one array member');
            }
        }
        if (usage & GPUResourceUsageFlags.BF_UNIFORM || usage & GPUResourceUsageFlags.BF_STORAGE) {
            usage |= GPUResourceUsageFlags.DYNAMIC;
        }
        const layout = structure.toBufferLayout(0, structure.layout);
        if (source && layout.byteSize !== source.byteLength) {
            throw new Error(`create structured buffer failed: invalid source size: ${source.byteLength}, should be ${layout.byteSize}`);
        }
        super(device, usage, source || layout.byteSize);
        this._data = new StructuredBufferData(layout, this);
        this._structure = structure;
    }
    set(name, value) {
        this._data.set(name, value);
    }
    get structure() {
        return this._structure;
    }
    set structure(st) {
        if (st && !st.isCompatibleType(this._structure)) {
            const layout = st.toBufferLayout(0, st.layout);
            if (layout.byteSize > this.byteLength) {
                throw new Error(`set structure type failed: new structure type is too large: ${layout.byteSize}`);
            }
            this._data = new StructuredBufferData(layout, this);
            this._structure = st;
        }
    }
    static getGPUVertexFormat(type) {
        return vertexFormatTable[type.typeId];
    }
}

class WebGPUBindGroup extends WebGPUObject {
    _layout;
    _bindGroup;
    _buffers;
    _textures;
    _videoTextures;
    _resources;
    constructor(device, layout){
        super(device);
        this._device = device;
        this._layout = layout;
        this._bindGroup = null;
        this._resources = {};
        this._buffers = [];
        this._textures = [];
        this._videoTextures = null;
    }
    get bindGroup() {
        if (!this._bindGroup) {
            this._bindGroup = this._create();
        }
        return this._bindGroup;
    }
    get bufferList() {
        return this._buffers;
    }
    get textureList() {
        return this._textures;
    }
    getLayout() {
        return this._layout;
    }
    getBuffer(name) {
        return this._getBuffer(name, GPUResourceUsageFlags.BF_UNIFORM | GPUResourceUsageFlags.BF_STORAGE, true);
    }
    setBuffer(name, buffer) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.name === bindName) {
                if (!entry.buffer) {
                    console.log(`setBuffer() failed: resource '${name}' is not buffer`);
                } else {
                    const bufferUsage = entry.buffer.type === 'uniform' ? GPUResourceUsageFlags.BF_UNIFORM : GPUResourceUsageFlags.BF_STORAGE;
                    if (buffer && !(buffer.usage & bufferUsage)) {
                        console.log(`setBuffer() failed: buffer resource '${name}' must be type '${entry.buffer.type}'`);
                    } else if (buffer !== this._resources[entry.name]) {
                        this._resources[entry.name] = buffer;
                        this._bindGroup = null;
                    }
                }
                return;
            }
        }
        console.log(`setBuffer() failed: no buffer resource named '${name}'`);
    }
    setValue(name, value) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setValue(mappedName, {
                [name]: value
            });
        } else {
            const buffer = this._getBuffer(name, GPUResourceUsageFlags.BF_UNIFORM | GPUResourceUsageFlags.BF_STORAGE, false);
            if (buffer) {
                if (!(buffer instanceof WebGPUStructuredBuffer)) {
                    throw new Error(`BindGroup.setValue() failed: '${name}' is not structured buffer`);
                }
                if (value?.BYTES_PER_ELEMENT) {
                    buffer.bufferSubData(0, value);
                } else {
                    for(const k in value){
                        buffer.set(k, value[k]);
                    }
                }
            } else {
                console.log(`setValue() failed: no uniform buffer named '${name}'`);
            }
        }
    }
    setRawData(name, byteOffset, data, srcPos, srcLength) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setRawData(mappedName, byteOffset, data, srcPos, srcLength);
        } else {
            const buffer = this._getBuffer(name, GPUResourceUsageFlags.BF_UNIFORM | GPUResourceUsageFlags.BF_STORAGE, false);
            if (buffer) {
                buffer.bufferSubData(byteOffset, data, srcPos, srcLength);
            } else {
                console.log(`set(): no uniform buffer named '${name}'`);
            }
        }
    }
    getTexture(name) {
        const entry = this._findTextureLayout(name);
        if (entry) {
            const t = this._resources[name];
            return t ? t[0] : null;
        } else {
            throw new Error(`getTexture() failed:${name} is not a texture`);
        }
    }
    setTextureView(name, value, level, face, mipCount, sampler) {
        if (!value) {
            throw new Error(`WebGPUBindGroup.setTextureView() failed: invalid texture uniform value: ${value}`);
        } else {
            const entry = this._findTextureLayout(name);
            if (entry) {
                if (entry.externalTexture) {
                    throw new Error(`WebGPUBindGroup.setTextureView() failed: video texture does not have view`);
                } else if (value.isTextureVideo()) {
                    throw new Error(`WebGPUBindGroup.setTextureView() failed: invalid texture type`);
                }
                const t = this._resources[name];
                const view = value.getView(level, face, mipCount);
                if (!t || t[1] !== view) {
                    this._resources[name] = [
                        value,
                        view
                    ];
                    this._bindGroup = null;
                }
                if (entry.texture?.autoBindSampler) {
                    const samplerEntry = this._findSamplerLayout(entry.texture.autoBindSampler);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTextureView() failed: sampler entry not found: ${entry.texture.autoBindSampler}`);
                    }
                    const s = !sampler || sampler.compare ? value.getDefaultSampler(false) : sampler;
                    if (s.object !== this._resources[entry.texture.autoBindSampler]) {
                        this._resources[entry.texture.autoBindSampler] = s.object;
                        this._bindGroup = null;
                    }
                }
                if (entry.texture?.autoBindSamplerComparison) {
                    const samplerEntry = this._findSamplerLayout(entry.texture.autoBindSamplerComparison);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTextureView() failed: sampler entry not found: ${entry.texture.autoBindSamplerComparison}`);
                    }
                    const s = !sampler || !sampler.compare ? value.getDefaultSampler(true) : sampler;
                    if (s.object !== this._resources[entry.texture.autoBindSamplerComparison]) {
                        this._resources[entry.texture.autoBindSamplerComparison] = s.object;
                        this._bindGroup = null;
                    }
                }
            } else {
                throw new Error(`WebGPUBindGroup.setView() failed: no texture uniform named '${name}'`);
            }
        }
    }
    setTexture(name, value, sampler) {
        if (!value) {
            throw new Error(`WebGPUBindGroup.setTexture() failed: invalid texture uniform value: ${value}`);
        } else {
            const entry = this._findTextureLayout(name);
            if (entry) {
                const t = this._resources[name];
                if (entry.externalTexture) {
                    if (!value.isTextureVideo()) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: invalid texture type of resource '${name}'`);
                    }
                    if (!t || t !== value) {
                        this._resources[name] = value;
                        this._bindGroup = null;
                        this._videoTextures = [];
                        for (const entry of this._layout.entries){
                            if (entry.externalTexture) {
                                const tex = this._resources[entry.name];
                                if (tex && this._videoTextures.indexOf(tex) < 0) {
                                    this._videoTextures.push(tex);
                                }
                            }
                        }
                    }
                } else {
                    if (value.isTextureVideo()) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: invalid texture type of resource '${name}'`);
                    }
                    const view = value.getDefaultView();
                    if (!entry.externalTexture && !view) {
                        throw new Error('WebGPUBindGroup.setTexture() failed: create texture view failed');
                    }
                    if (!t || t[0] !== value) {
                        this._resources[name] = [
                            value,
                            view
                        ];
                        this._bindGroup = null;
                    }
                }
                const autoBindSampler = entry.texture?.autoBindSampler || entry.externalTexture?.autoBindSampler;
                if (autoBindSampler) {
                    const samplerEntry = this._findSamplerLayout(autoBindSampler);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: sampler entry not found: ${autoBindSampler}`);
                    }
                    const s = !sampler || sampler.compare ? value.getDefaultSampler(false) : sampler;
                    if (s.object !== this._resources[autoBindSampler]) {
                        this._resources[autoBindSampler] = s.object;
                        this._bindGroup = null;
                    }
                }
                const autoBindSamplerComparison = entry.texture?.autoBindSamplerComparison;
                if (autoBindSamplerComparison) {
                    const samplerEntry = this._findSamplerLayout(autoBindSamplerComparison);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: sampler entry not found: ${autoBindSamplerComparison}`);
                    }
                    const s = !sampler || !sampler.compare ? value.getDefaultSampler(true) : sampler;
                    if (s.object !== this._resources[autoBindSamplerComparison]) {
                        this._resources[autoBindSamplerComparison] = s.object;
                        this._bindGroup = null;
                    }
                }
            } else {
                throw new Error(`WebGPUBindGroup.setTexture() failed: no texture uniform named '${name}'`);
            }
        }
    }
    setSampler(name, value) {
        const sampler = value?.object;
        if (!sampler) {
            console.log(`WebGPUBindGroup.setSampler() failed: invalid sampler uniform value: ${value}`);
        } else if (this._resources[name] !== sampler) {
            if (!this._findSamplerLayout(name)) {
                console.log(`WebGPUBindGroup.setSampler() failed: no sampler uniform named '${name}'`);
            } else {
                this._resources[name] = sampler;
                this._bindGroup = null;
            }
        }
    }
    destroy() {
        this._bindGroup = null;
        this._resources = {};
        this._buffers = [];
        this._textures = [];
        this._videoTextures = null;
        this._object = null;
    }
    async restore() {
        this._bindGroup = null;
        this._object = {};
    }
    isBindGroup() {
        return true;
    }
    /** @internal */ updateVideoTextures() {
        this._videoTextures?.forEach((t)=>{
            if (t.updateVideoFrame()) {
                this._bindGroup = null;
            }
        });
    }
    /** @internal */ _findTextureLayout(name) {
        for (const entry of this._layout.entries){
            if ((entry.texture || entry.storageTexture || entry.externalTexture) && entry.name === name) {
                return entry;
            }
        }
        return null;
    }
    /** @internal */ _findSamplerLayout(name) {
        for (const entry of this._layout.entries){
            if (entry.sampler && entry.name === name) {
                return entry;
            }
        }
        return null;
    }
    /** @internal */ _getBuffer(name, usage, nocreate = false) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.buffer && entry.name === bindName) {
                const bufferUsage = entry.buffer.type === 'uniform' ? GPUResourceUsageFlags.BF_UNIFORM : GPUResourceUsageFlags.BF_STORAGE;
                if (!(usage & bufferUsage)) {
                    return null;
                }
                let buffer = this._resources[entry.name];
                if (!buffer && !nocreate) {
                    const options = {
                        usage: bufferUsage === GPUResourceUsageFlags.BF_UNIFORM ? 'uniform' : null,
                        storage: bufferUsage === GPUResourceUsageFlags.BF_STORAGE,
                        dynamic: true
                    };
                    buffer = this._device.createStructuredBuffer(entry.type, options);
                    this._resources[entry.name] = buffer;
                }
                return buffer;
            }
        }
        return null;
    }
    /** @internal */ _create() {
        let bindGroup = null;
        this._textures = [];
        this._buffers = [];
        const entries = [];
        let resourceOk = true;
        for (const entry of this._layout.entries){
            const ge = {
                binding: entry.binding
            };
            if (entry.buffer) {
                const buffer = this._getBuffer(entry.name, entry.buffer.type === 'uniform' ? GPUResourceUsageFlags.BF_UNIFORM : GPUResourceUsageFlags.BF_STORAGE, true);
                if (!buffer) {
                    throw new Error(`Uniform buffer '${entry.name}' not exists, maybe you forgot settings some uniform values`);
                }
                if (this._buffers.indexOf(buffer) < 0) {
                    this._buffers.push(buffer);
                }
                ge.resource = {
                    buffer: buffer.object,
                    offset: 0,
                    size: buffer.byteLength
                };
                resourceOk = resourceOk && !!buffer.object;
            } else if (entry.texture || entry.storageTexture) {
                const t = this._resources[entry.name];
                if (!t) {
                    console.error(`Missing texture in bind group: ${entry.name}`);
                    resourceOk = false;
                } else {
                    if (this._textures.indexOf(t[0]) < 0) {
                        this._textures.push(t[0]);
                    }
                    ge.resource = t[1];
                    resourceOk = resourceOk && !!t[1];
                }
            } else if (entry.externalTexture) {
                const t = this._resources[entry.name];
                ge.resource = t.object;
                resourceOk = resourceOk && !!t.object;
            } else if (entry.sampler) {
                const sampler = this._resources[entry.name];
                ge.resource = sampler;
                resourceOk = resourceOk && !!sampler;
            }
            entries.push(ge);
        }
        if (!resourceOk) {
            return null;
        }
        const layout = this._device.fetchBindGroupLayout(this._layout);
        const descriptor = {
            layout,
            entries
        };
        if (layout.label) {
            descriptor.label = `${layout.label}.bindgroup`;
        }
        bindGroup = this._device.gpuCreateBindGroup(descriptor);
        if (!bindGroup) {
            console.log('Create bindgroup failed');
        }
        return bindGroup;
    }
}

const textureWrappingMap = {
    repeat: 'repeat',
    'mirrored-repeat': 'mirror-repeat',
    clamp: 'clamp-to-edge'
};
const textureFilterMap = {
    nearest: 'nearest',
    linear: 'linear',
    none: undefined
};
const compareFuncMap = {
    always: 'always',
    le: 'less-equal',
    ge: 'greater-equal',
    lt: 'less',
    gt: 'greater',
    eq: 'equal',
    ne: 'not-equal',
    never: 'never'
};
const stencilOpMap = {
    'keep': 'keep',
    'replace': 'replace',
    'zero': 'zero',
    'invert': 'invert',
    'incr': 'increment-clamp',
    'decr': 'decrement-clamp',
    'incr-wrap': 'increment-wrap',
    'decr-wrap': 'decrement-wrap'
};
const primitiveTypeMap = {
    'triangle-list': 'triangle-list',
    'triangle-strip': 'triangle-strip',
    'triangle-fan': null,
    'line-list': 'line-list',
    'line-strip': 'line-strip',
    'point-list': 'point-list'
};
const faceModeMap = {
    'back': 'back',
    'front': 'front',
    'none': 'none'
};
const blendEquationMap = {
    add: 'add',
    subtract: 'subtract',
    'reverse-subtract': 'reverse-subtract',
    min: 'min',
    max: 'max'
};
const blendFuncMap = {
    'const-color': 'constant',
    'const-alpha': 'constant',
    'dst-color': 'dst',
    'dst-alpha': 'dst-alpha',
    'inv-const-color': 'one-minus-constant',
    'inv-const-alpha': 'one-minus-constant',
    'inv-dst-color': 'one-minus-dst',
    'inv-dst-alpha': 'one-minus-dst-alpha',
    'src-color': 'src',
    'src-alpha': 'src-alpha',
    'inv-src-color': 'one-minus-src',
    'inv-src-alpha': 'one-minus-src-alpha',
    'src-alpha-saturate': 'src-alpha-saturated',
    one: 'one',
    zero: 'zero'
};
const vertexFormatToHash = {
    float32: '0',
    float32x2: '1',
    float32x3: '2',
    float32x4: '3',
    uint32: '4',
    uint32x2: '5',
    uint32x3: '6',
    uint32x4: '7',
    sint32: '8',
    sint32x2: '9',
    sint32x3: 'a',
    sint32x4: 'b',
    uint16x2: 'c',
    uint16x4: 'd',
    unorm16x2: 'e',
    unorm16x4: 'f',
    sint16x2: 'g',
    sint16x4: 'h',
    snorm16x2: 'i',
    snorm16x4: 'j',
    uint8x2: 'k',
    uint8x4: 'l',
    unorm8x2: 'm',
    unorm8x4: 'n',
    sint8x2: 'o',
    sint8x4: 'p',
    snorm8x2: 'q',
    snorm8x4: 'r'
};
const textureFormatMap = {
    ['unknown']: null,
    ['rgba8unorm']: 'rgba8unorm',
    ['rgba8snorm']: 'rgba8snorm',
    ['bgra8unorm']: 'bgra8unorm',
    ['dxt1']: 'bc1-rgba-unorm',
    ['dxt3']: 'bc2-rgba-unorm',
    ['dxt5']: 'bc3-rgba-unorm',
    ['dxt1-srgb']: 'bc1-rgba-unorm-srgb',
    ['dxt3-srgb']: 'bc2-rgba-unorm-srgb',
    ['dxt5-srgb']: 'bc3-rgba-unorm-srgb',
    ['r8unorm']: 'r8unorm',
    ['r8snorm']: 'r8snorm',
    ['r16f']: 'r16float',
    ['r32f']: 'r32float',
    ['r8ui']: 'r8uint',
    ['r8i']: 'r8sint',
    ['r16ui']: 'r16uint',
    ['r16i']: 'r16sint',
    ['r32ui']: 'r32uint',
    ['r32i']: 'r32sint',
    ['rg8unorm']: 'rg8unorm',
    ['rg8snorm']: 'rg8snorm',
    ['rg16f']: 'rg16float',
    ['rg32f']: 'rg32float',
    ['rg8ui']: 'rg8uint',
    ['rg8i']: 'rg8sint',
    ['rg16ui']: 'rg16uint',
    ['rg16i']: 'rg16sint',
    ['rg32ui']: 'rg32uint',
    ['rg32i']: 'rg32sint',
    ['rgba8unorm-srgb']: 'rgba8unorm-srgb',
    ['bgra8unorm-srgb']: 'bgra8unorm-srgb',
    ['rgba16f']: 'rgba16float',
    ['rgba32f']: 'rgba32float',
    ['rgba8ui']: 'rgba8uint',
    ['rgba8i']: 'rgba8sint',
    ['rgba16ui']: 'rgba16uint',
    ['rgba16i']: 'rgba16sint',
    ['rgba32ui']: 'rgba32uint',
    ['rgba32i']: 'rgba32sint',
    ['rg11b10uf']: 'rg11b10ufloat',
    ['d16']: 'depth16unorm',
    ['d24']: 'depth24plus',
    ['d32f']: 'depth32float',
    ['d32fs8']: 'depth32float-stencil8',
    ['d24s8']: 'depth24plus-stencil8'
};
function zip(keys, values) {
    const ret = {};
    const len = keys.length;
    for(let i = 0; i < len; i++){
        ret[keys[i]] = values[i];
    }
    return ret;
}
const textureFormatInvMap = zip(Object.values(textureFormatMap), Object.keys(textureFormatMap));
const hashToVertexFormat = zip(Object.values(vertexFormatToHash), Object.keys(vertexFormatToHash));

class WebGPUBaseTexture extends WebGPUObject {
    _target;
    _hash;
    _memCost;
    _views;
    _defaultView;
    _mipmapDirty;
    _flags;
    _width;
    _height;
    _depth;
    _format;
    _renderable;
    _fb;
    _gpuFormat;
    _mipLevelCount;
    _samplerOptions;
    _ringBuffer;
    _pendingUploads;
    constructor(device, target){
        super(device);
        this._target = target;
        this._flags = 0;
        this._width = 0;
        this._height = 0;
        this._depth = 0;
        this._renderable = false;
        this._fb = false;
        this._format = 'unknown';
        this._gpuFormat = null;
        this._mipLevelCount = 0;
        this._samplerOptions = null;
        this._memCost = 0;
        this._mipmapDirty = false;
        this._views = [];
        this._defaultView = null;
        this._ringBuffer = new UploadRingBuffer(device);
        this._pendingUploads = [];
    }
    get hash() {
        return this._object ? this._device.gpuGetObjectHash(this._object) : 0;
    }
    get target() {
        return this._target;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get depth() {
        return this._depth;
    }
    get format() {
        return this._format;
    }
    get mipLevelCount() {
        return this._mipLevelCount;
    }
    get gpuFormat() {
        return this._gpuFormat;
    }
    get samplerOptions() {
        return this._samplerOptions;
    }
    set samplerOptions(options) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._samplerOptions = options ? Object.assign({}, this._getSamplerOptions(params, !!options.compare), options) : null;
    }
    isTexture() {
        return true;
    }
    isFilterable() {
        if (!this.getTextureCaps().getTextureFormatInfo(this._format)?.filterable) {
            return false;
        }
        return true;
    }
    /** @internal */ getPendingUploads() {
        return this._pendingUploads;
    }
    /** @internal */ clearPendingUploads() {
        if (this._pendingUploads.length > 0) {
            this._pendingUploads = [];
            this.beginSyncChanges(null);
            this.endSyncChanges();
        }
    }
    isMipmapDirty() {
        return this._mipmapDirty;
    }
    setMipmapDirty(b) {
        this._mipmapDirty = b;
    }
    destroy() {
        if (this._object) {
            if (!this.isTextureVideo()) {
                this._object.destroy();
            }
            this._object = null;
            this._device.updateVideoMemoryCost(-this._memCost);
            this._memCost = 0;
        }
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.init();
        }
    }
    getTextureCaps() {
        return this._device.getDeviceCaps().textureCaps;
    }
    isSRGBFormat() {
        return isSRGBTextureFormat(this._format);
    }
    isFloatFormat() {
        return isFloatTextureFormat(this._format);
    }
    isIntegerFormat() {
        return isIntegerTextureFormat(this._format);
    }
    isSignedFormat() {
        return isSignedTextureFormat(this._format);
    }
    isCompressedFormat() {
        return isCompressedTextureFormat(this._format);
    }
    isDepth() {
        return hasDepthChannel(this._format);
    }
    isRenderable() {
        return this._renderable;
    }
    getView(level, face, mipCount) {
        level = Number(level) || 0;
        face = Number(face) || 0;
        mipCount = Number(mipCount) || 0;
        if (!this._views[face]) {
            this._views[face] = [];
        }
        if (!this._views[face][level]) {
            this._views[face][level] = [];
        }
        if (!this._views[face][level][mipCount]) {
            this._views[face][level][mipCount] = this.createView(level, face, mipCount);
        }
        return this._views[face][level][mipCount];
    }
    getDefaultView() {
        if (!this._defaultView && this._object && !this.isTextureVideo()) {
            this._defaultView = this._device.gpuCreateTextureView(this._object, {
                dimension: this.isTextureCube() ? 'cube' : this.isTexture3D() ? '3d' : this.isTexture2DArray() ? '2d-array' : '2d',
                arrayLayerCount: this.isTextureCube() ? 6 : this.isTexture2DArray() ? this._depth : 1,
                aspect: hasDepthChannel(this.format) ? 'depth-only' : 'all'
            });
        }
        return this._defaultView;
    }
    copyPixelDataToBuffer(x, y, w, h, layer, level, buffer) {
        if (this.isTextureVideo()) {
            throw new Error('copyPixelDataToBuffer() failed: can not copy pixel data of video texture');
        }
        this.sync();
        WebGPUBaseTexture.copyTexturePixelsToBuffer(this._device.device, this.object, this.width, this.height, this.format, x, y, w, h, layer, level, buffer);
    }
    generateMipmaps() {
        this._mipmapDirty = true;
    }
    beginSyncChanges(encoder) {
        if (!this.isTextureVideo() && this._pendingUploads.length > 0 && this._object) {
            const cmdEncoder = encoder || this._device.device.createCommandEncoder();
            for (const u of this._pendingUploads){
                if (u.mappedBuffer) {
                    const upload = u;
                    cmdEncoder.copyBufferToTexture({
                        buffer: upload.mappedBuffer.buffer,
                        offset: upload.mappedBuffer.offset,
                        bytesPerRow: upload.bufferStride,
                        rowsPerImage: upload.uploadHeight
                    }, {
                        texture: this._object,
                        origin: {
                            x: upload.uploadOffsetX,
                            y: upload.uploadOffsetY,
                            z: upload.uploadOffsetZ
                        },
                        mipLevel: upload.mipLevel
                    }, {
                        width: upload.uploadWidth,
                        height: upload.uploadHeight,
                        depthOrArrayLayers: upload.uploadDepth
                    });
                } else if (u.image) {
                    const upload = u;
                    // FIXME: copy image cannot be queued into the command buffer
                    const copyView = {
                        texture: this._object,
                        origin: {
                            x: upload.offsetX,
                            y: upload.offsetY,
                            z: upload.offsetZ
                        },
                        mipLevel: upload.mipLevel,
                        premultipliedAlpha: false
                    };
                    this._device.device.queue.copyExternalImageToTexture({
                        source: upload.image,
                        origin: {
                            x: upload.srcX,
                            y: upload.srcY
                        }
                    }, copyView, {
                        width: upload.width,
                        height: upload.height,
                        depthOrArrayLayers: upload.depth
                    });
                }
            }
            this._pendingUploads.length = 0;
            if (!encoder) {
                this._device.device.queue.submit([
                    cmdEncoder.finish()
                ]);
            }
            this._ringBuffer.beginUploads();
        }
    }
    endSyncChanges() {
        if (this._flags & GPUResourceUsageFlags.DYNAMIC) {
            this._ringBuffer.endUploads();
        } else {
            this._ringBuffer.purge();
        }
    }
    getDefaultSampler(shadow) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        return this._device.createSampler(!this._samplerOptions || !this._samplerOptions.compare !== !shadow ? this._getSamplerOptions(params, shadow) : this._samplerOptions);
    }
    /** @internal */ sync() {
        if (this._pendingUploads) {
            if (this._device.isTextureUploading(this)) {
                this._device.currentPass.end();
            } else {
                this.beginSyncChanges(null);
                this.endSyncChanges();
            }
        }
    }
    /** @internal */ _calcMipLevelCount(format, width, height, depth) {
        if (hasDepthChannel(format) || this.isTexture3D() || this.isTextureVideo()) {
            return 1;
        }
        if (this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) {
            return 1;
        }
        const params = this.getTextureCaps().getTextureFormatInfo(format);
        if (!params || !params.renderable) {
            return 1;
        }
        return Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    /** @internal */ allocInternal(format, width, height, depth, numMipLevels) {
        if (this.isTextureVideo()) {
            return;
        }
        if (numMipLevels === 0) {
            numMipLevels = this._calcMipLevelCount(format, width, height, depth);
        } else if (numMipLevels !== 1) {
            let size = Math.max(width, height);
            if (this.isTexture3D()) {
                size = Math.max(size, depth);
            }
            const autoMipLevelCount = Math.floor(Math.log2(size)) + 1; //this._calcMipLevelCount(format, width, height, depth);
            //const autoMipLevelCount = this._calcMipLevelCount(format, width, height, depth);
            if (!Number.isInteger(numMipLevels) || numMipLevels < 0 || numMipLevels > autoMipLevelCount) {
                numMipLevels = autoMipLevelCount;
            }
        }
        if (this._object && (this._format !== format || this._width !== width || this._height !== height || this._depth !== depth, this._mipLevelCount !== numMipLevels)) {
            const obj = this._object;
            this._device.runNextFrame(()=>{
                obj.destroy();
            });
            this._object = null;
        }
        if (!this._object) {
            this._format = format;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._mipLevelCount = numMipLevels;
            if (!this._device.isContextLost()) {
                this._gpuFormat = textureFormatMap[this._format];
                const params = this.getTextureCaps().getTextureFormatInfo(this._format);
                this._renderable = params.renderable && !(this._flags & GPUResourceUsageFlags.TF_WRITABLE);
                this._object = this._device.gpuCreateTexture({
                    size: {
                        width: this._width,
                        height: this._height,
                        depthOrArrayLayers: this.isTextureCube() ? 6 : this._depth
                    },
                    format: this._gpuFormat,
                    mipLevelCount: this._mipLevelCount,
                    sampleCount: 1,
                    dimension: this.isTexture3D() ? '3d' : '2d',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | (this._renderable && !this.isTexture3D() ? GPUTextureUsage.RENDER_ATTACHMENT : 0) | (this._flags & GPUResourceUsageFlags.TF_WRITABLE ? GPUTextureUsage.STORAGE_BINDING : 0)
                });
                const memCost = this.getTextureCaps().calcMemoryUsage(this._format, this._width * this._height * (this.isTextureCube() ? 6 : this._depth));
                this._device.updateVideoMemoryCost(memCost - this._memCost);
                this._memCost = memCost;
            }
        }
    }
    /** @internal */ static copyTexturePixelsToBuffer(device, texture, texWidth, texHeight, format, x, y, w, h, layer, level, buffer) {
        if (!(buffer.gpuUsage & GPUBufferUsage.COPY_DST)) {
            throw new Error('copyTexturePixelsToBuffer() failed: destination buffer does not have COPY_DST usage set');
        }
        const blockWidth = getTextureFormatBlockWidth(format);
        const blockHeight = getTextureFormatBlockHeight(format);
        const blockSize = getTextureFormatBlockSize(format);
        const blocksPerRow = texWidth / blockWidth;
        const blocksPerCol = texHeight / blockHeight;
        const rowStride = blocksPerRow * blockSize;
        const bufferStride = rowStride + 255 & ~255;
        const bufferSize = blocksPerCol * rowStride;
        const bufferSizeAligned = blocksPerCol * bufferStride;
        if (buffer.byteLength < bufferSize) {
            throw new Error(`copyTexturePixelsToBuffer() failed: destination buffer size is ${buffer.byteLength}, should be at least ${bufferSize}`);
        }
        const tmpBuffer = device.createBuffer({
            size: bufferSizeAligned,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        const encoder = device.createCommandEncoder();
        encoder.copyTextureToBuffer({
            texture: texture,
            mipLevel: level ?? 0,
            origin: {
                x: x,
                y: y,
                z: layer ?? 0
            }
        }, {
            buffer: tmpBuffer,
            offset: 0,
            bytesPerRow: bufferStride
        }, {
            width: w,
            height: h,
            depthOrArrayLayers: 1
        });
        if (bufferSize !== bufferSizeAligned) {
            for(let i = 0; i < blocksPerCol; i++){
                encoder.copyBufferToBuffer(tmpBuffer, i * bufferStride, buffer.object, i * rowStride, rowStride);
            }
        } else {
            encoder.copyBufferToBuffer(tmpBuffer, 0, buffer.object, 0, bufferSize);
        }
        device.queue.submit([
            encoder.finish()
        ]);
        tmpBuffer.destroy();
    }
    /** @internal */ uploadRaw(pixels, width, height, depth, offsetX, offsetY, offsetZ, miplevel) {
        const data = new Uint8Array(pixels.buffer, pixels.byteOffset, pixels.byteLength);
        const info = this.getTextureCaps().getTextureFormatInfo(this._format);
        const blockWidth = info.blockWidth || 1;
        const blockHeight = info.blockHeight || 1;
        const blocksPerRow = Math.ceil(width / blockWidth);
        const blocksPerCol = Math.ceil(height / blockHeight);
        const rowStride = blocksPerRow * info.size;
        if (rowStride * blocksPerCol * depth !== data.byteLength) {
            throw new Error(`WebGPUTexture.update() invalid data size: ${data.byteLength}`);
        }
        if (!this._device.isTextureUploading(this)) {
            this.clearPendingUploads();
            const destination = {
                texture: this._object,
                mipLevel: miplevel,
                origin: {
                    x: offsetX,
                    y: offsetY,
                    z: offsetZ
                }
            };
            const dataLayout = {
                bytesPerRow: rowStride,
                rowsPerImage: blockHeight * blocksPerCol
            };
            const size = {
                width: blockWidth * blocksPerRow,
                height: blockHeight * blocksPerCol,
                depthOrArrayLayers: depth
            };
            this._device.device.queue.writeTexture(destination, data, dataLayout, size);
        } else {
            const bufferStride = rowStride + 255 & ~255; // align to 256 bytes
            const uploadSize = bufferStride * blocksPerCol * depth;
            const upload = this._ringBuffer.uploadBuffer(null, null, 0, 0, uploadSize);
            const mappedRange = upload.mappedBuffer.mappedRange;
            const src = new Uint8Array(data);
            const dst = new Uint8Array(mappedRange, upload.mappedBuffer.offset, uploadSize);
            if (uploadSize === data.byteLength) {
                dst.set(new Uint8Array(data));
            } else {
                for(let d = 0; d < depth; d++){
                    const srcLayerOffset = d * rowStride * blocksPerRow;
                    const dstLayerOffset = d * bufferStride * blocksPerCol;
                    for(let i = 0; i < blocksPerCol; i++){
                        dst.set(src.subarray(srcLayerOffset + i * rowStride, srcLayerOffset + (i + 1) * rowStride), dstLayerOffset + i * bufferStride);
                    }
                }
            }
            this._pendingUploads.push({
                mappedBuffer: upload.mappedBuffer,
                uploadOffsetX: offsetX,
                uploadOffsetY: offsetY,
                uploadOffsetZ: offsetZ,
                uploadWidth: blockWidth * blocksPerRow,
                uploadHeight: blockHeight * blocksPerCol,
                uploadDepth: depth,
                bufferStride: bufferStride,
                mipLevel: miplevel
            });
        }
    }
    /** @internal */ uploadImageData(data, srcX, srcY, width, height, destX, destY, miplevel, layer) {
        {
            /*
      // can not use getImageData() because it is not accurate
      const tmpCanvas = document.createElement('canvas');
      let gl = tmpCanvas.getContext("webgl2");
      gl.activeTexture(gl.TEXTURE0);
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
      let pixels = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      this.uploadRaw(pixels, width, height, 1, offsetX, offsetY, faceIndex, miplevel);
      tmpCanvas.width = 0;
      tmpCanvas.height = 0;
      */ this._pendingUploads.push({
                image: data,
                offsetX: destX,
                offsetY: destY,
                offsetZ: layer ?? 0,
                srcX: srcX ?? 0,
                srcY: srcY ?? 0,
                srcZ: 0,
                width: width,
                height: height,
                depth: 1,
                mipLevel: miplevel ?? 0
            });
        }
    }
    /** @internal */ _getSamplerOptions(params, shadow) {
        const comparison = this.isDepth() && shadow;
        const filterable = params.filterable || comparison;
        const magFilter = filterable ? 'linear' : 'nearest';
        const minFilter = params.filterable ? 'linear' : 'nearest';
        const mipFilter = this._mipLevelCount > 1 ? filterable ? 'linear' : 'nearest' : 'none';
        return {
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter,
            minFilter,
            mipFilter,
            compare: comparison ? 'lt' : null
        };
    }
    /** @internal */ _markAsCurrentFB(b) {
        this._fb = b;
    }
    /** @internal */ _isMarkedAsCurrentFB() {
        return this._fb;
    }
}

class WebGPUTexture2D extends WebGPUBaseTexture {
    constructor(device){
        super(device, '2d');
    }
    isTexture2D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, 1, xOffset, yOffset, 0, 0);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, destX, destY, srcX, srcY, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        if (data instanceof HTMLCanvasElement || this._device.isTextureUploading(this)) {
            // Copy the pixel values out in case the canvas content may be changed later
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, srcX, srcY, width, height, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            this.update(imageData.data, destX, destY, width, height);
            cvs.width = 0;
            cvs.height = 0;
        } else {
            this.uploadImageData(data, srcX, srcY, width, height, destX, destY, 0, 0);
        }
    }
    async readPixels(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        if (faceOrLayer !== 0) {
            throw new Error(`Texture2D.readPixels(): parameter faceOrLayer must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = Math.ceil(w / blockWidth);
        const blocksPerCol = Math.ceil(h / blockHeight);
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, 0, mipLevel, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        if (faceOrLayer !== 0) {
            throw new Error(`Texture2D.readPixels(): parameter faceOrLayer must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, 0, mipLevel, buffer);
    }
    loadFromElement(element, sRGB, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        const format = sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm';
        this.loadImage(element, format);
    }
    createEmpty(format, width, height, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        this.loadEmpty(format, width, height, 0);
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            dimension: '2d',
            baseMipLevel: level ?? 0,
            mipLevelCount: mipCount || this._mipLevelCount - (level ?? 0),
            baseArrayLayer: 0,
            arrayLayerCount: 1
        }) : null;
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (data.isCubemap || data.isVolume) {
            console.error('loading 2d texture with mipmap data failed: data is not 2d texture');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error(new Error('webgl device does not support storage texture'));
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, width, height, numMipLevels) {
        this.allocInternal(format, width, height, 1, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    /** @internal */ loadLevels(levels, sRGB) {
        let format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        let swizzle = false;
        if (format === 'bgra8unorm') {
            format = 'rgba8unorm';
            swizzle = true;
        } else if (this._format === 'bgra8unorm-srgb') {
            format = 'rgba8unorm-srgb';
            swizzle = true;
        }
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let i = 0; i < levels.mipDatas[0].length; i++){
                if (swizzle) {
                    // convert bgra to rgba
                    for(let j = 0; j < levels.mipDatas[0][i].width * levels.mipDatas[0][i].height; j++){
                        const t = levels.mipDatas[0][i].data[j * 4];
                        levels.mipDatas[0][i].data[j * 4] = levels.mipDatas[0][i].data[j * 4 + 2];
                        levels.mipDatas[0][i].data[j * 4 + 2] = t;
                    }
                }
                this.uploadRaw(levels.mipDatas[0][i].data, levels.mipDatas[0][i].width, levels.mipDatas[0][i].height, 1, 0, 0, 0, i);
            }
        }
    }
    /** @internal */ loadImage(element, format) {
        this.allocInternal(format, Number(element.width), Number(element.height), 1, 0);
        if (!this._device.isContextLost()) {
            this.updateFromElement(element, 0, 0, 0, 0, this._width, this._height);
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
}

class WebGPUTexture2DArray extends WebGPUBaseTexture {
    constructor(device){
        super(device, '2darray');
    }
    isTexture2DArray() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, depth, xOffset, yOffset, zOffset, 0);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, destX, destY, destZ, srcX, srcY, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        if (data instanceof HTMLCanvasElement || this._device.isTextureUploading(this)) {
            // Copy the pixel values out in case the canvas content may be changed later
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, srcX, srcY, width, height, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            this.update(imageData.data, destX, destY, destZ, width, height, 1);
            cvs.width = 0;
            cvs.height = 0;
        } else {
            this.uploadImageData(data, srcX, srcY, width, height, destX, destY, 0, destZ);
        }
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        this.loadEmpty(format, width, height, depth, 0);
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            dimension: '2d',
            baseMipLevel: level ?? 0,
            mipLevelCount: mipCount || this._mipLevelCount - (level ?? 0),
            baseArrayLayer: face ?? 0,
            arrayLayerCount: 1
        }) : null;
    }
    async readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixels(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = Math.ceil(w / blockWidth);
        const blocksPerCol = Math.ceil(h / blockHeight);
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, layer, mipLevel, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, layer, mipLevel, buffer);
    }
    loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const depth = levels.arraySize;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, depth) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture2DArray.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, levels.arraySize, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let layer = 0; layer < levels.arraySize; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture2DArray.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    this.uploadRaw(levels.mipDatas[layer][i].data, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, 0, 0, layer, i);
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
}

class WebGPUTexture3D extends WebGPUBaseTexture {
    constructor(device){
        super(device, '3d');
    }
    isTexture3D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, depth, xOffset, yOffset, zOffset, 0);
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        this.loadEmpty(format, width, height, depth, 0);
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            dimension: '2d',
            baseMipLevel: 0,
            mipLevelCount: 1,
            baseArrayLayer: face,
            arrayLayerCount: 1
        }) : null;
    }
    async readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixels(): parameter mipLevel must be 0`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = this.width / blockWidth;
        const blocksPerCol = this.height / blockHeight;
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, layer, 0, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixelsToBuffer(): parameter mipLevel must be 0`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, layer, 0, buffer);
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const depth = levels.depth;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, depth) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture3D.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, depth, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let layer = 0; layer < depth; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture3D.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    this.uploadRaw(levels.mipDatas[layer][i].data, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, 0, 0, layer, i);
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
    loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
}

class WebGPUTextureCube extends WebGPUBaseTexture {
    constructor(device){
        super(device, 'cube');
    }
    init() {
        this.loadEmpty(this._format, this._width, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height, face) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, 1, xOffset, yOffset, face, 0);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, destX, destY, face, srcX, srcY, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        if (data instanceof HTMLCanvasElement || this._device.isTextureUploading(this)) {
            // Copy the pixel values out in case the canvas content may be changed later
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, srcX, srcY, width, height, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            this.update(imageData.data, destX, destY, width, height, face);
            cvs.width = 0;
            cvs.height = 0;
        } else {
            this.uploadImageData(data, srcX, srcY, width, height, destX, destY, 0, face);
        }
    }
    createEmpty(format, size, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('storage texture can not be cube texture'));
        } else {
            this.loadEmpty(format, size, 0);
        }
    }
    isTextureCube() {
        return true;
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            format: this._gpuFormat,
            dimension: '2d',
            baseMipLevel: level ?? 0,
            mipLevelCount: mipCount || this._mipLevelCount - (level ?? 0),
            baseArrayLayer: face ?? 0,
            arrayLayerCount: 1,
            aspect: 'all'
        }) : null;
    }
    async readPixels(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = Math.ceil(w / blockWidth);
        const blocksPerCol = Math.ceil(h / blockHeight);
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, face, mipLevel, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, face, mipLevel, buffer);
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (!data.isCubemap) {
            console.error('loading cubmap with mipmap data failed: data is not cubemap');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('webgl device does not support storage texture');
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, size, mipLevelCount) {
        this.allocInternal(format, size, size, 1, mipLevelCount);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    /** @internal */ loadImages(images, format) {
        const width = images[0].width;
        const height = images[0].height;
        if (images.length !== 6) {
            console.error(new Error('cubemap face list must have 6 images'));
            return;
        }
        for(let i = 1; i < 6; i++){
            if (images[i].width !== width || images[i].height !== height) {
                console.error(new Error('cubemap face images must have identical sizes'));
                return;
            }
        }
        if (width === 0 || height === 0) {
            return;
        }
        this.allocInternal(format, width, height, 1, 0);
        if (!this._device.isContextLost()) {
            const w = this._width;
            const h = this._height;
            for(let face = 0; face < 6; face++){
                createImageBitmap(images[face], {
                    premultiplyAlpha: 'none'
                }).then((bmData)=>{
                    this.updateFromElement(bmData, 0, 0, face, 0, 0, w, h);
                });
            }
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
    /** @internal */ loadLevels(levels, sRGB) {
        const format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        const width = levels.width;
        const height = levels.height;
        //const mipLevelCount = levels.mipLevels;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, 1) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('TextureCube.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let face = 0; face < 6; face++){
                if (levels.mipDatas[face].length !== levels.mipLevels) {
                    console.log(`TextureCube.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    this.uploadRaw(levels.mipDatas[face][i].data, levels.mipDatas[face][i].width, levels.mipDatas[face][i].height, 1, 0, 0, face, i);
                }
            }
        }
        if (levels.mipLevels !== this.mipLevelCount) {
            this.generateMipmaps();
        }
    }
}

class WebGPUTextureVideo extends WebGPUBaseTexture {
    _source;
    constructor(device, element){
        super(device, '2d');
        this._source = element;
        this._width = 0;
        this._height = 0;
        this.loadFromElement();
    }
    isTextureVideo() {
        return true;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get source() {
        return this._source;
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.loadElement(this._source);
        }
    }
    updateVideoFrame() {
        if (this._source.readyState > 2) {
            const videoFrame = new window.VideoFrame(this._source);
            videoFrame.close();
            this._object = this._device.gpuImportExternalTexture(this._source);
            return true;
        }
        return false;
    }
    createView(level, face, mipCount) {
        return null;
    }
    init() {
        this.loadFromElement();
    }
    readPixels(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixels()`);
    }
    readPixelsToBuffer(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixelsToBuffer()`);
    }
    /** @internal */ loadFromElement() {
        this.loadElement(this._source);
    }
    /** @internal */ loadElement(element) {
        this._format = 'rgba8unorm';
        this._width = element.videoWidth;
        this._height = element.videoHeight;
        this._depth = 1;
        this._mipLevelCount = 1;
        if (!this._device.isContextLost()) {
            if (element.readyState > 2) {
                this._object = this._device.gpuImportExternalTexture(element);
            }
        }
        return !!this._object;
    }
}

class WebGPUFramebufferCaps {
    maxDrawBuffers;
    maxColorAttachmentBytesPerSample;
    supportMultisampledFramebuffer;
    supportFloatBlending;
    supportDepth32float;
    supportDepth32floatStencil8;
    constructor(device){
        this.maxDrawBuffers = device.device.limits.maxColorAttachments;
        this.maxColorAttachmentBytesPerSample = device.device.limits.maxColorAttachmentBytesPerSample;
        this.supportMultisampledFramebuffer = true;
        this.supportFloatBlending = true;
        this.supportDepth32float = true;
        this.supportDepth32floatStencil8 = device.device.features.has('depth32float-stencil8');
    }
}
class WebGPUMiscCaps {
    supportOversizedViewport;
    supportBlendMinMax;
    support32BitIndex;
    supportDepthClamp;
    maxBindGroups;
    maxTexCoordIndex;
    constructor(device){
        this.supportOversizedViewport = false;
        this.supportBlendMinMax = true;
        this.support32BitIndex = true;
        this.supportDepthClamp = device.device.features.has('depth-clip-control');
        this.maxBindGroups = 4;
        this.maxTexCoordIndex = 8;
    }
}
class WebGPUShaderCaps {
    supportFragmentDepth;
    supportStandardDerivatives;
    supportShaderTextureLod;
    supportHighPrecisionFloat;
    supportHighPrecisionInt;
    maxUniformBufferSize;
    uniformBufferOffsetAlignment;
    constructor(device){
        this.supportFragmentDepth = true;
        this.supportStandardDerivatives = true;
        this.supportShaderTextureLod = true;
        this.supportHighPrecisionFloat = true;
        this.maxUniformBufferSize = device.device.limits.maxUniformBufferBindingSize || 65536;
        this.uniformBufferOffsetAlignment = device.device.limits.minUniformBufferOffsetAlignment || 256;
    }
}
class WebGPUTextureCaps {
    _textureFormatInfos;
    maxTextureSize;
    maxCubeTextureSize;
    npo2Mipmapping;
    npo2Repeating;
    supportS3TC;
    supportS3TCSRGB;
    supportDepthTexture;
    support3DTexture;
    supportSRGBTexture;
    supportFloatTexture;
    supportLinearFloatTexture;
    supportHalfFloatTexture;
    supportLinearHalfFloatTexture;
    supportAnisotropicFiltering;
    supportFloatColorBuffer;
    supportHalfFloatColorBuffer;
    supportFloatBlending;
    constructor(device){
        this.supportAnisotropicFiltering = true;
        this.supportDepthTexture = true;
        this.support3DTexture = true;
        this.supportSRGBTexture = true;
        this.supportFloatTexture = true;
        this.supportFloatColorBuffer = true;
        this.supportHalfFloatColorBuffer = true;
        this.supportFloatBlending = true;
        this.supportS3TC = device.device.features.has('texture-compression-bc');
        this.supportS3TCSRGB = this.supportS3TC;
        this.supportHalfFloatTexture = true;
        this.maxTextureSize = device.device.limits.maxTextureDimension2D;
        this.maxCubeTextureSize = device.device.limits.maxTextureDimension2D;
        this.npo2Mipmapping = true;
        this.npo2Repeating = true;
        this._textureFormatInfos = {
            ['rgba8unorm']: {
                gpuSampleType: 'float',
                filterable: true,
                renderable: true,
                compressed: false,
                writable: true,
                size: 4
            },
            ['rgba8snorm']: {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: false,
                writable: true,
                size: 4
            },
            ['bgra8unorm']: {
                gpuSampleType: 'float',
                filterable: true,
                renderable: true,
                compressed: false,
                writable: false,
                size: 4
            }
        };
        if (this.supportS3TC) {
            this._textureFormatInfos['dxt1'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 8,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt3'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt5'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
        }
        if (this.supportS3TCSRGB) {
            this._textureFormatInfos['dxt1-srgb'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 8,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt3-srgb'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt5-srgb'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
        }
        this._textureFormatInfos['r8unorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 1
        };
        this._textureFormatInfos['r8snorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: false,
            compressed: false,
            writable: false,
            size: 1
        }, this._textureFormatInfos['r16f'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['r32f'] = {
            gpuSampleType: 'unfilterable-float',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['r8ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 1
        };
        this._textureFormatInfos['r8i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 1
        };
        this._textureFormatInfos['r16ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['r16i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['r32ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['r32i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['rg8unorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg8snorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: false,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg16f'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rg32f'] = {
            gpuSampleType: 'unfilterable-float',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rg8ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg8i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg16ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rg16i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rg32ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rg32i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba8unorm-srgb'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['bgra8unorm-srgb'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rgba16f'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba32f'] = {
            gpuSampleType: 'unfilterable-float',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 16
        };
        this._textureFormatInfos['rgba8ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['rgba8i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['rgba16ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba16i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba32ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 16
        };
        this._textureFormatInfos['rgba32i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 16
        };
        this._textureFormatInfos['rg11b10uf'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: device.device.features.has('rg11b10ufloat-renderable'),
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['d16'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['d24'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['d32f'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['d32fs8'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 8
        };
        this._textureFormatInfos['d24s8'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this.supportLinearFloatTexture = this._textureFormatInfos['r32f'].filterable && this._textureFormatInfos['rg32f'].filterable && this._textureFormatInfos['rgba32f'].filterable;
        this.supportLinearHalfFloatTexture = this._textureFormatInfos['r16f'].filterable && this._textureFormatInfos['rg16f'].filterable && this._textureFormatInfos['rgba16f'].filterable;
    }
    calcMemoryUsage(format, numPixels) {
        return this._textureFormatInfos[format] ? this._textureFormatInfos[format].size * numPixels : 0;
    }
    getTextureFormatInfo(format) {
        return this._textureFormatInfos[format];
    }
}

class WebGPUVertexLayout extends WebGPUObject {
    static _hashCounter = 0;
    _vertexData;
    _hash;
    _layouts;
    constructor(device, options){
        super(device);
        this._vertexData = new VertexData();
        for (const vb of options.vertexBuffers){
            this._vertexData.setVertexBuffer(vb.buffer, vb.stepMode);
        }
        if (options.indexBuffer) {
            this._vertexData.setIndexBuffer(options.indexBuffer);
        }
        this._hash = String(++WebGPUVertexLayout._hashCounter);
        this._layouts = {};
    }
    destroy() {
        this._object = null;
    }
    async restore() {
        this._object = {};
    }
    setDrawOffset(buffer, byteOffset) {
        for (const info of this._vertexData.vertexBuffers){
            if (info?.buffer === buffer) {
                info.drawOffset = byteOffset;
            }
        }
    }
    get hash() {
        return this._hash;
    }
    get vertexBuffers() {
        return this._vertexData.vertexBuffers;
    }
    get indexBuffer() {
        return this._vertexData.indexBuffer;
    }
    getDrawOffset() {
        return this._vertexData.getDrawOffset();
    }
    getVertexBuffer(semantic) {
        return this._vertexData.getVertexBuffer(semantic);
    }
    getVertexBufferInfo(semantic) {
        return this._vertexData.getVertexBufferInfo(semantic);
    }
    getIndexBuffer() {
        return this._vertexData.getIndexBuffer();
    }
    getLayouts(attributes) {
        if (!attributes) {
            return null;
        }
        let layout = this._layouts[attributes];
        if (!layout) {
            layout = this.calcHash(attributes);
            this._layouts[attributes] = layout;
        }
        return layout;
    }
    calcHash(attribHash) {
        const layouts = [];
        const layoutVertexBuffers = [];
        const vertexBuffers = this._vertexData.vertexBuffers;
        const attributes = attribHash.split(':').map((val)=>Number(val));
        for(let idx = 0; idx < attributes.length; idx++){
            const attrib = attributes[idx];
            const bufferInfo = vertexBuffers[attrib];
            const buffer = bufferInfo?.buffer;
            if (!buffer) {
                console.log(`ERROR: No vertex buffer set for location ${idx}`);
                continue;
            }
            const gpuFormat = WebGPUStructuredBuffer.getGPUVertexFormat(bufferInfo.type);
            if (!gpuFormat) {
                throw new Error('Invalid vertex buffer format');
            }
            const index = layoutVertexBuffers.findIndex((val)=>val.buffer === buffer);
            const stride = bufferInfo.stride;
            let layout = index >= 0 ? layouts[index] : `${stride}-${Number(bufferInfo.stepMode === 'instance')}`;
            layout += `-${vertexFormatToHash[gpuFormat]}-${bufferInfo.offset}-${idx}`;
            if (index >= 0) {
                layouts[index] = layout;
            } else {
                layouts.push(layout);
                layoutVertexBuffers.push(bufferInfo);
            }
        }
        return {
            layoutHash: layouts.join(':'),
            buffers: layoutVertexBuffers
        };
    }
    bind() {
        this._device.setVertexLayout(this);
    }
    draw(primitiveType, first, count) {
        this.bind();
        this._device.draw(primitiveType, first, count);
    }
    drawInstanced(primitiveType, first, count, numInstances) {
        this.bind();
        this._device.drawInstanced(primitiveType, first, count, numInstances);
    }
}

class WebGPURenderState {
    static _defaultState;
    _hash;
    static get defaultState() {
        return this._defaultState;
    }
    constructor(){
        this._hash = null;
    }
    get hash() {
        return this._getHash(this.constructor);
    }
    invalidateHash() {
        this._hash = null;
    }
    _getHash(ctor) {
        if (this === ctor.defaultState) {
            return '';
        } else {
            if (this._hash === null) {
                this._hash = this.computeHash();
            }
            return this._hash;
        }
    }
}
class WebGPUColorState extends WebGPURenderState {
    static _defaultState = new WebGPUColorState();
    _redMask;
    _greenMask;
    _blueMask;
    _alphaMask;
    constructor(){
        super();
        this._redMask = this._greenMask = this._blueMask = this._alphaMask = true;
    }
    clone() {
        return new WebGPUColorState().setColorMask(this._redMask, this._greenMask, this._blueMask, this._alphaMask);
    }
    get redMask() {
        return this._redMask;
    }
    set redMask(val) {
        if (this._redMask !== !!val) {
            this._redMask = !!val;
            this.invalidateHash();
        }
    }
    get greenMask() {
        return this._greenMask;
    }
    set greenMask(val) {
        if (this._greenMask !== !!val) {
            this._greenMask = !!val;
            this.invalidateHash();
        }
    }
    get blueMask() {
        return this._blueMask;
    }
    set blueMask(val) {
        if (this._blueMask !== !!val) {
            this._blueMask = !!val;
            this.invalidateHash();
        }
    }
    get alphaMask() {
        return this._alphaMask;
    }
    set alphaMask(val) {
        if (this._alphaMask !== !!val) {
            this._alphaMask = !!val;
            this.invalidateHash();
        }
    }
    setColorMask(r, g, b, a) {
        this.redMask = r;
        this.greenMask = g;
        this.blueMask = b;
        this.alphaMask = a;
        return this;
    }
    computeHash() {
        let val = 0;
        if (this.redMask) {
            val += 1 << 0;
        }
        if (this.greenMask) {
            val += 1 << 1;
        }
        if (this.blueMask) {
            val += 1 << 2;
        }
        if (this.alphaMask) {
            val += 1 << 3;
        }
        return String(val);
    }
}
class WebGPUBlendingState extends WebGPURenderState {
    static _defaultState = new WebGPUBlendingState();
    _enabled;
    _alphaToCoverageEnabled;
    _srcBlendRGB;
    _dstBlendRGB;
    _srcBlendAlpha;
    _dstBlendAlpha;
    _rgbEquation;
    _alphaEquation;
    constructor(){
        super();
        this._enabled = false;
        this._alphaToCoverageEnabled = false;
        this._srcBlendRGB = 'one';
        this._dstBlendRGB = 'zero';
        this._srcBlendAlpha = 'one';
        this._dstBlendAlpha = 'zero';
        this._rgbEquation = 'add';
        this._alphaEquation = 'add';
    }
    clone() {
        const other = new WebGPUBlendingState();
        other.enable(this._enabled);
        other.enableAlphaToCoverage(this._alphaToCoverageEnabled);
        other.setBlendFuncRGB(this._srcBlendRGB, this._dstBlendRGB);
        other.setBlendFuncAlpha(this._srcBlendAlpha, this._dstBlendAlpha);
        other.setBlendEquation(this._rgbEquation, this._alphaEquation);
        return other;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(val) {
        if (this._enabled !== !!val) {
            this._enabled = !!val;
            this.invalidateHash();
        }
    }
    get alphaToCoverageEnabled() {
        return this._alphaToCoverageEnabled;
    }
    set alphaToCoverageEnabled(val) {
        if (this._alphaToCoverageEnabled !== !!val) {
            this._alphaToCoverageEnabled = !!val;
            this.invalidateHash();
        }
    }
    get srcBlendRGB() {
        return this._srcBlendRGB;
    }
    set srcBlendRGB(val) {
        if (this._srcBlendRGB !== val) {
            this._srcBlendRGB = val;
            this.invalidateHash();
        }
    }
    get srcBlendAlpha() {
        return this._srcBlendAlpha;
    }
    set srcBlendAlpha(val) {
        if (this._srcBlendAlpha !== val) {
            this._srcBlendAlpha = val;
            this.invalidateHash();
        }
    }
    get dstBlendRGB() {
        return this._dstBlendRGB;
    }
    set dstBlendRGB(val) {
        if (this._dstBlendRGB !== val) {
            this._dstBlendRGB = val;
            this.invalidateHash();
        }
    }
    get dstBlendAlpha() {
        return this._dstBlendAlpha;
    }
    set dstBlendAlpha(val) {
        if (this._dstBlendAlpha !== val) {
            this._dstBlendAlpha = val;
            this.invalidateHash();
        }
    }
    get rgbEquation() {
        return this._rgbEquation;
    }
    set rgbEquation(val) {
        if (this._rgbEquation !== val) {
            this._rgbEquation = val;
            this.invalidateHash();
        }
    }
    get alphaEquation() {
        return this._alphaEquation;
    }
    set alphaEquation(val) {
        if (this._alphaEquation !== val) {
            this._alphaEquation = val;
            this.invalidateHash();
        }
    }
    enable(b) {
        this.enabled = b;
        return this;
    }
    enableAlphaToCoverage(b) {
        this.alphaToCoverageEnabled = b;
        return this;
    }
    setBlendFunc(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendFuncRGB(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        return this;
    }
    setBlendFuncAlpha(src, dest) {
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendEquation(rgb, alpha) {
        this.rgbEquation = rgb;
        this.alphaEquation = alpha;
        return this;
    }
    computeHash() {
        return this._enabled ? `${this._srcBlendRGB}-${this._srcBlendAlpha}-${this._dstBlendRGB}-${this._dstBlendAlpha}-${this._rgbEquation}-${this._alphaEquation}-${Number(!!this._alphaToCoverageEnabled)}` : `${Number(!!this._alphaToCoverageEnabled)}`;
    }
}
class WebGPURasterizerState extends WebGPURenderState {
    static _defaultState = new WebGPURasterizerState();
    _cullMode;
    _depthClampEnabled;
    constructor(){
        super();
        this._cullMode = 'back';
        this._depthClampEnabled = false;
    }
    clone() {
        return new WebGPURasterizerState().setCullMode(this._cullMode).enableDepthClamp(this._depthClampEnabled);
    }
    get cullMode() {
        return this._cullMode;
    }
    set cullMode(val) {
        if (this._cullMode !== val) {
            this._cullMode = val;
            this.invalidateHash();
        }
    }
    setCullMode(mode) {
        this.cullMode = mode;
        return this;
    }
    get depthClampEnabled() {
        return this._depthClampEnabled;
    }
    set depthClampEnabled(val) {
        this.enableDepthClamp(val);
    }
    enableDepthClamp(enable) {
        if (this._depthClampEnabled !== !!enable) {
            this._depthClampEnabled = !!enable;
            this.invalidateHash();
        }
        return this;
    }
    computeHash() {
        return `${this._cullMode}-${this._depthClampEnabled ? 1 : 0}`;
    }
}
class WebGPUDepthState extends WebGPURenderState {
    static _defaultState = new WebGPUDepthState();
    _testEnabled;
    _writeEnabled;
    _compareFunc;
    constructor(){
        super();
        this._testEnabled = true;
        this._writeEnabled = true;
        this._compareFunc = 'le';
    }
    clone() {
        const other = new WebGPUDepthState();
        other.enableTest(this._testEnabled);
        other.enableWrite(this._writeEnabled);
        other.setCompareFunc(this._compareFunc);
        return other;
    }
    get testEnabled() {
        return this._testEnabled;
    }
    set testEnabled(val) {
        if (this._testEnabled !== !!val) {
            this._testEnabled = val;
            this.invalidateHash();
        }
    }
    get writeEnabled() {
        return this._writeEnabled;
    }
    set writeEnabled(val) {
        if (this._writeEnabled !== !!val) {
            this._writeEnabled = val;
            this.invalidateHash();
        }
    }
    get compareFunc() {
        return this._compareFunc;
    }
    set compareFunc(val) {
        if (this._compareFunc !== val) {
            this._compareFunc = val;
            this.invalidateHash();
        }
    }
    enableTest(b) {
        this.testEnabled = b;
        return this;
    }
    enableWrite(b) {
        this.writeEnabled = b;
        return this;
    }
    setCompareFunc(func) {
        this.compareFunc = func;
        return this;
    }
    computeHash() {
        return `${Number(this._testEnabled)}-${Number(this._writeEnabled)}-${this.compareFunc}}`;
    }
}
class WebGPUStencilState extends WebGPURenderState {
    static _defaultState = new WebGPUStencilState();
    _enabled;
    _writeMask;
    _failOp;
    _failOpBack;
    _zFailOp;
    _zFailOpBack;
    _passOp;
    _passOpBack;
    _func;
    _funcBack;
    _ref;
    _readMask;
    constructor(){
        super();
        this._enabled = false;
        this._failOp = this.failOpBack = 'keep';
        this._zFailOp = this.zFailOpBack = 'keep';
        this._passOp = this.passOpBack = 'keep';
        this._func = this.funcBack = 'always';
        this._ref = 0;
        this._writeMask = 0xffffffff;
        this._readMask = 0xffffffff;
    }
    clone() {
        const other = new WebGPUStencilState();
        other.enable(this._enabled);
        other.setWriteMask(this._writeMask);
        other.setFrontOp(this._failOp, this._zFailOp, this._passOp);
        other.setBackOp(this._failOpBack, this._zFailOpBack, this._passOpBack);
        other.setFrontCompareFunc(this._func);
        other.setBackCompareFunc(this._funcBack);
        other.setReference(this._ref);
        other.setReadMask(this._readMask);
        return other;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(val) {
        if (this._enabled !== !!val) {
            this._enabled = !!val;
            this.invalidateHash();
        }
    }
    get writeMask() {
        return this._writeMask;
    }
    set writeMask(val) {
        if (this._writeMask !== val) {
            this._writeMask = val;
            this.invalidateHash();
        }
    }
    get failOp() {
        return this._failOp;
    }
    set failOp(val) {
        if (this._failOp !== val) {
            this._failOp = val;
            this.invalidateHash();
        }
    }
    get failOpBack() {
        return this._failOpBack;
    }
    set failOpBack(val) {
        if (this._failOpBack !== val) {
            this._failOpBack = val;
            this.invalidateHash();
        }
    }
    get zFailOp() {
        return this._zFailOp;
    }
    set zFailOp(val) {
        if (this._zFailOp !== val) {
            this._zFailOp = val;
            this.invalidateHash();
        }
    }
    get zFailOpBack() {
        return this._zFailOpBack;
    }
    set zFailOpBack(val) {
        if (this._zFailOpBack !== val) {
            this._zFailOpBack = val;
            this.invalidateHash();
        }
    }
    get passOp() {
        return this._passOp;
    }
    set passOp(val) {
        if (this._passOp !== val) {
            this._passOp = val;
            this.invalidateHash();
        }
    }
    get passOpBack() {
        return this._passOpBack;
    }
    set passOpBack(val) {
        if (this._passOpBack !== val) {
            this._passOpBack = val;
            this.invalidateHash();
        }
    }
    get func() {
        return this._func;
    }
    set func(val) {
        if (this._func !== val) {
            this._func = val;
            this.invalidateHash();
        }
    }
    get funcBack() {
        return this._funcBack;
    }
    set funcBack(val) {
        if (this._funcBack !== val) {
            this._funcBack = val;
            this.invalidateHash();
        }
    }
    get ref() {
        return this._ref;
    }
    set ref(val) {
        if (this._ref !== val) {
            this._ref = val;
            this.invalidateHash();
        }
    }
    get readMask() {
        return this._readMask;
    }
    set readMask(val) {
        if (this._readMask !== val) {
            this._readMask = val;
            this.invalidateHash();
        }
    }
    enable(b) {
        this.enabled = b;
        return this;
    }
    setWriteMask(mask) {
        this.writeMask = mask;
        return this;
    }
    setFrontOp(fail, zfail, pass) {
        this.failOp = fail;
        this.zFailOp = zfail;
        this.passOp = pass;
        return this;
    }
    setBackOp(fail, zfail, pass) {
        this.failOpBack = fail;
        this.zFailOpBack = zfail;
        this.passOpBack = pass;
        return this;
    }
    setFrontCompareFunc(func) {
        this.func = func;
        return this;
    }
    setBackCompareFunc(func) {
        this.funcBack = func;
        return this;
    }
    setReference(ref) {
        this.ref = ref;
        return this;
    }
    setReadMask(mask) {
        this.readMask = mask;
        return this;
    }
    computeHash() {
        return this._enabled ? `${this.sideHash(false)}-${this.sideHash(true)}-${this.readMask.toString(16)}-${this.writeMask.toString(16)}-${this.ref.toString(16)}` : '';
    }
    sideHash(back) {
        return back ? `${this._failOpBack}-${this._zFailOpBack}-${this._passOpBack}-${this._funcBack}` : `${this._failOp}-${this._zFailOp}-${this._passOp}-${this._func}`;
    }
}
class WebGPURenderStateSet {
    _device;
    colorState;
    blendingState;
    rasterizerState;
    depthState;
    stencilState;
    constructor(device){
        this._device = device;
        this.colorState = null;
        this.blendingState = null;
        this.rasterizerState = null;
        this.depthState = null;
        this.stencilState = null;
    }
    copyFrom(stateSet) {
        this.colorState = stateSet.colorState;
        this.blendingState = stateSet.blendingState;
        this.rasterizerState = stateSet.rasterizerState;
        this.depthState = stateSet.depthState;
        this.stencilState = stateSet.stencilState;
    }
    get hash() {
        return `${this.colorState?.hash || ''}:${this.blendingState?.hash || ''}:${this.rasterizerState?.hash || ''}:${this.depthState?.hash || ''}:${this.stencilState?.hash || ''}`;
    }
    useColorState(state) {
        return this.colorState = state ?? this.colorState ?? new WebGPUColorState();
    }
    defaultColorState() {
        this.colorState = null;
    }
    useBlendingState(state) {
        return this.blendingState = state ?? this.blendingState ?? new WebGPUBlendingState();
    }
    defaultBlendingState() {
        this.blendingState = null;
    }
    useRasterizerState(state) {
        return this.rasterizerState = state ?? this.rasterizerState ?? new WebGPURasterizerState();
    }
    defaultRasterizerState() {
        this.rasterizerState = null;
    }
    useDepthState(state) {
        return this.depthState = state ?? this.depthState ?? new WebGPUDepthState();
    }
    defaultDepthState() {
        this.depthState = null;
    }
    useStencilState(state) {
        return this.stencilState = state ?? this.stencilState ?? new WebGPUStencilState();
    }
    defaultStencilState() {
        this.stencilState = null;
    }
    apply(force) {
        this._device.setRenderStates(this);
    }
}

const typeU16$2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const stencilFormats = [
    'stencil8',
    'depth24plus-stencil8',
    'depth24unorm-stencil8',
    'depth32float-stencil8'
];
const depthFormats = [
    'depth16unorm',
    'depth24plus',
    'depth24plus-stencil8',
    'depth32float',
    'depth24unorm-stencil8',
    'depth32float-stencil8'
];
class PipelineCache {
    _device;
    _renderPipelines;
    _computePipelines;
    constructor(device){
        this._device = device;
        this._renderPipelines = {};
        this._computePipelines = {};
    }
    wipeCache() {
        this._renderPipelines = {};
        this._computePipelines = {};
    }
    fetchComputePipeline(program) {
        const hash = this.getComputePipelineHash(program);
        let pipeline = this._computePipelines[hash];
        if (pipeline === undefined) {
            const shaderModule = program.getShaderModule();
            const desc = {
                layout: shaderModule.pipelineLayout,
                compute: {
                    module: shaderModule.csModule,
                    entryPoint: 'main'
                }
            };
            pipeline = this._device.gpuCreateComputePipeline(desc);
            this._computePipelines[hash] = pipeline;
        }
        return pipeline;
    }
    fetchRenderPipeline(program, vertexData, stateSet, primitiveType, frameBufferInfo) {
        if (!frameBufferInfo.hash) {
            return null;
        }
        if (!program.vertexAttributes) {
            // no vertex data needed for this pipeline
            vertexData = null;
        }
        const hash = this.getRenderPipelineHash(frameBufferInfo.hash, program, vertexData, stateSet, primitiveType);
        let pipeline = this._renderPipelines[hash];
        if (pipeline === undefined) {
            const bufferLayouts = vertexData ? this._device.fetchVertexLayout(vertexData.getLayouts(program.vertexAttributes).layoutHash) : null;
            const shaderModule = program.getShaderModule();
            const vertex = {
                module: shaderModule.vsModule,
                entryPoint: 'main'
            };
            if (bufferLayouts) {
                vertex.buffers = bufferLayouts;
            }
            const primitiveState = this.createPrimitiveState(vertexData, stateSet, primitiveType);
            const depthStencilState = this.createDepthStencilState(frameBufferInfo.depthFormat, stateSet);
            const colorTargetStates = frameBufferInfo.colorFormats.map((val)=>this.createColorTargetState(stateSet, val));
            const desc = {
                label: hash,
                layout: shaderModule.pipelineLayout,
                vertex,
                primitive: primitiveState,
                depthStencil: depthStencilState,
                multisample: this.createMultisampleState(frameBufferInfo.sampleCount, stateSet),
                fragment: {
                    module: shaderModule.fsModule,
                    entryPoint: 'main',
                    targets: colorTargetStates
                }
            };
            pipeline = this._device.gpuCreateRenderPipeline(desc);
            this._renderPipelines[hash] = pipeline;
        }
        return pipeline;
    }
    createPrimitiveState(vertexData, stateSet, primitiveType) {
        const topology = primitiveTypeMap[primitiveType];
        if (!topology) {
            throw new Error(`createPrimitiveState() failed: invalid primitive type: ${primitiveType}`);
        }
        const rasterizerState = stateSet?.rasterizerState || WebGPURasterizerState.defaultState;
        const cullMode = faceModeMap[rasterizerState.cullMode];
        if (!cullMode) {
            throw new Error(`createPrimitiveState() failed: invalid cull mode: ${rasterizerState.cullMode}`);
        }
        const frontFace = this._device.isWindingOrderReversed() ? 'cw' : 'ccw';
        const state = {
            topology,
            frontFace,
            cullMode
        };
        if (this._device.device.features.has('depth-clip-control')) {
            state.unclippedDepth = rasterizerState.depthClampEnabled;
        }
        if (topology === 'triangle-strip' || topology === 'line-strip') {
            state.stripIndexFormat = vertexData?.getIndexBuffer()?.indexType === typeU16$2 ? 'uint16' : 'uint32';
        }
        return state;
    }
    createMultisampleState(sampleCount, stateSet) {
        return {
            count: sampleCount,
            alphaToCoverageEnabled: sampleCount > 1 && (stateSet?.blendingState ?? WebGPUBlendingState.defaultState).alphaToCoverageEnabled
        };
    }
    createDepthStencilState(depthFormat, stateSet) {
        if (!depthFormat) {
            return undefined;
        }
        const depthState = stateSet?.depthState || WebGPUDepthState.defaultState;
        const stencilState = stateSet?.stencilState || WebGPUStencilState.defaultState;
        const hasStencil = stencilFormats.indexOf(depthFormat) >= 0;
        const hasDepth = depthFormats.indexOf(depthFormat) >= 0;
        const depthWriteEnabled = hasDepth ? depthState.writeEnabled : false;
        const depthCompare = hasDepth && depthState.testEnabled ? compareFuncMap[depthState.compareFunc] : 'always';
        const state = {
            format: depthFormat,
            depthWriteEnabled,
            depthCompare
        };
        if (hasStencil) {
            const stencilFront = stencilState.enabled ? this.createStencilFaceState(stencilState.func, stencilState.failOp, stencilState.zFailOp, stencilState.passOp) : undefined;
            const stencilBack = stencilState.enabled ? this.createStencilFaceState(stencilState.funcBack, stencilState.failOpBack, stencilState.zFailOpBack, stencilState.passOpBack) : undefined;
            const stencilReadMask = stencilState.enabled ? stencilState.readMask : undefined;
            const stencilWriteMask = stencilState.enabled ? stencilState.writeMask : undefined;
            state.stencilFront = stencilFront;
            state.stencilBack = stencilBack;
            state.stencilReadMask = stencilReadMask;
            state.stencilWriteMask = stencilWriteMask;
        }
        return state;
    }
    createStencilFaceState(func, failOp, zFailOp, passOp) {
        return {
            compare: compareFuncMap[func],
            failOp: stencilOpMap[failOp],
            depthFailOp: stencilOpMap[zFailOp],
            passOp: stencilOpMap[passOp]
        };
    }
    createColorTargetState(stateSet, format) {
        const blendingState = stateSet?.blendingState || WebGPUBlendingState.defaultState;
        const colorState = stateSet?.colorState || WebGPUColorState.defaultState;
        const r = colorState.redMask ? GPUColorWrite.RED : 0;
        const g = colorState.greenMask ? GPUColorWrite.GREEN : 0;
        const b = colorState.blueMask ? GPUColorWrite.BLUE : 0;
        const a = colorState.alphaMask ? GPUColorWrite.ALPHA : 0;
        const state = {
            format: format,
            writeMask: r | g | b | a
        };
        if (blendingState.enabled) {
            state.blend = this.createBlendState(blendingState);
        }
        return state;
    }
    createBlendState(blendingState) {
        return {
            color: this.createBlendComponent(blendingState.rgbEquation, blendingState.srcBlendRGB, blendingState.dstBlendRGB),
            alpha: this.createBlendComponent(blendingState.alphaEquation, blendingState.srcBlendAlpha, blendingState.dstBlendAlpha)
        };
    }
    createBlendComponent(op, srcFunc, dstFunc) {
        const operation = blendEquationMap[op];
        if (!operation) {
            throw new Error(`createBlendComponent() failed: invalid blend op: ${op}`);
        }
        const srcFactor = blendFuncMap[srcFunc];
        if (!srcFactor) {
            throw new Error(`createBlendComponent() failed: invalid source blend func ${srcFunc}`);
        }
        const dstFactor = blendFuncMap[dstFunc];
        if (!dstFactor) {
            throw new Error(`createBlendComponent() failed: invalid dest blend func ${dstFunc}`);
        }
        return {
            operation,
            srcFactor,
            dstFactor
        };
    }
    getRenderPipelineHash(fbHash, program, vertexData, stateSet, primitiveType) {
        const programHash = program.hash;
        const vertexHash = vertexData?.getLayouts(program.vertexAttributes).layoutHash || '';
        const stateHash = stateSet?.hash || '';
        return `${programHash}:${vertexHash}:${fbHash}:${primitiveType}:${stateHash}:${Number(this._device.isWindingOrderReversed())}`;
    }
    getComputePipelineHash(program) {
        return program.hash;
    }
}

class WebGPUFrameBuffer extends WebGPUObject {
    _options;
    _width;
    _height;
    _bindFlag;
    _msaaColorTextures;
    _msaaDepthTexture;
    constructor(device, colorAttachments, depthAttachment, opt){
        super(device);
        if (colorAttachments.length > 0 && colorAttachments.findIndex((val)=>!val) >= 0) {
            throw new Error('WebGPUFramebuffer(): invalid color attachments');
        }
        this._object = null;
        this._options = {
            colorAttachments: colorAttachments?.length > 0 ? colorAttachments.map((value)=>({
                    texture: value,
                    face: 0,
                    layer: 0,
                    level: 0,
                    generateMipmaps: true
                })) : null,
            depthAttachment: depthAttachment ? {
                texture: depthAttachment,
                face: 0,
                layer: 0,
                level: 0,
                generateMipmaps: false
            } : null,
            sampleCount: opt?.sampleCount ?? 1,
            ignoreDepthStencil: opt?.ignoreDepthStencil ?? false
        };
        if (!this._options.colorAttachments && !this._options.depthAttachment) {
            throw new Error('WebGPUFramebuffer(): colorAttachments or depthAttachment must be specified');
        }
        this._width = this._options.colorAttachments ? this._options.colorAttachments[0].texture.width : this._options.depthAttachment.texture.width;
        this._height = this._options.colorAttachments ? this._options.colorAttachments[0].texture.height : this._options.depthAttachment.texture.height;
        if (this._options.colorAttachments && this._options.colorAttachments.findIndex((val)=>val.texture.width !== this._width || val.texture.height !== this._height) >= 0 || this._options.depthAttachment && (this._options.depthAttachment.texture.width !== this._width || this._options.depthAttachment.texture.height !== this._height)) {
            throw new Error('WebGPUFramebuffer(): attachment textures must have same width and height');
        }
        this._bindFlag = 0;
        this._msaaColorTextures = null;
        this._msaaDepthTexture = null;
        this._init();
    }
    getOptions() {
        return this._options;
    }
    get bindFlag() {
        return this._bindFlag;
    }
    getWidth() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return attachment ? Math.max(attachment.texture.width >> attachment.level, 1) : 0;
    }
    getHeight() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return attachment ? Math.max(attachment.texture.height >> attachment.level, 1) : 0;
    }
    async restore() {
        if (this._options?.depthAttachment?.texture?.disposed) {
            await this._options.depthAttachment.texture.reload();
        }
        if (this._options?.colorAttachments) {
            for (const k of this._options.colorAttachments){
                if (k?.texture?.disposed) {
                    await k.texture.reload();
                }
            }
        }
        if (!this._device.isContextLost()) {
            this._init();
        }
    }
    destroy() {
        this._object = null;
        if (this._msaaColorTextures) {
            for (const tex of this._msaaColorTextures){
                tex.destroy();
            }
            this._msaaColorTextures = null;
        }
        if (this._msaaDepthTexture) {
            this._msaaDepthTexture.destroy();
            this._msaaDepthTexture = null;
        }
    }
    setColorAttachmentGenerateMipmaps(index, generateMipmaps) {
        const k = this._options.colorAttachments?.[index];
        if (k) {
            k.generateMipmaps = !!generateMipmaps;
        }
    }
    setColorAttachmentCubeFace(index, face) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.face !== face) {
            k.face = face;
            this._bindFlag++;
        }
    }
    setColorAttachmentMipLevel(index, level) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.level !== level) {
            k.level = level;
            this._bindFlag++;
        }
    }
    setColorAttachmentLayer(index, layer) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.layer !== layer) {
            k.layer = layer;
            this._bindFlag++;
        }
    }
    setDepthAttachmentCubeFace(face) {
        const k = this._options.depthAttachment;
        if (k && k.face !== face) {
            k.face = face;
            this._bindFlag++;
        }
    }
    setDepthAttachmentLayer(layer) {
        const k = this._options.depthAttachment;
        if (k && k.layer !== layer) {
            k.layer = layer;
            this._bindFlag++;
        }
    }
    getDepthAttachment() {
        return this._options?.depthAttachment?.texture || null;
    }
    getColorAttachments() {
        return this._options?.colorAttachments?.map((val)=>val?.texture || null) || [];
    }
    getMSAADepthAttachment() {
        return this._msaaDepthTexture;
    }
    getMSAAColorAttacments() {
        return this._msaaColorTextures;
    }
    getColorFormats() {
        return this._options?.colorAttachments?.map((val)=>(val?.texture)?.gpuFormat || null);
    }
    getDepthFormat() {
        return (this._options.depthAttachment?.texture)?.gpuFormat || null;
    }
    bind() {
        throw new Error('no bind operatation for WebGPU');
    }
    unbind() {
        throw new Error('no unbind operatation for WebGPU');
    }
    _init() {
        if (this._options.sampleCount > 1) {
            this._msaaColorTextures = [];
            for (const colorAttachment of this._options.colorAttachments){
                const msaaTexture = this.device.gpuCreateTexture({
                    size: {
                        width: this._width,
                        height: this._height,
                        depthOrArrayLayers: 1
                    },
                    format: colorAttachment.texture.gpuFormat,
                    mipLevelCount: 1,
                    sampleCount: this._options.sampleCount,
                    dimension: '2d',
                    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
                });
                this._msaaColorTextures.push(msaaTexture);
            }
            if (this._options.depthAttachment) {
                const msaaDepthTexture = this.device.gpuCreateTexture({
                    size: {
                        width: this._width,
                        height: this._height,
                        depthOrArrayLayers: 1
                    },
                    format: this._options.depthAttachment.texture.gpuFormat,
                    mipLevelCount: 1,
                    sampleCount: this._options.sampleCount,
                    dimension: '2d',
                    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
                });
                this._msaaDepthTexture = msaaDepthTexture;
            }
        }
        this._object = {};
    }
    isFramebuffer() {
        return true;
    }
    getSampleCount() {
        return this._options.sampleCount;
    }
}

const typeU16$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const typeU32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
class WebGPUIndexBuffer extends WebGPUBuffer {
    indexType;
    length;
    constructor(device, data, usage){
        if (!(data instanceof Uint16Array) && !(data instanceof Uint32Array)) {
            throw new Error('invalid index data');
        }
        super(device, GPUResourceUsageFlags.BF_INDEX | usage, data);
        this.indexType = data instanceof Uint16Array ? typeU16$1 : typeU32;
        this.length = data.length;
    }
}

class BindGroupCache {
    _device;
    _bindGroupLayoutCache;
    constructor(device){
        this._device = device;
        this._bindGroupLayoutCache = {};
    }
    fetchBindGroupLayout(desc) {
        const hash = desc ? this.getLayoutHash(desc) : '';
        let bgl = this._bindGroupLayoutCache[hash];
        if (!bgl) {
            bgl = this.createBindGroupLayout(desc);
            if (bgl) {
                this._bindGroupLayoutCache[hash] = bgl;
            } else {
                throw new Error(`fetchBindGroupLayout() failed: hash: ${hash}`);
            }
        }
        return bgl;
    }
    getLayoutHash(desc) {
        let hash = '';
        for (const entry of desc.entries){
            let s = `${entry.binding}:${entry.visibility}:`;
            if (entry.buffer) {
                s += `b:${entry.buffer.type}:${entry.buffer.hasDynamicOffset}:${entry.buffer.minBindingSize}`;
            } else if (entry.sampler) {
                s += `s${entry.sampler.type}:`;
            } else if (entry.texture) {
                s += `t${entry.texture.sampleType}-${entry.texture.viewDimension}-${Number(!!entry.texture.multisampled)}:`;
            } else if (entry.storageTexture) {
                s += `k${entry.storageTexture.access}-${entry.storageTexture.format}-${entry.storageTexture.viewDimension}:`;
            } else if (entry.externalTexture) {
                s += `v:`;
            }
            hash = `${hash} ${s}`;
        }
        return hash;
    }
    createBindGroupLayout(desc) {
        const layoutDescriptor = {
            entries: desc?.entries.map((entry)=>{
                const binding = entry.binding;
                const visibility = (entry.visibility & ShaderType.Vertex ? GPUShaderStage.VERTEX : 0) | (entry.visibility & ShaderType.Fragment ? GPUShaderStage.FRAGMENT : 0) | (entry.visibility & ShaderType.Compute ? GPUShaderStage.COMPUTE : 0);
                const buffer = entry.buffer ? {
                    type: entry.buffer.type,
                    hasDynamicOffset: entry.buffer.hasDynamicOffset,
                    // minBindingSize: entry.buffer.uniformLayout.byteSize
                    minBindingSize: Number(entry.buffer.minBindingSize) || 0
                } : undefined;
                const sampler = entry.sampler ? {
                    type: entry.sampler.type
                } : undefined;
                const texture = entry.texture ? {
                    sampleType: entry.texture.sampleType,
                    viewDimension: entry.texture.viewDimension
                } : undefined;
                const storageTexture = entry.storageTexture ? {
                    access: 'write-only',
                    viewDimension: '2d',
                    format: textureFormatMap[entry.storageTexture.format]
                } : undefined;
                const externalTexture = entry.externalTexture ? {} : undefined;
                const t = {
                    binding,
                    visibility
                };
                if (buffer) {
                    t.buffer = buffer;
                } else if (sampler) {
                    t.sampler = sampler;
                } else if (texture) {
                    t.texture = texture;
                } else if (storageTexture) {
                    t.storageTexture = storageTexture;
                } else if (externalTexture) {
                    t.externalTexture = externalTexture;
                }
                return t;
            }) || []
        };
        if (desc?.label) {
            layoutDescriptor.label = desc.label;
        }
        return this._device.device.createBindGroupLayout(layoutDescriptor);
    }
}

class VertexLayoutCache {
    _layouts;
    constructor(){
        this._layouts = {};
    }
    fetchVertexLayout(hash) {
        let layouts = this._layouts[hash];
        if (!layouts) {
            layouts = [];
            hash.split(':').forEach((l)=>{
                const parts = l.split('-');
                const layout = {
                    arrayStride: Number(parts[0]),
                    stepMode: Number(parts[1]) ? 'instance' : 'vertex',
                    attributes: []
                };
                for(let i = 2; i < parts.length; i += 3){
                    layout.attributes.push({
                        format: hashToVertexFormat[parts[i]],
                        offset: Number(parts[i + 1]),
                        shaderLocation: Number(parts[i + 2])
                    });
                }
                layouts.push(layout);
            });
            this._layouts[hash] = layouts;
        }
        return layouts;
    }
}

class WebGPUTextureSampler extends WebGPUObject {
    _options;
    constructor(device, options){
        super(device);
        this._options = Object.assign({
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter: 'nearest',
            minFilter: 'nearest',
            mipFilter: 'none',
            lodMin: 0,
            lodMax: 32,
            compare: null,
            maxAnisotropy: 1
        }, options || {});
        this._load();
    }
    get hash() {
        return this._object ? this._device.gpuGetObjectHash(this._object) : 0;
    }
    get addressModeU() {
        return this._options.addressU;
    }
    get addressModeV() {
        return this._options.addressV;
    }
    get addressModeW() {
        return this._options.addressW;
    }
    get magFilter() {
        return this._options.magFilter;
    }
    get minFilter() {
        return this._options.minFilter;
    }
    get mipFilter() {
        return this._options.mipFilter;
    }
    get lodMin() {
        return this._options.lodMin;
    }
    get lodMax() {
        return this._options.lodMax;
    }
    get compare() {
        return this._options.compare;
    }
    get maxAnisotropy() {
        return this._options.maxAnisotropy;
    }
    destroy() {
        this._object = null;
    }
    async restore() {
        if (!this._device.isContextLost()) {
            this._load();
        }
    }
    _load() {
        this._object = this._device.gpuCreateSampler({
            addressModeU: textureWrappingMap[this._options.addressU],
            addressModeV: textureWrappingMap[this._options.addressV],
            addressModeW: textureWrappingMap[this._options.addressW],
            magFilter: textureFilterMap[this._options.magFilter],
            minFilter: textureFilterMap[this._options.minFilter],
            mipmapFilter: textureFilterMap[this._options.mipFilter],
            lodMinClamp: this._options.lodMin,
            lodMaxClamp: this._options.lodMax,
            compare: compareFuncMap[this._options.compare] || undefined,
            maxAnisotropy: this._options.maxAnisotropy
        });
        return !!this._object;
    }
    isSampler() {
        return true;
    }
}

class SamplerCache {
    _device;
    _samplers;
    constructor(device){
        this._device = device;
        this._samplers = {};
    }
    fetchSampler(options) {
        const hash = this.hash(options);
        let sampler = this._samplers[hash];
        if (!sampler) {
            sampler = this.createSampler(options);
            this._samplers[hash] = sampler;
        }
        return sampler;
    }
    hash(options) {
        const addressU = options.addressU ? String(options.addressU) : '';
        const addressV = options.addressV ? String(options.addressV) : '';
        const addressW = options.addressW ? String(options.addressW) : '';
        const magFilter = options.magFilter ? String(options.magFilter) : '';
        const minFilter = options.minFilter ? String(options.minFilter) : '';
        const mipFilter = options.mipFilter ? String(options.mipFilter) : '';
        const lodMin = options.lodMin ? String(options.lodMin) : '';
        const lodMax = options.lodMax ? String(options.lodMax) : '';
        const compare = options.compare ? String(options.compare) : '';
        const maxAnisotropy = options.maxAnisotropy ? String(options.maxAnisotropy) : '';
        return `${addressU}:${addressV}:${addressW}:${magFilter}:${minFilter}:${mipFilter}:${lodMin}:${lodMax}:${compare}:${maxAnisotropy}`;
    }
    createSampler(options) {
        return new WebGPUTextureSampler(this._device, options);
    }
}

class WebGPUClearQuad {
    static _clearPrograms = {};
    static _clearBindGroup = null;
    static _clearStateSet = null;
    static _defaultClearColor = new Vector4(0, 0, 0, 1);
    static drawClearQuad(renderPass, clearColor, clearDepth, clearStencil) {
        if (!this._clearBindGroup) {
            this.initClearQuad(renderPass);
        }
        const hash = renderPass.getFrameBufferInfo().clearHash;
        const program = this.getClearProgram(renderPass.getDevice(), hash);
        const bClearColor = !!clearColor;
        const bClearDepth = !(clearDepth === null || clearDepth === undefined);
        const bClearStencil = !(clearStencil === null || clearStencil === undefined);
        program.bindGroup.setValue('clearDepth', clearDepth ?? 1);
        program.bindGroup.setValue('clearColor', clearColor ?? this._defaultClearColor);
        this._clearStateSet.useDepthState().enableWrite(bClearDepth);
        this._clearStateSet.useColorState().setColorMask(bClearColor, bClearColor, bClearColor, bClearColor);
        this._clearStateSet.useStencilState().enable(bClearStencil).setReference(bClearStencil ? clearStencil : 0);
        renderPass.draw(program.program, null, this._clearStateSet, [
            program.bindGroup
        ], null, 'triangle-strip', 0, 4, 1);
    }
    static getClearProgram(device, hash) {
        let programInfo = this._clearPrograms[hash];
        if (!programInfo) {
            const colorAttachments = hash.split('');
            const program = device.buildRenderProgram({
                label: `ClearQuad-${hash}`,
                vertex (pb) {
                    this.clearDepth = pb.float().uniform(0);
                    this.coords = [
                        pb.vec2(-1, 1),
                        pb.vec2(1, 1),
                        pb.vec2(-1, -1),
                        pb.vec2(1, -1)
                    ];
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.coords.at(this.$builtins.vertexIndex), this.clearDepth, 1);
                    });
                },
                fragment (pb) {
                    this.clearColor = pb.vec4().uniform(0);
                    if (colorAttachments.length === 0) {
                        this.$outputs.outColor = pb.vec4();
                        pb.main(function() {
                            this.$outputs.outColor = this.clearColor;
                        });
                    } else {
                        for(let i = 0; i < colorAttachments.length; i++){
                            this.$outputs[`outColor${i}`] = colorAttachments[i] === 'f' ? pb.vec4() : colorAttachments[i] === 'i' ? pb.ivec4() : pb.uvec4();
                        }
                        pb.main(function() {
                            for(let i = 0; i < colorAttachments.length; i++){
                                this.$outputs[`outColor${i}`] = colorAttachments[i] === 'f' ? this.clearColor : colorAttachments[i] === 'i' ? pb.ivec4(this.clearColor) : pb.uvec4(this.clearColor);
                            }
                        });
                    }
                }
            });
            const bindGroup = device.createBindGroup(program.bindGroupLayouts[0]);
            programInfo = {
                program,
                bindGroup
            };
            this._clearPrograms[hash] = programInfo;
        }
        return programInfo;
    }
    static initClearQuad(renderPass) {
        this._clearStateSet = renderPass.getDevice().createRenderStateSet();
        this._clearStateSet.useDepthState().enableTest(false);
        this._clearStateSet.useRasterizerState().setCullMode('none');
        this._clearStateSet.useStencilState().enable(true).setFrontOp('replace', 'replace', 'replace').setBackOp('replace', 'replace', 'replace').setFrontCompareFunc('always').setBackCompareFunc('always');
    }
}
class WebGPUMipmapGenerator {
    static _frameBufferInfo = null;
    static _mipmapGenerationProgram = null;
    static _mipmapGenerationBindGroup = new WeakMap();
    static _mipmapGenerationStateSet = null;
    static generateMipmap(device, tex) {
        if (!this._mipmapGenerationProgram) {
            this.initMipmapGeneration(device);
        }
        const cmdEncoder = device.device.createCommandEncoder();
        const miplevels = tex.mipLevelCount;
        const numLayers = tex.isTextureCube() ? 6 : tex.isTexture2DArray() ? tex.depth : 1;
        let tmpTex = tex.object;
        if (!tex.isRenderable()) {
            tmpTex = device.gpuCreateTexture({
                size: {
                    width: tex.width,
                    height: tex.height,
                    depthOrArrayLayers: numLayers
                },
                format: tex.gpuFormat,
                mipLevelCount: tex.mipLevelCount,
                sampleCount: 1,
                dimension: '2d',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
            });
        }
        tex.setMipmapDirty(false);
        for(let face = 0; face < numLayers; face++){
            for(let level = 1; level < miplevels; level++){
                this.generateMiplevel(device, cmdEncoder, tex, tmpTex, tex.gpuFormat, tmpTex === tex.object ? level : level - 1, level, face);
            }
        }
        if (tmpTex !== tex.object) {
            let width = tex.width;
            let height = tex.height;
            for(let level = 1; level < miplevels; level++){
                cmdEncoder.copyTextureToTexture({
                    texture: tmpTex,
                    mipLevel: level - 1
                }, {
                    texture: tex.object,
                    mipLevel: level
                }, {
                    width: width,
                    height: height,
                    depthOrArrayLayers: numLayers
                });
                width = Math.ceil(width / 2);
                height = Math.ceil(height / 2);
            }
        }
        device.device.queue.submit([
            cmdEncoder.finish()
        ]);
        if (tmpTex !== tex.object) {
            tmpTex.destroy();
        }
    }
    static generateMipmapsForBindGroups(device, bindGroups) {
        for (const bindGroup of bindGroups){
            if (bindGroup) {
                for (const tex of bindGroup.textureList){
                    if (!tex.disposed && tex.isMipmapDirty()) {
                        WebGPUMipmapGenerator.generateMipmap(device, tex);
                    }
                }
            }
        }
    }
    static generateMiplevel(device, commandEncoder, srcTex, dstTex, format, dstLevel, srcLevel, face) {
        const renderPassEncoder = this.beginMipmapGenerationPass(commandEncoder, dstTex, format, dstLevel, face);
        renderPassEncoder.setBindGroup(0, this.getMipmapGenerationBindGroup(device, srcTex, srcLevel, face).bindGroup);
        const pipeline = device.pipelineCache.fetchRenderPipeline(this._mipmapGenerationProgram, null, this._mipmapGenerationStateSet, 'triangle-strip', this._frameBufferInfo);
        if (pipeline) {
            renderPassEncoder.setPipeline(pipeline);
            renderPassEncoder.draw(4, 1, 0);
        }
        renderPassEncoder.end();
    }
    static beginMipmapGenerationPass(encoder, texture, format, level, face) {
        const passDesc = {
            colorAttachments: [
                {
                    view: texture.createView({
                        dimension: '2d',
                        baseMipLevel: level || 0,
                        mipLevelCount: 1,
                        baseArrayLayer: face || 0,
                        arrayLayerCount: 1
                    }),
                    loadOp: 'clear',
                    clearValue: [
                        0,
                        0,
                        0,
                        0
                    ],
                    storeOp: 'store'
                }
            ]
        };
        this._frameBufferInfo = {
            colorFormats: [
                format
            ],
            depthFormat: null,
            sampleCount: 1,
            hash: null,
            clearHash: null
        };
        this._frameBufferInfo.hash = `${this._frameBufferInfo.colorFormats.join('-')}:${this._frameBufferInfo.depthFormat}:${this._frameBufferInfo.sampleCount}`;
        const renderPassEncoder = encoder.beginRenderPass(passDesc);
        renderPassEncoder.insertDebugMarker('MipmapGeneration');
        return renderPassEncoder;
    }
    static getMipmapGenerationBindGroup(device, texture, level, face) {
        let faceGroups = this._mipmapGenerationBindGroup.get(texture);
        if (!faceGroups) {
            faceGroups = [];
            this._mipmapGenerationBindGroup.set(texture, faceGroups);
        }
        let levelGroups = faceGroups[face];
        if (!levelGroups) {
            levelGroups = [];
            faceGroups[face] = levelGroups;
        }
        let levelGroup = levelGroups[level];
        if (!levelGroup) {
            levelGroup = device.createBindGroup(this._mipmapGenerationProgram.bindGroupLayouts[0]);
            levelGroup.setTextureView('tex', texture, level - 1, face, 1);
            levelGroups[level] = levelGroup;
        }
        return levelGroup;
    }
    static initMipmapGeneration(device) {
        this._mipmapGenerationProgram = device.buildRenderProgram({
            label: 'MipmapGeneration',
            vertex (pb) {
                this.$outputs.outUV = pb.vec2();
                this.coords = [
                    pb.vec2(-1, 1),
                    pb.vec2(1, 1),
                    pb.vec2(-1, -1),
                    pb.vec2(1, -1)
                ];
                this.uv = [
                    pb.vec2(0, 0),
                    pb.vec2(1, 0),
                    pb.vec2(0, 1),
                    pb.vec2(1, 1)
                ];
                pb.main(function() {
                    this.$builtins.position = pb.vec4(this.coords.at(this.$builtins.vertexIndex), 0, 1);
                    this.$outputs.outUV = this.uv.at(this.$builtins.vertexIndex);
                });
            },
            fragment (pb) {
                this.$outputs.color = pb.vec4();
                this.tex = pb.tex2D().uniform(0);
                pb.main(function() {
                    this.$outputs.color = pb.textureSampleLevel(this.tex, this.$inputs.outUV, 0);
                });
            }
        });
        this._mipmapGenerationStateSet = device.createRenderStateSet();
        this._mipmapGenerationStateSet.useDepthState().enableTest(false).enableWrite(false);
        this._mipmapGenerationStateSet.useRasterizerState().setCullMode('none');
    }
}

const VALIDATION_NEED_NEW_PASS$1 = 1 << 0;
const VALIDATION_NEED_GENERATE_MIPMAP$1 = 1 << 1;
const VALIDATION_FAILED$1 = 1 << 2;
const typeU16 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
class WebGPURenderPass {
    _device;
    _frameBuffer;
    _bufferUploads;
    _textureUploads;
    _bufferUploadsNext;
    _textureUploadsNext;
    _renderCommandEncoder;
    _renderPassEncoder;
    _fbBindFlag;
    _currentViewport;
    _currentScissor;
    _frameBufferInfo;
    constructor(device){
        this._device = device;
        this._bufferUploads = new Set();
        this._textureUploads = new Set();
        this._bufferUploadsNext = new Set();
        this._textureUploadsNext = new Set();
        this._renderCommandEncoder = this._device.device.createCommandEncoder();
        this._renderPassEncoder = null;
        this._frameBuffer = null;
        this._fbBindFlag = null;
        this._currentViewport = null;
        this._currentScissor = null;
        this._frameBufferInfo = null;
    }
    get active() {
        return !!this._renderPassEncoder;
    }
    isBufferUploading(buffer) {
        return !!this._bufferUploads.has(buffer);
    }
    isTextureUploading(tex) {
        return !!this._textureUploads.has(tex);
    }
    setFramebuffer(fb) {
        if (this._frameBuffer !== fb) {
            this.end();
            this._frameBuffer = fb;
            this.setViewport(null);
            this.setScissor(null);
        }
    }
    getFramebuffer() {
        return this._frameBuffer;
    }
    setViewport(vp) {
        if (!vp || !Array.isArray(vp) && vp.default) {
            this._currentViewport = {
                x: 0,
                y: 0,
                width: this._device.deviceToScreen(this._device.drawingBufferWidth),
                height: this._device.deviceToScreen(this._device.drawingBufferHeight),
                default: true
            };
        } else {
            if (Array.isArray(vp)) {
                this._currentViewport = {
                    x: vp[0],
                    y: vp[1],
                    width: vp[2],
                    height: vp[3],
                    default: false
                };
            } else {
                this._currentViewport = Object.assign({
                    default: false
                }, vp);
            }
        }
        const vx = this._device.screenToDevice(this._currentViewport.x);
        const vy = this._device.screenToDevice(this._currentViewport.y);
        const vw = this._device.screenToDevice(this._currentViewport.width);
        const vh = this._device.screenToDevice(this._currentViewport.height);
        if (vx < 0 || vy < 0 || vw > this._device.drawingBufferWidth || vh > this._device.drawingBufferHeight) {
            console.log(`** VIEWPORT ERROR **: (${vx}, ${vy}, ${vw}, ${vh}) => (0, 0, ${this._device.drawingBufferWidth}, ${this._device.drawingBufferHeight})`);
        }
        if (this._renderPassEncoder) {
            this._renderPassEncoder.setViewport(vx, this._device.drawingBufferHeight - vy - vh, vw, vh, 0, 1);
        }
    }
    getViewport() {
        return Object.assign({}, this._currentViewport);
    }
    setScissor(scissor) {
        const backBufferWidth = this._device.deviceToScreen(this._device.drawingBufferWidth);
        const backBufferHeight = this._device.deviceToScreen(this._device.drawingBufferHeight);
        if (scissor === null || scissor === undefined || !Array.isArray(scissor) && scissor.default) {
            this._currentScissor = {
                x: 0,
                y: 0,
                width: backBufferWidth,
                height: backBufferHeight,
                default: true
            };
        } else {
            if (Array.isArray(scissor)) {
                this._currentScissor = {
                    x: scissor[0],
                    y: scissor[1],
                    width: scissor[2],
                    height: scissor[3],
                    default: false
                };
            } else {
                this._currentScissor = Object.assign({
                    default: false
                }, scissor);
            }
        }
        let vx = this._device.screenToDevice(this._currentScissor.x);
        let vy = this._device.screenToDevice(this._currentScissor.y);
        let vw = this._device.screenToDevice(this._currentScissor.width);
        let vh = this._device.screenToDevice(this._currentScissor.height);
        // Clip scissor region to screen
        if (vx < 0) {
            vw += vx;
            vx = 0;
        }
        if (vy < 0) {
            vh += vy;
            vy = 0;
        }
        vw = Math.min(this._device.screenToDevice(backBufferWidth) - vx, vw);
        vh = Math.min(this._device.screenToDevice(backBufferHeight) - vy, vh);
        if (vw < 0 || vh < 0) {
            vx = 0;
            vy = 0;
            vw = 0;
            vh = 0;
        }
        if (this._renderPassEncoder) {
            this._renderPassEncoder.setScissorRect(vx, this._device.drawingBufferHeight - vy - vh, vw, vh);
        }
    }
    getScissor() {
        return Object.assign({}, this._currentScissor);
    }
    draw(program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances) {
        const validation = this.validateDraw(program, vertexData, bindGroups);
        if (validation & VALIDATION_FAILED$1) {
            return;
        }
        if (validation & VALIDATION_NEED_NEW_PASS$1 || validation & VALIDATION_NEED_GENERATE_MIPMAP$1) {
            this.end();
        }
        if (validation & VALIDATION_NEED_GENERATE_MIPMAP$1) {
            WebGPUMipmapGenerator.generateMipmapsForBindGroups(this._device, bindGroups);
        }
        if (!this.active) {
            this.begin();
        }
        this.drawInternal(this._renderPassEncoder, program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances);
    }
    clear(color, depth, stencil) {
        if (!this._currentScissor) {
            this.end();
            this.begin(color, depth, stencil);
        } else {
            if (!this._renderPassEncoder) {
                this.begin();
            }
            this._renderPassEncoder.insertDebugMarker('clear');
            WebGPUClearQuad.drawClearQuad(this, color, depth, stencil);
            this._renderPassEncoder.insertDebugMarker('end clear');
        }
    }
    getDevice() {
        return this._device;
    }
    getFrameBufferInfo() {
        return this._frameBufferInfo;
    }
    begin(color, depth, stencil) {
        if (this.active) {
            console.error('WebGPURenderPass.begin() failed: begin() has already been called');
            return;
        }
        this._renderCommandEncoder = this._device.device.createCommandEncoder();
        if (!this._frameBuffer) {
            const fmt = textureFormatInvMap[this._device.backbufferFormat];
            this._frameBufferInfo = {
                colorFormats: [
                    this._device.backbufferFormat
                ],
                depthFormat: this._device.backbufferDepthFormat,
                sampleCount: this._device.sampleCount,
                hash: `${this._device.backbufferFormat}:${this._device.backbufferDepthFormat}:${this._device.sampleCount}`,
                clearHash: isIntegerTextureFormat(fmt) ? isSignedTextureFormat(fmt) ? 'i' : 'u' : 'f'
            };
            const mainPassDesc = this._device.defaultRenderPassDesc;
            const colorAttachmentDesc = this._device.defaultRenderPassDesc.colorAttachments[0];
            if (this._frameBufferInfo.sampleCount > 1) {
                colorAttachmentDesc.resolveTarget = this._device.context.getCurrentTexture().createView();
            } else {
                colorAttachmentDesc.view = this._device.context.getCurrentTexture().createView();
            }
            colorAttachmentDesc.loadOp = color ? 'clear' : 'load';
            colorAttachmentDesc.clearValue = color;
            const depthAttachmentDesc = this._device.defaultRenderPassDesc.depthStencilAttachment;
            depthAttachmentDesc.depthLoadOp = typeof depth === 'number' ? 'clear' : 'load';
            depthAttachmentDesc.depthClearValue = depth;
            depthAttachmentDesc.stencilLoadOp = typeof stencil === 'number' ? 'clear' : 'load';
            depthAttachmentDesc.stencilClearValue = stencil;
            this._renderPassEncoder = this._renderCommandEncoder.beginRenderPass(mainPassDesc);
        } else {
            const colorAttachmentTextures = this._frameBuffer.getColorAttachments();
            const depthAttachmentTexture = this._frameBuffer.getDepthAttachment();
            let depthTextureView;
            if (depthAttachmentTexture) {
                depthAttachmentTexture._markAsCurrentFB(true);
                const attachment = this._frameBuffer.getOptions().depthAttachment;
                const layer = depthAttachmentTexture.isTexture2DArray() || depthAttachmentTexture.isTexture3D() ? attachment.layer : depthAttachmentTexture.isTextureCube() ? attachment.face : 0;
                depthTextureView = depthAttachmentTexture.getView(0, layer ?? 0, 1);
            }
            this._frameBufferInfo = {
                colorFormats: colorAttachmentTextures.map((val)=>val.gpuFormat),
                depthFormat: depthAttachmentTexture?.gpuFormat,
                sampleCount: this._frameBuffer.getOptions().sampleCount,
                hash: null,
                clearHash: colorAttachmentTextures.map((val)=>{
                    const fmt = textureFormatInvMap[val.gpuFormat];
                    return isIntegerTextureFormat(fmt) ? isSignedTextureFormat(fmt) ? 'i' : 'u' : 'f';
                }).join('')
            };
            this._frameBufferInfo.hash = `${this._frameBufferInfo.colorFormats.join('-')}:${this._frameBufferInfo.depthFormat}:${this._frameBufferInfo.sampleCount}`;
            this._fbBindFlag = this._frameBuffer.bindFlag;
            const passDesc = {
                label: `customRenderPass:${this._frameBufferInfo.hash}`,
                colorAttachments: this._frameBuffer.getOptions().colorAttachments?.map((attachment, index)=>{
                    const tex = attachment.texture;
                    if (tex) {
                        tex._markAsCurrentFB(true);
                        const layer = tex.isTexture2DArray() || tex.isTexture3D() ? attachment.layer : tex.isTextureCube() ? attachment.face : 0;
                        if (this._frameBuffer.getOptions().sampleCount === 1) {
                            return {
                                view: tex.getView(attachment.level ?? 0, layer ?? 0, 1),
                                loadOp: color ? 'clear' : 'load',
                                clearValue: color,
                                storeOp: 'store'
                            };
                        } else {
                            const msaaTexture = this._frameBuffer.getMSAAColorAttacments()[index];
                            const msaaView = this._device.gpuCreateTextureView(msaaTexture, {
                                dimension: '2d',
                                baseMipLevel: attachment.level ?? 0,
                                mipLevelCount: 1,
                                baseArrayLayer: 0,
                                arrayLayerCount: 1
                            });
                            return {
                                view: msaaView,
                                resolveTarget: tex.getView(attachment.level ?? 0, layer ?? 0, 1),
                                loadOp: color ? 'clear' : 'load',
                                clearValue: color,
                                storeOp: 'store'
                            };
                        }
                    } else {
                        return null;
                    }
                }) ?? [],
                depthStencilAttachment: depthAttachmentTexture ? this._frameBuffer.getOptions().sampleCount === 1 ? {
                    view: depthTextureView,
                    depthLoadOp: typeof depth === 'number' ? 'clear' : 'load',
                    depthClearValue: depth,
                    depthStoreOp: 'store',
                    stencilLoadOp: hasStencilChannel(depthAttachmentTexture.format) ? typeof stencil === 'number' ? 'clear' : 'load' : undefined,
                    stencilClearValue: stencil,
                    stencilStoreOp: hasStencilChannel(depthAttachmentTexture.format) ? 'store' : undefined
                } : {
                    view: this._frameBuffer.getMSAADepthAttachment().createView(),
                    depthLoadOp: typeof depth === 'number' ? 'clear' : 'load',
                    depthClearValue: depth,
                    depthStoreOp: 'store',
                    stencilLoadOp: hasStencilChannel(depthAttachmentTexture.format) ? typeof stencil === 'number' ? 'clear' : 'load' : undefined,
                    stencilClearValue: stencil,
                    stencilStoreOp: hasStencilChannel(depthAttachmentTexture.format) ? 'store' : undefined
                } : undefined
            };
            this._renderPassEncoder = this._renderCommandEncoder.beginRenderPass(passDesc);
        }
        this.setViewport(this._currentViewport);
        this.setScissor(this._currentScissor);
    }
    end() {
        const commands = [];
        // upload the resources needed for this rendering pass
        if (this._bufferUploads.size > 0 || this._textureUploads.size > 0) {
            const uploadCommandEncoder = this._device.device.createCommandEncoder();
            this._bufferUploads.forEach((buffer)=>buffer.beginSyncChanges(uploadCommandEncoder));
            this._textureUploads.forEach((tex)=>tex.beginSyncChanges(uploadCommandEncoder));
            commands.push(uploadCommandEncoder.finish());
        }
        // finish current render pass command
        if (this._renderPassEncoder) {
            this._renderPassEncoder.end();
            this._renderPassEncoder = null;
        }
        // render commands
        if (this._renderCommandEncoder) {
            commands.push(this._renderCommandEncoder.finish());
            this._renderCommandEncoder = null;
        }
        // submit to GPU
        if (commands.length > 0) {
            this._device.device.queue.submit(commands);
        }
        // free up resource upload buffers
        this._bufferUploads.forEach((buffer)=>buffer.endSyncChanges());
        this._textureUploads.forEach((tex)=>tex.endSyncChanges());
        this._bufferUploads.clear();
        this._textureUploads.clear();
        // next pass uploading becomes current pass uploading
        [this._bufferUploads, this._bufferUploadsNext] = [
            this._bufferUploadsNext,
            this._bufferUploads
        ];
        [this._textureUploads, this._textureUploadsNext] = [
            this._textureUploadsNext,
            this._textureUploads
        ];
        // unmark render target flags and generate render target mipmaps if needed
        if (this._frameBuffer) {
            const options = this._frameBuffer.getOptions();
            if (options.colorAttachments) {
                for (const attachment of options.colorAttachments){
                    attachment.texture._markAsCurrentFB(false);
                    if (attachment.generateMipmaps && attachment.texture.mipLevelCount > 1) {
                        attachment.texture.generateMipmaps();
                    }
                }
            }
            (options.depthAttachment?.texture)?._markAsCurrentFB(false);
        }
    }
    drawInternal(renderPassEncoder, program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances) {
        if (this.setBindGroupsForRender(renderPassEncoder, program, vertexData, bindGroups, bindGroupOffsets)) {
            const pipeline = this._device.pipelineCache.fetchRenderPipeline(program, vertexData, stateSet, primitiveType, this._frameBufferInfo);
            if (pipeline) {
                renderPassEncoder.setPipeline(pipeline);
                const stencilState = stateSet?.stencilState;
                if (stencilState) {
                    renderPassEncoder.setStencilReference(stencilState.ref);
                }
                if (vertexData) {
                    const vertexBuffers = vertexData.getLayouts(program.vertexAttributes)?.buffers;
                    vertexBuffers?.forEach((val, index)=>{
                        renderPassEncoder.setVertexBuffer(index, val.buffer.object, val.drawOffset);
                    });
                    const indexBuffer = vertexData.getIndexBuffer();
                    if (indexBuffer) {
                        renderPassEncoder.setIndexBuffer(indexBuffer.object, indexBuffer.indexType === typeU16 ? 'uint16' : 'uint32');
                        renderPassEncoder.drawIndexed(count, numInstances, first);
                    } else {
                        renderPassEncoder.draw(count, numInstances, first);
                    }
                } else {
                    renderPassEncoder.draw(count, numInstances, first);
                }
            }
        }
    }
    validateDraw(program, vertexData, bindGroups) {
        let validation = 0;
        const bufferUploads = [];
        const textureUploads = [];
        if (bindGroups) {
            for(let i = 0; i < program.bindGroupLayouts.length; i++){
                const bindGroup = bindGroups[i];
                if (bindGroup) {
                    if (bindGroup.bindGroup) {
                        for (const ubo of bindGroup.bufferList){
                            if (ubo.disposed) {
                                validation |= VALIDATION_FAILED$1;
                            }
                            if (ubo.getPendingUploads().length > 0) {
                                bufferUploads.push(ubo);
                            }
                        }
                        for (const tex of bindGroup.textureList){
                            if (tex.disposed) {
                                validation |= VALIDATION_FAILED$1;
                            }
                            if (tex._isMarkedAsCurrentFB()) {
                                console.error('bind resource texture can not be current render target');
                                validation |= VALIDATION_FAILED$1;
                            }
                            if (tex.isMipmapDirty()) {
                                validation |= VALIDATION_NEED_GENERATE_MIPMAP$1;
                            }
                            if (tex.getPendingUploads().length > 0) {
                                if (tex.isMipmapDirty()) {
                                    this._textureUploads.add(tex);
                                } else {
                                    textureUploads.push(tex);
                                }
                            }
                        }
                    }
                } else {
                    console.error(`Missing bind group (${i}) when drawing with program '${program.name}'`);
                    return VALIDATION_FAILED$1;
                }
            }
        }
        const vertexBuffers = vertexData?.getLayouts(program.vertexAttributes)?.buffers;
        if (vertexBuffers) {
            for (const buffer of vertexBuffers){
                if (buffer.buffer.getPendingUploads().length > 0) {
                    bufferUploads.push(buffer.buffer);
                }
            }
        }
        const indexBuffer = vertexData?.getIndexBuffer();
        if (indexBuffer?.getPendingUploads().length > 0) {
            bufferUploads.push(indexBuffer);
        }
        if (this._frameBuffer && this._frameBuffer.bindFlag !== this._fbBindFlag) {
            validation |= VALIDATION_NEED_NEW_PASS$1;
        }
        const needNewPass = validation & VALIDATION_NEED_NEW_PASS$1 || validation & VALIDATION_NEED_GENERATE_MIPMAP$1;
        if (bufferUploads.length > 0) {
            const bu = needNewPass ? this._bufferUploadsNext : this._bufferUploads;
            for (const buffer of bufferUploads){
                bu.add(buffer);
            }
        }
        if (textureUploads.length > 0) {
            const tu = needNewPass ? this._textureUploadsNext : this._textureUploads;
            for (const tex of textureUploads){
                tu.add(tex);
            }
        }
        return validation;
    }
    setBindGroupsForRender(renderPassEncoder, program, vertexData, bindGroups, bindGroupOffsets) {
        if (bindGroups) {
            for(let i = 0; i < 4; i++){
                if (i < program.bindGroupLayouts.length) {
                    bindGroups[i].updateVideoTextures();
                    const bindGroup = bindGroups[i].bindGroup;
                    if (!bindGroup) {
                        return false;
                    }
                    renderPassEncoder.setBindGroup(i, bindGroup, bindGroupOffsets?.[i] || undefined);
                } else {
                    renderPassEncoder.setBindGroup(i, null);
                }
            }
        }
        return true;
    }
}

const VALIDATION_NEED_NEW_PASS = 1 << 0;
const VALIDATION_NEED_GENERATE_MIPMAP = 1 << 1;
const VALIDATION_FAILED = 1 << 2;
class WebGPUComputePass {
    _device;
    _bufferUploads;
    _textureUploads;
    _uploadCommandEncoder;
    _computeCommandEncoder;
    _computePassEncoder;
    constructor(device, frameBuffer){
        this._device = device;
        this._bufferUploads = new Set();
        this._textureUploads = new Set();
        this._uploadCommandEncoder = this._device.device.createCommandEncoder();
        this._computeCommandEncoder = this._device.device.createCommandEncoder();
        this._computePassEncoder = null;
    }
    get active() {
        return !!this._computePassEncoder;
    }
    isBufferUploading(buffer) {
        return !!this._bufferUploads.has(buffer);
    }
    isTextureUploading(tex) {
        return !!this._textureUploads.has(tex);
    }
    compute(program, bindGroups, bindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ) {
        const validation = this.validateCompute(program, bindGroups);
        if (validation & VALIDATION_FAILED) {
            return;
        }
        if (validation & VALIDATION_NEED_NEW_PASS || validation & VALIDATION_NEED_GENERATE_MIPMAP) {
            if (this._computePassEncoder) {
                this.end();
            }
        }
        if (validation & VALIDATION_NEED_GENERATE_MIPMAP) {
            WebGPUMipmapGenerator.generateMipmapsForBindGroups(this._device, bindGroups);
        }
        if (!this._computePassEncoder) {
            this.begin();
        }
        this.setBindGroupsForCompute(this._computePassEncoder, program, bindGroups, bindGroupOffsets);
        const pipeline = this._device.pipelineCache.fetchComputePipeline(program);
        if (pipeline) {
            this._computePassEncoder.setPipeline(pipeline);
            this._computePassEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
        }
    }
    setBindGroupsForCompute(computePassEncoder, program, bindGroups, bindGroupOffsets) {
        if (bindGroups) {
            for(let i = 0; i < 4; i++){
                if (i < program.bindGroupLayouts.length) {
                    const bindGroup = bindGroups[i].bindGroup;
                    if (!bindGroup) {
                        return false;
                    }
                    computePassEncoder.setBindGroup(i, bindGroup, bindGroupOffsets?.[i] || undefined);
                } else {
                    computePassEncoder.setBindGroup(i, null);
                }
            }
        }
        return true;
    }
    begin() {
        if (this.active) {
            console.error('WebGPUComputePass.begin() failed: WebGPUComputePass.begin() has already been called');
            return;
        }
        this._uploadCommandEncoder = this._device.device.createCommandEncoder();
        this._computeCommandEncoder = this._device.device.createCommandEncoder();
        this._computePassEncoder = this._computeCommandEncoder.beginComputePass();
    }
    end() {
        if (this.active) {
            this._computePassEncoder.end();
            this._computePassEncoder = null;
            this._bufferUploads.forEach((buffer)=>buffer.beginSyncChanges(this._uploadCommandEncoder));
            this._textureUploads.forEach((tex)=>tex.beginSyncChanges(this._uploadCommandEncoder));
            this._device.device.queue.submit([
                this._uploadCommandEncoder.finish(),
                this._computeCommandEncoder.finish()
            ]);
            this._bufferUploads.forEach((buffer)=>buffer.endSyncChanges());
            this._textureUploads.forEach((tex)=>tex.endSyncChanges());
            this._bufferUploads.clear();
            this._textureUploads.clear();
            this._uploadCommandEncoder = null;
            this._computeCommandEncoder = null;
        }
    }
    validateCompute(program, bindGroups) {
        let validation = 0;
        if (bindGroups) {
            for(let i = 0; i < program.bindGroupLayouts.length; i++){
                const bindGroup = bindGroups[i];
                if (bindGroup) {
                    if (bindGroup.bindGroup) {
                        for (const ubo of bindGroup.bufferList){
                            if (ubo.disposed) {
                                validation |= VALIDATION_FAILED;
                            }
                            if (ubo.getPendingUploads().length > 0) {
                                this._bufferUploads.add(ubo);
                            }
                        }
                        for (const tex of bindGroup.textureList){
                            if (tex.disposed) {
                                validation |= VALIDATION_FAILED;
                            }
                            if (tex.isMipmapDirty()) {
                                validation |= VALIDATION_NEED_GENERATE_MIPMAP;
                            }
                            if (tex.getPendingUploads().length > 0) {
                                this._textureUploads.add(tex);
                            }
                        }
                    }
                } else {
                    console.error(`Missing bind group (${i}) when compute with program '${program.name}'`);
                    return VALIDATION_FAILED;
                }
            }
        }
        return validation;
    }
}

class CommandQueueImmediate {
    _renderPass;
    _computePass;
    constructor(device){
        this._renderPass = new WebGPURenderPass(device);
        this._computePass = new WebGPUComputePass(device);
    }
    get currentPass() {
        return this._renderPass.active ? this._renderPass : this._computePass.active ? this._computePass : null;
    }
    beginFrame() {}
    endFrame() {
        this._renderPass.end();
        this._computePass.end();
    }
    flush() {
        this._renderPass.end();
        this._computePass.end();
    }
    setFramebuffer(fb) {
        this._renderPass.setFramebuffer(fb);
    }
    getFramebuffer() {
        return this._renderPass.getFramebuffer();
    }
    getFramebufferInfo() {
        return this._renderPass.getFrameBufferInfo();
    }
    compute(program, bindGroups, bindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ) {
        this._renderPass.end();
        this._computePass.compute(program, bindGroups, bindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ);
    }
    draw(program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances) {
        this._computePass.end();
        this._renderPass.draw(program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances);
    }
    setViewport(vp) {
        this._renderPass.setViewport(vp);
    }
    getViewport() {
        return this._renderPass.getViewport();
    }
    setScissor(scissor) {
        this._renderPass.setScissor(scissor);
    }
    getScissor() {
        return this._renderPass.getScissor();
    }
    clear(color, depth, stencil) {
        this._renderPass.clear(color, depth, stencil);
    }
    isBufferUploading(buffer) {
        return this._renderPass.isBufferUploading(buffer) || this._computePass.isBufferUploading(buffer);
    }
    isTextureUploading(tex) {
        return this._renderPass.isTextureUploading(tex) || this._computePass.isTextureUploading(tex);
    }
}

class WebGPUDevice extends BaseDevice {
    _context;
    _dpr;
    _device;
    _adapter;
    _deviceCaps;
    _reverseWindingOrder;
    _canRender;
    _backBufferFormat;
    _depthFormat;
    _defaultMSAAColorTexture;
    _defaultMSAAColorTextureView;
    _defaultDepthTexture;
    _defaultDepthTextureView;
    _pipelineCache;
    _bindGroupCache;
    _vertexLayoutCache;
    _samplerCache;
    _currentProgram;
    _currentVertexData;
    _currentStateSet;
    _currentBindGroups;
    _currentBindGroupOffsets;
    _commandQueue;
    _gpuObjectHashCounter;
    _gpuObjectHasher;
    _defaultRenderPassDesc;
    _sampleCount;
    constructor(backend, cvs, options){
        super(cvs, backend);
        this._dpr = Math.max(1, Math.floor(options?.dpr ?? window.devicePixelRatio));
        this._device = null;
        this._adapter = null;
        this._context = null;
        this._reverseWindingOrder = false;
        this._defaultMSAAColorTexture = null;
        this._defaultMSAAColorTextureView = null;
        this._defaultDepthTexture = null;
        this._defaultDepthTextureView = null;
        this._pipelineCache = null;
        this._bindGroupCache = null;
        this._vertexLayoutCache = null;
        this._currentProgram = null;
        this._currentVertexData = null;
        this._currentStateSet = null;
        this._currentBindGroups = [];
        this._currentBindGroupOffsets = [];
        this._defaultRenderPassDesc = null;
        this._sampleCount = options?.msaa ? 4 : 1;
        this._deviceCaps = null;
        this._gpuObjectHasher = new WeakMap();
        this._gpuObjectHashCounter = 1;
        this._samplerCache = new SamplerCache(this);
    }
    get context() {
        return this._context;
    }
    getFrameBufferSampleCount() {
        return this.getFramebuffer()?.getSampleCount() ?? this._sampleCount;
    }
    get device() {
        return this._device;
    }
    get adapter() {
        return this._adapter;
    }
    get drawingBufferWidth() {
        return this.getDrawingBufferWidth();
    }
    get drawingBufferHeight() {
        return this.getDrawingBufferHeight();
    }
    get clientWidth() {
        return this.canvas.clientWidth;
    }
    get clientHeight() {
        return this.canvas.clientHeight;
    }
    get pipelineCache() {
        return this._pipelineCache;
    }
    get backbufferFormat() {
        return this._backBufferFormat;
    }
    get backbufferDepthFormat() {
        return this._depthFormat;
    }
    get defaultDepthTexture() {
        return this._defaultDepthTexture;
    }
    get defaultDepthTextureView() {
        return this._defaultDepthTextureView;
    }
    get defaultMSAAColorTextureView() {
        return this._defaultMSAAColorTextureView;
    }
    get defaultRenderPassDesc() {
        return this._defaultRenderPassDesc;
    }
    get sampleCount() {
        return this._sampleCount;
    }
    get currentPass() {
        return this._commandQueue.currentPass;
    }
    getScale() {
        return this._dpr;
    }
    isContextLost() {
        return false;
    }
    getDeviceCaps() {
        return this._deviceCaps;
    }
    getDrawingBufferWidth() {
        return this.getFramebuffer()?.getWidth() || this.canvas.width;
    }
    getDrawingBufferHeight() {
        return this.getFramebuffer()?.getHeight() || this.canvas.height;
    }
    getBackBufferWidth() {
        return this.canvas.width;
    }
    getBackBufferHeight() {
        return this.canvas.height;
    }
    async initContext() {
        if (!navigator.gpu) {
            throw new Error('No browser support for WebGPU');
        }
        this._adapter = await navigator.gpu.requestAdapter();
        if (!this._adapter) {
            throw new Error('WebGPU: requestAdapter() failed');
        }
        if (this._adapter.isFallbackAdapter) {
            console.warn('using a fallback adapter');
        }
        this._device = await this._adapter.requestDevice({
            requiredFeatures: [
                ...this._adapter.features
            ]
        });
        console.log('WebGPU device features:');
        for (const feature of this._device.features){
            console.log(` - ${feature}`);
        }
        this.device.lost.then((info)=>{
            console.error(`WebGPU device was lost: ${info.message}`);
            this._canRender = false;
        });
        this._context = this.canvas.getContext('webgpu') || null;
        if (!this._context) {
            this._canRender = false;
            throw new Error('WebGPU: getContext() failed');
        }
        this.canvas.width = this.canvas.clientWidth;
        this.canvas.height = this.canvas.clientHeight;
        this._deviceCaps = {
            textureCaps: new WebGPUTextureCaps(this),
            framebufferCaps: new WebGPUFramebufferCaps(this),
            miscCaps: new WebGPUMiscCaps(this),
            shaderCaps: new WebGPUShaderCaps(this)
        };
        this.configure();
        this._pipelineCache = new PipelineCache(this);
        this._bindGroupCache = new BindGroupCache(this);
        this._vertexLayoutCache = new VertexLayoutCache();
        this._commandQueue = new CommandQueueImmediate(this);
        this._canRender = true;
        this.setViewport(null);
        this.setScissor(null);
        this.on('resize', (evt)=>{
            const width = Math.max(1, Math.round(this.canvas.clientWidth * this._dpr));
            const height = Math.max(1, Math.round(this.canvas.clientHeight * this._dpr));
            if (width !== this.canvas.width || height !== this.canvas.height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this.createDefaultRenderAttachments();
                this.setViewport(null);
                this.setScissor(null);
            }
        });
        this.dispatchEvent(new DeviceResizeEvent(this.canvas.clientWidth, this.canvas.clientHeight));
    }
    clearFrameBuffer(clearColor, clearDepth, clearStencil) {
        this._commandQueue.clear(clearColor, clearDepth, clearStencil);
    }
    // factory
    createGPUTimer() {
        // throw new Error('not implemented');
        return null;
    }
    createRenderStateSet() {
        return new WebGPURenderStateSet(this);
    }
    createSampler(options) {
        return this.fetchSampler(options);
    }
    createTextureFromMipmapData(data, sRGB, options) {
        if (!data) {
            console.error(`Device.createTextureFromMipmapData() failed: invalid data`);
            return null;
        }
        if (data.isCubemap) {
            const tex = new WebGPUTextureCube(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        } else if (data.isVolume) {
            const tex = new WebGPUTexture3D(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else if (data.isArray) {
            const tex = new WebGPUTexture2DArray(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else {
            const tex = new WebGPUTexture2D(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        }
    }
    createTexture2D(format, width, height, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2D() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createEmpty(format, width, height, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromMipmapData() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromImage(element, sRGB, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromImage() failed: options.texture must be 2d texture');
            return null;
        }
        tex.loadFromElement(element, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArray(format, width, height, depth, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArray() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromMipmapData(data, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArrayFromMipmapData() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createWithMipmapData(data, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromImages(elements, sRGB, options) {
        if (!elements || elements.length === 0) {
            console.error('createTexture2DArrayFromImages() failed: Invalid image elements');
            return null;
        }
        let width = 0;
        let height = 0;
        for (const element of elements){
            if (width === 0 || height === 0) {
                width = element.width;
                height = element.height;
            } else if (width !== element.width || height !== element.height) {
                console.error('createTexture2DArrayFromImages() failed: Image elements must have the same size');
                return null;
            }
        }
        if (options?.texture && !options.texture.isTexture2DArray()) {
            console.error('createTexture2DArrayFromImages() failed: options.texture must be 2d array texture');
            return null;
        }
        let tex = options?.texture;
        if (tex) {
            if (tex.depth !== elements.length) {
                console.error('createTexture2DArrayFromImages() failed: Layer count of options.texture not match the given image elements');
                return null;
            }
            if (tex.width !== width || tex.height !== height) {
                console.error('createTexture2DArrayFromImages() failed: Size of options.texture not match the given image elements');
                return null;
            }
        } else {
            tex = this.createTexture2DArray(sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm', width, height, elements.length, options);
            for(let i = 0; i < elements.length; i++){
                tex.updateFromElement(elements[i], 0, 0, i, 0, 0, width, height);
            }
        }
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture3D(format, width, height, depth, options) {
        const tex = (options?.texture) ?? new WebGPUTexture3D(this);
        if (!tex.isTexture3D()) {
            console.error('createTexture3D() failed: options.texture must be 3d texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTexture(format, size, options) {
        const tex = (options?.texture) ?? new WebGPUTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTexture() failed: options.texture must be cube texture');
            return null;
        }
        tex.createEmpty(format, size, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTextureFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGPUTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTextureFromMipmapData() failed: options.texture must be cube texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTextureVideo(el, samplerOptions) {
        const tex = new WebGPUTextureVideo(this, el);
        tex.samplerOptions = samplerOptions ?? null;
        return tex;
    }
    createGPUProgram(params) {
        return new WebGPUProgram(this, params);
    }
    createBindGroup(layout) {
        return new WebGPUBindGroup(this, layout);
    }
    createBuffer(sizeInBytes, options) {
        return new WebGPUBuffer(this, this.parseBufferOptions(options), sizeInBytes);
    }
    createIndexBuffer(data, options) {
        return new WebGPUIndexBuffer(this, data, this.parseBufferOptions(options, 'index'));
    }
    createStructuredBuffer(structureType, options, data) {
        return new WebGPUStructuredBuffer(this, structureType, this.parseBufferOptions(options), data);
    }
    createVertexLayout(options) {
        return new WebGPUVertexLayout(this, options);
    }
    createFrameBuffer(colorAttachments, depthAttachement, options) {
        return new WebGPUFrameBuffer(this, colorAttachments, depthAttachement, options);
    }
    setBindGroup(index, bindGroup, dynamicOffsets) {
        this._currentBindGroups[index] = bindGroup;
        this._currentBindGroupOffsets[index] = dynamicOffsets || null;
    }
    getBindGroup(index) {
        return [
            this._currentBindGroups[index],
            this._currentBindGroupOffsets[index]
        ];
    }
    // render related
    setViewport(vp) {
        this._commandQueue.setViewport(vp);
    }
    getViewport() {
        return this._commandQueue.getViewport();
    }
    setScissor(scissor) {
        this._commandQueue.setScissor(scissor);
    }
    getScissor() {
        return this._commandQueue.getScissor();
    }
    setProgram(program) {
        this._currentProgram = program;
    }
    getProgram() {
        return this._currentProgram;
    }
    setVertexLayout(vertexData) {
        this._currentVertexData = vertexData;
    }
    getVertexLayout() {
        return this._currentVertexData;
    }
    setRenderStates(stateSet) {
        this._currentStateSet = stateSet;
    }
    getRenderStates() {
        return this._currentStateSet;
    }
    setFramebuffer(rt) {
        this._commandQueue.setFramebuffer(rt);
    }
    getFramebuffer() {
        return this._commandQueue.getFramebuffer() ?? null;
    }
    reverseVertexWindingOrder(reverse) {
        this._reverseWindingOrder = !!reverse;
    }
    isWindingOrderReversed() {
        return this._reverseWindingOrder;
    }
    /** @internal */ isBufferUploading(buffer) {
        return this._commandQueue.isBufferUploading(buffer);
    }
    /** @internal */ isTextureUploading(tex) {
        return this._commandQueue.isTextureUploading(tex);
    }
    /** @internal */ getFramebufferInfo() {
        return this._commandQueue.getFramebufferInfo();
    }
    /** @internal */ gpuGetObjectHash(obj) {
        return this._gpuObjectHasher.get(obj);
    }
    /** @internal */ gpuCreateTexture(desc) {
        const tex = this._device.createTexture(desc);
        if (tex) {
            this._gpuObjectHasher.set(tex, ++this._gpuObjectHashCounter);
        }
        return tex;
    }
    /** @internal */ gpuImportExternalTexture(el) {
        const tex = this._device.importExternalTexture({
            source: el
        });
        if (tex) {
            this._gpuObjectHasher.set(tex, ++this._gpuObjectHashCounter);
        }
        return tex;
    }
    /** @internal */ gpuCreateSampler(desc) {
        const sampler = this._device.createSampler(desc);
        if (sampler) {
            this._gpuObjectHasher.set(sampler, ++this._gpuObjectHashCounter);
        }
        return sampler;
    }
    /** @internal */ gpuCreateBindGroup(desc) {
        const bindGroup = this._device.createBindGroup(desc);
        if (bindGroup) {
            this._gpuObjectHasher.set(bindGroup, ++this._gpuObjectHashCounter);
        }
        return bindGroup;
    }
    /** @internal */ gpuCreateBuffer(desc) {
        const buffer = this._device.createBuffer(desc);
        if (buffer) {
            this._gpuObjectHasher.set(buffer, ++this._gpuObjectHashCounter);
        }
        return buffer;
    }
    /** @internal */ gpuCreateTextureView(texture, desc) {
        const view = texture?.createView(desc);
        if (view) {
            this._gpuObjectHasher.set(view, ++this._gpuObjectHashCounter);
        }
        return view;
    }
    /** @internal */ gpuCreateRenderPipeline(desc) {
        const pipeline = this._device.createRenderPipeline(desc);
        if (pipeline) {
            this._gpuObjectHasher.set(pipeline, ++this._gpuObjectHashCounter);
        }
        return pipeline;
    }
    /** @internal */ gpuCreateComputePipeline(desc) {
        const pipeline = this._device.createComputePipeline(desc);
        if (pipeline) {
            this._gpuObjectHasher.set(pipeline, ++this._gpuObjectHashCounter);
        }
        return pipeline;
    }
    /** @internal */ fetchVertexLayout(hash) {
        return this._vertexLayoutCache.fetchVertexLayout(hash);
    }
    /** @internal */ fetchSampler(options) {
        return this._samplerCache.fetchSampler(options);
    }
    /** @internal */ fetchBindGroupLayout(desc) {
        return this._bindGroupCache.fetchBindGroupLayout(desc);
    }
    flush() {
        this._commandQueue.flush();
    }
    async readPixels(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? (fb.getColorAttachments()[index]?.object) : this.context.getCurrentTexture();
        const texFormat = fb ? fb.getColorAttachments()[index]?.format : textureFormatInvMap[this._backBufferFormat];
        if (colorAttachment && texFormat) {
            const pixelSize = getTextureFormatBlockSize(texFormat);
            const bufferSize = w * h * pixelSize;
            const stagingBuffer = this.createBuffer(bufferSize, {
                usage: 'read'
            });
            this.readPixelsToBuffer(0, x, y, w, h, stagingBuffer);
            const data = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            await stagingBuffer.getBufferSubData(data);
            stagingBuffer.dispose();
        } else {
            console.error('readPixels() failed: no color attachment0 or unrecoganized color attachment format');
        }
    }
    readPixelsToBuffer(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? (fb.getColorAttachments()[index]?.object) : this.context.getCurrentTexture();
        const texFormat = fb ? fb.getColorAttachments()[index]?.format : textureFormatInvMap[this._backBufferFormat];
        const texWidth = fb ? fb.getColorAttachments()[index]?.width : this.getDrawingBufferWidth();
        const texHeight = fb ? fb.getColorAttachments()[index]?.height : this.getDrawingBufferHeight();
        if (colorAttachment && texFormat) {
            this.flush();
            WebGPUBaseTexture.copyTexturePixelsToBuffer(this._device, colorAttachment, texWidth, texHeight, texFormat, x, y, w, h, 0, 0, buffer);
        } else {
            console.error('readPixelsToBuffer() failed: no color attachment0 or unrecoganized color attachment format');
        }
    }
    looseContext() {
    // not implemented
    }
    restoreContext() {
    // not implemented
    }
    /** @internal */ onBeginFrame() {
        if (this._canRender) {
            this._commandQueue.beginFrame();
            return true;
        } else {
            return false;
        }
    }
    /** @internal */ onEndFrame() {
        this._commandQueue.endFrame();
    }
    /** @internal */ _draw(primitiveType, first, count) {
        this._commandQueue.draw(this._currentProgram, this._currentVertexData, this._currentStateSet, this._currentBindGroups, this._currentBindGroupOffsets, primitiveType, first, count, 1);
    }
    /** @internal */ _drawInstanced(primitiveType, first, count, numInstances) {
        this._commandQueue.draw(this._currentProgram, this._currentVertexData, this._currentStateSet, this._currentBindGroups, this._currentBindGroupOffsets, primitiveType, first, count, numInstances);
    }
    /** @internal */ _compute(workgroupCountX, workgroupCountY, workgroupCountZ) {
        this._commandQueue.compute(this._currentProgram, this._currentBindGroups, this._currentBindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ);
    }
    configure() {
        this._backBufferFormat = navigator.gpu.getPreferredCanvasFormat();
        this._depthFormat = this._deviceCaps.framebufferCaps.supportDepth32floatStencil8 ? 'depth32float-stencil8' : 'depth24plus-stencil8';
        this._context.configure({
            device: this._device,
            format: this._backBufferFormat,
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            alphaMode: 'opaque',
            colorSpace: 'srgb'
        });
        this.createDefaultRenderAttachments();
    }
    createDefaultRenderAttachments() {
        const width = Math.max(1, this.canvas.width);
        const height = Math.max(1, this.canvas.height);
        this._defaultMSAAColorTexture?.destroy();
        this._defaultMSAAColorTexture = null;
        this._defaultMSAAColorTextureView = null;
        this._defaultDepthTexture?.destroy();
        this._defaultDepthTexture = null;
        this._defaultDepthTextureView = null;
        if (this._sampleCount > 1) {
            this._defaultMSAAColorTexture = this.gpuCreateTexture({
                size: {
                    width,
                    height,
                    depthOrArrayLayers: 1
                },
                format: this._backBufferFormat,
                dimension: '2d',
                mipLevelCount: 1,
                sampleCount: this._sampleCount,
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            this._defaultMSAAColorTextureView = this._defaultMSAAColorTexture.createView();
        }
        this._defaultDepthTexture = this.gpuCreateTexture({
            size: {
                width,
                height,
                depthOrArrayLayers: 1
            },
            format: this._depthFormat,
            dimension: '2d',
            mipLevelCount: 1,
            sampleCount: this._sampleCount,
            usage: GPUTextureUsage.RENDER_ATTACHMENT
        });
        this._defaultDepthTextureView = this._defaultDepthTexture.createView();
        this._defaultRenderPassDesc = {
            label: `mainRenderPass:${this._sampleCount}`,
            colorAttachments: [
                {
                    view: this._sampleCount > 1 ? this._defaultMSAAColorTextureView : null,
                    resolveTarget: undefined,
                    loadOp: 'clear',
                    clearValue: [
                        0,
                        0,
                        0,
                        0
                    ],
                    storeOp: 'store'
                }
            ],
            depthStencilAttachment: {
                view: this._defaultDepthTextureView,
                depthLoadOp: 'clear',
                depthClearValue: 1,
                depthStoreOp: 'store',
                stencilLoadOp: 'clear',
                stencilClearValue: 0,
                stencilStoreOp: 'store'
            }
        };
    }
}

/**
 * The WebGPU backend
 * @public
 */ const backendWebGPU = {
    typeName () {
        return 'webgpu';
    },
    supported () {
        return !!window.GPU && navigator.gpu instanceof window.GPU;
    },
    async createDevice (cvs, options) {
        try {
            const factory = makeEventTarget(WebGPUDevice)();
            const device = new factory(this, cvs, options);
            await device.initContext();
            device.setViewport();
            device.setScissor();
            return device;
        } catch (err) {
            console.error(err);
            return null;
        }
    }
};

function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var bindImgui$1 = {
    exports: {}
};

(function(module, exports) {
    var Module = (()=>{
        var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
        return function(Module = {}) {
            // include: shell.js
            // The Module object: Our interface to the outside world. We import
            // and export values on it. There are various ways Module can be used:
            // 1. Not defined. We create it here
            // 2. A function parameter, function(Module) { ..generated code.. }
            // 3. pre-run appended it, var Module = {}; ..generated code..
            // 4. External script tag defines var Module.
            // We need to check if Module already exists (e.g. case 3 above).
            // Substitution will be replaced with actual code on later stage of the build,
            // this way Closure Compiler will not mangle it (e.g. case 4. above).
            // Note that if you want to run closure, and also to use Module
            // after the generated code, you will need to define   var Module = {};
            // before the code. Then that object will be used in the code, and you
            // can continue to use Module afterwards as well.
            var Module = typeof Module != 'undefined' ? Module : {};
            // Set up the promise that indicates the Module is initialized
            var readyPromiseResolve, readyPromiseReject;
            Module['ready'] = new Promise((resolve, reject)=>{
                readyPromiseResolve = resolve;
                readyPromiseReject = reject;
            });
            [
                "_main",
                "_fflush",
                "__embind_initialize_bindings",
                "onRuntimeInitialized"
            ].forEach((prop)=>{
                if (!Object.getOwnPropertyDescriptor(Module['ready'], prop)) {
                    Object.defineProperty(Module['ready'], prop, {
                        get: ()=>abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),
                        set: ()=>abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js')
                    });
                }
            });
            // --pre-jses are emitted after the Module integration code, so that they can
            // refer to Module (if they choose; they can also define Module)
            // Sometimes an existing Module object exists with properties
            // meant to overwrite the default module functionality. Here
            // we collect those properties and reapply _after_ we configure
            // the current environment's defaults to avoid having to be so
            // defensive during initialization.
            var moduleOverrides = Object.assign({}, Module);
            // Determine the runtime environment we are in. You can customize this by
            // setting the ENVIRONMENT setting at compile time (see settings.js).
            var ENVIRONMENT_IS_WEB = true;
            var ENVIRONMENT_IS_WORKER = false;
            var ENVIRONMENT_IS_NODE = false;
            var ENVIRONMENT_IS_SHELL = false;
            if (Module['ENVIRONMENT']) {
                throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
            }
            // `/` should be present at the end if `scriptDirectory` is not empty
            var scriptDirectory = '';
            function locateFile(path) {
                if (Module['locateFile']) {
                    return Module['locateFile'](path, scriptDirectory);
                }
                return scriptDirectory + path;
            }
            // Hooks that are implemented differently in different runtime environments.
            var readBinary;
            {
                if (typeof document != 'undefined' && document.currentScript) {
                    scriptDirectory = document.currentScript.src;
                }
                // When MODULARIZE, this JS may be executed later, after document.currentScript
                // is gone, so we saved it, and we use it here instead of any other info.
                if (_scriptDir) {
                    scriptDirectory = _scriptDir;
                }
                // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
                // otherwise, slice off the final part of the url to find the script directory.
                // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
                // and scriptDirectory will correctly be replaced with an empty string.
                // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
                // they are removed because they could contain a slash.
                if (scriptDirectory.indexOf('blob:') !== 0) {
                    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/') + 1);
                } else {
                    scriptDirectory = '';
                }
                if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');
            }
            var out = Module['print'] || console.log.bind(console);
            var err = Module['printErr'] || console.error.bind(console);
            // Merge back in the overrides
            Object.assign(Module, moduleOverrides);
            // Free the object hierarchy contained in the overrides, this lets the GC
            // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
            moduleOverrides = null;
            checkIncomingModuleAPI();
            // Emit code to handle expected values on the Module object. This applies Module.x
            // to the proper local x. This has two benefits: first, we only emit it if it is
            // expected to arrive, and second, by using a local everywhere else that can be
            // minified.
            if (Module['arguments']) Module['arguments'];
            legacyModuleProp('arguments', 'arguments_');
            if (Module['thisProgram']) Module['thisProgram'];
            legacyModuleProp('thisProgram', 'thisProgram');
            if (Module['quit']) Module['quit'];
            legacyModuleProp('quit', 'quit_');
            // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
            // Assertions on removed incoming Module JS APIs.
            assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
            assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
            assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
            assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
            assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
            legacyModuleProp('read', 'read_');
            legacyModuleProp('readAsync', 'readAsync');
            legacyModuleProp('readBinary', 'readBinary');
            legacyModuleProp('setWindowTitle', 'setWindowTitle');
            assert(!ENVIRONMENT_IS_WORKER, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.");
            assert(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.");
            assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
            // end include: shell.js
            // include: preamble.js
            // === Preamble library stuff ===
            // Documentation for the public APIs defined in this file must be updated in:
            //    site/source/docs/api_reference/preamble.js.rst
            // A prebuilt local version of the documentation is available at:
            //    site/build/text/docs/api_reference/preamble.js.txt
            // You can also build docs locally as HTML or other formats in site/
            // An online HTML version (which may be of a different version of Emscripten)
            //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
            var wasmBinary;
            if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
            legacyModuleProp('wasmBinary', 'wasmBinary');
            Module['noExitRuntime'] || false;
            legacyModuleProp('noExitRuntime', 'noExitRuntime');
            if (typeof WebAssembly != 'object') {
                abort('no native wasm support detected');
            }
            // Wasm globals
            var wasmMemory;
            //========================================
            // Runtime essentials
            //========================================
            // whether we are quitting the application. no code should run after this.
            // set in exit() and abort()
            var ABORT = false;
            /** @type {function(*, string=)} */ function assert(condition, text) {
                if (!condition) {
                    abort('Assertion failed' + (text ? ': ' + text : ''));
                }
            }
            // We used to include malloc/free by default in the past. Show a helpful error in
            // builds with assertions.
            // Memory management
            var /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;
            function updateMemoryViews() {
                var b = wasmMemory.buffer;
                Module['HEAP8'] = HEAP8 = new Int8Array(b);
                Module['HEAP16'] = HEAP16 = new Int16Array(b);
                Module['HEAP32'] = HEAP32 = new Int32Array(b);
                Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
                Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
                Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
                Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
                Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
            }
            assert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');
            assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, 'JS engine does not provide full typed array support');
            // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
            assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
            assert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');
            // include: runtime_init_table.js
            // In regular non-RELOCATABLE mode the table is exported
            // from the wasm module and this will be assigned once
            // the exports are available.
            var wasmTable;
            // end include: runtime_init_table.js
            // include: runtime_stack_check.js
            // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
            function writeStackCookie() {
                var max = _emscripten_stack_get_end();
                assert((max & 3) == 0);
                // If the stack ends at address zero we write our cookies 4 bytes into the
                // stack.  This prevents interference with SAFE_HEAP and ASAN which also
                // monitor writes to address zero.
                if (max == 0) {
                    max += 4;
                }
                // The stack grow downwards towards _emscripten_stack_get_end.
                // We write cookies to the final two words in the stack and detect if they are
                // ever overwritten.
                HEAPU32[max >> 2] = 0x02135467;
                HEAPU32[max + 4 >> 2] = 0x89BACDFE;
                // Also test the global address 0 for integrity.
                HEAPU32[0 >> 2] = 1668509029;
            }
            function checkStackCookie() {
                if (ABORT) return;
                var max = _emscripten_stack_get_end();
                // See writeStackCookie().
                if (max == 0) {
                    max += 4;
                }
                var cookie1 = HEAPU32[max >> 2];
                var cookie2 = HEAPU32[max + 4 >> 2];
                if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
                    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
                }
                // Also test the global address 0 for integrity.
                if (HEAPU32[0 >> 2] != 0x63736d65 /* 'emsc' */ ) {
                    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
                }
            }
            // end include: runtime_stack_check.js
            // include: runtime_assertions.js
            // Endianness check
            (function() {
                var h16 = new Int16Array(1);
                var h8 = new Int8Array(h16.buffer);
                h16[0] = 0x6373;
                if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
            })();
            // end include: runtime_assertions.js
            var __ATPRERUN__ = []; // functions called before the runtime is initialized
            var __ATINIT__ = []; // functions called during startup
            var __ATPOSTRUN__ = []; // functions called after the main() is called
            var runtimeInitialized = false;
            var runtimeExited = false;
            function preRun() {
                if (Module['preRun']) {
                    if (typeof Module['preRun'] == 'function') Module['preRun'] = [
                        Module['preRun']
                    ];
                    while(Module['preRun'].length){
                        addOnPreRun(Module['preRun'].shift());
                    }
                }
                callRuntimeCallbacks(__ATPRERUN__);
            }
            function initRuntime() {
                assert(!runtimeInitialized);
                runtimeInitialized = true;
                checkStackCookie();
                callRuntimeCallbacks(__ATINIT__);
            }
            function postRun() {
                checkStackCookie();
                if (Module['postRun']) {
                    if (typeof Module['postRun'] == 'function') Module['postRun'] = [
                        Module['postRun']
                    ];
                    while(Module['postRun'].length){
                        addOnPostRun(Module['postRun'].shift());
                    }
                }
                callRuntimeCallbacks(__ATPOSTRUN__);
            }
            function addOnPreRun(cb) {
                __ATPRERUN__.unshift(cb);
            }
            function addOnInit(cb) {
                __ATINIT__.unshift(cb);
            }
            function addOnPostRun(cb) {
                __ATPOSTRUN__.unshift(cb);
            }
            // include: runtime_math.js
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
            assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            // end include: runtime_math.js
            // A counter of dependencies for calling run(). If we need to
            // do asynchronous work before running, increment this and
            // decrement it. Incrementing must happen in a place like
            // Module.preRun (used by emcc to add file preloading).
            // Note that you can add dependencies in preRun, even though
            // it happens right before run - run will be postponed until
            // the dependencies are met.
            var runDependencies = 0;
            var runDependencyWatcher = null;
            var dependenciesFulfilled = null; // overriden to take different actions when all run dependencies are fulfilled
            var runDependencyTracking = {};
            function addRunDependency(id) {
                runDependencies++;
                if (Module['monitorRunDependencies']) {
                    Module['monitorRunDependencies'](runDependencies);
                }
                if (id) {
                    assert(!runDependencyTracking[id]);
                    runDependencyTracking[id] = 1;
                    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
                        // Check for missing dependencies every few seconds
                        runDependencyWatcher = setInterval(()=>{
                            if (ABORT) {
                                clearInterval(runDependencyWatcher);
                                runDependencyWatcher = null;
                                return;
                            }
                            var shown = false;
                            for(var dep in runDependencyTracking){
                                if (!shown) {
                                    shown = true;
                                    err('still waiting on run dependencies:');
                                }
                                err('dependency: ' + dep);
                            }
                            if (shown) {
                                err('(end of list)');
                            }
                        }, 10000);
                    }
                } else {
                    err('warning: run dependency added without ID');
                }
            }
            function removeRunDependency(id) {
                runDependencies--;
                if (Module['monitorRunDependencies']) {
                    Module['monitorRunDependencies'](runDependencies);
                }
                if (id) {
                    assert(runDependencyTracking[id]);
                    delete runDependencyTracking[id];
                } else {
                    err('warning: run dependency removed without ID');
                }
                if (runDependencies == 0) {
                    if (runDependencyWatcher !== null) {
                        clearInterval(runDependencyWatcher);
                        runDependencyWatcher = null;
                    }
                    if (dependenciesFulfilled) {
                        var callback = dependenciesFulfilled;
                        dependenciesFulfilled = null;
                        callback(); // can add another dependenciesFulfilled
                    }
                }
            }
            /** @param {string|number=} what */ function abort(what) {
                if (Module['onAbort']) {
                    Module['onAbort'](what);
                }
                what = 'Aborted(' + what + ')';
                // TODO(sbc): Should we remove printing and leave it up to whoever
                // catches the exception?
                err(what);
                ABORT = true;
                // Use a wasm runtime error, because a JS error might be seen as a foreign
                // exception, which means we'd run destructors on it. We need the error to
                // simply make the program stop.
                // FIXME This approach does not work in Wasm EH because it currently does not assume
                // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
                // a trap or not based on a hidden field within the object. So at the moment
                // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
                // allows this in the wasm spec.
                // Suppress closure compiler warning here. Closure compiler's builtin extern
                // defintion for WebAssembly.RuntimeError claims it takes no arguments even
                // though it can.
                // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
                /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);
                readyPromiseReject(e);
                // Throw the error whether or not MODULARIZE is set because abort is used
                // in code paths apart from instantiation where an exception is expected
                // to be thrown when abort is called.
                throw e;
            }
            // include: memoryprofiler.js
            // end include: memoryprofiler.js
            // show errors on likely calls to FS when it was not included
            var FS = {
                error: function() {
                    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
                },
                init: function() {
                    FS.error();
                },
                createDataFile: function() {
                    FS.error();
                },
                createPreloadedFile: function() {
                    FS.error();
                },
                createLazyFile: function() {
                    FS.error();
                },
                open: function() {
                    FS.error();
                },
                mkdev: function() {
                    FS.error();
                },
                registerDevice: function() {
                    FS.error();
                },
                analyzePath: function() {
                    FS.error();
                },
                ErrnoError: function ErrnoError() {
                    FS.error();
                }
            };
            Module['FS_createDataFile'] = FS.createDataFile;
            Module['FS_createPreloadedFile'] = FS.createPreloadedFile;
            // include: URIUtils.js
            // Prefix of data URIs emitted by SINGLE_FILE and related options.
            var dataURIPrefix = 'data:application/octet-stream;base64,';
            // Indicates whether filename is a base64 data URI.
            function isDataURI(filename) {
                // Prefix of data URIs emitted by SINGLE_FILE and related options.
                return filename.startsWith(dataURIPrefix);
            }
            // Indicates whether filename is delivered via file protocol (as opposed to http/https)
            function isFileURI(filename) {
                return filename.startsWith('file://');
            }
            // end include: URIUtils.js
            /** @param {boolean=} fixedasm */ function createExportWrapper(name, fixedasm) {
                return function() {
                    var displayName = name;
                    var asm = fixedasm;
                    if (!fixedasm) {
                        asm = Module['asm'];
                    }
                    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');
                    assert(!runtimeExited, 'native function `' + displayName + '` called after runtime exit (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
                    if (!asm[name]) {
                        assert(asm[name], 'exported native function `' + displayName + '` not found');
                    }
                    return asm[name].apply(null, arguments);
                };
            }
            // include: runtime_exceptions.js
            // end include: runtime_exceptions.js
            var wasmBinaryFile;
            wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAAB8oqAgACiAWACf38AYAF/AGACf38Bf2ABfwF/YAN/f38AYAN/f38Bf2AAAGAEf39/fwF/YAABf2AEf39/fwBgB39/f39/f38Bf2AFf39/f38AYAJ/fwF9YAZ/f39/f38Bf2AFf39/f38Bf2AGf39/f39/AGAAAX1gCH9/f39/f39/AX9gAn99AGADf399AGAHf39/f39/fwBgAX0AYAF9AX1gAX8BfWAFf399f38AYAZ/f39/f30AYAl/f39/f39/f38Bf2AFf39/f30AYAR/f31/AGADf35/AX5gAXwBfGAFf35+fn4AYAp/f39/f39/f39/AGAIf39/f39/f38AYAV/f399fwBgB39/fX9/f38Bf2AGf399fX9/AX9gAX8BfGAGfX19f39/AGACfX0AYAR/f399AGAHf39/f39/fQBgBn9/fX9/fQBgB39/fX19f38Bf2AJf39/f39/f39/AGADf399AX9gBH99f38AYAJ/fQF/YAZ/f39/fX8AYAh/f39/f399fwBgB39/f39/fX8AYAt/f39/f39/f39/fwBgCX9/f39/f399fwBgAX8BfmACf30BfWAFf39/fX0AYAN/fX0Bf2ADf319AGAEf399fQBgBn9/fX19fwBgB39/f399f30AYAV/f39/fQF/YAN9f38AYAZ/f3x8f38Bf2ADf31/AGAJf399fX1/f39/AGAGf399f39/AGACfX0BfWABfQF/YAR/fn5/AGAAAXxgBn9/f39/fQF/YAh/f399f39/fwF/YAd/f31+fn9/AX9gB39/f39/fX0BfWAHf31/f399fQF/YAd/fn5+f319AX1gB399fn5/fX0BfmADf39+AX5gB399fX1/fX0BfWAJf39/f35+f39/AX9gA39/fwF9YAl/f39/f319f38AYAl/f39/f399fX8AYAh/f31/f399fwBgBn9/f31/fwBgBH99f30Bf2ABfAF9YAN/fn8Bf2ABfAF/YAF+AX9gAnx/AXxgBn98f39/fwF/YAJ+fwF/YAR+fn5+AX9gDX9/f39/f39/f39/f38AYAN/f38BfGADf398AGAIf39/fX1/f38AYAR9fX19AX9gC399fX19fX19fX1/AGAJf319fX19fX1/AGAJf399f39/f31/AGAHf399f39/fwBgBn9/f319fQBgCH9/f399f31/AGAHf39/f319fwF/YAd/f318fH9/AX9gA39/fQF9YAd/fHx8f319AX1gB399fHx/fX0BfGADf398AXxgCX9/f399f39/fwF/YAl/f399fX1/f38Bf2AJf39/fX9/f39/AX9gCX9/f399fX9/fwF/YAl/f39/fHx/f38Bf2AHf39/fX1/fwF/YAp/f39/f39/fX1/AX9gBH99fX0BfWAIf39/f399f30AYAh/f39/f39/fQBgB39/f31/f30AYAl/f399f39/fX8AYAx/f39/f39/f39/f38AYAp/f39/f39/f31/AGAHf39/fX19fwBgCX9/fX19f39/fwF/YAV/f31/fQF/YAd/f399f39/AGAEf39/fQF/YAp/f39/f39/f39/AX9gB39/f3x8f38Bf2AFf39/fX8Bf2AHf319fX9/fwBgBH9/fX0Bf2AEf399fwF/YAV/fX9/fQF/YAp/f31/f39/f31/AGACfX8Bf2ACf3wBfGACfHwBfGACfn8BfGADfHx/AXxgA3x+fgF8YAF8AGACfH8BfWACf34AYAJ+fgF/YAN/fn4AYAJ/fwF+YAJ/fwF8YAN+f38Bf2ABfAF+YAR/f39+AX5gA39/fgBgAn98AGACfn4BfGACfn4BfWAEf39+fwF+YAV/f39+fgBgBH9+f38BfwKJiYCAACoDZW52DV9fYXNzZXJ0X2ZhaWwACQNlbnYRX2VtdmFsX25ld19vYmplY3QACANlbnYRX2VtdmFsX3Rha2VfdmFsdWUAAgNlbnYNX2VtdmFsX2RlY3JlZgABA2VudhJfZW12YWxfbmV3X2NzdHJpbmcAAwNlbnYTX2VtdmFsX3NldF9wcm9wZXJ0eQAEA2VudhlfZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uABQDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAXwNlbnYJX2VtdmFsX2FzAGADZW52Fl9lbXZhbF9ydW5fZGVzdHJ1Y3RvcnMAAQNlbnYTX2VtdmFsX2dldF9wcm9wZXJ0eQACA2VudhZfZW12YWxfc3RyaWN0bHlfZXF1YWxzAAIDZW52DV9lbXZhbF9pbmNyZWYAAQNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19wcm9wZXJ0eQAgA2Vudh9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uACwDZW52C19fY3hhX3Rocm93AAQDZW52Il9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IADwNlbnYLX2VtdmFsX2NhbGwABwNlbnYZX2VtYmluZF9yZWdpc3Rlcl9jb25zdGFudABhA2Vudg1fZW12YWxfdHlwZW9mAAMDZW52EF9lbXZhbF9uZXdfYXJyYXkACANlbnYYX2VtdmFsX2dldF9tZXRob2RfY2FsbGVyAAIDZW52F19lbXZhbF9jYWxsX3ZvaWRfbWV0aG9kAAkDZW52FV9lbWJpbmRfcmVnaXN0ZXJfdm9pZAAAA2VudhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wACwNlbnYYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAAsDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQABANlbnYbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAADZW52HF9lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcABANlbnYWX2VtYmluZF9yZWdpc3Rlcl9lbXZhbAAAA2VudhxfZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3AAQDZW52FWVtc2NyaXB0ZW5fbWVtY3B5X2JpZwAEA2VudhBfX3N5c2NhbGxfb3BlbmF0AAcDZW52EV9fc3lzY2FsbF9mY250bDY0AAUDZW52D19fc3lzY2FsbF9pb2N0bAAFFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3JlYWQABxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAMDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAwNlbnYFYWJvcnQABgNlbnYXX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQAFBZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsADgP8kYCAANgRBgMSAwAAAwAAAAUBCQcUCwQDAwUBAgcBAwcHBTUHDgIHAgIAAyYmBQIFBQQEAgEELRUFBAQELgMDEwEnAwgvAwMDAAABEgABAwIJBAAoIRsUYhsTBAUFAwMBAgIFAgICBgEBAAYBAQMIAgUIBQIBNggBCAgB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7QruCu8K8ArxCvIKgwOGA4cDiwOMA4gDiQOPA94C8wqNA44D9Aq3AvUK9gr3Cm74CnH5CroCuwK8Ar0C9wL5Alv6Ar4CvwL6CtkC+wr8Cv0K/gr/CoALgQuCC4MLhwXqAoQFggWEC/UC9gKEA+kChQvvAvAChgvyAvMChwuIC4kLhQX8Av0C/gL/AooL7gGLC4wLjQuOC48LkAuRC5ILkwuUC5ULlguXC5gLmQuaC5sLnAudC54LnwugC6ELogujC6QLpQumC6cLgQWoC4sFqQuqC6sLrAutC64LrwuwC7ELsguzC7QLtQu2C7cLuAu5C7oLuwu8C70Lvgu/C8ALwQvCC8MLxAvFC8YLxwvIC8kLygvLC8wLzQvOC88L0AvRC9IL0wvUC9UL1gvXC9gL2QvaC9sL3AvdC94L3wvgC+EL4gvjC4gG5AvlC+YL5wvoC+kL6gvrC+wL7QvuC+8LlgaXBvAL8QuYBvIL8wv0C/UL9gv3C/gL+Qv6C54G+wv8C/0L/gv/C4AMgQyCDIMMhAyFDK0GrgavBrAGhgyzBocMiAyJDIoMkAPbAYsMjAyNDJYDjgyPDJQDkAyRDJIMkwyUDJUMlgyXDJgMmQyaDJsMnAydDJ4MnwygDKEMogyjDKQMpQymDKcMqAypDKoMqwysDK0MrgzZBMwErwzQBNIEzwTRBM0EsAy9BrEMygayDLMMqQO0DKsDgAKsA7UMogO2DLcMowOlA7gMpwO5DLoMuwz5Ad0C3AKRAZoCkgGeAqMCpAKbApwCnQKfAqACoQKiArwMvQy+DKUCvwzADMEMwgzDDLcBuAHEDMUMxgzHDMgMyQzKDMsMzAzNDLICzgzPDNAM0QzSDNMM1AzVDIgCzQHWDNEBiwLXDIoCmAKCAowCjQKOAtgM2QzaDJMC2wzcDN0MkALeDN8MlQKWApcCmQLgDOEM4gzjDOQM5QzmDOcM6AzpDOoM9QyDDeYN6Q3qDfMN9A31DfcN+Q36DewM7Qz9Df4N/w2ADoEOgw6EDoUOhg6HDogOiQ6KDosOjA6NDo8OkA6RDpIOkw6UDpUOlg6XDpgOmQ6aDpsOnA6dDp4Onw6gDqEOog6jDqQOpQ6mDqcOqA6pDqoOqw6sDq0Org6vDrAOsQ6yDrMOtA61DrYOtw64DrkOug7sBvcGgAeZB6AHrAe1B78HxwfJCNsI6Aj9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NgIAAkAgAEGwA2ooAgBBBXEiBQ0AIABBrANqIgMgAygCAEEBajYCAAsCQCACKAKkNSABRyIGDQAgAi0A/DlFDQAgAi0AwDVBAXENACACKALoOQ0AIAIgADYC6DkgAkEAQX8gBRtBASACQf0Bai0AABsgAEGsA2ooAgBqNgL4OQtBACEDAkACQCACKALkOSAARw0AIAQgAigC7DlGDQECQCAFDQAgAEGsA2ooAgAgAigC8DlHDQAgAiABNgLgNwwCCyAGDQBBACEDQQBBABCNAQsgAw8LQQELKgEBfyAAQagDaiIBIAEoAgBBf2o2AgAgAEGsA2oiACAAKAIAQX9qNgIAC3sCAX0Bf0MAAAAAIQICQCABQwAAAABdDQBBACgCsOYLKALsNCEDAkACQCABQwAAAABcDQAgA0GcBGoqAgAhAQwBCyABQwAAAABeRQ0AIAMqAgwgAyoCWJMgAZIhAQsgASAAKgIAkyIBQwAAgD8gAUMAAIA/YBshAgsgAgsuAQJ/AkBBACgCsOYLIgBB0AFqKAIAIgENAEGW3AgPCyAAQdgBaigCACABEQMACywBAn8CQEEAKAKw5gsiAUHUAWooAgAiAkUNACABQdgBaigCACAAIAIRAAALCwYAQau0BgsJAEEAKAKw5gsLCwBBACAANgKw5gsLHQBBACABNgKU2ApBACAANgKQ2ApBACACNgK45gsLXgEBfwJAQQAoArDmCyIBRQ0AIAFB8AZqIgEgASgCAEEBajYCAAtBgPwAQQAoArjmC0EAKAKQ2AoRAgAgABChASEAAkBBACgCsOYLDQBBACAANgKw5gsLIAAQogEgAAvsDAEBfyAAQQhqEC0aIABBmCpqECsaIABBuDJqEMUDIQIgAEIANwKENSAAQgA3A/g3IABCADcDyDUgAEGAOGpCADcDACAAQgA3A6A4IABBqDhqQgA3AwAgAEHUOGpBADYCACAAQgA3Asw4IABBrDRqQQBBPBCgDxogAEHwNWpBAEHUARCgDxogAEHgOGpB////+wc2AgAgAEHkOGpCADcCACAAQdg4akL////79///v/8ANwMAIABB7DhqQgA3AgAgAEH0OGpCADcCACAAQfw4akEANgIAIABBiDlqQf////sHNgIAIABBjDlqQgA3AgAgAEGAOWpC////+/f//7//ADcDACAAQZQ5akIANwIAIABBnDlqQgA3AgAgAEGkOWpBADYCACAAQbA5akH////7BzYCACAAQbQ5akIANwIAIABBqDlqQv////v3//+//wA3AwAgAEG8OWpCADcCACAAQQA6AIA6IABByDpqQQBBkAEQoA8aIABBhDpqQQBBwAAQoA8aIABB9DpqIAI2AgAgAEHYO2pBAEGQARCgDxogAEGEPGogAjYCACAAQZA9akEAQSEQoA8aIABBhD1qQgA3AgAgAEIANwL8PCAAQYw9akF/NgIAIABCADcCtD0gAEGxPWpBADsAACAAQbw9akIANwIAIABB6D1qQQA2AgAgAEIANwPgPSAAQYA+akEAQcAAEKAPGiAAQcQ+akEAQcwdEKAPGiAAQZDcAGoQ+A4aIABBtN4AakIANwIAIABCADcCrF4gAEH63wBqQQA6AAAgAEEAOwH4XyAAQdjfAGpBADYCACAAQgA3A9BfIABB2N4AakEAQSgQoA8aIABBiN8AakEAQTwQoA8aIABBgOAAakJ/NwMAIABB+98AakGBAjsAACAAQQA2ArQyIAAgAUU6AAEgAEEAOgAAIABCADcCrDIgAEH4N2ohAgJAIAENAAJAQQAoArDmCyIBRQ0AIAFB8AZqIgEgASgCAEEBajYCAAtBtAhBACgCuOYLQQAoApDYChECABDwDiEBCyAAQgA3A4g0IABCADcCpDQgAEKAgICAcDcDkDQgAEL/////DzcDmDQgAEIANwPoNCAAQZgBaiABNgIAIABBoDRqQQA6AAAgAEHwNGpCADcDACAAQfg0akIANwMAIABBgDVqQQA2AgAgAEGMNWpBAEErEKAPGiAAQcA1akIANwMAIABCADcDuDUgAEEANgLsNSAAQgA3AuQ1IABCgICA/IuAgMC/fzcDyDUgAEIANwPQNSAAQdg1akIANwMAIABB4DVqQQA7AQAgAEHEN2pBAEE0EKAPGiACQQhqQgA3AwAgAkIANwMAIABBADYCvDggAEIANwK0OCAAQQA6ALA4IABBADYCnDggAEEBOgCWOCAAQQA7AZQ4IABB/////wc2ApA4IABCADcDiDggAEF/NgLIOCAAQQA2AJc4IABCfzcDwDggAEIANwLkOSAAQgA3AsQ5IABBzDlqQgA3AgAgAEHUOWpCADcCACAAQdk5akIANwAAIABB/////wc2AvA5IABB/////wc2Auw5IABC//////f/////ADcC9DkgAEH4OmpBn9gFNgIAIABBiDxqQazYBTYCACAAQQA2AvA8IABBADYCxDogAEEAOgD8OSAAQQA2Aug8IABB6zxqQQA2AAAgAEJ/NwL0PCAAQgA3AsQ9IABBzD1qQgA3AgAgAEHUPWpBADYCACAAQQA2AsA+IABBADYCkF4gAEL/////DzcD2D0gAEIANwP4PiAAQfw9akEANgIAIABB9D1qQgA3AgAgAEIANwLsPSAAQQA2ApxeIABBqN4AakH////7BzYCACAAQoCAwNQANwKUXiAAQoCAgICg4fWRPDcCxF4gAEIANwLMXiAAQv////v3//+//wA3A/heIABBgICA+AM2AtReIABBADsBwF4gAEEANgK8XiAAQv////v3//+//wA3A6BeIABBADoAxF8gAEEAOgDgXyAAQQA2AuRfIABBAjYC7F8gAEL////79///v/8ANwPwXiAAQgA3A8hfIABBLjsBgF8gAEH////7BzYC3F8gAEEANgKEXyAAQQA2AvRfIABBADoA8F8gAEECNgLoXyAAQYjgAGpBAEHoAxCgDxogAEF/NgL4YyAAQn83A/BjIABB/OMAakEAQYEYEKAPGiAAC6QDAQV/AkAgAC0AAA0AIAAtAIFfDQBBoJIEQQBBABBFIQECQCAAKAKUXyICIABBmN8AaigCAEcNACACQQFqIQMCQAJAIAINAEEIIQQMAQsgAkECbSACaiEECyACIAQgAyAEIANKGyIDTg0AIANBJGwhAgJAQQAoArDmCyIERQ0AIARB8AZqIgQgBCgCAEEBajYCAAsgAkEAKAK45gtBACgCkNgKEQIAIQICQCAAQZzfAGooAgAiBEUNACACIAQgACgClF9BJGwQng8aAkAgACgCnF8iBEUNAEEAKAKw5gsiBUUNACAFQfAGaiIFIAUoAgBBf2o2AgALIARBACgCuOYLQQAoApTYChEAAAsgACADNgKYXyAAIAI2ApxfIAAoApRfIQILIABBnN8AaigCACACQSRsaiICQQA2AiAgAkEENgIcIAJBBTYCGCACQQY2AhQgAkEHNgIQIAJBADYCDCACQQg2AgggAiABNgIEIAJBoJIENgIAIAAgACgClF9BAWo2ApRfIAAQwgQgAEEBOgAADwtB4OQFQYLpBEGeH0H7qwUQAAAL0gUC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IBRFIA9yDQAgBUGAgIAYRg0AIANBuAFqIAcQ6QEgByADKQO4ATcCDAtBACgCsOYLIghBEGoqAgAhIiADQfAAakEMaiAIQRRqKgIAIic4AgAgAyAiOAJ4IANCADcCcCAEQbwraioCACEjIARBxCtqKgIAISQgA0HgAGpBDGogJyAEQcAraioCACIoIARByCtqKgIAIikgKCApYBsiKJMiKjgCACADICIgIyAkICMgJGAbIiOTIis4AmggAyAoQwAAAACSIig4AmQgAyAjQwAAAACSIik4AmACQCAPIBByDQAgBywAoAFBAEoNACAHLAChAUEASg0AICJDAAAAAF5FDQAgJ0MAAAAAXkUNACAHIANB4ABqEOoBCwJAAkAgByoCDCIii0MAAABPXUUNACAiqCEIDAELQYCAgIB4IQgLIAcgCLI4AgwCQAJAIAdBEGoiCCoCACIii0MAAABPXUUNACAiqCEPDAELQYCAgIB4IQ8LIAggD7I4AgACQAJAIA5FDQAgBEHAKmohCAwBCwJAIAlBgICA4ABxQYCAgCBHDQAgBEHIKmohCAwBCyAEQaQqaiEICyAHIAgqAgAiIjgCRCADQgA3A1ggA0IANwNQAkACQCAEKgKwMiIjQ83MjD+UIiQgI0PNzEw+lCAiQwAAgD+SIiOSIiIgJCAiYBsiIotDAAAAT11FDQAgIqghGAwBC0GAgICAeCEYCyAlICaSISwgB0EMaiEZQQJBASAEQbQBai0AABshESASQQBHIQ8CQCAHLQCNAUUNACAHQf8BOgCUASAHQZQBaiEXDA8LIActAAhBwgBxDQsgBywAoAFBAEoNCyAHLAChAUEASg0LIActAIsBRQ0LQQAoArDmCyIXQbQBai0AACEaIBcqArAyISIgA0L////79///v/8ANwJAIANC////+/f//7//ADcDMCAHQcACakEBNgIAQcmMBhDrAQJAAkAgIkPNzKw/lCIkICJDzcxMPpQgI5IiIiAkICJgGyIii0MAAABPXUUNACAiqCEIDAELQYCAgIB4IQgLAkACQCAIskMAAEA/lCIii0MAAABPXUUNACAiqCEIDAELQYCAgIB4IQgLIAiyIiSMIS1DAACAQEMAAAAAIBobIS4gAykDiAEhHyADQcABaiEbQQAhCEEAIRwDQCAHKgIUISUgByoCDCEiIAMgByoCECIj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AgAiBUEgcjYCAAsgASgCpDUgASgC3DVGDQAgAiAFQeAAcjYCAAsgASgCoDciAkEATA0BCyABIAJBf2o2AqA3IABBIGokAA8LQam3BkHvjgVB8gxBoYYFEAAAC9EBAQJ/QQAoArDmCyICKALsNCIDQQE6AIwBAkAgAy0AjwENAAJAAkAgAEMAAAAAWw0AIANBlAJqKgIAQwAAAAAgASABQwAAAABdGyADKgIMIAMqAliTIACSkpIhACADQZACaioCACEBDAELAkAgAUMAAAAAXUUNACACQeAqaioCACEBCyADQdQBaioCACEACyADIAEgAJI4AswBIANB0AFqIANB2AFqKgIAOAIAIANB9AFqIANB/AFqKQIANwIAIANBhAJqIANBiAJqKgIAOAIACwtLAgF/An0jAEEQayICJAAgAEEMaioCACEDIAAqAgQhBCACIAAqAgggACoCAJM4AgggAiADIASTOAIMIAJBCGogARCuAiACQRBqJAALFgAgAEEAKAKw5gsoAuw0KQLMATcCAAtnAwF/AX4CfUEAKAKw5gsoAuw0IgFBAToAjAEgASAAKQIAIgI3AswBIAFB5AFqIgAgACoCACIDIAKnviIEIAMgBGAbOAIAIAFB6AFqIgEgASoCACIDIAJCIIinviIEIAMgBGAbOAIAC1UCAX8DfUEAKAKw5gsoAuw0IgFB3ABqKgIAIQIgAUEQaioCACEDIAFB0AFqKgIAIQQgACABKgLMASABKgIMkyABKgJYkjgCACAAIAIgBCADk5I4AgQLIQEBf0EAKAKw5gsoAuw0IgAqAswBIAAqAgyTIAAqAliSCysBAX9BACgCsOYLKALsNCIAQdABaioCACAAQRBqKgIAkyAAQdwAaioCAJILjQECAX8DfUEAKAKw5gsoAuw0IgFBAToAjAEgACoCBCECIAEgASoCDCABKgJYkyAAKgIAkiIDOALMASABQdABaiACIAFBEGoqAgAgAUHcAGoqAgCTkiICOAIAIAFB5AFqIgAgACoCACIEIAMgBCADYBs4AgAgAUHoAWoiASABKgIAIgMgAiADIAJgGzgCAAtJAgF/AX1BACgCsOYLKALsNCIBQQE6AIwBIAEgASoCDCABKgJYkyAAkiIAOALMASABQeQBaiIBIAEqAgAiAiAAIAIgAGAbOAIAC1MCAX8BfUEAKAKw5gsoAuw0IgFBAToAjAEgAUHQAWogAUEQaioCACABQdwAaioCAJMgAJIiADgCACABQegBaiIBIAEqAgAiAiAAIAIgAGAbOAIAC0QCAX8CfUEAKAKw5gsoAuw0IgFB3AFqKgIAIQIgASoCDCEDIAAgAUHgAWoqAgAgAUEQaioCAJM4AgQgACACIAOTOAIAC14BAn9BACgCsOYLIgEoAuw0IgJBAToAjAECQCAAQwAAAABcDQAgAUGAK2oqAgAhAAsgAkGMAmoiASAAIAEqAgCSIgA4AgAgAiAAIAIqAgySIAJBkAJqKgIAkjgCzAELXgECf0EAKAKw5gsiASgC7DQiAkEBOgCMAQJAIABDAAAAAFwNACABQYAraioCACEACyACQYwCaiIBIAEqAgAgAJMiADgCACACIAAgAioCDJIgAkGQAmoqAgCSOALMAQvjAgEGf0EAKAKw5gsiASgC7DQhAgJAIABDAAAAAFwNACACKgLkBCEACyACQbQDaiAAOAIAIAC8IQMCQCACQbwDaigCACIEIAJBwANqKAIARw0AIARBAWohBQJAAkAgBA0AQQghBgwBCyAEQQJtIARqIQYLIAQgBiAFIAYgBUobIgVODQAgAUHwBmoiBCAEKAIAQQFqNgIAIAVBAnRBACgCuOYLQQAoApDYChECACEEAkAgAkHEA2ooAgAiA0UNACAEIAMgAigCvANBAnQQng8aAkAgAigCxAMiA0UNAEEAKAKw5gsiBkUNACAGQfAGaiIGIAYoAgBBf2o2AgALIANBACgCuOYLQQAoApTYChEAAAsgAiAFNgLAAyACIAQ2AsQDIAIoArQDIQMgAigCvAMhBAsgAkHEA2ooAgAgBEECdGogAzYCACACIAIoArwDQQFqNgK8AyABIAEoAtA2QX5xNgLQNgu0BgIHfwN9AkACQCABQQAoArDmCyICQegqaioCACIJIABBf2oiA7IiCpSTIACylSILi0MAAABPXUUNACALqCEEDAELQYCAgIB4IQQLAkACQCABIAlDAACAPyAEsiILIAtDAACAP18bIguSIAqUkyIBi0MAAABPXUUNACABqCEEDAELQYCAgIB4IQQLQwAAgD8gBLIiASABQwAAgD9fGyEBAkAgAigC7DQiBEG8A2ooAgAiBSAEQcADaigCAEcNACAFQQFqIQYCQAJAIAUNAEEIIQcMAQsg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OAIADwsgAUEwaioCACEDIAFBwABqKgIAIQQgAUHcAGoqAgAhBSABQfgDaioCACEGIAEqAiwhByAAIAEqAvQDIAEqAliTIAEqAjySIgg4AgAgACAIIAeSOAIIIAAgBCAGIAWTkiIEOAIEIABBDGogBCADkjgCAA8LIAAgASkCxAQ3AgAgAEEIaiABQcwEaikCADcCAA8LQc68BkGC6QRB49IAQZeyBBAAAAsgAUEYaioCACEEIAFBEGoqAgAhAyAAIAEqAgwiBSABKgIUkjgCCCAAIAM4AgQgACAFOAIAIABBDGogAyAEkjgCAAvRCAEEfQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDg0NAAECAwQFBgcICQoLDAsgACABKQLkATcCACAAQQhqIAFB7AFqKQIANwIADwsgACABKQL0ATcCACAAQQhqIAFB/AFqKQIANwIADwsgACABKQLEAjcCACAAQQhqIAFBzAJqKQIANwIADwsgACABKQKEAjcCACAAQQhqIAFBjAJqKQIANwIADwsgACABKQKUAjcCACAAQQhqIAFBnAJqKQIANwIADwsgA0EASA0IIAEoAgwiAiADQegAbGogAUEQaigCAE8NCCACIANB6ABsaiIDKgIIIQQgAyoCDCEFIABBDGogAUGIAmoqAgAiBiABKgK0AZI4AgAgACAFOAIIIAAgBjgCBCAAIAQ4AgAPCyADQQBIDQggASgCDCICIANB6ABsaiABQRBqKAIATw0IIAIgA0HoAGxqIgMqAjQhBCABQfgBaioCACEFIAMqAjghBiAAQQxqIAFBgAJqKgIAOAIAIAAgBjgCCCAAIAU4AgQgACAEOAIADwsgA0EASA0IIAEoAgwiAiADQegAbGogAUEQaigCAE8NCCAAIAIgA0HoAGxqIgEpAiA3AgAgAEEIaiABQShqKQIANwIADwsgA0EASA0IIAEoAgwiAiADQegAbGogAUEQaigCAE8NCCACIANB6ABsaiIDKgI0IQQgAyoCSCEFIABBDGogAUGIAmoqAgAiBiABKgK4AZI4AgAgACAFOAIIIAAgBjgCBCAAIAQ4AgAPCyADQQBIDQggASgCDCICIANB6ABsaiABQRBqKAIATw0IIAIgA0HoAGxqIgMqAjQhBCADKgJMIQUgAEEMaiABQYgC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hgQgA0EwahBDGiADQgA3AuABIANBgAJqQQBBACADQeABahCNBRoCQEEAEJEBRQ0AIAMgASAMQQFBABC6AwsgA0HgAWoQYRogDCgCHEEDbiEAQQAoArDmCyIFKALsNCECAkAgBSgC/D0iBUUNACAFLQCVBEUNACAFEKAECyACQdABaioCACEUIANBgICA/Hs2AvQBIAMgFDgC+AEgAyAANgLoASADQgA3AuwBIANC/////w83AuABAkAgA0HgAWoQZkUNAANAAkAgAygC4AEiEiADKALkAU4NACAMKAIYIBJBA2xqIQADQCADQcABakEQakIANwMAIANCADcDyAEgA0IANwPAASADQYACaiECQQAhBgNAIAAhBQJAIAhFDQAgCCAAQQF0ai8BACEFCyADQcABaiAGQQN0aiARIAVBFGxqIgUpAgA3AwAgBSoCACEUIAUqAgQhFSAFKgIIIRYgBUEMaioCACEXIANBKGogBSgCEDYCACADQSBqIBe7OQMAIANBGGogFrs5AwAgA0EQaiAVuzkDACADQebOCEGUmwYgBhs2AgAgAyAUuzkDCCADIAA2AgQgAEEBaiEAIAIgAiALIAJrQaTUCCADEENqIQIgBkEBaiIGQQNHDQALIANCADcCuAEgA0GAAmpBAEEAIANBuAFqEI0FGgJAQQAQkQFFDQAgCSAJKAL8OyIFQX5xNgL8OyAKIANBwAFqQQNB//+DeEEBQwAAgD8Q2QMgCSAFNgL8OwsgEkEBaiISIAMoAuQBSA0ACwsgA0HgAWoQZg0ACwsQlgYgA0HgAWoQYhoLIAxBKGoiDCABKAIIIARBKGxqSQ0ACwsQlgYLIANBsARqJAALgQcCB38CfSMAQfACayICJAAgACgCJCEDQQAoArDmCygCkDQhBCAAKAIAIQUgACgCECEGIAIgATYCUCACIAY2AlQgAiAFNgJYIAJB39kHQZbcCCADIARBfmoiAUgbNgJcIAJB8ABqQYACQZzWBCACQdAAahBDGgJAAkACQCADIAFODQBBAEEAKAKw5gtB7CtqEG0gAiACQfAAajYCMCAAQevZBCACQTBqEIwGIQNBARBuIAMNAQwCCyACIAJB8ABqNgJAIABB69kEIAJBwABqEIwGIQMCQEEAEJEBRQ0AQQAoArDmC0HYO2oiASAAQShqIABBMGpB//+DeEMAAAAA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DzgCACABQQFqIgFBDEcNAAsgAguXAQICfwF9AkAgACoCFCABWw0AIAAgATgCFEEAIQIDQAJAAkBD2w/JQCACskMAAIA/kiIEIAGTIASVEJAPlSIEi0MAAABPXUUNACAEqCEDDAELQYCAgIB4IQMLIAAgAmpBjAFqIANBgAQgA0GABEgbIgNBDCADQQxKGyIDQf8BIANB/wFIGzoAACACQQFqIgJBwABHDQALCwvpBQEDfwJAIAAoAgRBf0oNAEEAEDwhAQJAIAAoAggiAkUNACABIAIgACgCAEEobBCeDxogACgCCBA+CyAAQQA2AgQgACABNgIICyAAQQA2AgACQCAAQRBqKAIAQX9KDQBBABA8IQECQCAAQRRqKAIAIgJFDQAgASACIAAoAgxBAXQQng8aIAAoAhQQPgsgAEEANgIQIAAgATYCFAsgAEEANgIMAkAgAEEcaigCAEF/Sg0AQQAQPCEBAkAgAEEgaigCACICRQ0AIAEgAiAAKAIYQRRsEJ4PGiAAKAIgED4LIABBADYCHCAAIAE2AiALIABBADYCGCAAKAIsKAIoIQEgAEIANwJgIAAgATYCJCAAQegAakIANwIAIABB8ABqQgA3AgAgAEIANwI0IABBADYCKAJAIABBwABqKAIAQX9KDQBBABA8IQECQCAAQcQAaigCACICRQ0AIAEgAiAAKAI8QQR0EJ4PGiAAKAJEED4LIABBADYCQCAAIAE2AkQLIABBADYCPAJAIABBzABqKAIAQX9KDQBBABA8IQECQCAAQdAAaigCACICRQ0AIAEgAiAAKAJIQQJ0EJ4PGiAAKAJQED4LIABBADYCTCAAIAE2AlALIABBADYCSAJAIABB2ABqKAIAQX9KDQBBABA8IQECQCAAQdwAaigCACICRQ0AIAEgAiAAKAJUQQN0EJ4PGiAAKAJcED4LIABBADYCWCAAIAE2AlwLIABCgICAgBA3AnggAEEANgJUAkAgACgCACIBIAAoAgRHDQAgAUEBaiECAkACQCABDQBBCCEDDAELIAFBAm0gAWohAwsgASADIAIgAyACShsiAk4NACACQShsEDwhAQJAIAAoAggiA0UNACABIAMgACgCAEEobBCeDxogACgCCBA+CyAAIAI2AgQgACABNgIIIAAoAgAhAQsgACgCCCABQShsakEAQSgQoA8aIABBgICA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QYCAgBhxGyIDQf9vcSADIANBgCBxGyIDQRByIgcgAyAHIANBD3EbIApBgAJxGyIHNgIEIA0gBCkCADcCnAMCQAJAIAtFDQAgB0GAgIAYcSEDAkACQCAFQ///f38gB0GAgIAIcSIBQRh2G0P//39/IAVDAAAAAF4bIgVD//9/f1wiBA0AIANBgICACEcNAQsgBkMAAIAAQwAAAAAgA0GAgIAIRhs4AiAgBiAFQwAAAAAgBBs4AhwgBkEcahDSAgsCQCAPQYCAgBhxDQAgBkIANwIcIAZBHGoQ0wILIAYgBioCYCAGKgJYkzgCHCAGIAZB5ABqKgIAIAYqAlyTOAIgIAAgESAGQRxqQQAgAUENdhCpAhogDSAIKALsNCIDNgK0AyANIAMpApQENwL0ASANQfwBaiADQZwEaikCADcCACADQRhqKgIAIRIgAyoCFCETIAMqAgwhBSANQdgBaiADQRBqKgIAIhQ4AgAgDSAFOALUASANQeABaiAUIBKSOAIAIA1B3AFqIAUgE5I4AgAgDUHsAWogA0H8A2opAgA3AgAgDSADKQL0AzcC5AECQCADKgI8QwAAAABcDQAgA0HAAGoqAgBDAAAAAFwNACADKgJIQwAAAABbDQILQe2nBUHS6ARB9wJB74oEEAAACyANIAYpA1g3AuQBIA1B7AFqIAZB4ABqIgMpAwA3AgAgDSAGKQNYNwLUASANQdwBaiADKQMANwIAIA0gBikDWDcC9AEgDUH8AWogAykDADcCAAsgERDiAiANIA0oArQDIgBBjAJqKgIAOAKYASANIAApArQENwLEAiANQcwCaiAAQbwEaikCADcCACANIAAtAI8BOgCiBCANQdwCaiAAQZwEaikCADcCACANIAApApQENwLUAiANIAApAqQENwLkAiANQewCaiAAQawEaikCADcCACANIAlBkAJqKAIANgKkAyANIABB/AFqIgMpAgA3AoQDIA0gAEH0AWoiASkCADcCjAMgDSAAQeQBaikCADcClAMgDSAJQbQDaioCADgCqAMgDSAJQbwDaigCADYCrAMgA0IANwIAIAFCADcCACAHQYCAgAJxRSAHQYCIgAFxQQBHcSEDQwAAAAAhBUMAAIA/QwAAAAAgB0GABHEbIRMCQAJAAkAgB0GAhIAEcSIBQYAERg0AIAENASAIQfAqaioCACESDAIL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M7s5AwBDAAAAACE0IAFBoAJqQRhqQf3nB0GW3AggM0MAAAAAWxs2AgAgASAyuzkDqAIgASAxuzkDoAJBrtUEIAFBoAJqEOgEIAAqAqQBITEgACoCrAEhMiAAKgKwASEzIAFBgAJqQRhqIAAqAqABuzkDACABQYACakEQaiAzuzkDACABIDK7OQOIAiABIDG7OQOAAkGeogUgAUGAAmoQ6AQgACwAgAQhAiABIAAsAIEENgL0ASABIAI2AvABQbHvBSABQfABahDoBCAALACDBCECIAAsAIYEIQMgASAALACFBDYC6AEgASADNgLkASABIAI2AuABQanwBSABQeABahDoBAJAIAAoAlQiBEEBSA0AIABBEGooAgAhBSAAKAIMIQdBACECA0AgByACQegAbGoiAyAFTw0DAkAgAy0AAEEEcUUNACA0IAMqAhiSITQLIAJBAWoiAiAERw0ACyAEQQFIDQAgAUGoA2pBCGohCCABQdABaiEJIAFBzAFqIQogAUHIAWohCyABQcQBaiEMIAFBwAFqIQ0gAUG4AWohDiABQYABaiEPIAFB+ABqIRAgAUHwAGohESABQeAAaiESIAFB2ABqIRMgAUHQAGohFCABQcgAaiEVIAFBwABqIRYgAUE8aiEXIAFBOGohGCABQTRqIRkgAUEwaiEaIAFBLGohGyABQSRqIRwgAUEgaiEdIAFBGGohHiABQbABaiEfIAFBqAFqISAgAUGgAWohISABQZgBaiEiIAFBiAFqISMgAUGQAWohJCABQbwBaiElQQAhAwNAIAAoAgwgA0HoAGxqIgIgACgCEE8NBCAAIAMQnQQhBUHi6gdBltwIIAMgACwAjgRIGyEHQwAAAAAhNSACLQBZISYgAi0AWCEnIAItAF8hKCACLQBeISkgAi0AXSEqIAItAFwhKyACLQBaISwgAiwAUiEtIAIqAhgiMbshPCACKgIUuyE9IAIqAhC7IT4gAioCBLshPyACKgIMIjIgACoC9AEiNpO7IUAgAioCCCIzIDaTuyFBAkAgMUMAAAAAXkUNACAxIDSVQwAAyEKUITULIAItAGQhLiACQShqKgIAITYgAioCQCE3IAIqAkQhOCACKgJIITkgAioCTCE6IAIqAjQhMSACKgIgITsgAiwAViEvIAIoAjAhMCAJQbDNCEGW3AggAigCACIEQRBxGzYC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GGogDSANkiADKgJokiAKIAqSIAMqAmySEPsCIAMgCzgCTCADQdQAaiALIAMqAmSSOAIAIAMgCTYCSCADIAMqAmAgDJI4AlAgA0HgAGogCCoCABCuAiADQcgAaiAHQQAQrwJFDQAgA0HIAGogByADQccAaiADQcYAaiAGQbADaigCAEEJdEGACHEgAnIQ6gQhBEEXQRYgAy0ARhtBFSADLQBHG0MAAIA/EGghBiADQcgAaiAHQQEQfiADIAMpA0giDjcDOCADIAMpA1AiDzcDMCAFQdgqaioCACEKIAMgDjcDECADIA83AwggA0EQaiADQQhqIAZBASAKEHwgBSoC0CohCiADIAMqAkwgBSoC1CoiC5I4AiwgAyAKIAMqAkiSOAIoIAMgAyoCVCALkzgCJCADIAMqAlAgCpM4AiAgA0EoaiADQSBqIABBACADQegAaiAFQawraiADQcgAahB6CyADQfAAaiQAIAQLCwAgACABQQAQ6wQLTwICfwF9IwBBEGsiASQAQQAoArDmC0HUKmoiAioCACEDIAJBADYCACABQgA3AgggACABQQhqQYCAAhDrBCEAIAIgAzgCACABQRBqJAAgAAuRAgMDfwF+AX0jAEEwayIDJABBACEEQQAoArDmCygC7DQiBUEBOgCMAQJAAkAgBS0AjwENACABKgIAQwAAAABbDQEgASoCBEMAAAAAWw0BQQAhBCAFIABBABCAASEAIAMgASkCACIGNwMAIAMgBjcDICADQShqIANDAAAAAEMAAAAAEPsCIAUqAswBIQcgBSkCzAEhBiADQRxqIAVB0AFqKgIAIAMqAiySOAIAIAMgBjcDECADIAcgAyoCKJI4AhggA0EoakMAAIC/EK4CIANBEGogAEEAEK8CRQ0AIANBEGogACADQQ9qIANBDmogAhDqBCEECyADQTBqJAAgBA8LQYypBUG96ARB2gVBrvMEEAAAC+YDAwV/A30CfiMAQdAAayIEJABBACEFQQAoArDmCyIGKALsNCIHQQE6AIwBAkAgBy0AjwENAEEAIQUgByAAQQAQgAEhACACKgIAIQkgByoCzAEhCiAHKQLMASEMIARBzABqIAdB0AFqKgIAIAIqAgQiC5I4AgAgBCAMNwNAIAQgCiAJkjgCSEMAAIC/IQkCQCALEP4CYEUNACAGQdQqaioCACEJCyACIAkQ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Ay8BACIBIAQvAQBrIgAgACABSxs7AQAPCwJAIAFBK0cNACADKAIAIQACQAJAIAQoAgAiAUF/Sg0AQYCAgIB4IQRBgICAgHggAWsgAEoNAQtB/////wcgASAAaiIEIAFB/////wdzIABIGyAEIAFBAEobIQQLIAIgBDYCAA8LIAFBLUcNBSADKAIAIQACQAJAIAQoAgAiAUEBSA0AQYCAgIB4IQQgAUGAgICAeHIgAEoNAQtB/////wcgACABayIEIAFB/////wdqIABIGyAEIAFBAEgbIQQLIAIgBDYCAA8LAkAgAUErRw0AIAJBfyAEKAIAIgEgAygCAGoiACAAIAFJGzYCAA8LIAFBLUcNBCACQQAgAygCACIBIAQoAgBrIgAgACABSxs2AgAPCwJAIAFBK0cNACADKQMAIQUCQAJAIAQpAwAiBkJ/VQ0AQoCAgICAgICAgH8hB0KAgICAgICAgIB/IAZ9IAVVDQELQv///////////wAgBiAFfCIHIAZC////////////AIUgBVMbIAcgBkIAVRshBwsgAiAHNwMADwsgAUEtRw0DIAMpAwAhBQJAAkAgBCkDACIGQgFTDQBCgICAgICAgICAfyEHIAZCgICAgICAgICAf4QgBVUNAQtC////////////ACAFIAZ9IgcgBkL///////////8AfCAFUxsgByAGQgBTGyEHCyACIAc3AwAPCwJAIAFBK0cNACACQn8gBCkDACIGIAMpAwB8IgUgBSAGVBs3AwAPCyABQS1HDQIgAkIAIAMpAwAiBiAEKQMAfSIFIAUgBlYbNwMADwsCQCABQStHDQAgAiADKgIAIAQqAgCSOAIADwsgAUEtRw0BIAIgAyoCACAEKgIAkzgCAA8LAkAgAUErRw0AIAIgAysDACAEKwMAoDkDAA8LIAFBLUcNACACIAMrAwAgBCsDAKE5AwALDwtBzrwGQb3oBEHXDkHT7AQQAAAL+gkDBX8BfQF8IwBB0AFrIgUkAAN/QQAhBgJAAkACQAJAAkAgAC0AACIHQR9KDQAgB0EJRw0BDAQLIAdBIEYNAyAHQVZqQQJJDQEgB0EvRg0BCyAHIQgMAQsDQCAALQABIQggAEEBaiIJIQAgCEEJRg0AIAkhACAIQSBGDQALIAchBiAJIQALAkACQAJAIAhFDQAgAkEKTw0CIAVByAFq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0gpBiPMIQfABIABB7NIKQYzzCEHxASABEA1BBBDfECIAQcAANgIAQQQQ3xAiAUHAADYCAEHIhglBncsEQcDTCkGI8whB+QEgAEHA0wpBjPMIQfoBIAEQDUEEEN8QIgBBxAA2AgBBBBDfECIBQcQANgIAQciGCUH9gQRB/NMKQdTwCEH0ASAAQfzTCkHY8AhB9QEgARANQQQQ3xAiAEH7ATYCAEEEEN8QIgFB/AE2AgBByIYJQcnIBUGQ7whBiPMIQe4BIABBkO8IQYzzCEHvASABEA1BBBDfECIAQf0BNgIAQciGCUHDpgRBkO8IQYjzCEHuASAAQQBBAEEAQQAQDQsGAEHIhgkLDwACQCAARQ0AIAAQ4BALCy4BAX8jAEEQayICJAAgAkHonQQ2AgBBjc8IIAIQ5w8aIABBAjYCACACQRBqJAALJwEBfyMAQRBrIgIkACACQcKcBDYCAEGNzwggAhDnDxogAkEQaiQACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAAAgAigCDBAMIAIoAgwiABADIAJBEGokACAACzUBAX8jAEEQayIDJAAgACgCACEAIAMgAjYCDCABIANBDGogABEAACADKAIMEAMgA0EQaiQACw0AIAEgACgCAGotAAALDwAgASAAKAIAaiACOgAACw0AIAEgACgCAGooAgALDwAgASAAKAIAaiACNgIACw0AIAEgACgCAGoqAgALDwAgASAAKAIAaiACOAIACy4BAX8jAEEQayICJAAgAiABQSBqNgIIIABBxPAIIAJBCGoQAjYCACACQRBqJAALLgEBfyMAQRBrIgIkACACIAFBKGo2AgggAEHE8AggAkEIahACNgIAIAJBEGokAAtEAQF/IwBBEGsiAiQAAkACQCABKAIwIgENAEECIQEMAQsgAiABNgIIQczTCiACQQhqEAIhAQsgACABNgIAIAJBEGokAAsNACABIAAoAgBqKAIACw8AIAEgACgCAGogAjYCAAs/AQF/IwBBEGsiAiQAIAAgAkEEaiABQcoAahCSByIBEJMHGgJAIAEsAAtBf0oNACABKAIAEOAQCyACQRBqJAALUAEBfyMAQRBrIgIkACACQQRqIAEQ6QYgAEHKAGogAigCBCIAIAJBBGogAiwADyIBQQBIG0EnEIMQGgJAIAFBf0oNACAAEOAQCyACQRBqJAALRAEBfyMAQRBrIgIkAAJAAkAgASgCdCIBDQBBAiEBDAELIAIgATYCCEHo/gggAkEIahACIQELIAAgATYCACACQRBqJAAL7QIBAn9BpIcJQbyHCUHchwlBAEGY7whB/gFBhPAIQQBBhPAIQQBBr9QEQYbwCEH/ARAHQbypBEGAAhCBCUEIEN8QIgBBADYCBCAAQYECNgIAQaSHCUHrqQRBAkH4hwlBiPMIQYICIABBAEEAEA5BiqIGQYMCEIUJQQQQ3xAiAEGEAjYCAEEEEN8QIgFBhQI2AgBBpIcJQZyNBkGQ7whBiPMIQYYCIABBkO8IQYzzCEGHAiABEA1BBBDfECIAQQg2AgBBBBDfECIBQQg2AgBBpIcJQYuIBUG00wpBiPMIQYgCIABBtNMKQYzzCEGJAiABEA1BBBDfECIAQQw2AgBBBBDfECIBQQw2AgBBpIcJQbGsBEG00wpBiPMIQYgCIABBtNMKQYzzCEGJAiABEA1BBBDfECIAQYoCNgIAQaSHCUGCggVBkO8IQYjzCEGGAiAAQQBBAEEAQQAQDUHauQRBiwIQjglBzqYEQYwCEJAJCwYAQaSHCQsSAAJAIABFDQAgABDxDhDgEAsLewECfyMAQZABayIDJAACQAJAIAIoAgAiBEECRw0AIANBEGoQ/AMaDAELIAMgBDYCDCAEEAwgA0EQaiADQQxqEOgGIAQQAwsgAyABQQAgA0EQaiACKAIAQQJGGxDyDjYCiAEgAEHo/gggA0GIAWoQAjYCACADQZABaiQACysBAX9BBBDfECICIAE2AgBBpIcJIABBA0HshwlBhPEIQY0CIAJBAEEAEA4LBABBAQs5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAwALqAIBBH8jAEEgayICJAAgAkEANgIUIAJBfzYCECACQX82AgwgAkF/NgIIIAEgAkEUaiACQRBqIAJBDGogAkEIahD2DiAAEAEiATYCAEH2xgQQBCEAIAIoAgghAyACKAIMIQQgAigCECEFIAIgAigCFDYCHCACIAMgBCAFbGw2AhggASAAQaiICSACQRhqEAIiAxAFIAMQAyAAEANBhYgFEAQhACACIAIoAhA2AhggASAAQbTTCiACQRhqEAIiAxAFIAMQAyAAEANBo6wEEAQhACACIAIoAgw2AhggASAAQbTTCiACQRhqEAIiAxAFIAMQAyAAEANB64EFEAQhACACIAIoAgg2AhggASAAQbTTCiACQRhqEAIiAxAFIAMQAyAAEAMgAkEgaiQACysBAX9BBBDfECICIAE2AgBBpIcJIABBAkGAiAlBiPMIQY4CIAJBAEEAEA4LLgEBfyMAQRBrIgIkACACIAEoAgQ2AgggAEG00wogAkEIahACNgIAIAJBEGokAAtbAgF/AXwjAEEQayICJAAgASgCAEG00wogAkEMahAIIQMgAigCDBAJAkACQCADmUQAAAAAAADgQWNFDQAgA6ohAQwBC0GAgICAeCEBCyAAIAE2AgQgAkEQaiQACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAAAgAigCDBAMIAIoAgwiABADIAJBEGokACAACzUBAX8jAEEQayIDJAAgACgCACEAIAMgAjYCDCABIANBDGogABEAACADKAIMEAMgA0EQaiQACw0AIAEgACgCAGooAgALDwAgASAAKAIAaiACNgIACy4BAX8jAEEQayICJAAgAiABQSBqNgIIIABBxPAIIAJBCGoQAjYCACACQRBqJAALewEDfyMAQRBrIgIkAAJAIAAoAqgIQQFIDQBBACEDA0AgAiAAKAKwCCADQQJ0aigCADYCCEHo/gggAkEIahACIgQQDCACIAQ2AgggASgCAEEBQfjuCCACQQhqEBEQAyAEEAMgA0EBaiIDIAAoAqgISA0ACwsgAkEQaiQACysBAX9BBBDfECICIAE2AgBBpIcJIABBA0GwiAlBjPMIQY8CIAJBAEEAEA4LLAEBfyMAQRBrIgIkACACEO8ONgIIIABB6P4IIAJBCGoQAjYCACACQRBqJAALKwEBf0EEEN8QIgIgATYCAEGkhwkgAEECQYCICUGI8whBjgIgAkEAQQAQDgtMAQF/IwBBEGsiAyQAIAAoAgAhACADIAI2AgggA0EMaiABIANBCGogABEEACADKAIMEAwgAygCDCIAEAMgAygCCBADIANBEGokACAACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAAAgAigCDBAMIAIoAgwiABADIAJBEGokACAACzUBAX8jAEEQayIDJAAgACgCACEAIAMgAjYCDCABIANBDGogABEAACADKAIMEAMgA0EQ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AAsHACAAERAAC0EBAX8jAEEQayIEJAAgBCADNgIIIAQgATYCDCAEQQxqIAIgBEEIaiAAEQQAIAQoAggQAyAEKAIMEAMgBEEQaiQACzwBAX8jAEEQayIDJAAgA0IANwIIIAAgA0EIahDdBiEAIANCADcCACAAIAEgAiADEN0GENACIANBEGokAAsuAQF/IwBBEGsiAyQAIAMgATYCDCADQQxqIAIgABEAACADKAIMEAMgA0EQaiQACyoBAX8jAEEQayICJAAgAkIANwIIIAAgAkEIahDdBiABEN0BIAJBEGokAAtiAQF/IwBBEGsiBSQAIAUgAjYCCCAFIAE2AgwgBSADNgIEIAUgBDYCACAFQQxqIAVBCGogBUEEaiAFIAARCQAgBSgCABADIAUoAgQQAyAFKAIIEAMgBSgCDBADIAVBEGokAAubAQEDfyMAQRBrIgQkAAJAAkAgAigCACIFQQJGDQBBACgCxOYLIQYgBRAMIAYoAkwQAyAGIAIoAgA2AkwgBEIANwIIIAAgBEEIahDdBiECIARCADcCACACIAEgBBDdBkHMBkEAENECDAELIARCADcCCCAAIARBCGoQ3QYhAiAEQgA3AgAgAiABIAQQ3QZBAEEAENECCyAEQRBqJAALKAEBfyMAQRBrIgEkACABQgA3AgggACABQQhqEN0GENICIAFBEGokAAsLACABIAIgABEAAAsJACABIAARFQALKgEBfyMAQRBrIgIkACACQgA3AgggACACQQhqEN0GIAEQxQIgAkEQaiQACyoBAX8jAEEQayICJAAgAkIANwIIIAAgAkEIahDdBiABEMgCIAJBEGokAAsJACAAIAEQygILBQAQzgILVgEBfyMAQRBrIgQkACAEQQRqIAFBBGogASgCABDqBiEBIAQgAjYCACABIAQgAyAAEQQAIAQoAgAQAwJAIAEsAAtBf0oNACABKAIAEOAQCyAEQRBqJAALQgEDfyMAQRBrIgMkACAAKAIAIQQgACwACyEFIANCADcCCCAEIAAgBUEASBsgASADQQhqEN0GIAIQxgIgA0EQaiQAC0IBA38jAEEQayIDJAAgACgCACEEIAAsAAshBSADQgA3AgggBCAAIAVBAEgbIAEgA0EIahDdBiACEMkCIANBEGokAAtGAQF/IwBBEGsiBCQAIARBBGogAUEEaiABKAIAEOoG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IQAMAQtBgICAgHghAAsgABDlAiEADAELIAFBBGogABDpBiABKAIEIAFBBGogASwAD0EASBsQ5AIhACABLAAPQX9KDQAgASgCBBDgEAsgAUEQaiQAIAALFwAgACgCACAAIAAsAAtBAEgbQQAQ3QQLMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDeBCABQRBqJAALUgEBfyMAQRBrIgMkACADIAE2AgwgA0EMaiADIAJBBGogAigCABDqBiICIAARAAACQCACLAALQX9KDQAgAigCABDgEAsgAygCDBADIANBEGokAAtRAQF/IwBBIGsiAiQAIAJBGGpCADcDACACQgA3AxAgACACQRBqEOMGIQAgAiABKAIAIAEgASwAC0EASBs2AgAgAEHr2QQgAhDgBCACQSBqJAALMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDiBCABQRBqJAALMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDkBCABQRBqJAALawEBfyMAQSBrIgMkACADQRRqIAFBBGogASgCABDqBiIBIANBCGogAkEEaiACKAIAEOoGIgIgABEAAAJAIAIsAAtBf0oNACACKAIAEOAQCwJAIAEsAAtBf0oNACABKAIAEOAQCyADQSBqJAALSgEDfyMAQRBrIgIkACAAKAIAIQMgACwACyEEIAIgASgCACABIAEsAAtBAEgbNgIAIAMgACAEQQBIG0Hr2QQgAhDmBCACQRBqJAALMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDoBCABQRBqJAALWAEBfyMAQRBrIgMkACADQQRqIAFBBGogASgCABDqBiEBIAMgAjYCACABIAMgABECACECIAMoAgAQAwJAIAEsAAtBf0oNACABKAIAEOAQCyADQRBqJAAgAgtEAQN/IwBBEGsiAiQAIAAoAgAhAyAALAALIQQgAkIANwIIIAMgACAEQQBIGyABIAJBCGoQ3QYQ7AQhACACQRBqJAAgAAtGAQF/IwBBEGsiAiQAIAJBBGogAUEEaiABKAIAEOoGIgEgABEDACEAAkAgASwAC0F/Sg0AIAEoAgAQ4BALIAJBEGokACAACxUAIAAoAgAgACAALAALQQBIGxDtBAtGAQN/IwBBEGsiAyQAIAAoAgAhBCAALAALIQUgA0IANwIIIAQgACAFQQBIGyABIANBCGoQ3QYgAhDuBCEAIANBEGokACAAC0gBAX8jAEEQayIDJAAgA0EEaiABQQRqIAEoAgAQ6gYiASACIAARAgAhAgJAIAEsAAtBf0oNACABKAIAEOAQCyADQRBqJAAgAgsXACAAKAIAIAAgACwAC0EASBsgARDwBAuLAQEBfyMAQSBrIgckACAHIAI2AhggByABNgIcIAcgAzYCFCAHIAQ2AhAgByAFNgIMIAcgBjYCCCAHQRxqIAdBGGogB0EUaiAHQRBqIAdBDGogB0EIaiAAEQ8AIAcoAggQAyAHKAIMEAMgBygCEBADIAcoAhQQAyAHKAIYEAMgBygCHBADIAdBIGokAAvaAQIBfwF8IwBBwABrIgYkACAAKAIAQbTTCiAGQRhqEAghByAGKAIYEAkgBkIANwI4IAEgBkE4ahDdBiEAIAZCADcCMCACIAZBMGoQ3QYhASAGQgA3AiggAyAGQShqEN0GIQIgBkEYakEIakIANwMAIAZCADcDGCAEIAZBGGoQ4wYhAyAGQQhqQQhqQgA3AwAgBkIANwMIAkACQCAHmUQAAAAAAADgQWNFDQAgB6ohBAwBC0GAgICAeCEECyAEIAAgASACIAMgBSAGQQhqEOMGEPYEIAZBwABqJAALkQEBAX8jAEEgayIIJAAgCCACNgIYIAggATYCHCAIIAM2AhQgCCAENgIQIAggBjYCDCAIIAc2AgggCEEcaiAIQRhqIAhBFGogCEEQaiAFIAhBDGogCEEIaiAAEQoAIQIgCCgCCBADIAgoAgwQAyAIKAIQEAMgCCgCFBADIAgoAhgQAyAIKAIcEAMgCEEgaiQAIAIL4AECAX8BfCMAQcAAayIHJAAgACgCAEG00wogB0EYahAIIQggBygCGBAJIAdCADcCOCABIAdBOGoQ3QYhACAHQgA3AjAgAiAHQTBqEN0GIQEgB0IANwIoIAMgB0EoahDdBiECIAdBGGpBCGpCADcDACAHQgA3AxggBSAHQRhqEOMGIQMgB0EIakEIakIANwMAIAdCADcDCAJAAkAgCJlEAAAAAAAA4EFjRQ0AIAiqIQUMAQtBgICAgHghBQsgBSAAIAEgAiAEIAMgBiAHQQhqEOMGEPgEIQAgB0HAAGokACAAC2QBA38jAEEQayICJAAgACgCACEDIAAsAAshBCACIAE2AgwgAkGckglBCGoiATYCBCACQQRqEPYMIAMgACAEQQBIGyACQQhqEPkEIQAgAiABNgIEIAJBBGoQ9wwgAkEQaiQAIAALWgEBfyMAQRBrIgQkACAEQQRqIAFBBGogASgCABDqBiEBIAQgAjYCACABIAQgAyAAEQUAIQIgBCgCABADAkAgASwAC0F/Sg0AIAEoAgAQ4BALIARBEGokACACC2YBA38jAEEQayIDJAAgACgCACEEIAAsAAshBSADIAE2AgwgA0HwkglBCGoiATYCBCADQQRqEPoMIAQgACAFQQBIGyADQQhqIAIQ/AQhACADIAE2AgQgA0EEahD7DCADQRBqJAAgAAtIAQF/IwBBEGsiAyQAIANBBGogAUEEaiABKAIAEOoGIgEgAiAAEQIAIQICQCABLAALQX9KDQAgASgCABDgEAsgA0EQaiQAIAILFwAgACgCACAAIAAsAAtBAEgbIAEQ/gQLZgEDfyMAQRBrIgMkACAAKAIAIQQgACwACyEFIAMgATYCDCADQbSTCUEIaiIBNgIEIANBBGoQ/gwgBCAAIAVBAEgbIANBCGogAhD/BCEAIAMgATYCBCADQQRqEP8MIANBEGokACAAC0EBAX8jAEEQayIEJAAgBCADNgIIIAQgAjYCDCABIARBDGogBEEIaiAAET4AIAQoAggQAyAEKAIMEAMgBEEQaiQAC7oBAQN/IwBBIGsiAyQAIANCADcCGCABIANBGGoQ3QYhBEEAIQEgA0EQakEANgIAIANCADcCCCADQaCVCUEIaiIFNgIEIAMgAjYCFAJAIAIoAgBBAkYNACADQQRqEIINQQAgAygCCCADQQhqIAMsABNBAEgbIAMoAhQoAgBBAkYbIQELIANBiJQJQQhqNgIEIAAgBCABEIAFIAMgBTYCBAJAIAMsABNBf0oNACADKAIIEOAQCyADQSBqJAALxQEBBX8jAEEgayIDJAAgACgCACEEIAAsAAshBUEAIQYgA0EYakEANgIAIANCADcCECADQaCVCUEIaiIHNgIMIAQgACAFQQBIGyEAIAMgATYCHAJAIAEoAgBBAkYNACADQQxqEIINQQAgAygCECADQRBqIAMsABtBAEgbIAMoAhwoAgBBAkYb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EI4NIAQgACAFQQBIGyADQRBqIAIQ/wUhACADIAE2AgwgA0EMahCPDSADQSBqJAAgAAtmAQN/IwBBIGsiAyQAIAAoAgAhBCAALAALIQUgAyABNgIcIANBuJcJQQhqIgE2AgggA0EIahCSDSAEIAAgBUEASBsgA0EMaiACEIAGIQAgAyABNgIIIANBCGoQkw0gA0EgaiQAIAALZgEDfyMAQSBrIgMkACAAKAIAIQQgACwACyEFIAMgATYCHCADQYCXCUEIaiIBNgIMIANBDGoQjg0gBCAAIAVBAEgbIANBEGogAhCHBiEAIAMgATYCDCADQQxqEI8NIANBIGokACAAC3ABAX8jAEEgayIFJAAgBUEUaiABQQRqIAEoAgAQ6gYhASAFIAQ2AgwgBSACNgIQIAEgBUEQaiADIAVBDGogABEHACEEIAUoAgwQAyAFKAIQEAMCQCABLAALQX9KDQAgASgCABDgEAsgBUEgaiQAIAQL1AEBA38jAEEwayIEJAAgACgCACEFIAAsAAshBiAEIAE2AiwgBEG4lwlBCGo2AhggBEEYahCSDSAEQdSjCUEIajYCAEEAIQEgBSAAIAZBAEgbIQAgBCADNgIUIARBGGpBBGohBQJAIAMoAgBBAkYNACAEEO8NIAQoAhQoAgBBAkYNACAEQQRqIQELIAAgBSACIAEQgwYhACAEQdSjCUEIajYCAAJAIAQoAhQoAgBBAkYNACAEEPANCyAEQbiXCUEIajYCGCAEQRhqEJMNIARBMGokACAAC28BA38jAEEgayIEJAAgACgCACEFIAAsAAshBiAEQRhqQgA3AwAgBEIANwMQIAEgBEEQahDjBiEBIARCADcCCCAEIAMgBEEIahDdBikCADcDACAFIAAgBkEASBsgASACIAQQggYhACAEQSBqJAAgAAsVACAAKAIAIAAgACwAC0EASBsQjgYLbwEBfyMAQSBrIgMkACADQRRqIAFBBGogASgCABDqBiIBIANBCGogAkEEaiACKAIAEOoGIgIgABECACEAAkAgAiwAC0F/Sg0AIAIoAgAQ4BALAkAgASwAC0F/Sg0AIAEoAgAQ4BALIANBIGokACAAC04BA38jAEEQayICJAAgACgCACEDIAAsAAshBCACIAEoAgAgASABLAALQQBIGzYCACADIAAgBEEASBtB69kEIAIQiQYhASAC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AkBBAkYNACACKAJIEAwgASACKAJINgIQIAEgAigCQEEBQYyOCSABQRBqEBE2AgwgAkE0aiEDIAFBEGogAUEMahDpBgJAIAIsAD9Bf0oNACADKAIAEOAQCyADIAEpAhA3AgAgA0EIaiABQRBqQQhqKAIANgIAIAFBADoAGyABQQA6ABAgASgCDBADCyACLAA/IQMgAigCNCEEIAFBIGokACAEIAJBNGogA0EASBsLVwECfyABKAIAEAwgACABKAIANgIAIAIoAgQgAi0ACyIBIAHAQQBIIgMbIgFBBGoQxBAiBCABNgIAIARBBGogAigCACACIAMbIAEQng8aIAAgBDYCCCAAC4ABAgJ/AXwjAEEQayIBJAAgAUEANgIIA0AgAUEEaiAAKAIIIAFBCGoQ8wwgASgCBEHs0gogAUEMahAIIQMgASgCDBAJIAAgASgCCGpBBGogA0QAAAAAAAAAAGI6AAAgASgCBBADIAEgASgCCEEBaiICNgIIIAJFDQALIAFBEGokAAtmAQJ/IwBBEGsiASQAIAFBADYCBANAIAAoAgghAiABIAAtAAQ2AgggAUHs0gogAUEIahACNgIAIAIgAUEEaiABEPQMIAEoAgAQAyABIAEoAgRBAWoiAjYCBCACRQ0ACyABQRBqJAALJQAgAEGwjglBCGo2AgACQCAAKAIIKAIAQQJGDQAgABDwDAsgAAsoACAAQbCOCUEIajYCAAJAIAAoAggoAgBBAkYNACAAEPAMCyAAEOAQCz8BAX8jAEEQayIDJAAgASgCACEBIAMgAigCADYCCCAAIAFB2NMKIANBCGoQAiICEAo2AgAgAhADIANBEGokAAs/AQF/IwBBEGsiAyQAIAAoAgAhACADIAEoAgA2AgggAEHY0wogA0EIahACIgEgAigCABAFIAEQAyADQRBqJAALUgECfyMAQRBrIgEkAEEAKALE5gshAiABIAA2AghB1PQIIAFBCGoQAiIAEAwgASAANgIIIAIoAkxBAUH47gggAUEIahAREAMgABADIAFBEGokAAuAAQICfwF8IwBBEGsiASQAIAFBADYCCANAIAFBBGogACgCCCABQQhqEPMMIAEoAgRB7NIKIAFBDGoQCCEDIAEoAgwQCSAAIAEoAghqQQRqIANEAAAAAAAAAABiOgAAIAEoAgQQAyABIAEoAghBAWoiAjYC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AgQQAyABIAEoAghBAWoiAjYCCCACQQJJDQALIAFBEGokAAt1AQN/IwBBEGsiASQAQQAhAiABQQA2AgQDQCAAKAIMIQMgASAAIAJBAnRqQQRqKAIANgIIIAFBtNMKIAFBCGoQAjYCACADIAFBBGogARD0DCABKAIAEAMgASABKAIEQQFqIgI2AgQgAkECSQ0ACyABQRBqJAALFQAgAEHQmAlBCGo2AgAgABCXDSAACxgAIABB0JgJQQhqNgIAIAAQlw0gABDgEAukAQIDfwF8IwBBEGsiASQAIAFBADYCCANAIAFBBGogACgCECABQQhqEPMMIAEoAgRBtNMKIAFBDGoQCCEEIAEoAgwQCSAAIAEoAghBAnRqQQRqIQICQAJAIASZRAAAAAAAAOBBY0UNACAEqiEDDAELQYCAgIB4IQMLIAIgAzYCACABKAIEEAMgASABKAIIQQFqIgI2AgggAkEDSQ0ACyABQRBqJAALdQEDfyMAQRBrIgEkAEEAIQIgAUEANgIEA0AgACgCECEDIAEgACACQQJ0akEEaigCADYCCCABQbTTCiABQQhqEAI2AgAgAyABQQRqIAEQ9AwgASgCABADIAEgASgCBEEBaiICNgIEIAJBA0kNAAsgAUEQaiQACxUAIABBiJkJQQhqNgIAIAAQmw0gAAsYACAAQYiZCUEIajYCACAAEJsNIAAQ4BALpAECA38BfCMAQRBrIgEkACABQQA2AggDQCABQQRqIAAoAhQgAUEIahDzDCABKAIEQbTTCiABQQxqEAghBCABKAIMEAkgACABKAIIQQJ0akEEaiECAkACQCAEmUQAAAAAAADgQWNFDQAgBKohAwwBC0GAgICAeCEDCyACIAM2AgAgASgCBBADIAEgASgCCEEBaiICNgIIIAJBBEkNAAsgAUEQaiQAC3UBA38jAEEQayIBJABBACECIAFBADYCBANAIAAoAhQhAyABIAAgAkECdGpBBGooAgA2AgggAUG00wogAUEIahACNgIAIAMgAUEEaiABEPQMIAEoAgAQAyABIAEoAgRBAWoiAjYCBCACQQRJDQALIAFBEGokAAsVACAAQcCZCUEIajYCACAAEJ8NIAALGAAgAEHAmQlBCGo2AgAgABCfDSAAEOAQC8oBAgJ/AXwjAEEQayICJAAgACABNgIMIABBADYCCCAAQgA3AgAg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AiABQbQEajYCCCAAQcisCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQZQEajYCCCAAQcisCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQfQDajYCCCAAQcisCSACQQhqEAI2AgAgAkEQaiQACw0AIAEgACgCAGoqAgALDwAgASAAKAIAaiACOAIACy8BAX8jAEEQayICJAAgAiABQdgAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQeAAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQegAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQfAAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQfgAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQYABajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACw0AIAEgACgCAGotAAALDwAgASAAKAIAaiACOgAACy8BAX8jAEEQayICJAAgAiABQZwGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQaAGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQaQGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQagGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACzABAX8jAEEQayIBJAAgARCdASgC7DQ2AgggAEHwrQkgAUEIahACNgIAIAFBEGokAAswAQF/IwBBEGsiASQAIAEQnQEoAvA0NgIIIABB8K0JIAFBCGoQAjYCACABQRBqJAALMAEBfyMAQRBrIgEkACABEJ0BKAL0NDYCCCAAQfCtCSABQQhqEAI2AgAgAUEQaiQACzABAX8jAEEQayIBJAAgARCdASgC0DU2AgggAEHwrQkgAUEIahACNgIAIAFBEGokAAswAQF/IwBBEGsiASQAIAEQnQEoApA1NgIIIABBwNMKIAFB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AgA2AgBB95oIIAEQ3gRBACAAQQhqIgIQbUGAswdBABDkBEEBEG4gAUKAgKCWBDcCCAJAQYyDBCABQQhqEOwERQ0AIABBAToABgtDAAAAAEMAAIC/EOoCIAFCgICglgQ3AggCQEGpuAUgAUEIahDsBEUNACAAQQA6AAYLQd3cBCACQQAQ/wUaEO4BIAFBEGokAAsXAQF/AkBBACgCxI8MIgFFDQAgARA+CwuIBgEDfyAAQYACakEAQSQQoA8aIABBqAJqQZbcCBBXGiAAEIEPIABBAEGAAhCgDyIAQX82AqQCAkAgACgCjAIiASAAQZACaigCAEcNACABQQFqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiABQQJ0akHthQY2AgAgACAAKAKMAiICQQFqIgE2AowCAkAgASAAKAKQAkcNACACQQJqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiABQQJ0akG1+wU2AgAgACAAKAKMAiICQQFqIgE2AowCAkAgASAAKAKQAkcNACACQQJqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiABQQJ0akHnhQY2AgAgACAAKAKMAiICQQFqIgE2AowCAkAgASAAKAKQAkcNACACQQJqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiAB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ADYCnAcgAEEBNgKYByAAQTI2ApQHIABBgICAgHw2ApAHIABB/////wM2AowHIABBm////wM2AogHIABB/////wM2AoQHIABBADYCgAcgAEEBNgL8BiAAQTI2AvgGIABBADYC9AYgAEH/////BzYC8AYgAEGb////BzYC7AYgAEH/////BzYC6AYgAEIANwOQCCAAQgE3A+AIIABCMjcDgAkgAEKAgICAgICAgEA3A/gIIABC//////////8/NwPwCCAAQpv/////////PzcD2AggAEL//////////z83A9AIIABCADcDyAggAEIBNwPgBiAAQjI3A9gGIABCADcD0AYgAEL///////////8ANwPIBiAAQpv//////////wA3A8AGIABC////////////ADcDuAYgAEEANgK0BiAAQYCAgPwDNgKwBiAAQfmF1IB9NgKsBiAAQfmF1IAFNgKoBiAAQgA3A6AGIABCgICAgICAgPg/NwOYBiAAQoCA0LHS/pqGQzcDkAYgAEKAgNCx0v6ahsMANwOIBkGMnAZBABDeBEG8tAZBvIEMEPkEGkMAAAAAQwAAgL8Q6gJBhpoHEMsOQYKiBkEAQdzcC0PNzEw+IABBvwdqQQBBAC0AvIEMIgIbIABBvQdqQQAgAhtBAEEAELAFGkHxoQZBAUHd3AtDzcxMPiAAQboHakEAQQAtALyBDCICGyAAQbgHakEAIAIbQcjGBEEAELAFGkGyowZBAkHe3AtDzcxMPiAAQbQHakEAQQAtALyBDCICGyAAQbAHakEAIAIbQQBBABCwBRpBn6MGQQNB4NwLQ83MTD4gAEGqB2pBAEEALQC8gQwiAhsgAEGmB2pBACACG0HIxgRBABCwBRpBm6oGQQRB5NwLQ83MTD4gAEGcB2pBAEEALQC8gQwiAhsgAEGUB2pBACACG0EAQQAQsAUaQYiqBkEFQejcC0PNzEw+IABBgAdqQQBBAC0AvIEMIgIbIABB+AZqQQAgAhtByMYEQQAQsAUaQcelBkEGQfDcC0PNzEw+IABBkAhqQQBBAC0AvIEMIgIbIABBgAlqQQAgAhtBAEEAELAFGkG0pQZBB0H43AtDzcxMPiAAQcgIakEAQQAtALyBDCICGyAAQdgGakEAIAIbQQBBABCwBRpB6LQEQQhBgN0LQwrXozsgAEG0BmogAEGwBmpB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AgAgAEEVakIANwAAIABBEGpCADcCACAAQQhqIgFCADcCACAAQSBqQQBBlAgQoA8aIAFCgIKAgIAINwIAIAALiwEBA38CQCAAKAKoCCIBQQFIDQBBACECA0ACQCAAKAKwCCACQQJ0aigCACIDRQ0AIAMQ+Q4aIAMQPiAAKAKoCCEBCyACQQFqIgIgAUgNAAsLAkAgAEGwCGooAgAiAkUNACAAQgA3AqgIIAIQPiAAQQA2ArAICwJAIABBGGooAgAiAkUNACACED4LIAAL7gMCBH8BfSMAQYABayICJABBgAIQPCIDEPgOGiADEPMOIANBATsB0AEgA0HYAGohBAJAAkAgAUUNACAEIAFB+AAQnw8aDAELIAQgAkEIahD8A0H4ABCeDxogA0H0AGpBAToAACADQewAakKBgICAEDcCAAsCQCADQegAaioCACIGQwAAAABfRQ0AIANBgICAiwQ2AmhDAABgQSEGCwJAIANBogFqIgEtAAANACABQShB25wFQQAQQxogAyoCaCEGCyADQaABakGFATsBACADQYQBaiEEAkACQCAGQwAAUEGVIgaLQwAAAE9dRQ0AIAaoIQUMAQtBgICAgHghBQsgBCAFsjgCACADQRBqIAEQmREaIANBgICA/AM2AuABIAMgADYCVCADIAMqAmg4AjQCQCAAKAKoCCIBIABBrAhqKAIARw0AIAFBAWohBAJAAkAgAQ0AQQghBQwBCyABQQJtIAFqIQULIAEgBSAEIAUgBEobIgRODQAgBEECdBA8IQECQCAAQbAIaigCACIFRQ0AIAEgBSAAKAKoCEECdBCeDxogACgCsAgQPgsgACAENgKsCCAAIAE2ArAIIAAoAqgIIQELIABBsAhqKAIAIAFBAnRqIAM2AgAgACAAKAKoCEEBajYCqAggAkGAAWokACADC7gFAQN/AkAgACgCRCIBIABByABqKAIARw0AIAFBAWohAgJAAkAgAQ0AQQghAwwBCyABQQJtIAFqIQMLIAEgAyACIAMgAkobIgJODQAgAkEwbBA8IQECQCAAQcwAaigCACIDRQ0AIAEgAyAAKAJEQTBsEJ4PGiAAKAJMED4LIAAgAjYCSCAAIAE2AkwgACgCRCEBCyAAQcwAaigCACABQTBsakEAQTAQoA8aIAAgACgCRCICQQFqIgE2AkQCQCABIAAoAkhHDQAg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DQYgASAEQX9qIgRqLQAAIAYgBGotAABGDQALIA0hBCAOIQcMAgsgCCALayEEC0EAIQcLIAYgBGohBgwACwALQQAhBgsgAkGgCGokACAGC0EBAn8jAEEQayIBJABBfyECAkAgABCzDw0AIAAgAUEPakEBIAAoAiARBQBBAUcNACABLQAPIQILIAFBEGokACACC0cBAn8gACABNwNwIAAgACgCLCAAKAIEIgJrrDcDeCAAKAIIIQMCQCABUA0AIAMgAmusIAFXDQAgAiABp2ohAwsgACADNgJoC90BAgN/An4gACkDeCAAKAIEIgEgACgCLCICa6x8IQQCQAJAAkAgACkDcCIFUA0AIAQgBVkNAQsgABCJECICQX9KDQEgACgCBCEBIAAoAiwhAgsgAEJ/NwNwIAAgATYCaCAAIAQgAiABa6x8NwN4QX8PCyAEQgF8IQQgACgCBCEBIAAoAgghAwJAIAApA3AiBUIAUQ0AIAUgBH0iBSADIAFrrFkNACABIAWnaiEDCyAAIAM2AmggACAEIAAoAiwiAyABa6x8NwN4AkAgASADSw0AIAFBf2ogAjoAAAsgAgsQACAAQSBGIABBd2pBBUlyCzUAIAAgATcDACAAIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGIAJC////////P4OENwMIC+cCAQF/IwBB0ABrIgQkAAJAAkAgA0GAgAFIDQAgBEEgaiABIAJCAEKAgICAgICA//8AENkQIARBIGpBCGopAwAhAiAEKQMgIQECQCADQf//AU8NACADQYGAf2ohAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQ2RAgA0H9/wIgA0H9/wJIG0GCgH5qIQMgBEEQakEIaikDACECIAQpAxAhAQwBCyADQYGAf0oNACAEQcAAaiABIAJCAEKAgICAgICAORDZECAEQcAAakEIaikDACECIAQpA0AhAQJAIANB9IB+TQ0AIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQ2RAgA0HogX0gA0HogX1KG0Ga/gFqIQMgBEEwakEIaikDACECIAQpAzAhAQsgBCABIAJCACADQf//AGqtQjCGENkQIAAgBEEIaikDADcDCCAAIAQpAwA3AwAgBEHQAGokAAtLAgF+An8gAUL///////8/gyECAkACQCABQjCIp0H//wFxIgNB//8BRg0AQQQhBCADDQFBAkEDIAIgAIRQGw8LIAIgAIRQIQQLIAQL1QYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABDPEEUNACADIAQQjxAhBiACQjCIpyIHQf//AXEiCEH//wFGDQAgBg0BCyAFQRBqIAEgAiADIAQQ2RAgBSAFKQMQIgQgBUEQakEIaikDACIDIAQgAxDRECAFQQhqKQMAIQIgBSkDACEEDAELAkAgASACQv///////////wCDIgkgAyAEQv///////////wCDIgoQzxBBAEoNAAJAIAEgCSADIAoQzxBFDQAgASEEDAILIAVB8ABqIAEgAkIAQgAQ2RAgBUH4AGopAwAhAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGAkACQCAIRQ0AIAEhBAwBCyAFQeAAaiABIAlCAEKAgICAgIDAu8AAENkQIAVB6ABqKQMAIglCMIinQYh/aiEIIAUpA2AhBAsCQCAGDQAgBUHQAGogAyAKQgBCgICAgICAwLvAABDZECAFQdgAaikDACIKQjCIp0GIf2ohBiAFKQNQIQMLIApC////////P4NCgICAgICAwACEIQsgCUL///////8/g0KAgICAgIDAAIQhCQJAIAggBkwNAANAAkACQCAJIAt9IAQgA1StfSIKQgBTDQACQCAKIAQgA30iBIRCAFINACAFQSBqIAEgAkIAQgAQ2RAgBUEoaikDACECIAUpAyAhBAwFCyAKQgGGIARCP4iEIQkMAQsgCUIBhiAEQj+IhCEJCyAEQgGGIQQgCEF/aiIIIAZKDQALIAYhCAsCQAJAIAkgC30gBCADVK19IgpCAFkNACAJIQoMAQsgCiAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAENkQIAVBOGopAwAhAiAFKQMwIQQMAQsCQCAKQv///////z9WDQADQCAEQj+IIQMgCEF/aiEIIARCAYYhBCADIApCAYaEIgpCgICAgICAwABUDQALCyAHQYCAAnEhBgJAIAhBAEoNACAFQcAAaiAEIApC////////P4MgCEH4AGogBnKtQjCGhEIAQoCAgICAgMDDPxDZECAFQcgAaikDACECIAUpA0AhBAwBCyAKQv///////z+DIAggBnKtQjCGhCECCyAAIAQ3AwAgACACNwMIIAVBgAFqJAALHAAgACACQv///////////wCDNwMIIAAgATcDAAuHCQIFfwN+IwBBMGsiBCQAQgAhCQJAAkAgAkECSw0AIAJBAnQiAkHcxgpqKAIAIQUgAkHQxgpqKAIAIQYDQAJAAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAItAAAhAgwBCyABEIsQIQILIAIQjBANAAtBASEHAkACQCACQVVqDgMAAQABC0F/QQEgAkEtRhshBwJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARCLECECC0EAIQgCQAJAAkADQCACQSByIAhB5IAEaiwAAEcNAQJAIAhBBksNAAJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARCLECECCyAIQQFqIghBCEcNAAwCCwALAkAgCEEDRg0AIAhBCEYNASADRQ0CIAhBBEkNAiAIQQhGDQELAkAgASkDcCIJQgBTDQAgASABKAIEQX9qNgIECyADRQ0AIAhBBEkNACAJQgBTIQIDQAJAIAINACABIAEoAgRBf2o2AgQLIAhBf2oiCEEDSw0ACwsgBCAHskMAAIB/lBDTECAEQQhqKQMAIQogBCkDACEJDAILAkACQAJAIAgNAEEAIQgDQCACQSByIAhB0fsEaiwAAEcNAQJAIAhBAUsNAAJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARCLECECCyAIQQFqIghBA0cNAAwCCwALAkACQCAIDgQAAQECAQsCQCACQTBHDQACQAJAIAEoAgQiCCABKAJoRg0AIAEgCEEBajYCBCAILQAAIQgMAQsgARCLECEICwJAIAhBX3FB2ABHDQAgBEEQaiABIAYgBSAHIAMQkxAgBEEYaikDACEKIAQpAxAhCQwGCyABKQNwQgBTDQAgASABKAIEQX9qNgIECyAEQSBqIAEgAiAGIAUgByADEJQQIARBKGopAwAhCiAEKQMgIQkMBAtCACEJAkAgASkDcEIAUw0AIAEgASgCBEF/ajYCBAsQqg9BHDYCAAwBCwJAAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAItAAAhAgwBCyABEIsQIQILAkACQCACQShHDQBBASEIDAELQgAhCUKAgICAgIDg//8AIQogASkDcEIA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EGoiAigCACIGDQALIAIgADYCACAAIAQ2AhgLIAAgADYCDCAAIAA2AggPCyAEKAIIIgEgADYCDCAEIAA2AgggAEEANgIYIAAgBDYCDCAAIAE2AggLC2UCAX8BfgJAAkAgAA0AQQAhAgwBCyAArSABrX4iA6chAiABIAByQYCABEkNAEF/IAIgA0IgiKdBAEcbIQILAkAgAhDEECIARQ0AIABBfGotAABBA3FFDQAgAEEAIAIQoA8aCyAAC+gKAgR/BH4jAEHwAGsiBSQAIARC////////////AIMhCQJAAkACQCABUCIGIAJC////////////AIMiCkKAgICAgIDAgIB/fEKAgICAgIDAgIB/VCAKUBsNACADQgBSIAlCgICAgICAwICAf3wiC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCwJAIAYgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhBCABIQMMAgsCQCADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEEDAILAkAgASAKQoCAgICAgMD//wCFhEIAUg0AQoCAgICAgOD//wAgAiADIAGFIAQgAoVCgICAgICAgICAf4WEUCIGGyEEQgAgASAGGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQECQCABIAqEQgBSDQAgAyAJhEIAUg0CIAMgAYMhAyAEIAKDIQQMAgsgAyAJhFBFDQAgASEDIAIhBAwBCyADIAEgAyABViAJIApWIAkgClEbIgcbIQkgBCACIAcbIgtC////////P4MhCiACIAQgBxsiAkIwiKdB//8BcSEIAkAgC0IwiKdB//8BcSIGDQAgBUHgAGogCSAKIAkgCiAKUCIGG3kgBkEGdK18pyIGQXFqEM4QQRAgBmshBiAFQegAaikDACEKIAUpA2AhCQsgASADIAcbIQMgAkL///////8/gyEEAkAgCA0AIAVB0ABqIAMgBCADIAQgBFAiBxt5IAdBBnStfKciB0FxahDOEEEQIAdrIQggBUHYAGopAwAhBCAFKQNQIQMLIARCA4YgA0I9iIRCgICAgICAgASEIQEgCkIDhiAJQj2IhCEEIANCA4YhCiALIAKFIQMCQCAGIAhGDQACQCAGIAhrIgdB/wBNDQBCACEBQgEhCgwBCyAFQcAAaiAKIAFBgAEgB2sQzhAgBUEwaiAKIAEgBxDYECAFKQMwIAUpA0AgBUHAAGpBCGopAwCEQgBSrYQhCiAFQTBqQQhqKQMAIQELIARCgICAgICAgASEIQwgCUIDhiEJAkACQCADQn9VDQBCACEDQgAhBCAJIAqFIAwgAYWEUA0CIAkgCn0hAiAMIAF9IAkgClStfSIEQv////////8DVg0BIAVBIGogAiAEIAIgBCAEUCIHG3kgB0EGdK18p0F0aiIHEM4QIAYgB2shBiAFQShqKQMAIQQgBSkDICECDAELIAEgDHwgCiAJfCICIApUrXwiBEKAgICAgICACINQDQAgAkIBiCAEQj+GhCAKQgGDhCECIAZBAWohBiAEQgGIIQQLIAtCgICAgICAgICAf4MhCgJAIAZB//8BSA0AIApCgICAgICAwP//AIQhBEIAIQMMAQtBACEHAkACQCAGQQBMDQAgBiEHDAELIAVBEGogAiAEIAZB/wBqEM4QIAUgAiAEQQEgBmsQ2BAgBSkDACAFKQMQIAVBEGpBCGopAwCEQgBSrYQhAiAFQQhqKQMAIQQLIAJCA4ggBEI9hoQhAyAHrUIwhiAEQgOIQv///////z+DhCAKhCEEIAKnQQdxIQYCQAJAAkACQAJAENYQDgMAAQIDCyAEIAMgBkEES618IgogA1StfCEEAkAgBkEERg0AIAohAwwDCyAEIApCAYMiASAKfCIDIAFUrXwhBAwDCyAEIAMgCkIAUiAGQQBHca18IgogA1StfCEEIAohAwwBCyAEIAMgClAgBkEAR3GtfCIKIANUrXwhBCAKIQMLIAZFDQELENcQGgsgACADNwMAIAAgBDcDCCAFQfAAaiQAC1MBAX4CQAJAIANBwABxRQ0AIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAUHAACADa62IIAIgA60iBIaEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC+ABAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvYAQIBfwJ+QX8hBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNACAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwsgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC+cQAgV/D34jAEHQAmsiBSQAIARC////////P4MhCiACQv///////z+DIQsgBCAChUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEMDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEMIAMhAQwCCwJAIAEgDUKAgICAgIDA//8AhYRCAFINAAJAIAMgAkKAgICAgIDA//8AhYRQRQ0AQgAhAUKAgICAgIDg//8AIQwMAwsgDEKAgICAgIDA//8AhCEMQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINAEIAIQEMAgsCQCABIA2EQgBSDQBCgICAgICA4P//ACAMIAMgAoRQGyEMQgAhAQwCCwJAIAMgAoRCAFINACAMQoCAgICAgMD//wCEIQxCACEBDAILQQAhCAJAIA1C////////P1YNACAFQcACaiABIAsgASALIAtQIggbeSAIQQZ0rXynIghBcWoQzhBBECAIayEIIAVByAJqKQMAIQsgBSkDwAIhAQsgAkL///////8/Vg0AIAVBsAJqIAMgCiADIAogClAiCRt5IAlBBnStfKciCUFxahDOECAJIAhqQXBqIQggBUG4AmopAwAhCiAFKQOwAiEDCyAFQaACaiADQjGIIApCgICAgICAwACEIg5CD4aEIgJCAEKAgICAsOa8gvUAIAJ9IgRCABDaECAFQZACakIAIAVBoAJqQQhqKQMAfUIAIARCABDaECAFQYACaiAFKQOQAkI/iCAFQZACakEIaikDAEIBhoQiBEIAIAJCABDaECAFQfABaiAEQgBCACAFQYACakEIaikDAH1CABDaECAFQeABaiAFKQPwAUI/iCAFQfABakEIaikDAEIBhoQiBEIAIAJCABDaECAFQdABaiAEQgBCACAFQeABakEIaikDAH1CABDaECAFQcABaiAFKQPQAUI/iCAFQdABakEIaikDAEIBhoQiBEIAIAJCABDaECAFQbABaiAEQgBCACAFQcABakEIaikDAH1CABDaECAFQaABaiACQgAgBSkDsAFCP4ggBUGwAWpBCGopAwBCAYaEQn98IgRCABDaECAFQZABaiADQg+GQgAgBEIAENoQIAVB8ABqIARCAEIAIAVBoAFqQQhqKQMAIAUpA6ABIgogBUGQAWpBCGopAwB8IgIgClStfCACQgFWrXx9QgAQ2hAgBUGAAWpCASACfUIAIARCABDaECAIIAcgBmtqIQYCQAJAIAUpA3AiD0IBhiIQIAUpA4ABQj+IIAVBgAFqQQhqKQMAIhFCAYaEfCINQpmTf3wiEkIgiCICIAtCgICAgICAwACEIhNCAYYiFEIgiCIEfiIVIAFCAYYiFkIgiCIKIAVB8ABqQQhqKQMAQgGGIA9CP4iEIBFCP4h8IA0gEFStfCASIA1UrXxCf3wiD0IgiCINfnwiECAVVK0gECAPQv////8PgyIPIAFCP4giFyALQgGGhEL/////D4MiC358IhEgEFStfCANIAR+fCAPIAR+IhUgCyANfnwiECAVVK1CIIYgEEIgiIR8IBEgEEIghnwiECARVK18IBAgEkL/////D4MiEiALfiIVIAIgCn58IhEgFVStIBEgDyAWQv7///8PgyIVfnwiGCARVK18fCIRIBBUrXwgESASIAR+IhAgFSANfnwiBCACIAt+fCINIA8gCn58Ig9CIIggBCAQVK0gDSAEVK18IA8gDVStfEIghoR8IgQgEVStfCAEIBggAiAVfiICIBIgCn58IgpCIIggCiACVK1CIIaEfCICIBhUrSACIA9CIIZ8IAJUrXx8IgIgBFStfCIEQv////////8AVg0AIBQgF4QhEyAFQdAAaiACIAQgAyAOENoQIAFCMYYgBUHQAGpBCGopAwB9IAUpA1AiAUIAUq19IQ0gBkH+/wBqIQZCACABfSEKDAELIAVB4ABqIAJCAYggBEI/hoQiAiAEQgGIIgQgAyAOENoQIAFCMIYgBUHgAGpBCGopAwB9IAUpA2AiCkIAUq19IQ0gBkH//wBqIQZCACAKfSEKIAEhFgsCQCAGQf//AUgNACAMQoCAgICAgMD//wCEIQxCACEBDAELAkACQCAGQQFIDQAgDUIBhiAKQj+IhCENIAatQjCGIARC////////P4OEIQ8gCkIBhiEEDAELAkAgBkGPf0oNAEIAIQEMAgsgBUHAAGogAiAEQQEgBmsQ2BAgBUEwaiAWIBMgBkHwAGoQzhAgBUEgaiADIA4gBSkDQCICIAVBwABqQQhqKQMAIg8Q2hAgBUEwakEIaikDACAFQSBqQQhqKQMAQgGGIAUpAyAiAUI/iIR9IAUpAzAiBCABQgGGIgFUrX0hDSAEIAF9IQQLIAVBEGogAyAOQgNCABDaECAFIAMgDkIFQgAQ2hAgDyACIAJCAYMiASAEfCIEIANWIA0gBCABVK18IgEgDlYgASAOURutfCIDIAJUrXwiAiADIAJCgICAgICAwP//AFQgBCAFKQMQViABIAVBEGpBCGopAwAiAlYgASACURtxrXwiAiADVK18IgMgAiADQoCAgICAgMD//wBUIAQgBSkDAFYgASAFQQhqKQMAIgRWIAEgBFEbca18IgEgAlStfCAMhCEMCyAAIAE3AwAgACAMNwMIIAVB0AJqJAALjgICAn8DfiMAQRBrIgIkAAJAAkAgAb0iBEL///////////8AgyIFQoCAgICAgIB4fEL/////////7/8AVg0AIAVCPIYhBiAFQgSIQoCAgICAgICAPHwhBQwBCwJAIAVCgICAgICAgPj/AFQNACAEQjyGIQYgBEIEiEKAgICAgIDA//8AhCEFDAELAkAgBVBFDQBCACEGQgAhBQwBCyACIAVCACAEp2dBIGogBUIgiKdnIAVCgICAgBBUGyIDQTFqEM4QIAJBCGopAwBCgICAgICAwACFQYz4ACADa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIARCgICAgICAgICAf4OENwMIIAJBEGokAAvhAQIDfwJ+IwBBEGsiAiQAAkACQCABvCIDQf////8HcSIEQYCAgHxqQf////cHSw0AIAStQhmGQoCAgICAgIDAP3whBUIAIQYMAQsCQCAEQYCAgPwHSQ0AIAOtQhmGQoCAgICAgMD//wCEIQVCACEGDAELAkAgBA0AQgAhBkIAIQUMAQsgAiAErUIAIARnIgRB0QBqEM4QIAJBCGopAwBCgICAgICAwACFQYn/ACAEa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIANBgICAgHhxrUIghoQ3AwggAkEQaiQAC40BAgJ/An4jAEEQayICJAACQAJAIAENAEIAIQRCACEFDAELIAIgASABQR91IgNzIANrIgOtQgAgA2ciA0HRAGoQzhAgAkEIaikDAEKAgICAgIDAAIVBnoABIANrrUIwhnwgAUGAgICAeHGtQiCGhCEFIAIpAwAhBAsgACAENwMAIAAgBTcDCCACQRBqJAALcgIBfwJ+IwBBEGsiAiQAAkACQCABDQBCACEDQgAhBAwBCyACIAGtQgAgAWciAUHRAGoQzhAgAkEIaikDAEKAgICAgIDAAIVBnoABIAFrrUIwhnwhBCACKQMAIQMLIAAgAzcDACAAIAQ3AwggAkEQaiQACwQAQQALBABBAAtTAQF+AkACQCADQcAAcUUNACACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAuaCwIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQogBCAChUKAgICAgICAgIB/gyELIAJC////////P4MiDEIgiCENIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyIOQoCAgICAgMD//wBUIA5CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCELDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCELIAMhAQwCCwJAIAEgDkKAgICAgIDA//8AhYRCAFINAAJAIAMgAoRQRQ0AQoCAgICAgOD//wAhC0IAIQEMAwsgC0KAgICAgIDA//8AhCELQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINACABIA6EIQJCACEBAkAgAlBFDQBCgICAgICA4P//ACELDAMLIAtCgICAgICAwP//AIQhCwwCCwJAIAEgDoRCAFINAEIAIQEMAgsCQCADIAKEQgBSDQBCACEBDAILQQAhCAJAIA5C////////P1YNACAFQdAAaiABIAwgASAMIAxQIggbeSAIQQZ0rXynIghBcWoQzhBBECAIayEIIAVB2ABqKQMAIgxCIIghDSAFKQNQIQELIAJC////////P1YNACAFQcAAaiADIAogAyAKIApQIgkbeSAJQQZ0rXynIglBcWoQzhAgCCAJa0EQaiEIIAVByABqKQMAIQogBSkDQCEDCyADQg+GIg5CgID+/w+DIgIgAUIgiCIEfiIPIA5CIIgiDiABQv////8PgyIBfnwiEEIghiIRIAIgAX58IhIgEVStIAIgDEL/////D4MiDH4iEyAOIAR+fCIRIANCMYggCkIPhiIUhEL/////D4MiAyABfnwiCiAQQiCIIBAgD1StQiCGhHwiDyACIA1CgIAEhCIQfiIVIA4gDH58Ig0gFEIgiEKAgICACIQiAiABfnwiFCADIAR+fCIWQiCGfCIXfCEBIAcgBmogCGpBgYB/aiEGAkACQCACIAR+IhggDiAQfnwiBCAYVK0gBCADIAx+fCIOIARUrXwgAiAQfnwgDiARIBNUrSAKIBFUrXx8IgQgDlStfCADIBB+IgMgAiAMfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgFkIgiCANIBVUrSAUIA1UrXwgFiAUVK18QiCGhHwiBCACVK18IAQgDyAKVK0gFyAPVK18fCICIARUrXwiBEKAgICAgIDAAINQDQAgBkEBaiEGDAELIBJCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIBJCAYYhEiADIAFCAYaEIQELAkAgBkH//wFIDQAgC0KAgICAgIDA//8AhCELQgAhAQwBCwJAAkAgBkEASg0AAkBBASAGayIHQf8ASw0AIAVBMGogEiABIAZB/wBqIgYQzhAgBUEgaiACIAQgBhDOECAFQRBqIBIgASAHENgQIAUgAiAEIAcQ2BAgBSkDICAFKQMQhCAFKQMwIAVBMGpBCGopAwCEQgBSrYQhEiAFQSBqQQhqKQMAIAVBEGpBCGopAwCEIQEgBUEIaikDACEEIAUpAwAhAgwCC0IAIQEMAgsgBq1CMIYgBEL///////8/g4QhBAsgBCALhCELAkAgElAgAUJ/VSABQoCAgICAgICAgH9RGw0AIAsgAkIBfCIBUK18IQsMAQsCQCASIAFCgICAgICAgICAf4WEQgBRDQAgAiEBDAELIAsgAiACQgGDfCIBIAJUrXwhCwsgACABNwMAIAAgCzcDCCAFQeAAaiQAC3UBAX4gACAEIAF+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgA0L/////D4MgAiABfnwiAUIgiHw3AwggACABQiCGIAVC/////w+DhDcDAAtIAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRDNECAFKQMAIQQgACAFQQhqKQMANwMIIAAgBDcDACAFQRBqJAAL5AMCAn8CfiMAQSBrIgIkAAJAAkAgAUL///////////8AgyIEQoCAgICAgMD/Q3wgBEKAgICAgIDAgLx/fFoNACAAQjyIIAFCBIaEIQQCQCAAQv//////////D4MiAEKBgICAgICAgAhUDQAgBEKBgICAgICAgMAAfCEFDAILIARCgICAgICAgIDAAHwhBSAAQoCAgICAgICACFINASAFIARCAYN8IQUMAQsCQCAAUCAEQoCAgICAgMD//wBUIARCgICAgICAwP//AFEbDQAgAEI8iCABQgSGhEL/////////A4NCgICAgICAgPz/AIQhBQwBC0KAgICAgICA+P8AIQUgBEL///////+//8MAVg0AQgAhBSAEQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQzhAgAiAAIARBgfgAIANrENgQIAIpAwAiBEI8iCACQQhqKQMAQgSGhCEFAkAgBEL//////////w+DIAIpAxAgAkEQakEIaikDAIRCAFKthCIEQoGAgICAgICACFQNACAFQgF8IQUMAQsgBEKAgICAgICAgAhSDQAgBUIBgyAFfCEFCyACQSBqJAAgBSABQoCAgICAgICAgH+DhL8LxAMCA38BfiMAQSBrIgIkAAJAAkAgAUL///////////8AgyIFQoCAgICAgMC/QHwgBUKAgICAgIDAwL9/fFoNACABQhmIpyEDAkAgAFAgAUL///8PgyIFQoCAgAhUIAVCgICACFEbDQAgA0GBgICABGohBAwCCyADQYCAgIAEaiEEIAAgBUKAgIAIhYRCAFINASAEIANBAXFqIQQMAQsCQCAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbDQAgAUIZiKdB////AXFBgICA/gdyIQQMAQtBgICA/AchBCAFQv///////7+/wABWDQBBACEEIAVCMIinIgNBkf4ASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIFIANB/4F/ahDOECACIAAgBUGB/wAgA2sQ2BAgAkEIaikDACIFQhmIpyEEAkAgAikDACACKQMQIAJBEGpBCGopAwCEQgBSrYQiAFAgBUL///8PgyIFQoCAgAhUIAVCgICACFEbDQAgBEEBaiEEDAELIAAgBUKAgIAIhYRCAFINACAEQQFxIARqIQQLIAJBIGokACAEIAFCIIinQYCAgIB4cXK+C0UBAn8jAEEQayICJABBACEDAkAgAEEDcQ0AIAEgAHANACACQQxqIAAgARDJECEAQQAgAigCDCAAGyEDCyACQRBqJAAgAws2AQF/IABBASAAQQFLGyEBAkADQCABEMQQIgANAQJAEMQRIgBFDQAgABEGAAwBCwsQJwALIAALBwAgABDFEAs/AQJ/IAFBBCABQQRLGyECIABBASAAQQFLGyEAAkADQCACIAAQ4hAiAw0BEMQRIgFFDQEgAREGAAwACwALIAMLIQEBfyAAIAAgAWpBf2pBACAAa3EiAiABIAIgAUsbEN4QCwcAIAAQ5BALBwAgABDFEAsQACAAQaTWCkEIajYCACAACzwBAn8gARCAECICQQ1qEN8QIgNBADYCCCADIAI2AgQgAyACNgIAIAAgAxDnECABIAJBAWoQng82AgAgAAsHACAAQQxqCyAAIAAQ5RAiAEGU1wpBCGo2AgAgAEEEaiABEOYQGiAACwQAQQELBAAgAAsNACAAEOwQLQALQQd2CwcAIAAQ7RALBAAgAAsYAAJAIAAQ6xBFDQAgABD1EA8LIAAQ9hALHwEBf0EKIQECQCAAEOsQRQ0AIAAQ9xBBf2ohAQsgAQsYAAJAIAAQ6xBFDQAgABD4EA8LIAAQ+RALBAAgAAsLACAAIAEgAhD6EAs4AQF/IwBBEGsiAyQAIAAgAhD7ECAAIAIQ/BAgA0EAOgAPIAEgAmogA0EPahD9ECADQRBqJAAgAAvHAgEDfyMAQRBrIggkAAJAIAAQ/hAiCSABQX9zaiACSQ0AIAAQ8BAhCgJAIAlBAXZBcGogAU0NACAIIAFBAXQ2AgwgCCACIAFqNgIEIAhBBGogCEEMahD/ECgCABCAEUEBaiEJCyAIQQRqIAAQgREgCRCCESAIKAIEIgkgCCgCCBCDESAAEIQRAkAgBEUNACAJEPEQIAoQ8RAgBBCFERoLAkAgBkUNACAJEPEQIARqIAcgBhCFERoLIAMgBSAEaiIHayECAkAgAyAHRg0AIAkQ8RAgBGogBmogChDxECAEaiAFaiACEIURGgsCQCABQQFqIgFBC0YNACAAEIERIAogARCGEQsgACAJEIcRIAAgCCgCCBCIESAAIAYgBGogAmoiBBCJESAIQQA6AAwgCSAEaiAIQQxqEP0QIAhBEGokAA8LIAAQlAcACwoAIAAQ7BAoAgQLDgAgABDsEC0AC0H/AHELEQAgABDsECgCCEH/////B3ELCgAgABCPESgCAAsKACAAEI8REJARCwsAIAAgASACEJ8PCxwAAkAgABDrEEUNACAAIAEQiREPCyAAIAEQixELAgALDAAgACABLQAAOgAACxkAIAAQjBEQjREiACAAEI4RQQF2S3ZBcGoLCQAgACABEJwRCy0BAX9BCiEBAkAgAEELSQ0AIABBAWoQkxEiACAAQX9qIgAgAEELRhshAQsgAQsHACAAEJIRCxkAIAEgAhCRESEBIAAgAjYCBCAAIAE2AgALAgALAgALDgAgASACIAAQlBEaIAALCwAgACABIAIQlxELDAAgABCPESABNgIACzoBAX8gABCPESICIAIoAghBgICAgHhxIAFB/////wdxcjYCCCAAEI8RIgAgACgCCEGAgICAeHI2AggLDAAgABCPESABNgIECwcAIABBC0kLLQEBfyAAEI8RIgIgAi0AC0GAAXEgAXI6AAsgABCPESIAIAAtAAtB/wBxOgALCwcAIAAQnhELBQAQjhELBQAQnxELBwAgABChEQsEACAACxoAAkAgABCNESABTw0AEJcHAAsgAUEBEKIRCwcAIAAQphELCgAgAEEPakFwcQsOACAAIAAgAWogAhCnEQsHACAAEJYRCwcAIAAQgBALCwAgASACQQEQvhELTAECfwJAIAAQ7xAiAyACSQ0AIAAQ8BAQ8RAiAyABIAIQ8hAaIAAgAyACEPMQDwsgACADIAIgA2sgABDuECIEQQAgBCACIAEQ9BAgAAsOACAAIAEgARCVERCYEQtqAQF/IwBBEGsiAiQAIAIgATYCDAJAIAAQ/hAgAUkNAAJAIAAQ7xAgAU8NACACIAAQ7hA2AgggAkEMaiACQQhqEP8QKAIAEIARIgEgABDvEEYNACAAIAEQmxELIAJBEGokAA8LIAAQlAcAC5ICAQd/IwBBEGsiAiQAIAAQ7xAhAyAAEO4QIQQCQAJAAkAgARCKESIFRQ0AQQEhBiABQQFqIQcgABD5ECEBIAAQ+BAhCAwBCyABQQFqIQgCQAJAIAMgAU8NACACQQhqIAAQgREgCBCCESACKAIMIQcgAigCCCEBDAELIAJBCGogABCBESAIEIIRIAIoAggiAUUNAiACKAIMIQcLIAEgBxCDESAAEOsQIQYgABDwECEICyABEPEQIAgQ8RAgABDuEEEBahCFERoCQCAGRQ0AIAAQgREgCCADQQFqEIYRCwJAAkAgBQ0AIAAgBxCIESAAIAQQiREgACABEIcRDAELIAAgBBCLEQsgABCEEQsgAkEQaiQACykBAn8jAEEQayICJAAgAkEPaiAAIAEQnREhAyACQRBqJAAgASAAIAMbCw0AIAEoAgAgAigCAEkLBwAgABCgEQsEAEF/CwQAIAALBAAgAAsaAAJAIAEQoxFFDQAgACABEKQRDwsgABClEQsHACAAQQhLCwkAIAAgARDhEAsHACAAEN8QCwQAIAALKwEBfyMAQRBrIgMkACADQQhqIAAgASACEKgRIAMoAgwhAiADQRBqJAAgAgsNACAAIAEgAiADEKkRCw0AIAAgASACIAMQqhELaQEBfyMAQSBrIgQkACAEQRhqIAEgAhCrESAEQRBqIARBDGogBCgCGCAEKAIcIAMQrBEQrREgBCABIAQoAhAQrhE2AgwgBCADIAQoAhQQrxE2AgggACAEQQxqIARBCGoQsBEgBEEgaiQACwsAIAAgASACELERCwcAIAAQsxELDQAgACACIAMgBBCyEQsJACAAIAEQtRELCQAgACABELYRCwwAIAAgASACELQRGgs4AQF/IwBBEGsiAyQAIAMgARC3ETYCDCADIAIQtxE2AgggACADQQxqIANBCGoQuBEaIANBEGokAAtAAQF/IwBBEGsiBCQAIAQgAjYCDCAEIAMgASACIAFrIgIQnw8gAmo2AgggACAEQQxqIARBCGoQuhEgBEEQaiQACwcAIAAQ8RALGAAgACABKAIANgIAIAAgAigCADYCBCAACwkAIAAgARC8EQsNACAAIAEgABDxEGtqCwcAIAAQuRELGAAgACABKAIANgIAIAAgAigCADYCBCAACwcAIAAQ6hALDAAgACABIAIQuxEaCxgAIAAgASgCADYCACAAIAIoAgA2AgQgAAsJACAAIAEQvRELDQAgACABIAAQ6hBragseAAJAIAIQoxFFDQAgACABIAIQvxEPCyAAIAEQwBELCQAgACACEMERCwcAIAAQwhELCQAgACABEOMQCwcAIAAQ4BALBwAgACgCAAsJAEG4nwwQwxELDwAgAEHQAGoQxBBB0ABqCwcAIAAQ8xELAgALAgALCgAgABDGERDgEAsKACAAEMYREOAQCwoAIAAQxhEQ4BALCgAgABDGERDgEAsKACAAEMYREOAQCwsAIAAgAUEAEM8RCzAAAkAgAg0AIAAoAgQgASgCBEYPCwJAIAAgAUcNAEEBDwsgABDQESABENAREP4PRQsHACAAKAIECwQAQQALrQEBAn8jAEHAAGsiAyQAQQEhBAJAIAAgAUEAEM8RDQBBACEEIAFFDQBBACEEIAFB4M8KQZDQCkEAENMRIgFFDQAgA0EMakEAQTQQoA8aIANBATYCOCADQX82AhQgAyAANgIQIAMgATYCCCABIANBCGogAigCAEEBIAEoAgAoAhwRCQACQCADKAIgIgRBAUcNACACIAMoAhg2AgALIARBAUYhBAsgA0HAAGokACAEC8wCAQN/IwBBwABrIgQkACAAKAIAIgVBfGooAgAhBiAFQXhqKAIAIQUgBEEgakIANwIAIARBKGpCADcCACAEQTBqQgA3AgAgBEE3akIANwAAIARCADcCGCAEIAM2AhQgBCABNgIQIAQgADYCDCAEIAI2AgggACAFaiEAQQAhAwJAAkAgBiACQQAQzxFFDQAgBEEBNgI4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c0Zyb21NZW1vcnkAQ2VsZXJ5AENvcHkARHVtbXkAUmFzdGVyaXplck11bHRpcGx5AFJlc2l6ZSBob3Jpem9udGFsIG9ubHkAUmVzaXplIHZlcnRpY2FsIG9ubHkAaW8uQ29uZmlnV2luZG93c01vdmVGcm9tVGl0bGVCYXJPbmx5AEltR3VpSW5wdXRUZXh0RmxhZ3NfUmVhZE9ubHkAdGFibGVfc2Nyb2xseQBNb2RpZnkARXZlbnRLZXkASW1HdWlUYWJsZUZsYWdzX0NvbnRleHRNZW51SW5Cb2R5AEltR3VpVGFibGVGbGFnc19Ob0JvcmRlcnNJbkJvZHkAU2l6aW5nIFBvbGljeQBCb2JieQBFeGFtcGxlOiBTaW1wbGUgb3ZlcmxheQBFeGFtcGxlOiBMb25nIHRleHQgZGlzcGxheQBLZXlSZXBlYXREZWxheQBNeQB0YWJsZS0+QmdDbGlwUmVjdC5NaW4ueSA8PSB0YWJsZS0+QmdDbGlwUmVjdC5NYXgueQB0YWJsZS0+QmcyQ2xpcFJlY3RGb3JEcmF3Q21kLk1pbi55IDw9IHRhYmxlLT5CZzJDbGlwUmVjdEZvckRyYXdDbWQuTWF4LnkAdGFibGUtPlJvd1Bvc1kyID09IGlubmVyX3dpbmRvdy0+REMuQ3Vyc29yUG9zLnkAV2UgY2FsbCBBbGlnblRleHRUb0ZyYW1lUGFkZGluZygpIHRvIHZlcnRpY2FsbHkgYWxpZ24gdGhlIHRleHQgYmFzZWxpbmUgYnkgK0ZyYW1lUGFkZGluZy55AFByaW1WdHgAUHJpbVdyaXRlVnR4ACMjY3N4ACslLjBmIHB4AFgvWSA9ICUuMGYgcHgATWVzaDogRWxlbUNvdW50OiAlZCwgVnR4T2Zmc2V0OiArJWQsIElkeE9mZnNldDogKyVkLCBBcmVhOiB+JTAuZiBweABUZXh0dXJlIEFyZWE6IGFib3V0ICVkIHB4IH4lZHglZCBweABjaGVja2JveABJVEVNOiBDaGVja2JveABJVEVNOiBMaXN0Qm94AERlYnVnTm9kZURyYXdDbWRTaG93TWVzaEFuZEJvdW5kaW5nQm94AHRhYmxlX3Njcm9sbHgAU2l4AFBhdGhGaWxsQ29udmV4ACMjaGV4AGlucHV0IHUzMiBoZXgAaW5wdXQgczMyIGhleABHZXRLZXlJbmRleABUYWJsZUdldFJvd0luZGV4AEdldEluZGV4AFRhYmxlU2V0Q29sdW1uSW5kZXgAVGFibGVHZXRDb2x1bW5JbmRleABBbnRpQWxpYXNlZExpbmVzVXNlVGV4AEhleABQcmltV3JpdGVJZHgAIyNtYXgAR2V0Q2xpcFJlY3RNYXgAR2V0SXRlbVJlY3RNYXgAR2V0V2luZG93Q29udGVudFJlZ2lvbk1heABHZXRDb250ZW50UmVnaW9uTWF4AFNjcm9sbE1heABJbnB1dFRleHRFeABQbG90RXgAU2VwYXJhdG9yRXgAU2Nyb2xsYmFyRXgAVGFiSXRlbUV4AEJlZ2luVGFibGVFeAAjI1BvcHVwXyUwOHgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABSZW5kZXJBcnJvdwBJbUd1aVRyZWVOb2RlRmxhZ3NfT3Blbk9uQXJyb3cAWWVsbG93AHNsaWRlciBmbG9hdCBsb3cAc2xpZGVyIGRvdWJsZSBsb3cAc2xpZGVyIHU2NCBsb3cAc2xpZGVyIHM2NCBsb3cAc2xpZGVyIHUzMiBsb3cAc2xpZGVyIHMzMiBsb3cATWVudSBpbnNpZGUgYSByZWd1bGFyIHdpbmRvdwBNZW51cyBpbnNpZGUgYSByZWd1bGFyIHdpbmRvdwBTaG93IEhvcml6b250YWwgY29udGVudHMgc2l6ZSBkZW1vIHdpbmRvdwBFeGFtcGxlOiBBdXRvLXJlc2l6aW5nIHdpbmRvdwBDb25zdHJhaW5lZC1yZXNpemluZyB3aW5kb3cAZy5DdXJyZW50V2luZG93ID09IHdpbmRvdwB3aW5kb3cgPT0gZy5OYXZXaW5kb3cAQmVnaW5Qb3B1cENvbnRleHRXaW5kb3cAU2hvd0Fib3V0V2luZG93AEdldEhvdmVyZWRSb290V2luZG93AGcuTW92aW5nV2luZG93ICYmIGcuTW92aW5nV2luZG93LT5Sb290V2luZG93AEdldEN1cnJlbnRXaW5kb3cAaW5uZXJfd2luZG93ID09IGcuQ3VycmVudFdpbmRvdwBvdXRlcl93aW5kb3cgPT0gaW5uZXJfd2luZG93IHx8IG91dGVyX3dpbmRvdyA9PSBpbm5lcl93aW5kb3ctPlBhcmVudFdpbmRvdwBOYXZJbml0V2luZG93AE5hdlVwZGF0ZVdpbmRvd2luZ0hpZ2hsaWdodFdpbmRvdwBGb2N1c1dpbmRvdwBTaG93TWV0cmljc1dpbmRvdwBDbG9zZVBvcHVwc092ZXJXaW5kb3cAd2luZG93ID09IHRhYmxlLT5Jbm5lcldpbmRvdwBTaG93RGVtb1dpbmRvdwB+SW1HdWlXaW5kb3cAR2V0QWN0aXZlV2luZG93AGZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19DaGlsZFdpbmRvdwB3aW5kb3ctPkZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19DaGlsZFdpbmRvdwAgQ2hpbGRXaW5kb3cAR2V0SG92ZXJlZFdpbmRvdwBnLk5hdldpbmRvdyAmJiByZXN1bHQtPldpbmRvdwBCb3JkZXJTaGFkb3cAVGFibGVOZXh0Um93AFRhYmxlSGVhZGVyc1JvdwBUYWJsZUJlZ2luUm93ACF0YWJsZS0+SXNJbnNpZGVSb3cAVGFibGVFbmRSb3cAIyNwcmV2aWV3AEltR3VpQ29tYm9GbGFnc19Ob1ByZXZpZXcAV2l0aCBTaWRlIFByZXZpZXcAV2l0aCBBbHBoYSBQcmV2aWV3AFdpdGggSGFsZiBBbHBoYSBQcmV2aWV3AGl0ZW0gdmlldwBUcmVlIHZpZXcATmV3AGRyYXdfY21kLkNsaXBSZWN0LnggPD0gZHJhd19jbWQuQ2xpcFJlY3QueiAmJiBkcmF3X2NtZC5DbGlwUmVjdC55IDw9IGRyYXdfY21kLkNsaXBSZWN0LncAIyNoc3YARmlsZTFfYi53YXYARmlsZTFfYS53YXYATm8gbmF2AFJvb3RXaW5kb3dGb3JOYXYAIyN2AHRhYmxlX2NvbnRleHRfbWVudQBTdWItbWVudQBpdGVtIGNvbnRleHQgbWVudQBFbmFibGUgY29udGV4dCBtZW51AE5vIG1lbnUAVGFibGVPcGVuQ29udGV4dE1lbnUAIyNDb250ZXh0TWVudQBNeUhlbHBNZW51AEJlZ2luTWVudQBFbmRNZW51ACBDaGlsZE1lbnUAV2l0aCBPcHRpb25zIE1lbnUARGlzYWJsZSBNZW51ACVsbHUAJXNfJXUAaW1ndWlfbG9nLnR4dAB3aW5kb3dfY29udGV4dAB2b2lkX2NvbnRleHQARGVzdHJveUNvbnRleHQAU2V0Q3VycmVudENvbnRleHQAR2V0Q3VycmVudENvbnRleHQAV3JhcEltR3VpQ29udGV4dABDcmVhdGVDb250ZXh0AHNob3dfd3JhcHBlZF90ZXh0AGlucHV0IHRleHQAQnVsbGV0IHRleHQAc29tZSBtb3JlIHRleHQAJWQgc29tZSB0ZXh0AFRlbXBJbnB1dFRleHQAaW8uQ29uZmlnRHJhZ0NsaWNrVG9JbnB1dFRleHQASVRFTTogSW5wdXRUZXh0AEJ1bGxldFRleHQARGF0YVR5cGVBcHBseU9wRnJvbVRleHQATGFiZWxUZXh0AExvZ1RleHQAU2V0Q2xpcGJvYXJkVGV4dABHZXRDbGlwYm9hcmRUZXh0AEFkZFRleHQAIyNUZXh0AENvbG9yZnVsIFRleHQAQWRkIERlYnVnIFRleHQASVRFTTogVGV4dABVVEYtOCBUZXh0AHd0AFVURi04IGlucHV0AFdhbnRUZXh0SW5wdXQASW1HdWlTbGlkZXJGbGFnc19Ob0lucHV0AEltR3VpSW5wdXRUZXh0RmxhZ3NfQWxsb3dUYWJJbnB1dABNdWx0aS1saW5lIFRleHQgSW5wdXQARmlsdGVyZWQgVGV4dCBJbnB1dABQYXNzd29yZCBJbnB1dABFeGFtcGxlOiBTaW1wbGUgbGF5b3V0AFRhYkJhckxheW91dABUYWJsZVVwZGF0ZUxheW91dABEZWJ1Z0NoZWNrVmVyc2lvbkFuZERhdGFMYXlvdXQAQmFzaWMgSG9yaXpvbnRhbCBMYXlvdXQAQ29jb251dABDdXQAa2VlcGNvc3QAYXV0byBlbWJpbmRfaW5pdF9JbUd1aSgpOjooYW5vbnltb3VzIGNsYXNzKTo6b3BlcmF0b3IoKShlbXNjcmlwdGVuOjp2YWwpIGNvbnN0AGF1dG8gZW1iaW5kX2luaXRfSW1Gb250Q29uZmlnKCk6Oihhbm9ueW1vdXMgY2xhc3MpOjpvcGVyYXRvcigpKEltRm9udENvbmZpZyAmLCBlbXNjcmlwdGVuOjp2YWwpIGNvbnN0AGF1dG8gZW1iaW5kX2luaXRfSW1HdWkoKTo6KGFub255bW91cyBjbGFzcyk6Om9wZXJhdG9yKCkoKSBjb25zdABhdXRvIGVtYmluZF9pbml0X0ltRm9udENvbmZpZygpOjooYW5vbnltb3VzIGNsYXNzKTo6b3BlcmF0b3IoKShjb25zdCBJbUZvbnRDb25maWcgJikgY29uc3QARHJhd0xpc3QgPT0gJkRyYXdMaXN0SW5zdABEcmF3IGluIEJhY2tncm91bmQgZHJhdyBsaXN0AERyYXcgaW4gRm9yZWdyb3VuZCBkcmF3IGxpc3QAR2V0V2luZG93RHJhd0xpc3QASW1EcmF3TGlzdABHZXRCYWNrZ3JvdW5kRHJhd0xpc3QAR2V0Rm9yZWdyb3VuZERyYXdMaXN0ACMjI05hdldpbmRvd2luZ0xpc3QATW91c2VEb3VibGVDbGlja01heERpc3QAU2Nyb2xsVGFyZ2V0RWRnZVNuYXBEaXN0AGcuTmF2TW92ZVJlcXVlc3QAUGF0aEFyY1RvRmFzdABFeHBvcnQAdW5zaWduZWQgc2hvcnQAX0RlZmF1bHRTb3J0AF9Ob1NvcnQAUmV2ZXJ0AGluc2VydABEaXNwbGF5U3RhcnQAU2VsZWN0aW9uU3RhcnQAQ2Fycm90AEJlZXRyb290AFJvb3QAQXByaWNvdABHZXRLZXlQcmVzc2VkQW1vdW50ACMjY29sdW1uc19jb3VudABpdGVtc19jb3VudAB2X2lkeCA+PSAwICYmIHZfaWR4IDwgdmFsdWVzX2NvdW50AHYxX2lkeCA+PSAwICYmIHYxX2lkeCA8IHZhbHVlc19jb3VudABTYW1wbGUgY291bnQAVG90YWxWdHhDb3VudABUb3RhbElkeENvdW50AENtZExpc3RzQ291bnQAR2V0Q29sdW1uc0NvdW50AHNldHRpbmdzLT5Db2x1bW5zQ291bnQgPT0gdGFibGUtPkNvbHVtbnNDb3VudCAmJiBzZXR0aW5ncy0+Q29sdW1uc0NvdW50TWF4ID49IHNldHRpbmdzLT5Db2x1bW5zQ291bnQAY29sdW1uX24gPj0gLTEgJiYgY29sdW1uX24gPCB0YWJsZS0+Q29sdW1uc0NvdW50AGNvbHVtbl9uID49IDAgJiYgY29sdW1uX24gPCB0YWJsZS0+Q29sdW1uc0NvdW50AGNvbHVtbl9uID49IDAgJiYgdGFibGUtPkNvbHVtbnNDb3VudABJdGVtc0NvdW50AGNvbHVtbi0+U29ydE9yZGVyIDwgdGFibGUtPlNvcnRTcGVjc0NvdW50AFRhYmxlR2V0Q29sdW1uQ291bnQARWxlbUNvdW50AG4gPCBjb2x1bW4tPlNvcnREaXJlY3Rpb25zQXZhaWxDb3VudABHZXRGcmFtZUNvdW50AGcuRnJhbWVDb3VudEVuZGVkICE9IGcuRnJhbWVDb3VudABDb25maWdEYXRhQ291bnQAaWR4ID49IDAgJiYgaWR4IDwgX0NvdW50AE5vIGJyaW5nIHRvIGZyb250AERzdEZvbnQAU2V0Q3VycmVudEZvbnQAR2V0Rm9udABQb3BGb250AEltRm9udABQdXNoRm9udABDb2RlcG9pbnQAQW5vdGhlciBidWxsZXQgcG9pbnQAQ29uc3RyYWludABJbnB1dFRleHRXaXRoSGludAAjI2ludABpbnB1dCBpbnQAc2xpZGVyIGludABkcmFnIGludAByYW5nZSBpbnQAdW5zaWduZWQgaW50AFBhdWNpbG9xdWVudABDb250ZW50ACMjY3VycmVudABDaGFubmVsc1NldEN1cnJlbnQAU29tZSBEb2N1bWVudABUZXh0IEJhc2VsaW5lIEFsaWdubWVudABVbmluZGVudABJbmRlbnQARGVzY2VudABBc2NlbnQAT3BlbiBSZWNlbnQARWdncGxhbnQASW5wdXRJbnQAVlNsaWRlckludABEcmFnSW50AE5hdlVwZGF0ZU1vdmVSZXN1bHQAU2V0IGFzIGRlZmF1bHQAQWRkRm9udERlZmF1bHQASXRlbVdpZHRoRGVmYXVsdABEZWJ1ZyMjRGVmYXVsdABJc0J1aWx0AEtleUFsdABUYWJsZVJvd0JnQWx0AEV4aXQAR3JhcGVmcnVpdABRdWl0AHNwbGl0AENoYW5uZWxzU3BsaXQAIyNlZGl0AElzSXRlbURlYWN0aXZhdGVkQWZ0ZXJFZGl0AENvbnRlbnRTaXplRXhwbGljaXQASW1HdWlUYWJsZUZsYWdzX1NpemluZ0ZpeGVkRml0AFRlc3RCaXQAU2V0Qml0AENsZWFyQml0AFRvcC1yaWdodABCb3R0b20tcmlnaHQAIyNyaWdodABOYXZIaWdobGlnaHQAUm9vdFdpbmRvd0ZvclRpdGxlQmFySGlnaGxpZ2h0AE5hdldpbmRvd2luZ0hpZ2hsaWdodAB0YWJsZV9yb3dfaGVpZ2h0AHJvd19taW5faGVpZ2h0AFJvdyBoZWlnaHQAV2VpZ2h0AFRleEhlaWdodABHZXRXaW5kb3dIZWlnaHQASXRlbXNIZWlnaHQAR2V0VGV4dExpbmVIZWlnaHQAR2V0RnJhbWVIZWlnaHQAZy5TdHlsZS5XaW5kb3dNZW51QnV0dG9uUG9zaXRpb24gPT0gSW1HdWlEaXJfTm9uZSB8fCBnLlN0eWxlLldpbmRvd01lbnVCdXR0b25Qb3NpdGlvbiA9PSBJbUd1aURpcl9MZWZ0IHx8IGcuU3R5bGUuV2luZG93TWVudUJ1dHRvblBvc2l0aW9uID09IEltR3VpRGlyX1JpZ2h0AEhlbGxvIFJpZ2h0AFN0eWxlQ29sb3JzTGlnaHQAVGFibGVCb3JkZXJMaWdodABLZXlTaGlmdABUb3AtbGVmdABCb3R0b20tbGVmdAAjI2xlZnQASW1HdWlDb21ib0ZsYWdzX1BvcHVwQWxpZ25MZWZ0AEhlbGxvIExlZnQAcHRyX2Zyb21fb2Zmc2V0AGlvLkJhY2tlbmRGbGFnczogUmVuZGVyZXJIYXNWdHhPZmZzZXQAX09uQ2hhbmdlZFZ0eE9mZnNldABJZHhPZmZzZXQASW1EcmF3VmVydFBvc09mZnNldABTZXRDb2x1bW5PZmZzZXQAR2V0Q29sdW1uT2Zmc2V0AEdldERyYWdnZWRDb2x1bW5PZmZzZXQASW1EcmF3VmVydENvbE9mZnNldABHbHlwaE9mZnNldABieXRlT2Zmc2V0AEltRHJhd1ZlcnRVVk9mZnNldABTY3JvbGwgT2Zmc2V0AExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0AEJ1bGxldAByb3cgYmcgdGFyZ2V0AEJlZ2luRHJhZ0Ryb3BUYXJnZXQARW5kRHJhZ0Ryb3BUYXJnZXQAZy5EcmFnRHJvcFdpdGhpblRhcmdldABTY3JvbGxUYXJnZXQAZy5OYXZXaW5kb3dpbmdUYXJnZXQAU2V0AE9iamVjdABHZXRXaW5kb3dSZWN0AENvbHVtbnNSZWN0AE91dGVyUmVjdABJbm5lclJlY3QAR2V0UmVzaXplQm9yZGVyUmVjdABHZXRXaW5kb3dTY3JvbGxiYXJSZWN0AEhvc3RDbGlwUmVjdABDb2x1bW5zQ2xpcFJlY3QASW5uZXJDbGlwUmVjdABQb3BDbGlwUmVjdABQdXNoQ2xpcFJlY3QAQmFja2dyb3VuZENsaXBSZWN0AF9PbkNoYW5nZWRDbGlwUmVjdABDb250ZW50UmVnaW9uUmVjdABQcmltUmVjdABJbVJlY3QAQ29sdW1uc1dvcmtSZWN0AFBhdGhSZWN0AElzTW91c2VIb3ZlcmluZ1JlY3QAR2V0VGFibGVSZWN0AEFkZFJlY3QAaW5wdXQgZmxvYXQAc2xpZGVyIGZsb2F0AGRyYWcgc21hbGwgZmxvYXQAZHJhZyBmbG9hdAByYW5nZSBmbG9hdABJVEVNOiBJbnB1dEZsb2F0AFZTbGlkZXJGbG9hdABJVEVNOiBTbGlkZXJGbG9hdABEcmFnRmxvYXQASW1HdWlTbGlkZXJGbGFnc19Ob1JvdW5kVG9Gb3JtYXQAUG9wQnV0dG9uUmVwZWF0AFB1c2hCdXR0b25SZXBlYXQARWF0AHVpbnQ2NF90ADN3YXlzAGZyZWV6ZV9yb3dzAFBvcHVwcyAmIE1vZGFsIHdpbmRvd3MAQ2hpbGQgd2luZG93cwBTZXR0aW5nc1dpbmRvd3MATWV0cmljc1JlbmRlcldpbmRvd3MATWV0cmljc0FjdGl2ZVdpbmRvd3MAQ2hpbGRXaW5kb3dzAENhdHR5d2FtcHVzACMjcHJldmlvdXMAUHJldmlvdXMAQ29udGV4dCBtZW51cwBTZXROZXh0V2luZG93Rm9jdXMAU2V0V2luZG93Rm9jdXMAU2V0SXRlbURlZmF1bHRGb2N1cwBTZXRXaW5kb3dOYW1lRm9jdXMAUG9wQWxsb3dLZXlib2FyZEZvY3VzAFB1c2hBbGxvd0tleWJvYXJkRm9jdXMASW5wdXRzLCBOYXZpZ2F0aW9uICYgRm9jdXMATm9OYXZJbnB1dHMAX3NldEF0X05hdklucHV0cwBfZ2V0QXRfTmF2SW5wdXRzAE5vTW91c2VJbnB1dHMAQkcvRkcgZHJhdyBsaXN0cwBJdGVyYXRlRHJhd0xpc3RzAFRhYmxlQmVnaW5BcHBseVJlcXVlc3RzAFRpdGxlIGJhciBIb3ZlcmVkL0FjdGl2ZSB0ZXN0cwBJdGVyYXRlRm9udHMAU2V0TmV4dFdpbmRvd1NpemVDb25zdHJhaW50cwBTb21lIG90aGVyIGNvbnRlbnRzAEV2ZW4gbW9yZSBjb250ZW50cwBTb21lIGNvbnRlbnRzAFNvbWUgdHJlZSBjb250ZW50cwBOb2RlIGNvbnRlbnRzAENvbnRlbnRzAENsb3NlIEFsbCBEb2N1bWVudHMARXhhbXBsZTogRG9jdW1lbnRzAEdyYWRpZW50cwBNYXg6ICVkIHVuaXRzAE1pbjogJWQgdW5pdHMAQnVsbGV0cwBEcmFnIGFuZCBkcm9wIGluIHN0YW5kYXJkIHdpZGdldHMAU2hvd0RlbW9XaW5kb3dXaWRnZXRzAE11bHRpLWNvbXBvbmVudCBXaWRnZXRzAFBsb3RzIFdpZGdldHMAQ29sb3IvUGlja2VyIFdpZGdldHMAUmFuZ2UgV2lkZ2V0cwBTY2FsZUNsaXBSZWN0cwBUaGlja25lc3MATW91c2UgY3Vyc29ycwBpby5CYWNrZW5kRmxhZ3M6IEhhc01vdXNlQ3Vyc29ycwAjI2NvbG9ycwBGaWx0ZXIgY29sb3JzAEhTViBlbmNvZGVkIGNvbG9ycwBfc2V0QXRfQ29sb3JzAF9nZXRBdF9Db2xvcnMAT25seSBNb2RpZmllZCBDb2xvcnMAaW8uQ29uZmlnTWFjT1NYQmVoYXZpb3JzACJpbWd1aSIgbGV0dGVycwBDbGVhcklucHV0Q2hhcmFjdGVycwBTZXR0aW5nc0hhbmRsZXJzAFRhYmxlR2NDb21wYWN0VHJhbnNpZW50QnVmZmVycwBEZUluZGV4QWxsQnVmZmVycwBUYWJsZVVwZGF0ZUJvcmRlcnMASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnMAVmVydGljYWwgU2xpZGVycwBzaG93X2hlYWRlcnMAdGFibGVfY3VzdG9tX2hlYWRlcnMARGlzcGxheSBoZWFkZXJzAEN1c3RvbSBoZWFkZXJzAFJlb3JkZXJhYmxlLCBoaWRlYWJsZSwgd2l0aCBoZWFkZXJzAERpc2FibGUgdmVydGljYWwgYm9yZGVycyBpbiBjb2x1bW5zIEJvZHkgKGJvcmRlcnMgd2lsbCBhbHdheXMgYXBwZWFycyBpbiBIZWFkZXJzAENvbGxhcHNpbmcgSGVhZGVycwBJbnNlcnRDaGFycwBEZWxldGVDaGFycwBUYWJCYXJzAFBvcHVwcwBHcm91cHMAIyNwb3MAY2ZnX2luZm9zAERpc3BsYXlQb3MAU2V0TmV4dFdpbmRvd1BvcwBTZXRXaW5kb3dQb3MAR2V0V2luZG93UG9zAEdldEN1cnNvclN0YXJ0UG9zAFNldEN1cnNvclBvcwBHZXRDdXJzb3JQb3MAUG9wVGV4dFdyYXBQb3MAUHVzaFRleHRXcmFwUG9zAFNldEN1cnNvclNjcmVlblBvcwBHZXRDdXJzb3JTY3JlZW5Qb3MAV2FudFNldE1vdXNlUG9zAGlvLkJhY2tlbmRGbGFnczogSGFzU2V0TW91c2VQb3MAaW8uQ29uZmlnRmxhZ3M6IE5hdkVuYWJsZVNldE1vdXNlUG9zAEdldE1vdXNlUG9zAFNldFdpbmRvd05hbWVQb3MAX2dldEF0X01vdXNlQ2xpY2tlZFBvcwBTY3JvbGwgVG8gUG9zAFNob3cgc3RlcCBidXR0b25zAFNtYWxsIGJ1dHRvbnMATm9ybWFsIGJ1dHRvbnMATG9nQnV0dG9ucwBXaW5kb3cgb3B0aW9ucwBTZXRDb2xvckVkaXRPcHRpb25zAFNldEFsbG9jYXRvckZ1bmN0aW9ucwBSZW5kZXJXaW5kb3dEZWNvcmF0aW9ucwAlZCBhY3RpdmUgYWxsb2NhdGlvbnMATWV0cmljc0FjdGl2ZUFsbG9jYXRpb25zAG15Y29sdW1ucwBJbiBjb2x1bW5zACVkIGNvbHVtbnMAQmVnaW5Db2x1bW5zAEVuZENvbHVtbnMAVGFibGVzICYgQ29sdW1ucwAlLjA2ZiBucwBEcmFnIGFuZCBkcm9wIHRvIGNvcHkvc3dhcCBpdGVtcwBNaXhlZCBpdGVtcwBTaG93IGluZGVudGVkIGl0ZW1zACUuMTBmIGdyYW1zACVlIGdyYW1zACVJNjR1IG1zACV1IG1zAFRvb2xzAGZyZWV6ZV9jb2xzAERlYnVnIGRldGFpbHMARGV0YWlscwBwaXhlbHMAU2l6ZVBpeGVscwBUYWJsZVNldHVwRHJhd0NoYW5uZWxzAFRhYmxlTWVyZ2VEcmF3Q2hhbm5lbHMARXF1YWxzAE1vZGFscwBVcGRhdGVXaW5kb3dQYXJlbnRBbmRSb290TGlua3MAdXNtYmxrcwBmc21ibGtzAGhibGtzAHVvcmRibGtzAGZvcmRibGtzAEVycm9yQ2hlY2tOZXdGcmFtZVNhbml0eUNoZWNrcwBFcnJvckNoZWNrRW5kRnJhbWVTYW5pdHlDaGVja3MAQ29tcGxldGlvbiwgSGlzdG9yeSwgRWRpdCBDYWxsYmFja3MAQ29sdW1ucyB3aWR0aHMASW1HdWlUYWJsZUZsYWdzX1ByZWNpc2VXaWR0aHMAZ2x5cGhzAEl0ZXJhdGVHbHlwaHMAQ2xlYXIgc2V0dGluZ3MAV2FudFNhdmVJbmlTZXR0aW5ncwBUYWJsZVNhdmVTZXR0aW5ncwBVcGRhdGVTZXR0aW5ncwBUYWJsZUdldEJvdW5kU2V0dGluZ3MASW1HdWlUYWJsZUZsYWdzX05vU2F2ZWRTZXR0aW5ncwB0YWJsZV9jb2x1bW5zX2ZsYWdzAENvbHVtbnMgZmxhZ3MAVGFiSXRlbUJ1dHRvbiAmIExlYWRpbmcvVHJhaWxpbmcgZmxhZ3MAY2FsbGJhY2tfZGF0YS5GbGFncyA9PSBmbGFncwBDaGVja2JveEZsYWdzAFJhc3Rlcml6ZXJGbGFncwBUYWJsZUdldENvbHVtbkZsYWdzAFRhYmxlU2V0dXBDb2x1bW5GbGFncwBDb25maWdGbGFncwBCYWNrZW5kRmxhZ3MARHJhZy9TbGlkZXIgRmxhZ3MAQmFja2VuZCBGbGFncwBTY3JvbGxiYXJTaXplcwBTY2FsZUFsbFNpemVzAHRhYmxlX2NvbHVtbnNfZmxhZ3NfY2hlY2tib3hlcwBBbGwgcHJpbWl0aXZlcwBQcmltaXRpdmVzACMjdmFsdWVzAFJhdyBIU1YgdmFsdWVzAFNldHRpbmdzIHBhY2tlZCBkYXRhOiBXaW5kb3dzOiAlZCBieXRlcwBTZXR0aW5ncyBwYWNrZWQgZGF0YTogVGFibGVzOiAlZCBieXRlcwBTZXR0aW5ncyB1bnBhY2tlZCBkYXRhICguaW5pKTogJWQgYnl0ZXMAQnVmZmVyIGNvbnRlbnRzOiAlZCBsaW5lcywgJWQgYnl0ZXMAJXM6ICVkIGVudHJpZXMsICVkIGJ5dGVzADEyLDM0NSBieXRlcwAgMiwzNDUgYnl0ZXMAVGV4dHVyZXMARGF0YSBUeXBlcwBOdW1iZXIgb2YgbGluZXMAQnVsbGV0IHBvaW50IDIKT24gbXVsdGlwbGUgbGluZXMAQW50aS1hbGlhc2VkIGxpbmVzAEFkZCAxMDAwIGxpbmVzAFBsb3RMaW5lcwBBbnRpQWxpYXNlZExpbmVzAEZyYW1lIFRpbWVzAE1hbmlwdWxhdGluZyB3aW5kb3cgdGl0bGVzAEV4YW1wbGVzAFNob3cgd2luZG93cyByZWN0YW5nbGVzAFNob3cgdGFibGVzIHJlY3RhbmdsZXMAU2VsZWN0YWJsZXMATmVzdGVkIHRhYmxlcwBTaG93RGVtb1dpbmRvd1RhYmxlcwBTZXR0aW5nc1RhYmxlcwBbRGVidWddIEFkZCA1IGVudHJpZXMAU2l6aW5nIHBvbGljaWVzAEdseXBoUmFuZ2VzAGlvLkNvbmZpZ1dpbmRvd3NSZXNpemVGcm9tRWRnZXMASW1hZ2VzAEJhc2ljIHRyZWVzAFRyZWVzAEFkdmFuY2VkLCB3aXRoIFNlbGVjdGFibGUgbm9kZXMAVHJlZSBub2RlcwBOLWdvbiBzaWRlcwBTeW5jZWQgaW5zdGFuY2VzAE1ldHJpY3NSZW5kZXJWZXJ0aWNlcwBNZXRyaWNzUmVuZGVySW5kaWNlcwBZZXMARGVzACVzOiAnJXMnICVkIHZ0eCwgJWQgaW5kaWNlcywgJWQgY21kcwBJdGVyYXRlRHJhd0NtZHMAVGFibGVHZXRTb3J0U3BlY3MAQ29tcGFyZVdpdGhTb3J0U3BlY3MASW1HdWlUYWJsZVNvcnRTcGVjcwBJbUd1aVRhYmxlU29ydENvbHVtblNwZWNzACMjdGFicwBJbUd1aVRhYkJhckZsYWdzX0F1dG9TZWxlY3ROZXdUYWJzACMjVGFicwBjYW52YXMAQ2FudmFzAEZvbnREYXRhT3duZWRCeUF0bGFzAEltRm9udEF0bGFzAElzAAolKnMlLipzACAlLipzAEtleXMgbW9kczogJXMlcyVzJXMAU2Nyb2xsOiAoJS4yZi8lLjJmLCUuMmYvJS4yZikgU2Nyb2xsYmFyOiVzJXMAUG9wdXBJRDogJTA4eCwgV2luZG93OiAnJXMnJXMlcwBDb2x1bW5zR2l2ZW5XaWR0aDogJS4xZiwgQ29sdW1uc0F1dG9GaXRXaWR0aDogJS4xZiwgSW5uZXJXaWR0aDogJS4xZiVzACUuKnMlJWQlcwBkZWZpbmU6IF9fY2xhbmdfdmVyc2lvbl9fPSVzACVzIDB4JTA4WCAoJWQgdGFicyklcwBUYWJsZSAweCUwOFggKCVkIGNvbHVtbnMsIGluICclcycpJXMAJXMgJyVzJyVzAENvcHkgJXMAJXMgJWRweCAlcwAlcyAlcwBTd2FwICVzAERlYXIgSW1HdWkgJXMATW92ZSAlcwBTYXZlICVzACglNi4xZiwlNi4xZikgKCU2LjFmLCU2LjFmKSBTaXplICglNi4xZiwlNi4xZikgQ29sICVkICVzAE5hdkxhc3RDaGlsZE5hdldpbmRvdzogJXMAJSVzOiAlcwBpby5CYWNrZW5kUmVuZGVyZXJOYW1lOiAlcwBpby5CYWNrZW5kUGxhdGZvcm1OYW1lOiAlcwBOYXZJbnB1dFNvdXJjZTogJXMAQWN0aXZlSWQ6IDB4JTA4WC8weCUwOFggKCUuMmYgc2VjKSwgQWxsb3dPdmVybGFwOiAlZCwgU291cmNlOiAlcwBNb3VzZSBjdXJzb3IgJWQ6ICVzAEN1cnJlbnQgbW91c2UgY3Vyc29yID0gJWQ6ICVzAC0gJXMAKCU2LjFmLCU2LjFmKSAoJTYuMWYsJTYuMWYpIFNpemUgKCU2LjFmLCU2LjFmKSAlcwBGb3VyRm91ckZvdXIASXRlbSBGb3VyAGluZGV4X2Zyb21fcHRyAG9mZnNldF9mcm9tX3B0cgAjI015U3RyAEV4YW1wbGU6IFByb3BlcnR5IGVkaXRvcgBTaG93U3R5bGVFZGl0b3IARGVhciBJbUd1aSBTdHlsZSBFZGl0b3IAdmVjdG9yAFNob3dGb250U2VsZWN0b3IAU2hvd1N0eWxlU2VsZWN0b3IARm9udHMjI1NlbGVjdG9yAENvbG9ycyMjU2VsZWN0b3IAU2VwYXJhdG9yAGlvLk1vdXNlRHJhd0N1cnNvcgBTZXRNb3VzZUN1cnNvcgBHZXRNb3VzZUN1cnNvcgBSZW5kZXJNb3VzZUN1cnNvcgBlcnJvcgBDaXJjbGVTZWdtZW50TWF4RXJyb3IAQ2lyY2xlIFNlZ21lbnQgTWF4IEVycm9yAEFkZCBEZWJ1ZyBFcnJvcgAjI2NvbG9yAEJhY2tncm91bmQgY29sb3IAQWRkUmVjdEZpbGxlZE11bHRpQ29sb3IAVGFibGVTZXRCZ0NvbG9yACMjUmVmQ29sb3IAUG9wU3R5bGVDb2xvcgBQdXNoU3R5bGVDb2xvcgBXaXRoIFJlZiBDb2xvcgBUYWlsb3IAU2FpbG9yAFNsaWRlckJlaGF2aW9yAEJ1dHRvbkJlaGF2aW9yAERyYWdCZWhhdmlvcgBUcmVlTm9kZUJlaGF2aW9yAGRzdF9jb2x1bW4tPkRpc3BsYXlPcmRlciA9PSBkc3Rfb3JkZXIgLSByZW9yZGVyX2RpcgBBaXIAQ29ybmlmbG93ZXIASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlcgBMaXN0Qm94Rm9vdGVyAENlbnRlcgBGaWx0ZXIAQWRkSW5wdXRDaGFyYWN0ZXIAV2F0ZXIAS2V5U3VwZXIAfkltR3VpTGlzdENsaXBwZXIASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lcgBDb25maWdNZW1vcnlDb21wYWN0VGltZXIAbXlwaWNrZXIAIyNwcmV2aWV3aW5nX3BpY2tlcgAjI3BpY2tlcgBEZWFyIEltR3VpIE1ldHJpY3MvRGVidWdnZXIAYnVmZmVyAFZ0eEJ1ZmZlcgBJZHhCdWZmZXIAbG9uZ2VlZXIAX05vUmVvcmRlcgBUYWJCYXJRdWV1ZVJlb3JkZXIAV2luZG93Qm9yZGVyAFBvcHVwQm9yZGVyAEltR3VpQ29sb3JFZGl0RmxhZ3NfTm9Cb3JkZXIARnJhbWVCb3JkZXIAUmVzZXQgb3JkZXIAU2hvdyB3aW5kb3dzIGJlZ2luIG9yZGVyAGNvbHVtbi0+SW5kZXhXaXRoaW5FbmFibGVkU2V0IDw9IGNvbHVtbi0+RGlzcGxheU9yZGVyAFNvcnRPcmRlcgBSZW5kZXIARm9sZGVyAFNob3cgMm5kIGhlYWRlcgBDb2xsYXBzaW5nSGVhZGVyAFRhYmxlSGVhZGVyAG51bWJlcgBDdWN1bWJlcgBJbnB1dFNjYWxhcgBWU2xpZGVyU2NhbGFyAERyYWdTY2FsYXIAdW5zaWduZWQgY2hhcgBFdmVudENoYXIARWxsaXBzaXNDaGFyAFJlbmRlckNoYXIAUGF0aENsZWFyAE9oIGRlYXIAUGVhcgAjI21lbnViYXIASC1zY3JvbGxiYXIATm8gc2Nyb2xsYmFyAE5vIHRpdGxlYmFyAE1haW4gbWVudSBiYXIAVGFiIGJhcgBQb3BTdHlsZVZhcgBQdXNoU3R5bGVWYXIAQmVnaW5NZW51QmFyAEJlZ2luTWFpbk1lbnVCYXIARW5kTWFpbk1lbnVCYXIAIyNNYWluTWVudUJhcgBFbmRNZW51QmFyAHdpbmRvdy0+RmxhZ3MgJiBJbUd1aVdpbmRvd0ZsYWdzX01lbnVCYXIAUHJvZ3Jlc3NCYXIATXlUYWJCYXIAQmVnaW5UYWJCYXIARW5kVGFiQmFyACMjVGFiQmFyAFByb2dyZXNzIEJhcgBEZWZhdWx0OiBVaW50OCArIEhTViArIEh1ZSBCYXIAV2l0aCBBbHBoYSBCYXIAbXlfc2VsZWN0X3BvcHVwAG15X2ZpbGVfcG9wdXAAbXlfdG9nZ2xlX3BvcHVwAGFub3RoZXIgcG9wdXAASSBhbSBhIHRvb2x0aXAgb3ZlciBhIHBvcHVwAE15UG9wdXAAR2V0TW91c2VQb3NPbk9wZW5pbmdDdXJyZW50UG9wdXAAQ2xvc2VDdXJyZW50UG9wdXAARmluZEJlc3RXaW5kb3dQb3NGb3JQb3B1cABCZWdpblBvcHVwAE9wZW5Qb3B1cABFbmRQb3B1cAB3aW5kb3ctPkZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19Qb3B1cABTdGFja2VkIFBvcHVwAEJlZ2luR3JvdXAARW5kR3JvdXAAU3RyZHVwAC4uL2ltZ3VpX2RyYXcuY3BwAC4uL2ltZ3VpX3dpZGdldHMuY3BwAC4uL2ltZ3VpX3RhYmxlcy5jcHAALi4vaW1ndWlfZGVtby5jcHAASGVsbG8uY3BwAC4uL2ltZ3VpLmNwcABjY2MyLmNwcABiYmIyLmNwcABhYWEyLmNwcABDYXB0dXJlTW91c2VGcm9tQXBwAENhcHR1cmVLZXlib2FyZEZyb21BcHAASW1HdWlUYWJsZUZsYWdzX1NpemluZ1N0cmV0Y2hQcm9wAFdpdGggRHJhZyBhbmQgRHJvcABOaW5jb21wb29wAENob3AAVG9wAFRyZWVQb3AASW1HdWlTbGlkZXJGbGFnc19BbHdheXNDbGFtcABEYXRhVHlwZUNsYW1wAEhlbHAASSBhbSBhIGZhbmN5IHRvb2x0aXAASSBhbSBhIHRvb2x0aXAAU2V0VG9vbHRpcABCZWdpblRvb2x0aXAARW5kVG9vbHRpcABHZXRDdXJyZW50V2luZG93UmVhZCgpLT5GbGFncyAmIEltR3VpV2luZG93RmxhZ3NfVG9vbHRpcABSZXNpemVHcmlwAExvbmcgdGV4dCB0aGF0IGlzIGxpa2VseSB0byBjbGlwAEltR3VpVGFibGVGbGFnc19Ob0NsaXAAU3RlcABTd2FwAFNldEl0ZW1BbGxvd092ZXJsYXAAX3NldEF0X0tleU1hcABfZ2V0QXRfS2V5TWFwAERhdGFUeXBlQXBwbHlPcABDYWxsYmFjayAlcCwgdXNlcl9kYXRhICVwAC9wYXRoL3R3bwBUd29Ud29Ud28ASXRlbSBUd28AVG9tYXRvAFNldCB0byB6ZXJvAGZvbwBEZWFyIEltR3VpIERlbW8AVHdvIGl0ZW1zOiBIZWxsbwBNb3JlIHNwYWNpbmc6IEhlbGxvAFNjcm9sbFRhcmdldENlbnRlclJhdGlvAE1hbmdvAG1hbGxpbmZvAERhdGFUeXBlR2V0SW5mbwBHZXRTdHlsZVZhckluZm8AVW5kbwBzdGJfdGV4dGVkaXRfZGlzY2FyZF9yZWRvAFJlZG8AQXZvY2FkbwBPbmx5IG1ha2VzIGEgZGlmZmVyZW5jZSBpZiB0aGUgcG9wdXAgaXMgbGFyZ2VyIHRoYW4gdGhlIGNvbWJvAEJlZ2luQ29tYm8ARW5kQ29tYm8ASVRFTTogQ29tYm8AUGF0aEJlemllclF1YWRyYXRpY0N1cnZlVG8AUGF0aEJlemllckN1YmljQ3VydmVUbwBQYXRoTGluZVRvAFBhdGhBcmNUbwBGb250Tm8AU3RlcE5vAEJyeW4AVW5rbm93bgBJc0tleURvd24AX3NldEF0X0tleXNEb3duAF9nZXRBdF9LZXlzRG93bgBJbUd1aVRhYkJhckZsYWdzX0ZpdHRpbmdQb2xpY3lSZXNpemVEb3duAElzQW55TW91c2VEb3duAElzTW91c2VEb3duAF9zZXRBdF9Nb3VzZURvd24AX2dldEF0X01vdXNlRG93bgAjU291cmNlRXh0ZXJuAHdhcm4ASGVhZGVyIHdpdGggYSBjbG9zZSBidXR0b24AdGhpcyBpcyBhIDMwMC13aWRlIGJ1dHRvbgBJbUd1aUNvbWJvRmxhZ3NfTm9BcnJvd0J1dHRvbgAjI0NvbG9yQnV0dG9uAEltR3VpVGFiQmFyRmxhZ3NfVGFiTGlzdFBvcHVwQnV0dG9uAFRhYkl0ZW1CdXR0b24ARmlsbEJ1dHRvbgBTbWFsbEJ1dHRvbgBJbUd1aVRhYkJhckZsYWdzX05vQ2xvc2VXaXRoTWlkZGxlTW91c2VCdXR0b24AVGFiTWluV2lkdGhGb3JDbG9zZUJ1dHRvbgBJbnZpc2libGVCdXR0b24ASW1hZ2VCdXR0b24AQnV0dG9uOiAlcyMjI0J1dHRvbgBBZHZhbmNlZCAmIENsb3NlIEJ1dHRvbgBJVEVNOiBCdXR0b24AV2F0ZXJtZWxvbgBEYWlrb24ARGVzY3JpcHRpb24Ac3RkOjpleGNlcHRpb24AU29tZU9wdGlvbgBBbGlnbiBsYWJlbCB3aXRoIGN1cnJlbnQgWCBwb3NpdGlvbgBXaW5kb3dNZW51QnV0dG9uUG9zaXRpb24AQ29sb3JCdXR0b25Qb3NpdGlvbgBDb21wbGV0aW9uAFRhYmxlR2V0Q29sdW1uTmV4dFNvcnREaXJlY3Rpb24AVGFibGVTZXRDb2x1bW5Tb3J0RGlyZWN0aW9uAFRhYmxlR2V0Q29sdW1uQXZhaWxTb3J0RGlyZWN0aW9uAEhhc1NlbGVjdGlvbgBTZWxlY3Rpb24gU3RhdGU6IE11bHRpcGxlIFNlbGVjdGlvbgBTZWxlY3Rpb24gU3RhdGU6IFNpbmdsZSBTZWxlY3Rpb24AQWN0aW9uAERpc2FibGUgdHJlZSBpbmRlbnRhdGlvbgBDb25maWd1cmF0aW9uAF9nZXRBdF9LZXlzRG93bkR1cmF0aW9uAF9nZXRBdF9OYXZJbnB1dHNEb3duRHVyYXRpb24AX2dldEF0X01vdXNlRG93bkR1cmF0aW9uAERlY29yYXRpb24AQ29uZmlnL0J1aWxkIEluZm9ybWF0aW9uAEdldFZlcnNpb24AJTA0ZDogc2Nyb2xsYWJsZSByZWdpb24AIyNTY3JvbGxpbmdSZWdpb24AQWRkTmdvbgBUcmVlIGluIGNvbHVtbgBUYWJsZU5leHRDb2x1bW4AVGFibGVTZXR1cENvbHVtbgAjI21pbgAoKGNoYXIqKShzdGF0ZS0+dW5kb19yZWMgKyBzdGF0ZS0+cmVkb19wb2ludCkpID49IGJ1Zl9iZWdpbgBMb2dCZWdpbgBNYWluAEdldENsaXBSZWN0TWluAEdldEl0ZW1SZWN0TWluAEdldFdpbmRvd0NvbnRlbnRSZWdpb25NaW4AcmlnaHQtYWxpZ24AQnV0dG9uVGV4dEFsaWduAFNlbGVjdGFibGVUZXh0QWxpZ24AV2luZG93VGl0bGVBbGlnbgBDb2x1bW5zQ29udGVudFVuZnJvemVuAENvbHVtbnNDb250ZW50RnJvemVuAEl0ZW1zRnJvemVuAElzUG9wdXBPcGVuAFNldE5leHRJdGVtT3BlbgBJc0l0ZW1Ub2dnbGVkT3BlbgBwb3MgPD0gdGV4dF9sZW4AUHVzaENsaXBSZWN0RnVsbFNjcmVlbgBIaWRkZW4AcG9zICsgYnl0ZXNfY291bnQgPD0gQnVmVGV4dExlbgBuYW4AU2V0Q2xpcGJvYXJkVGV4dEZuAEdldENsaXBib2FyZFRleHRGbgBXZWlnaHQ9JWYlbgBPcmRlcj0lZCVuAFdpZHRoPSVkJW4AVmlzaWJsZT0lZCVuAENvbHVtbiAlZCVuAFNvcnQ9JWQlYyVuAFVzZXJJRD0weCUwOFglbgBzbGlkZXIgZW51bQBQbHVtAEFxdWFyaXVtAEJvdHRvbQBDdXN0b20AIyNpdGVtAFNvbWUgbWVudSBpdGVtAE1lbnUgaXRlbQBUZXh0IGFsaWduZWQgdG8gZnJhbWVkIGl0ZW0AU29tZSBmcmFtZWQgaXRlbQBJVEVNOiBNZW51SXRlbQBCZWdpblBvcHVwQ29udGV4dEl0ZW0ATmF2U2NvcmVJdGVtAEJlZ2luVGFiSXRlbQBFbmRUYWJJdGVtAFBsb3RIaXN0b2dyYW0AQnJlYW0AS2V5Q3RybABib29sAEN1cnZlVGVzc2VsbGF0aW9uVG9sAGZpc2hfaGF0LmlubABzbGlkZXIgdTggZnVsbABzbGlkZXIgczggZnVsbABzbGlkZXIgdTE2IGZ1bGwAc2xpZGVyIHMxNiBmdWxsAHNsaWRlciB1NjQgZnVsbABzbGlkZXIgczY0IGZ1bGwAc2xpZGVyIHUzMiBmdWxsAHNsaWRlciBzMzIgZnVsbABTaXplRnVsbABBdXRvLXNjcm9sbABJbUd1aVRhYkJhckZsYWdzX0ZpdHRpbmdQb2xpY3lTY3JvbGwAQW50aS1hbGlhc2VkIGZpbGwAQW50aUFsaWFzZWRGaWxsACMjY2VsbABzbWFsbAAjI2NoZWNrYWxsAE9wZW4gYWxsAFJlbW92ZSBhbGwAQ2xvc2UgYWxsAFJlc2l6ZUFsbABTaXplIGFsbCBjb2x1bW5zIHRvIGRlZmF1bHQjIyNTaXplQWxsAFNpemUgYWxsIGNvbHVtbnMgdG8gZml0IyMjU2l6ZUFsbABXaW5kb3dTZXR0aW5nc0hhbmRsZXJfV3JpdGVBbGwAR2V0Q29udGVudFJlZ2lvbkF2YWlsAGJ5dGVzX3Blcl9waXhlbABHZXRGb250VGV4VXZXaGl0ZVBpeGVsAENsb3NlUG9wdXBUb0xldmVsAE1hY2tlcmVsAFNldEN1cnJlbnRDaGFubmVsAE1vdXNlV2hlZWwARGVmYXVsdDogRmxvYXQgKyBIRFIgKyBIdWUgV2hlZWwARGlzYWJsZSBNb3VzZSBXaGVlbABDYW5jZWwAbGFiZWwAZW1zY3JpcHRlbjo6dmFsAGhvcml6b250YWwAIyNvcmlnaW5hbABPcmlnaW5hbABoZXhhZGVjaW1hbABDb250ZW50SWRlYWwAQ29sdW1uc0NvbnRlbnRIZWFkZXJzSWRlYWwAQ29udGVudFNpemVJZGVhbABCZWdpblBvcHVwTW9kYWwAdmVydGljYWwAU2F2ZSB0byBkaXNrAENoZWNrTWFyawBTdHlsZUNvbG9yc0RhcmsAbmV4dF9jaHVuawBzaHJpbmsAaW8uQ29uZmlnSW5wdXRUZXh0Q3Vyc29yQmxpbmsAUGluawBubyBibGFuawBQb2xsb2NrAEhhZGRvY2sAT3BlblBvcHVwT25JdGVtQ2xpY2sASVRFTTogVHJlZU5vZGUgdy8gSW1HdWlUcmVlTm9kZUZsYWdzX09wZW5PbkRvdWJsZUNsaWNrAFRyYWNrAEZpbmRHbHlwaE5vRmFsbGJhY2sATXlSZXNpemVDYWxsYmFjawBBZGRDYWxsYmFjawBSZXNpemUgQ2FsbGJhY2sAcG9wX2JhY2sAS2l3aQBpbWd1aQBBYm91dCBEZWFyIEltR3VpAEltR3VpVGFibGVGbGFnc19Tb3J0TXVsdGkAZGVza3RvcC5pbmkAaW1ndWkuaW5pACMjSW5pAEJyb2Njb2xpAEJpYmkAUG9zPSVpLCVpAFNpemU9JWksJWkARWFydGgARGVmYXVsdCBEZXB0aABCb3RoAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGJ5dGVMZW5ndGgAaW5uZXJfd2lkdGgAdGFibGVfaXRlbV93aWR0aABXcmFwIHdpZHRoAEl0ZW0gd2lkdGgAVGV4V2lkdGgAR2V0V2luZG93V2lkdGgAX05vSGVhZGVyV2lkdGgAR2V0V2luZG93Q29udGVudFJlZ2lvbldpZHRoAFRhYmxlU2V0Q29sdW1uV2lkdGgAR2V0Q29sdW1uV2lkdGgAVGFibGVVcGRhdGVDb2x1bW5zV2VpZ2h0RnJvbVdpZHRoAFNldE5leHRJdGVtV2lkdGgAUG9wSXRlbVdpZHRoAFB1c2hJdGVtV2lkdGgAQ2FsY0l0ZW1XaWR0aABJbUd1aVRyZWVOb2RlRmxhZ3NfU3BhbkZ1bGxXaWR0aABJbUd1aVRyZWVOb2RlRmxhZ3NfU3BhbkF2YWlsV2lkdGgAV2lkZ2V0cyBXaWR0aABQYXRoACNUcmVlUHVzaABMb2dGaW5pc2gAVGlsZWZpc2gAZ2x5cGgASW1Gb250R2x5cGgAQ3JlYXRlR2x5cGgARmluZEdseXBoAGFhYWFhYWFhIGJiYmJiYmJiLCBjIGNjY2NjY2NjLGRkZGRkZGRkLiBkIGVlZWVlZWVlICAgZmZmZmZmZmYuIGdnZ2dnZ2dnIWhoaGhoaGhoAHNsaWRlciBmbG9hdCBoaWdoAHNsaWRlciBkb3VibGUgaGlnaABzbGlkZXIgdTY0IGhpZ2gAc2xpZGVyIHM2NCBoaWdoAHNsaWRlciB1MzIgaGlnaABzbGlkZXIgczMyIGhpZ2gAUmVzaXphYmxlLCBzdHJldGNoAF9XaWR0aFN0cmV0Y2gAbXkgc2FpbG9yIGlzIHJpY2gAUmljaABLTyBCbGFoYmxhaABPSyBCbGFoYmxhaABUaGlzIGlzIHRoZSBDdWN1bWJlciB0YWIhCmJsYWggYmxhaCBibGFoIGJsYWggYmxhaABUaGlzIGlzIHRoZSBBdm9jYWRvIHRhYiEKYmxhaCBibGFoIGJsYWggYmxhaCBibGFoAFRoaXMgaXMgdGhlIEJyb2Njb2xpIHRhYiEKYmxhaCBibGFoIGJsYWggYmxhaCBibGFoAEJsYWggYmxhaCBibGFoAEJsYWggYmxhaApCbGFoIEJsYWgALi4vaW1zdGJfdGV4dGVkaXQuaABmaXNoX2hhdC5oAEhlbGxvLmgALi4vaW1ndWlfaW50ZXJuYWwuaAAuLlxpbWd1aS5oAC4uL2ltZ3VpLmgAYWJjLmgAc2xpZGVyIGZsb2F0IGxvdyBsb2cAc2xpZGVyIGRvdWJsZSBsb3cgbG9nAGRyYWcgZmxvYXQgbG9nAGRyYWcgZG91YmxlIGxvZwAlaSBUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nAEV4YW1wbGU6IExvZwBDb3B5IG9mIEltYWdlMDAxLnBuZwBDb3B5IG9mIEltYWdlMDAxIChGaW5hbDIpLnBuZwBbZXJyb3JdIHNvbWV0aGluZyB3ZW50IHdyb25nAFRhYmxlQm9yZGVyU3Ryb25nAHVuc2lnbmVkIGxvbmcASG92ZXJlZC9BY3RpdmUgdGVzdHMgYWZ0ZXIgQmVnaW4oKSBmb3IgdGl0bGUgYmFyIHRlc3RpbmcAdGFibGVfc29ydGluZwBTb3J0aW5nAHN0ZDo6d3N0cmluZwBiYXNpY19zdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcARGF0YVR5cGVGb3JtYXRTdHJpbmcAU2hvdyBJbURyYXdDbWQgYm91bmRpbmcgYm94ZXMgd2hlbiBob3ZlcmluZwBTaG93IEltRHJhd0NtZCBtZXNoIHdoZW4gaG92ZXJpbmcARmlsdGVyaW5nAEV4YW1wbGU6IEN1c3RvbSByZW5kZXJpbmcAUmVuZGVyaW5nAElzV2luZG93QXBwZWFyaW5nAFZlcnRpY2FsIHNjcm9sbGluZywgd2l0aCBjbGlwcGluZwBDYWxjTGlzdENsaXBwaW5nAHdvcmQtd3JhcHBpbmcAV29yZC13cmFwcGluZwBXb3JkIFdyYXBwaW5nAEhvcml6b250YWwgc2Nyb2xsaW5nACMjSG9yaXpvbnRhbFNjcm9sbGluZwAjI1ZlcnRpY2FsU2Nyb2xsaW5nAEhvcml6b250YWwgU2Nyb2xsaW5nAExheW91dCAmIFNjcm9sbGluZwBGb250QWxsb3dVc2VyU2NhbGluZwBDYXB0dXJlL0xvZ2dpbmcASXNNb3VzZURyYWdnaW5nAFdpbmRvd1JvdW5kaW5nAFNjcm9sbGJhclJvdW5kaW5nAFBvcHVwUm91bmRpbmcARnJhbWVSb3VuZGluZwBDaGlsZFJvdW5kaW5nAEdyYWJSb3VuZGluZwBUYWJSb3VuZGluZwAhd2luZG93LT5EQy5NZW51QmFyQXBwZW5kaW5nAF9QcmVmZXJTb3J0RGVzY2VuZGluZwBfTm9Tb3J0RGVzY2VuZGluZwBfUHJlZmVyU29ydEFzY2VuZGluZwBfTm9Tb3J0QXNjZW5kaW5nAHRhYmxlX3BhZGRpbmcARGlzcGxheVdpbmRvd1BhZGRpbmcAQ2VsbFBhZGRpbmcAQWxpZ25UZXh0VG9GcmFtZVBhZGRpbmcAVG91Y2hFeHRyYVBhZGRpbmcARGlzcGxheVNhZmVBcmVhUGFkZGluZwBTYWZlIEFyZWEgUGFkZGluZwBJbmRlbnRTcGFjaW5nAEl0ZW1Jbm5lclNwYWNpbmcAQ29sdW1uc01pblNwYWNpbmcASXRlbVNwYWNpbmcAR2V0VHJlZU5vZGVUb0xhYmVsU3BhY2luZwBHZXRUZXh0TGluZUhlaWdodFdpdGhTcGFjaW5nAEdldEZyYW1lSGVpZ2h0V2l0aFNwYWNpbmcAR2x5cGhFeHRyYVNwYWNpbmcAVGFiYmluZwBJbUZvbnRDb25maWcAJS4wZiBkZWcAc2hvd193aWRnZXRfZnJhbWVfYmcASG9sZGluZyBtZSBjbGVhcnMgdGhlCnRoZSBrZXlib2FyZCBjYXB0dXJlIGZsYWcASG92ZXJpbmcgbWUgc2V0cyB0aGUKa2V5Ym9hcmQgY2FwdHVyZSBmbGFnAE5hdlVwZGF0ZUFueVJlcXVlc3RGbGFnAEV2ZW50RmxhZwBQb3BJdGVtRmxhZwBQdXNoSXRlbUZsYWcAV2luZG93QmcAVGFibGVSb3dCZwBJbUd1aVRhYmxlRmxhZ3NfUm93QmcAVGFibGVIZWFkZXJCZwBTY3JvbGxiYXJCZwBNZW51QmFyQmcAUG9wdXBCZwBNb2RhbFdpbmRvd0RpbUJnAE5hdldpbmRvd2luZ0RpbUJnAEZyYW1lQmcAVGl0bGVCZwBDaGlsZEJnAFRleHRTZWxlY3RlZEJnACVkOiAlOC40ZwolZDogJTguNGcAYnVmAG15X3N0ci0+YmVnaW4oKSA9PSBkYXRhLT5CdWYAaW5mAEFsaWduIHRvIHJpZ2h0IGVkZ2UgbWludXMgaGFsZgAlbGYAc2Fucy1zZXJpZgAjI29mZgBSZXZlcnQgUmVmAFNhdmUgUmVmACUuOGYAIFdlaWdodD0lLjRmAFY6JTAuM2YAUzolMC4zZgBSOiUwLjNmAEg6JTAuM2YARzolMC4zZgBCOiUwLjNmAEE6JTAuM2YAcmF0aW8gPSAlLjNmACVzOiAlLjNmAEg6ICUuM2YsIFM6ICUuM2YsIFY6ICUuM2YASDogJS4zZiwgUzogJS4zZiwgVjogJS4zZiwgQTogJS4zZgAlLjAyZgBzdHlsZS5XaW5kb3dQYWRkaW5nOiAlLjJmLCUuMmYAc3R5bGUuRnJhbWVQYWRkaW5nOiAlLjJmLCUuMmYAc3R5bGUuSXRlbUlubmVyU3BhY2luZzogJS4yZiwlLjJmAHN0eWxlLkl0ZW1TcGFjaW5nOiAlLjJmLCUuMmYAaW8uRGlzcGxheVNpemU6ICUuMmYsJS4yZgBpby5EaXNwbGF5RnJhbWVidWZmZXJTY2FsZTogJS4yZiwlLjJmAE9mZnNldCAlLjJmAFNldHRpbmdzRGlydHlUaW1lciAlLjJmAEF2YWlsICUuMmYAV2lkdGggJS4yZgBbJWRdICUuMmYAbWluX3Jvd19oZWlnaHQgPSAlLjJmAHN0eWxlLkZyYW1lUm91bmRpbmc6ICUuMmYAc3R5bGUuV2luZG93Qm9yZGVyU2l6ZTogJS4yZgBzdHlsZS5GcmFtZUJvcmRlclNpemU6ICUuMmYATXlDb2xvciMjMmYAU2Nyb2xsICUuMWYvJS4xZiAlLjFmLyUuMWYAJTAyZCVjIFRhYiAweCUwOFggJyVzJyBPZmZzZXQ6ICUuMWYsIFdpZHRoOiAlLjFmLyUuMWYAaW8uQ29uZmlnTWVtb3J5Q29tcGFjdFRpbWVyID0gJS4xZgBNb3VzZSB3aGVlbDogJS4xZgBDZWxsUGFkZGluZ1g6ICUuMWYsIENlbGxTcGFjaW5nWDogJS4xZi8lLjFmLCBPdXRlclBhZGRpbmdYOiAlLjFmAEFkdmFuY2VYOiAlLjFmAFc6ICUuMWYAJS4xMGYAKihjb25zdCBmbG9hdCopcF9taW4gPj0gLTMuNDAyODIzNDdlKzM4RiAvIDIuMGYgJiYgKihjb25zdCBmbG9hdCopcF9tYXggPD0gMy40MDI4MjM0N2UrMzhGIC8gMi4wZgAqKGNvbnN0IGRvdWJsZSopcF9taW4gPj0gLTEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4IC8gMi4wZiAmJiAqKGNvbnN0IGRvdWJsZSopcF9tYXggPD0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDggLyAyLjBmAGNlbnRlcl95X3JhdGlvID49IDAuMGYgJiYgY2VudGVyX3lfcmF0aW8gPD0gMS4wZgBjZW50ZXJfeF9yYXRpbyA+PSAwLjBmICYmIGNlbnRlcl94X3JhdGlvIDw9IDEuMGYAY29sdW1uLT5TdHJldGNoV2VpZ2h0ID4gMC4wZgBJdGVtc0hlaWdodCA+IDAuMGYAdmlzaWJsZV93ZWlnaHQgPiAwLjBmICYmIHZpc2libGVfd2lkdGggPiAwLjBmAGNvbHVtbl8wX3dpZHRoID4gMC4wZiAmJiBjb2x1bW5fMV93aWR0aCA+IDAuMGYAdGFiLT5Db250ZW50V2lkdGggPiAwLjBmAHRhYmxlLT5NaW5Db2x1bW5XaWR0aCA+IDAuMGYAc2Nyb2xsYmFyX3NpemUgPiAwLjBmAHNjYWxlID4gMC4wZgBmb250LT5TY2FsZSA+IDAuMGYASW1NYXgoc2l6ZV9jb250ZW50c192LCBzaXplX2F2YWlsX3YpID4gMC4wZgBpbm5lcl93aWR0aCA+PSAwLjBmAHRhYmxlLT5Jbm5lcldpbmRvdy0+V2luZG93UGFkZGluZy54ID09IDAuMGYgJiYgdGFibGUtPklubmVyV2luZG93LT5XaW5kb3dQYWRkaW5nLnkgPT0gMC4wZiAmJiB0YWJsZS0+SW5uZXJXaW5kb3ctPldpbmRvd0JvcmRlclNpemUgPT0gMC4wZgBJdGVtc0hlaWdodCA8PSAwLjBmAHNpemVfYXJnLnggIT0gMC4wZiAmJiBzaXplX2FyZy55ICE9IDAuMGYAJS4wZnglLjBmACVzCiUuMGYvJS4wZgBSZWZTY2FsZT0lZgBhdmcgJWYAQXNjZW50OiAlZiwgRGVzY2VudDogJWYsIEhlaWdodDogJWYAVW5kZXJseWluZyBmbG9hdCB2YWx1ZTogJWYAVGFibGVTb3J0U3BlY3NTYW5pdGl6ZQBBdXRvLXJlc2l6ZQBObyByZXNpemUAQWx3YXlzQXV0b1Jlc2l6ZQBfTm9SZXNpemUASW1HdWlUYWJsZUZsYWdzX05vQm9yZGVyc0luQm9keVVudGlsUmVzaXplAEV4YW1wbGU6IENvbnN0cmFpbmVkIFJlc2l6ZQBvdXRlcl9zaXplAGFwcGx5X25ld190ZXh0X2xlbmd0aCA8PSBidWZfc2l6ZQBFeHBsaWNpdCBjb250ZW50IHNpemUAT3V0ZXIgc2l6ZQBJbml0aWFsaXplAERpc3BsYXlTaXplAEltRHJhd0lkeFNpemUAU2V0TmV4dFdpbmRvd1NpemUAU2V0V2luZG93U2l6ZQBHZXRXaW5kb3dTaXplAENhbGNUZXh0U2l6ZQBJbURyYXdWZXJ0U2l6ZQBHZXRGb250U2l6ZQBTZXROZXh0V2luZG93Q29udGVudFNpemUAQ3VycmVudFNpemUAR2V0SXRlbVJlY3RTaXplACMjT3V0ZXJTaXplAFdpbmRvd0JvcmRlclNpemUAUG9wdXBCb3JkZXJTaXplAEZyYW1lQm9yZGVyU2l6ZQBDaGlsZEJvcmRlclNpemUAVGFiQm9yZGVyU2l6ZQBTY3JvbGxiYXJTaXplAFdpbmRvd01pblNpemUAR3JhYk1pblNpemUAQnVmU2l6ZQBTZXRXaW5kb3dOYW1lU2l6ZQBJbUd1aVN0eWxlU2l6ZQBEZXNpcmVkU2l6ZQBJbUd1aUlPU2l6ZQBJbVZlYzRTaXplAEltVmVjMlNpemUAZy5XaW5kb3dzRm9jdXNPcmRlci5TaXplID09IGcuV2luZG93cy5TaXplAGNvbHVtbl9pbmRleCA8IGNvbHVtbnMtPkNvbHVtbnMuU2l6ZQAoaW50KWRyYXdfbGlzdC0+X1Z0eEN1cnJlbnRJZHggPT0gZHJhd19saXN0LT5WdHhCdWZmZXIuU2l6ZQBkcmF3X2xpc3QtPlZ0eEJ1ZmZlci5TaXplID09IDAgfHwgZHJhd19saXN0LT5fVnR4V3JpdGVQdHIgPT0gZHJhd19saXN0LT5WdHhCdWZmZXIuRGF0YSArIGRyYXdfbGlzdC0+VnR4QnVmZmVyLlNpemUAZHJhd19saXN0LT5JZHhCdWZmZXIuU2l6ZSA9PSAwIHx8IGRyYXdfbGlzdC0+X0lkeFdyaXRlUHRyID09IGRyYXdfbGlzdC0+SWR4QnVmZmVyLkRhdGEgKyBkcmF3X2xpc3QtPklkeEJ1ZmZlci5TaXplAGcuV2luZG93cy5TaXplID09IGcuV2luZG93c1RlbXBTb3J0QnVmZmVyLlNpemUAZHN0X3RtcCA9PSBnLkRyYXdDaGFubmVsc1RlbXBNZXJnZUJ1ZmZlci5EYXRhICsgZy5EcmF3Q2hhbm5lbHNUZW1wTWVyZ2VCdWZmZXIuU2l6ZQByZW1haW5pbmcgPj0gMCAmJiByZW1haW5pbmcgPCBnLk9wZW5Qb3B1cFN0YWNrLlNpemUAdGFiLT5OYW1lT2Zmc2V0ICE9IC0xICYmIChpbnQpdGFiLT5OYW1lT2Zmc2V0IDwgVGFic05hbWVzLkJ1Zi5TaXplAG9mZiA+PSA0ICYmIG9mZiA8IEJ1Zi5TaXplAHAgPj0gQnVmLkRhdGEgJiYgcCA8IEJ1Zi5EYXRhICsgQnVmLlNpemUAdGV4dF9sZW4gPCBvYmotPlRleHRXLlNpemUAbmV3X3NpemUgPD0gU2l6ZQBpID49IDAgJiYgaSA8IFNpemUAaXQgPj0gRGF0YSAmJiBpdCA8PSBEYXRhICsgU2l6ZQBpdCA+PSBEYXRhICYmIGl0IDwgRGF0YSArIFNpemUAVGFibGVTZXR1cFNjcm9sbEZyZWV6ZQBDdXJ2ZQBQcmltVW5yZXNlcnZlAFByaW1SZXNlcnZlAE5vIG1vdmUATW92ZQBOYXZBY3RpdmUAV2FzQWN0aXZlAFNlcGFyYXRvckFjdGl2ZQBIZWFkZXJBY3RpdmUAZy5BY3RpdmVJZCA9PSBpZCB8fCBnLkFjdGl2ZUlkID09IDAgfHwgZy5EcmFnRHJvcEFjdGl2ZQBSZXNpemVHcmlwQWN0aXZlAEJ1dHRvbkFjdGl2ZQBJc0FueUl0ZW1BY3RpdmUASXNJdGVtQWN0aXZlAEZyYW1lQmdBY3RpdmUAVGl0bGVCZ0FjdGl2ZQBUYWJVbmZvY3VzZWRBY3RpdmUAU2xpZGVyR3JhYkFjdGl2ZQBTY3JvbGxiYXJHcmFiQWN0aXZlAFRhYkFjdGl2ZQBwYXJlbnRfd2luZG93ICYmIHBhcmVudF93aW5kb3ctPkFjdGl2ZQBJdGVtIEZpdmUAU2F2ZQBnLkN1cnJlbnRXaW5kb3ctPklzRmFsbGJhY2tXaW5kb3cgPT0gdHJ1ZQBPcGFxdWUAYmx1ZQAjI3ZhbHVlACMjVmFsdWUAaHVlACMjcGFsZXR0ZQBQYWxldHRlAFBhc3RlAEltR3VpVGFibGVGbGFnc19Tb3J0VHJpc3RhdGUASW50ZXJuYWwgc3RhdGUAR2V0SW5wdXRUZXh0U3RhdGUASW1HdWlJbnB1dFRleHRTdGF0ZQBDb21wYXJlV2l0aEN1cnJlbnRTdGF0ZQBLZXlib2FyZCwgTW91c2UgJiBOYXZpZ2F0aW9uIFN0YXRlAEZyYW1lcmF0ZQBBbmltYXRlAEFic3F1YXR1bGF0ZQBJdGVyYXRlR2x5cGhUb0NyZWF0ZQBOYXZVcGRhdGUAUGF0aExpbmVUb01lcmdlRHVwbGljYXRlAEtleVJlcGVhdFJhdGUASW5pU2F2aW5nUmF0ZQBpby5Db25maWdGbGFnczogTm9Nb3VzZQBXYW50Q2FwdHVyZU1vdXNlAHNsaWRlciB1OCByZXZlcnNlAHNsaWRlciBzOCByZXZlcnNlAHNsaWRlciB1NjQgcmV2ZXJzZQBzbGlkZXIgczY0IHJldmVyc2UAc2xpZGVyIHUzMiByZXZlcnNlAHNsaWRlciBzMzIgcmV2ZXJzZQBObyBjb2xsYXBzZQBObyBjbG9zZQBDbG9zZQBnLkRyYWdEcm9wV2l0aGluVGFyZ2V0ID09IGZhbHNlAHRhYmxlLT5Jc1VuZnJvemVuUm93cyA9PSBmYWxzZQBnLldpdGhpbkVuZENoaWxkID09IGZhbHNlAHRhYmxlLT5NZW1vcnlDb21wYWN0ZWQgPT0gZmFsc2UAZy5Mb2dFbmFibGVkID09IGZhbHNlAHRhYmxlICE9IDBMICYmIHRhYmxlLT5Jc0xheW91dExvY2tlZCA9PSBmYWxzZQBlcmFzZQB1cHBlcmNhc2UAQXRsYXMgdGV4dHVyZQBBbnRpLWFsaWFzZWQgbGluZXMgdXNlIHRleHR1cmUARmlyZQBlbnRlciB0ZXh0IGhlcmUAVG9vbHRpcCBoZXJlAFNldEtleWJvYXJkRm9jdXNIZXJlAEN1c3RvbTogQWx3YXlzIFNxdWFyZQBEYXRhVHlwZUNvbXBhcmUAIyNvdXRwdXRfdHlwZQAjI3Nob3dfd2luZG93c19yZWN0X3R5cGUAIyNzaG93X3RhYmxlX3JlY3RzX3R5cGUAVGVzdCB0eXBlAHJvdyBiZyB0eXBlAGNlbGwgYmcgdHlwZQBJdGVtIFR5cGUAZy5XaXRoaW5GcmFtZVNjb3BlAExvZ1NsaWRlckRlYWR6b25lAHRhcmdldCAhPSBJbUd1aVRhYmxlQmdUYXJnZXRfTm9uZQBnLk5hdk1vdmVEaXIgIT0gSW1HdWlEaXJfTm9uZSAmJiBnLk5hdk1vdmVDbGlwRGlyICE9IEltR3VpRGlyX05vbmUAc29ydF9kaXJlY3Rpb24gIT0gSW1HdWlTb3J0RGlyZWN0aW9uX05vbmUAZy5OYXZNb3ZlUmVxdWVzdEZvcndhcmQgPT0gSW1HdWlOYXZGb3J3YXJkX05vbmUAL3BhdGgvb25lAExpa2UgdGhpcyBvbmUAUmVtb3ZlIG9uZQBBZGRQb2x5bGluZQBJbnB1dFRleHRNdWx0aWxpbmUAUmVuZGVyaW5nIG1vcmUgdGV4dCBpbnRvIHRoZSBzYW1lIGxpbmUAQnkgZGVmYXVsdCwgU2VsZWN0YWJsZXMgdXNlcyBzdHlsZS5TZWxlY3RhYmxlVGV4dEFsaWduIGJ1dCBpdCBjYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIHBlci1pdGVtIGJhc2lzIHVzaW5nIFB1c2hTdHlsZVZhcigpLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byBhbHdheXMga2VlcCB5b3VyIGRlZmF1bHQgc2l0dWF0aW9uIHRvIGxlZnQtYWxpZ24gb3RoZXJ3aXNlIGl0IGJlY29tZXMgZGlmZmljdWx0IHRvIGxheW91dCBtdWx0aXBsZSBpdGVtcyBvbiBhIHNhbWUgbGluZQBCbGFpbmUASW1HdWlJbnB1dFRleHRGbGFnc19DdHJsRW50ZXJGb3JOZXdMaW5lAFNhbWVMaW5lAEFkZExpbmUAbGVmdCBwYW5lAFNpemUgY29sdW1uIHRvIGZpdCMjI1NpemVPbmUAT25lT25lT25lAEl0ZW0gT25lAERvbid0IGFzayBtZSBuZXh0IHRpbWUAR2V0VGltZQBNb3VzZURvdWJsZUNsaWNrVGltZQBEZWx0YVRpbWUAVXBkYXRlTW91c2VNb3ZpbmdXaW5kb3dOZXdGcmFtZQBHZXRBY3RpdmVJZFByZXZpb3VzRnJhbWUAR2V0SG92ZXJlZElkUHJldmlvdXNGcmFtZQBOYXZFbmRGcmFtZQBCZWdpbkNoaWxkRnJhbWUARW5kQ2hpbGRGcmFtZQBJbmlGaWxlbmFtZQBMb2dGaWxlbmFtZQBJbUd1aVRhYmxlRmxhZ3NfU2l6aW5nU3RyZXRjaFNhbWUASW1HdWlUYWJsZUZsYWdzX1NpemluZ0ZpeGVkU2FtZQBGb250TmFtZQBHZXRTdHlsZUNvbG9yTmFtZQBCYWNrZW5kUmVuZGVyZXJOYW1lAFRhYmxlR2V0Q29sdW1uTmFtZQBCYWNrZW5kUGxhdGZvcm1OYW1lAEdldFRhYk5hbWUALSBvciBtZQBIb3ZlciBvdmVyIG1lAENsaWNrIG1lAEZvbnRTdHlsZQBHZXRTdHlsZQBJbUd1aVN0eWxlAEFuaW1hdGVkIHRpdGxlICVjICVkIyMjQW5pbWF0ZWRUaXRsZQBBIFJhdGhlciBMb25nIFRpdGxlAFBpbmVhcHBsZQBBcHBsZQBDbG9zZSBDb25zb2xlAEV4YW1wbGU6IENvbnNvbGUAQXVkaW8gZmlsZQBTeXN0ZW0gZmlsZQBJbWFnZSBmaWxlAFNob3dFeGFtcGxlTWVudUZpbGUATG9nVG9GaWxlAExvZyBUbyBGaWxlAEFkZFRyaWFuZ2xlAHNsaWRlciBhbmdsZQBTbGlkZXJBbmdsZQBBZGRDaXJjbGUAaW5wdXQgZG91YmxlAGRyYWcgZG91YmxlAElucHV0RG91YmxlACFpc192aXNpYmxlAE5hdlZpc2libGUASW1HdWlUYWJsZUZsYWdzX05vS2VlcENvbHVtbnNWaXNpYmxlAF9Jc1Zpc2libGUASXNJdGVtVmlzaWJsZQB0YWItPkxhc3RGcmFtZVZpc2libGUgPj0gdGFiX2Jhci0+UHJldkZyYW1lVmlzaWJsZQB0YWJsZS0+RmxhZ3MgJiBJbUd1aVRhYmxlRmxhZ3NfUmVzaXphYmxlAHRhYmxlLT5GbGFncyAmIEltR3VpVGFibGVGbGFnc19Tb3J0YWJsZQAjI3NlbGVjdGFibGUAMy4gSSBhbSBub3Qgc2VsZWN0YWJsZQA0LiBJIGFtIHNlbGVjdGFibGUAMi4gSSBhbSBzZWxlY3RhYmxlADEuIEkgYW0gc2VsZWN0YWJsZQBTZWxlY3RhYmxlAGcuQ3VycmVudFdpbmRvdyA9PSBvdXRlcl93aW5kb3cgJiYgZy5DdXJyZW50VGFibGUgPT0gdGFibGUAX0luZGVudERpc2FibGUASW1HdWlUYWJCYXJGbGFnc19SZW9yZGVyYWJsZQB0YWJsZS0+RmxhZ3MgJiBJbUd1aVRhYmxlRmxhZ3NfUmVvcmRlcmFibGUAX0luZGVudEVuYWJsZQA1LiBJIGFtIGRvdWJsZSBjbGlja2FibGUASW1HdWlUYWJsZUZsYWdzX0hpZGVhYmxlAEJlZ2luVGFibGUARW5kVGFibGUAd2luZG93IHNjYWxlAEZvbnQgc2NhbGUAZ2xvYmFsIHNjYWxlAFNldFdpbmRvd0ZvbnRTY2FsZQBNb3VzZUN1cnNvclNjYWxlAERpc3BsYXlGcmFtZWJ1ZmZlclNjYWxlAEZvbnRHbG9iYWxTY2FsZQBQYXRoU3Ryb2tlAEFydGljaG9rZQBDaGFubmVsc01lcmdlAE9yYW5nZQBpby5Db25maWdGbGFnczogTm9Nb3VzZUN1cnNvckNoYW5nZQBBbGlnbiB0byByaWdodCBlZGdlAFNldFN0YXRlU3RvcmFnZQBHZXRTdGF0ZVN0b3JhZ2UAI2ltYWdlAEFkZEltYWdlAHRyZWUAL3BhdGgvdGhyZWUAVGhyZWVUaHJlZVRocmVlAEl0ZW0gVGhyZWUAT25lClR3bwpUaHJlZQBUcmVlAE1lbUZyZWUAU25pY2tlcnNuZWUAdGhpcyBpcyBhIHRyZWUgbm9kZQBUcmVlIG5vZGUAZmlsZW5hbWUgJiYgbW9kZQBGb2N1cyBmcm9tIGNvZGUAU2Nyb2xsIGZyb20gY29kZQBJVEVNOiBUcmVlTm9kZQBNZXJnZU1vZGUARGlzcGxheSBNb2RlAFBpY2tlciBNb2RlAFNob3dVc2VyR3VpZGUAIyNjdXJ2ZXNzZWdtZW50b3ZlcnJpZGUAIyNjaXJjbGVzZWdtZW50b3ZlcnJpZGUAQ3VydmVzIHNlZ21lbnRzIG92ZXJyaWRlAENpcmNsZSBzZWdtZW50cyBvdmVycmlkZQBfRGVmYXVsdEhpZGUAX05vSGlkZQBMZXR0dWNlACMjc291cmNlAFRoaXMgaXMgYSBkcmFnIGFuZCBkcm9wIHNvdXJjZQBUZXN0IHRyZWUgbm9kZSBhcyBkcmFnIHNvdXJjZQBCZWdpbkRyYWdEcm9wU291cmNlAEVuZERyYWdEcm9wU291cmNlAEN1cnZlIFRlc3NlbGxhdGlvbiBUb2xlcmFuY2UAY29uZCA9PSBJbUd1aUNvbmRfQWx3YXlzIHx8IGNvbmQgPT0gSW1HdWlDb25kX09uY2UAQmVhdHJpY2UAc3RiX3RleHRlZGl0X3JlcGxhY2UATWV0cmljc1RvdGFsU3VyZmFjZQBEcmFnIE1lACVlAHBhc3N3b3JkAE5hdk1vdmVSZXF1ZXN0Rm9yd2FyZABOYXZLZXlib2FyZABXYW50Q2FwdHVyZUtleWJvYXJkACBOYXZOb0NhcHR1cmVLZXlib2FyZABpby5Db25maWdGbGFnczogTmF2RW5hYmxlS2V5Ym9hcmQAQ29weSB0byBjbGlwYm9hcmQAQ29weSAiSGVsbG8sIHdvcmxkISIgdG8gY2xpcGJvYXJkAExvZ1RvQ2xpcGJvYXJkAExvZyBUbyBDbGlwYm9hcmQAQmVybmFyZABObyBiYWNrZ3JvdW5kAEJvcmRlcnMsIGJhY2tncm91bmQAVGFiSXRlbUJhY2tncm91bmQAIyNCYWNrZ3JvdW5kACMjRm9yZWdyb3VuZAAoKGNoYXIqKShzdGF0ZS0+dW5kb19yZWMgKyBzdGF0ZS0+cmVkb19wb2ludCArIDEpICsgbW92ZV9zaXplKSA8PSBidWZfZW5kAEhhbmQARGlzcGxheUVuZABTZWxlY3Rpb25FbmQAaXQgPj0gRGF0YSAmJiBpdCA8IERhdGFFbmQAcCA+PSBEYXRhICYmIHAgPCBEYXRhRW5kAEltRHJhd0NtZABBZGREcmF3Q21kAGhlbGxvLCB3b3JsZABIZWxsbwpXb3JsZABJc01vdXNlRHJhZ1Bhc3RUaHJlc2hvbGQATW91c2VEcmFnVGhyZXNob2xkAGJ1dHRvbl9mbGFncyAmIEltR3VpQnV0dG9uRmxhZ3NfUHJlc3NlZE9uRHJhZ0Ryb3BIb2xkACVsbGQAVGFibGVTb3J0U3BlY3NCdWlsZABvdXRlcl9jaGlsZABCZWdpbkNoaWxkAEVuZENoaWxkAEZpZWxkAEVuYWJsZSBncmlkAEdyaWQAdm9pZABCZWdpblBvcHVwQ29udGV4dFZvaWQASXNNb3VzZVBvc1ZhbGlkAGcuQWN0aXZlSWQgPT0gaWQAY29sdW1ucy0+SUQgPT0gaWQAc3RhdGUgJiYgc3RhdGUtPklEID09IGlkAGhibGtoZABnLkluaXRpYWxpemVkAFJlc2l6YWJsZSwgbWl4ZWQAUmVzaXphYmxlLCBmaXhlZABfV2lkdGhGaXhlZABOb3RBbGxvd2VkAGcuTmF2TW92ZVJlcXVlc3RGb3J3YXJkID09IEltR3VpTmF2Rm9yd2FyZF9Gb3J3YXJkUXVldWVkAFRleHRVbmZvcm1hdHRlZABlcmFzZV91bnNvcnRlZABfSXNTb3J0ZWQASW5kZW50ZWQASXNJdGVtRWRpdGVkAE1hcmtJdGVtRWRpdGVkAE5vdCBTZWxlY3RlZABJc0l0ZW1EZWFjdGl2YXRlZABJc0l0ZW1BY3RpdmF0ZWQAQ2xlYXJHbHlwaENyZWF0ZWQAdW51c2VkAFRhYlVuZm9jdXNlZABJc1dpbmRvd0ZvY3VzZWQASXNBbnlJdGVtRm9jdXNlZABJc0l0ZW1Gb2N1c2VkAElzS2V5UHJlc3NlZABTZXROZXh0V2luZG93Q29sbGFwc2VkAFNldFdpbmRvd0NvbGxhcHNlZABJc1dpbmRvd0NvbGxhcHNlZABUaXRsZUJnQ29sbGFwc2VkAFNldFdpbmRvd05hbWVDb2xsYXBzZWQAU2V0VGFiSXRlbUNsb3NlZABJc0tleVJlbGVhc2VkAElzTW91c2VSZWxlYXNlZABDb2x1bW5zQ29udGVudEhlYWRlcnNVc2VkAFRleHRDb2xvcmVkAEZpcnN0IGdyb3VwIGhvdmVyZWQASXNXaW5kb3dIb3ZlcmVkAFBsb3RMaW5lc0hvdmVyZWQAX0lzSG92ZXJlZABTZXBhcmF0b3JIb3ZlcmVkAEhlYWRlckhvdmVyZWQAUmVzaXplR3JpcEhvdmVyZWQAQnV0dG9uSG92ZXJlZABJc0FueUl0ZW1Ib3ZlcmVkAElzSXRlbUhvdmVyZWQAUGxvdEhpc3RvZ3JhbUhvdmVyZWQARnJhbWVCZ0hvdmVyZWQAU2Nyb2xsYmFyR3JhYkhvdmVyZWQAVGFiSG92ZXJlZABPdXRlclJlY3RDbGlwcGVkAFRleHQgd3JhcHBlZABUZXh0V3JhcHBlZABBbGlnbmVkACh3aW5kb3ctPkZsYWdzIHwgZy5OYXZXaW5kb3ctPkZsYWdzKSAmIEltR3VpV2luZG93RmxhZ3NfTmF2RmxhdHRlbmVkAEJ1bWZ1enpsZWQAQWRkQ29udmV4UG9seUZpbGxlZABBZGRSZWN0RmlsbGVkAEFkZE5nb25GaWxsZWQAQWRkVHJpYW5nbGVGaWxsZWQAQWRkQ2lyY2xlRmlsbGVkAEFkZFF1YWRGaWxsZWQAVGV4dERpc2FibGVkAF9Jc0VuYWJsZWQASXNJdGVtQ2xpY2tlZABJc01vdXNlQ2xpY2tlZABJc01vdXNlRG91YmxlQ2xpY2tlZABDaGVja2VkAEFkZEltYWdlUm91bmRlZAAhZy5Jbml0aWFsaXplZCAmJiAhZy5TZXR0aW5nc0xvYWRlZAB0YWJsZV9hZHZhbmNlZABBZHZhbmNlZABSZWQAQWRkSW1hZ2VRdWFkAEFkZFF1YWQATmF2R2FtZXBhZABpby5CYWNrZW5kRmxhZ3M6IEhhc0dhbWVwYWQAaW8uQ29uZmlnRmxhZ3M6IE5hdkVuYWJsZUdhbWVwYWQAQWNjZXB0RHJhZ0Ryb3BQYXlsb2FkAFNldERyYWdEcm9wUGF5bG9hZABHZXREcmFnRHJvcFBheWxvYWQAR2V0SW5wdXRUZXh0SWQAU2V0QWN0aXZlSWQAR2V0QWN0aXZlSWQAZy5OYXZBY3RpdmF0ZURvd25JZCA9PSBnLk5hdkFjdGl2YXRlSWQAZm9udC0+Q29udGFpbmVyQXRsYXMtPlRleElEID09IF9DbWRIZWFkZXIuVGV4dHVyZUlkAEdldEhvdmVyZWRJZAAlSTY0ZAAlMDRkACUwM2QAVjolM2QAUzolM2QAUjolM2QASDolM2QARzolM2QAQjolM2QAQTolM2QAIyNNZW51XyUwMmQAIyNUb29sdGlwXyUwMmQAIyNDb21ib18lMDJkAENvbHVtbiAlLTJkAE5vZGUlZABiJWQARmllbGRfJWQAZGVmaW5lOiBfX2NwbHVzcGx1cz0lZAAgT3JkZXI9JWQAIFdpZHRoPSVkACBWaXNpYmxlPSVkADB4JTA4WCAiJXMiIFBvcyAoJWQsJWQpIFNpemUgKCVkLCVkKSBDb2xsYXBzZWQ9JWQAZGVmaW5lOiBfX0dOVUNfXz0lZAAlZC8lZABOb2RlJWQuJWQAJXMgJWQsJWQASGVsbG8gJWQsJWQAVGhpcyBpcyB0aGUgcG9wdXAgZm9yIEJ1dHRvbigiLi4iKSBpbiBDZWxsICVkLCVkAEhlbGxvIHdvcmxkICVkLCVkAEZpeGVkICVkLCVkAGlvLkZvbnRzOiAlZCBmb250cywgRmxhZ3M6IDB4JTA4WCwgVGV4U2l6ZTogJWQsJWQAMHglMDhYLCVkAFJvdyAlZABTY3JvbGxpbmcgVGV4dCAlZABTb21lIHRlc3QgJWQATW9yZSBjb250ZW50ICVkAFNvbWUgY29udGVudCAlZABNeU9iamVjdCAlZABUaGlzIGlzIGEgY3VzdG9tIHBvcHVwIGZvciBDb2x1bW4gJWQAUm93ICVkIENvbHVtbiAlZABJdGVtICVkAHRoaXMgY2VsbCAlZABTZWxlY3RhYmxlIExlYWYgJWQAJSpzVGhpcyBpcyBsaW5lICVkAExpbmUgJWQAU3luY2VkIFRhYmxlICVkAFNlbGVjdGFibGUgTm9kZSAlZABDaGlsZCAlZABJdGVtID0gJWQARGF0YTogJXAKU2l6ZTogJWQKQ2FwYWNpdHk6ICVkAEFjdGl2ZTogJWQvJWQsIFdyaXRlQWNjZXNzZWQ6ICVkLCBCZWdpbk9yZGVyV2l0aGluQ29udGV4dDogJWQAV2FudFRleHRJbnB1dDogJWQATXlPYmplY3Q6ICVkAEl0ZW0gd2l0aCBmb2N1czogJWQAV2FudFNldE1vdXNlUG9zOiAlZABBcHBlYXJpbmc6ICVkLCBIaWRkZW46ICVkIChDYW5Ta2lwICVkIENhbm5vdCAlZCksIFNraXBJdGVtczogJWQAJXM6ICVkAE5hdklkOiAweCUwOFgsIE5hdkxheWVyOiAlZABOYXZEaXNhYmxlSGlnaGxpZ2h0OiAlZCwgTmF2RGlzYWJsZU1vdXNlSG92ZXI6ICVkAEhvdmVyZWRDb2x1bW5Cb2R5OiAlZCwgSG92ZXJlZENvbHVtbkJvcmRlcjogJWQASG92ZXJlZElkOiAweCUwOFgvMHglMDhYICglLjJmIHNlYyksIEFsbG93T3ZlcmxhcDogJWQASG92ZXJlZCBjb2x1bW46ICVkAFJlc2l6ZWRDb2x1bW46ICVkLCBSZW9yZGVyQ29sdW1uOiAlZCwgSGVsZEhlYWRlckNvbHVtbjogJWQAV2FudENhcHR1cmVNb3VzZTogJWQATmF2QWN0aXZlOiAlZCwgTmF2VmlzaWJsZTogJWQAV2FudENhcHR1cmVLZXlib2FyZDogJWQASXNJdGVtSG92ZXJlZDogJWQAc2l6ZW9mKHNpemVfdCk6ICVkLCBzaXplb2YoSW1EcmF3SWR4KTogJWQsIHNpemVvZihJbURyYXdWZXJ0KTogJWQAQXNjAHN0ZDo6YmFkX2FsbG9jAE1lbUFsbG9jAGZ1bmMAQWRkQmV6aWVyUXVhZHJhdGljAE11c2ljAFN0eWxlQ29sb3JzQ2xhc3NpYwBCYXNpYwBJbUd1aVNsaWRlckZsYWdzX0xvZ2FyaXRobWljAGlucHV0IHNjaWVudGlmaWMAQWRkQmV6aWVyQ3ViaWMAJS4yZgpzZWMAR2V0U3BlYwBhYmMATXlDb2xvciMjM2MAZmlzaF9oYXQuYwBtYWluLmMAY2NjMS5jAGJiYjEuYwBhYWExLmMAIFNvcnQ9JWQlYwAlYyVjJWMAcmFkaW8gYwByYgAjI3JnYgBzaG93X21lc2ggfHwgc2hvd19hYWJiAFNsaWRlckdyYWIAU2Nyb2xsYmFyR3JhYgBUYWJCYXJDbG9zZVRhYgBmbG9hdCAoaW5kZW50ZWQpIyM1YgBmbG9hdCAoaW5kZW50ZWQpIyM0YgBNeUNvbG9yIyMzYgBmbG9hdCAoaW5kZW50ZWQpIyMzYgBmbG9hdCAoaW5kZW50ZWQpIyMyYgBmbG9hdCMjMWIAZmxvYXQgKGluZGVudGVkKSMjMWIAcmFkaW8gYgByd2EAUmVzZXRNb3VzZURyYWdEZWx0YQBHZXRNb3VzZURyYWdEZWx0YQBNb3VzZURlbHRhAEdldERyYXdEYXRhAEFkZERyYXdMaXN0VG9EcmF3RGF0YQBJbURyYXdEYXRhAEZvbnREYXRhAEJhY2tlbmRSZW5kZXJlclVzZXJEYXRhAEJhY2tlbmRQbGF0Zm9ybVVzZXJEYXRhAEJhY2tlbmRMYW5ndWFnZVVzZXJEYXRhAENsaXBib2FyZFVzZXJEYXRhAEltR3VpSW5wdXRUZXh0Q2FsbGJhY2tEYXRhAEltR3VpU2l6ZUNhbGxiYWNrRGF0YQBTZXR0aW5nc0luaURhdGEAQ29uZmlnRGF0YQBHZXREcmF3TGlzdFNoYXJlZERhdGEAQnVmID09IGVkaXRfc3RhdGUtPlRleHRBLkRhdGEAY2FsbGJhY2tfZGF0YS5CdWYgPT0gc3RhdGUtPlRleHRBLkRhdGEAQnJpYW5uYQBhcmVuYQBCYW5hbmEAQWJpYmxpb3Bob2JpYQBhbHBoYQBTZXROZXh0V2luZG93QmdBbHBoYQBHbG9iYWwgQWxwaGEAV2l0aCBBbHBoYQAjI2Zsb2F0NWEAZmxvYXQjIzRhAGZsb2F0IyMzYQBmbG9hdCMjMmEAcmFkaW8gYQBbfl0AW3hdAFtlcnJvcl0AWyVkXQBvcGVyYXRvcltdAFsgXQB8Ly1cAENUUkwrWgAjI1oARm9jdXMgb24gWgBHZXRTY3JvbGxNYXhZAFN0YXJ0UG9zWQBTZXRDdXJzb3JQb3NZAEdldEN1cnNvclBvc1kAU2V0U2Nyb2xsRnJvbVBvc1kAU2Nyb2xsYmFyWQBTZXRTY3JvbGxZAEdldFNjcm9sbFkASW1HdWlUYWJsZUZsYWdzX1Njcm9sbFkAU2V0U2Nyb2xsSGVyZVkASW1HdWlUYWJsZUZsYWdzX05vSG9zdEV4dGVuZFkATG9nVG9UVFkATG9nIFRvIFRUWQBISVNUT1JZACNTQ1JPTExZAENMQVNTSUZZAENUUkwrWQAjI1kARm9jdXMgb24gWQBHZXRTY3JvbGxNYXhYAFNldEN1cnNvclBvc1gAR2V0Q3Vyc29yUG9zWABTZXRTY3JvbGxGcm9tUG9zWABJbUd1aVRhYmxlRmxhZ3NfTm9QYWRPdXRlclgASW1HdWlUYWJsZUZsYWdzX1BhZE91dGVyWABJbUd1aVRhYmxlRmxhZ3NfTm9QYWRJbm5lclgAU2Nyb2xsYmFyWABTZXRTY3JvbGxYAEdldFNjcm9sbFgASW1HdWlUYWJsZUZsYWdzX1Njcm9sbFgAU3RyZXRjaCArIFNjcm9sbFgAU2V0U2Nyb2xsSGVyZVgAR2x5cGhNYXhBZHZhbmNlWABHbHlwaE1pbkFkdmFuY2VYAEltR3VpVGFibGVGbGFnc19Ob0hvc3RFeHRlbmRYACNTQ1JPTExYAEZMVF9NQVgAQ29sdW1uICVkIE9yZGVyICVkIFNvcnRPcmRlciAlZCAlcyBWaXMgJWQgJXMgJTcuM2YgVXNlcklEIDB4JTA4WABOYXZGb2N1c1Njb3BlSWQgPSAweCUwOFgAaW8uQ29uZmlnRmxhZ3M6IDB4JTA4WABTYXZlRmxhZ3M6IDB4JTA4WABpby5CYWNrZW5kRmxhZ3M6IDB4JTA4WABOYXZBY3RpdmF0ZUlkOiAweCUwOFgsIE5hdklucHV0SWQ6IDB4JTA4WABIb3ZlcmVkSWQ6IDB4JTA4WAAlcy8lc18lMDhYACBVc2VySUQ9JTA4WAAlcy8lMDhYAENvbHVtbnMgSWQ6IDB4JTA4WCwgQ291bnQ6ICVkLCBGbGFnczogMHglMDRYAENvZGVwb2ludDogVSslMDRYACMlMDJYJTAyWCUwMlglMDJYACMlMDJYJTAyWCUwMlgAQ1RSTCtYAE5hdkxhc3RJZHM6IDB4JTA4WCwweCUwOFgsIE5hdkxheWVyQWN0aXZlTWFzazogJVgAIyNYAE9mZnNldCBYAEZvY3VzIG9uIFgAUmVzaXplTkVTVwBSZXNpemVFVwBDVFJMK1cAIyNXAEltR3VpVGFibGVGbGFnc19Cb3JkZXJzVgBJbUd1aVRhYmxlRmxhZ3NfQm9yZGVyc091dGVyVgBJbUd1aVRhYmxlRmxhZ3NfQm9yZGVyc0lubmVyVgBPdmVyc2FtcGxlVgBQcmltUmVjdFVWAFByaW1RdWFkVVYAQ29sb3JDb252ZXJ0UkdCdG9IU1YAQ1RSTCtWAFRFU1QAaW1ndWlfa2V5ID49IDAgJiYgaW1ndWlfa2V5IDwgSW1HdWlLZXlfQ09VTlQAbW91c2VfY3Vyc29yID4gSW1HdWlNb3VzZUN1cnNvcl9Ob25lICYmIG1vdXNlX2N1cnNvciA8IEltR3VpTW91c2VDdXJzb3JfQ09VTlQAaWR4ID49IDAgJiYgaWR4IDwgSW1HdWlTdHlsZVZhcl9DT1VOVABtb3VzZV9idXR0b24gPj0gMCAmJiBtb3VzZV9idXR0b24gPCBJbUd1aU1vdXNlQnV0dG9uX0NPVU5UAGRhdGFfdHlwZSA+PSAwICYmIGRhdGFfdHlwZSA8IEltR3VpRGF0YVR5cGVfQ09VTlQAbiA8IEJJVENPVU5UAE5BVixGT0NVUwBTVEJfVEVYVEVESVRfSU5TRVJUQ0hBUlMAUmVzaXplTlMASVRFTVMAQ3RybCtTAENUUkwrUwBDaGlsZFIAV2l0aCBIRFIAQ0xFQVIASEVMUABPT09PT09PAEdldElPAEltR3VpSU8AQ3RybCtPAFJFQUNUSU9OAElNR1VJX1ZFUlNJT04ASU1HVUlfQ0hFQ0tWRVJTSU9OAEZMVF9NSU4AaGFzX2ZyZWV6ZV92ID09IGZhbHNlIHx8IHRhYmxlLT5CZzJEcmF3Q2hhbm5lbFVuZnJvemVuICE9IFRBQkxFX0RSQVdfQ0hBTk5FTF9CRzJfRlJPWkVOAE5BTgBNTU1NAENUUkwrTQBDaGlsZEwAJXM6IE5VTEwATExMTExMTABETkRfREVNT19DRUxMAHdpbmRvdy0+REMuQ3VycmVudENvbHVtbnMgPT0gMEwAY3Vycl9jbWQtPlVzZXJDYWxsYmFjayA9PSAwTABnLkxvZ0ZpbGUgPT0gMEwAZy5OYXZXaW5kb3cgIT0gMEwAd2luZG93ID09IDBMIHx8IHdpbmRvdy0+Um9vdFdpbmRvdyAhPSAwTAB3aW5kb3ctPlJvb3RXaW5kb3dGb3JOYXYtPlBhcmVudFdpbmRvdyAhPSAwTAB0ZXh0ICE9IDBMAGNvbHVtbnMgIT0gMEwAY2FsbGJhY2sgIT0gMEwAR0ltR3VpICE9IDBMAHN0YXRlICE9IDBMAHR5cGUgIT0gMEwAdGFibGUgIT0gMEwAQnVmLkRhdGEgIT0gMEwAT0sAS0tLS0tLSwBKSkpKAExlZ2FjeSBDb2x1bW5zIEFQSQBTZXQgdG8gUEkASUlJSUlJSQBJbUd1aVRhYmxlRmxhZ3NfQm9yZGVyc0gASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnMKID0gSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lclYKIHwgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlclYKIHwgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lclYKIHwgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlckgASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lckgAUGl4ZWxTbmFwSABPdmVyc2FtcGxlSABISEhIAFdJTkRPV0lORwBDVVJSRU5UTFkgQVBQRU5ESU5HAEdHR0cASU5GAEZGRkYAX0NPTDRGAF9DT0wzRgAjUkVTSVpFACNNT1ZFAFJlc2l6ZU5XU0UAI0NPTExBUFNFACNDTE9TRQBFRUVFAF9UUkVFTk9ERQBWYWx1ZV9EAExFVkVSQUdFCkJVWlpXT1JEAFRleElEAFNldE5hdklEAEdldElEAFNldEZvY3VzSUQAQ29sdW1uVXNlcklEAFBvcElEAFB1c2hJRABUYWJsZUdldENvbHVtblJlc2l6ZUlEAFBvcFRleHR1cmVJRABQdXNoVGV4dHVyZUlEAF9PbkNoYW5nZWRUZXh0dXJlSUQAZ3JvdXBfZGF0YS5XaW5kb3dJRCA9PSB3aW5kb3ctPklEAHNldHRpbmdzLT5JRCA9PSB3aW5kb3ctPklEAGVkaXRfc3RhdGUtPklEICE9IDAgJiYgZy5BY3RpdmVJZCA9PSBlZGl0X3N0YXRlLT5JRABzZXR0aW5ncy0+SUQgPT0gdGFibGUtPklEAEREREQAVHJlZU5vZGVFeF9DAFZhbHVlX0MAVHJlZU5vZGVfQwBHZXRDb2xvclUzMl9DAENDQ0NDQ0NDQ0NDQwBDVFJMK0MAQ2F0ZWdvcnkgQwBMaXN0Qm94X0IAVHJlZU5vZGVFeF9CAEFkZFRleHRfQgBMaXN0Qm94SGVhZGVyX0IAQ29sbGFwc2luZ0hlYWRlcl9CAFJhZGlvQnV0dG9uX0IATWVudUl0ZW1fQgBUcmVlUHVzaF9CAFZhbHVlX0IASXNSZWN0VmlzaWJsZV9CAFNlbGVjdGFibGVfQgBUcmVlTm9kZV9CAEdldENvbG9yVTMyX0IAQ29sb3JDb252ZXJ0SFNWdG9SR0IARnJhbWVCQgBCQkJCQkJCQgBDYXRlZ29yeSBCAGNhbGxiYWNrX2RhdGEuQnVmU2l6ZSA9PSBzdGF0ZS0+QnVmQ2FwYWNpdHlBAENhbGNXb3JkV3JhcFBvc2l0aW9uQQBDYWxjVGV4dFNpemVBAExpc3RCb3hfQQBUcmVlTm9kZUV4X0EAQWRkVGV4dF9BAExpc3RCb3hIZWFkZXJfQQBDb2xsYXBzaW5nSGVhZGVyX0EAUmFkaW9CdXR0b25fQQBNZW51SXRlbV9BAFRyZWVQdXNoX0EAVmFsdWVfQQBJc1JlY3RWaXNpYmxlX0EAU2VsZWN0YWJsZV9BAFRyZWVOb2RlX0EAR2V0Q29sb3JVMzJfQQBBQUFBAE4vQQBDYXRlZ29yeSBBAFNhdmUgY2hhbmdlIHRvIHRoZSBmb2xsb3dpbmcgaXRlbXM/AFNhdmU/AERlbGV0ZT8AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+ADxVbmtub3duPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBJdGVtIHdpdGggZm9jdXM6IDxub25lPgBOYXZSZWN0UmVsWzBdOiA8Tm9uZT4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgA8cGFzc3dvcmQ+AE1vdXNlIFBvc2l0aW9uOiA8aW52YWxpZD4APE5VTEw+AE1vdXNlIHBvczogPElOVkFMSUQ+ADw8UFJFU1MgU1BBQ0UgVE8gRElTQUJMRT4+ACMjPgA8PAAjIzwAQ29sb3IgYnV0dG9uIG9ubHk6AENvbG9yIHdpZGdldCB3aXRoIEZsb2F0IERpc3BsYXk6AE11bHRpLWxpbmUgdGV4dDoAVmVydDoAQ29sb3Igd2lkZ2V0OgBIb2xkIHRvIHJlcGVhdDoATGlzdHM6AENlbGwgY29udGVudHM6AEhvdmVyIHRvIHNlZSBtb3VzZSBjdXJzb3JzOgBEZWNvcmF0aW9uczoAQ29sdW1uczoATWlzYyBpdGVtczoARHJhZ3M6AE91dHB1dCBmbGFnczoASW5wdXQgZmxhZ3M6AEZlYXR1cmVzOgBUYWJsZXM6AENvbW1hbmRzOgAlczoAQ29sb3IgcGlja2VyOgBDb2xvciBidXR0b24gd2l0aCBQaWNrZXI6AE90aGVyOgBXaXRob3V0IGJvcmRlcjoAV2l0aCBib3JkZXI6AENvbG9yIGJ1dHRvbiB3aXRoIEN1c3RvbSBQaWNrZXIgUG9wdXA6AEtleXMgZG93bjoATmF2SW5wdXRzIGRvd246AE1vdXNlIGRvd246AE5hdklucHV0cyBkdXJhdGlvbjoATW91c2UgZGJsY2xpY2s6AFNpemluZzoAU29ydGluZzoATWFudWFsbHkgd3JhcHBpbmc6AFNjcm9sbGluZzoAUGFkZGluZzoAVXNpbmcgZXhwbGljaXQgc2l6ZToAQ2hhcnMgcXVldWU6AEtleXMgcmVsZWFzZToAVGV4dCBiYXNlbGluZToARWRpdCBuYW1lOgBTZXQgZGVmYXVsdHMgaW4gY29kZToAS2V5cyBwcmVzc2VkOgBOYXZJbnB1dHMgcHJlc3NlZDoATW91c2UgcmVsZWFzZWQ6AFdpdGgga2V5Ym9hcmQgbmF2aWdhdGlvbiBlbmFibGVkOgBNb3VzZSBjbGlja2VkOgBUZXN0IHBhcmFncmFwaCAlZDoAQ29sb3Igd2lkZ2V0IEhTViB3aXRoIEFscGhhOgBVc2luZyBOb0hvc3RFeHRlbmRYIGFuZCBOb0hvc3RFeHRlbmRZOgBDb2xvciB3aWRnZXQgd2l0aCBJbnB1dEhTVjoAQUJPVVQgVEhJUyBERU1POgBVU0VSIEdVSURFOgBQUk9HUkFNTUVSIEdVSURFOgBJc01vdXNlRHJhZ2dpbmcoJWQpOgBHZXRNb3VzZURyYWdEZWx0YSgwKToAJyVzJzoASUQ6IDAxMjM0NTY3ODkAaW5wdXQgdTgAZHJhZyB1OABpbnB1dCBzOABkcmFnIHM4AEdldFRleERhdGFBc0FscGhhOABVOABTOABBZGRJbnB1dENoYXJhY3RlcnNVVEY4AHJvd3MgPj0gMCAmJiByb3dzIDwgMTI4AHNvcnRfb3JkZXJfY291bnQgPCAoaW50KXNpemVvZihzb3J0X29yZGVyX21hc2spICogOAAxMjM0NTYAMTIzLjQ1NgBpbnB1dCB1MTYAZHJhZyB1MTYAaW5wdXQgczE2AGRyYWcgczE2AFUxNgBTMTYAMC4uMjU1AGlucHV0IGludDQAc2xpZGVyIGludDQAZHJhZyBpbnQ0AElucHV0SW50NABTbGlkZXJJbnQ0AERyYWdJbnQ0AElURU06IENvbG9yRWRpdDQAaW5wdXQgZmxvYXQ0AHNsaWRlciBmbG9hdDQAZHJhZyBmbG9hdDQASW5wdXRGbG9hdDQAU2xpZGVyRmxvYXQ0AENvbG9yQ29udmVydFUzMlRvRmxvYXQ0AERyYWdGbG9hdDQAQ29sb3JQaWNrZXI0AEdldFN0eWxlQ29sb3JWZWM0AEltVmVjNABBbHQrRjQAaW5wdXQgdTY0AGRyYWcgdTY0AGlucHV0IHM2NABkcmFnIHM2NABVNjQAUzY0AGNvbHVtbnMgPj0gMCAmJiBjb2x1bW5zIDwgNjQAMTIzNABNeUNvbG9yIyM0AEJ1dHRvbiMjNABpbnB1dCBpbnQzAHNsaWRlciBpbnQzAGRyYWcgaW50MwBJbnB1dEludDMAU2xpZGVySW50MwBEcmFnSW50MwBDb2xvckVkaXQzAHNldDMAaW5wdXQgZmxvYXQzAHNsaWRlciBmbG9hdDMAZHJhZyBmbG9hdDMASVRFTTogSW5wdXRGbG9hdDMAU2xpZGVyRmxvYXQzAERyYWdGbG9hdDMAbXljb2x1bW5zMwBmbGFnczMAQ29sb3JQaWNrZXIzAHRhYmxlMwBNeUNvbG9yIyMzAEJ1dHRvbiMjMwBJdGVtIyMzAEZvY3VzIG9uIDMAaW5wdXQgaW50MgBzbGlkZXIgaW50MgBkcmFnIGludDIAIyNncmFkaWVudDIASW5wdXRJbnQyAFNsaWRlckludDIARHJhZ0ludDIAc3BsaXQyAHNldDIAaW5wdXQgZmxvYXQyAHNsaWRlciBmbG9hdDIAZHJhZyBmbG9hdDIASW5wdXRGbG9hdDIAU2xpZGVyRmxvYXQyAERyYWdGbG9hdDIAdGFibGUyAERyYWdJbnRSYW5nZTIARHJhZ0Zsb2F0UmFuZ2UyAHRhYmxlX25lc3RlZDIASW1WZWMyAHRhYmxlX2NvbnRleHRfbWVudV8yAHRhYmxlX3BhZGRpbmdfMgBpbnB1dCB1MzIAZHJhZyB1MzIAaW5wdXQgczMyAGRyYWcgczMyAENvbG9yQ29udmVydEZsb2F0NFRvVTMyAFMzMgBTYW1lIHRpdGxlIGFzIGFub3RoZXIgd2luZG93IyMyAE15Q29sb3IjIzIAQnV0dG9uIyMyAENvbmZpZ3VyYXRpb24jIzIASXRlbSMjMgBOb2RlIyMyAFRFU1QjIzIASE9QIyMyAGNvbG9yIDIARm9jdXMgb24gMgBTdGFja2VkIDIAcm93X2JnX3R5cGUgPj0gMCAmJiByb3dfYmdfdHlwZSA8PSAyACooY29uc3QgSW1VNjQqKXBfbWF4IDw9IElNX1U2NF9NQVggLyAyACooY29uc3QgSW1TNjQqKXBfbWluID49IElNX1M2NF9NSU4gLyAyICYmICooY29uc3QgSW1TNjQqKXBfbWF4IDw9IElNX1M2NF9NQVggLyAyACooY29uc3QgSW1VMzIqKXBfbWF4IDw9IElNX1UzMl9NQVggLyAyACooY29uc3QgSW1TMzIqKXBfbWluID49IElNX1MzMl9NSU4gLyAyICYmICooY29uc3QgSW1TMzIqKXBfbWF4IDw9IElNX1MzMl9NQVggLyAyACMjZ3JhZGllbnQxAHNwbGl0MQBzZXQxAGZsb2F0MQB0YWJsZTEAdGFibGVfbmVzdGVkMQBZMQBTcGFjZVgxAFYxAFUxAEIxAEExAG9mZnNldCA+PSAtMQBjb2x1bW5fbiA9PSAtMQBwYXlsb2FkLkRhdGFGcmFtZUNvdW50ICE9IC0xAGNvbHVtbl93aXRoX3NtYWxsZXN0X3NvcnRfb3JkZXIgIT0gLTEAdGFibGUtPkN1cnJlbnRDb2x1bW4gIT0gLTEAdGFibGUtPkxlZnRNb3N0U3RyZXRjaGVkQ29sdW1uICE9IC0xICYmIHRhYmxlLT5SaWdodE1vc3RTdHJldGNoZWRDb2x1bW4gIT0gLTEAcmVvcmRlcl9kaXIgPT0gLTEgfHwgcmVvcmRlcl9kaXIgPT0gKzEAZGlyID09IC0xIHx8IGRpciA9PSArMQBTYW1lIHRpdGxlIGFzIGFub3RoZXIgd2luZG93IyMxAE15Q29sb3IjIzEAQnV0dG9uIyMxAEl0ZW0jIzEATm9kZSMjMQBIU1Ygc2hvd24gYXMgSFNWIyMxAFRFU1QjIzEASE9QIyMxAEhTViBzaG93biBhcyBSR0IjIzEAQnVsbGV0IHBvaW50IDEAY29sb3IgMQBjb21ibyAxAEZvY3VzIG9uIDEAQjEgQ2VsbCAxAEExIENlbGwgMQBCMCBDZWxsIDEAQTAgQ2VsbCAxAFN0YWNrZWQgMQBnLkl0ZW1GbGFnc1N0YWNrLlNpemUgPiAxAHdpbmRvdy0+SURTdGFjay5TaXplID4gMQBjb2x1bW5zX2NvdW50ID49IDEAbmF2X2xheWVyID09IDAgfHwgbmF2X2xheWVyID09IDEAZy5OYXZMYXllciA9PSAwIHx8IGcuTmF2TGF5ZXIgPT0gMQBpZHggPD0gMQByb3dfYmdfdGFyZ2V0ID49IDAgJiYgcm93X2JnX3RhcmdldCA8PSAxAGNlbGxfYmdfdHlwZSA+PSAwICYmIGNlbGxfYmdfdHlwZSA8PSAxADAgPCAlLjEwZiA8IDEAZmxvYXQwAFkwAFNwYWNlWDAAVjAAVTAAQjAAQTAARGVmYXVsdCBmb3IgY29sdW1uID4wADgweDgwADEuODAANTB4NTAAeD0xNTAAQ2xhbXAgaW50ZWdlcnMgdG8gMC4uNTAANTAweDUwMABIZWlnaHQgNDAwLTUwMABXaWR0aCA0MDAtNTAwAHg9MzAwADgwMHgyMDAAMjAweDIwMABkcmFnIGludCAwLi4xMDAAQWxpZ24gdG8gcmlnaHQgZWRnZSBtaW51cyAxMDAAV2lkdGggPiAxMDAsIEhlaWdodCA+IDEwMABNOjAwMABNOjAuMDAwADAuMDAuLjEuMDAARGVmYXVsdCBmb3IgY29sdW1uIDAAQjEgQ2VsbCAwAEExIENlbGwgMABCMCBDZWxsIDAAQTAgQ2VsbCAwAGNvbHVtbl9pbmRleCA+IDAAY29sdW1uLT5Tb3J0RGlyZWN0aW9uc0F2YWlsQ291bnQgPiAwAGcuQ3VycmVudFdpbmRvd1N0YWNrLlNpemUgPiAwAGcuQmVnaW5Qb3B1cFN0YWNrLlNpemUgPiAwAGcuR3JvdXBTdGFjay5TaXplID4gMAB0YWJfYmFyLT5MYXN0VGFiSXRlbUlkeCA+PSAwAHRhYmxlLT5SaWdodE1vc3RFbmFibGVkQ29sdW1uID49IDAAYXBwbHlfbmV3X3RleHRfbGVuZ3RoID49IDAAYnVmICE9IDBMICYmIGJ1Zl9zaXplID49IDAAd2luZG93LT5CZWdpbkNvdW50ID09IDAAd2luZG93LT5EcmF3TGlzdC0+Q21kQnVmZmVyLlNpemUgPT0gMSAmJiB3aW5kb3ctPkRyYXdMaXN0LT5DbWRCdWZmZXJbMF0uRWxlbUNvdW50ID09IDAAc3BsaXR0ZXItPl9DdXJyZW50ID09IDAAY29sdW1ucy0+Q3VycmVudCA9PSAwAGlkID09IDAAdGFiX2Jhci0+UmVvcmRlclJlcXVlc3RUYWJJZCA9PSAwAChmbGFncyAmIEltR3VpSG92ZXJlZEZsYWdzX0FsbG93V2hlbk92ZXJsYXBwZWQpID09IDAAKHRhYmxlLT5GbGFncyAmIEltR3VpVGFibGVGbGFnc19TY3JvbGxYKSA9PSAwAChmbGFncyAmIChJbUd1aUhvdmVyZWRGbGFnc19Sb290V2luZG93IHwgSW1HdWlIb3ZlcmVkRmxhZ3NfQ2hpbGRXaW5kb3dzKSkgPT0gMABtb3ZlX2ZsYWdzICE9IDAAc291cmNlX2lkICE9IDAAcGF5bG9hZC5Tb3VyY2VJZCAhPSAwAGNoaWxkX3dpbmRvdy0+Q2hpbGRJZCAhPSAwAChmbGFncyAmIEltR3VpV2luZG93RmxhZ3NfTm9UaXRsZUJhcikgIT0gMAAocG9wdXAuV2luZG93LT5GbGFncyAmIEltR3VpV2luZG93RmxhZ3NfUG9wdXApICE9IDAAUmVhZCB0aGUgRkFRIGF0IGh0dHA6Ly93d3cuZGVhcmltZ3VpLm9yZy9mYXEvAEluc3RydWN0IGJhY2tlbmQgdG8gbm90IGFsdGVyIG1vdXNlIGN1cnNvciBzaGFwZSBhbmQgdmlzaWJpbGl0eS4AU2VjdGlvbnMgYmVsb3cgYXJlIGRlbW9uc3RyYXRpbmcgbWFueSBhc3BlY3RzIG9mIHRoZSBsaWJyYXJ5LgBVc2luZyBUYWJsZU5leHRSb3coKSArIGNhbGxpbmcgVGFibGVOZXh0Q29sdW1uKCkgX2JlZm9yZV8gZWFjaCBjZWxsLCBtYW51YWxseS4AV2hlbiBkcmF3aW5nIGNpcmNsZSBwcmltaXRpdmVzIHdpdGggIm51bV9zZWdtZW50cyA9PSAwIiB0ZXNzZWxhdGlvbiB3aWxsIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS4AV2UgZG9uJ3QgdXNlIHRoZSBkcmFnIGFuZCBkcm9wIGFwaSBhdCBhbGwgaGVyZSEgSW5zdGVhZCB3ZSBxdWVyeSB3aGVuIHRoZSBpdGVtIGlzIGhlbGQgYnV0IG5vdCBob3ZlcmVkLCBhbmQgb3JkZXIgaXRlbXMgYWNjb3JkaW5nbHkuAEJ5IGRlZmF1bHQsIHJpZ2h0LWNsaWNraW5nIG92ZXIgYSBUYWJsZUhlYWRlcnNSb3coKS9UYWJsZUhlYWRlcigpIGxpbmUgd2lsbCBvcGVuIHRoZSBkZWZhdWx0IGNvbnRleHQtbWVudS4KVXNpbmcgSW1HdWlUYWJsZUZsYWdzX0NvbnRleHRNZW51SW5Cb2R5IHdlIGFsc28gYWxsb3cgcmlnaHQtY2xpY2tpbmcgb3ZlciBjb2x1bW5zIGJvZHkuAFlvdSBjYW4gcGFzcyBhICdtaW5fcm93X2hlaWdodCcgdG8gVGFibGVOZXh0Um93KCkuCgpSb3dzIGFyZSBwYWRkZWQgd2l0aCAnc3R5bGUuQ2VsbFBhZGRpbmcueScgb24gdG9wIGFuZCBib3R0b20sIHNvIGVmZmVjdGl2ZWx5IHRoZSBtaW5pbXVtIHJvdyBoZWlnaHQgd2lsbCBhbHdheXMgYmUgPj0gJ3N0eWxlLkNlbGxQYWRkaW5nLnkgKiAyLjBmJy4KCldlIGNhbm5vdCBob25vciBhIF9tYXhpbXVtXyByb3cgaGVpZ2h0IGFzIHRoYXQgd291bGQgcmVxdWlyZXMgYSB1bmlxdWUgY2xpcHBpbmcgcmVjdGFuZ2xlIHBlciByb3cuAFVzZSBjaGlsZCB3aW5kb3dzIHRvIGJlZ2luIGludG8gYSBzZWxmLWNvbnRhaW5lZCBpbmRlcGVuZGVudCBzY3JvbGxpbmcvY2xpcHBpbmcgcmVnaW9ucyB3aXRoaW4gYSBob3N0IHdpbmRvdy4ARG91YmxlLWNsaWNrIG9uIHRpdGxlIGJhciB0byBjb2xsYXBzZSB3aW5kb3cuAEVzY2FwZSB0byBkZWFjdGl2YXRlIGEgd2lkZ2V0LCBjbG9zZSBwb3B1cCwgZXhpdCBjaGlsZCB3aW5kb3cuAENUUkwrVGFiIHRvIHNlbGVjdCBhIHdpbmRvdy4AQWx0IHRvIGp1bXAgdG8gdGhlIG1lbnUgbGF5ZXIgb2YgYSB3aW5kb3cuAE1vdXNlIExlZnQ6IGRyYWcgdG8gYWRkIGxpbmVzLApNb3VzZSBSaWdodDogZHJhZyB0byBzY3JvbGwsIGNsaWNrIGZvciBjb250ZXh0IG1lbnUuAENsaWNrIGFuZCBkcmFnIGNvbHVtbiBoZWFkZXJzIHRvIHJlb3JkZXIgY29sdW1ucy4KClJpZ2h0LWNsaWNrIG9uIGEgaGVhZGVyIHRvIG9wZW4gYSBjb250ZXh0IG1lbnUuAEluIHRoZSBjb2xvciBsaXN0OgpMZWZ0LWNsaWNrIG9uIGNvbG9yIHNxdWFyZSB0byBvcGVuIGNvbG9yIHBpY2tlciwKUmlnaHQtY2xpY2sgdG8gb3BlbiBlZGl0IG9wdGlvbnMgbWVudS4AQ1RSTCtDbGljayBvbiBhIHNsaWRlciBvciBkcmFnIGJveCB0byBpbnB1dCB2YWx1ZSBhcyB0ZXh0LgBQcmludGluZyB1bnVzdWFsbHkgbG9uZyBhbW91bnQgb2YgdGV4dC4AWW91IGNhbiBhbHNvIGNhbGwgSW1HdWk6OkxvZ1RleHQoKSB0byBvdXRwdXQgZGlyZWN0bHkgdG8gdGhlIGxvZyB3aXRob3V0IGEgdmlzdWFsIG91dHB1dC4AVXNpbmcgVGFibGVTZXR1cENvbHVtbigpIHRvIHNldHVwIGV4cGxpY2l0IHdpZHRoLgoKVW5sZXNzIF9Ob0tlZXBDb2x1bW5zVmlzaWJsZSBpcyBzZXQsIGZpeGVkIGNvbHVtbnMgd2l0aCBzZXQgd2lkdGggbWF5IHN0aWxsIGJlIHNocnVuayBkb3duIGlmIHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBpbiB0aGUgaG9zdC4ARVNDQVBFIHRvIHJldmVydC4AQWxpZ25tZW50IGFwcGxpZXMgd2hlbiBhIGJ1dHRvbiBpcyBsYXJnZXIgdGhhbiBpdHMgdGV4dCBjb250ZW50LgBBbGlnbm1lbnQgYXBwbGllcyB3aGVuIGEgc2VsZWN0YWJsZSBpcyBsYXJnZXIgdGhhbiBpdHMgdGV4dCBjb250ZW50LgBXaGVuIGEgcG9wdXAgaXMgYWN0aXZlLCBpdCBpbmhpYml0cyBpbnRlcmFjdGluZyB3aXRoIHdpbmRvd3MgdGhhdCBhcmUgYmVoaW5kIHRoZSBwb3B1cC4gQ2xpY2tpbmcgb3V0c2lkZSB0aGUgcG9wdXAgY2xvc2VzIGl0LgBZb3VyIGFwcGxpY2F0aW9uIGNhbiByZW5kZXIgYSBkaWZmZXJlbnQgbW91c2UgY3Vyc29yIGJhc2VkIG9uIHdoYXQgSW1HdWk6OkdldE1vdXNlQ3Vyc29yKCkgcmV0dXJucy4gSWYgc29mdHdhcmUgY3Vyc29yIHJlbmRlcmluZyAoaW8uTW91c2VEcmF3Q3Vyc29yKSBpcyBzZXQgSW1HdWkgd2lsbCBkcmF3IHRoZSByaWdodCBjdXJzb3IgZm9yIHlvdSwgb3RoZXJ3aXNlIHlvdXIgYmFja2VuZCBuZWVkcyB0byBoYW5kbGUgaXQuAEhlbGxvIGZyb20gU3RhY2tlZCBUaGUgRmlyc3QKVXNpbmcgc3R5bGUuQ29sb3JzW0ltR3VpQ29sX01vZGFsV2luZG93RGltQmddIGJlaGluZCBpdC4AWW91IGNhbiB1c2UgSW1HdWk6OkdldE1vdXNlRHJhZ0RlbHRhKDApIHRvIHF1ZXJ5IGZvciB0aGUgZHJhZ2dlZCBhbW91bnQgb24gYW55IHdpZGdldC4ARGlzYWJsZSBDVFJMK0NsaWNrIG9yIEVudGVyIGtleSBhbGxvd2luZyB0byBpbnB1dCB0ZXh0IGRpcmVjdGx5IGludG8gdGhlIHdpZGdldC4AUmV0dXJuIHRvIGlucHV0IHRleHQgaW50byBhIHdpZGdldC4AU3BhY2UgdG8gYWN0aXZhdGUgYSB3aWRnZXQuAFlvdSBjYW4gYXBwbHkgYXJpdGhtZXRpYyBvcGVyYXRvcnMgKywqLC8gb24gbnVtZXJpY2FsIHZhbHVlcy4KICBlLmcuIFsgMTAwIF0sIGlucHV0ICcqMicsIHJlc3VsdCBiZWNvbWVzIFsgMjAwIF0KVXNlICstIHRvIHN1YnRyYWN0LgBZb3UgY2FuIGFwcGx5IGFyaXRobWV0aWMgb3BlcmF0b3JzICssKiwvIG9uIG51bWVyaWNhbCB2YWx1ZXMuClVzZSArLSB0byBzdWJ0cmFjdC4AVXNlIFNldFNjcm9sbEhlcmVYKCkgb3IgU2V0U2Nyb2xsRnJvbVBvc1goKSB0byBzY3JvbGwgdG8gYSBnaXZlbiBob3Jpem9udGFsIHBvc2l0aW9uLgoKQmVjYXVzZSB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlIG9mIG1vc3Qgd2luZG93IGhpZGVzIGhhbGYgd29ydGggb2YgV2luZG93UGFkZGluZyBvbiB0aGUgbGVmdC9yaWdodCwgdXNpbmcgU2V0U2Nyb2xsRnJvbVBvc1goKzEpIHdpbGwgdXN1YWxseSByZXN1bHQgaW4gY2xpcHBlZCB0ZXh0IHdoZXJlYXMgdGhlIGVxdWl2YWxlbnQgU2V0U2Nyb2xsRnJvbVBvc1koKzEpIHdvdWxkbid0LgBUaGUgQmFja2dyb3VuZCBkcmF3IGxpc3Qgd2lsbCBiZSByZW5kZXJlZCBiZWxvdyBldmVyeSBEZWFyIEltR3VpIHdpbmRvd3MuAFRoZSBGb3JlZ3JvdW5kIGRyYXcgbGlzdCB3aWxsIGJlIHJlbmRlcmVkIG92ZXIgZXZlcnkgRGVhciBJbUd1aSB3aW5kb3dzLgBDVFJMK01vdXNlIFdoZWVsIHRvIHpvb20gd2luZG93IGNvbnRlbnRzLgBVc2luZyBfUmVzaXphYmxlICsgX1NpemluZ0ZpeGVkRml0IGZsYWdzLgpGaXhlZC13aWR0aCBjb2x1bW5zIGdlbmVyYWxseSBtYWtlcyBtb3JlIHNlbnNlIGlmIHlvdSB3YW50IHRvIHVzZSBob3Jpem9udGFsIHNjcm9sbGluZy4KCkRvdWJsZS1jbGljayBhIGNvbHVtbiBib3JkZXIgdG8gYXV0by1maXQgdGhlIGNvbHVtbiB0byBpdHMgY29udGVudHMuAFRoZSAiRXhhbXBsZXMiIG1lbnUgYWJvdmUgbGVhZHMgdG8gbW9yZSBkZW1vIGNvbnRlbnRzLgBUaG9zZSBhcmUgb2xkIHNldHRpbmdzIHByb3ZpZGVkIGZvciBjb252ZW5pZW5jZS4KSG93ZXZlciwgdGhlIF9jb3JyZWN0XyB3YXkgb2Ygc2NhbGluZyB5b3VyIFVJIGlzIGN1cnJlbnRseSB0byByZWxvYWQgeW91ciBmb250IGF0IHRoZSBkZXNpZ25lZCBzaXplLCByZWJ1aWxkIHRoZSBmb250IGF0bGFzLCBhbmQgY2FsbCBzdHlsZS5TY2FsZUFsbFNpemVzKCkgb24gYSByZWZlcmVuY2UgSW1HdWlTdHlsZSBzdHJ1Y3R1cmUuClVzaW5nIHRob3NlIHNldHRpbmdzIGhlcmUgd2lsbCBnaXZlIHlvdSBwb29yIHF1YWxpdHkgcmVzdWx0cy4ASGVyZSB3ZSB0b2dnbGUgdGhlIGNhc2luZyBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9uIGV2ZXJ5IGVkaXRzICsgY291bnQgZWRpdHMuAENvbHVtbnMgZGVmYXVsdCB0byBfV2lkdGhTdHJldGNoIHdpdGggc2FtZSB3ZWlnaHRzLgBDdXJyZW50bHkgYWxsIHRoaXMgZG9lcyBpcyB0byBsaWZ0IHRoZSAwLi4xIGxpbWl0cyBvbiBkcmFnZ2luZyB3aWRnZXRzLgBUaGlzIGlzIHRlc3RpbmcgdGhlIHZlcnRpY2FsIGFsaWdubWVudCB0aGF0IGdldHMgYXBwbGllZCBvbiB0ZXh0IHRvIGtlZXAgaXQgYWxpZ25lZCB3aXRoIHdpZGdldHMuIExpbmVzIG9ubHkgY29tcG9zZWQgb2YgdGV4dCBvciAic21hbGwiIHdpZGdldHMgdXNlIGxlc3MgdmVydGljYWwgc3BhY2UgdGhhbiBsaW5lcyB3aXRoIGZyYW1lZCB3aWRnZXRzLgBCeSBPbWFyIENvcm51dCBhbmQgYWxsIERlYXIgSW1HdWkgY29udHJpYnV0b3JzLgBJbnN0cnVjdCBuYXZpZ2F0aW9uIHRvIG1vdmUgdGhlIG1vdXNlIGN1cnNvci4gU2VlIGNvbW1lbnQgZm9yIEltR3VpQ29uZmlnRmxhZ3NfTmF2RW5hYmxlU2V0TW91c2VQb3MuAFJpZ2h0LWNsaWNrIG9uIHRoZSBpbmRpdmlkdWFsIGNvbG9yIHdpZGdldCB0byBzaG93IG9wdGlvbnMuAEFsc28gc2VlIFN0eWxlLT5SZW5kZXJpbmcgZm9yIHJlbmRlcmluZyBvcHRpb25zLgBEaXNhYmxlIGNsaXBwaW5nIHJlY3RhbmdsZSBmb3IgZXZlcnkgaW5kaXZpZHVhbCBjb2x1bW5zIChyZWR1Y2UgZHJhdyBjb21tYW5kIGNvdW50LCBpdGVtcyB3aWxsIGJlIGFibGUgdG8gb3ZlcmZsb3cgaW50byBvdGhlciBjb2x1bW5zKS4gR2VuZXJhbGx5IGluY29tcGF0aWJsZSB3aXRoIFNjcm9sbEZyZWV6ZSBvcHRpb25zLgBUaGlzIHNlY3Rpb24gYWxsb3dzIHlvdSB0byBpbnRlcmFjdCBhbmQgc2VlIHRoZSBlZmZlY3Qgb2YgdmFyaW91cyBzaXppbmcgcG9saWNpZXMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgU2Nyb2xsIGlzIGVuYWJsZWQgYW5kIHRoZSBjb250ZW50cyBvZiB5b3VyIGNvbHVtbnMuAEhlcmUgd2UgYWN0aXZhdGUgU2Nyb2xsWSwgd2hpY2ggd2lsbCBjcmVhdGUgYSBjaGlsZCB3aW5kb3cgY29udGFpbmVyIHRvIGFsbG93IGhvc3Rpbmcgc2Nyb2xsYWJsZSBjb250ZW50cy4KCldlIGFsc28gZGVtb25zdHJhdGUgdXNpbmcgSW1HdWlMaXN0Q2xpcHBlciB0byB2aXJ0dWFsaXplIHRoZSBzdWJtaXNzaW9uIG9mIG1hbnkgaXRlbXMuAEhvbGQgQ1RSTCBhbmQgY2xpY2sgdG8gc2VsZWN0IG11bHRpcGxlIGl0ZW1zLgBTZXQgJ2lvLkNvbmZpZ0ZsYWdzIHw9IE5hdkVuYWJsZUtleWJvYXJkJyBmb3Iga2V5Ym9hcmQgY29udHJvbHMuAEVuYWJsZSBrZXlib2FyZCBjb250cm9scy4AU2V0ICdpby5Db25maWdGbGFncyB8PSBOYXZFbmFibGVHYW1lcGFkJyBmb3IgZ2FtZXBhZCBjb250cm9scy4ARW5hYmxlIGdhbWVwYWQgY29udHJvbHMuIFJlcXVpcmUgYmFja2VuZCB0byBzZXQgaW8uQmFja2VuZEZsYWdzIHw9IEltR3VpQmFja2VuZEZsYWdzX0hhc0dhbWVwYWQuCgpSZWFkIGluc3RydWN0aW9ucyBpbiBpbWd1aS5jcHAgZm9yIGRldGFpbHMuAENKSyB0ZXh0IHdpbGwgb25seSBhcHBlYXJzIGlmIHRoZSBmb250IHdhcyBsb2FkZWQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgQ0pLIGNoYXJhY3RlciByYW5nZXMuIENhbGwgaW8uRm9udC0+QWRkRm9udEZyb21GaWxlVFRGKCkgbWFudWFsbHkgdG8gbG9hZCBleHRyYSBjaGFyYWN0ZXIgcmFuZ2VzLiBSZWFkIGRvY3MvRk9OVFMubWQgZm9yIGRldGFpbHMuAFVzaW5nIHRoZSBfUmVzaXphYmxlIGZsYWcgYXV0b21hdGljYWxseSBlbmFibGVzIHRoZSBfQm9yZGVyc0lubmVyViBmbGFnIGFzIHdlbGwsIHRoaXMgaXMgd2h5IHRoZSByZXNpemUgYm9yZGVycyBhcmUgc3RpbGwgc2hvd2luZyB3aGVuIHVuY2hlY2tpbmcgdGhpcy4AQ29sdW1ucyBkZWZhdWx0IHRvIF9XaWR0aFN0cmV0Y2ggd2l0aCB3ZWlnaHRzIHByb3BvcnRpb25hbCB0byB0aGVpciB3aWR0aHMuAFlvdSBjYW4gZHJhZyBmcm9tIHRoZSBjb2xvciBzcXVhcmVzLgBQcmVzc2VkICVkIHRpbWVzLgBUZXN0IG9mIGRpZmZlcmVudCB3aWRnZXRzIHJlYWN0IGFuZCBpbXBhY3QgdGhlIHdvcmsgcmVjdGFuZ2xlIGdyb3dpbmcgd2hlbiBob3Jpem9udGFsIHNjcm9sbGluZyBpcyBlbmFibGVkLgoKVXNlICdNZXRyaWNzLT5Ub29scy0+U2hvdyB3aW5kb3dzIHJlY3RhbmdsZXMnIHRvIHZpc3VhbGl6ZSByZWN0YW5nbGVzLgBUaGlzIHRleHQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgd3JhcCBvbiB0aGUgZWRnZSBvZiB0aGUgd2luZG93LiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBmb3IgdGV4dCB3cmFwcGluZyBmb2xsb3dzIHNpbXBsZSBydWxlcyBzdWl0YWJsZSBmb3IgRW5nbGlzaCBhbmQgcG9zc2libHkgb3RoZXIgbGFuZ3VhZ2VzLgBVc2UgVEFCL1NISUZUK1RBQiB0byBjeWNsZSB0aHJvdWdoIGtleWJvYXJkIGVkaXRhYmxlIGZpZWxkcy4AVXNpbmcgdGhlIGZvcm1hdCBzdHJpbmcgcGFyYW1ldGVyIHRvIGRpc3BsYXkgYSBuYW1lIGluc3RlYWQgb2YgdGhlIHVuZGVybHlpbmcgaW50ZWdlci4AU2VlIGV4YW1wbGUgYXBwbGljYXRpb25zIGluIHRoZSBleGFtcGxlcy8gZm9sZGVyLgBXaXRoIHRoZSBJbUd1aUNvbG9yRWRpdEZsYWdzX05vSW5wdXRzIGZsYWcgeW91IGNhbiBoaWRlIGFsbCB0aGUgc2xpZGVyL3RleHQgaW5wdXRzLgpXaXRoIHRoZSBJbUd1aUNvbG9yRWRpdEZsYWdzX05vTGFiZWwgZmxhZyB5b3UgY2FuIHBhc3MgYSBub24tZW1wdHkgbGFiZWwgd2hpY2ggd2lsbCBvbmx5IGJlIHVzZWQgZm9yIHRoZSB0b29sdGlwIGFuZCBwaWNrZXIgcG9wdXAuAEJlZ2luR3JvdXAoKSBiYXNpY2FsbHkgbG9ja3MgdGhlIGhvcml6b250YWwgcG9zaXRpb24gZm9yIG5ldyBsaW5lLiBFbmRHcm91cCgpIGJ1bmRsZXMgdGhlIHdob2xlIGdyb3VwIHNvIHRoYXQgeW91IGNhbiB1c2UgIml0ZW0iIGZ1bmN0aW9ucyBzdWNoIGFzIElzSXRlbUhvdmVyZWQoKS9Jc0l0ZW1BY3RpdmUoKSBvciBTYW1lTGluZSgpIGV0Yy4gb24gdGhlIHdob2xlIGdyb3VwLgBTZWUgY29tbWVudHMgaW4gaW1ndWkuY3BwLgBXaW5kb3cgd2lsbCByZXNpemUgZXZlcnktZnJhbWUgdG8gdGhlIHNpemUgb2YgaXRzIGNvbnRlbnQuCk5vdGUgdGhhdCB5b3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byBxdWVyeSB0aGUgd2luZG93IHNpemUgdG8Kb3V0cHV0IHlvdXIgY29udGVudCBiZWNhdXNlIHRoYXQgd291bGQgY3JlYXRlIGEgZmVlZGJhY2sgbG9vcC4AVXNpbmcgVGFibGVOZXh0Um93KCkgKyBjYWxsaW5nIFRhYmxlU2V0Q29sdW1uSW5kZXgoKSBfYmVmb3JlXyBlYWNoIGNlbGwsIGluIGEgbG9vcC4AQ1RSTCtMZWZ0L1JpZ2h0IHRvIHdvcmQganVtcC4ARW50ZXIgJ0hFTFAnIGZvciBoZWxwLgBCeSBkZWZhdWx0LCBjb2xvcnMgYXJlIGdpdmVuIHRvIENvbG9yRWRpdCBhbmQgQ29sb3JQaWNrZXIgaW4gUkdCLCBidXQgSW1HdWlDb2xvckVkaXRGbGFnc19JbnB1dEhTVmFsbG93cyB5b3UgdG8gc3RvcmUgY29sb3JzIGFzIEhTViBhbmQgcGFzcyB0aGVtIHRvIENvbG9yRWRpdCBhbmQgQ29sb3JQaWNrZXIgYXMgSFNWLiBUaGlzIGNvbWVzIHdpdGggdGhlYWRkZWQgYmVuZWZpdCB0aGF0IHlvdSBjYW4gbWFuaXB1bGF0ZSBodWUgdmFsdWVzIHdpdGggdGhlIHBpY2tlciBldmVuIHdoZW4gc2F0dXJhdGlvbiBvciB2YWx1ZSBhcmUgemVyby4AQ1RSTCtaLENUUkwrWSB0byB1bmRvL3JlZG8uAFRoZSBsb2dnaW5nIEFQSSByZWRpcmVjdHMgYWxsIHRleHQgb3V0cHV0IHNvIHlvdSBjYW4gZWFzaWx5IGNhcHR1cmUgdGhlIGNvbnRlbnQgb2YgYSB3aW5kb3cgb3IgYSBibG9jay4gVHJlZSBub2RlcyBjYW4gYmUgYXV0b21hdGljYWxseSBleHBhbmRlZC4KVHJ5IG9wZW5pbmcgYW55IG9mIHRoZSBjb250ZW50cyBiZWxvdyBpbiB0aGlzIHdpbmRvdyBhbmQgdGhlbiBjbGljayBvbmUgb2YgdGhlICJMb2cgVG8iIGJ1dHRvbi4AVXNlIFNldFNjcm9sbEhlcmVZKCkgb3IgU2V0U2Nyb2xsRnJvbVBvc1koKSB0byBzY3JvbGwgdG8gYSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbi4AT25seSB1c2luZyBUYWJsZU5leHRDb2x1bW4oKSwgd2hpY2ggdGVuZHMgdG8gYmUgY29udmVuaWVudCBmb3IgdGFibGVzIHdoZXJlIGV2ZXJ5IGNlbGxzIGNvbnRhaW5zIHRoZSBzYW1lIHR5cGUgb2YgY29udGVudHMuClRoaXMgaXMgYWxzbyBtb3JlIHNpbWlsYXIgdG8gdGhlIG9sZCBOZXh0Q29sdW1uKCkgZnVuY3Rpb24gb2YgdGhlIENvbHVtbnMgQVBJLCBhbmQgcHJvdmlkZWQgdG8gZmFjaWxpdGF0ZSB0aGUgQ29sdW1ucy0+VGFibGVzIEFQSSB0cmFuc2l0aW9uLgBUaGUgc2FtZSBjb250ZW50cyBjYW4gYmUgYWNjZXNzZWQgaW4gJ1Rvb2xzLT5TdHlsZSBFZGl0b3InIG9yIGJ5IGNhbGxpbmcgdGhlIFNob3dTdHlsZUVkaXRvcigpIGZ1bmN0aW9uLgBEZWFyIEltR3VpIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSwgc2VlIExJQ0VOU0UgZm9yIG1vcmUgaW5mb3JtYXRpb24uAFRoaXMgaXMgYSBjdXN0b20gcG9wdXAgZm9yIHVudXNlZCBzcGFjZSBhZnRlciB0aGUgbGFzdCBjb2x1bW4uAFRoaXMgaXMgYSBtb3JlIHR5cGljYWwgbG9va2luZyB0cmVlIHdpdGggc2VsZWN0YWJsZSBub2Rlcy4KQ2xpY2sgdG8gc2VsZWN0LCBDVFJMK0NsaWNrIHRvIHRvZ2dsZSwgY2xpY2sgb24gYXJyb3dzIG9yIGRvdWJsZS1jbGljayB0byBvcGVuLgBTcGVjaWZ5IGhlaWdodCBvZiB0aGUgU2VsZWN0YWJsZSBpdGVtLgBUYXJnZXQgUm93QmcwIHRvIG92ZXJyaWRlIHRoZSBhbHRlcm5hdGluZyBvZGQvZXZlbiBjb2xvcnMsClRhcmdldCBSb3dCZzEgdG8gYmxlbmQgd2l0aCB0aGVtLgBXaGVuIGRpc2FibGluZyBhbnRpLWFsaWFzaW5nIGxpbmVzLCB5b3UnbGwgcHJvYmFibHkgd2FudCB0byBkaXNhYmxlIGJvcmRlcnMgaW4geW91ciBzdHlsZSBhcyB3ZWxsLgBUaGlzIGRlbW9uc3RyYXRlIGVtYmVkZGluZyBhIHRhYmxlIGludG8gYW5vdGhlciB0YWJsZSBjZWxsLgBDVFJMK0Egb3IgZG91YmxlLWNsaWNrIHRvIHNlbGVjdCBhbGwuAEluIHRoZSBBZHZhbmNlZCBkZW1vIHdlIG92ZXJyaWRlIHRoZSBwb2xpY3kgb2YgZWFjaCBjb2x1bW4gc28gdGhvc2UgdGFibGUtd2lkZSBzZXR0aW5ncyBoYXZlIGxlc3MgZWZmZWN0IHRoYXQgdHlwaWNhbC4AY2FuIGZpdCB3aXRoaW4gYSB0ZXh0IGJsb2NrLgBBbHdheXMgY2xhbXAgdmFsdWUgdG8gbWluL21heCBib3VuZHMgKGlmIGFueSkgd2hlbiBpbnB1dCBtYW51YWxseSB3aXRoIENUUkwrQ2xpY2suAEhlcmUgd2UgYXBwZW5kICIuLiIgZWFjaCB0aW1lIFRhYiBpcyBwcmVzc2VkLiBTZWUgJ0V4YW1wbGVzPkNvbnNvbGUnIGZvciBhIG1vcmUgbWVhbmluZ2Z1bCBkZW1vbnN0cmF0aW9uIG9mIHVzaW5nIHRoaXMgY2FsbGJhY2suAEhlcmUgd2UgcmVwbGFjZSBhbmQgc2VsZWN0IHRleHQgZWFjaCB0aW1lIFVwL0Rvd24gYXJlIHByZXNzZWQuIFNlZSAnRXhhbXBsZXM+Q29uc29sZScgZm9yIGEgbW9yZSBtZWFuaW5nZnVsIGRlbW9uc3RyYXRpb24gb2YgdXNpbmcgdGhpcyBjYWxsYmFjay4ARW5hYmxlIHJlc2l6aW5nIG9mIHdpbmRvd3MgZnJvbSB0aGVpciBlZGdlcyBhbmQgZnJvbSB0aGUgbG93ZXItbGVmdCBjb3JuZXIuClRoaXMgcmVxdWlyZXMgKGlvLkJhY2tlbmRGbGFncyAmIEltR3VpQmFja2VuZEZsYWdzX0hhc01vdXNlQ3Vyc29ycykgYmVjYXVzZSBpdCBuZWVkcyBtb3VzZSBjdXJzb3IgZmVlZGJhY2suAERpc2FibGUgZGlzdHJpYnV0aW5nIHJlbWFpbmRlciB3aWR0aCB0byBzdHJldGNoZWQgY29sdW1ucyAod2lkdGggYWxsb2NhdGlvbiBvbiBhIDEwMC13aWRlIHRhYmxlIHdpdGggMyBjb2x1bW5zOiBXaXRob3V0IHRoaXMgZmxhZzogMzMsMzMsMzQuIFdpdGggdGhpcyBmbGFnOiAzMywzMywzMykuIFdpdGggbGFyZ2VyIG51bWJlciBvZiBjb2x1bW5zLCByZXNpemluZyB3aWxsIGFwcGVhciB0byBiZSBsZXNzIHNtb290aC4ARGlzYWJsZSB0aGUgaW5kZW50aW5nIG9mIHRyZWUgbm9kZXMgc28gZGVtbyB0YWJsZXMgY2FuIHVzZSB0aGUgZnVsbCB3aW5kb3cgd2lkdGguAFVzaW5nIFRhYmxlU2V0dXBDb2x1bW4oKSB0byBzZXR1cCBkZWZhdWx0IHdpZHRoLgBCZSBtaW5kZnVsIHRoYXQgdXNpbmcgcmlnaHQtYWxpZ25tZW50IChlLmcuIHNpemUueCA9IC1GTFRfTUlOKSBjcmVhdGVzIGEgZmVlZGJhY2sgbG9vcCB3aGVyZSBjb250ZW50cyB3aWR0aCBjYW4gZmVlZCBpbnRvIGF1dG8tY29sdW1uIHdpZHRoIGNhbiBmZWVkIGludG8gY29udGVudHMgd2lkdGguAENvbHVtbnMgZGVmYXVsdCB0byBfV2lkdGhGaXhlZCAoaWYgcmVzaXphYmxlKSBvciBfV2lkdGhBdXRvIChpZiBub3QgcmVzaXphYmxlKSwgbWF0Y2hpbmcgY29udGVudHMgd2lkdGguAEZpeGVkIHdpZHRoLgBXaWxsIGNhbGwgdGhlIElNX0RFQlVHX0JSRUFLKCkgbWFjcm8gdG8gYnJlYWsgaW4gZGVidWdnZXIuCldhcm5pbmc6IElmIHlvdSBkb24ndCBoYXZlIGEgZGVidWdnZXIgYXR0YWNoZWQsIHRoaXMgd2lsbCBwcm9iYWJseSBjcmFzaC4AVXNpbmcgVGFibGVTZXR1cENvbHVtbigpIHRvIGFsdGVyIHJlc2l6aW5nIHBvbGljeSBvbiBhIHBlci1jb2x1bW4gYmFzaXMuCgpXaGVuIGNvbWJpbmluZyBGaXhlZCBhbmQgU3RyZXRjaCBjb2x1bW5zLCBnZW5lcmFsbHkgeW91IG9ubHkgd2FudCBvbmUsIG1heWJlIHR3byB0cmFpbGluZyBjb2x1bW5zIHRvIHVzZSBfV2lkdGhTdHJldGNoLgBUaGUgbGF6eSBkb2cgaXMgYSBnb29kIGRvZy4gVGhpcyBwYXJhZ3JhcGggc2hvdWxkIGZpdCB3aXRoaW4gJS4wZiBwaXhlbHMuIFRlc3RpbmcgYSAxIGNoYXJhY3RlciB3b3JkLiBUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLgBVc2luZyBJbUd1aUlucHV0VGV4dEZsYWdzX0NhbGxiYWNrUmVzaXplIHRvIHdpcmUgeW91ciBjdXN0b20gc3RyaW5nIHR5cGUgdG8gSW5wdXRUZXh0KCkuCgpTZWUgbWlzYy9jcHAvaW1ndWlfc3RkbGliLmggZm9yIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZm9yIHN0ZDo6c3RyaW5nLgBQcmVzcyBFU0MgdG8gYWJvcnQgcGlja2luZy4AV2Ugb2Z0ZW4gd2FudCBvdXRlciBwYWRkaW5nIGFjdGl2YXRlZCB3aGVuIGFueSB1c2luZyBmZWF0dXJlcyB3aGljaCBtYWtlcyB0aGUgZWRnZXMgb2YgYSBjb2x1bW4gdmlzaWJsZToKZS5nLjoKLSBCb3JkZXJPdXRlclYKLSBhbnkgZm9ybSBvZiByb3cgc2VsZWN0aW9uCkJlY2F1c2Ugb2YgdGhpcywgYWN0aXZhdGluZyBCb3JkZXJPdXRlclYgc2V0cyB0aGUgZGVmYXVsdCB0byBQYWRPdXRlclguIFVzaW5nIFBhZE91dGVyWCBvciBOb1BhZE91dGVyWCB5b3UgY2FuIG92ZXJyaWRlIHRoZSBkZWZhdWx0LgoKQWN0dWFsIHBhZGRpbmcgdmFsdWVzIGFyZSB1c2luZyBzdHlsZS5DZWxsUGFkZGluZy4KCkluIHRoaXMgZGVtbyB3ZSBkb24ndCBzaG93IGhvcml6b250YWwgYm9yZGVycyB0byBlbXBoYXNpcyBob3cgdGhleSBkb24ndCBhZmZlY3QgZGVmYXVsdCBob3Jpem9udGFsIHBhZGRpbmcuAFJlYWQgRkFRIGFuZCBkb2NzL0ZPTlRTLm1kIGZvciBkZXRhaWxzIG9uIGZvbnQgbG9hZGluZy4AVGhpcyBpcyBhbm90aGVyIGNoaWxkIHdpbmRvdyBmb3IgdGVzdGluZyB0aGUgX0NoaWxkV2luZG93cyBmbGFnLgBUaGlzIGlzIHdpbmRvdyAxLgpNeSB0aXRsZSBpcyB0aGUgc2FtZSBhcyB3aW5kb3cgMiwgYnV0IG15IGlkZW50aWZpZXIgaXMgdW5pcXVlLgBUaGlzIGlzIHdpbmRvdyAyLgpNeSB0aXRsZSBpcyB0aGUgc2FtZSBhcyB3aW5kb3cgMSwgYnV0IG15IGlkZW50aWZpZXIgaXMgdW5pcXVlLgBDbGljayBhbmQgZHJhZyB0byBlZGl0IHZhbHVlLgpIb2xkIFNISUZUL0FMVCBmb3IgZmFzdGVyL3Nsb3dlciBlZGl0LgpEb3VibGUtY2xpY2sgb3IgQ1RSTCtjbGljayB0byBpbnB1dCB2YWx1ZS4AU2V0dGluZyBzdHlsZS5DZWxsUGFkZGluZyB0byAoMCwwKSBvciBhIGN1c3RvbSB2YWx1ZS4AQXMgd2l0aCBldmVyeSB3aWRnZXRzIGluIGRlYXIgaW1ndWksIHdlIG5ldmVyIG1vZGlmeSB2YWx1ZXMgdW5sZXNzIHRoZXJlIGlzIGEgdXNlciBpbnRlcmFjdGlvbi4KWW91IGNhbiBvdmVycmlkZSB0aGUgY2xhbXBpbmcgbGltaXRzIGJ5IHVzaW5nIENUUkwrQ2xpY2sgdG8gaW5wdXQgYSB2YWx1ZS4AQ1RSTCtYL0MvViB0byB1c2UgY2xpcGJvYXJkIGN1dC9jb3B5L3Bhc3RlLgBBcnJvdyBrZXlzIHRvIG5hdmlnYXRlLgBTaG93Y2FzZSB1c2luZyBQdXNoSXRlbVdpZHRoKCkgYW5kIGhvdyBpdCBpcyBwcmVzZXJ2ZWQgb24gYSBwZXItY29sdW1uIGJhc2lzLgoKTm90ZSB0aGF0IG9uIGF1dG8tcmVzaXppbmcgbm9uLXJlc2l6YWJsZSBmaXhlZCBjb2x1bW5zLCBxdWVyeWluZyB0aGUgY29udGVudCB3aWR0aCBmb3IgZS5nLiByaWdodC1hbGlnbm1lbnQgZG9lc24ndCBtYWtlIHNlbnNlLgBTaG93Y2FzZSB1c2luZyBTdHJldGNoIGNvbHVtbnMgKyBTY3JvbGxYIHRvZ2V0aGVyOiB0aGlzIGlzIHJhdGhlciB1bnVzdWFsIGFuZCBvbmx5IG1ha2VzIHNlbnNlIHdoZW4gc3BlY2lmeWluZyBhbiAnaW5uZXJfd2lkdGgnIGZvciB0aGUgdGFibGUhCldpdGhvdXQgYW4gZXhwbGljaXQgdmFsdWUsIGlubmVyX3dpZHRoIGlzID09IG91dGVyX3NpemUueCBhbmQgdGhlcmVmb3JlIHVzaW5nIFN0cmV0Y2ggY29sdW1ucyArIFNjcm9sbFggdG9nZXRoZXIgZG9lc24ndCBtYWtlIHNlbnNlLgBVc2UgZGVmYXVsdCBzaXppbmcgcG9saWN5OgotIEltR3VpVGFibGVGbGFnc19TaXppbmdGaXhlZEZpdCBpZiBTY3JvbGxYIGlzIG9uIG9yIGlmIGhvc3Qgd2luZG93IGhhcyBJbUd1aVdpbmRvd0ZsYWdzX0Fsd2F5c0F1dG9SZXNpemUuCi0gSW1HdWlUYWJsZUZsYWdzX1NpemluZ1N0cmV0Y2hTYW1lIG90aGVyd2lzZS4AU2F2ZS9SZXZlcnQgaW4gbG9jYWwgbm9uLXBlcnNpc3RlbnQgc3RvcmFnZS4gRGVmYXVsdCBDb2xvcnMgZGVmaW5pdGlvbiBhcmUgbm90IGFmZmVjdGVkLiBVc2UgIkV4cG9ydCIgYmVsb3cgdG8gc2F2ZSB0aGVtIHNvbWV3aGVyZS4ASSBhbSB0aGUgbGFzdCBvbmUgaGVyZS4AQW4gZXh0cmEgbGluZSBoZXJlLgBXZSBhcmUgY29sb3JpemluZyBjZWxscyB0byBCMS0+QzIgaGVyZS4AVGhlIFRleHREaXNhYmxlZCBjb2xvciBpcyBzdG9yZWQgaW4gSW1HdWlTdHlsZS4ASW1HdWlUYWJsZUZsYWdzX1Jvd0JnIGF1dG9tYXRpY2FsbHkgc2V0cyBSb3dCZzAgdG8gYWx0ZXJuYXRpdmUgY29sb3JzIHB1bGxlZCBmcm9tIHRoZSBTdHlsZS4AVGhpcyB3aW5kb3cgaGFzIGEgY2hhbmdpbmcgdGl0bGUuACUqc0hlbGxvLCBzYWlsb3IhIE1ha2luZyB0aGlzIGxpbmUgbG9uZyBlbm91Z2ggZm9yIHRoZSBleGFtcGxlLgBUaGlzIHRleHQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgd3JhcCBvbiB0aGUgZWRnZSBvZiB0aGUgd29yayByZWN0YW5nbGUuAFNldENvbG9yRWRpdE9wdGlvbnMoKSBpcyBkZXNpZ25lZCB0byBhbGxvdyB5b3UgdG8gc2V0IGJvb3QtdGltZSBkZWZhdWx0LgpXZSBkb24ndCBoYXZlIFB1c2gvUG9wIGZ1bmN0aW9ucyBiZWNhdXNlIHlvdSBjYW4gZm9yY2Ugb3B0aW9ucyBvbiBhIHBlci13aWRnZXQgYmFzaXMgaWYgbmVlZGVkLGFuZCB0aGUgdXNlciBjYW4gY2hhbmdlIG5vbi1mb3JjZWQgb25lcyB3aXRoIHRoZSBvcHRpb25zIG1lbnUuCldlIGRvbid0IGhhdmUgYSBnZXR0ZXIgdG8gYXZvaWRlbmNvdXJhZ2luZyB5b3UgdG8gcGVyc2lzdGVudGx5IHNhdmUgdmFsdWVzIHRoYXQgYXJlbid0IGZvcndhcmQtY29tcGF0aWJsZS4ATWFrZSBvdXRlciBoZWlnaHQgc3RvcCBleGFjdGx5IGF0IG91dGVyX3NpemUueSAocHJldmVudCBhdXRvLWV4dGVuZGluZyB0YWJsZSBwYXN0IHRoZSBsaW1pdCkuCgpPbmx5IGF2YWlsYWJsZSB3aGVuIFNjcm9sbFgvU2Nyb2xsWSBhcmUgZGlzYWJsZWQuIERhdGEgYmVsb3cgdGhlIGxpbWl0IHdpbGwgYmUgY2xpcHBlZCBhbmQgbm90IHZpc2libGUuAENvbHVtbnMgYXJlIGFsbCB0aGUgc2FtZSB3aWR0aCwgbWF0Y2hpbmcgdGhlIG1heGltdW0gY29udGVudHMgd2lkdGguCkltcGxpY2l0bHkgZGlzYWJsZSBJbUd1aVRhYmxlRmxhZ3NfUmVzaXphYmxlIGFuZCBlbmFibGUgSW1HdWlUYWJsZUZsYWdzX05vS2VlcENvbHVtbnNWaXNpYmxlLgBFeHRlbmQgaGl0IGFyZWEgdG8gYWxsIGF2YWlsYWJsZSB3aWR0aCBpbnN0ZWFkIG9mIGFsbG93aW5nIG1vcmUgaXRlbXMgdG8gYmUgbGFpZCBvdXQgYWZ0ZXIgdGhlIG5vZGUuAFVzZXIgY2FuIHJpZ2h0LWNsaWNrIHRoZSBwaWNrZXIgdG8gY2hhbmdlIG1vZGUuAE5COiBDdXJzb3IgJiBzZWxlY3Rpb24gYXJlIHByZXNlcnZlZCB3aGVuIHJlZm9jdXNpbmcgbGFzdCB1c2VkIGl0ZW0gaW4gY29kZS4ATW9kYWwgd2luZG93cyBhcmUgbGlrZSBwb3B1cHMgYnV0IHRoZSB1c2VyIGNhbm5vdCBjbG9zZSB0aGVtIGJ5IGNsaWNraW5nIG91dHNpZGUuAFRob3NlIGZsYWdzIGFyZSBzZXQgYnkgdGhlIGJhY2tlbmRzIChpbWd1aV9pbXBsX3h4eCBmaWxlcykgdG8gc3BlY2lmeSB0aGVpciBjYXBhYmlsaXRpZXMuCkhlcmUgd2UgZXhwb3NlIHRoZW4gYXMgcmVhZC1vbmx5IGZpZWxkcyB0byBhdm9pZCBicmVha2luZyBpbnRlcmFjdGlvbnMgd2l0aCB5b3VyIGJhY2tlbmQuAE1ha2Ugb3V0ZXIgd2lkdGggYXV0by1maXQgdG8gY29sdW1ucywgb3ZlcnJpZGluZyBvdXRlcl9zaXplLnggdmFsdWUuCgpPbmx5IGF2YWlsYWJsZSB3aGVuIFNjcm9sbFgvU2Nyb2xsWSBhcmUgZGlzYWJsZWQgYW5kIFN0cmV0Y2ggY29sdW1ucyBhcmUgbm90IHVzZWQuAE9ubHkgYXZhaWxhYmxlIGlmIFNjcm9sbFggaXMgZGlzYWJsZWQuAE5vdGU6IHNvbWUgbWVtb3J5IGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbXBhY3RlZC9mcmVlZC4ATXVsdGlwbGUgdGFibGVzIHdpdGggdGhlIHNhbWUgaWRlbnRpZmllciB3aWxsIHNoYXJlIHRoZWlyIHNldHRpbmdzLCB3aWR0aCwgdmlzaWJpbGl0eSwgb3JkZXIgZXRjLgBUaGlzIGV4YW1wbGUgaW1wbGVtZW50cyBhIGNvbnNvbGUgd2l0aCBiYXNpYyBjb2xvcmluZywgY29tcGxldGlvbiAoVEFCIGtleSkgYW5kIGhpc3RvcnkgKFVwL0Rvd24ga2V5cykuIEEgbW9yZSBlbGFib3JhdGUgaW1wbGVtZW50YXRpb24gbWF5IHdhbnQgdG8gc3RvcmUgZW50cmllcyBhbG9uZyB3aXRoIGV4dHJhIGRhdGEgc3VjaCBhcyB0aW1lc3RhbXAsIGVtaXR0ZXIsIGV0Yy4ASSBhbSBhbiBvZGQgdGFiLgBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4AVGhpcyBleGFtcGxlIHNob3dzIGhvdyB5b3UgbWF5IGltcGxlbWVudCBhIHByb3BlcnR5IGVkaXRvciB1c2luZyB0d28gY29sdW1ucy4KQWxsIG9iamVjdHMvZmllbGRzIGRhdGEgYXJlIGR1bW1pZXMgaGVyZS4KUmVtZW1iZXIgdGhhdCBpbiBtYW55IHNpbXBsZSBjYXNlcywgeW91IGNhbiB1c2UgSW1HdWk6OlNhbWVMaW5lKHh4eCkgdG8gcG9zaXRpb24KeW91ciBjdXJzb3IgaG9yaXpvbnRhbGx5IGluc3RlYWQgb2YgdXNpbmcgdGhlIENvbHVtbnMoKSBBUEkuAEZpbGUgTWVudS4uAEJhc2VsaW5lIG9mIGJ1dHRvbiB3aWxsIGxvb2sgbWlzYWxpZ25lZCB3aXRoIHRleHQuLgBTZWxlY3QuLgBBbmQgbm93IHNvbWUgdGV4dHVyZWQgYnV0dG9ucy4uAFN0YWNrZWQgbW9kYWxzLi4AU29tZSAlcyB0ZXh0ICVkLCVkCk92ZXIgdHdvIGxpbmVzLi4AQ29weSBhcy4uAFNhdmUgQXMuLgBDb2x1bW4gJWQgb3JkZXIgJWQgJyVzJzogb2Zmc2V0ICUrLjJmIHRvICUrLjJmJXMKRW5hYmxlZDogJWQsIFZpc2libGVYL1k6ICVkLyVkLCBSZXF1ZXN0T3V0cHV0OiAlZCwgU2tpcEl0ZW1zOiAlZCwgRHJhd0NoYW5uZWxzOiAlZCwlZApXaWR0aEdpdmVuOiAlLjFmLCBSZXF1ZXN0L0F1dG86ICUuMWYvJS4xZiwgU3RyZXRjaFdlaWdodDogJS4zZiAoJS4xZiUlKQpNaW5YOiAlLjFmLCBNYXhYOiAlLjFmICglKy4xZiksIENsaXBSZWN0OiAlLjFmIHRvICUuMWYgKCslLjFmKQpDb250ZW50V2lkdGg6ICUuMWYsJS4xZiwgSGVhZGVyc1VzZWQvSWRlYWwgJS4xZi8lLjFmClNvcnQ6ICVkJXMsIFVzZXJJRDogMHglMDhYLCBGbGFnczogMHglMDRYOiAlcyVzJXMuLgBJdGVtIFBpY2tlci4uAEFkZCBhbm90aGVyIG1vZGFsLi4ARGVsZXRlLi4AUmVjdXJzZS4uAE1vcmUuLgBUb2dnbGUuLgBJdGVtICVkLi4AYW5vdGhlciBvbmUgb2YgdGhvc2UgdHJlZSBub2RlLi4uAExpbmUgJWQgQ29sdW1uICVkLi4uAERlbW9uc3RyYXRlIG1peGluZyB0YWJsZSBjb250ZXh0IG1lbnUgKG92ZXIgaGVhZGVyKSwgaXRlbSBjb250ZXh0IGJ1dHRvbiAob3ZlciBidXR0b24pIGFuZCBjdXN0b20gcGVyLWNvbHVtIGNvbnRleHQgbWVudSAob3ZlciBjb2x1bW4gYm9keSkuAElmIHNjcm9sbGluZyBpcyBkaXNhYmxlZCAoU2Nyb2xsWCBhbmQgU2Nyb2xsWSBub3Qgc2V0KToKLSBUaGUgdGFibGUgaXMgb3V0cHV0IGRpcmVjdGx5IGluIHRoZSBwYXJlbnQgd2luZG93LgotIE91dGVyU2l6ZS54IDwgMC4wZiB3aWxsIHJpZ2h0LWFsaWduIHRoZSB0YWJsZS4KLSBPdXRlclNpemUueCA9IDAuMGYgd2lsbCBuYXJyb3cgZml0IHRoZSB0YWJsZSB1bmxlc3MgdGhlcmUgYXJlIGFueSBTdHJldGNoIGNvbHVtbi4KLSBPdXRlclNpemUueSB0aGVuIGJlY29tZXMgdGhlIG1pbmltdW0gc2l6ZSBmb3IgdGhlIHRhYmxlLCB3aGljaCB3aWxsIGV4dGVuZCB2ZXJ0aWNhbGx5IGlmIHRoZXJlIGFyZSBtb3JlIHJvd3MgKHVubGVzcyBOb0hvc3RFeHRlbmRZIGlzIHNldCkuAENsaWNrIGFuZCBkcmFnIG9uIGxvd2VyIGNvcm5lciB0byByZXNpemUgd2luZG93Cihkb3VibGUtY2xpY2sgdG8gYXV0byBmaXQgd2luZG93IHRvIGl0cyBjb250ZW50cykuAERpc2FibGUgcm91bmRpbmcgdW5kZXJseWluZyB2YWx1ZSB0byBtYXRjaCBwcmVjaXNpb24gb2YgdGhlIGZvcm1hdCBzdHJpbmcgKGUuZy4gJS4zZiB2YWx1ZXMgYXJlIHJvdW5kZWQgdG8gdGhvc2UgMyBkaWdpdHMpLgBXaGVuIFNjcm9sbFggaXMgZW5hYmxlZCwgdGhlIGRlZmF1bHQgc2l6aW5nIHBvbGljeSBiZWNvbWVzIEltR3VpVGFibGVGbGFnc19TaXppbmdGaXhlZEZpdCwgYXMgYXV0b21hdGljYWxseSBzdHJldGNoaW5nIGNvbHVtbnMgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2Ugd2l0aCBob3Jpem9udGFsIHNjcm9sbGluZy4KCkFsc28gbm90ZSB0aGF0IGFzIG9mIHRoZSBjdXJyZW50IHZlcnNpb24sIHlvdSB3aWxsIGFsbW9zdCBhbHdheXMgd2FudCB0byBlbmFibGUgU2Nyb2xsWSBhbG9uZyB3aXRoIFNjcm9sbFgsYmVjYXVzZSB0aGUgY29udGFpbmVyIHdpbmRvdyB3b24ndCBhdXRvbWF0aWNhbGx5IGV4dGVuZCB2ZXJ0aWNhbGx5IHRvIGZpeCBjb250ZW50cyAodGhpcyBtYXkgYmUgaW1wcm92ZWQgaW4gZnV0dXJlIHZlcnNpb25zKS4ARW5hYmxlIGxvZ2FyaXRobWljIGVkaXRpbmcgKG1vcmUgcHJlY2lzaW9uIGZvciBzbWFsbCB2YWx1ZXMpLgBVU0VSOgpIb2xkIFNISUZUIG9yIHVzZSBtb3VzZSB0byBzZWxlY3QgdGV4dC4KQ1RSTCtMZWZ0L1JpZ2h0IHRvIHdvcmQganVtcC4KQ1RSTCtBIG9yIGRvdWJsZS1jbGljayB0byBzZWxlY3QgYWxsLgpDVFJMK1gsQ1RSTCtDLENUUkwrViBjbGlwYm9hcmQuCkNUUkwrWixDVFJMK1kgdW5kby9yZWRvLgpFU0NBUEUgdG8gcmV2ZXJ0LgoKUFJPR1JBTU1FUjoKWW91IGNhbiB1c2UgdGhlIEltR3VpSW5wdXRUZXh0RmxhZ3NfQ2FsbGJhY2tSZXNpemUgZmFjaWxpdHkgaWYgeW91IG5lZWQgdG8gd2lyZSBJbnB1dFRleHQoKSB0byBhIGR5bmFtaWMgc3RyaW5nIHR5cGUuIFNlZSBtaXNjL2NwcC9pbWd1aV9zdGRsaWIuaCBmb3IgYW4gZXhhbXBsZSAodGhpcyBpcyBub3QgZGVtb25zdHJhdGVkIGluIGltZ3VpX2RlbW8uY3BwKS4AVGhlICJUb29scyIgbWVudSBhYm92ZSBnaXZlcyBhY2Nlc3MgdG86IEFib3V0IEJveCwgU3R5bGUgRWRpdG9yLAphbmQgTWV0cmljcy9EZWJ1Z2dlciAoZ2VuZXJhbCBwdXJwb3NlIERlYXIgSW1HdWkgZGVidWdnaW5nIHRvb2wpLgBFbmFibGUgdHVybmluZyBEcmFnWFhYIHdpZGdldHMgaW50byB0ZXh0IGlucHV0IHdpdGggYSBzaW1wbGUgbW91c2UgY2xpY2stcmVsZWFzZSAod2l0aG91dCBtb3ZpbmcpLgBGYXN0ZXIgbGluZXMgdXNpbmcgdGV4dHVyZSBkYXRhLiBSZXF1aXJlIGJhY2tlbmQgdG8gcmVuZGVyIHdpdGggYmlsaW5lYXIgZmlsdGVyaW5nIChub3QgcG9pbnQvbmVhcmVzdCBmaWx0ZXJpbmcpLgBJbnN0cnVjdCBEZWFyIEltR3VpIHRvIHJlbmRlciBhIG1vdXNlIGN1cnNvciBpdHNlbGYuIE5vdGUgdGhhdCBhIG1vdXNlIGN1cnNvciByZW5kZXJlZCB2aWEgeW91ciBhcHBsaWNhdGlvbiBHUFUgcmVuZGVyaW5nIHBhdGggd2lsbCBmZWVsIG1vcmUgbGFnZ3kgdGhhbiBoYXJkd2FyZSBjdXJzb3IsIGJ1dCB3aWxsIGJlIG1vcmUgaW4gc3luYyB3aXRoIHlvdXIgb3RoZXIgdmlzdWFscy4KClNvbWUgZGVza3RvcCBhcHBsaWNhdGlvbnMgbWF5IHVzZSBib3RoIGtpbmRzIG9mIGN1cnNvcnMgKGUuZy4gZW5hYmxlIHNvZnR3YXJlIGN1cnNvciBvbmx5IHdoZW4gcmVzaXppbmcvZHJhZ2dpbmcgc29tZXRoaW5nKS4AQWRqdXN0IGlmIHlvdSBjYW5ub3Qgc2VlIHRoZSBlZGdlcyBvZiB5b3VyIHNjcmVlbiAoZS5nLiBvbiBhIFRWIHdoZXJlIHNjYWxpbmcgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQpLgBXaGVuIHNvcnRpbmcgaXMgZW5hYmxlZDogaG9sZCBzaGlmdCB3aGVuIGNsaWNraW5nIGhlYWRlcnMgdG8gc29ydCBvbiBtdWx0aXBsZSBjb2x1bW4uIFRhYmxlR2V0U29ydFNwZWNzKCkgbWF5IHJldHVybiBzcGVjcyB3aGVyZSAoU3BlY3NDb3VudCA+IDEpLgBXaGVuIHNvcnRpbmcgaXMgZW5hYmxlZDogYWxsb3cgbm8gc29ydGluZywgZGlzYWJsZSBkZWZhdWx0IHNvcnRpbmcuIFRhYmxlR2V0U29ydFNwZWNzKCkgbWF5IHJldHVybiBzcGVjcyB3aGVyZSAoU3BlY3NDb3VudCA9PSAwKS4AQ29sb3JFZGl0IGRlZmF1bHRzIHRvIGRpc3BsYXlpbmcgUkdCIGlucHV0cyBpZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhIGRpc3BsYXkgbW9kZSwgYnV0IHRoZSB1c2VyIGNhbiBjaGFuZ2UgaXQgd2l0aCBhIHJpZ2h0LWNsaWNrLgoKQ29sb3JQaWNrZXIgZGVmYXVsdHMgdG8gZGlzcGxheWluZyBSR0IrSFNWK0hleCBpZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhIGRpc3BsYXkgbW9kZS4KCllvdSBjYW4gY2hhbmdlIHRoZSBkZWZhdWx0cyB1c2luZyBTZXRDb2xvckVkaXRPcHRpb25zKCkuAEhvcml6b250YWwgc2Nyb2xsaW5nIGZvciBhIHdpbmRvdyBpcyBlbmFibGVkIHZpYSB0aGUgSW1HdWlXaW5kb3dGbGFnc19Ib3Jpem9udGFsU2Nyb2xsYmFyIGZsYWcuCgpZb3UgbWF5IHdhbnQgdG8gYWxzbyBleHBsaWNpdGx5IHNwZWNpZnkgY29udGVudCB3aWR0aCBieSB1c2luZyBTZXROZXh0V2luZG93Q29udGVudFdpZHRoKCkgYmVmb3JlIEJlZ2luKCkuAC0gTG9hZCBhZGRpdGlvbmFsIGZvbnRzIHdpdGggaW8uRm9udHMtPkFkZEZvbnRGcm9tRmlsZVRURigpLgotIFRoZSBmb250IGF0bGFzIGlzIGJ1aWx0IHdoZW4gY2FsbGluZyBpby5Gb250cy0+R2V0VGV4RGF0YUFzWFhYWCgpIG9yIGlvLkZvbnRzLT5CdWlsZCgpLgotIFJlYWQgRkFRIGFuZCBkb2NzL0ZPTlRTLm1kIGZvciBtb3JlIGRldGFpbHMuCi0gSWYgeW91IG5lZWQgdG8gYWRkL3JlbW92ZSBmb250cyBhdCBydW50aW1lIChlLmcuIGZvciBEUEkgY2hhbmdlKSwgZG8gaXQgYmVmb3JlIGNhbGxpbmcgTmV3RnJhbWUoKS4AVGVzdGluZyBob3cgdmFyaW91cyB0eXBlcyBvZiBpdGVtcyBhcmUgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgSXNJdGVtWFhYIGZ1bmN0aW9ucy4gTm90ZSB0aGF0IHRoZSBib29sIHJldHVybiB2YWx1ZSBvZiBtb3N0IEltR3VpIGZ1bmN0aW9uIGlzIGdlbmVyYWxseSBlcXVpdmFsZW50IHRvIGNhbGxpbmcgSW1HdWk6OklzSXRlbUhvdmVyZWQoKS4AWW91IGNhbiBpbnB1dCB2YWx1ZSB1c2luZyB0aGUgc2NpZW50aWZpYyBub3RhdGlvbiwKICBlLmcuICIxZSs4IiBiZWNvbWVzICIxMDAwMDAwMDAiLgAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQAgIHcvIGRlZmF1bHQgdGhyZXNob2xkOiAlZCwAICB3LyB6ZXJvIHRocmVzaG9sZDogJWQsACAgdy8gbGFyZ2UgdGhyZXNob2xkOiAlZCwAKwAqVW5rbm93biBpdGVtKgAgKkluYWN0aXZlKgBjb21ibyAzIChhcnJheSkAQ29sdW1uICUwMmQ6IE9mZnNldE5vcm0gJS4zZiAoPSAlLjFmIHB4KQBnLkFjdGl2ZUlkID09IGNvbHVtbnMtPklEICsgSW1HdWlJRChjb2x1bW5faW5kZXgpACh4KQBTZWxlY3RhYmxlIChzcGFuIHJvdykAOiBEcmF3Q21kOiArJWQgKGluIHNhbWUgd2luZG93KQBwYXJlbnRfd2luZG93ICE9IDBMIHx8ICEoZmxhZ3MgJiBJbUd1aVdpbmRvd0ZsYWdzX0NoaWxkV2luZG93KQAoZmxhZ3MgJiAoSW1HdWlDb21ib0ZsYWdzX05vQXJyb3dCdXR0b24gfCBJbUd1aUNvbWJvRmxhZ3NfTm9QcmV2aWV3KSkgIT0gKEltR3VpQ29tYm9GbGFnc19Ob0Fycm93QnV0dG9uIHwgSW1HdWlDb21ib0ZsYWdzX05vUHJldmlldykAKGRlbW8gbWVudSkAaW5wdXQgdGV4dCAody8gaGludCkAcGFzc3dvcmQgKHcvIGhpbnQpAHBheWxvYWQtPkRhdGFTaXplID09IHNpemVvZihpbnQpAERpc2FibGUgb3V0ZXItbW9zdCBwYWRkaW5nIChkZWZhdWx0IGlmIEltR3VpVGFibGVGbGFnc19Cb3JkZXJzT3V0ZXJWIGlzIG5vdCBzZXQpAEVuYWJsZSBvdXRlci1tb3N0IHBhZGRpbmcgKGRlZmF1bHQgaWYgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlclYgaXMgc2V0KQBIYWxmIG9mIGF2YWlsYWJsZSB3aWR0aC4KKH4gcmlnaHQtY3Vyc29yX3BvcykKKHdvcmtzIHdpdGhpbiBhIGNvbHVtbiBzZXQpAGxpc3Rib3gKKHNpbmdsZSBzZWxlY3QpAEJ1dHRvbiAody8gcmVwZWF0KQBEaXNhYmxlIHZlcnRpY2FsIGJvcmRlcnMgaW4gY29sdW1ucyBCb2R5IHVudGlsIGhvdmVyZWQgZm9yIHJlc2l6ZSAoYm9yZGVycyB3aWxsIGFsd2F5cyBhcHBlYXJzIGluIEhlYWRlcnMpAFVzaW5nIEltR3VpOjpQdXNoQ2xpcFJlY3QoKToKV2lsbCBhbHRlciBJbUd1aSBoaXQtdGVzdGluZyBsb2dpYyArIEltRHJhd0xpc3QgcmVuZGVyaW5nLgoodXNlIHRoaXMgaWYgeW91IHdhbnQgeW91ciBjbGlwcGluZyByZWN0YW5nbGUgdG8gYWZmZWN0IGludGVyYWN0aW9ucykAU2V0dGluZ3MgMHglMDhYICglZCBjb2x1bW5zKQBVc2luZyBJbURyYXdMaXN0OjpBZGRUZXh0KCkgd2l0aCBhIGZpbmUgQ2xpcFJlY3Q6CldpbGwgYWx0ZXIgb25seSB0aGlzIHNwZWNpZmljIEltRHJhd0xpc3Q6OkFkZFRleHQoKSByZW5kZXJpbmcuCih0aGlzIGlzIG9mdGVuIHVzZWQgaW50ZXJuYWxseSB0byBhdm9pZCBhbHRlcmluZyB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlIGFuZCBtaW5pbWl6ZSBkcmF3IGNhbGxzKQBVc2luZyBJbURyYXdMaXN0OjpQdXNoQ2xpcFJlY3QoKToKV2lsbCBhbHRlciBJbURyYXdMaXN0IHJlbmRlcmluZyBvbmx5LgoodXNlIHRoaXMgYXMgYSBzaG9ydGN1dCBpZiB5b3UgYXJlIG9ubHkgdXNpbmcgSW1EcmF3TGlzdCBjYWxscykAQnVsbGV0IHBvaW50IDMgKHR3byBjYWxscykAQXRsYXMgdGV4dHVyZSAoJWR4JWQgcGl4ZWxzKQBEcmFnRHJvcDogJWQsIFNvdXJjZUlkID0gMHglMDhYLCBQYXlsb2FkICIlcyIgKCVkIGJ5dGVzKQAlZCB2ZXJ0aWNlcywgJWQgaW5kaWNlcyAoJWQgdHJpYW5nbGVzKQAgKERlcykAcmFuZ2UgaW50IChubyBib3VuZHMpAGIlZCAoJS4wMmYgc2VjcykAJWQgKDB4JVgpICglLjAyZiBzZWNzKQBGb250OiAiJXMiCiUuMmYgcHgsICVkIGdseXBocywgJWQgZmlsZShzKQBkZWFyIGltZ3VpIHNheXMgaGVsbG8uICglcykAVSslMDRYLi5VKyUwNFggKCVkICVzKQB3aW5kb3ctPkRDLk5hdkxheWVyQWN0aXZlTWFza05leHQgJiAoMSA8PCBsYXllcikAY29tYm8gMiAob25lLWxpbmVyKQBwYXNzd29yZCAoY2xlYXIpAChNYWluIG1lbnUgYmFyKQAoUG9wdXApADQgKHRhYiBza2lwKQAzICh0YWIgc2tpcCkAIChhdXRvKQBIaXJhZ2FuYTog44GL44GN44GP44GR44GTIChrYWtpa3VrZWtvKQBLYW5qaXM6IOaXpeacrOiqniAobmlob25nbykAIWlzX3RhYl9idXR0b24gfHwgISh0YWJfYmFyLT5TZWxlY3RlZFRhYklkID09IHRhYi0+SUQgJiYgaXNfdGFiX2J1dHRvbikAIXBfb3BlbiB8fCAhKGZsYWdzICYgSW1HdWlUYWJJdGVtRmxhZ3NfQnV0dG9uKQAhKHRhYi0+RmxhZ3MgJiBJbUd1aVRhYkl0ZW1GbGFnc19CdXR0b24pAFNpbXBsZSBvdmVybGF5CmluIHRoZSBjb3JuZXIgb2YgdGhlIHNjcmVlbi4KKHJpZ2h0LWNsaWNrIHRvIGNoYW5nZSBwb3NpdGlvbikAY29tYm8gNCAoZnVuY3Rpb24pAGl0ZW1zX3R5cGUgKGZpcnN0IGNvbHVtbikAIChGcm96ZW4pAChVc2UgSW1HdWk6OlNhbWVMaW5lKCkgdG8ga2VlcCBhZGRpbmcgaXRlbXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwcmVjZWRpbmcgaXRlbSkAKG51bGwpAChDbGljayBhbmQgZHJhZyB0byBzY3JvbGwpAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb2xvckVkaXRGbGFnc19fRGlzcGxheU1hc2spAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb2xvckVkaXRGbGFnc19fSW5wdXRNYXNrKQBJbUlzUG93ZXJPZlR3byhmbGFncyAmIEltR3VpQ29sb3JFZGl0RmxhZ3NfX1BpY2tlck1hc2spAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb2xvckVkaXRGbGFnc19fRGF0YVR5cGVNYXNrKQBUcmVlTm9kZSAody8gZG91YmxlLWNsaWNrKQBzbGlkZXIgZmxvYXQgKGxvZykARW1iZWQgZXZlcnl0aGluZyBpbnNpZGUgYSBjaGlsZCB3aW5kb3cgKGZvciBhZGRpdGlvbmFsIHRlc3RpbmcpAEVuYWJsZSBibGlua2luZyBjdXJzb3IgKG9wdGlvbmFsIGFzIHNvbWUgdXNlcnMgY29uc2lkZXIgaXQgdG8gYmUgZGlzdHJhY3RpbmcpAChmbGFncyAmIChJbUd1aVRhYkl0ZW1GbGFnc19MZWFkaW5nIHwgSW1HdWlUYWJJdGVtRmxhZ3NfVHJhaWxpbmcpKSAhPSAoSW1HdWlUYWJJdGVtRmxhZ3NfTGVhZGluZyB8IEltR3VpVGFiSXRlbUZsYWdzX1RyYWlsaW5nKQBNb3VzZSBwb3M6ICglZywgJWcpAE1vdXNlIGRlbHRhOiAoJWcsICVnKQBjYWxsYmFja19kYXRhLkJ1ZlRleHRMZW4gPT0gKGludClzdHJsZW4oY2FsbGJhY2tfZGF0YS5CdWYpAERyYWdGbG9hdCAoLWluZiAtPiAraW5mKQBEcmFnRmxvYXQgKDAgLT4gK2luZikARGlzYWJsZSBpbm5lciBwYWRkaW5nIGJldHdlZW4gY29sdW1ucyAoZG91YmxlIGlubmVyIHBhZGRpbmcgaWYgQm9yZGVyc091dGVyViBpcyBvbiwgc2luZ2xlIGlubmVyIHBhZGRpbmcgaWYgQm9yZGVyc091dGVyViBpcyBvZmYpACglLjNmZiwgJS4zZmYsICUuM2ZmLCAlLjNmZikAMTcuMC4wIChodHRwczovL2dpdGh1Yi5jb20vbGx2bS9sbHZtLXByb2plY3QgODg0MjFlYTk3MzkxNmU2MGMzNGJlYjI2NTk3YTVmYzMzZjgzZGQ4ZikAU2V0TmV4dEl0ZW1XaWR0aC9QdXNoSXRlbVdpZHRoKC1HZXRDb250ZW50UmVnaW9uQXZhaWwoKS54ICogMC41ZikAU2V0TmV4dEl0ZW1XaWR0aC9QdXNoSXRlbVdpZHRoKEdldENvbnRlbnRSZWdpb25BdmFpbCgpLnggKiAwLjVmKQBVVjogKCUuM2YsJS4zZiktPiglLjNmLCUuM2YpACMlMDJYJTAyWCUwMlgKUjogJWQsIEc6ICVkLCBCOiAlZAooJS4zZiwgJS4zZiwgJS4zZikAIyUwMlglMDJYJTAyWCUwMlgKUjolZCwgRzolZCwgQjolZCwgQTolZAooJS4zZiwgJS4zZiwgJS4zZiwgJS4zZikAUG9zOiAoJS4yZiwlLjJmKS0+KCUuMmYsJS4yZikATWF4OiAoJS4yZiwgJS4yZikATWluOiAoJS4yZiwgJS4yZikAKHc6ICU1LjFmKQBOYXZSZWN0UmVsWzBdOiAoJS4xZiwlLjFmKSglLjFmLCUuMWYpAFBvczogKCUuMWYsJS4xZiksIFNpemU6ICglLjFmLCUuMWYpLCBDb250ZW50U2l6ZSAoJS4xZiwlLjFmKSBJZGVhbCAoJS4xZiwlLjFmKQBJbnB1dCAlZDogJyVzJywgT3ZlcnNhbXBsZTogKCVkLCVkKSwgUGl4ZWxTbmFwSDogJWQsIE9mZnNldDogKCUuMWYsJS4xZikATW91c2UgUG9zaXRpb246ICglLjFmLCUuMWYpAFdpZHRoOiAlLjFmIChNaW5YOiAlLjFmLCBNYXhYOiAlLjFmKQBSZXR1cm4gdmFsdWUgPSAlZApJc0l0ZW1Gb2N1c2VkKCkgPSAlZApJc0l0ZW1Ib3ZlcmVkKCkgPSAlZApJc0l0ZW1Ib3ZlcmVkKF9BbGxvd1doZW5CbG9ja2VkQnlQb3B1cCkgPSAlZApJc0l0ZW1Ib3ZlcmVkKF9BbGxvd1doZW5CbG9ja2VkQnlBY3RpdmVJdGVtKSA9ICVkCklzSXRlbUhvdmVyZWQoX0FsbG93V2hlbk92ZXJsYXBwZWQpID0gJWQKSXNJdGVtSG92ZXJlZChfUmVjdE9ubHkpID0gJWQKSXNJdGVtQWN0aXZlKCkgPSAlZApJc0l0ZW1FZGl0ZWQoKSA9ICVkCklzSXRlbUFjdGl2YXRlZCgpID0gJWQKSXNJdGVtRGVhY3RpdmF0ZWQoKSA9ICVkCklzSXRlbURlYWN0aXZhdGVkQWZ0ZXJFZGl0KCkgPSAlZApJc0l0ZW1WaXNpYmxlKCkgPSAlZApJc0l0ZW1DbGlja2VkKCkgPSAlZApJc0l0ZW1Ub2dnbGVkT3BlbigpID0gJWQKR2V0SXRlbVJlY3RNaW4oKSA9ICglLjFmLCAlLjFmKQpHZXRJdGVtUmVjdE1heCgpID0gKCUuMWYsICUuMWYpCkdldEl0ZW1SZWN0U2l6ZSgpID0gKCUuMWYsICUuMWYpACAgdy8gZGVmYXVsdCB0aHJlc2hvbGQ6ICglLjFmLCAlLjFmKQAgIHcvIHplcm8gdGhyZXNob2xkOiAoJS4xZiwgJS4xZikAaW8uTW91c2VEZWx0YTogKCUuMWYsICUuMWYpAERyYXdDbWQ6JTVkIHRyaXMsIFRleCAweCVwLCBDbGlwUmVjdCAoJTQuMGYsJTQuMGYpLSglNC4wZiwlNC4wZikAUmVjdCBvZiBjaGlsZCB3aW5kb3cgaXM6ICglLjBmLCUuMGYpICglLjBmLCUuMGYpADogRHJhd0NtZDogKyVkIChpbiBjaGlsZCB3aW5kb3cpLCBTY3JvbGw6ICglLmYvJS5mKSAoJS5mLyUuZikAaW5uZXJfd2lkdGggKHdoZW4gU2Nyb2xsWCBhY3RpdmUpAFNsaWRlcnMgKHJldmVyc2UpAFlvdSBjYW4gdXNlIHRoZSBJbUd1aUlucHV0VGV4dEZsYWdzX0NhbGxiYWNrUmVzaXplIGZhY2lsaXR5IGlmIHlvdSBuZWVkIHRvIHdpcmUgSW5wdXRUZXh0TXVsdGlsaW5lKCkgdG8gYSBkeW5hbWljIHN0cmluZyB0eXBlLiBTZWUgbWlzYy9jcHAvaW1ndWlfc3RkbGliLmggZm9yIGFuIGV4YW1wbGUuIChUaGlzIGlzIG5vdCBkZW1vbnN0cmF0ZWQgaW4gaW1ndWlfZGVtby5jcHAgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgPHN0cmluZz4gaW4gaGVyZSkAVmFsdWUgPSAlLjNmICg8LS0gcmlnaHQtY2xpY2sgaGVyZSkAIShmbGFncyAmIEltR3VpSW5wdXRUZXh0RmxhZ3NfTXVsdGlsaW5lKQBEcmFnIHRvIHJlb3JkZXIgaXRlbXMgKHNpbXBsZSkAJWQgYWN0aXZlIHdpbmRvd3MgKCVkIHZpc2libGUpAGNvbmQgPT0gMCB8fCBJbUlzUG93ZXJPZlR3byhjb25kKQAoVW50aXRsZWQpACglZCwlZCwlZCwlZCkAQWN0aXZlIERyYXdMaXN0cyAoJWQpAENvbHVtbnMgc2V0cyAoJWQpAFRhYiBCYXJzICglZCkAUG9wdXBzICglZCkAR2x5cGhzICglZCkAVGFibGVzICglZCkARGVhciBJbUd1aSAlcyAoJWQpAFNldHRpbmdzIGhhbmRsZXJzOiAoJWQpAENvbHVtbnNDb3VudDogJWQgKG1heCAlZCkARmlsdGVyIChpbmMsLWV4YykAIChBc2MpAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb21ib0ZsYWdzX0hlaWdodE1hc2tfKQBJbUlzUG93ZXJPZlR3byhmbGFncyAmIEltR3VpVGFibGVDb2x1bW5GbGFnc19XaWR0aE1hc2tfKQAnJWMnICgweCUwNFgpAEVsbGlwc2lzIGNoYXJhY3RlcjogJyVjJyAoVSslMDRYKQBGYWxsYmFjayBjaGFyYWN0ZXI6ICclYycgKFUrJTA0WCkAJWQgKDB4JVgpAEFwcGxpY2F0aW9uIGF2ZXJhZ2UgJS4zZiBtcy9mcmFtZSAoJS4xZiBGUFMpAFNldE5leHRJdGVtV2lkdGgvUHVzaEl0ZW1XaWR0aCgtRkxUX01JTikAKD8pAChJbiBmcm9udC10by1iYWNrIG9yZGVyOikAY2hhbm5lbF9ubyA8ICg0ICsgNjQgKiAyKQBEcmFnRmxvYXQgKC1pbmYgLT4gMSkAU2xpZGVyRmxvYXQgKDAgLT4gMSkARHJhZ0Zsb2F0ICgwIC0+IDEpAFNldE5leHRJdGVtV2lkdGgvUHVzaEl0ZW1XaWR0aCgtMTAwKQBTZXROZXh0SXRlbVdpZHRoL1B1c2hJdGVtV2lkdGgoMTAwKQBDdXN0b206IEZpeGVkIFN0ZXBzICgxMDApAFNsaWRlckludCAoMCAtPiAxMDApAERyYWdJbnQgKDAgLT4gMTAwKQAoZGF0YSAhPSAwTCAmJiBkYXRhX3NpemUgPiAwKSB8fCAoZGF0YSA9PSAwTCAmJiBkYXRhX3NpemUgPT0gMCkAKFlvdSBjYW4gYWxzbyByaWdodC1jbGljayBtZSB0byBvcGVuIHRoZSBzYW1lIHBvcHVwIGFzIGFib3ZlLikATm90ZSB0aGFuIHRoZSBkZWZhdWx0IGVtYmVkZGVkIGZvbnQgaXMgTk9UIG1lYW50IHRvIGJlIHNjYWxlZC4KCkZvbnQgYXJlIGN1cnJlbnRseSByZW5kZXJlZCBpbnRvIGJpdG1hcHMgYXQgYSBnaXZlbiBzaXplIGF0IHRoZSB0aW1lIG9mIGJ1aWxkaW5nIHRoZSBhdGxhcy4gWW91IG1heSBvdmVyc2FtcGxlIHRoZW0gdG8gZ2V0IHNvbWUgZmxleGliaWxpdHkgd2l0aCBzY2FsaW5nLiBZb3UgY2FuIGFsc28gcmVuZGVyIGF0IG11bHRpcGxlIHNpemVzIGFuZCBzZWxlY3Qgd2hpY2ggb25lIHRvIHVzZSBhdCBydW50aW1lLgoKKEdsaW1tZXIgb2YgaG9wZTogdGhlIGF0bGFzIHN5c3RlbSB3aWxsIGJlIHJld3JpdHRlbiBpbiB0aGUgZnV0dXJlIHRvIG1ha2Ugc2NhbGluZyBtb3JlIGZsZXhpYmxlLikAUXVlcnlpbmcgU3RhdHVzIChFZGl0ZWQvQWN0aXZlL0ZvY3VzZWQvSG92ZXJlZCBldGMuKQBGbGFnczogMHglMDhYICglcyVzJXMlcyVzJXMlcyVzJXMuLikAISgoZmxhZ3MgJiBJbUd1aUlucHV0VGV4dEZsYWdzX0NhbGxiYWNrQ29tcGxldGlvbikgJiYgKGZsYWdzICYgSW1HdWlJbnB1dFRleHRGbGFnc19BbGxvd1RhYklucHV0KSkAY2hhbm5lbC0+X0NtZEJ1ZmZlci5TaXplID09IDEgJiYgbWVyZ2VfY2xpcF9yZWN0LkNvbnRhaW5zKEltUmVjdChjaGFubmVsLT5fQ21kQnVmZmVyWzBdLkNsaXBSZWN0KSkASW1Jc1Bvd2VyT2ZUd28oZmxhZ3MgJiAoSW1HdWlTZXBhcmF0b3JGbGFnc19Ib3Jpem9udGFsIHwgSW1HdWlTZXBhcmF0b3JGbGFnc19WZXJ0aWNhbCkpACEoKGZsYWdzICYgSW1HdWlJbnB1dFRleHRGbGFnc19DYWxsYmFja0hpc3RvcnkpICYmIChmbGFncyAmIEltR3VpSW5wdXRUZXh0RmxhZ3NfTXVsdGlsaW5lKSkAY291bnQgPT0gKChpbnQpKHNpemVvZihQb3MpIC8gc2l6ZW9mKCooUG9zKSkpKQB1c2VyX2tleV9pbmRleCA+PSAwICYmIHVzZXJfa2V5X2luZGV4IDwgKChpbnQpKHNpemVvZihnLklPLktleXNEb3duKSAvIHNpemVvZigqKGcuSU8uS2V5c0Rvd24pKSkpAGtleV9pbmRleCA+PSAwICYmIGtleV9pbmRleCA8ICgoaW50KShzaXplb2YoZy5JTy5LZXlzRG93bikgLyBzaXplb2YoKihnLklPLktleXNEb3duKSkpKQBidXR0b24gPj0gMCAmJiBidXR0b24gPCAoKGludCkoc2l6ZW9mKGcuSU8uTW91c2VEb3duKSAvIHNpemVvZigqKGcuSU8uTW91c2VEb3duKSkpKQBnLlNldHRpbmdzV2luZG93cy5lbXB0eSgpAGcuTG9nQnVmZmVyLmVtcHR5KCkAcGFzc3dvcmRfZm9udC0+R2x5cGhzLmVtcHR5KCkgJiYgcGFzc3dvcmRfZm9udC0+SW5kZXhBZHZhbmNlWC5lbXB0eSgpICYmIHBhc3N3b3JkX2ZvbnQtPkluZGV4TG9va3VwLmVtcHR5KCkAU2hvdyBUcmFpbGluZyBUYWJJdGVtQnV0dG9uKCkAU2hvdyBMZWFkaW5nIFRhYkl0ZW1CdXR0b24oKQBTbWFsbEJ1dHRvbigpAGl0ZW1fZmxhZ3MgPT0gZy5JdGVtRmxhZ3NTdGFjay5iYWNrKCkAcCA+PSBiZWdpbigpICYmIHAgPCBlbmQoKQAhZy5OYXZTY29yaW5nUmVjdC5Jc0ludmVydGVkKCkAZm9udCAmJiBmb250LT5Jc0xvYWRlZCgpAFRhYmxlIDB4JTA4WCAoJWQgY29sdW1ucywgaW4gJyVzJykARmlsdGVyICgiaW5jbCwtZXhjbCIpICgiZXJyb3IiKQAoICkATmF2V2luZG93OiAnJXMnAEhvdmVyZWRSb290V2luZG93OiAnJXMnAEhvdmVyZWRXaW5kb3dVbmRlck1vdmluZ1dpbmRvdzogJyVzJwBIb3ZlcmVkV2luZG93OiAnJXMnAEFjdGl2ZUlkV2luZG93OiAnJXMnAE5hdldpbmRvd2luZ1RhcmdldDogJyVzJwBPdXRlclJlY3Q6IFBvczogKCUuMWYsJS4xZikgU2l6ZTogKCUuMWYsJS4xZikgU2l6aW5nOiAnJXMnAG5hbWUgIT0gMEwgJiYgbmFtZVswXSAhPSAnXDAnAG9wID09ICcrJyB8fCBvcCA9PSAnLScANzUlADI1JQAlLjBmJSUAJWQlJQBNYXg6ICUuMWYgJSUATWluOiAlLjFmICUlACMjIwBMaW5lICMARmlsdGVyIHVzYWdlOgogICIiICAgICAgICAgZGlzcGxheSBhbGwgbGluZXMKICAieHh4IiAgICAgIGRpc3BsYXkgbGluZXMgY29udGFpbmluZyAieHh4IgogICJ4eHgseXl5IiAgZGlzcGxheSBsaW5lcyBjb250YWluaW5nICJ4eHgiIG9yICJ5eXkiCiAgIi14eHgiICAgICBoaWRlIGxpbmVzIGNvbnRhaW5pbmcgInh4eCIAKGtleV9tb2RfZmxhZ3MgPT0gMCB8fCBnLklPLktleU1vZHMgPT0ga2V5X21vZF9mbGFncykgJiYgIk1pc21hdGNoaW5nIGlvLktleUN0cmwvaW8uS2V5U2hpZnQvaW8uS2V5QWx0L2lvLktleVN1cGVyIHZzIGlvLktleU1vZHMiAGlvLktleU1vZHMgPT0gR2V0TWVyZ2VkS2V5TW9kRmxhZ3MoKSAmJiAiTWlzbWF0Y2hpbmcgaW8uS2V5Q3RybC9pby5LZXlTaGlmdC9pby5LZXlBbHQvaW8uS2V5U3VwZXIgdnMgaW8uS2V5TW9kcyIARG9jdW1lbnQgIiVzIgBzdHJsZW4odHlwZSkgPCAoKGludCkoc2l6ZW9mKHBheWxvYWQuRGF0YVR5cGUpIC8gc2l6ZW9mKCoocGF5bG9hZC5EYXRhVHlwZSkpKSkgJiYgIlBheWxvYWQgdHlwZSBjYW4gYmUgYXQgbW9zdCAzMiBjaGFyYWN0ZXJzIGxvbmciAGRyYXdfbGlzdC0+X1Z0eEN1cnJlbnRJZHggPCAoMSA8PCAxNikgJiYgIlRvbyBtYW55IHZlcnRpY2VzIGluIEltRHJhd0xpc3QgdXNpbmcgMTYtYml0IGluZGljZXMuIFJlYWQgY29tbWVudCBhYm92ZSIAdGFibGUtPkNvbHVtbnNDb3VudCA9PSBjb2x1bW5zX2NvdW50ICYmICJCZWdpblRhYmxlKCk6IENhbm5vdCBjaGFuZ2UgY29sdW1ucyBjb3VudCBtaWQtZnJhbWUgd2hpbGUgcHJlc2VydmluZyBzYW1lIElEIgAoZy5DdXJyZW50V2luZG93U3RhY2suU2l6ZSA9PSAxKSAmJiAiTWlzbWF0Y2hlZCBCZWdpbi9CZWdpbkNoaWxkIHZzIEVuZC9FbmRDaGlsZCBjYWxsczogZGlkIHlvdSBjYWxsIEVuZC9FbmRDaGlsZCB0b28gbXVjaD8iAEl0ZW1zQ291bnQgPT0gLTEgJiYgIkZvcmdvdCB0byBjYWxsIEVuZCgpLCBvciB0byBTdGVwKCkgdW50aWwgZmFsc2U/IgAoZy5GcmFtZUNvdW50ID09IDAgfHwgZy5GcmFtZUNvdW50RW5kZWQgPT0gZy5GcmFtZUNvdW50KSAmJiAiRm9yZ290IHRvIGNhbGwgUmVuZGVyKCkgb3IgRW5kRnJhbWUoKSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBmcmFtZT8iAChnLkN1cnJlbnRXaW5kb3dTdGFjay5TaXplID09IDEpICYmICJNaXNtYXRjaGVkIEJlZ2luL0JlZ2luQ2hpbGQgdnMgRW5kL0VuZENoaWxkIGNhbGxzOiBkaWQgeW91IGZvcmdldCB0byBjYWxsIEVuZC9FbmRDaGlsZD8iACh3aW5kb3ctPkZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19DaGlsZFdpbmRvdykgJiYgIk1pc21hdGNoZWQgTGlzdEJveEhlYWRlci9MaXN0Qm94Rm9vdGVyIGNhbGxzLiBEaWQgeW91IHRlc3QgdGhlIHJldHVybiB2YWx1ZSBvZiBMaXN0Qm94SGVhZGVyKCk/IgBnLldpdGhpbkZyYW1lU2NvcGUgJiYgIkZvcmdvdCB0byBjYWxsIEltR3VpOjpOZXdGcmFtZSgpPyIAZy5EcmFnRHJvcFdpdGhpblNvdXJjZSAmJiAiTm90IGFmdGVyIGEgQmVnaW5EcmFnRHJvcFNvdXJjZSgpPyIAZy5JTy5Gb250cy0+Rm9udHMuU2l6ZSA+IDAgJiYgIkZvbnQgQXRsYXMgbm90IGJ1aWx0LiBEaWQgeW91IGNhbGwgaW8uRm9udHMtPkdldFRleERhdGFBc1JHQkEzMigpIC8gR2V0VGV4RGF0YUFzQWxwaGE4KCk/IgBHSW1HdWkgIT0gMEwgJiYgIk5vIGN1cnJlbnQgY29udGV4dC4gRGlkIHlvdSBjYWxsIEltR3VpOjpDcmVhdGVDb250ZXh0KCkgYW5kIEltR3VpOjpTZXRDdXJyZW50Q29udGV4dCgpID8iAF9DdXJyZW50ID09IDAgJiYgX0NvdW50IDw9IDEgJiYgIk5lc3RlZCBjaGFubmVsIHNwbGl0dGluZyBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIHNlcGFyYXRlIGluc3RhbmNlcyBvZiBJbURyYXdMaXN0U3BsaXR0ZXIuIgBnLklPLktleU1hcFtJbUd1aUtleV9TcGFjZV0gIT0gLTEgJiYgIkltR3VpS2V5X1NwYWNlIGlzIG5vdCBtYXBwZWQsIHJlcXVpcmVkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uLiIAaW5pdF93aWR0aF9vcl93ZWlnaHQgPD0gMC4wZiAmJiAiQ2FuIG9ubHkgc3BlY2lmeSB3aWR0aC93ZWlnaHQgaWYgc2l6aW5nIHBvbGljeSBpcyBzZXQgZXhwbGljaXRlbHkgaW4gZWl0aGVyIFRhYmxlIG9yIENvbHVtbi4iADAgJiYgIkNhbm5vdCB1c2UgSXNQb3B1cE9wZW4oKSB3aXRoIGEgc3RyaW5nIGlkIGFuZCBJbUd1aVBvcHVwRmxhZ3NfQW55UG9wdXBMZXZlbC4iAGcuU3R5bGUuV2luZG93TWluU2l6ZS54ID49IDEuMGYgJiYgZy5TdHlsZS5XaW5kb3dNaW5TaXplLnkgPj0gMS4wZiAmJiAiSW52YWxpZCBzdHlsZSBzZXR0aW5nLiIAKGZsYWdzID09IDEgfHwgKGZsYWdzICYgSW1HdWlTbGlkZXJGbGFnc19JbnZhbGlkTWFza18pID09IDApICYmICJJbnZhbGlkIEltR3VpU2xpZGVyRmxhZ3MgZmxhZ3MhIEhhcyB0aGUgJ2Zsb2F0IHBvd2VyJyBhcmd1bWVudCBiZWVuIG1pc3Rha2VubHkgY2FzdCB0byBmbGFncz8gQ2FsbCBmdW5jdGlvbiB3aXRoIEltR3VpU2xpZGVyRmxhZ3NfTG9nYXJpdGhtaWMgZmxhZ3MgaW5zdGVhZC4iAChmbGFncyA9PSAxIHx8IChmbGFncyAmIEltR3VpU2xpZGVyRmxhZ3NfSW52YWxpZE1hc2tfKSA9PSAwKSAmJiAiSW52YWxpZCBJbUd1aVNsaWRlckZsYWdzIGZsYWchICBIYXMgdGhlICdmbG9hdCBwb3dlcicgYXJndW1lbnQgYmVlbiBtaXN0YWtlbmx5IGNhc3QgdG8gZmxhZ3M/IENhbGwgZnVuY3Rpb24gd2l0aCBJbUd1aVNsaWRlckZsYWdzX0xvZ2FyaXRobWljIGZsYWdzIGluc3RlYWQuIgBnLklPLktleU1hcFtuXSA+PSAtMSAmJiBnLklPLktleU1hcFtuXSA8ICgoaW50KShzaXplb2YoZy5JTy5LZXlzRG93bikgLyBzaXplb2YoKihnLklPLktleXNEb3duKSkpKSAmJiAiaW8uS2V5TWFwW10gY29udGFpbnMgYW4gb3V0IG9mIGJvdW5kIHZhbHVlIChuZWVkIHRvIGJlIDAuLjUxMiwgb3IgLTEgZm9yIHVubWFwcGVkIGtleSkiAChmbGFncyAmIEltR3VpVGFibGVDb2x1bW5GbGFnc19TdGF0dXNNYXNrXykgPT0gMCAmJiAiSWxsZWdhbCB0byBwYXNzIFN0YXR1c01hc2sgdmFsdWVzIHRvIFRhYmxlU2V0dXBDb2x1bW4oKSIASXRlbXNIZWlnaHQgPiAwLjBmICYmICJVbmFibGUgdG8gY2FsY3VsYXRlIGl0ZW0gaGVpZ2h0ISBGaXJzdCBpdGVtIGhhc24ndCBtb3ZlZCB0aGUgY3Vyc29yIHZlcnRpY2FsbHkhIgB0YWJsZS0+SXNMYXlvdXRMb2NrZWQgPT0gZmFsc2UgJiYgIk5lZWQgdG8gY2FsbCBUYWJsZVNldHVwQ29sdW1uKCkgYmVmb3JlIGZpcnN0IHJvdyEiAHRhYmxlLT5Jc0xheW91dExvY2tlZCA9PSBmYWxzZSAmJiAiTmVlZCB0byBjYWxsIGNhbGwgVGFibGVTZXR1cENvbHVtbigpIGJlZm9yZSBmaXJzdCByb3chIgBzel9pZHggPT0gc2l6ZW9mKEltRHJhd0lkeCkgJiYgIk1pc21hdGNoZWQgc3RydWN0IGxheW91dCEiAHN6X3ZlcnQgPT0gc2l6ZW9mKEltRHJhd1ZlcnQpICYmICJNaXNtYXRjaGVkIHN0cnVjdCBsYXlvdXQhIgBzel9zdHlsZSA9PSBzaXplb2YoSW1HdWlTdHlsZSkgJiYgIk1pc21hdGNoZWQgc3RydWN0IGxheW91dCEiAHN6X2lvID09IHNpemVvZihJbUd1aUlPKSAmJiAiTWlzbWF0Y2hlZCBzdHJ1Y3QgbGF5b3V0ISIAc3pfdmVjNCA9PSBzaXplb2YoSW1WZWM0KSAmJiAiTWlzbWF0Y2hlZCBzdHJ1Y3QgbGF5b3V0ISIAc3pfdmVjMiA9PSBzaXplb2YoSW1WZWMyKSAmJiAiTWlzbWF0Y2hlZCBzdHJ1Y3QgbGF5b3V0ISIAMCAmJiAiQ2FsbGVkIFB1c2hTdHlsZVZhcigpIGZsb2F0IHZhcmlhbnQgYnV0IHZhcmlhYmxlIGlzIG5vdCBhIGZsb2F0ISIAKHRhYmxlLT5EZWNsQ29sdW1uc0NvdW50IDwgdGFibGUtPkNvbHVtbnNDb3VudCkgJiYgIkNhbGxlZCBUYWJsZVNldHVwQ29sdW1uKCkgdG9vIG1hbnkgdGltZXMhIgAoZy5DdXJyZW50V2luZG93U3RhY2suU2l6ZSA+IDEpICYmICJDYWxsaW5nIEVuZCgpIHRvbyBtYW55IHRpbWVzISIASW1HdWk6OkdldEN1cnJlbnRDb250ZXh0KCkgIT0gMEwgJiYgIk1pc3NpbmcgZGVhciBpbWd1aSBjb250ZXh0LiBSZWZlciB0byBleGFtcGxlcyBhcHAhIgAoZy5Hcm91cFN0YWNrLlNpemUgPT0gMCkgJiYgIk1pc3NpbmcgRW5kR3JvdXAgY2FsbCEiAChvdXRlcl93aW5kb3ctPkRDLkl0ZW1XaWR0aFN0YWNrLlNpemUgPj0gdGFibGUtPkhvc3RCYWNrdXBJdGVtV2lkdGhTdGFja1NpemUpICYmICJUb28gbWFueSBQb3BJdGVtV2lkdGghIgBTaXplT2ZCZWdpblBvcHVwU3RhY2sgPT0gZy5CZWdpblBvcHVwU3RhY2suU2l6ZSAmJiAiQmVnaW5Qb3B1cC9FbmRQb3B1cCBvciBCZWdpbk1lbnUvRW5kTWVudSBNaXNtYXRjaCEiAFNpemVPZkZvbnRTdGFjayA+PSBnLkZvbnRTdGFjay5TaXplICYmICJQdXNoRm9udC9Qb3BGb250IE1pc21hdGNoISIAU2l6ZU9mQ29sb3JTdGFjayA+PSBnLkNvbG9yU3RhY2suU2l6ZSAmJiAiUHVzaFN0eWxlQ29sb3IvUG9wU3R5bGVDb2xvciBNaXNtYXRjaCEiAFNpemVPZlN0eWxlVmFyU3RhY2sgPj0gZy5TdHlsZVZhclN0YWNrLlNpemUgJiYgIlB1c2hTdHlsZVZhci9Qb3BTdHlsZVZhciBNaXNtYXRjaCEiAFNpemVPZkdyb3VwU3RhY2sgPT0gZy5Hcm91cFN0YWNrLlNpemUgJiYgIkJlZ2luR3JvdXAvRW5kR3JvdXAgTWlzbWF0Y2ghIgBTaXplT2ZJRFN0YWNrID09IHdpbmRvdy0+SURTdGFjay5TaXplICYmICJQdXNoSUQvUG9wSUQgb3IgVHJlZU5vZGUvVHJlZVBvcCBNaXNtYXRjaCEiAFNpemVPZkZvY3VzU2NvcGVTdGFjayA9PSBnLkZvY3VzU2NvcGVTdGFjay5TaXplICYmICJQdXNoRm9jdXNTY29wZS9Qb3BGb2N1c1Njb3BlIE1pc21hdGNoISIAZy5TdHlsZS5BbHBoYSA+PSAwLjBmICYmIGcuU3R5bGUuQWxwaGEgPD0gMS4wZiAmJiAiSW52YWxpZCBzdHlsZSBzZXR0aW5nISIAZy5TdHlsZS5DaXJjbGVTZWdtZW50TWF4RXJyb3IgPiAwLjBmICYmICJJbnZhbGlkIHN0eWxlIHNldHRpbmchIgBnLlN0eWxlLkN1cnZlVGVzc2VsbGF0aW9uVG9sID4gMC4wZiAmJiAiSW52YWxpZCBzdHlsZSBzZXR0aW5nISIAc3RyY21wKHZlcnNpb24sICIxLjgwIikgPT0gMCAmJiAiTWlzbWF0Y2hlZCB2ZXJzaW9uIHN0cmluZyEiAHRhYmxlICE9IDBMICYmICJPbmx5IGNhbGwgRW5kVGFibGUoKSBpZiBCZWdpblRhYmxlKCkgcmV0dXJucyB0cnVlISIAZy5JTy5EaXNwbGF5U2l6ZS54ID49IDAuMGYgJiYgZy5JTy5EaXNwbGF5U2l6ZS55ID49IDAuMGYgJiYgIkludmFsaWQgRGlzcGxheVNpemUgdmFsdWUhIgAoZy5JTy5EZWx0YVRpbWUgPiAwLjBmIHx8IGcuRnJhbWVDb3VudCA9PSAwKSAmJiAiTmVlZCBhIHBvc2l0aXZlIERlbHRhVGltZSEiAGNvbHVtbnNfY291bnQgPiAwICYmIGNvbHVtbnNfY291bnQgPD0gNjQgJiYgIk9ubHkgMS4uNjQgY29sdW1ucyBhbGxvd2VkISIAKGlubmVyX3dpbmRvdy0+SURTdGFjay5iYWNrKCkgPT0gdGFibGUtPklEICsgdGFibGUtPkluc3RhbmNlQ3VycmVudCkgJiYgIk1pc21hdGNoaW5nIFB1c2hJRC9Qb3BJRCEiADAgJiYgIkNhbGxlZCBQdXNoU3R5bGVWYXIoKSBJbVZlYzIgdmFyaWFudCBidXQgdmFyaWFibGUgaXMgbm90IGEgSW1WZWMyISIAKHRhYl9iYXIgIT0gMEwpICYmICJNaXNtYXRjaGVkIEJlZ2luVGFiQmFyKCkvRW5kVGFiQmFyKCkhIgAodGFiX2JhcikgJiYgIk5lZWRzIHRvIGJlIGNhbGxlZCBiZXR3ZWVuIEJlZ2luVGFiQmFyKCkgYW5kIEVuZFRhYkJhcigpISIAKHRhYl9iYXIgIT0gMEwpICYmICJOZWVkcyB0byBiZSBjYWxsZWQgYmV0d2VlbiBCZWdpblRhYkJhcigpIGFuZCBFbmRUYWJCYXIoKSEiAHRhYmxlICE9IDBMICYmICJOZWVkIHRvIGNhbGwgVGFibGVIZWFkZXJzUm93KCkgYWZ0ZXIgQmVnaW5UYWJsZSgpISIAdGFibGUgIT0gMEwgJiYgIk5lZWQgdG8gY2FsbCBUYWJsZUhlYWRlcigpIGFmdGVyIEJlZ2luVGFibGUoKSEiAHRhYmxlICE9IDBMICYmICJOZWVkIHRvIGNhbGwgVGFibGVTZXR1cENvbHVtbigpIGFmdGVyIEJlZ2luVGFibGUoKSEiAChnLldpdGhpbkVuZENoaWxkKSAmJiAiTXVzdCBjYWxsIEVuZENoaWxkKCkgYW5kIG5vdCBFbmQoKSEiAEJlbG93IHdlIGFyZSBkaXNwbGF5aW5nIHRoZSBmb250IHRleHR1cmUgKHdoaWNoIGlzIHRoZSBvbmx5IHRleHR1cmUgd2UgaGF2ZSBhY2Nlc3MgdG8gaW4gdGhpcyBkZW1vKS4gVXNlIHRoZSAnSW1UZXh0dXJlSUQnIHR5cGUgYXMgc3RvcmFnZSB0byBwYXNzIHBvaW50ZXJzIG9yIGlkZW50aWZpZXIgdG8geW91ciBvd24gdGV4dHVyZSBkYXRhLiBIb3ZlciB0aGUgdGV4dHVyZSBmb3IgYSB6b29tZWQgdmlldyEAQ2xpY2sgdG8gYnJlYWsgaW4gZGVidWdnZXIhAFByZXNzZWQgVXAhAEhlbGxvIQBQcmVzc2VkIERvd24hAEJlbG93IHdlIGFyZSB0ZXN0aW5nIGFkZGluZyBtZW51IGl0ZW1zIHRvIGEgcmVndWxhciB3aW5kb3cuIEl0J3MgcmF0aGVyIHVudXN1YWwgYnV0IHNob3VsZCB3b3JrIQBXZWxjb21lIHRvIERlYXIgSW1HdWkhAFNlZSB0aGUgU2hvd0RlbW9XaW5kb3coKSBjb2RlIGluIGltZ3VpX2RlbW8uY3BwLiA8LSB5b3UgYXJlIGhlcmUhAGRpc3BsYXkgdmVyeSBpbXBvcnRhbnQgbWVzc2FnZSBoZXJlIQBMaW5lIDEgaGVsbG8KTGluZSAyIGNsaXAgbWUhAFRoYW5rcyBmb3IgY2xpY2tpbmcgbWUhAEhlbGxvIGZyb20gU3RhY2tlZCBUaGUgU2Vjb25kIQBIZWxsbywgd29ybGQhAFdhcm5pbmc6IG93bmluZyBXaW5kb3cgaXMgaW5hY3RpdmUuIFRoaXMgRHJhd0xpc3QgaXMgbm90IGJlaW5nIHJlbmRlcmVkIQBUaGlzIGlzIHRoZSAlcyB0YWIhAENvbHVtbnMoKSBpcyBhbiBvbGQgQVBJISBQcmVmZXIgdXNpbmcgdGhlIG1vcmUgZmxleGlibGUgYW5kIHBvd2VyZnVsIEJlZ2luVGFibGUoKSBBUEkhAE1ZIENVU1RPTSBDT0xPUiBQSUNLRVIgV0lUSCBBTiBBTUFaSU5HIFBBTEVUVEUhAENoaWxkTWVudSAATm9TYXZlZFNldHRpbmdzIABQb3B1cCAAVG9vbHRpcCAATW9kYWwgAFdpZHRoIABXaWR0aFN0cmV0Y2ggAE5vUmVzaXplIABDaGlsZCAAV2lkdGhGaXhlZCAAQUxUIABTSElGVCAAU1VQRVIgAENUUkwgAExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiAAIyAAICAgICAAVE9ETzogRm9udERhdGEgJXp1ICV6dQoAJTNkOiAlcwoAVE9ETzogJXMKAC0gJXMKACMgJXMKACVpIFRoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cKAFJlZlNjYWxlPSVnCgBDb2xsYXBzZWQ9JWQKAFBvcz0lZCwlZAoAU2l6ZT0lZCwlZAoASXNXaW5kb3dGb2N1c2VkKCkgPSAlZApJc1dpbmRvd0ZvY3VzZWQoX0NoaWxkV2luZG93cykgPSAlZApJc1dpbmRvd0ZvY3VzZWQoX0NoaWxkV2luZG93c3xfUm9vdFdpbmRvdykgPSAlZApJc1dpbmRvd0ZvY3VzZWQoX1Jvb3RXaW5kb3cpID0gJWQKSXNXaW5kb3dGb2N1c2VkKF9BbnlXaW5kb3cpID0gJWQKAElzV2luZG93SG92ZXJlZCgpID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9BbGxvd1doZW5CbG9ja2VkQnlQb3B1cCkgPSAlZApJc1dpbmRvd0hvdmVyZWQoX0FsbG93V2hlbkJsb2NrZWRCeUFjdGl2ZUl0ZW0pID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9DaGlsZFdpbmRvd3MpID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9DaGlsZFdpbmRvd3N8X1Jvb3RXaW5kb3cpID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9DaGlsZFdpbmRvd3N8X0FsbG93V2hlbkJsb2NrZWRCeVBvcHVwKSA9ICVkCklzV2luZG93SG92ZXJlZChfUm9vdFdpbmRvdykgPSAlZApJc1dpbmRvd0hvdmVyZWQoX0FueVdpbmRvdykgPSAlZAoACmBgYAoAWyVzXVslc10KAFslc11bMHglMDhYLCVkXQoAJXMgJTA0ZDogcG9zICglOC4yZiwlOC4yZiksIHV2ICglLjZmLCUuNmYpLCBjb2wgJTA4WAoASW1WZWM0KiBjb2xvcnMgPSBJbUd1aTo6R2V0U3R5bGUoKS5Db2xvcnM7CgBjb2xvcnNbSW1HdWlDb2xfJXNdJSpzPSBJbVZlYzQoJS4yZmYsICUuMmZmLCAlLjJmZiwgJS4yZmYpOwoAV2hpbGUgaW5wdXRpbmcgdGV4dDoKAFBvc3NpYmxlIG1hdGNoZXM6CgBSZWZlciB0byB0aGUgIkNvbWJvIiBzZWN0aW9uIGJlbG93IGZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGUgZnVsbCBCZWdpbkNvbWJvL0VuZENvbWJvIEFQSSwgYW5kIGRlbW9uc3RyYXRpb24gb2YgdmFyaW91cyBmbGFncy4KAERpc3BsYXkgYWxsIGNoYXJhY3RlcnMgYXMgJyonLgpEaXNhYmxlIGNsaXBib2FyZCBjdXQgYW5kIGNvcHkuCkRpc2FibGUg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WC5YWFgtICBYLi4uWCAgLSAgICAgICAgIFguLi5YICAgICAgICAgLVguLi4uWCAgICAgICAgICAgLSAgICAgICAgICAgWC4uLi5YLSAgICBYLi5YICAgICAgICAgWCAgICAgICAgICAgLSAgWC5YICAtIFguLi4uLlggLSAgICAgICAgWC4uLi4uWCAgICAgICAgLVguLi5YICAgICAgICAgICAgLSAgICAgICAgICAgIFguLi5YLSAgICBYLi5YICAgICAgICAgWFggICAgICAgICAgLSAgWC5YICAtWC4uLi4uLi5YLSAgICAgICBYLi4uLi4uLlggICAgICAgLVguLlguWCAgICAgICAgICAgLSAgICAgICAgICAgWC5YLi5YLSAgICBYLi5YICAgICAgICAgWC5YICAgICAgICAgLSAgWC5YICAtWFhYWC5YWFhYLSAgICAgICBYWFhYLlhYWFggICAgICAgLVguWCBYLlggICAgICAgICAgLSAgICAgICAgICBYLlggWC5YLSAgICBYLi5YWFggICAgICAgWC4uWCAgICAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgICAgICAgICBYLlggICAgICAgICAgLVhYICAgWC5YICAgICAgICAgLSAgICAgICAgIFguWCAgIFhYLSAgICBYLi5YLi5YWFggICAgWC4uLlggICAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgICBYWCAgICBYLlggICAgWFggICAgLSAgICAgIFguWCAgICAgICAgLSAgICAgICAgWC5YICAgICAgLSAgICBYLi5YLi5YLi5YWCAgWC4uLi5YICAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgIFguWCAgICBYLlggICAgWC5YICAgLSAgICAgICBYLlggICAgICAgLSAgICAgICBYLlggICAgICAgLSAgICBYLi5YLi5YLi5YLlggWC4uLi4uWCAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgWC4uWCAgICBYLlggICAgWC4uWCAgLSAgICAgICAgWC5YICAgICAgLSAgICAgIFguWCAgICAgICAgLVhYWCBYLi5YLi5YLi5YLi5YWC4uLi4uLlggICAgLSAgWC5YICAtICAgWC5YICAgLSBYLi4uWFhYWFhYLlhYWFhYWC4uLlggLSAgICAgICAgIFguWCAgIFhYLVhYICAgWC5YICAgICAgICAgLVguLlhYLi4uLi4uLi5YLi5YWC4uLi4uLi5YICAgLSAgWC5YICAtICAgWC5YICAgLVguLi4uLi4uLi4uLi4uLi4uLi4uLi5YLSAgICAgICAgICBYLlggWC5YLVguWCBYLlggICAgICAgICAgLVguLi5YLi4uLi4uLi4uLi5YWC4uLi4uLi4uWCAgLSAgWC5YICAtICAgWC5YICAgLSBYLi4uWFhYWFhYLlhYWFhYWC4uLlggLSAgICAgICAgICAgWC5YLi5YLVguLlguWCAgICAgICAgICAgLSBYLi4uLi4uLi4uLi4uLi5YWC4uLi4uLi4uLlggLVhYWC5YWFgtICAgWC5YICAgLSAgWC4uWCAgICBYLlggICAgWC4uWCAgLSAgICAgICAgICAgIFguLi5YLVguLi5YICAgICAgICAgICAgLSAgWC4uLi4uLi4uLi4uLi5YWC4uLi4uLi4uLi5YLVguLi4uLlgtICAgWC5YICAgLSAgIFguWCAgICBYLlggICAgWC5YICAgLSAgICAgICAgICAgWC4uLi5YLVguLi4uWCAgICAgICAgICAgLSAgWC4uLi4uLi4uLi4uLi5YWC4uLi4uLlhYWFhYLVhYWFhYWFgtICAgWC5YICAgLSAgICBYWCAgICBYLlggICAgWFggICAgLSAgICAgICAgICBYLi4uLi5YLVguLi4uLlggICAgICAgICAgLSAgIFguLi4uLi4uLi4uLi5YWC4uLlguLlggICAgLS0tLS0tLS0tICAgWC5YICAgLSAgICAgICAgICBYLlggICAgICAgICAgLSAgICAgICAgICBYWFhYWFhYLVhYWFhYWFggICAgICAgICAgLSAgIFguLi4uLi4uLi4uLlggWC4uWCBYLi5YICAgLSAgICAgICAtWFhYWC5YWFhYLSAgICAgICBYWFhYLlhYWFggICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBYLi4uLi4uLi4uLlggWC5YICBYLi5YICAgLSAgICAgICAtWC4uLi4uLi5YLSAgICAgICBYLi4uLi4uLlggICAgICAgLSAgICBYWCAgICAgICAgICAgWFggICAgLSAgICAgICAgICAgLSAgICBYLi4uLi4uLi4uLlggWFggICAgWC4uWCAgLSAgICAgICAtIFguLi4uLlggLSAgICAgICAgWC4uLi4uWCAgICAgICAgLSAgIFguWCAgICAgICAgICAgWC5YICAgLSAgICAgICAgICAgLSAgICAgWC4uLi4uLi4uWCAgICAgICAgWC4uWCAgICAgICAgICAtICBYLi4uWCAgLSAgICAgICAgIFguLi5YICAgICAgICAgLSAgWC4uWCAgICAgICAgICAgWC4uWCAgLSAgICAgICAgICAgLSAgICAgWC4uLi4uLi4uWCAgICAgICAgIFhYICAgICAgICAgICAtICAgWC5YICAgLSAgICAgICAgICBYLlggICAgICAgICAgLSBYLi4uWFhYWFhYWFhYWFhYWC4uLlggLSAgICAgICAgICAgLSAgICAgWFhYWFhYWFhYWCAgLS0tLS0tLS0tLS0tICAgICAgICAtICAgIFggICAgLSAgICAgICAgICAgWCAgICAgICAgICAgLVguLi4uLi4uLi4uLi4uLi4uLi4uLi5YLSAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBYLi4uWFhYWFhYWFhYWFhYWC4uLlggLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAgWC4uWCAgICAgICAgICAgWC4uWCAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAgIFguWCAgICAgICAgICAgWC5YICAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAgICBYWCAgICAgICAgICAgWFggICAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAAAAAAAAAAAAAx4kBAMCIAQDihwEAp4cBAHOGAQA2hgEALYYBAAqGAQAYhQEA9oQBAO6EAQAAAAAAPl8BAJ9DAQBALwEAmy8BAM5kAQA+fAEAbQABACpDAQD+NgEATmgBAMRkAQB0AAEAAzoBAAAAAAAAAAAAAAAAAMeJAQDAiAEA4ocBAKeHAQBzhgEANoYBAC2GAQAKhgEAG4UBAPaEAQDxhAEAuYMBAJ2DAQDyggEAYWFhYQBiYmJiAGNjY2MAZGRkZABlZWVlAAAAAAAAAAAAAAAAAAAAADZoAQCgEAEA6wABAA46AQBTaW4AU2F3AABBdXRvL0N1cnJlbnQATm9uZQBSR0IgT25seQBIU1YgT25seQBIZXggT25seQAAQXV0by9DdXJyZW50AEh1ZSBiYXIgKyBTViByZWN0AEh1ZSB3aGVlbCArIFNWIHRyaWFuZ2xlAAAA2wwBAPw5AQCo7wEA5wMBAKMaAQA9DAEAhRoBAIuTAQAPkgEAzT4BAGZpAQDA9gEAsTcBAPYDAQAAAAAAAAAAAM5kAQA+fAEAbQABACpDAQDHiQEAwIgBAOKHAQCnhwEAAAAAP83MTD7NzEw/mpkZPwAAgD4AAAAAAAAAAAAAAAAaNQEAmAsCAHsvAQCUCwIAbD4BAAAAAAAAAAAAAAAAAI0XAQCYCwIAey8BAJQLAgAbFwEAAAAAAAAAAAAAAAAAHz8BAIZCAQAkQQEAfkIBADdFAQBTaG93IHdpZHRoAFNob3J0IFRleHQATG9uZyBUZXh0AEJ1dHRvbgBGaWxsIEJ1dHRvbgBJbnB1dFRleHQAAE5vbmUAUmVkAEdyYWRpZW50AABSb3dCZzAAUm93QmcxAABOb25lAEJsdWUAAACpEAEAJDEBAP////8BAAAAAwAAADd5AQAkMQEA/////wQAAAACAAAATCcBACQxAQD/////BgAAAAMAAABgQwEA/mQBAAAEAAD//////////2MKAQDzZAEAeOABAP//////////VwoBAPNkAQBA9QYA//////////8OSAEACmUBAHgZAwD//////////wZIAQAKZQEA+BkDAP//////////G0gBAAplAQD4GgMA//////////8AAAAAAAAAAAAAAAA+fAEAzmQBAG0AAQADOgEADRUBAHQAAQD+NgEAKkMBAE5oAQDEZAEAfwABAF4+AQDeDQEAzzEBAK4QAQAAAAAA2wwBAPw5AQBaOQEATzkBAMlmAQBa7QEAAAAAAAAAAAAAAAAA4xQBANjPAQAAIAAAZxUBAHTGAQAAQAAAzWMBALTUAQAAYAAA1TQBAH61AQAAgAAAq2MBAGiuAQDUYgEAljYBAPFoAQDrYAEAfTYBAMJoAQAAAAAAAAAAAAAAAADUeQEAzXkBAMZ5AQChNAEAmDQBAI80AQB6RwEA6WwBAMsFAQDzDAEAZEABALqCAQDQgAEAxYABAFeGAQCDbAEAXm4BAFllcwBObwBNYXliZQAAAAAINwEAtzgBAAUuAQCTcQEAhhsBAARpAQBFfAEAL10BAAo1AQDxEwEAU2luZ2xlIGNhbGwgdG8gVGV4dFVuZm9ybWF0dGVkKCkATXVsdGlwbGUgY2FsbHMgdG8gVGV4dCgpLCBjbGlwcGVkAE11bHRpcGxlIGNhbGxzIHRvIFRleHQoKSwgbm90IGNsaXBwZWQgKHNsb3cpAAAAAAAnAQEAEAEBAL2aAQBrmgEAXJoBAHVfAQCVAwIATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAGSqAgAMaQIATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAGSqAgBUaQIATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAABkqgIAnGkCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAZKoCAOhpAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAAGSqAgA0agIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAABkqgIAXGoCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXhFRQAAZKoCAIRqAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l5RUUAAGSqAgCsagIA2w9JP9sPSb/kyxZA5MsWwAAAAAAAAACA2w9JQNsPScAAAAAAAAAA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ABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAAZAAoAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkAEQoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAZAAoNGRkZAA0AAAIACQ4AAAAJAA4AAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAEwAAAAATAAAAAAkMAAAAAAAMAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAA8AAAAEDwAAAAAJEAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAARAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAABoaGgAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAABcAAAAAFwAAAAAJFAAAAAAAFAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAAAAAAAAAAAAAAVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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';
            if (!isDataURI(wasmBinaryFile)) {
                wasmBinaryFile = locateFile(wasmBinaryFile);
            }
            function getBinary(file) {
                try {
                    if (file == wasmBinaryFile && wasmBinary) {
                        return new Uint8Array(wasmBinary);
                    }
                    var binary = tryParseAsDataURI(file);
                    if (binary) {
                        return binary;
                    }
                    if (readBinary) ;
                    throw "both async and sync fetching of the wasm failed";
                } catch (err) {
                    abort(err);
                }
            }
            function getBinaryPromise(binaryFile) {
                // If we don't have the binary yet, try to load it asynchronously.
                // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
                // See https://github.com/github/fetch/pull/92#issuecomment-140665932
                // Cordova or Electron apps are typically loaded from a file:// url.
                // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
                if (!wasmBinary && ENVIRONMENT_IS_WEB) {
                    if (typeof fetch == 'function') {
                        return fetch(binaryFile, {
                            credentials: 'same-origin'
                        }).then((response)=>{
                            if (!response['ok']) {
                                throw "failed to load wasm binary file at '" + binaryFile + "'";
                            }
                            return response['arrayBuffer']();
                        }).catch(()=>getBinary(binaryFile));
                    }
                }
                // Otherwise, getBinary should be able to get it synchronously
                return Promise.resolve().then(()=>getBinary(binaryFile));
            }
            function instantiateArrayBuffer(binaryFile, imports, receiver) {
                return getBinaryPromise(binaryFile).then((binary)=>{
                    return WebAssembly.instantiate(binary, imports);
                }).then((instance)=>{
                    return instance;
                }).then(receiver, (reason)=>{
                    err('failed to asynchronously prepare wasm: ' + reason);
                    // Warn on some common problems.
                    if (isFileURI(wasmBinaryFile)) {
                        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');
                    }
                    abort(reason);
                });
            }
            function instantiateAsync(binary, binaryFile, imports, callback) {
                if (!binary && typeof WebAssembly.instantiateStreaming == 'function' && !isDataURI(binaryFile) && typeof fetch == 'function') {
                    return fetch(binaryFile, {
                        credentials: 'same-origin'
                    }).then((response)=>{
                        // Suppress closure warning here since the upstream definition for
                        // instantiateStreaming only allows Promise<Repsponse> rather than
                        // an actual Response.
                        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
                        /** @suppress {checkTypes} */ var result = WebAssembly.instantiateStreaming(response, imports);
                        return result.then(callback, function(reason) {
                            // We expect the most common failure cause to be a bad MIME type for the binary,
                            // in which case falling back to ArrayBuffer instantiation should work.
                            err('wasm streaming compile failed: ' + reason);
                            err('falling back to ArrayBuffer instantiation');
                            return instantiateArrayBuffer(binaryFile, imports, callback);
                        });
                    });
                } else {
                    return instantiateArrayBuffer(binaryFile, imports, callback);
                }
            }
            // Create the wasm instance.
            // Receives the wasm imports, returns the exports.
            function createWasm() {
                // prepare imports
                var info = {
                    'env': wasmImports,
                    'wasi_snapshot_preview1': wasmImports
                };
                // Load the wasm module and create an instance of using native support in the JS engine.
                // handle a generated wasm instance, receiving its exports and
                // performing other necessary setup
                /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {
                    var exports = instance.exports;
                    Module['asm'] = exports;
                    wasmMemory = Module['asm']['memory'];
                    assert(wasmMemory, "memory not found in wasm exports");
                    // This assertion doesn't hold when emscripten is run in --post-link
                    // mode.
                    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
                    //assert(wasmMemory.buffer.byteLength === 16777216);
                    updateMemoryViews();
                    wasmTable = Module['asm']['__indirect_function_table'];
                    assert(wasmTable, "table not found in wasm exports");
                    addOnInit(Module['asm']['__wasm_call_ctors']);
                    removeRunDependency('wasm-instantiate');
                    return exports;
                }
                // wait for the pthread pool (if any)
                addRunDependency('wasm-instantiate');
                // Prefer streaming instantiation if available.
                // Async compilation can be confusing when an error on the page overwrites Module
                // (for example, if the order of elements is wrong, and the one defining Module is
                // later), so we save Module and check it later.
                var trueModule = Module;
                function receiveInstantiationResult(result) {
                    // 'result' is a ResultObject object which has both the module and instance.
                    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
                    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
                    trueModule = null;
                    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
                    // When the regression is fixed, can restore the above PTHREADS-enabled path.
                    receiveInstance(result['instance']);
                }
                // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
                // to manually instantiate the Wasm module themselves. This allows pages to
                // run the instantiation parallel to any other async startup actions they are
                // performing.
                // Also pthreads and wasm workers initialize the wasm instance through this
                // path.
                if (Module['instantiateWasm']) {
                    try {
                        return Module['instantiateWasm'](info, receiveInstance);
                    } catch (e) {
                        err('Module.instantiateWasm callback failed with error: ' + e);
                        // If instantiation fails, reject the module ready promise.
                        readyPromiseReject(e);
                    }
                }
                // If instantiation fails, reject the module ready promise.
                instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
                return {}; // no exports yet; we'll fill them in later
            }
            // include: runtime_debug.js
            function legacyModuleProp(prop, newName) {
                if (!Object.getOwnPropertyDescriptor(Module, prop)) {
                    Object.defineProperty(Module, prop, {
                        configurable: true,
                        get: function() {
                            abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');
                        }
                    });
                }
            }
            function ignoredModuleProp(prop) {
                if (Object.getOwnPropertyDescriptor(Module, prop)) {
                    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');
                }
            }
            // forcing the filesystem exports a few things by default
            function isExportedByForceFilesystem(name) {
                return name === 'FS_createPath' || name === 'FS_createDataFile' || name === 'FS_createPreloadedFile' || name === 'FS_unlink' || name === 'addRunDependency' || // The old FS has some functionality that WasmFS lacks.
                name === 'FS_createLazyFile' || name === 'FS_createDevice' || name === 'removeRunDependency';
            }
            function missingGlobal(sym, msg) {
                if (typeof globalThis !== 'undefined') {
                    Object.defineProperty(globalThis, sym, {
                        configurable: true,
                        get: function() {
                            warnOnce('`' + sym + '` is not longer defined by emscripten. ' + msg);
                            return undefined;
                        }
                    });
                }
            }
            missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
            function missingLibrarySymbol(sym) {
                if (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
                    Object.defineProperty(globalThis, sym, {
                        configurable: true,
                        get: function() {
                            // Can't `abort()` here because it would break code that does runtime
                            // checks.  e.g. `if (typeof SDL === 'undefined')`.
                            var msg = '`' + sym + '` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line';
                            // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
                            // library.js, which means $name for a JS name with no prefix, or name
                            // for a JS name like _name.
                            var librarySymbol = sym;
                            if (!librarySymbol.startsWith('_')) {
                                librarySymbol = '$' + sym;
                            }
                            msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
                            if (isExportedByForceFilesystem(sym)) {
                                msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
                            }
                            warnOnce(msg);
                            return undefined;
                        }
                    });
                }
                // Any symbol that is not included from the JS libary is also (by definition)
                // not exported on the Module object.
                unexportedRuntimeSymbol(sym);
            }
            function unexportedRuntimeSymbol(sym) {
                if (!Object.getOwnPropertyDescriptor(Module, sym)) {
                    Object.defineProperty(Module, sym, {
                        configurable: true,
                        get: function() {
                            var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
                            if (isExportedByForceFilesystem(sym)) {
                                msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
                            }
                            abort(msg);
                        }
                    });
                }
            }
            function callRuntimeCallbacks(callbacks) {
                while(callbacks.length > 0){
                    // Pass the module as the first argument.
                    callbacks.shift()(Module);
                }
            }
            function ptrToString(ptr) {
                assert(typeof ptr === 'number');
                return '0x' + ptr.toString(16).padStart(8, '0');
            }
            function warnOnce(text) {
                if (!warnOnce.shown) warnOnce.shown = {};
                if (!warnOnce.shown[text]) {
                    warnOnce.shown[text] = 1;
                    err(text);
                }
            }
            var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;
            /**
	     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
	     * array that contains uint8 values, returns a copy of that string as a
	     * Javascript String object.
	     * heapOrArray is either a regular array, or a JavaScript typed array view.
	     * @param {number} idx
	     * @param {number=} maxBytesToRead
	     * @return {string}
	     */ function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
                var endIdx = idx + maxBytesToRead;
                var endPtr = idx;
                // TextDecoder needs to know the byte length in advance, it doesn't stop on
                // null terminator by itself.  Also, use the length info to avoid running tiny
                // strings through TextDecoder, since .subarray() allocates garbage.
                // (As a tiny code save trick, compare endPtr against endIdx using a negation,
                // so that undefined means Infinity)
                while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;
                if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
                    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
                }
                var str = '';
                // If building with TextDecoder, we have already computed the string length
                // above, so test loop end condition against that
                while(idx < endPtr){
                    // For UTF8 byte structure, see:
                    // http://en.wikipedia.org/wiki/UTF-8#Description
                    // https://www.ietf.org/rfc/rfc2279.txt
                    // https://tools.ietf.org/html/rfc3629
                    var u0 = heapOrArray[idx++];
                    if (!(u0 & 0x80)) {
                        str += String.fromCharCode(u0);
                        continue;
                    }
                    var u1 = heapOrArray[idx++] & 63;
                    if ((u0 & 0xE0) == 0xC0) {
                        str += String.fromCharCode((u0 & 31) << 6 | u1);
                        continue;
                    }
                    var u2 = heapOrArray[idx++] & 63;
                    if ((u0 & 0xF0) == 0xE0) {
                        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                    } else {
                        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
                        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
                    }
                    if (u0 < 0x10000) {
                        str += String.fromCharCode(u0);
                    } else {
                        var ch = u0 - 0x10000;
                        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
                    }
                }
                return str;
            }
            /**
	     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
	     * emscripten HEAP, returns a copy of that string as a Javascript String object.
	     *
	     * @param {number} ptr
	     * @param {number=} maxBytesToRead - An optional length that specifies the
	     *   maximum number of bytes to read. You can omit this parameter to scan the
	     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
	     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
	     *   string will cut short at that byte index (i.e. maxBytesToRead will not
	     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
	     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
	     *   JS JIT optimizations off, so it is worth to consider consistently using one
	     * @return {string}
	     */ function UTF8ToString(ptr, maxBytesToRead) {
                assert(typeof ptr == 'number');
                return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
            }
            function ___assert_fail(condition, filename, line, func) {
                abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [
                    filename ? UTF8ToString(filename) : 'unknown filename',
                    line,
                    func ? UTF8ToString(func) : 'unknown function'
                ]);
            }
            /** @constructor */ function ExceptionInfo(excPtr) {
                this.excPtr = excPtr;
                this.ptr = excPtr - 24;
                this.set_type = function(type) {
                    HEAPU32[this.ptr + 4 >> 2] = type;
                };
                this.get_type = function() {
                    return HEAPU32[this.ptr + 4 >> 2];
                };
                this.set_destructor = function(destructor) {
                    HEAPU32[this.ptr + 8 >> 2] = destructor;
                };
                this.get_destructor = function() {
                    return HEAPU32[this.ptr + 8 >> 2];
                };
                this.set_caught = function(caught) {
                    caught = caught ? 1 : 0;
                    HEAP8[this.ptr + 12 >> 0] = caught;
                };
                this.get_caught = function() {
                    return HEAP8[this.ptr + 12 >> 0] != 0;
                };
                this.set_rethrown = function(rethrown) {
                    rethrown = rethrown ? 1 : 0;
                    HEAP8[this.ptr + 13 >> 0] = rethrown;
                };
                this.get_rethrown = function() {
                    return HEAP8[this.ptr + 13 >> 0] != 0;
                };
                // Initialize native structure fields. Should be called once after allocated.
                this.init = function(type, destructor) {
                    this.set_adjusted_ptr(0);
                    this.set_type(type);
                    this.set_destructor(destructor);
                };
                this.set_adjusted_ptr = function(adjustedPtr) {
                    HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
                };
                this.get_adjusted_ptr = function() {
                    return HEAPU32[this.ptr + 16 >> 2];
                };
                // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted
                // when the pointer is casted to some of the exception object base classes (e.g. when virtual
                // inheritance is used). When a pointer is thrown this method should return the thrown pointer
                // itself.
                this.get_exception_ptr = function() {
                    // Work around a fastcomp bug, this code is still included for some reason in a build without
                    // exceptions support.
                    var isPointer = ___cxa_is_pointer_type(this.get_type());
                    if (isPointer) {
                        return HEAPU32[this.excPtr >> 2];
                    }
                    var adjusted = this.get_adjusted_ptr();
                    if (adjusted !== 0) return adjusted;
                    return this.excPtr;
                };
            }
            function ___cxa_throw(ptr, type, destructor) {
                var info = new ExceptionInfo(ptr);
                // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.
                info.init(type, destructor);
                assert(false, 'Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.');
            }
            function ___syscall_fcntl64(fd, cmd, varargs) {
                return 0;
            }
            function ___syscall_ioctl(fd, op, varargs) {
                return 0;
            }
            function ___syscall_openat(dirfd, path, flags, varargs) {
                abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');
            }
            function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}
            function getShiftFromSize(size) {
                switch(size){
                    case 1:
                        return 0;
                    case 2:
                        return 1;
                    case 4:
                        return 2;
                    case 8:
                        return 3;
                    default:
                        throw new TypeError(`Unknown type size: ${size}`);
                }
            }
            function embind_init_charCodes() {
                var codes = new Array(256);
                for(var i = 0; i < 256; ++i){
                    codes[i] = String.fromCharCode(i);
                }
                embind_charCodes = codes;
            }
            var embind_charCodes = undefined;
            function readLatin1String(ptr) {
                var ret = "";
                var c = ptr;
                while(HEAPU8[c]){
                    ret += embind_charCodes[HEAPU8[c++]];
                }
                return ret;
            }
            var awaitingDependencies = {};
            var registeredTypes = {};
            var typeDependencies = {};
            var char_0 = 48;
            var char_9 = 57;
            function makeLegalFunctionName(name) {
                if (undefined === name) {
                    return '_unknown';
                }
                name = name.replace(/[^a-zA-Z0-9_]/g, '$');
                var f = name.charCodeAt(0);
                if (f >= char_0 && f <= char_9) {
                    return `_${name}`;
                }
                return name;
            }
            function createNamedFunction(name, body) {
                name = makeLegalFunctionName(name);
                // Use an abject with a computed property name to create a new function with
                // a name specified at runtime, but without using `new Function` or `eval`.
                return ({
                    [name]: function() {
                        return body.apply(this, arguments);
                    }
                })[name];
            }
            function extendError(baseErrorType, errorName) {
                var errorClass = createNamedFunction(errorName, function(message) {
                    this.name = errorName;
                    this.message = message;
                    var stack = new Error(message).stack;
                    if (stack !== undefined) {
                        this.stack = this.toString() + '\n' + stack.replace(/^Error(:[^\n]*)?\n/, '');
                    }
                });
                errorClass.prototype = Object.create(baseErrorType.prototype);
                errorClass.prototype.constructor = errorClass;
                errorClass.prototype.toString = function() {
                    if (this.message === undefined) {
                        return this.name;
                    } else {
                        return `${this.name}: ${this.message}`;
                    }
                };
                return errorClass;
            }
            var BindingError = undefined;
            function throwBindingError(message) {
                throw new BindingError(message);
            }
            var InternalError = undefined;
            function throwInternalError(message) {
                throw new InternalError(message);
            }
            function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
                myTypes.forEach(function(type) {
                    typeDependencies[type] = dependentTypes;
                });
                function onComplete(typeConverters) {
                    var myTypeConverters = getTypeConverters(typeConverters);
                    if (myTypeConverters.length !== myTypes.length) {
                        throwInternalError('Mismatched type converter count');
                    }
                    for(var i = 0; i < myTypes.length; ++i){
                        registerType(myTypes[i], myTypeConverters[i]);
                    }
                }
                var typeConverters = new Array(dependentTypes.length);
                var unregisteredTypes = [];
                var registered = 0;
                dependentTypes.forEach((dt, i)=>{
                    if (registeredTypes.hasOwnProperty(dt)) {
                        typeConverters[i] = registeredTypes[dt];
                    } else {
                        unregisteredTypes.push(dt);
                        if (!awaitingDependencies.hasOwnProperty(dt)) {
                            awaitingDependencies[dt] = [];
                        }
                        awaitingDependencies[dt].push(()=>{
                            typeConverters[i] = registeredTypes[dt];
                            ++registered;
                            if (registered === unregisteredTypes.length) {
                                onComplete(typeConverters);
                            }
                        });
                    }
                });
                if (0 === unregisteredTypes.length) {
                    onComplete(typeConverters);
                }
            }
            /** @param {Object=} options */ function registerType(rawType, registeredInstance, options = {}) {
                if (!('argPackAdvance' in registeredInstance)) {
                    throw new TypeError('registerType registeredInstance requires argPackAdvance');
                }
                var name = registeredInstance.name;
                if (!rawType) {
                    throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
                }
                if (registeredTypes.hasOwnProperty(rawType)) {
                    if (options.ignoreDuplicateRegistrations) {
                        return;
                    } else {
                        throwBindingError(`Cannot register type '${name}' twice`);
                    }
                }
                registeredTypes[rawType] = registeredInstance;
                delete typeDependencies[rawType];
                if (awaitingDependencies.hasOwnProperty(rawType)) {
                    var callbacks = awaitingDependencies[rawType];
                    delete awaitingDependencies[rawType];
                    callbacks.forEach((cb)=>cb());
                }
            }
            function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
                var shift = getShiftFromSize(size);
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(wt) {
                        // ambiguous emscripten ABI: sometimes return values are
                        // true or false, and sometimes integers (0 or 1)
                        return !!wt;
                    },
                    'toWireType': function(destructors, o) {
                        return o ? trueValue : falseValue;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': function(pointer) {
                        // TODO: if heap is fixed (like in asm.js) this could be executed outside
                        var heap;
                        if (size === 1) {
                            heap = HEAP8;
                        } else if (size === 2) {
                            heap = HEAP16;
                        } else if (size === 4) {
                            heap = HEAP32;
                        } else {
                            throw new TypeError("Unknown boolean type size: " + name);
                        }
                        return this['fromWireType'](heap[pointer >> shift]);
                    },
                    destructorFunction: null
                });
            }
            function ClassHandle_isAliasOf(other) {
                if (!(this instanceof ClassHandle)) {
                    return false;
                }
                if (!(other instanceof ClassHandle)) {
                    return false;
                }
                var leftClass = this.$$.ptrType.registeredClass;
                var left = this.$$.ptr;
                var rightClass = other.$$.ptrType.registeredClass;
                var right = other.$$.ptr;
                while(leftClass.baseClass){
                    left = leftClass.upcast(left);
                    leftClass = leftClass.baseClass;
                }
                while(rightClass.baseClass){
                    right = rightClass.upcast(right);
                    rightClass = rightClass.baseClass;
                }
                return leftClass === rightClass && left === right;
            }
            function shallowCopyInternalPointer(o) {
                return {
                    count: o.count,
                    deleteScheduled: o.deleteScheduled,
                    preservePointerOnDelete: o.preservePointerOnDelete,
                    ptr: o.ptr,
                    ptrType: o.ptrType,
                    smartPtr: o.smartPtr,
                    smartPtrType: o.smartPtrType
                };
            }
            function throwInstanceAlreadyDeleted(obj) {
                function getInstanceTypeName(handle) {
                    return handle.$$.ptrType.registeredClass.name;
                }
                throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
            }
            var finalizationRegistry = false;
            function detachFinalizer(handle) {}
            function runDestructor($$) {
                if ($$.smartPtr) {
                    $$.smartPtrType.rawDestructor($$.smartPtr);
                } else {
                    $$.ptrType.registeredClass.rawDestructor($$.ptr);
                }
            }
            function releaseClassHandle($$) {
                $$.count.value -= 1;
                var toDelete = 0 === $$.count.value;
                if (toDelete) {
                    runDestructor($$);
                }
            }
            function downcastPointer(ptr, ptrClass, desiredClass) {
                if (ptrClass === desiredClass) {
                    return ptr;
                }
                if (undefined === desiredClass.baseClass) {
                    return null; // no conversion
                }
                var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
                if (rv === null) {
                    return null;
                }
                return desiredClass.downcast(rv);
            }
            var registeredPointers = {};
            function getInheritedInstanceCount() {
                return Object.keys(registeredInstances).length;
            }
            function getLiveInheritedInstances() {
                var rv = [];
                for(var k in registeredInstances){
                    if (registeredInstances.hasOwnProperty(k)) {
                        rv.push(registeredInstances[k]);
                    }
                }
                return rv;
            }
            var deletionQueue = [];
            function flushPendingDeletes() {
                while(deletionQueue.length){
                    var obj = deletionQueue.pop();
                    obj.$$.deleteScheduled = false;
                    obj['delete']();
                }
            }
            var delayFunction = undefined;
            function setDelayFunction(fn) {
                delayFunction = fn;
                if (deletionQueue.length && delayFunction) {
                    delayFunction(flushPendingDeletes);
                }
            }
            function init_embind() {
                Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
                Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
                Module['flushPendingDeletes'] = flushPendingDeletes;
                Module['setDelayFunction'] = setDelayFunction;
            }
            var registeredInstances = {};
            function getBasestPointer(class_, ptr) {
                if (ptr === undefined) {
                    throwBindingError('ptr should not be undefined');
                }
                while(class_.baseClass){
                    ptr = class_.upcast(ptr);
                    class_ = class_.baseClass;
                }
                return ptr;
            }
            function getInheritedInstance(class_, ptr) {
                ptr = getBasestPointer(class_, ptr);
                return registeredInstances[ptr];
            }
            function makeClassHandle(prototype, record) {
                if (!record.ptrType || !record.ptr) {
                    throwInternalError('makeClassHandle requires ptr and ptrType');
                }
                var hasSmartPtrType = !!record.smartPtrType;
                var hasSmartPtr = !!record.smartPtr;
                if (hasSmartPtrType !== hasSmartPtr) {
                    throwInternalError('Both smartPtrType and smartPtr must be specified');
                }
                record.count = {
                    value: 1
                };
                return attachFinalizer(Object.create(prototype, {
                    $$: {
                        value: record
                    }
                }));
            }
            function RegisteredPointer_fromWireType(ptr) {
                // ptr is a raw pointer (or a raw smartpointer)
                // rawPointer is a maybe-null raw pointer
                var rawPointer = this.getPointee(ptr);
                if (!rawPointer) {
                    this.destructor(ptr);
                    return null;
                }
                var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
                if (undefined !== registeredInstance) {
                    // JS object has been neutered, time to repopulate it
                    if (0 === registeredInstance.$$.count.value) {
                        registeredInstance.$$.ptr = rawPointer;
                        registeredInstance.$$.smartPtr = ptr;
                        return registeredInstance['clone']();
                    } else {
                        // else, just increment reference count on existing object
                        // it already has a reference to the smart pointer
                        var rv = registeredInstance['clone']();
                        this.destructor(ptr);
                        return rv;
                    }
                }
                function makeDefaultHandle() {
                    if (this.isSmartPointer) {
                        return makeClassHandle(this.registeredClass.instancePrototype, {
                            ptrType: this.pointeeType,
                            ptr: rawPointer,
                            smartPtrType: this,
                            smartPtr: ptr
                        });
                    } else {
                        return makeClassHandle(this.registeredClass.instancePrototype, {
                            ptrType: this,
                            ptr: ptr
                        });
                    }
                }
                var actualType = this.registeredClass.getActualType(rawPointer);
                var registeredPointerRecord = registeredPointers[actualType];
                if (!registeredPointerRecord) {
                    return makeDefaultHandle.call(this);
                }
                var toType;
                if (this.isConst) {
                    toType = registeredPointerRecord.constPointerType;
                } else {
                    toType = registeredPointerRecord.pointerType;
                }
                var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
                if (dp === null) {
                    return makeDefaultHandle.call(this);
                }
                if (this.isSmartPointer) {
                    return makeClassHandle(toType.registeredClass.instancePrototype, {
                        ptrType: toType,
                        ptr: dp,
                        smartPtrType: this,
                        smartPtr: ptr
                    });
                } else {
                    return makeClassHandle(toType.registeredClass.instancePrototype, {
                        ptrType: toType,
                        ptr: dp
                    });
                }
            }
            function attachFinalizer(handle) {
                if ('undefined' === typeof FinalizationRegistry) {
                    attachFinalizer = (handle)=>handle;
                    return handle;
                }
                // If the running environment has a FinalizationRegistry (see
                // https://github.com/tc39/proposal-weakrefs), then attach finalizers
                // for class handles.  We check for the presence of FinalizationRegistry
                // at run-time, not build-time.
                finalizationRegistry = new FinalizationRegistry((info)=>{
                    console.warn(info.leakWarning.stack.replace(/^Error: /, ''));
                    releaseClassHandle(info.$$);
                });
                attachFinalizer = (handle)=>{
                    var $$ = handle.$$;
                    var hasSmartPtr = !!$$.smartPtr;
                    if (hasSmartPtr) {
                        // We should not call the destructor on raw pointers in case other code expects the pointee to live
                        var info = {
                            $$: $$
                        };
                        // Create a warning as an Error instance in advance so that we can store
                        // the current stacktrace and point to it when / if a leak is detected.
                        // This is more useful than the empty stacktrace of `FinalizationRegistry`
                        // callback.
                        var cls = $$.ptrType.registeredClass;
                        info.leakWarning = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.\n` + "We'll free it automatically in this case, but this functionality is not reliable across various environments.\n" + "Make sure to invoke .delete() manually once you're done with the instance instead.\n" + "Originally allocated"); // `.stack` will add "at ..." after this sentence
                        if ('captureStackTrace' in Error) {
                            Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);
                        }
                        finalizationRegistry.register(handle, info, handle);
                    }
                    return handle;
                };
                detachFinalizer = (handle)=>finalizationRegistry.unregister(handle);
                return attachFinalizer(handle);
            }
            function ClassHandle_clone() {
                if (!this.$$.ptr) {
                    throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.preservePointerOnDelete) {
                    this.$$.count.value += 1;
                    return this;
                } else {
                    var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                        $$: {
                            value: shallowCopyInternalPointer(this.$$)
                        }
                    }));
                    clone.$$.count.value += 1;
                    clone.$$.deleteScheduled = false;
                    return clone;
                }
            }
            function ClassHandle_delete() {
                if (!this.$$.ptr) {
                    throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                    throwBindingError('Object already scheduled for deletion');
                }
                detachFinalizer(this);
                releaseClassHandle(this.$$);
                if (!this.$$.preservePointerOnDelete) {
                    this.$$.smartPtr = undefined;
                    this.$$.ptr = undefined;
                }
            }
            function ClassHandle_isDeleted() {
                return !this.$$.ptr;
            }
            function ClassHandle_deleteLater() {
                if (!this.$$.ptr) {
                    throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                    throwBindingError('Object already scheduled for deletion');
                }
                deletionQueue.push(this);
                if (deletionQueue.length === 1 && delayFunction) {
                    delayFunction(flushPendingDeletes);
                }
                this.$$.deleteScheduled = true;
                return this;
            }
            function init_ClassHandle() {
                ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
                ClassHandle.prototype['clone'] = ClassHandle_clone;
                ClassHandle.prototype['delete'] = ClassHandle_delete;
                ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
                ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
            }
            function ClassHandle() {}
            function ensureOverloadTable(proto, methodName, humanName) {
                if (undefined === proto[methodName].overloadTable) {
                    var prevFunc = proto[methodName];
                    // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
                    proto[methodName] = function() {
                        // TODO This check can be removed in -O3 level "unsafe" optimizations.
                        if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
                        }
                        return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
                    };
                    // Move the previous function into the overload table.
                    proto[methodName].overloadTable = [];
                    proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
                }
            }
            /** @param {number=} numArguments */ function exposePublicSymbol(name, value, numArguments) {
                if (Module.hasOwnProperty(name)) {
                    if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
                        throwBindingError(`Cannot register public name '${name}' twice`);
                    }
                    // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
                    // that routes between the two.
                    ensureOverloadTable(Module, name, name);
                    if (Module.hasOwnProperty(numArguments)) {
                        throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
                    }
                    // Add the new function into the overload table.
                    Module[name].overloadTable[numArguments] = value;
                } else {
                    Module[name] = value;
                    if (undefined !== numArguments) {
                        Module[name].numArguments = numArguments;
                    }
                }
            }
            /** @constructor */ function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
                this.name = name;
                this.constructor = constructor;
                this.instancePrototype = instancePrototype;
                this.rawDestructor = rawDestructor;
                this.baseClass = baseClass;
                this.getActualType = getActualType;
                this.upcast = upcast;
                this.downcast = downcast;
                this.pureVirtualFunctions = [];
            }
            function upcastPointer(ptr, ptrClass, desiredClass) {
                while(ptrClass !== desiredClass){
                    if (!ptrClass.upcast) {
                        throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
                    }
                    ptr = ptrClass.upcast(ptr);
                    ptrClass = ptrClass.baseClass;
                }
                return ptr;
            }
            function constNoSmartPtrRawPointerToWireType(destructors, handle) {
                if (handle === null) {
                    if (this.isReference) {
                        throwBindingError(`null is not a valid ${this.name}`);
                    }
                    return 0;
                }
                if (!handle.$$) {
                    throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
                }
                if (!handle.$$.ptr) {
                    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
                }
                var handleClass = handle.$$.ptrType.registeredClass;
                var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
                return ptr;
            }
            function genericPointerToWireType(destructors, handle) {
                var ptr;
                if (handle === null) {
                    if (this.isReference) {
                        throwBindingError(`null is not a valid ${this.name}`);
                    }
                    if (this.isSmartPointer) {
                        ptr = this.rawConstructor();
                        if (destructors !== null) {
                            destructors.push(this.rawDestructor, ptr);
                        }
                        return ptr;
                    } else {
                        return 0;
                    }
                }
                if (!handle.$$) {
                    throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
                }
                if (!handle.$$.ptr) {
                    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
                }
                if (!this.isConst && handle.$$.ptrType.isConst) {
                    throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
                }
                var handleClass = handle.$$.ptrType.registeredClass;
                ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
                if (this.isSmartPointer) {
                    // TODO: this is not strictly true
                    // We could support BY_EMVAL conversions from raw pointers to smart pointers
                    // because the smart pointer can hold a reference to the handle
                    if (undefined === handle.$$.smartPtr) {
                        throwBindingError('Passing raw pointer to smart pointer is illegal');
                    }
                    switch(this.sharingPolicy){
                        case 0:
                            // no upcasting
                            if (handle.$$.smartPtrType === this) {
                                ptr = handle.$$.smartPtr;
                            } else {
                                throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
                            }
                            break;
                        case 1:
                            ptr = handle.$$.smartPtr;
                            break;
                        case 2:
                            if (handle.$$.smartPtrType === this) {
                                ptr = handle.$$.smartPtr;
                            } else {
                                var clonedHandle = handle['clone']();
                                ptr = this.rawShare(ptr, Emval.toHandle(function() {
                                    clonedHandle['delete']();
                                }));
                                if (destructors !== null) {
                                    destructors.push(this.rawDestructor, ptr);
                                }
                            }
                            break;
                        default:
                            throwBindingError('Unsupporting sharing policy');
                    }
                }
                return ptr;
            }
            function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
                if (handle === null) {
                    if (this.isReference) {
                        throwBindingError(`null is not a valid ${this.name}`);
                    }
                    return 0;
                }
                if (!handle.$$) {
                    throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
                }
                if (!handle.$$.ptr) {
                    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
                }
                if (handle.$$.ptrType.isConst) {
                    throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
                }
                var handleClass = handle.$$.ptrType.registeredClass;
                var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
                return ptr;
            }
            function simpleReadValueFromPointer(pointer) {
                return this['fromWireType'](HEAP32[pointer >> 2]);
            }
            function RegisteredPointer_getPointee(ptr) {
                if (this.rawGetPointee) {
                    ptr = this.rawGetPointee(ptr);
                }
                return ptr;
            }
            function RegisteredPointer_destructor(ptr) {
                if (this.rawDestructor) {
                    this.rawDestructor(ptr);
                }
            }
            function RegisteredPointer_deleteObject(handle) {
                if (handle !== null) {
                    handle['delete']();
                }
            }
            function init_RegisteredPointer() {
                RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
                RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
                RegisteredPointer.prototype['argPackAdvance'] = 8;
                RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
                RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
                RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
            }
            /** @constructor
	      @param {*=} pointeeType,
	      @param {*=} sharingPolicy,
	      @param {*=} rawGetPointee,
	      @param {*=} rawConstructor,
	      @param {*=} rawShare,
	      @param {*=} rawDestructor,
	       */ function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
                this.name = name;
                this.registeredClass = registeredClass;
                this.isReference = isReference;
                this.isConst = isConst;
                // smart pointer properties
                this.isSmartPointer = isSmartPointer;
                this.pointeeType = pointeeType;
                this.sharingPolicy = sharingPolicy;
                this.rawGetPointee = rawGetPointee;
                this.rawConstructor = rawConstructor;
                this.rawShare = rawShare;
                this.rawDestructor = rawDestructor;
                if (!isSmartPointer && registeredClass.baseClass === undefined) {
                    if (isConst) {
                        this['toWireType'] = constNoSmartPtrRawPointerToWireType;
                        this.destructorFunction = null;
                    } else {
                        this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
                        this.destructorFunction = null;
                    }
                } else {
                    this['toWireType'] = genericPointerToWireType;
                // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
                // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
                // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
                //       craftInvokerFunction altogether.
                }
            }
            /** @param {number=} numArguments */ function replacePublicSymbol(name, value, numArguments) {
                if (!Module.hasOwnProperty(name)) {
                    throwInternalError('Replacing nonexistant public symbol');
                }
                // If there's an overload table for this symbol, replace the symbol in the overload table instead.
                if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
                    Module[name].overloadTable[numArguments] = value;
                } else {
                    Module[name] = value;
                    Module[name].argCount = numArguments;
                }
            }
            function dynCallLegacy(sig, ptr, args) {
                assert('dynCall_' + sig in Module, `bad function pointer type - dynCall function not found for sig '${sig}'`);
                if (args && args.length) {
                    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
                    assert(args.length === sig.substring(1).replace(/j/g, '--').length);
                } else {
                    assert(sig.length == 1);
                }
                var f = Module['dynCall_' + sig];
                return args && args.length ? f.apply(null, [
                    ptr
                ].concat(args)) : f.call(null, ptr);
            }
            var wasmTableMirror = [];
            function getWasmTableEntry(funcPtr) {
                var func = wasmTableMirror[funcPtr];
                if (!func) {
                    if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
                    wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
                }
                assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
                return func;
            }
            /** @param {Object=} args */ function dynCall(sig, ptr, args) {
                // Without WASM_BIGINT support we cannot directly call function with i64 as
                // part of thier signature, so we rely the dynCall functions generated by
                // wasm-emscripten-finalize
                if (sig.includes('j')) {
                    return dynCallLegacy(sig, ptr, args);
                }
                assert(getWasmTableEntry(ptr), `missing table entry in dynCall: ${ptr}`);
                var rtn = getWasmTableEntry(ptr).apply(null, args);
                return rtn;
            }
            function getDynCaller(sig, ptr) {
                assert(sig.includes('j') || sig.includes('p'), 'getDynCaller should only be called with i64 sigs');
                var argCache = [];
                return function() {
                    argCache.length = 0;
                    Object.assign(argCache, arguments);
                    return dynCall(sig, ptr, argCache);
                };
            }
            function embind__requireFunction(signature, rawFunction) {
                signature = readLatin1String(signature);
                function makeDynCaller() {
                    if (signature.includes('j')) {
                        return getDynCaller(signature, rawFunction);
                    }
                    return getWasmTableEntry(rawFunction);
                }
                var fp = makeDynCaller();
                if (typeof fp != "function") {
                    throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
                }
                return fp;
            }
            var UnboundTypeError = undefined;
            function getTypeName(type) {
                var ptr = ___getTypeName(type);
                var rv = readLatin1String(ptr);
                _free(ptr);
                return rv;
            }
            function throwUnboundTypeError(message, types) {
                var unboundTypes = [];
                var seen = {};
                function visit(type) {
                    if (seen[type]) {
                        return;
                    }
                    if (registeredTypes[type]) {
                        return;
                    }
                    if (typeDependencies[type]) {
                        typeDependencies[type].forEach(visit);
                        return;
                    }
                    unboundTypes.push(type);
                    seen[type] = true;
                }
                types.forEach(visit);
                throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([
                    ', '
                ]));
            }
            function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
                name = readLatin1String(name);
                getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
                if (upcast) {
                    upcast = embind__requireFunction(upcastSignature, upcast);
                }
                if (downcast) {
                    downcast = embind__requireFunction(downcastSignature, downcast);
                }
                rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
                var legalFunctionName = makeLegalFunctionName(name);
                exposePublicSymbol(legalFunctionName, function() {
                    // this code cannot run if baseClassRawType is zero
                    throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [
                        baseClassRawType
                    ]);
                });
                whenDependentTypesAreResolved([
                    rawType,
                    rawPointerType,
                    rawConstPointerType
                ], baseClassRawType ? [
                    baseClassRawType
                ] : [], function(base) {
                    base = base[0];
                    var baseClass;
                    var basePrototype;
                    if (baseClassRawType) {
                        baseClass = base.registeredClass;
                        basePrototype = baseClass.instancePrototype;
                    } else {
                        basePrototype = ClassHandle.prototype;
                    }
                    var constructor = createNamedFunction(legalFunctionName, function() {
                        if (Object.getPrototypeOf(this) !== instancePrototype) {
                            throw new BindingError("Use 'new' to construct " + name);
                        }
                        if (undefined === registeredClass.constructor_body) {
                            throw new BindingError(name + " has no accessible constructor");
                        }
                        var body = registeredClass.constructor_body[arguments.length];
                        if (undefined === body) {
                            throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
                        }
                        return body.apply(this, arguments);
                    });
                    var instancePrototype = Object.create(basePrototype, {
                        constructor: {
                            value: constructor
                        }
                    });
                    constructor.prototype = instancePrototype;
                    var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
                    if (registeredClass.baseClass) {
                        // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.
                        if (registeredClass.baseClass.__derivedClasses === undefined) {
                            registeredClass.baseClass.__derivedClasses = [];
                        }
                        registeredClass.baseClass.__derivedClasses.push(registeredClass);
                    }
                    var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
                    var pointerConverter = new RegisteredPointer(name + '*', registeredClass, false, false, false);
                    var constPointerConverter = new RegisteredPointer(name + ' const*', registeredClass, false, true, false);
                    registeredPointers[rawType] = {
                        pointerType: pointerConverter,
                        constPointerType: constPointerConverter
                    };
                    replacePublicSymbol(legalFunctionName, constructor);
                    return [
                        referenceConverter,
                        pointerConverter,
                        constPointerConverter
                    ];
                });
            }
            function heap32VectorToArray(count, firstElement) {
                var array = [];
                for(var i = 0; i < count; i++){
                    // TODO(https://github.com/emscripten-core/emscripten/issues/17310):
                    // Find a way to hoist the `>> 2` or `>> 3` out of this loop.
                    array.push(HEAPU32[firstElement + i * 4 >> 2]);
                }
                return array;
            }
            function runDestructors(destructors) {
                while(destructors.length){
                    var ptr = destructors.pop();
                    var del = destructors.pop();
                    del(ptr);
                }
            }
            function newFunc(constructor, argumentList) {
                if (!(constructor instanceof Function)) {
                    throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
                }
                /*
	       * Previously, the following line was just:
	       *   function dummy() {};
	       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even
	       * though at creation, the 'dummy' has the correct constructor name.  Thus,
	       * objects created with IMVU.new would show up in the debugger as 'dummy',
	       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the
	       * issue.  Doublely-unfortunately, there's no way to write a test for this
	       * behavior.  -NRD 2013.02.22
	       */ var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function() {});
                dummy.prototype = constructor.prototype;
                var obj = new dummy;
                var r = constructor.apply(obj, argumentList);
                return r instanceof Object ? r : obj;
            }
            function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {
                // humanName: a human-readable string name for the function to be generated.
                // argTypes: An array that contains the embind type objects for all types in the function signature.
                //    argTypes[0] is the type object for the function return value.
                //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
                //    argTypes[2...] are the actual function parameters.
                // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
                // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
                // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
                // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.
                var argCount = argTypes.length;
                if (argCount < 2) {
                    throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
                }
                assert(!isAsync, 'Async bindings are only supported with JSPI.');
                var isClassMethodFunc = argTypes[1] !== null && classType !== null;
                // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
                // TODO: This omits argument count check - enable only at -O3 or similar.
                //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
                //       return FUNCTION_TABLE[fn];
                //    }
                // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
                // TODO: Remove this completely once all function invokers are being dynamically generated.
                var needsDestructorStack = false;
                for(var i = 1; i < argTypes.length; ++i){
                    if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
                        needsDestructorStack = true;
                        break;
                    }
                }
                var returns = argTypes[0].name !== "void";
                var argsList = "";
                var argsListWired = "";
                for(var i = 0; i < argCount - 2; ++i){
                    argsList += (i !== 0 ? ", " : "") + "arg" + i;
                    argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
                }
                var invokerFnBody = `
        return function ${makeLegalFunctionName(humanName)}(${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ${arguments.length} arguments, expected ${argCount - 2} args!');
        }`;
                if (needsDestructorStack) {
                    invokerFnBody += "var destructors = [];\n";
                }
                var dtorStack = needsDestructorStack ? "destructors" : "null";
                var args1 = [
                    "throwBindingError",
                    "invoker",
                    "fn",
                    "runDestructors",
                    "retType",
                    "classParam"
                ];
                var args2 = [
                    throwBindingError,
                    cppInvokerFunc,
                    cppTargetFunc,
                    runDestructors,
                    argTypes[0],
                    argTypes[1]
                ];
                if (isClassMethodFunc) {
                    invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
                }
                for(var i = 0; i < argCount - 2; ++i){
                    invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
                    args1.push("argType" + i);
                    args2.push(argTypes[i + 2]);
                }
                if (isClassMethodFunc) {
                    argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
                }
                invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
                if (needsDestructorStack) {
                    invokerFnBody += "runDestructors(destructors);\n";
                } else {
                    for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){
                        var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                        if (argTypes[i].destructorFunction !== null) {
                            invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                            args1.push(paramName + "_dtor");
                            args2.push(argTypes[i].destructorFunction);
                        }
                    }
                }
                if (returns) {
                    invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
                }
                invokerFnBody += "}\n";
                args1.push(invokerFnBody);
                return newFunc(Function, args1).apply(null, args2);
            }
            function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
                assert(argCount > 0);
                var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
                invoker = embind__requireFunction(invokerSignature, invoker);
                whenDependentTypesAreResolved([], [
                    rawClassType
                ], function(classType) {
                    classType = classType[0];
                    var humanName = `constructor ${classType.name}`;
                    if (undefined === classType.registeredClass.constructor_body) {
                        classType.registeredClass.constructor_body = [];
                    }
                    if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
                        throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
                    }
                    classType.registeredClass.constructor_body[argCount - 1] = ()=>{
                        throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
                    };
                    whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                        // Insert empty slot for context type (argTypes[1]).
                        argTypes.splice(1, 0, null);
                        classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
                        return [];
                    });
                    return [];
                });
            }
            function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
                var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
                methodName = readLatin1String(methodName);
                rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
                whenDependentTypesAreResolved([], [
                    rawClassType
                ], function(classType) {
                    classType = classType[0];
                    var humanName = `${classType.name}.${methodName}`;
                    if (methodName.startsWith("@@")) {
                        methodName = Symbol[methodName.substring(2)];
                    }
                    if (isPureVirtual) {
                        classType.registeredClass.pureVirtualFunctions.push(methodName);
                    }
                    function unboundTypesHandler() {
                        throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
                    }
                    var proto = classType.registeredClass.instancePrototype;
                    var method = proto[methodName];
                    if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
                        // This is the first overload to be registered, OR we are replacing a
                        // function in the base class with a function in the derived class.
                        unboundTypesHandler.argCount = argCount - 2;
                        unboundTypesHandler.className = classType.name;
                        proto[methodName] = unboundTypesHandler;
                    } else {
                        // There was an existing function with the same name registered. Set up
                        // a function overload routing table.
                        ensureOverloadTable(proto, methodName, humanName);
                        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
                    }
                    whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                        var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
                        // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types
                        // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.
                        if (undefined === proto[methodName].overloadTable) {
                            // Set argCount in case an overload is registered later
                            memberFunction.argCount = argCount - 2;
                            proto[methodName] = memberFunction;
                        } else {
                            proto[methodName].overloadTable[argCount - 2] = memberFunction;
                        }
                        return [];
                    });
                    return [];
                });
            }
            function validateThis(this_, classType, humanName) {
                if (!(this_ instanceof Object)) {
                    throwBindingError(`${humanName} with invalid "this": ${this_}`);
                }
                if (!(this_ instanceof classType.registeredClass.constructor)) {
                    throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
                }
                if (!this_.$$.ptr) {
                    throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
                }
                // todo: kill this
                return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
            }
            function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
                fieldName = readLatin1String(fieldName);
                getter = embind__requireFunction(getterSignature, getter);
                whenDependentTypesAreResolved([], [
                    classType
                ], function(classType) {
                    classType = classType[0];
                    var humanName = `${classType.name}.${fieldName}`;
                    var desc = {
                        get: function() {
                            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [
                                getterReturnType,
                                setterArgumentType
                            ]);
                        },
                        enumerable: true,
                        configurable: true
                    };
                    if (setter) {
                        desc.set = ()=>{
                            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [
                                getterReturnType,
                                setterArgumentType
                            ]);
                        };
                    } else {
                        desc.set = (v)=>{
                            throwBindingError(humanName + ' is a read-only property');
                        };
                    }
                    Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
                    whenDependentTypesAreResolved([], setter ? [
                        getterReturnType,
                        setterArgumentType
                    ] : [
                        getterReturnType
                    ], function(types) {
                        var getterReturnType = types[0];
                        var desc = {
                            get: function() {
                                var ptr = validateThis(this, classType, humanName + ' getter');
                                return getterReturnType['fromWireType'](getter(getterContext, ptr));
                            },
                            enumerable: true
                        };
                        if (setter) {
                            setter = embind__requireFunction(setterSignature, setter);
                            var setterArgumentType = types[1];
                            desc.set = function(v) {
                                var ptr = validateThis(this, classType, humanName + ' setter');
                                var destructors = [];
                                setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));
                                runDestructors(destructors);
                            };
                        }
                        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
                        return [];
                    });
                    return [];
                });
            }
            function __embind_register_constant(name, type, value) {
                name = readLatin1String(name);
                whenDependentTypesAreResolved([], [
                    type
                ], function(type) {
                    type = type[0];
                    Module[name] = type['fromWireType'](value);
                    return [];
                });
            }
            /** @constructor */ function HandleAllocator() {
                // Reserve slot 0 so that 0 is always an invalid handle
                this.allocated = [
                    undefined
                ];
                this.freelist = [];
                this.get = function(id) {
                    assert(this.allocated[id] !== undefined, `invalid handle: ${id}`);
                    return this.allocated[id];
                };
                this.has = function(id) {
                    return this.allocated[id] !== undefined;
                };
                this.allocate = function(handle) {
                    var id = this.freelist.pop() || this.allocated.length;
                    this.allocated[id] = handle;
                    return id;
                };
                this.free = function(id) {
                    assert(this.allocated[id] !== undefined);
                    // Set the slot to `undefined` rather than using `delete` here since
                    // apparently arrays with holes in them can be less efficient.
                    this.allocated[id] = undefined;
                    this.freelist.push(id);
                };
            }
            var emval_handles = new HandleAllocator();
            function __emval_decref(handle) {
                if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {
                    emval_handles.free(handle);
                }
            }
            function count_emval_handles() {
                var count = 0;
                for(var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i){
                    if (emval_handles.allocated[i] !== undefined) {
                        ++count;
                    }
                }
                return count;
            }
            function init_emval() {
                // reserve some special values. These never get de-allocated.
                // The HandleAllocator takes care of reserving zero.
                emval_handles.allocated.push({
                    value: undefined
                }, {
                    value: null
                }, {
                    value: true
                }, {
                    value: false
                });
                emval_handles.reserved = emval_handles.allocated.length;
                Module['count_emval_handles'] = count_emval_handles;
            }
            var Emval = {
                toValue: (handle)=>{
                    if (!handle) {
                        throwBindingError('Cannot use deleted val. handle = ' + handle);
                    }
                    return emval_handles.get(handle).value;
                },
                toHandle: (value)=>{
                    switch(value){
                        case undefined:
                            return 1;
                        case null:
                            return 2;
                        case true:
                            return 3;
                        case false:
                            return 4;
                        default:
                            {
                                return emval_handles.allocate({
                                    refcount: 1,
                                    value: value
                                });
                            }
                    }
                }
            };
            function __embind_register_emval(rawType, name) {
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(handle) {
                        var rv = Emval.toValue(handle);
                        __emval_decref(handle);
                        return rv;
                    },
                    'toWireType': function(destructors, value) {
                        return Emval.toHandle(value);
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': simpleReadValueFromPointer,
                    destructorFunction: null
                });
            }
            function embindRepr(v) {
                if (v === null) {
                    return 'null';
                }
                var t = typeof v;
                if (t === 'object' || t === 'array' || t === 'function') {
                    return v.toString();
                } else {
                    return '' + v;
                }
            }
            function floatReadValueFromPointer(name, shift) {
                switch(shift){
                    case 2:
                        return function(pointer) {
                            return this['fromWireType'](HEAPF32[pointer >> 2]);
                        };
                    case 3:
                        return function(pointer) {
                            return this['fromWireType'](HEAPF64[pointer >> 3]);
                        };
                    default:
                        throw new TypeError("Unknown float type: " + name);
                }
            }
            function __embind_register_float(rawType, name, size) {
                var shift = getShiftFromSize(size);
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(value) {
                        return value;
                    },
                    'toWireType': function(destructors, value) {
                        if (typeof value != "number" && typeof value != "boolean") {
                            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
                        }
                        // The VM will perform JS to Wasm value conversion, according to the spec:
                        // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
                        return value;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': floatReadValueFromPointer(name, shift),
                    destructorFunction: null
                });
            }
            function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
                var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
                name = readLatin1String(name);
                rawInvoker = embind__requireFunction(signature, rawInvoker);
                exposePublicSymbol(name, function() {
                    throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
                }, argCount - 1);
                whenDependentTypesAreResolved([], argTypes, function(argTypes) {
                    var invokerArgsArray = [
                        argTypes[0],
                        null
                    ].concat(argTypes.slice(1));
                    replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
                    return [];
                });
            }
            function integerReadValueFromPointer(name, shift, signed) {
                // integers are quite common, so generate very specialized functions
                switch(shift){
                    case 0:
                        return signed ? function readS8FromPointer(pointer) {
                            return HEAP8[pointer];
                        } : function readU8FromPointer(pointer) {
                            return HEAPU8[pointer];
                        };
                    case 1:
                        return signed ? function readS16FromPointer(pointer) {
                            return HEAP16[pointer >> 1];
                        } : function readU16FromPointer(pointer) {
                            return HEAPU16[pointer >> 1];
                        };
                    case 2:
                        return signed ? function readS32FromPointer(pointer) {
                            return HEAP32[pointer >> 2];
                        } : function readU32FromPointer(pointer) {
                            return HEAPU32[pointer >> 2];
                        };
                    default:
                        throw new TypeError("Unknown integer type: " + name);
                }
            }
            function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
                name = readLatin1String(name);
                // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come
                // out as 'i32 -1'. Always treat those as max u32.
                if (maxRange === -1) {
                    maxRange = 4294967295;
                }
                var shift = getShiftFromSize(size);
                var fromWireType = (value)=>value;
                if (minRange === 0) {
                    var bitshift = 32 - 8 * size;
                    fromWireType = (value)=>value << bitshift >>> bitshift;
                }
                var isUnsignedType = name.includes('unsigned');
                var checkAssertions = (value, toTypeName)=>{
                    if (typeof value != "number" && typeof value != "boolean") {
                        throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${toTypeName}`);
                    }
                    if (value < minRange || value > maxRange) {
                        throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${name}", which is outside the valid range [${minRange}, ${maxRange}]!`);
                    }
                };
                var toWireType;
                if (isUnsignedType) {
                    toWireType = function(destructors, value) {
                        checkAssertions(value, this.name);
                        return value >>> 0;
                    };
                } else {
                    toWireType = function(destructors, value) {
                        checkAssertions(value, this.name);
                        // The VM will perform JS to Wasm value conversion, according to the spec:
                        // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
                        return value;
                    };
                }
                registerType(primitiveType, {
                    name: name,
                    'fromWireType': fromWireType,
                    'toWireType': toWireType,
                    'argPackAdvance': 8,
                    'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
                    destructorFunction: null
                });
            }
            function __embind_register_memory_view(rawType, dataTypeIndex, name) {
                var typeMapping = [
                    Int8Array,
                    Uint8Array,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                ];
                var TA = typeMapping[dataTypeIndex];
                function decodeMemoryView(handle) {
                    handle = handle >> 2;
                    var heap = HEAPU32;
                    var size = heap[handle]; // in elements
                    var data = heap[handle + 1]; // byte offset into emscripten heap
                    return new TA(heap.buffer, data, size);
                }
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': decodeMemoryView,
                    'argPackAdvance': 8,
                    'readValueFromPointer': decodeMemoryView
                }, {
                    ignoreDuplicateRegistrations: true
                });
            }
            function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
                assert(typeof str === 'string');
                // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
                // undefined and false each don't write out any bytes.
                if (!(maxBytesToWrite > 0)) return 0;
                var startIdx = outIdx;
                var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                    // unit, not a Unicode code point of the character! So decode
                    // UTF16->UTF32->UTF8.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
                    // and https://www.ietf.org/rfc/rfc2279.txt
                    // and https://tools.ietf.org/html/rfc3629
                    var u = str.charCodeAt(i); // possibly a lead surrogate
                    if (u >= 0xD800 && u <= 0xDFFF) {
                        var u1 = str.charCodeAt(++i);
                        u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;
                    }
                    if (u <= 0x7F) {
                        if (outIdx >= endIdx) break;
                        heap[outIdx++] = u;
                    } else if (u <= 0x7FF) {
                        if (outIdx + 1 >= endIdx) break;
                        heap[outIdx++] = 0xC0 | u >> 6;
                        heap[outIdx++] = 0x80 | u & 63;
                    } else if (u <= 0xFFFF) {
                        if (outIdx + 2 >= endIdx) break;
                        heap[outIdx++] = 0xE0 | u >> 12;
                        heap[outIdx++] = 0x80 | u >> 6 & 63;
                        heap[outIdx++] = 0x80 | u & 63;
                    } else {
                        if (outIdx + 3 >= endIdx) break;
                        if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
                        heap[outIdx++] = 0xF0 | u >> 18;
                        heap[outIdx++] = 0x80 | u >> 12 & 63;
                        heap[outIdx++] = 0x80 | u >> 6 & 63;
                        heap[outIdx++] = 0x80 | u & 63;
                    }
                }
                // Null-terminate the pointer to the buffer.
                heap[outIdx] = 0;
                return outIdx - startIdx;
            }
            function stringToUTF8(str, outPtr, maxBytesToWrite) {
                assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
                return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
            }
            function lengthBytesUTF8(str) {
                var len = 0;
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                    // unit, not a Unicode code point of the character! So decode
                    // UTF16->UTF32->UTF8.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    var c = str.charCodeAt(i); // possibly a lead surrogate
                    if (c <= 0x7F) {
                        len++;
                    } else if (c <= 0x7FF) {
                        len += 2;
                    } else if (c >= 0xD800 && c <= 0xDFFF) {
                        len += 4;
                        ++i;
                    } else {
                        len += 3;
                    }
                }
                return len;
            }
            function __embind_register_std_string(rawType, name) {
                name = readLatin1String(name);
                var stdStringIsUTF8 = name === "std::string";
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(value) {
                        var length = HEAPU32[value >> 2];
                        var payload = value + 4;
                        var str;
                        if (stdStringIsUTF8) {
                            var decodeStartPtr = payload;
                            // Looping here to support possible embedded '0' bytes
                            for(var i = 0; i <= length; ++i){
                                var currentBytePtr = payload + i;
                                if (i == length || HEAPU8[currentBytePtr] == 0) {
                                    var maxRead = currentBytePtr - decodeStartPtr;
                                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                                    if (str === undefined) {
                                        str = stringSegment;
                                    } else {
                                        str += String.fromCharCode(0);
                                        str += stringSegment;
                                    }
                                    decodeStartPtr = currentBytePtr + 1;
                                }
                            }
                        } else {
                            var a = new Array(length);
                            for(var i = 0; i < length; ++i){
                                a[i] = String.fromCharCode(HEAPU8[payload + i]);
                            }
                            str = a.join('');
                        }
                        _free(value);
                        return str;
                    },
                    'toWireType': function(destructors, value) {
                        if (value instanceof ArrayBuffer) {
                            value = new Uint8Array(value);
                        }
                        var length;
                        var valueIsOfTypeString = typeof value == 'string';
                        if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                            throwBindingError('Cannot pass non-string to std::string');
                        }
                        if (stdStringIsUTF8 && valueIsOfTypeString) {
                            length = lengthBytesUTF8(value);
                        } else {
                            length = value.length;
                        }
                        // assumes 4-byte alignment
                        var base = _malloc(4 + length + 1);
                        var ptr = base + 4;
                        HEAPU32[base >> 2] = length;
                        if (stdStringIsUTF8 && valueIsOfTypeString) {
                            stringToUTF8(value, ptr, length + 1);
                        } else {
                            if (valueIsOfTypeString) {
                                for(var i = 0; i < length; ++i){
                                    var charCode = value.charCodeAt(i);
                                    if (charCode > 255) {
                                        _free(ptr);
                                        throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                                    }
                                    HEAPU8[ptr + i] = charCode;
                                }
                            } else {
                                for(var i = 0; i < length; ++i){
                                    HEAPU8[ptr + i] = value[i];
                                }
                            }
                        }
                        if (destructors !== null) {
                            destructors.push(_free, base);
                        }
                        return base;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': simpleReadValueFromPointer,
                    destructorFunction: function(ptr) {
                        _free(ptr);
                    }
                });
            }
            var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;
            function UTF16ToString(ptr, maxBytesToRead) {
                assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
                var endPtr = ptr;
                // TextDecoder needs to know the byte length in advance, it doesn't stop on
                // null terminator by itself.
                // Also, use the length info to avoid running tiny strings through
                // TextDecoder, since .subarray() allocates garbage.
                var idx = endPtr >> 1;
                var maxIdx = idx + maxBytesToRead / 2;
                // If maxBytesToRead is not passed explicitly, it will be undefined, and this
                // will always evaluate to true. This saves on code size.
                while(!(idx >= maxIdx) && HEAPU16[idx])++idx;
                endPtr = idx << 1;
                if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
                // Fallback: decode without UTF16Decoder
                var str = '';
                // If maxBytesToRead is not passed explicitly, it will be undefined, and the
                // for-loop's condition will always evaluate to true. The loop is then
                // terminated on the first null char.
                for(var i = 0; !(i >= maxBytesToRead / 2); ++i){
                    var codeUnit = HEAP16[ptr + i * 2 >> 1];
                    if (codeUnit == 0) break;
                    // fromCharCode constructs a character from a UTF-16 code unit, so we can
                    // pass the UTF16 string right through.
                    str += String.fromCharCode(codeUnit);
                }
                return str;
            }
            function stringToUTF16(str, outPtr, maxBytesToWrite) {
                assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
                assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
                // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
                if (maxBytesToWrite === undefined) {
                    maxBytesToWrite = 0x7FFFFFFF;
                }
                if (maxBytesToWrite < 2) return 0;
                maxBytesToWrite -= 2; // Null terminator.
                var startPtr = outPtr;
                var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
                for(var i = 0; i < numCharsToWrite; ++i){
                    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
                    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
                    HEAP16[outPtr >> 1] = codeUnit;
                    outPtr += 2;
                }
                // Null-terminate the pointer to the HEAP.
                HEAP16[outPtr >> 1] = 0;
                return outPtr - startPtr;
            }
            function lengthBytesUTF16(str) {
                return str.length * 2;
            }
            function UTF32ToString(ptr, maxBytesToRead) {
                assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
                var i = 0;
                var str = '';
                // If maxBytesToRead is not passed explicitly, it will be undefined, and this
                // will always evaluate to true. This saves on code size.
                while(!(i >= maxBytesToRead / 4)){
                    var utf32 = HEAP32[ptr + i * 4 >> 2];
                    if (utf32 == 0) break;
                    ++i;
                    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    if (utf32 >= 0x10000) {
                        var ch = utf32 - 0x10000;
                        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
                    } else {
                        str += String.fromCharCode(utf32);
                    }
                }
                return str;
            }
            function stringToUTF32(str, outPtr, maxBytesToWrite) {
                assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
                assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
                // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
                if (maxBytesToWrite === undefined) {
                    maxBytesToWrite = 0x7FFFFFFF;
                }
                if (maxBytesToWrite < 4) return 0;
                var startPtr = outPtr;
                var endPtr = startPtr + maxBytesToWrite - 4;
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
                    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
                        var trailSurrogate = str.charCodeAt(++i);
                        codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;
                    }
                    HEAP32[outPtr >> 2] = codeUnit;
                    outPtr += 4;
                    if (outPtr + 4 > endPtr) break;
                }
                // Null-terminate the pointer to the HEAP.
                HEAP32[outPtr >> 2] = 0;
                return outPtr - startPtr;
            }
            function lengthBytesUTF32(str) {
                var len = 0;
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    var codeUnit = str.charCodeAt(i);
                    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
                    len += 4;
                }
                return len;
            }
            function __embind_register_std_wstring(rawType, charSize, name) {
                name = readLatin1String(name);
                var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
                if (charSize === 2) {
                    decodeString = UTF16ToString;
                    encodeString = stringToUTF16;
                    lengthBytesUTF = lengthBytesUTF16;
                    getHeap = ()=>HEAPU16;
                    shift = 1;
                } else if (charSize === 4) {
                    decodeString = UTF32ToString;
                    encodeString = stringToUTF32;
                    lengthBytesUTF = lengthBytesUTF32;
                    getHeap = ()=>HEAPU32;
                    shift = 2;
                }
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(value) {
                        // Code mostly taken from _embind_register_std_string fromWireType
                        var length = HEAPU32[value >> 2];
                        var HEAP = getHeap();
                        var str;
                        var decodeStartPtr = value + 4;
                        // Looping here to support possible embedded '0' bytes
                        for(var i = 0; i <= length; ++i){
                            var currentBytePtr = value + 4 + i * charSize;
                            if (i == length || HEAP[currentBytePtr >> shift] == 0) {
                                var maxReadBytes = currentBytePtr - decodeStartPtr;
                                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                                if (str === undefined) {
                                    str = stringSegment;
                                } else {
                                    str += String.fromCharCode(0);
                                    str += stringSegment;
                                }
                                decodeStartPtr = currentBytePtr + charSize;
                            }
                        }
                        _free(value);
                        return str;
                    },
                    'toWireType': function(destructors, value) {
                        if (!(typeof value == 'string')) {
                            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
                        }
                        // assumes 4-byte alignment
                        var length = lengthBytesUTF(value);
                        var ptr = _malloc(4 + length + charSize);
                        HEAPU32[ptr >> 2] = length >> shift;
                        encodeString(value, ptr + 4, length + charSize);
                        if (destructors !== null) {
                            destructors.push(_free, ptr);
                        }
                        return ptr;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': simpleReadValueFromPointer,
                    destructorFunction: function(ptr) {
                        _free(ptr);
                    }
                });
            }
            function __embind_register_void(rawType, name) {
                name = readLatin1String(name);
                registerType(rawType, {
                    isVoid: true,
                    name: name,
                    'argPackAdvance': 0,
                    'fromWireType': function() {
                        return undefined;
                    },
                    'toWireType': function(destructors, o) {
                        // TODO: assert if anything else is given?
                        return undefined;
                    }
                });
            }
            function requireRegisteredType(rawType, humanName) {
                var impl = registeredTypes[rawType];
                if (undefined === impl) {
                    throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
                }
                return impl;
            }
            function __emval_as(handle, returnType, destructorsRef) {
                handle = Emval.toValue(handle);
                returnType = requireRegisteredType(returnType, 'emval::as');
                var destructors = [];
                var rd = Emval.toHandle(destructors);
                HEAPU32[destructorsRef >> 2] = rd;
                return returnType['toWireType'](destructors, handle);
            }
            function emval_lookupTypes(argCount, argTypes) {
                var a = new Array(argCount);
                for(var i = 0; i < argCount; ++i){
                    a[i] = requireRegisteredType(HEAPU32[argTypes + i * 4 >> 2], "parameter " + i);
                }
                return a;
            }
            function __emval_call(handle, argCount, argTypes, argv) {
                handle = Emval.toValue(handle);
                var types = emval_lookupTypes(argCount, argTypes);
                var args = new Array(argCount);
                for(var i = 0; i < argCount; ++i){
                    var type = types[i];
                    args[i] = type['readValueFromPointer'](argv);
                    argv += type['argPackAdvance'];
                }
                var rv = handle.apply(undefined, args);
                return Emval.toHandle(rv);
            }
            var emval_symbols = {};
            function getStringOrSymbol(address) {
                var symbol = emval_symbols[address];
                if (symbol === undefined) {
                    return readLatin1String(address);
                }
                return symbol;
            }
            var emval_methodCallers = [];
            function __emval_call_void_method(caller, handle, methodName, args) {
                caller = emval_methodCallers[caller];
                handle = Emval.toValue(handle);
                methodName = getStringOrSymbol(methodName);
                caller(handle, methodName, null, args);
            }
            function emval_addMethodCaller(caller) {
                var id = emval_methodCallers.length;
                emval_methodCallers.push(caller);
                return id;
            }
            var emval_registeredMethods = [];
            function __emval_get_method_caller(argCount, argTypes) {
                var types = emval_lookupTypes(argCount, argTypes);
                var retType = types[0];
                var signatureName = retType.name + "_$" + types.slice(1).map(function(t) {
                    return t.name;
                }).join("_") + "$";
                var returnId = emval_registeredMethods[signatureName];
                if (returnId !== undefined) {
                    return returnId;
                }
                var params = [
                    "retType"
                ];
                var args = [
                    retType
                ];
                var argsList = ""; // 'arg0, arg1, arg2, ... , argN'
                for(var i = 0; i < argCount - 1; ++i){
                    argsList += (i !== 0 ? ", " : "") + "arg" + i;
                    params.push("argType" + i);
                    args.push(types[1 + i]);
                }
                var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
                var functionBody = "return function " + functionName + "(handle, name, destructors, args) {\n";
                var offset = 0;
                for(var i = 0; i < argCount - 1; ++i){
                    functionBody += "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? "+" + offset : "") + ");\n";
                    offset += types[i + 1]['argPackAdvance'];
                }
                functionBody += "    var rv = handle[name](" + argsList + ");\n";
                for(var i = 0; i < argCount - 1; ++i){
                    if (types[i + 1]['deleteObject']) {
                        functionBody += "    argType" + i + ".deleteObject(arg" + i + ");\n";
                    }
                }
                if (!retType.isVoid) {
                    functionBody += "    return retType.toWireType(destructors, rv);\n";
                }
                functionBody += "};\n";
                params.push(functionBody);
                var invokerFunction = newFunc(Function, params).apply(null, args);
                returnId = emval_addMethodCaller(invokerFunction);
                emval_registeredMethods[signatureName] = returnId;
                return returnId;
            }
            function __emval_get_property(handle, key) {
                handle = Emval.toValue(handle);
                key = Emval.toValue(key);
                return Emval.toHandle(handle[key]);
            }
            function __emval_incref(handle) {
                if (handle > 4) {
                    emval_handles.get(handle).refcount += 1;
                }
            }
            function __emval_new_array() {
                return Emval.toHandle([]);
            }
            function __emval_new_cstring(v) {
                return Emval.toHandle(getStringOrSymbol(v));
            }
            function __emval_new_object() {
                return Emval.toHandle({});
            }
            function __emval_run_destructors(handle) {
                var destructors = Emval.toValue(handle);
                runDestructors(destructors);
                __emval_decref(handle);
            }
            function __emval_set_property(handle, key, value) {
                handle = Emval.toValue(handle);
                key = Emval.toValue(key);
                value = Emval.toValue(value);
                handle[key] = value;
            }
            function __emval_strictly_equals(first, second) {
                first = Emval.toValue(first);
                second = Emval.toValue(second);
                return first === second;
            }
            function __emval_take_value(type, arg) {
                type = requireRegisteredType(type, '_emval_take_value');
                var v = type['readValueFromPointer'](arg);
                return Emval.toHandle(v);
            }
            function __emval_typeof(handle) {
                handle = Emval.toValue(handle);
                return Emval.toHandle(typeof handle);
            }
            function _abort() {
                abort('native code called abort()');
            }
            function _emscripten_memcpy_big(dest, src, num) {
                HEAPU8.copyWithin(dest, src, src + num);
            }
            function getHeapMax() {
                // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
                // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
                // for any code that deals with heap sizes, which would require special
                // casing all heap size related code to treat 0 specially.
                return 2147483648;
            }
            function emscripten_realloc_buffer(size) {
                var b = wasmMemory.buffer;
                var pages = size - b.byteLength + 65535 >>> 16;
                try {
                    // round size grow request up to wasm page size (fixed 64KB per spec)
                    wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
                    updateMemoryViews();
                    return 1 /*success*/ ;
                } catch (e) {
                    err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
                }
            // implicit 0 return to save code size (caller will cast "undefined" into 0
            // anyhow)
            }
            function _emscripten_resize_heap(requestedSize) {
                var oldSize = HEAPU8.length;
                requestedSize = requestedSize >>> 0;
                // With multithreaded builds, races can happen (another thread might increase the size
                // in between), so return a failure, and let the caller retry.
                assert(requestedSize > oldSize);
                // Memory resize rules:
                // 1.  Always increase heap size to at least the requested size, rounded up
                //     to next page multiple.
                // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
                //     geometrically: increase the heap size according to
                //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
                //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
                // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
                //     linearly: increase the heap size by at least
                //     MEMORY_GROWTH_LINEAR_STEP bytes.
                // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
                //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
                // 4.  If we were unable to allocate as much memory, it may be due to
                //     over-eager decision to excessively reserve due to (3) above.
                //     Hence if an allocation fails, cut down on the amount of excess
                //     growth, in an attempt to succeed to perform a smaller allocation.
                // A limit is set for how much we can grow. We should not exceed that
                // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
                var maxHeapSize = getHeapMax();
                if (requestedSize > maxHeapSize) {
                    err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
                    return false;
                }
                var alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;
                // Loop through potential heap size increases. If we attempt a too eager
                // reservation that fails, cut down on the attempted size and reserve a
                // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
                for(var cutDown = 1; cutDown <= 4; cutDown *= 2){
                    var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
                    // but limit overreserving (default to capping at +96MB overgrowth at most)
                    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
                    var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
                    var replacement = emscripten_realloc_buffer(newSize);
                    if (replacement) {
                        return true;
                    }
                }
                err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
                return false;
            }
            function _fd_close(fd) {
                abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');
            }
            function _fd_read(fd, iov, iovcnt, pnum) {
                abort('fd_read called without SYSCALLS_REQUIRE_FILESYSTEM');
            }
            function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
                return 70;
            }
            var printCharBuffers = [
                null,
                [],
                []
            ];
            function printChar(stream, curr) {
                var buffer = printCharBuffers[stream];
                assert(buffer);
                if (curr === 0 || curr === 10) {
                    (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
                    buffer.length = 0;
                } else {
                    buffer.push(curr);
                }
            }
            function _fd_write(fd, iov, iovcnt, pnum) {
                // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
                var num = 0;
                for(var i = 0; i < iovcnt; i++){
                    var ptr = HEAPU32[iov >> 2];
                    var len = HEAPU32[iov + 4 >> 2];
                    iov += 8;
                    for(var j = 0; j < len; j++){
                        printChar(fd, HEAPU8[ptr + j]);
                    }
                    num += len;
                }
                HEAPU32[pnum >> 2] = num;
                return 0;
            }
            embind_init_charCodes();
            BindingError = Module['BindingError'] = extendError(Error, 'BindingError');
            InternalError = Module['InternalError'] = extendError(Error, 'InternalError');
            init_ClassHandle();
            init_embind();
            init_RegisteredPointer();
            UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');
            init_emval();
            // include: base64Utils.js
            // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149
            // This code was written by Tyler Akins and has been placed in the
            // public domain.  It would be nice if you left this header intact.
            // Base64 code from Tyler Akins -- http://rumkin.com
            /**
	 * Decodes a base64 string.
	 * @param {string} input The string to decode.
	 */ var decodeBase64 = typeof atob == 'function' ? atob : function(input) {
                var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                var output = '';
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;
                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
                do {
                    enc1 = keyStr.indexOf(input.charAt(i++));
                    enc2 = keyStr.indexOf(input.charAt(i++));
                    enc3 = keyStr.indexOf(input.charAt(i++));
                    enc4 = keyStr.indexOf(input.charAt(i++));
                    chr1 = enc1 << 2 | enc2 >> 4;
                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                    chr3 = (enc3 & 3) << 6 | enc4;
                    output = output + String.fromCharCode(chr1);
                    if (enc3 !== 64) {
                        output = output + String.fromCharCode(chr2);
                    }
                    if (enc4 !== 64) {
                        output = output + String.fromCharCode(chr3);
                    }
                }while (i < input.length)
                return output;
            };
            // Converts a string of base64 into a byte array.
            // Throws error on invalid input.
            function intArrayFromBase64(s) {
                try {
                    var decoded = decodeBase64(s);
                    var bytes = new Uint8Array(decoded.length);
                    for(var i = 0; i < decoded.length; ++i){
                        bytes[i] = decoded.charCodeAt(i);
                    }
                    return bytes;
                } catch (_) {
                    throw new Error('Converting base64 string to bytes failed.');
                }
            }
            // If filename is a base64 data URI, parses and returns data (Buffer on node,
            // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
            function tryParseAsDataURI(filename) {
                if (!isDataURI(filename)) {
                    return;
                }
                return intArrayFromBase64(filename.slice(dataURIPrefix.length));
            }
            // end include: base64Utils.js
            function checkIncomingModuleAPI() {
                ignoredModuleProp('fetchSettings');
            }
            var wasmImports = {
                "__assert_fail": ___assert_fail,
                "__cxa_throw": ___cxa_throw,
                "__syscall_fcntl64": ___syscall_fcntl64,
                "__syscall_ioctl": ___syscall_ioctl,
                "__syscall_openat": ___syscall_openat,
                "_embind_register_bigint": __embind_register_bigint,
                "_embind_register_bool": __embind_register_bool,
                "_embind_register_class": __embind_register_class,
                "_embind_register_class_constructor": __embind_register_class_constructor,
                "_embind_register_class_function": __embind_register_class_function,
                "_embind_register_class_property": __embind_register_class_property,
                "_embind_register_constant": __embind_register_constant,
                "_embind_register_emval": __embind_register_emval,
                "_embind_register_float": __embind_register_float,
                "_embind_register_function": __embind_register_function,
                "_embind_register_integer": __embind_register_integer,
                "_embind_register_memory_view": __embind_register_memory_view,
                "_embind_register_std_string": __embind_register_std_string,
                "_embind_register_std_wstring": __embind_register_std_wstring,
                "_embind_register_void": __embind_register_void,
                "_emval_as": __emval_as,
                "_emval_call": __emval_call,
                "_emval_call_void_method": __emval_call_void_method,
                "_emval_decref": __emval_decref,
                "_emval_get_method_caller": __emval_get_method_caller,
                "_emval_get_property": __emval_get_property,
                "_emval_incref": __emval_incref,
                "_emval_new_array": __emval_new_array,
                "_emval_new_cstring": __emval_new_cstring,
                "_emval_new_object": __emval_new_object,
                "_emval_run_destructors": __emval_run_destructors,
                "_emval_set_property": __emval_set_property,
                "_emval_strictly_equals": __emval_strictly_equals,
                "_emval_take_value": __emval_take_value,
                "_emval_typeof": __emval_typeof,
                "abort": _abort,
                "emscripten_memcpy_big": _emscripten_memcpy_big,
                "emscripten_resize_heap": _emscripten_resize_heap,
                "fd_close": _fd_close,
                "fd_read": _fd_read,
                "fd_seek": _fd_seek,
                "fd_write": _fd_write
            };
            createWasm();
            /** @type {function(...*):?} */ Module["_fflush"] = createExportWrapper("fflush");
            /** @type {function(...*):?} */ var _malloc = createExportWrapper("malloc");
            /** @type {function(...*):?} */ var _free = createExportWrapper("free");
            /** @type {function(...*):?} */ var ___getTypeName = createExportWrapper("__getTypeName");
            /** @type {function(...*):?} */ Module["__embind_initialize_bindings"] = createExportWrapper("_embind_initialize_bindings");
            /** @type {function(...*):?} */ var _emscripten_stack_init = function() {
                return (_emscripten_stack_init = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
            };
            /** @type {function(...*):?} */ var _emscripten_stack_get_end = function() {
                return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
            };
            /** @type {function(...*):?} */ var ___cxa_is_pointer_type = createExportWrapper("__cxa_is_pointer_type");
            /** @type {function(...*):?} */ Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
            // include: postamble.js
            // === Auto-generated postamble setup entry stuff ===
            var missingLibrarySymbols = [
                'zeroMemory',
                'exitJS',
                'isLeapYear',
                'ydayFromDate',
                'arraySum',
                'addDays',
                'inetPton4',
                'inetNtop4',
                'inetPton6',
                'inetNtop6',
                'readSockaddr',
                'writeSockaddr',
                'getHostByName',
                'initRandomFill',
                'randomFill',
                'traverseStack',
                'getCallstack',
                'emscriptenLog',
                'convertPCtoSourceLocation',
                'readEmAsmArgs',
                'jstoi_q',
                'jstoi_s',
                'getExecutableName',
                'listenOnce',
                'autoResumeAudioContext',
                'handleException',
                'runtimeKeepalivePush',
                'runtimeKeepalivePop',
                'callUserCallback',
                'maybeExit',
                'safeSetTimeout',
                'asmjsMangle',
                'asyncLoad',
                'alignMemory',
                'mmapAlloc',
                'getNativeTypeSize',
                'STACK_SIZE',
                'STACK_ALIGN',
                'POINTER_SIZE',
                'ASSERTIONS',
                'writeI53ToI64',
                'writeI53ToI64Clamped',
                'writeI53ToI64Signaling',
                'writeI53ToU64Clamped',
                'writeI53ToU64Signaling',
                'readI53FromI64',
                'readI53FromU64',
                'convertI32PairToI53',
                'convertU32PairToI53',
                'getCFunc',
                'ccall',
                'cwrap',
                'uleb128Encode',
                'sigToWasmTypes',
                'generateFuncType',
                'convertJsFunctionToWasm',
                'getEmptyTableSlot',
                'updateTableMap',
                'getFunctionAddress',
                'addFunction',
                'removeFunction',
                'reallyNegative',
                'unSign',
                'strLen',
                'reSign',
                'formatString',
                'intArrayFromString',
                'AsciiToString',
                'stringToAscii',
                'stringToNewUTF8',
                'stringToUTF8OnStack',
                'writeArrayToMemory',
                'registerKeyEventCallback',
                'maybeCStringToJsString',
                'findEventTarget',
                'findCanvasEventTarget',
                'getBoundingClientRect',
                'fillMouseEventData',
                'registerMouseEventCallback',
                'registerWheelEventCallback',
                'registerUiEventCallback',
                'registerFocusEventCallback',
                'fillDeviceOrientationEventData',
                'registerDeviceOrientationEventCallback',
                'fillDeviceMotionEventData',
                'registerDeviceMotionEventCallback',
                'screenOrientation',
                'fillOrientationChangeEventData',
                'registerOrientationChangeEventCallback',
                'fillFullscreenChangeEventData',
                'registerFullscreenChangeEventCallback',
                'JSEvents_requestFullscreen',
                'JSEvents_resizeCanvasForFullscreen',
                'registerRestoreOldStyle',
                'hideEverythingExceptGivenElement',
                'restoreHiddenElements',
                'setLetterbox',
                'softFullscreenResizeWebGLRenderTarget',
                'doRequestFullscreen',
                'fillPointerlockChangeEventData',
                'registerPointerlockChangeEventCallback',
                'registerPointerlockErrorEventCallback',
                'requestPointerLock',
                'fillVisibilityChangeEventData',
                'registerVisibilityChangeEventCallback',
                'registerTouchEventCallback',
                'fillGamepadEventData',
                'registerGamepadEventCallback',
                'registerBeforeUnloadEventCallback',
                'fillBatteryEventData',
                'battery',
                'registerBatteryEventCallback',
                'setCanvasElementSize',
                'getCanvasElementSize',
                'demangle',
                'demangleAll',
                'jsStackTrace',
                'stackTrace',
                'getEnvStrings',
                'checkWasiClock',
                'wasiRightsToMuslOFlags',
                'wasiOFlagsToMuslOFlags',
                'createDyncallWrapper',
                'setImmediateWrapped',
                'clearImmediateWrapped',
                'polyfillSetImmediate',
                'getPromise',
                'makePromise',
                'idsToPromises',
                'makePromiseCallback',
                'setMainLoop',
                'getSocketFromFD',
                'getSocketAddress',
                'heapObjectForWebGLType',
                'heapAccessShiftForWebGLHeap',
                'webgl_enable_ANGLE_instanced_arrays',
                'webgl_enable_OES_vertex_array_object',
                'webgl_enable_WEBGL_draw_buffers',
                'webgl_enable_WEBGL_multi_draw',
                'emscriptenWebGLGet',
                'computeUnpackAlignedImageSize',
                'colorChannelsInGlTextureFormat',
                'emscriptenWebGLGetTexPixelData',
                '__glGenObject',
                'emscriptenWebGLGetUniform',
                'webglGetUniformLocation',
                'webglPrepareUniformLocationsBeforeFirstUse',
                'webglGetLeftBracePos',
                'emscriptenWebGLGetVertexAttrib',
                '__glGetActiveAttribOrUniform',
                'writeGLArray',
                'registerWebGlEventCallback',
                'runAndAbortIfError',
                'SDL_unicode',
                'SDL_ttfContext',
                'SDL_audio',
                'GLFW_Window',
                'ALLOC_NORMAL',
                'ALLOC_STACK',
                'allocate',
                'writeStringToMemory',
                'writeAsciiToMemory',
                'registerInheritedInstance',
                'unregisterInheritedInstance',
                'enumReadValueFromPointer',
                'craftEmvalAllocator',
                'emval_get_global'
            ];
            missingLibrarySymbols.forEach(missingLibrarySymbol);
            var unexportedSymbols = [
                'run',
                'addOnPreRun',
                'addOnInit',
                'addOnPreMain',
                'addOnExit',
                'addOnPostRun',
                'addRunDependency',
                'removeRunDependency',
                'FS_createFolder',
                'FS_createPath',
                'FS_createDataFile',
                'FS_createLazyFile',
                'FS_createLink',
                'FS_createDevice',
                'FS_unlink',
                'out',
                'err',
                'callMain',
                'abort',
                'keepRuntimeAlive',
                'wasmMemory',
                'stackAlloc',
                'stackSave',
                'stackRestore',
                'getTempRet0',
                'setTempRet0',
                'writeStackCookie',
                'checkStackCookie',
                'intArrayFromBase64',
                'tryParseAsDataURI',
                'ptrToString',
                'getHeapMax',
                'emscripten_realloc_buffer',
                'ENV',
                'MONTH_DAYS_REGULAR',
                'MONTH_DAYS_LEAP',
                'MONTH_DAYS_REGULAR_CUMULATIVE',
                'MONTH_DAYS_LEAP_CUMULATIVE',
                'ERRNO_CODES',
                'ERRNO_MESSAGES',
                'setErrNo',
                'DNS',
                'Protocols',
                'Sockets',
                'timers',
                'warnOnce',
                'UNWIND_CACHE',
                'readEmAsmArgsArray',
                'dynCallLegacy',
                'getDynCaller',
                'dynCall',
                'HandleAllocator',
                'convertI32PairToI53Checked',
                'freeTableIndexes',
                'functionsInTableMap',
                'setValue',
                'getValue',
                'PATH',
                'PATH_FS',
                'UTF8Decoder',
                'UTF8ArrayToString',
                'UTF8ToString',
                'stringToUTF8Array',
                'stringToUTF8',
                'lengthBytesUTF8',
                'intArrayToString',
                'UTF16Decoder',
                'UTF16ToString',
                'stringToUTF16',
                'lengthBytesUTF16',
                'UTF32ToString',
                'stringToUTF32',
                'lengthBytesUTF32',
                'JSEvents',
                'specialHTMLTargets',
                'currentFullscreenStrategy',
                'restoreOldWindowedStyle',
                'ExitStatus',
                'flush_NO_FILESYSTEM',
                'dlopenMissingError',
                'promiseMap',
                'uncaughtExceptionCount',
                'exceptionLast',
                'exceptionCaught',
                'ExceptionInfo',
                'Browser',
                'wget',
                'SYSCALLS',
                'tempFixedLengthArray',
                'miniTempWebGLFloatBuffers',
                'miniTempWebGLIntBuffers',
                'GL',
                'emscripten_webgl_power_preferences',
                'AL',
                'GLUT',
                'EGL',
                'GLEW',
                'IDBStore',
                'SDL',
                'SDL_gfx',
                'GLFW',
                'allocateUTF8',
                'allocateUTF8OnStack',
                'InternalError',
                'BindingError',
                'UnboundTypeError',
                'PureVirtualError',
                'init_embind',
                'throwInternalError',
                'throwBindingError',
                'throwUnboundTypeError',
                'ensureOverloadTable',
                'exposePublicSymbol',
                'replacePublicSymbol',
                'extendError',
                'createNamedFunction',
                'embindRepr',
                'registeredInstances',
                'getBasestPointer',
                'getInheritedInstance',
                'getInheritedInstanceCount',
                'getLiveInheritedInstances',
                'registeredTypes',
                'awaitingDependencies',
                'typeDependencies',
                'registeredPointers',
                'registerType',
                'whenDependentTypesAreResolved',
                'embind_charCodes',
                'embind_init_charCodes',
                'readLatin1String',
                'getTypeName',
                'heap32VectorToArray',
                'requireRegisteredType',
                'getShiftFromSize',
                'integerReadValueFromPointer',
                'floatReadValueFromPointer',
                'simpleReadValueFromPointer',
                'runDestructors',
                'newFunc',
                'craftInvokerFunction',
                'embind__requireFunction',
                'tupleRegistrations',
                'structRegistrations',
                'genericPointerToWireType',
                'constNoSmartPtrRawPointerToWireType',
                'nonConstNoSmartPtrRawPointerToWireType',
                'init_RegisteredPointer',
                'RegisteredPointer',
                'RegisteredPointer_getPointee',
                'RegisteredPointer_destructor',
                'RegisteredPointer_deleteObject',
                'RegisteredPointer_fromWireType',
                'runDestructor',
                'releaseClassHandle',
                'finalizationRegistry',
                'detachFinalizer_deps',
                'detachFinalizer',
                'attachFinalizer',
                'makeClassHandle',
                'init_ClassHandle',
                'ClassHandle',
                'ClassHandle_isAliasOf',
                'throwInstanceAlreadyDeleted',
                'ClassHandle_clone',
                'ClassHandle_delete',
                'deletionQueue',
                'ClassHandle_isDeleted',
                'ClassHandle_deleteLater',
                'flushPendingDeletes',
                'delayFunction',
                'setDelayFunction',
                'RegisteredClass',
                'shallowCopyInternalPointer',
                'downcastPointer',
                'upcastPointer',
                'validateThis',
                'char_0',
                'char_9',
                'makeLegalFunctionName',
                'emval_handles',
                'emval_symbols',
                'init_emval',
                'count_emval_handles',
                'getStringOrSymbol',
                'Emval',
                'emval_newers',
                'emval_lookupTypes',
                'emval_allocateDestructors',
                'emval_methodCallers',
                'emval_addMethodCaller',
                'emval_registeredMethods'
            ];
            unexportedSymbols.forEach(unexportedRuntimeSymbol);
            var calledRun;
            dependenciesFulfilled = function runCaller() {
                // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
                if (!calledRun) run();
                if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
            };
            function stackCheckInit() {
                // This is normally called automatically during __wasm_call_ctors but need to
                // get these values before even running any of the ctors so we call it redundantly
                // here.
                _emscripten_stack_init();
                // TODO(sbc): Move writeStackCookie to native to to avoid this.
                writeStackCookie();
            }
            function run() {
                if (runDependencies > 0) {
                    return;
                }
                stackCheckInit();
                preRun();
                // a preRun added a dependency, run will be called later
                if (runDependencies > 0) {
                    return;
                }
                function doRun() {
                    // run may have just been called through dependencies being fulfilled just in this very frame,
                    // or while the async setStatus time below was happening
                    if (calledRun) return;
                    calledRun = true;
                    Module['calledRun'] = true;
                    if (ABORT) return;
                    initRuntime();
                    readyPromiseResolve(Module);
                    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();
                    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
                    postRun();
                }
                if (Module['setStatus']) {
                    Module['setStatus']('Running...');
                    setTimeout(function() {
                        setTimeout(function() {
                            Module['setStatus']('');
                        }, 1);
                        doRun();
                    }, 1);
                } else {
                    doRun();
                }
                checkStackCookie();
            }
            if (Module['preInit']) {
                if (typeof Module['preInit'] == 'function') Module['preInit'] = [
                    Module['preInit']
                ];
                while(Module['preInit'].length > 0){
                    Module['preInit'].pop()();
                }
            }
            run();
            // end include: postamble.js
            return Module.ready;
        };
    })();
    module.exports = Module;
})(bindImgui$1);
var bindImguiExports = bindImgui$1.exports;
var bindImgui = /*@__PURE__*/ getDefaultExportFromCjs(bindImguiExports);

//export { Bind };
let bind;
async function imgui(value) {
    return new Promise((resolve)=>{
        bindImgui(value).then((value)=>{
            bind = value;
            bind.FLT_MIN;
            bind.FLT_MAX;
            resolve();
        });
    });
}
function import_Scalar(sca) {
    if (Array.isArray(sca)) {
        return [
            sca[0]
        ];
    }
    if (typeof sca === "function") {
        return [
            sca()
        ];
    }
    return [
        sca.x
    ];
}
function export_Scalar(tuple, sca) {
    if (Array.isArray(sca)) {
        sca[0] = tuple[0];
        return;
    }
    if (typeof sca === "function") {
        sca(tuple[0]);
        return;
    }
    sca.x = tuple[0];
}
const IMGUI_VERSION = "1.80"; // bind.IMGUI_VERSION;
function IMGUI_CHECKVERSION() {
    return DebugCheckVersionAndDataLayout(IMGUI_VERSION, bind.ImGuiIOSize, bind.ImGuiStyleSize, bind.ImVec2Size, bind.ImVec4Size, bind.ImDrawVertSize, bind.ImDrawIdxSize);
}
function ASSERT(c) {
    if (!c) {
        throw new Error();
    }
}
function IM_ASSERT(c) {
    if (!c) {
        throw new Error();
    }
}
function IM_ARRAYSIZE(_ARR) {
    if (_ARR instanceof ImStringBuffer) {
        return _ARR.size;
    } else {
        return _ARR.length;
    }
}
class ImStringBuffer {
    size;
    buffer;
    constructor(size, buffer = ""){
        this.size = size;
        this.buffer = buffer;
    }
}
var ImGuiWindowFlags;
(function(ImGuiWindowFlags) {
    ImGuiWindowFlags[ImGuiWindowFlags["None"] = 0] = "None";
    ImGuiWindowFlags[ImGuiWindowFlags["NoTitleBar"] = 1] = "NoTitleBar";
    ImGuiWindowFlags[ImGuiWindowFlags["NoResize"] = 2] = "NoResize";
    ImGuiWindowFlags[ImGuiWindowFlags["NoMove"] = 4] = "NoMove";
    ImGuiWindowFlags[ImGuiWindowFlags["NoScrollbar"] = 8] = "NoScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["NoScrollWithMouse"] = 16] = "NoScrollWithMouse";
    ImGuiWindowFlags[ImGuiWindowFlags["NoCollapse"] = 32] = "NoCollapse";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysAutoResize"] = 64] = "AlwaysAutoResize";
    ImGuiWindowFlags[ImGuiWindowFlags["NoBackground"] = 128] = "NoBackground";
    ImGuiWindowFlags[ImGuiWindowFlags["NoSavedSettings"] = 256] = "NoSavedSettings";
    ImGuiWindowFlags[ImGuiWindowFlags["NoMouseInputs"] = 512] = "NoMouseInputs";
    ImGuiWindowFlags[ImGuiWindowFlags["MenuBar"] = 1024] = "MenuBar";
    ImGuiWindowFlags[ImGuiWindowFlags["HorizontalScrollbar"] = 2048] = "HorizontalScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["NoFocusOnAppearing"] = 4096] = "NoFocusOnAppearing";
    ImGuiWindowFlags[ImGuiWindowFlags["NoBringToFrontOnFocus"] = 8192] = "NoBringToFrontOnFocus";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysVerticalScrollbar"] = 16384] = "AlwaysVerticalScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysHorizontalScrollbar"] = 32768] = "AlwaysHorizontalScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysUseWindowPadding"] = 65536] = "AlwaysUseWindowPadding";
    ImGuiWindowFlags[ImGuiWindowFlags["NoNavInputs"] = 262144] = "NoNavInputs";
    ImGuiWindowFlags[ImGuiWindowFlags["NoNavFocus"] = 524288] = "NoNavFocus";
    ImGuiWindowFlags[ImGuiWindowFlags["UnsavedDocument"] = 1048576] = "UnsavedDocument";
    ImGuiWindowFlags[ImGuiWindowFlags["NoNav"] = 786432] = "NoNav";
    ImGuiWindowFlags[ImGuiWindowFlags["NoDecoration"] = 43] = "NoDecoration";
    ImGuiWindowFlags[ImGuiWindowFlags["NoInputs"] = 786944] = "NoInputs";
    ImGuiWindowFlags[ImGuiWindowFlags["NavFlattened"] = 8388608] = "NavFlattened";
    ImGuiWindowFlags[ImGuiWindowFlags["ChildWindow"] = 16777216] = "ChildWindow";
    ImGuiWindowFlags[ImGuiWindowFlags["Tooltip"] = 33554432] = "Tooltip";
    ImGuiWindowFlags[ImGuiWindowFlags["Popup"] = 67108864] = "Popup";
    ImGuiWindowFlags[ImGuiWindowFlags["Modal"] = 134217728] = "Modal";
    ImGuiWindowFlags[ImGuiWindowFlags["ChildMenu"] = 268435456] = "ChildMenu";
})(ImGuiWindowFlags || (ImGuiWindowFlags = {}));
var ImGuiInputTextFlags;
(function(ImGuiInputTextFlags) {
    ImGuiInputTextFlags[ImGuiInputTextFlags["None"] = 0] = "None";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsDecimal"] = 1] = "CharsDecimal";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsHexadecimal"] = 2] = "CharsHexadecimal";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsUppercase"] = 4] = "CharsUppercase";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsNoBlank"] = 8] = "CharsNoBlank";
    ImGuiInputTextFlags[ImGuiInputTextFlags["AutoSelectAll"] = 16] = "AutoSelectAll";
    ImGuiInputTextFlags[ImGuiInputTextFlags["EnterReturnsTrue"] = 32] = "EnterReturnsTrue";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackCompletion"] = 64] = "CallbackCompletion";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackHistory"] = 128] = "CallbackHistory";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackAlways"] = 256] = "CallbackAlways";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackCharFilter"] = 512] = "CallbackCharFilter";
    ImGuiInputTextFlags[ImGuiInputTextFlags["AllowTabInput"] = 1024] = "AllowTabInput";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CtrlEnterForNewLine"] = 2048] = "CtrlEnterForNewLine";
    ImGuiInputTextFlags[ImGuiInputTextFlags["NoHorizontalScroll"] = 4096] = "NoHorizontalScroll";
    ImGuiInputTextFlags[ImGuiInputTextFlags["AlwaysInsertMode"] = 8192] = "AlwaysInsertMode";
    ImGuiInputTextFlags[ImGuiInputTextFlags["ReadOnly"] = 16384] = "ReadOnly";
    ImGuiInputTextFlags[ImGuiInputTextFlags["Password"] = 32768] = "Password";
    ImGuiInputTextFlags[ImGuiInputTextFlags["NoUndoRedo"] = 65536] = "NoUndoRedo";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsScientific"] = 131072] = "CharsScientific";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackResize"] = 262144] = "CallbackResize";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackEdit"] = 524288] = "CallbackEdit";
    ImGuiInputTextFlags[ImGuiInputTextFlags["Multiline"] = 1048576] = "Multiline";
    ImGuiInputTextFlags[ImGuiInputTextFlags["NoMarkEdited"] = 2097152] = "NoMarkEdited";
})(ImGuiInputTextFlags || (ImGuiInputTextFlags = {}));
var ImGuiTreeNodeFlags;
(function(ImGuiTreeNodeFlags) {
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["None"] = 0] = "None";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Selected"] = 1] = "Selected";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Framed"] = 2] = "Framed";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["AllowItemOverlap"] = 4] = "AllowItemOverlap";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["NoTreePushOnOpen"] = 8] = "NoTreePushOnOpen";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["NoAutoOpenOnLog"] = 16] = "NoAutoOpenOnLog";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["DefaultOpen"] = 32] = "DefaultOpen";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["OpenOnDoubleClick"] = 64] = "OpenOnDoubleClick";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["OpenOnArrow"] = 128] = "OpenOnArrow";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Leaf"] = 256] = "Leaf";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Bullet"] = 512] = "Bullet";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["FramePadding"] = 1024] = "FramePadding";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["SpanAvailWidth"] = 2048] = "SpanAvailWidth";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["SpanFullWidth"] = 4096] = "SpanFullWidth";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["NavLeftJumpsBackHere"] = 8192] = "NavLeftJumpsBackHere";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["CollapsingHeader"] = 26] = "CollapsingHeader";
})(ImGuiTreeNodeFlags || (ImGuiTreeNodeFlags = {}));
var ImGuiPopupFlags;
(function(ImGuiPopupFlags) {
    ImGuiPopupFlags[ImGuiPopupFlags["None"] = 0] = "None";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonLeft"] = 0] = "MouseButtonLeft";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonRight"] = 1] = "MouseButtonRight";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonMiddle"] = 2] = "MouseButtonMiddle";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonMask_"] = 0x1F] = "MouseButtonMask_";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonDefault_"] = 1] = "MouseButtonDefault_";
    ImGuiPopupFlags[ImGuiPopupFlags["NoOpenOverExistingPopup"] = 32] = "NoOpenOverExistingPopup";
    ImGuiPopupFlags[ImGuiPopupFlags["NoOpenOverItems"] = 64] = "NoOpenOverItems";
    ImGuiPopupFlags[ImGuiPopupFlags["AnyPopupId"] = 128] = "AnyPopupId";
    ImGuiPopupFlags[ImGuiPopupFlags["AnyPopupLevel"] = 256] = "AnyPopupLevel";
    ImGuiPopupFlags[ImGuiPopupFlags["AnyPopup"] = 384] = "AnyPopup";
})(ImGuiPopupFlags || (ImGuiPopupFlags = {}));
var ImGuiSelectableFlags;
(function(ImGuiSelectableFlags) {
    ImGuiSelectableFlags[ImGuiSelectableFlags["None"] = 0] = "None";
    ImGuiSelectableFlags[ImGuiSelectableFlags["DontClosePopups"] = 1] = "DontClosePopups";
    ImGuiSelectableFlags[ImGuiSelectableFlags["SpanAllColumns"] = 2] = "SpanAllColumns";
    ImGuiSelectableFlags[ImGuiSelectableFlags["AllowDoubleClick"] = 4] = "AllowDoubleClick";
    ImGuiSelectableFlags[ImGuiSelectableFlags["Disabled"] = 8] = "Disabled";
    ImGuiSelectableFlags[ImGuiSelectableFlags["AllowItemOverlap"] = 16] = "AllowItemOverlap";
})(ImGuiSelectableFlags || (ImGuiSelectableFlags = {}));
var ImGuiComboFlags;
(function(ImGuiComboFlags) {
    ImGuiComboFlags[ImGuiComboFlags["None"] = 0] = "None";
    ImGuiComboFlags[ImGuiComboFlags["PopupAlignLeft"] = 1] = "PopupAlignLeft";
    ImGuiComboFlags[ImGuiComboFlags["HeightSmall"] = 2] = "HeightSmall";
    ImGuiComboFlags[ImGuiComboFlags["HeightRegular"] = 4] = "HeightRegular";
    ImGuiComboFlags[ImGuiComboFlags["HeightLarge"] = 8] = "HeightLarge";
    ImGuiComboFlags[ImGuiComboFlags["HeightLargest"] = 16] = "HeightLargest";
    ImGuiComboFlags[ImGuiComboFlags["NoArrowButton"] = 32] = "NoArrowButton";
    ImGuiComboFlags[ImGuiComboFlags["NoPreview"] = 64] = "NoPreview";
    ImGuiComboFlags[ImGuiComboFlags["HeightMask_"] = 30] = "HeightMask_";
})(ImGuiComboFlags || (ImGuiComboFlags = {}));
var ImGuiTabBarFlags;
(function(ImGuiTabBarFlags) {
    ImGuiTabBarFlags[ImGuiTabBarFlags["None"] = 0] = "None";
    ImGuiTabBarFlags[ImGuiTabBarFlags["Reorderable"] = 1] = "Reorderable";
    ImGuiTabBarFlags[ImGuiTabBarFlags["AutoSelectNewTabs"] = 2] = "AutoSelectNewTabs";
    ImGuiTabBarFlags[ImGuiTabBarFlags["TabListPopupButton"] = 4] = "TabListPopupButton";
    ImGuiTabBarFlags[ImGuiTabBarFlags["NoCloseWithMiddleMouseButton"] = 8] = "NoCloseWithMiddleMouseButton";
    ImGuiTabBarFlags[ImGuiTabBarFlags["NoTabListScrollingButtons"] = 16] = "NoTabListScrollingButtons";
    ImGuiTabBarFlags[ImGuiTabBarFlags["NoTooltip"] = 32] = "NoTooltip";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyResizeDown"] = 64] = "FittingPolicyResizeDown";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyScroll"] = 128] = "FittingPolicyScroll";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyMask_"] = 192] = "FittingPolicyMask_";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyDefault_"] = 64] = "FittingPolicyDefault_";
})(ImGuiTabBarFlags || (ImGuiTabBarFlags = {}));
var ImGuiTabItemFlags;
(function(ImGuiTabItemFlags) {
    ImGuiTabItemFlags[ImGuiTabItemFlags["None"] = 0] = "None";
    ImGuiTabItemFlags[ImGuiTabItemFlags["UnsavedDocument"] = 1] = "UnsavedDocument";
    ImGuiTabItemFlags[ImGuiTabItemFlags["SetSelected"] = 2] = "SetSelected";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoCloseWithMiddleMouseButton"] = 4] = "NoCloseWithMiddleMouseButton";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoPushId"] = 8] = "NoPushId";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoTooltip"] = 16] = "NoTooltip";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoReorder"] = 32] = "NoReorder";
    ImGuiTabItemFlags[ImGuiTabItemFlags["Leading"] = 64] = "Leading";
    ImGuiTabItemFlags[ImGuiTabItemFlags["Trailing"] = 128] = "Trailing";
})(ImGuiTabItemFlags || (ImGuiTabItemFlags = {}));
var ImGuiTableFlags;
(function(ImGuiTableFlags) {
    ImGuiTableFlags[ImGuiTableFlags["None"] = 0] = "None";
    ImGuiTableFlags[ImGuiTableFlags["Resizable"] = 1] = "Resizable";
    ImGuiTableFlags[ImGuiTableFlags["Reorderable"] = 2] = "Reorderable";
    ImGuiTableFlags[ImGuiTableFlags["Hideable"] = 4] = "Hideable";
    ImGuiTableFlags[ImGuiTableFlags["Sortable"] = 8] = "Sortable";
    ImGuiTableFlags[ImGuiTableFlags["NoSavedSettings"] = 16] = "NoSavedSettings";
    ImGuiTableFlags[ImGuiTableFlags["ContextMenuInBody"] = 32] = "ContextMenuInBody";
    ImGuiTableFlags[ImGuiTableFlags["RowBg"] = 64] = "RowBg";
    ImGuiTableFlags[ImGuiTableFlags["BordersInnerH"] = 128] = "BordersInnerH";
    ImGuiTableFlags[ImGuiTableFlags["BordersOuterH"] = 256] = "BordersOuterH";
    ImGuiTableFlags[ImGuiTableFlags["BordersInnerV"] = 512] = "BordersInnerV";
    ImGuiTableFlags[ImGuiTableFlags["BordersOuterV"] = 1024] = "BordersOuterV";
    ImGuiTableFlags[ImGuiTableFlags["BordersH"] = 384] = "BordersH";
    ImGuiTableFlags[ImGuiTableFlags["BordersV"] = 1536] = "BordersV";
    ImGuiTableFlags[ImGuiTableFlags["BordersInner"] = 640] = "BordersInner";
    ImGuiTableFlags[ImGuiTableFlags["BordersOuter"] = 1280] = "BordersOuter";
    ImGuiTableFlags[ImGuiTableFlags["Borders"] = 1920] = "Borders";
    ImGuiTableFlags[ImGuiTableFlags["NoBordersInBody"] = 2048] = "NoBordersInBody";
    ImGuiTableFlags[ImGuiTableFlags["NoBordersInBodyUntilResize"] = 4096] = "NoBordersInBodyUntilResize";
    ImGuiTableFlags[ImGuiTableFlags["SizingFixedFit"] = 8192] = "SizingFixedFit";
    ImGuiTableFlags[ImGuiTableFlags["SizingFixedSame"] = 16384] = "SizingFixedSame";
    ImGuiTableFlags[ImGuiTableFlags["SizingStretchProp"] = 24576] = "SizingStretchProp";
    ImGuiTableFlags[ImGuiTableFlags["SizingStretchSame"] = 32768] = "SizingStretchSame";
    ImGuiTableFlags[ImGuiTableFlags["NoHostExtendX"] = 65536] = "NoHostExtendX";
    ImGuiTableFlags[ImGuiTableFlags["NoHostExtendY"] = 131072] = "NoHostExtendY";
    ImGuiTableFlags[ImGuiTableFlags["NoKeepColumnsVisible"] = 262144] = "NoKeepColumnsVisible";
    ImGuiTableFlags[ImGuiTableFlags["PreciseWidths"] = 524288] = "PreciseWidths";
    ImGuiTableFlags[ImGuiTableFlags["NoClip"] = 1048576] = "NoClip";
    ImGuiTableFlags[ImGuiTableFlags["PadOuterX"] = 2097152] = "PadOuterX";
    ImGuiTableFlags[ImGuiTableFlags["NoPadOuterX"] = 4194304] = "NoPadOuterX";
    ImGuiTableFlags[ImGuiTableFlags["NoPadInnerX"] = 8388608] = "NoPadInnerX";
    ImGuiTableFlags[ImGuiTableFlags["ScrollX"] = 16777216] = "ScrollX";
    ImGuiTableFlags[ImGuiTableFlags["ScrollY"] = 33554432] = "ScrollY";
    ImGuiTableFlags[ImGuiTableFlags["SortMulti"] = 67108864] = "SortMulti";
    ImGuiTableFlags[ImGuiTableFlags["SortTristate"] = 134217728] = "SortTristate";
    ImGuiTableFlags[ImGuiTableFlags["SizingMask_"] = 57344] = "SizingMask_";
})(ImGuiTableFlags || (ImGuiTableFlags = {}));
var ImGuiTableColumnFlags;
(function(ImGuiTableColumnFlags) {
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["None"] = 0] = "None";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["DefaultHide"] = 1] = "DefaultHide";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["DefaultSort"] = 2] = "DefaultSort";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["WidthStretch"] = 4] = "WidthStretch";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["WidthFixed"] = 8] = "WidthFixed";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoResize"] = 16] = "NoResize";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoReorder"] = 32] = "NoReorder";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoHide"] = 64] = "NoHide";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoClip"] = 128] = "NoClip";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoSort"] = 256] = "NoSort";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoSortAscending"] = 512] = "NoSortAscending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoSortDescending"] = 1024] = "NoSortDescending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoHeaderWidth"] = 2048] = "NoHeaderWidth";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["PreferSortAscending"] = 4096] = "PreferSortAscending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["PreferSortDescending"] = 8192] = "PreferSortDescending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IndentEnable"] = 16384] = "IndentEnable";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IndentDisable"] = 32768] = "IndentDisable";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsEnabled"] = 1048576] = "IsEnabled";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsVisible"] = 2097152] = "IsVisible";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsSorted"] = 4194304] = "IsSorted";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsHovered"] = 8388608] = "IsHovered";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["WidthMask_"] = 12] = "WidthMask_";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IndentMask_"] = 49152] = "IndentMask_";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["StatusMask_"] = 15728640] = "StatusMask_";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoDirectResize_"] = 1073741824] = "NoDirectResize_";
})(ImGuiTableColumnFlags || (ImGuiTableColumnFlags = {}));
var ImGuiTableRowFlags;
(function(ImGuiTableRowFlags) {
    ImGuiTableRowFlags[ImGuiTableRowFlags["None"] = 0] = "None";
    ImGuiTableRowFlags[ImGuiTableRowFlags["Headers"] = 1] = "Headers";
})(ImGuiTableRowFlags || (ImGuiTableRowFlags = {}));
var ImGuiTableBgTarget;
(function(ImGuiTableBgTarget) {
    ImGuiTableBgTarget[ImGuiTableBgTarget["None"] = 0] = "None";
    ImGuiTableBgTarget[ImGuiTableBgTarget["RowBg0"] = 1] = "RowBg0";
    ImGuiTableBgTarget[ImGuiTableBgTarget["RowBg1"] = 2] = "RowBg1";
    ImGuiTableBgTarget[ImGuiTableBgTarget["CellBg"] = 3 // Set cell background color (top-most color)
    ] = "CellBg";
})(ImGuiTableBgTarget || (ImGuiTableBgTarget = {}));
var ImGuiFocusedFlags;
(function(ImGuiFocusedFlags) {
    ImGuiFocusedFlags[ImGuiFocusedFlags["None"] = 0] = "None";
    ImGuiFocusedFlags[ImGuiFocusedFlags["ChildWindows"] = 1] = "ChildWindows";
    ImGuiFocusedFlags[ImGuiFocusedFlags["RootWindow"] = 2] = "RootWindow";
    ImGuiFocusedFlags[ImGuiFocusedFlags["AnyWindow"] = 4] = "AnyWindow";
    ImGuiFocusedFlags[ImGuiFocusedFlags["RootAndChildWindows"] = 3] = "RootAndChildWindows";
})(ImGuiFocusedFlags || (ImGuiFocusedFlags = {}));
var ImGuiHoveredFlags;
(function(ImGuiHoveredFlags) {
    ImGuiHoveredFlags[ImGuiHoveredFlags["None"] = 0] = "None";
    ImGuiHoveredFlags[ImGuiHoveredFlags["ChildWindows"] = 1] = "ChildWindows";
    ImGuiHoveredFlags[ImGuiHoveredFlags["RootWindow"] = 2] = "RootWindow";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AnyWindow"] = 4] = "AnyWindow";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenBlockedByPopup"] = 8] = "AllowWhenBlockedByPopup";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenBlockedByActiveItem"] = 32] = "AllowWhenBlockedByActiveItem";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenOverlapped"] = 64] = "AllowWhenOverlapped";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenDisabled"] = 128] = "AllowWhenDisabled";
    ImGuiHoveredFlags[ImGuiHoveredFlags["RectOnly"] = 104] = "RectOnly";
    ImGuiHoveredFlags[ImGuiHoveredFlags["RootAndChildWindows"] = 3] = "RootAndChildWindows";
})(ImGuiHoveredFlags || (ImGuiHoveredFlags = {}));
var ImGuiDragDropFlags;
(function(ImGuiDragDropFlags) {
    ImGuiDragDropFlags[ImGuiDragDropFlags["None"] = 0] = "None";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceNoPreviewTooltip"] = 1] = "SourceNoPreviewTooltip";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceNoDisableHover"] = 2] = "SourceNoDisableHover";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceNoHoldToOpenOthers"] = 4] = "SourceNoHoldToOpenOthers";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceAllowNullID"] = 8] = "SourceAllowNullID";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceExtern"] = 16] = "SourceExtern";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceAutoExpirePayload"] = 32] = "SourceAutoExpirePayload";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptBeforeDelivery"] = 1024] = "AcceptBeforeDelivery";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptNoDrawDefaultRect"] = 2048] = "AcceptNoDrawDefaultRect";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptNoPreviewTooltip"] = 4096] = "AcceptNoPreviewTooltip";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptPeekOnly"] = 3072] = "AcceptPeekOnly";
})(ImGuiDragDropFlags || (ImGuiDragDropFlags = {}));
var ImGuiDataType;
(function(ImGuiDataType) {
    ImGuiDataType[ImGuiDataType["S8"] = 0] = "S8";
    ImGuiDataType[ImGuiDataType["U8"] = 1] = "U8";
    ImGuiDataType[ImGuiDataType["S16"] = 2] = "S16";
    ImGuiDataType[ImGuiDataType["U16"] = 3] = "U16";
    ImGuiDataType[ImGuiDataType["S32"] = 4] = "S32";
    ImGuiDataType[ImGuiDataType["U32"] = 5] = "U32";
    ImGuiDataType[ImGuiDataType["S64"] = 6] = "S64";
    ImGuiDataType[ImGuiDataType["U64"] = 7] = "U64";
    ImGuiDataType[ImGuiDataType["Float"] = 8] = "Float";
    ImGuiDataType[ImGuiDataType["Double"] = 9] = "Double";
    ImGuiDataType[ImGuiDataType["COUNT"] = 10] = "COUNT";
})(ImGuiDataType || (ImGuiDataType = {}));
var ImGuiDir;
(function(ImGuiDir) {
    ImGuiDir[ImGuiDir["None"] = -1] = "None";
    ImGuiDir[ImGuiDir["Left"] = 0] = "Left";
    ImGuiDir[ImGuiDir["Right"] = 1] = "Right";
    ImGuiDir[ImGuiDir["Up"] = 2] = "Up";
    ImGuiDir[ImGuiDir["Down"] = 3] = "Down";
    ImGuiDir[ImGuiDir["COUNT"] = 4] = "COUNT";
})(ImGuiDir || (ImGuiDir = {}));
var ImGuiSortDirection;
(function(ImGuiSortDirection) {
    ImGuiSortDirection[ImGuiSortDirection["None"] = 0] = "None";
    ImGuiSortDirection[ImGuiSortDirection["Ascending"] = 1] = "Ascending";
    ImGuiSortDirection[ImGuiSortDirection["Descending"] = 2 // Descending = 9->0, Z->A etc.
    ] = "Descending";
})(ImGuiSortDirection || (ImGuiSortDirection = {}));
var ImGuiKey;
(function(ImGuiKey) {
    ImGuiKey[ImGuiKey["Tab"] = 0] = "Tab";
    ImGuiKey[ImGuiKey["LeftArrow"] = 1] = "LeftArrow";
    ImGuiKey[ImGuiKey["RightArrow"] = 2] = "RightArrow";
    ImGuiKey[ImGuiKey["UpArrow"] = 3] = "UpArrow";
    ImGuiKey[ImGuiKey["DownArrow"] = 4] = "DownArrow";
    ImGuiKey[ImGuiKey["PageUp"] = 5] = "PageUp";
    ImGuiKey[ImGuiKey["PageDown"] = 6] = "PageDown";
    ImGuiKey[ImGuiKey["Home"] = 7] = "Home";
    ImGuiKey[ImGuiKey["End"] = 8] = "End";
    ImGuiKey[ImGuiKey["Insert"] = 9] = "Insert";
    ImGuiKey[ImGuiKey["Delete"] = 10] = "Delete";
    ImGuiKey[ImGuiKey["Backspace"] = 11] = "Backspace";
    ImGuiKey[ImGuiKey["Space"] = 12] = "Space";
    ImGuiKey[ImGuiKey["Enter"] = 13] = "Enter";
    ImGuiKey[ImGuiKey["Escape"] = 14] = "Escape";
    ImGuiKey[ImGuiKey["KeyPadEnter"] = 15] = "KeyPadEnter";
    ImGuiKey[ImGuiKey["A"] = 16] = "A";
    ImGuiKey[ImGuiKey["C"] = 17] = "C";
    ImGuiKey[ImGuiKey["V"] = 18] = "V";
    ImGuiKey[ImGuiKey["X"] = 19] = "X";
    ImGuiKey[ImGuiKey["Y"] = 20] = "Y";
    ImGuiKey[ImGuiKey["Z"] = 21] = "Z";
    ImGuiKey[ImGuiKey["COUNT"] = 22] = "COUNT";
})(ImGuiKey || (ImGuiKey = {}));
var ImGuiKeyModFlags;
(function(ImGuiKeyModFlags) {
    ImGuiKeyModFlags[ImGuiKeyModFlags["None"] = 0] = "None";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Ctrl"] = 1] = "Ctrl";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Shift"] = 2] = "Shift";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Alt"] = 4] = "Alt";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Super"] = 8] = "Super";
})(ImGuiKeyModFlags || (ImGuiKeyModFlags = {}));
var ImGuiNavInput;
(function(ImGuiNavInput) {
    ImGuiNavInput[ImGuiNavInput["Activate"] = 0] = "Activate";
    ImGuiNavInput[ImGuiNavInput["Cancel"] = 1] = "Cancel";
    ImGuiNavInput[ImGuiNavInput["Input"] = 2] = "Input";
    ImGuiNavInput[ImGuiNavInput["Menu"] = 3] = "Menu";
    ImGuiNavInput[ImGuiNavInput["DpadLeft"] = 4] = "DpadLeft";
    ImGuiNavInput[ImGuiNavInput["DpadRight"] = 5] = "DpadRight";
    ImGuiNavInput[ImGuiNavInput["DpadUp"] = 6] = "DpadUp";
    ImGuiNavInput[ImGuiNavInput["DpadDown"] = 7] = "DpadDown";
    ImGuiNavInput[ImGuiNavInput["LStickLeft"] = 8] = "LStickLeft";
    ImGuiNavInput[ImGuiNavInput["LStickRight"] = 9] = "LStickRight";
    ImGuiNavInput[ImGuiNavInput["LStickUp"] = 10] = "LStickUp";
    ImGuiNavInput[ImGuiNavInput["LStickDown"] = 11] = "LStickDown";
    ImGuiNavInput[ImGuiNavInput["FocusPrev"] = 12] = "FocusPrev";
    ImGuiNavInput[ImGuiNavInput["FocusNext"] = 13] = "FocusNext";
    ImGuiNavInput[ImGuiNavInput["TweakSlow"] = 14] = "TweakSlow";
    ImGuiNavInput[ImGuiNavInput["TweakFast"] = 15] = "TweakFast";
    ImGuiNavInput[ImGuiNavInput[// Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) may be directly reading from io.KeyDown[] instead of io.NavInputs[].
    "KeyMenu_"] = 16] = "KeyMenu_";
    ImGuiNavInput[ImGuiNavInput["KeyLeft_"] = 17] = "KeyLeft_";
    ImGuiNavInput[ImGuiNavInput["KeyRight_"] = 18] = "KeyRight_";
    ImGuiNavInput[ImGuiNavInput["KeyUp_"] = 19] = "KeyUp_";
    ImGuiNavInput[ImGuiNavInput["KeyDown_"] = 20] = "KeyDown_";
    ImGuiNavInput[ImGuiNavInput["COUNT"] = 21] = "COUNT";
    ImGuiNavInput[ImGuiNavInput["InternalStart_"] = 16] = "InternalStart_";
})(ImGuiNavInput || (ImGuiNavInput = {}));
var ImGuiConfigFlags;
(function(ImGuiConfigFlags) {
    ImGuiConfigFlags[ImGuiConfigFlags["None"] = 0] = "None";
    ImGuiConfigFlags[ImGuiConfigFlags["NavEnableKeyboard"] = 1] = "NavEnableKeyboard";
    ImGuiConfigFlags[ImGuiConfigFlags["NavEnableGamepad"] = 2] = "NavEnableGamepad";
    ImGuiConfigFlags[ImGuiConfigFlags["NavEnableSetMousePos"] = 4] = "NavEnableSetMousePos";
    ImGuiConfigFlags[ImGuiConfigFlags["NavNoCaptureKeyboard"] = 8] = "NavNoCaptureKeyboard";
    ImGuiConfigFlags[ImGuiConfigFlags["NoMouse"] = 16] = "NoMouse";
    ImGuiConfigFlags[ImGuiConfigFlags["NoMouseCursorChange"] = 32] = "NoMouseCursorChange";
    ImGuiConfigFlags[ImGuiConfigFlags["IsSRGB"] = 1048576] = "IsSRGB";
    ImGuiConfigFlags[ImGuiConfigFlags["IsTouchScreen"] = 2097152] = "IsTouchScreen";
})(ImGuiConfigFlags || (ImGuiConfigFlags = {}));
var ImGuiCol;
(function(ImGuiCol) {
    ImGuiCol[ImGuiCol["Text"] = 0] = "Text";
    ImGuiCol[ImGuiCol["TextDisabled"] = 1] = "TextDisabled";
    ImGuiCol[ImGuiCol["WindowBg"] = 2] = "WindowBg";
    ImGuiCol[ImGuiCol["ChildBg"] = 3] = "ChildBg";
    ImGuiCol[ImGuiCol["PopupBg"] = 4] = "PopupBg";
    ImGuiCol[ImGuiCol["Border"] = 5] = "Border";
    ImGuiCol[ImGuiCol["BorderShadow"] = 6] = "BorderShadow";
    ImGuiCol[ImGuiCol["FrameBg"] = 7] = "FrameBg";
    ImGuiCol[ImGuiCol["FrameBgHovered"] = 8] = "FrameBgHovered";
    ImGuiCol[ImGuiCol["FrameBgActive"] = 9] = "FrameBgActive";
    ImGuiCol[ImGuiCol["TitleBg"] = 10] = "TitleBg";
    ImGuiCol[ImGuiCol["TitleBgActive"] = 11] = "TitleBgActive";
    ImGuiCol[ImGuiCol["TitleBgCollapsed"] = 12] = "TitleBgCollapsed";
    ImGuiCol[ImGuiCol["MenuBarBg"] = 13] = "MenuBarBg";
    ImGuiCol[ImGuiCol["ScrollbarBg"] = 14] = "ScrollbarBg";
    ImGuiCol[ImGuiCol["ScrollbarGrab"] = 15] = "ScrollbarGrab";
    ImGuiCol[ImGuiCol["ScrollbarGrabHovered"] = 16] = "ScrollbarGrabHovered";
    ImGuiCol[ImGuiCol["ScrollbarGrabActive"] = 17] = "ScrollbarGrabActive";
    ImGuiCol[ImGuiCol["CheckMark"] = 18] = "CheckMark";
    ImGuiCol[ImGuiCol["SliderGrab"] = 19] = "SliderGrab";
    ImGuiCol[ImGuiCol["SliderGrabActive"] = 20] = "SliderGrabActive";
    ImGuiCol[ImGuiCol["Button"] = 21] = "Button";
    ImGuiCol[ImGuiCol["ButtonHovered"] = 22] = "ButtonHovered";
    ImGuiCol[ImGuiCol["ButtonActive"] = 23] = "ButtonActive";
    ImGuiCol[ImGuiCol["Header"] = 24] = "Header";
    ImGuiCol[ImGuiCol["HeaderHovered"] = 25] = "HeaderHovered";
    ImGuiCol[ImGuiCol["HeaderActive"] = 26] = "HeaderActive";
    ImGuiCol[ImGuiCol["Separator"] = 27] = "Separator";
    ImGuiCol[ImGuiCol["SeparatorHovered"] = 28] = "SeparatorHovered";
    ImGuiCol[ImGuiCol["SeparatorActive"] = 29] = "SeparatorActive";
    ImGuiCol[ImGuiCol["ResizeGrip"] = 30] = "ResizeGrip";
    ImGuiCol[ImGuiCol["ResizeGripHovered"] = 31] = "ResizeGripHovered";
    ImGuiCol[ImGuiCol["ResizeGripActive"] = 32] = "ResizeGripActive";
    ImGuiCol[ImGuiCol["Tab"] = 33] = "Tab";
    ImGuiCol[ImGuiCol["TabHovered"] = 34] = "TabHovered";
    ImGuiCol[ImGuiCol["TabActive"] = 35] = "TabActive";
    ImGuiCol[ImGuiCol["TabUnfocused"] = 36] = "TabUnfocused";
    ImGuiCol[ImGuiCol["TabUnfocusedActive"] = 37] = "TabUnfocusedActive";
    ImGuiCol[ImGuiCol["PlotLines"] = 38] = "PlotLines";
    ImGuiCol[ImGuiCol["PlotLinesHovered"] = 39] = "PlotLinesHovered";
    ImGuiCol[ImGuiCol["PlotHistogram"] = 40] = "PlotHistogram";
    ImGuiCol[ImGuiCol["PlotHistogramHovered"] = 41] = "PlotHistogramHovered";
    ImGuiCol[ImGuiCol["TableHeaderBg"] = 42] = "TableHeaderBg";
    ImGuiCol[ImGuiCol["TableBorderStrong"] = 43] = "TableBorderStrong";
    ImGuiCol[ImGuiCol["TableBorderLight"] = 44] = "TableBorderLight";
    ImGuiCol[ImGuiCol["TableRowBg"] = 45] = "TableRowBg";
    ImGuiCol[ImGuiCol["TableRowBgAlt"] = 46] = "TableRowBgAlt";
    ImGuiCol[ImGuiCol["TextSelectedBg"] = 47] = "TextSelectedBg";
    ImGuiCol[ImGuiCol["DragDropTarget"] = 48] = "DragDropTarget";
    ImGuiCol[ImGuiCol["NavHighlight"] = 49] = "NavHighlight";
    ImGuiCol[ImGuiCol["NavWindowingHighlight"] = 50] = "NavWindowingHighlight";
    ImGuiCol[ImGuiCol["NavWindowingDimBg"] = 51] = "NavWindowingDimBg";
    ImGuiCol[ImGuiCol["ModalWindowDimBg"] = 52] = "ModalWindowDimBg";
    ImGuiCol[ImGuiCol["COUNT"] = 53] = "COUNT";
})(ImGuiCol || (ImGuiCol = {}));
var ImGuiStyleVar;
(function(ImGuiStyleVar) {
    ImGuiStyleVar[ImGuiStyleVar["Alpha"] = 0] = "Alpha";
    ImGuiStyleVar[ImGuiStyleVar["WindowPadding"] = 1] = "WindowPadding";
    ImGuiStyleVar[ImGuiStyleVar["WindowRounding"] = 2] = "WindowRounding";
    ImGuiStyleVar[ImGuiStyleVar["WindowBorderSize"] = 3] = "WindowBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["WindowMinSize"] = 4] = "WindowMinSize";
    ImGuiStyleVar[ImGuiStyleVar["WindowTitleAlign"] = 5] = "WindowTitleAlign";
    ImGuiStyleVar[ImGuiStyleVar["ChildRounding"] = 6] = "ChildRounding";
    ImGuiStyleVar[ImGuiStyleVar["ChildBorderSize"] = 7] = "ChildBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["PopupRounding"] = 8] = "PopupRounding";
    ImGuiStyleVar[ImGuiStyleVar["PopupBorderSize"] = 9] = "PopupBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["FramePadding"] = 10] = "FramePadding";
    ImGuiStyleVar[ImGuiStyleVar["FrameRounding"] = 11] = "FrameRounding";
    ImGuiStyleVar[ImGuiStyleVar["FrameBorderSize"] = 12] = "FrameBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["ItemSpacing"] = 13] = "ItemSpacing";
    ImGuiStyleVar[ImGuiStyleVar["ItemInnerSpacing"] = 14] = "ItemInnerSpacing";
    ImGuiStyleVar[ImGuiStyleVar["IndentSpacing"] = 15] = "IndentSpacing";
    ImGuiStyleVar[ImGuiStyleVar["CellPadding"] = 16] = "CellPadding";
    ImGuiStyleVar[ImGuiStyleVar["ScrollbarSize"] = 17] = "ScrollbarSize";
    ImGuiStyleVar[ImGuiStyleVar["ScrollbarRounding"] = 18] = "ScrollbarRounding";
    ImGuiStyleVar[ImGuiStyleVar["GrabMinSize"] = 19] = "GrabMinSize";
    ImGuiStyleVar[ImGuiStyleVar["GrabRounding"] = 20] = "GrabRounding";
    ImGuiStyleVar[ImGuiStyleVar["TabRounding"] = 21] = "TabRounding";
    ImGuiStyleVar[ImGuiStyleVar["ButtonTextAlign"] = 22] = "ButtonTextAlign";
    ImGuiStyleVar[ImGuiStyleVar["SelectableTextAlign"] = 23] = "SelectableTextAlign";
    ImGuiStyleVar[ImGuiStyleVar["COUNT"] = 24] = "COUNT";
})(ImGuiStyleVar || (ImGuiStyleVar = {}));
var ImGuiBackendFlags;
(function(ImGuiBackendFlags) {
    ImGuiBackendFlags[ImGuiBackendFlags["None"] = 0] = "None";
    ImGuiBackendFlags[ImGuiBackendFlags["HasGamepad"] = 1] = "HasGamepad";
    ImGuiBackendFlags[ImGuiBackendFlags["HasMouseCursors"] = 2] = "HasMouseCursors";
    ImGuiBackendFlags[ImGuiBackendFlags["HasSetMousePos"] = 4] = "HasSetMousePos";
    ImGuiBackendFlags[ImGuiBackendFlags["RendererHasVtxOffset"] = 8] = "RendererHasVtxOffset";
})(ImGuiBackendFlags || (ImGuiBackendFlags = {}));
var ImGuiButtonFlags;
(function(ImGuiButtonFlags) {
    ImGuiButtonFlags[ImGuiButtonFlags["None"] = 0] = "None";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonLeft"] = 1] = "MouseButtonLeft";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonRight"] = 2] = "MouseButtonRight";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonMiddle"] = 4] = "MouseButtonMiddle";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonMask_"] = 7] = "MouseButtonMask_";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonDefault_"] = 1] = "MouseButtonDefault_";
})(ImGuiButtonFlags || (ImGuiButtonFlags = {}));
var ImGuiColorEditFlags;
(function(ImGuiColorEditFlags) {
    ImGuiColorEditFlags[ImGuiColorEditFlags["None"] = 0] = "None";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoAlpha"] = 2] = "NoAlpha";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoPicker"] = 4] = "NoPicker";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoOptions"] = 8] = "NoOptions";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoSmallPreview"] = 16] = "NoSmallPreview";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoInputs"] = 32] = "NoInputs";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoTooltip"] = 64] = "NoTooltip";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoLabel"] = 128] = "NoLabel";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoSidePreview"] = 256] = "NoSidePreview";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoDragDrop"] = 512] = "NoDragDrop";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoBorder"] = 1024] = "NoBorder";
    ImGuiColorEditFlags[ImGuiColorEditFlags["AlphaBar"] = 65536] = "AlphaBar";
    ImGuiColorEditFlags[ImGuiColorEditFlags["AlphaPreview"] = 131072] = "AlphaPreview";
    ImGuiColorEditFlags[ImGuiColorEditFlags["AlphaPreviewHalf"] = 262144] = "AlphaPreviewHalf";
    ImGuiColorEditFlags[ImGuiColorEditFlags["HDR"] = 524288] = "HDR";
    ImGuiColorEditFlags[ImGuiColorEditFlags["DisplayRGB"] = 1048576] = "DisplayRGB";
    ImGuiColorEditFlags[ImGuiColorEditFlags["DisplayHSV"] = 2097152] = "DisplayHSV";
    ImGuiColorEditFlags[ImGuiColorEditFlags["DisplayHex"] = 4194304] = "DisplayHex";
    ImGuiColorEditFlags[ImGuiColorEditFlags["Uint8"] = 8388608] = "Uint8";
    ImGuiColorEditFlags[ImGuiColorEditFlags["Float"] = 16777216] = "Float";
    ImGuiColorEditFlags[ImGuiColorEditFlags["PickerHueBar"] = 33554432] = "PickerHueBar";
    ImGuiColorEditFlags[ImGuiColorEditFlags["PickerHueWheel"] = 67108864] = "PickerHueWheel";
    ImGuiColorEditFlags[ImGuiColorEditFlags["InputRGB"] = 134217728] = "InputRGB";
    ImGuiColorEditFlags[ImGuiColorEditFlags["InputHSV"] = 268435456] = "InputHSV";
    ImGuiColorEditFlags[ImGuiColorEditFlags[// override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
    "_OptionsDefault"] = 177209344] = "_OptionsDefault";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_DisplayMask"] = 7340032] = "_DisplayMask";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_DataTypeMask"] = 25165824] = "_DataTypeMask";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_PickerMask"] = 100663296] = "_PickerMask";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_InputMask"] = 402653184] = "_InputMask";
})(ImGuiColorEditFlags || (ImGuiColorEditFlags = {}));
var ImGuiSliderFlags;
(function(ImGuiSliderFlags) {
    ImGuiSliderFlags[ImGuiSliderFlags["None"] = 0] = "None";
    ImGuiSliderFlags[ImGuiSliderFlags["AlwaysClamp"] = 16] = "AlwaysClamp";
    ImGuiSliderFlags[ImGuiSliderFlags["Logarithmic"] = 32] = "Logarithmic";
    ImGuiSliderFlags[ImGuiSliderFlags["NoRoundToFormat"] = 64] = "NoRoundToFormat";
    ImGuiSliderFlags[ImGuiSliderFlags["NoInput"] = 128] = "NoInput";
    ImGuiSliderFlags[ImGuiSliderFlags["InvalidMask_"] = 0x7000000F // [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.
    ] = "InvalidMask_";
})(ImGuiSliderFlags || (ImGuiSliderFlags = {}));
var ImGuiMouseButton;
(function(ImGuiMouseButton) {
    ImGuiMouseButton[ImGuiMouseButton["Left"] = 0] = "Left";
    ImGuiMouseButton[ImGuiMouseButton["Right"] = 1] = "Right";
    ImGuiMouseButton[ImGuiMouseButton["Middle"] = 2] = "Middle";
    ImGuiMouseButton[ImGuiMouseButton["COUNT"] = 5] = "COUNT";
})(ImGuiMouseButton || (ImGuiMouseButton = {}));
var ImGuiMouseCursor;
(function(ImGuiMouseCursor) {
    ImGuiMouseCursor[ImGuiMouseCursor["None"] = -1] = "None";
    ImGuiMouseCursor[ImGuiMouseCursor["Arrow"] = 0] = "Arrow";
    ImGuiMouseCursor[ImGuiMouseCursor["TextInput"] = 1] = "TextInput";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeAll"] = 2] = "ResizeAll";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeNS"] = 3] = "ResizeNS";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeEW"] = 4] = "ResizeEW";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeNESW"] = 5] = "ResizeNESW";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeNWSE"] = 6] = "ResizeNWSE";
    ImGuiMouseCursor[ImGuiMouseCursor["Hand"] = 7] = "Hand";
    ImGuiMouseCursor[ImGuiMouseCursor["NotAllowed"] = 8] = "NotAllowed";
    ImGuiMouseCursor[ImGuiMouseCursor["COUNT"] = 9] = "COUNT";
})(ImGuiMouseCursor || (ImGuiMouseCursor = {}));
var ImGuiCond;
(function(ImGuiCond) {
    ImGuiCond[ImGuiCond["None"] = 0] = "None";
    ImGuiCond[ImGuiCond["Always"] = 1] = "Always";
    ImGuiCond[ImGuiCond["Once"] = 2] = "Once";
    ImGuiCond[ImGuiCond["FirstUseEver"] = 4] = "FirstUseEver";
    ImGuiCond[ImGuiCond["Appearing"] = 8] = "Appearing";
})(ImGuiCond || (ImGuiCond = {}));
var ImDrawCornerFlags;
(function(ImDrawCornerFlags) {
    ImDrawCornerFlags[ImDrawCornerFlags["None"] = 0] = "None";
    ImDrawCornerFlags[ImDrawCornerFlags["TopLeft"] = 1] = "TopLeft";
    ImDrawCornerFlags[ImDrawCornerFlags["TopRight"] = 2] = "TopRight";
    ImDrawCornerFlags[ImDrawCornerFlags["BotLeft"] = 4] = "BotLeft";
    ImDrawCornerFlags[ImDrawCornerFlags["BotRight"] = 8] = "BotRight";
    ImDrawCornerFlags[ImDrawCornerFlags["Top"] = 3] = "Top";
    ImDrawCornerFlags[ImDrawCornerFlags["Bot"] = 12] = "Bot";
    ImDrawCornerFlags[ImDrawCornerFlags["Left"] = 5] = "Left";
    ImDrawCornerFlags[ImDrawCornerFlags["Right"] = 10] = "Right";
    ImDrawCornerFlags[ImDrawCornerFlags["All"] = 0xF] = "All";
})(ImDrawCornerFlags || (ImDrawCornerFlags = {}));
var ImDrawListFlags;
(function(ImDrawListFlags) {
    ImDrawListFlags[ImDrawListFlags["None"] = 0] = "None";
    ImDrawListFlags[ImDrawListFlags["AntiAliasedLines"] = 1] = "AntiAliasedLines";
    ImDrawListFlags[ImDrawListFlags["AntiAliasedLinesUseTex"] = 2] = "AntiAliasedLinesUseTex";
    ImDrawListFlags[ImDrawListFlags["AntiAliasedFill"] = 4] = "AntiAliasedFill";
    ImDrawListFlags[ImDrawListFlags["AllowVtxOffset"] = 8] = "AllowVtxOffset";
})(ImDrawListFlags || (ImDrawListFlags = {}));
class ImVec2 {
    x;
    y;
    static ZERO = new ImVec2(0.0, 0.0);
    static UNIT = new ImVec2(1.0, 1.0);
    static UNIT_X = new ImVec2(1.0, 0.0);
    static UNIT_Y = new ImVec2(0.0, 1.0);
    constructor(x = 0.0, y = 0.0){
        this.x = x;
        this.y = y;
    }
    Set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    Copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }
    Equals(other) {
        if (this.x !== other.x) {
            return false;
        }
        if (this.y !== other.y) {
            return false;
        }
        return true;
    }
}
class ImVec4 {
    x;
    y;
    z;
    w;
    static ZERO = new ImVec4(0.0, 0.0, 0.0, 0.0);
    static UNIT = new ImVec4(1.0, 1.0, 1.0, 1.0);
    static UNIT_X = new ImVec4(1.0, 0.0, 0.0, 0.0);
    static UNIT_Y = new ImVec4(0.0, 1.0, 0.0, 0.0);
    static UNIT_Z = new ImVec4(0.0, 0.0, 1.0, 0.0);
    static UNIT_W = new ImVec4(0.0, 0.0, 0.0, 1.0);
    static BLACK = new ImVec4(0.0, 0.0, 0.0, 1.0);
    static WHITE = new ImVec4(1.0, 1.0, 1.0, 1.0);
    constructor(x = 0.0, y = 0.0, z = 0.0, w = 1.0){
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    Set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    Copy(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.z;
        this.w = other.w;
        return this;
    }
    Equals(other) {
        if (this.x !== other.x) {
            return false;
        }
        if (this.y !== other.y) {
            return false;
        }
        if (this.z !== other.z) {
            return false;
        }
        if (this.w !== other.w) {
            return false;
        }
        return true;
    }
}
class ImVector extends Array {
    get Size() {
        return this.length;
    }
    Data = this;
    empty() {
        return this.length === 0;
    }
    clear() {
        this.length = 0;
    }
    pop_back() {
        return this.pop();
    }
    push_back(value) {
        this.push(value);
    }
    front() {
        IM_ASSERT(this.Size > 0);
        return this.Data[0];
    }
    back() {
        IM_ASSERT(this.Size > 0);
        return this.Data[this.Size - 1];
    }
    size() {
        return this.Size;
    }
    resize(new_size, v) {
        if (v) {
            for(let index = this.length; index < new_size; ++index){
                this[index] = v(index);
            }
        } else {
            this.length = new_size;
        }
    }
    contains(value) {
        return this.includes(value);
    }
    find_erase_unsorted(value) {
        const index = this.indexOf(value);
        if (index !== -1) {
            this.splice(index, 1);
        }
    }
}
class ImDrawCmd {
    native;
    constructor(native){
        this.native = native;
        this.UserCallback = null;
        this.UserCallbackData = null;
    }
    // unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    get ElemCount() {
        return this.native.ElemCount;
    }
    // ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2)
    get ClipRect() {
        return this.native.ClipRect;
    }
    // ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
    get TextureId() {
        return ImGuiContext.getTexture(this.native.TextureId);
    }
    // unsigned int    VtxOffset;              // Start offset in vertex buffer. Pre-1.71 or without ImGuiBackendFlags_RendererHasVtxOffset: always 0. With ImGuiBackendFlags_RendererHasVtxOffset: may be >0 to support meshes larger than 64K vertices with 16-bits indices.
    get VtxOffset() {
        return this.native.VtxOffset;
    }
    // unsigned int    IdxOffset;              // Start offset in index buffer. Always equal to sum of ElemCount drawn so far.
    get IdxOffset() {
        return this.native.IdxOffset;
    }
    // ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    UserCallback;
    // void*           UserCallbackData;       // The draw callback code can access this.
    UserCallbackData;
}
class ImDrawList {
    native;
    constructor(native){
        this.native = native;
    }
    IterateDrawCmds(callback) {
        this.native.IterateDrawCmds((draw_cmd, ElemStart)=>{
            callback(new ImDrawCmd(draw_cmd), ElemStart);
        });
    }
    // This is what you have to render
    // ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    // ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
    get IdxBuffer() {
        return this.native.IdxBuffer;
    }
    // ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
    get VtxBuffer() {
        return this.native.VtxBuffer;
    }
    // ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
    get Flags() {
        return this.native.Flags;
    }
    set Flags(value) {
        this.native.Flags = value;
    }
    // [Internal, used while building lists]
    // unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
    // const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    // const char*             _OwnerName;         // Pointer to owner window's name for debugging
    // ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    // ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    // ImVector<ImVec4>        _ClipRectStack;     // [Internal]
    // ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
    // ImVector<ImVec2>        _Path;              // [Internal] current path building
    // int                     _ChannelsCurrent;   // [Internal] current channel number (0)
    // int                     _ChannelsCount;     // [Internal] number of active channels (1+)
    // ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)
    // ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
    // ~ImDrawList() { ClearFreeMemory(); }
    // IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect = false) {
        this.native.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    }
    // IMGUI_API void  PushClipRectFullScreen();
    PushClipRectFullScreen() {
        this.native.PushClipRectFullScreen();
    }
    // IMGUI_API void  PopClipRect();
    PopClipRect() {
        this.native.PopClipRect();
    }
    // IMGUI_API void  PushTextureID(ImTextureID texture_id);
    PushTextureID(texture_id) {
        this.native.PushTextureID(ImGuiContext.setTexture(texture_id));
    }
    // IMGUI_API void  PopTextureID();
    PopTextureID() {
        this.native.PopTextureID();
    }
    // inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    GetClipRectMin(out = new ImVec2()) {
        return this.native.GetClipRectMin(out);
    }
    // inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }
    GetClipRectMax(out = new ImVec2()) {
        return this.native.GetClipRectMax(out);
    }
    // Primitives
    // IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
    AddLine(a, b, col, thickness = 1.0) {
        this.native.AddLine(a, b, col, thickness);
    }
    // IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round
    AddRect(a, b, col, rounding = 0.0, rounding_corners_flags = ImDrawCornerFlags.All, thickness = 1.0) {
        this.native.AddRect(a, b, col, rounding, rounding_corners_flags, thickness);
    }
    // IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right
    AddRectFilled(a, b, col, rounding = 0.0, rounding_corners_flags = ImDrawCornerFlags.All) {
        this.native.AddRectFilled(a, b, col, rounding, rounding_corners_flags);
    }
    // IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    AddRectFilledMultiColor(a, b, col_upr_left, col_upr_right, col_bot_right, col_bot_left) {
        this.native.AddRectFilledMultiColor(a, b, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
    }
    // IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
    AddQuad(a, b, c, d, col, thickness = 1.0) {
        this.native.AddQuad(a, b, c, d, col, thickness);
    }
    // IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
    AddQuadFilled(a, b, c, d, col) {
        this.native.AddQuadFilled(a, b, c, d, col);
    }
    // IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
    AddTriangle(a, b, c, col, thickness = 1.0) {
        this.native.AddTriangle(a, b, c, col, thickness);
    }
    // IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
    AddTriangleFilled(a, b, c, col) {
        this.native.AddTriangleFilled(a, b, c, col);
    }
    // IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
    AddCircle(centre, radius, col, num_segments = 12, thickness = 1.0) {
        this.native.AddCircle(centre, radius, col, num_segments, thickness);
    }
    // IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
    AddCircleFilled(centre, radius, col, num_segments = 12) {
        this.native.AddCircleFilled(centre, radius, col, num_segments);
    }
    // IMGUI_API void  AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
    AddNgon(centre, radius, col, num_segments, thickness = 1.0) {
        this.native.AddNgon(centre, radius, col, num_segments, thickness);
    }
    // IMGUI_API void  AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
    AddNgonFilled(centre, radius, col, num_segments) {
        this.native.AddNgonFilled(centre, radius, col, num_segments);
    }
    AddText(...args) {
        if (args[0] instanceof ImFont) {
            const font = args[0];
            const font_size = args[1];
            const pos = args[2];
            const col = args[3];
            const text_begin = args[4];
            const text_end = args[5] || null;
            const wrap_width = args[6] ? args[6] : 0.0;
            const cpu_fine_clip_rect = args[7] || null;
            this.native.AddText_B(font.native, font_size, pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin, wrap_width, cpu_fine_clip_rect);
        } else {
            const pos = args[0];
            const col = args[1];
            const text_begin = args[2];
            const text_end = args[3] || null;
            this.native.AddText_A(pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin);
        }
    }
    // IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
    AddPolyline(points, num_points, col, closed, thickness) {
        this.native.AddPolyline(points, num_points, col, closed, thickness);
    }
    // IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);
    AddConvexPolyFilled(points, num_points, col) {
        this.native.AddConvexPolyFilled(points, num_points, col);
    }
    // IMGUI_API void  AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0); // Cubic Bezier (4 control points)
    AddBezierCubic(p1, p2, p3, p4, col, thickness = 1.0, num_segments = 0) {
        this.native.AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments);
    }
    // IMGUI_API void  AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);               // Quadratic Bezier (3 control points)
    AddBezierQuadratic(p1, p2, p3, col, thickness = 1.0, num_segments = 0) {
        this.native.AddBezierQuadratic(p1, p2, p3, col, thickness, num_segments);
    }
    // IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);
    AddImage(user_texture_id, a, b, uv_a = ImVec2.ZERO, uv_b = ImVec2.UNIT, col = 0xFFFFFFFF) {
        this.native.AddImage(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col);
    }
    // IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);
    AddImageQuad(user_texture_id, a, b, c, d, uv_a = ImVec2.ZERO, uv_b = ImVec2.UNIT_X, uv_c = ImVec2.UNIT, uv_d = ImVec2.UNIT_Y, col = 0xFFFFFFFF) {
        this.native.AddImageQuad(ImGuiContext.setTexture(user_texture_id), a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
    }
    // IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
    AddImageRounded(user_texture_id, a, b, uv_a, uv_b, col, rounding, rounding_corners = ImDrawCornerFlags.All) {
        this.native.AddImageRounded(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col, rounding, rounding_corners);
    }
    // Stateful path API, add points then finish with PathFill() or PathStroke()
    // inline    void  PathClear()                                                 { _Path.resize(0); }
    PathClear() {
        this.native.PathClear();
    }
    // inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    PathLineTo(pos) {
        this.native.PathLineTo(pos);
    }
    // inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
    PathLineToMergeDuplicate(pos) {
        this.native.PathLineToMergeDuplicate(pos);
    }
    // inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }
    PathFillConvex(col) {
        this.native.PathFillConvex(col);
    }
    // inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }
    PathStroke(col, closed, thickness = 1.0) {
        this.native.PathStroke(col, closed, thickness);
    }
    // IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
    PathArcTo(centre, radius, a_min, a_max, num_segments = 10) {
        this.native.PathArcTo(centre, radius, a_min, a_max, num_segments);
    }
    // IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                // Use precomputed angles for a 12 steps circle
    PathArcToFast(centre, radius, a_min_of_12, a_max_of_12) {
        this.native.PathArcToFast(centre, radius, a_min_of_12, a_max_of_12);
    }
    // IMGUI_API void  PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0);  // Cubic Bezier (4 control points)
    PathBezierCubicCurveTo(p2, p3, p4, num_segments = 0) {
        this.native.PathBezierCubicCurveTo(p2, p3, p4, num_segments);
    }
    // IMGUI_API void  PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);                // Quadratic Bezier (3 control points)
    PathBezierQuadraticCurveTo(p2, p3, num_segments = 0) {
        this.native.PathBezierQuadraticCurveTo(p2, p3, num_segments);
    }
    // IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);
    PathRect(rect_min, rect_max, rounding = 0.0, rounding_corners_flags = ImDrawCornerFlags.All) {
        this.native.PathRect(rect_min, rect_max, rounding, rounding_corners_flags);
    }
    // Channels
    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
    // IMGUI_API void  ChannelsSplit(int channels_count);
    ChannelsSplit(channels_count) {
        this.native.ChannelsSplit(channels_count);
    }
    // IMGUI_API void  ChannelsMerge();
    ChannelsMerge() {
        this.native.ChannelsMerge();
    }
    // IMGUI_API void  ChannelsSetCurrent(int channel_index);
    ChannelsSetCurrent(channel_index) {
        this.native.ChannelsSetCurrent(channel_index);
    }
    // Advanced
    // IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
    AddCallback(callback, callback_data) {
        const _callback = (parent_list, draw_cmd)=>{
            callback(new ImDrawList(parent_list), new ImDrawCmd(draw_cmd));
        };
        this.native.AddCallback(_callback, callback_data);
    }
    // IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
    AddDrawCmd() {
        this.native.AddDrawCmd();
    }
    // Internal helpers
    // NB: all primitives needs to be reserved via PrimReserve() beforehand!
    // IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
    PrimReserve(idx_count, vtx_count) {
        this.native.PrimReserve(idx_count, vtx_count);
    }
    // IMGUI_API void  PrimUnreserve(int idx_count, int vtx_count);
    PrimUnreserve(idx_count, vtx_count) {
        this.native.PrimUnreserve(idx_count, vtx_count);
    }
    // IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
    PrimRect(a, b, col) {
        this.native.PrimRect(a, b, col);
    }
    // IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    PrimRectUV(a, b, uv_a, uv_b, col) {
        this.native.PrimRectUV(a, b, uv_a, uv_b, col);
    }
    // IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col) {
        this.native.PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
    }
    // inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    PrimWriteVtx(pos, uv, col) {
        this.native.PrimWriteVtx(pos, uv, col);
    }
    // inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
    PrimWriteIdx(idx) {
        this.native.PrimWriteIdx(idx);
    }
    // inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
    PrimVtx(pos, uv, col) {
        this.native.PrimVtx(pos, uv, col);
    }
}
class ImDrawData {
    native;
    constructor(native){
        this.native = native;
    }
    IterateDrawLists(callback) {
        this.native.IterateDrawLists((draw_list)=>{
            callback(new ImDrawList(draw_list));
        });
    }
    // bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
    get Valid() {
        return this.native.Valid;
    }
    // ImDrawList**    CmdLists;
    // int             CmdListsCount;
    get CmdListsCount() {
        return this.native.CmdListsCount;
    }
    // int             TotalIdxCount;          // For convenience, sum of all cmd_lists idx_buffer.Size
    get TotalIdxCount() {
        return this.native.TotalIdxCount;
    }
    // int             TotalVtxCount;          // For convenience, sum of all cmd_lists vtx_buffer.Size
    get TotalVtxCount() {
        return this.native.TotalVtxCount;
    }
    // ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
    get DisplayPos() {
        return this.native.DisplayPos;
    }
    // ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
    get DisplaySize() {
        return this.native.DisplaySize;
    }
    // ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
    get FramebufferScale() {
        return this.native.FramebufferScale;
    }
    // Functions
    // ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }
    // IMGUI_API void DeIndexAllBuffers();               // For backward compatibility or convenience: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
    DeIndexAllBuffers() {
        this.native.DeIndexAllBuffers();
    }
    // IMGUI_API void ScaleClipRects(const ImVec2& fb_scale);  // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
    ScaleClipRects(fb_scale) {
        this.native.ScaleClipRects(fb_scale);
    }
}
class script_ImFontConfig {
    // void*           FontData;                   //          // TTF/OTF data
    // int             FontDataSize;               //          // TTF/OTF data size
    FontData = null;
    // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    FontDataOwnedByAtlas = true;
    // int             FontNo;                     // 0        // Index of font within TTF/OTF file
    FontNo = 0;
    // float           SizePixels;                 //          // Size in pixels for rasterizer.
    SizePixels = 0;
    // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    OversampleH = 3;
    OversampleV = 1;
    // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    PixelSnapH = false;
    // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    GlyphExtraSpacing = new ImVec2(0, 0);
    // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
    GlyphOffset = new ImVec2(0, 0);
    // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    GlyphRanges = null;
    // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    GlyphMinAdvanceX = 0;
    // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
    GlyphMaxAdvanceX = Number.MAX_VALUE;
    // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    MergeMode = false;
    // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    RasterizerFlags = 0;
    // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
    RasterizerMultiply = 1.0;
    // ImWchar         EllipsisChar;           // -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
    EllipsisChar = -1;
    // [Internal]
    // char            Name[32];                               // Name (strictly to ease debugging)
    Name = "";
    // ImFont*         DstFont;
    DstFont = null;
}
class ImFontConfig {
    internal;
    constructor(internal = new script_ImFontConfig()){
        this.internal = internal;
    }
    // void*           FontData;                   //          // TTF/OTF data
    // int             FontDataSize;               //          // TTF/OTF data size
    get FontData() {
        return this.internal.FontData;
    }
    // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    get FontDataOwnedByAtlas() {
        return this.internal.FontDataOwnedByAtlas;
    }
    // int             FontNo;                     // 0        // Index of font within TTF/OTF file
    get FontNo() {
        return this.internal.FontNo;
    }
    // float           SizePixels;                 //          // Size in pixels for rasterizer.
    get SizePixels() {
        return this.internal.SizePixels;
    }
    // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    get OversampleH() {
        return this.internal.OversampleH;
    }
    get OversampleV() {
        return this.internal.OversampleV;
    }
    // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    get PixelSnapH() {
        return this.internal.PixelSnapH;
    }
    // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    get GlyphExtraSpacing() {
        return this.internal.GlyphExtraSpacing;
    }
    // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
    get GlyphOffset() {
        return this.internal.GlyphOffset;
    }
    // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    get GlyphRanges() {
        return this.internal.GlyphRanges;
    }
    // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    get GlyphMinAdvanceX() {
        return this.internal.GlyphMinAdvanceX;
    }
    // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
    get GlyphMaxAdvanceX() {
        return this.internal.GlyphMaxAdvanceX;
    }
    // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    get MergeMode() {
        return this.internal.MergeMode;
    }
    // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    get RasterizerFlags() {
        return this.internal.RasterizerFlags;
    }
    // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
    get RasterizerMultiply() {
        return this.internal.RasterizerMultiply;
    }
    // [Internal]
    // char            Name[32];                               // Name (strictly to ease debugging)
    get Name() {
        return this.internal.Name;
    }
    set Name(value) {
        this.internal.Name = value;
    }
    // ImFont*         DstFont;
    get DstFont() {
        const font = this.internal.DstFont;
        return font && new ImFont(font);
    }
}
// struct ImFontGlyph
class script_ImFontGlyph {
    // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
    Codepoint = 0;
    // unsigned int    Visible : 1;        // Flag to allow early out when rendering
    Visible = false;
    // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    AdvanceX = 0.0;
    // float           X0, Y0, X1, Y1;     // Glyph corners
    X0 = 0.0;
    Y0 = 0.0;
    X1 = 1.0;
    Y1 = 1.0;
    // float           U0, V0, U1, V1;     // Texture coordinates
    U0 = 0.0;
    V0 = 0.0;
    U1 = 1.0;
    V1 = 1.0;
    TexID = null;
    Char = 0;
}
class ImFontGlyph {
    internal;
    constructor(internal = new script_ImFontGlyph()){
        this.internal = internal;
    }
    // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
    get Codepoint() {
        return this.internal.Codepoint;
    }
    // unsigned int    Visible : 1;        // Flag to allow early out when rendering
    get Visible() {
        return this.internal.Visible;
    }
    // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    get AdvanceX() {
        return this.internal.AdvanceX;
    }
    set AdvanceX(v) {
        this.internal.AdvanceX = v;
    }
    // float           X0, Y0, X1, Y1;     // Glyph corners
    get X0() {
        return this.internal.X0;
    }
    set X0(v) {
        this.internal.X0 = v;
    }
    get Y0() {
        return this.internal.Y0;
    }
    set Y0(v) {
        this.internal.Y0 = v;
    }
    get X1() {
        return this.internal.X1;
    }
    set X1(v) {
        this.internal.X1 = v;
    }
    get Y1() {
        return this.internal.Y1;
    }
    set Y1(v) {
        this.internal.Y1 = v;
    }
    // float           U0, V0, U1, V1;     // Texture coordinates
    get U0() {
        return this.internal.U0;
    }
    set U0(v) {
        this.internal.U0 = v;
    }
    get V0() {
        return this.internal.V0;
    }
    set V0(v) {
        this.internal.V0 = v;
    }
    get U1() {
        return this.internal.U1;
    }
    set U1(v) {
        this.internal.U1 = v;
    }
    get V1() {
        return this.internal.V1;
    }
    set V1(v) {
        this.internal.V1 = v;
    }
    get TexID() {
        return this.internal.TexID;
    }
    get TextureID() {
        return ImGuiContext.getTexture(this.internal.TexID);
    }
    set TextureID(v) {
        this.internal.TexID = ImGuiContext.setTexture(v);
    }
    get Char() {
        return this.internal.Char;
    }
}
var ImFontAtlasFlags;
(function(ImFontAtlasFlags) {
    ImFontAtlasFlags[ImFontAtlasFlags["None"] = 0] = "None";
    ImFontAtlasFlags[ImFontAtlasFlags["NoPowerOfTwoHeight"] = 1] = "NoPowerOfTwoHeight";
    ImFontAtlasFlags[ImFontAtlasFlags["NoMouseCursors"] = 2] = "NoMouseCursors";
    ImFontAtlasFlags[ImFontAtlasFlags["NoBakedLines"] = 4] = "NoBakedLines";
})(ImFontAtlasFlags || (ImFontAtlasFlags = {}));
class ImFontAtlas {
    native;
    constructor(native){
        this.native = native;
        this._Fonts = null;
    }
    // IMGUI_API ImFontAtlas();
    // IMGUI_API ~ImFontAtlas();
    // IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
    // IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
    AddFontDefault(font_cfg = null) {
        return new ImFont(this.native.AddFontDefault(font_cfg));
    }
    // IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
    // IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after Build(). Set font_cfg->FontDataOwnedByAtlas to false to keep ownership.
    AddFontFromMemoryTTF(data, size_pixels, font_cfg = null, glyph_ranges = null) {
        return new ImFont(this.native.AddFontFromMemoryTTF(new Uint8Array(data), size_pixels, font_cfg && font_cfg.internal, glyph_ranges));
    }
    // IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    // IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    // IMGUI_API void              ClearTexData();             // Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.
    ClearTexData() {
        this.native.ClearTexData();
    }
    // IMGUI_API void              ClearInputData();           // Clear the input TTF data (inc sizes, glyph ranges)
    ClearInputData() {
        this.native.ClearInputData();
    }
    // IMGUI_API void              ClearFonts();               // Clear the ImGui-side font data (glyphs storage, UV coordinates)
    ClearFonts() {
        this.native.ClearFonts();
    }
    // IMGUI_API void              Clear();                    // Clear all
    Clear() {
        this.native.Clear();
    }
    // Build atlas, retrieve pixel data.
    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
    // RGBA32 format is provided for convenience and compatibility, but note that unless you use CustomRect to draw color data, the RGB pixels emitted from Fonts will all be white (~75% of waste).
    // Pitch = Width * BytesPerPixels
    // IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
    Build() {
        return this.native.Build();
    }
    // IMGUI_API bool              IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
    IsBuilt() {
        return this.native.IsBuilt();
    }
    // IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
    GetTexDataAsAlpha8() {
        return this.native.GetTexDataAsAlpha8();
    }
    // IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
    GetTexDataAsRGBA32() {
        return this.native.GetTexDataAsRGBA32();
    }
    // void                        SetTexID(ImTextureID id)    { TexID = id; }
    SetTexID(id) {
        this.TexID = id;
    }
    //-------------------------------------------
    // Glyph Ranges
    //-------------------------------------------
    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
    // IMGUI_API const ImWchar*    GetGlyphRangesDefault();    // Basic Latin, Extended Latin
    GetGlyphRangesDefault() {
        return this.native.GetGlyphRangesDefault();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesKorean();     // Default + Korean characters
    GetGlyphRangesKorean() {
        return this.native.GetGlyphRangesKorean();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
    GetGlyphRangesJapanese() {
        return this.native.GetGlyphRangesJapanese();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
    GetGlyphRangesChineseFull() {
        return this.native.GetGlyphRangesChineseFull();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
    GetGlyphRangesChineseSimplifiedCommon() {
        return this.native.GetGlyphRangesChineseSimplifiedCommon();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   // Default + about 400 Cyrillic characters
    GetGlyphRangesCyrillic() {
        return this.native.GetGlyphRangesCyrillic();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesThai();       // Default + Thai characters
    GetGlyphRangesThai() {
        return this.native.GetGlyphRangesThai();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();       // Default + Vietnamese characters
    GetGlyphRangesVietnamese() {
        return this.native.GetGlyphRangesVietnamese();
    }
    // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().
    // struct GlyphRangesBuilder
    // {
    //     ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)
    //     GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }
    //     bool           GetBit(int n) const  { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }
    //     void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array
    //     void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character
    //     IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)
    //     IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault) to force add all of ASCII/Latin+Ext
    //     IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges
    // };
    //-------------------------------------------
    // Custom Rectangles/Glyphs API
    //-------------------------------------------
    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
    // struct CustomRect
    // {
    //     unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
    //     unsigned short  Width, Height;  // Input    // Desired rectangle dimension
    //     unsigned short  X, Y;           // Output   // Packed position in Atlas
    //     float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
    //     ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
    //     ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
    //     CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
    //     bool IsPacked() const   { return X != 0xFFFF; }
    // };
    // IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
    // IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
    // IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
    // const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }
    //-------------------------------------------
    // Members
    //-------------------------------------------
    // bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
    get Locked() {
        return this.native.Locked;
    }
    set Locked(value) {
        this.native.Locked = value;
    }
    // ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
    get Flags() {
        return this.native.Flags;
    }
    set Flags(value) {
        this.native.Flags = value;
    }
    // ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
    get TexID() {
        return ImGuiContext.getTexture(this.native.TexID);
    }
    set TexID(value) {
        this.native.TexID = ImGuiContext.setTexture(value);
    }
    // int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
    get TexDesiredWidth() {
        return this.native.TexDesiredWidth;
    }
    set TexDesiredWidth(value) {
        this.native.TexDesiredWidth = value;
    }
    // int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.
    get TexGlyphPadding() {
        return this.native.TexGlyphPadding;
    }
    set TexGlyphPadding(value) {
        this.native.TexGlyphPadding = value;
    }
    // [Internal]
    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
    // unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
    // unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
    // int                         TexWidth;           // Texture width calculated during Build().
    get TexWidth() {
        return this.native.TexWidth;
    }
    // int                         TexHeight;          // Texture height calculated during Build().
    get TexHeight() {
        return this.native.TexHeight;
    }
    // ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
    get TexUvScale() {
        return this.native.TexUvScale;
    }
    // ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
    get TexUvWhitePixel() {
        return this.native.TexUvWhitePixel;
    }
    // ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    get Fonts_() {
        const fonts = new ImVector();
        this.native.IterateFonts((font)=>{
            fonts.push(new ImFont(font));
        });
        return fonts;
    }
    get Fonts() {
        if (this._Fonts == null) {
            this._Fonts = this.Fonts_;
        }
        return this._Fonts;
    }
    _Fonts;
    // ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
    // ImVector<ImFontConfig>      ConfigData;         // Internal data
    // int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList
    get CurrentFont() {
        return new ImFont(this.native.CurrentFont);
    }
}
class ImFont {
    native;
    constructor(native){
        this.native = native;
    }
    setFont(config) {
        this.native.FontName = config.name;
        this.native.FontSize = config.fontsize;
        this.native.Ascent = config.ascent ? config.ascent : 0;
        this.native.Descent = config.descent ? config.descent : 0;
    }
    // Members: Hot ~62/78 bytes
    // float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)
    get FontStyle() {
        return this.native.FontStyle;
    }
    set FontStyle(v) {
        this.native.FontStyle = v;
    }
    get FontName() {
        return this.native.FontName;
    }
    set FontName(v) {
        this.native.FontName = v;
    }
    get FontSize() {
        return this.native.FontSize;
    }
    set FontSize(v) {
        this.native.FontSize = v;
    }
    get SpaceX() {
        return [
            this.native.SpaceX0,
            this.native.SpaceX1
        ];
    }
    set SpaceX(v) {
        this.native.SpaceX0 = v[0];
        this.native.SpaceX1 = v[1];
    }
    // float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()
    get Scale() {
        return this.native.Scale;
    }
    set Scale(value) {
        this.native.Scale = value;
    }
    // ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.
    get Glyphs() {
        const glyphs = new ImVector();
        this.native.IterateGlyphs((glyph)=>{
            glyphs.push(new ImFontGlyph(glyph)); // TODO: wrap native
        });
        return glyphs;
    }
    // ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).
    // get IndexAdvanceX(): any { return this.native.IndexAdvanceX; }
    // ImVector<unsigned short>    IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.
    // get IndexLookup(): any { return this.native.IndexLookup; }
    // const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)
    get FallbackGlyph() {
        const glyph = this.native.FallbackGlyph;
        return glyph && new ImFontGlyph(glyph);
    }
    set FallbackGlyph(value) {
        this.native.FallbackGlyph = value && value.internal;
    }
    // float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX
    get FallbackAdvanceX() {
        return this.native.FallbackAdvanceX;
    }
    // ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()
    get FallbackChar() {
        return this.native.FallbackChar;
    }
    // ImWchar                     EllipsisChar;       // 2     // out // = -1       // Character used for ellipsis rendering.
    get EllipsisChar() {
        return this.native.EllipsisChar;
    }
    // Members: Cold ~18/26 bytes
    // short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
    get ConfigDataCount() {
        return this.native.ConfigDataCount;
    }
    // ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData
    get ConfigData() {
        return new ImFontConfig(this.native.ConfigData);
    }
    // ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into
    get ContainerAtlas() {
        return null;
    }
    // float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
    get Ascent() {
        return this.native.Ascent;
    }
    set Ascent(v) {
        this.native.Ascent = v;
    }
    get Descent() {
        return this.native.Descent;
    }
    set Descent(v) {
        this.native.Descent = v;
    }
    // int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
    get MetricsTotalSurface() {
        return this.native.MetricsTotalSurface;
    }
    // Methods
    // IMGUI_API ImFont();
    // IMGUI_API ~ImFont();
    // IMGUI_API void              ClearOutputData();
    ClearOutputData() {
        return this.native.ClearOutputData();
    }
    // IMGUI_API void              BuildLookupTable();
    BuildLookupTable() {
        return this.native.BuildLookupTable();
    }
    // IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
    FindGlyph(c) {
        const glyph = this.native.FindGlyph(c);
        return glyph && new ImFontGlyph(glyph);
    }
    // IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    FindGlyphNoFallback(c) {
        const glyph = this.native.FindGlyphNoFallback(c);
        return glyph && new ImFontGlyph(glyph);
    }
    // IMGUI_API void              SetFallbackChar(ImWchar c);
    SetFallbackChar(c) {
        return this.native.SetFallbackChar(c);
    }
    // float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    GetCharAdvance(c) {
        return this.native.GetCharAdvance(c);
    }
    // bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
    IsLoaded() {
        return this.native.IsLoaded();
    }
    // const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }
    GetDebugName() {
        return this.native.GetDebugName();
    }
    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
    // IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
    CalcTextSizeA(size, max_width, wrap_width, text_begin, text_end = null, remaining = null, isready = null) {
        return this.native.CalcTextSizeA(size, max_width, wrap_width, text_end !== null ? text_begin.substring(0, text_end) : text_begin, remaining, isready, new ImVec2());
    }
    // IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    CalcWordWrapPositionA(scale, text, text_end = null, wrap_width) {
        return this.native.CalcWordWrapPositionA(scale, text_end !== null ? text.substring(0, text_end) : text, wrap_width);
    }
    // IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;
    RenderChar(draw_list, size, pos, col, c) {
        this.native.RenderChar(draw_list.native, size, pos, col, c);
    }
    // IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;
    RenderText(draw_list, size, pos, col, clip_rect, text_begin, text_end = null, wrap_width = 0.0, cpu_fine_clip = false) {}
    // [Internal]
    // IMGUI_API void              GrowIndex(int new_size);
    // IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    // IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
    // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
    // #endif
    // IMGUI_API bool              IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);
    IsGlyphRangeUnused(c_begin, c_last) {
        return false;
    }
    get GlyphToCreate() {
        const glyph = this.native.GlyphToCreate();
        return glyph ? new ImFontGlyph(glyph) : null;
    }
    get IterateGlyphToCreate() {
        const glyphs = [];
        this.native.IterateGlyphToCreate((glyph)=>{
            glyphs.push(new ImFontGlyph(glyph));
        });
        return glyphs;
    }
    GlyphCreated(glyph) {
        this.native.GlyphCreated(glyph.internal);
    }
    ClearGlyphCreated() {
        this.native.ClearGlyphCreated();
    }
    CreateGlyph(text) {
        this.native.CreateGlyph(text);
    }
}
// a script version of Bind.ImGuiStyle with matching interface
class script_ImGuiStyle {
    Alpha = 1.0;
    WindowPadding = new ImVec2(8, 8);
    WindowRounding = 7.0;
    WindowBorderSize = 0.0;
    WindowMinSize = new ImVec2(32, 32);
    WindowTitleAlign = new ImVec2(0.0, 0.5);
    WindowMenuButtonPosition = ImGuiDir.Left;
    ChildRounding = 0.0;
    ChildBorderSize = 1.0;
    PopupRounding = 0.0;
    PopupBorderSize = 1.0;
    FramePadding = new ImVec2(4, 3);
    FrameRounding = 0.0;
    FrameBorderSize = 0.0;
    ItemSpacing = new ImVec2(8, 4);
    ItemInnerSpacing = new ImVec2(4, 4);
    CellPadding = new ImVec2(4, 2);
    TouchExtraPadding = new ImVec2(0, 0);
    IndentSpacing = 21.0;
    ColumnsMinSpacing = 6.0;
    ScrollbarSize = 16.0;
    ScrollbarRounding = 9.0;
    GrabMinSize = 10.0;
    GrabRounding = 0.0;
    LogSliderDeadzone = 4.0;
    TabRounding = 0.0;
    TabBorderSize = 0.0;
    TabMinWidthForCloseButton = 0.0;
    ColorButtonPosition = ImGuiDir.Right;
    ButtonTextAlign = new ImVec2(0.5, 0.5);
    SelectableTextAlign = new ImVec2(0.0, 0.0);
    DisplayWindowPadding = new ImVec2(22, 22);
    DisplaySafeAreaPadding = new ImVec2(4, 4);
    MouseCursorScale = 1;
    AntiAliasedLines = true;
    AntiAliasedLinesUseTex = true;
    AntiAliasedFill = true;
    CurveTessellationTol = 1.25;
    CircleSegmentMaxError = 1.60;
    Colors = [];
    _getAt_Colors(index) {
        return this.Colors[index];
    }
    _setAt_Colors(index, color) {
        this.Colors[index].Copy(color);
        return true;
    }
    constructor(){
        for(let i = 0; i < ImGuiCol.COUNT; ++i){
            this.Colors[i] = new ImVec4();
        }
        const _this = new ImGuiStyle(this);
        const native = new bind.ImGuiStyle();
        const _that = new ImGuiStyle(native);
        _that.Copy(_this);
        bind.StyleColorsClassic(native);
        _this.Copy(_that);
        native.delete();
    }
    ScaleAllSizes(scale_factor) {
        const _this = new ImGuiStyle(this);
        const native = new bind.ImGuiStyle();
        const _that = new ImGuiStyle(native);
        _that.Copy(_this);
        native.ScaleAllSizes(scale_factor);
        _this.Copy(_that);
        native.delete();
    }
}
class ImGuiStyle {
    internal;
    constructor(internal = new script_ImGuiStyle()){
        this.internal = internal;
        this.Colors = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return ImGuiCol.COUNT;
                }
                return this.internal._getAt_Colors(Number(key));
            },
            set: (target, key, value)=>{
                return this.internal._setAt_Colors(Number(key), value);
            }
        });
    }
    get Alpha() {
        return this.internal.Alpha;
    }
    set Alpha(value) {
        this.internal.Alpha = value;
    }
    get WindowPadding() {
        return this.internal.WindowPadding;
    }
    get WindowRounding() {
        return this.internal.WindowRounding;
    }
    set WindowRounding(value) {
        this.internal.WindowRounding = value;
    }
    get WindowBorderSize() {
        return this.internal.WindowBorderSize;
    }
    set WindowBorderSize(value) {
        this.internal.WindowBorderSize = value;
    }
    get WindowMinSize() {
        return this.internal.WindowMinSize;
    }
    get WindowTitleAlign() {
        return this.internal.WindowTitleAlign;
    }
    get WindowMenuButtonPosition() {
        return this.internal.WindowMenuButtonPosition;
    }
    set WindowMenuButtonPosition(value) {
        this.internal.WindowMenuButtonPosition = value;
    }
    get ChildRounding() {
        return this.internal.ChildRounding;
    }
    set ChildRounding(value) {
        this.internal.ChildRounding = value;
    }
    get ChildBorderSize() {
        return this.internal.ChildBorderSize;
    }
    set ChildBorderSize(value) {
        this.internal.ChildBorderSize = value;
    }
    get PopupRounding() {
        return this.internal.PopupRounding;
    }
    set PopupRounding(value) {
        this.internal.PopupRounding = value;
    }
    get PopupBorderSize() {
        return this.internal.PopupBorderSize;
    }
    set PopupBorderSize(value) {
        this.internal.PopupBorderSize = value;
    }
    get FramePadding() {
        return this.internal.FramePadding;
    }
    get FrameRounding() {
        return this.internal.FrameRounding;
    }
    set FrameRounding(value) {
        this.internal.FrameRounding = value;
    }
    get FrameBorderSize() {
        return this.internal.FrameBorderSize;
    }
    set FrameBorderSize(value) {
        this.internal.FrameBorderSize = value;
    }
    get ItemSpacing() {
        return this.internal.ItemSpacing;
    }
    get ItemInnerSpacing() {
        return this.internal.ItemInnerSpacing;
    }
    get CellPadding() {
        return this.internal.CellPadding;
    }
    get TouchExtraPadding() {
        return this.internal.TouchExtraPadding;
    }
    get IndentSpacing() {
        return this.internal.IndentSpacing;
    }
    set IndentSpacing(value) {
        this.internal.IndentSpacing = value;
    }
    get ColumnsMinSpacing() {
        return this.internal.ColumnsMinSpacing;
    }
    set ColumnsMinSpacing(value) {
        this.internal.ColumnsMinSpacing = value;
    }
    get ScrollbarSize() {
        return this.internal.ScrollbarSize;
    }
    set ScrollbarSize(value) {
        this.internal.ScrollbarSize = value;
    }
    get ScrollbarRounding() {
        return this.internal.ScrollbarRounding;
    }
    set ScrollbarRounding(value) {
        this.internal.ScrollbarRounding = value;
    }
    get GrabMinSize() {
        return this.internal.GrabMinSize;
    }
    set GrabMinSize(value) {
        this.internal.GrabMinSize = value;
    }
    get GrabRounding() {
        return this.internal.GrabRounding;
    }
    set GrabRounding(value) {
        this.internal.GrabRounding = value;
    }
    get LogSliderDeadzone() {
        return this.internal.LogSliderDeadzone;
    }
    set LogSliderDeadzone(value) {
        this.internal.LogSliderDeadzone = value;
    }
    get TabRounding() {
        return this.internal.TabRounding;
    }
    set TabRounding(value) {
        this.internal.TabRounding = value;
    }
    get TabBorderSize() {
        return this.internal.TabBorderSize;
    }
    set TabBorderSize(value) {
        this.internal.TabBorderSize = value;
    }
    get TabMinWidthForCloseButton() {
        return this.internal.TabMinWidthForCloseButton;
    }
    set TabMinWidthForCloseButton(value) {
        this.internal.TabMinWidthForCloseButton = value;
    }
    get ColorButtonPosition() {
        return this.internal.ColorButtonPosition;
    }
    set ColorButtonPosition(value) {
        this.internal.ColorButtonPosition = value;
    }
    get ButtonTextAlign() {
        return this.internal.ButtonTextAlign;
    }
    get SelectableTextAlign() {
        return this.internal.SelectableTextAlign;
    }
    get DisplayWindowPadding() {
        return this.internal.DisplayWindowPadding;
    }
    get DisplaySafeAreaPadding() {
        return this.internal.DisplaySafeAreaPadding;
    }
    get MouseCursorScale() {
        return this.internal.MouseCursorScale;
    }
    set MouseCursorScale(value) {
        this.internal.MouseCursorScale = value;
    }
    get AntiAliasedLines() {
        return this.internal.AntiAliasedLines;
    }
    set AntiAliasedLines(value) {
        this.internal.AntiAliasedLines = value;
    }
    get AntiAliasedLinesUseTex() {
        return this.internal.AntiAliasedLinesUseTex;
    }
    set AntiAliasedLinesUseTex(value) {
        this.internal.AntiAliasedLinesUseTex = value;
    }
    get AntiAliasedFill() {
        return this.internal.AntiAliasedFill;
    }
    set AntiAliasedFill(value) {
        this.internal.AntiAliasedFill = value;
    }
    get CurveTessellationTol() {
        return this.internal.CurveTessellationTol;
    }
    set CurveTessellationTol(value) {
        this.internal.CurveTessellationTol = value;
    }
    get CircleSegmentMaxError() {
        return this.internal.CircleSegmentMaxError;
    }
    set CircleSegmentMaxError(value) {
        this.internal.CircleSegmentMaxError = value;
    }
    Colors;
    Copy(other) {
        this.Alpha = other.Alpha;
        this.WindowPadding.Copy(other.WindowPadding);
        this.WindowRounding = other.WindowRounding;
        this.WindowBorderSize = other.WindowBorderSize;
        this.WindowMinSize.Copy(other.WindowMinSize);
        this.WindowTitleAlign.Copy(other.WindowTitleAlign);
        this.WindowMenuButtonPosition = other.WindowMenuButtonPosition;
        this.ChildRounding = other.ChildRounding;
        this.ChildBorderSize = other.ChildBorderSize;
        this.PopupRounding = other.PopupRounding;
        this.PopupBorderSize = other.PopupBorderSize;
        this.FramePadding.Copy(other.FramePadding);
        this.FrameRounding = other.FrameRounding;
        this.FrameBorderSize = other.FrameBorderSize;
        this.ItemSpacing.Copy(other.ItemSpacing);
        this.ItemInnerSpacing.Copy(other.ItemInnerSpacing);
        this.CellPadding.Copy(other.CellPadding);
        this.TouchExtraPadding.Copy(other.TouchExtraPadding);
        this.IndentSpacing = other.IndentSpacing;
        this.ColumnsMinSpacing = other.ColumnsMinSpacing;
        this.ScrollbarSize = other.ScrollbarSize;
        this.ScrollbarRounding = other.ScrollbarRounding;
        this.GrabMinSize = other.GrabMinSize;
        this.GrabRounding = other.GrabRounding;
        this.LogSliderDeadzone = other.LogSliderDeadzone;
        this.TabRounding = other.TabRounding;
        this.TabBorderSize = other.TabBorderSize;
        this.TabMinWidthForCloseButton = other.TabMinWidthForCloseButton;
        this.ColorButtonPosition = other.ColorButtonPosition;
        this.ButtonTextAlign.Copy(other.ButtonTextAlign);
        this.DisplayWindowPadding.Copy(other.DisplayWindowPadding);
        this.DisplaySafeAreaPadding.Copy(other.DisplaySafeAreaPadding);
        this.MouseCursorScale = other.MouseCursorScale;
        this.AntiAliasedLines = other.AntiAliasedLines;
        this.AntiAliasedLinesUseTex = other.AntiAliasedLinesUseTex;
        this.AntiAliasedFill = other.AntiAliasedFill;
        this.CurveTessellationTol = other.CurveTessellationTol;
        this.CircleSegmentMaxError = other.CircleSegmentMaxError;
        for(let i = 0; i < ImGuiCol.COUNT; ++i){
            this.Colors[i].Copy(other.Colors[i]);
        }
        return this;
    }
    ScaleAllSizes(scale_factor) {
        this.internal.ScaleAllSizes(scale_factor);
    }
}
class ImGuiIO {
    native;
    constructor(native){
        this.native = native;
        this.KeyMap = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return ImGuiKey.COUNT;
                }
                return this.native._getAt_KeyMap(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_KeyMap(Number(key), value);
            }
        });
        this.MouseDown = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return 5;
                }
                return this.native._getAt_MouseDown(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_MouseDown(Number(key), value);
            }
        });
        this.KeysDown = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return 512;
                }
                return this.native._getAt_KeysDown(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_KeysDown(Number(key), value);
            }
        });
        this.NavInputs = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return ImGuiNavInput.COUNT;
                }
                return this.native._getAt_NavInputs(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_NavInputs(Number(key), value);
            }
        });
        this.MouseClickedPos = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return 5;
                }
                return this.native._getAt_MouseClickedPos(Number(key));
            }
        });
        this.MouseDownDuration = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return 5;
                }
                return this.native._getAt_MouseDownDuration(Number(key));
            }
        });
        this.KeysDownDuration = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return 512;
                }
                return this.native._getAt_KeysDownDuration(Number(key));
            }
        });
        this.NavInputsDownDuration = new Proxy([], {
            get: (target, key)=>{
                if (key === "length") {
                    return ImGuiNavInput.COUNT;
                }
                return this.native._getAt_NavInputsDownDuration(Number(key));
            }
        });
    }
    //------------------------------------------------------------------
    // Settings (fill once)                 // Default value:
    //------------------------------------------------------------------
    // ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
    get ConfigFlags() {
        return this.native.ConfigFlags;
    }
    set ConfigFlags(value) {
        this.native.ConfigFlags = value;
    }
    // ImGuiBackendFlags  BackendFlags;        // = 0                  // Set ImGuiBackendFlags_ enum. Set by imgui_impl_xxx files or custom back-end to communicate features supported by the back-end.
    get BackendFlags() {
        return this.native.BackendFlags;
    }
    set BackendFlags(value) {
        this.native.BackendFlags = value;
    }
    // ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.
    get DisplaySize() {
        return this.native.DisplaySize;
    }
    // float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.
    get DeltaTime() {
        return this.native.DeltaTime;
    }
    set DeltaTime(value) {
        this.native.DeltaTime = value;
    }
    // float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.
    get IniSavingRate() {
        return this.native.IniSavingRate;
    }
    set IniSavingRate(value) {
        this.native.IniSavingRate = value;
    }
    // const char*   IniFilename;              // = "imgui.ini"        // Path to .ini file. NULL to disable .ini saving.
    get IniFilename() {
        return this.native.IniFilename;
    }
    set IniFilename(value) {
        this.native.IniFilename = value;
    }
    // const char*   LogFilename;              // = "imgui_log.txt"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    get LogFilename() {
        return this.native.LogFilename;
    }
    set LogFilename(value) {
        this.native.LogFilename = value;
    }
    // float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.
    get MouseDoubleClickTime() {
        return this.native.MouseDoubleClickTime;
    }
    set MouseDoubleClickTime(value) {
        this.native.MouseDoubleClickTime = value;
    }
    // float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.
    get MouseDoubleClickMaxDist() {
        return this.native.MouseDoubleClickMaxDist;
    }
    set MouseDoubleClickMaxDist(value) {
        this.native.MouseDoubleClickMaxDist = value;
    }
    // float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging
    get MouseDragThreshold() {
        return this.native.MouseDragThreshold;
    }
    set MouseDragThreshold(value) {
        this.native.MouseDragThreshold = value;
    }
    // int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array
    KeyMap;
    // float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    get KeyRepeatDelay() {
        return this.native.KeyRepeatDelay;
    }
    set KeyRepeatDelay(value) {
        this.native.KeyRepeatDelay = value;
    }
    // float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.
    get KeyRepeatRate() {
        return this.native.KeyRepeatRate;
    }
    set KeyRepeatRate(value) {
        this.native.KeyRepeatRate = value;
    }
    // void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.
    get UserData() {
        return this.native.UserData;
    }
    set UserData(value) {
        this.native.UserData = value;
    }
    // ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
    get Fonts() {
        return new ImFontAtlas(this.native.Fonts);
    }
    // float         FontGlobalScale;          // = 1.0f               // Global scale all fonts
    get FontGlobalScale() {
        return this.native.FontGlobalScale;
    }
    set FontGlobalScale(value) {
        this.native.FontGlobalScale = value;
    }
    // bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.
    get FontAllowUserScaling() {
        return this.native.FontAllowUserScaling;
    }
    set FontAllowUserScaling(value) {
        this.native.FontAllowUserScaling = value;
    }
    // ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
    get FontDefault() {
        const font = this.native.FontDefault;
        return font === null ? null : new ImFont(font);
    }
    set FontDefault(value) {
        this.native.FontDefault = value && value.native;
    }
    // ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.
    get DisplayFramebufferScale() {
        return this.native.DisplayFramebufferScale;
    }
    // Miscellaneous configuration options
    // bool          OptMacOSXBehaviors;       // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl
    get ConfigMacOSXBehaviors() {
        return this.native.ConfigMacOSXBehaviors;
    }
    set ConfigMacOSXBehaviors(value) {
        this.native.ConfigMacOSXBehaviors = value;
    }
    // bool          ConfigInputTextCursorBlink;   // = true               // Enable blinking cursor, for users who consider it annoying.
    get ConfigInputTextCursorBlink() {
        return this.native.ConfigInputTextCursorBlink;
    }
    set ConfigInputTextCursorBlink(value) {
        this.native.ConfigInputTextCursorBlink = value;
    }
    // bool        ConfigDragClickToInputText;     // = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
    get ConfigDragClickToInputText() {
        return this.native.ConfigDragClickToInputText;
    }
    set ConfigDragClickToInputText(value) {
        this.native.ConfigDragClickToInputText = value;
    }
    // bool          ConfigWindowsResizeFromEdges; // = false          // [BETA] Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the ImGuiWindowFlags_ResizeFromAnySide flag)
    get ConfigWindowsResizeFromEdges() {
        return this.native.ConfigWindowsResizeFromEdges;
    }
    set ConfigWindowsResizeFromEdges(value) {
        this.native.ConfigWindowsResizeFromEdges = value;
    }
    // bool        ConfigWindowsMoveFromTitleBarOnly;// = false        // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.
    get ConfigWindowsMoveFromTitleBarOnly() {
        return this.native.ConfigWindowsMoveFromTitleBarOnly;
    }
    set ConfigWindowsMoveFromTitleBarOnly(value) {
        this.native.ConfigWindowsMoveFromTitleBarOnly = value;
    }
    // float       ConfigMemoryCompactTimer;       // = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
    get ConfigMemoryCompactTimer() {
        return this.native.ConfigMemoryCompactTimer;
    }
    set ConfigMemoryCompactTimer(value) {
        this.native.ConfigMemoryCompactTimer = value;
    }
    //------------------------------------------------------------------
    // Settings (User Functions)
    //------------------------------------------------------------------
    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
    // const char* BackendPlatformName;            // = NULL
    get BackendPlatformName() {
        return this.native.BackendPlatformName;
    }
    set BackendPlatformName(value) {
        this.native.BackendPlatformName = value;
    }
    // const char* BackendRendererName;            // = NULL
    get BackendRendererName() {
        return this.native.BackendRendererName;
    }
    set BackendRendererName(value) {
        this.native.BackendRendererName = value;
    }
    // void*       BackendPlatformUserData;        // = NULL
    get BackendPlatformUserData() {
        return this.native.BackendPlatformUserData;
    }
    set BackendPlatformUserData(value) {
        this.native.BackendPlatformUserData = value;
    }
    // void*       BackendRendererUserData;        // = NULL
    get BackendRendererUserData() {
        return this.native.BackendRendererUserData;
    }
    set BackendRendererUserData(value) {
        this.native.BackendRendererUserData = value;
    }
    // void*       BackendLanguageUserData;        // = NULL
    get BackendLanguageUserData() {
        return this.native.BackendLanguageUserData;
    }
    set BackendLanguageUserData(value) {
        this.native.BackendLanguageUserData = value;
    }
    // Optional: access OS clipboard
    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
    // const char* (*GetClipboardTextFn)(void* user_data);
    get GetClipboardTextFn() {
        return this.native.GetClipboardTextFn;
    }
    set GetClipboardTextFn(value) {
        this.native.GetClipboardTextFn = value;
    }
    // void        (*SetClipboardTextFn)(void* user_data, const char* text);
    get SetClipboardTextFn() {
        return this.native.SetClipboardTextFn;
    }
    set SetClipboardTextFn(value) {
        this.native.SetClipboardTextFn = value;
    }
    // void*       ClipboardUserData;
    get ClipboardUserData() {
        return this.native.ClipboardUserData;
    }
    set ClipboardUserData(value) {
        this.native.ClipboardUserData = value;
    }
    // Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.
    // (default to posix malloc/free)
    // void*       (*MemAllocFn)(size_t sz);
    // void        (*MemFreeFn)(void* ptr);
    // Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)
    // (default to use native imm32 api on Windows)
    // void        (*ImeSetInputScreenPosFn)(int x, int y);
    // void*       ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.
    //------------------------------------------------------------------
    // Input - Fill before calling NewFrame()
    //------------------------------------------------------------------
    // ImVec2      MousePos;                   // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
    get MousePos() {
        return this.native.MousePos;
    }
    // bool        MouseDown[5];               // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    MouseDown;
    // float       MouseWheel;                 // Mouse wheel: 1 unit scrolls about 5 lines text.
    get MouseWheel() {
        return this.native.MouseWheel;
    }
    set MouseWheel(value) {
        this.native.MouseWheel = value;
    }
    // float       MouseWheelH;                    // Mouse wheel (Horizontal). Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
    get MouseWheelH() {
        return this.native.MouseWheelH;
    }
    set MouseWheelH(value) {
        this.native.MouseWheelH = value;
    }
    // bool        MouseDrawCursor;            // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).
    get MouseDrawCursor() {
        return this.native.MouseDrawCursor;
    }
    set MouseDrawCursor(value) {
        this.native.MouseDrawCursor = value;
    }
    // bool        KeyCtrl;                    // Keyboard modifier pressed: Control
    get KeyCtrl() {
        return this.native.KeyCtrl;
    }
    set KeyCtrl(value) {
        this.native.KeyCtrl = value;
    }
    // bool        KeyShift;                   // Keyboard modifier pressed: Shift
    get KeyShift() {
        return this.native.KeyShift;
    }
    set KeyShift(value) {
        this.native.KeyShift = value;
    }
    // bool        KeyAlt;                     // Keyboard modifier pressed: Alt
    get KeyAlt() {
        return this.native.KeyAlt;
    }
    set KeyAlt(value) {
        this.native.KeyAlt = value;
    }
    // bool        KeySuper;                   // Keyboard modifier pressed: Cmd/Super/Windows
    get KeySuper() {
        return this.native.KeySuper;
    }
    set KeySuper(value) {
        this.native.KeySuper = value;
    }
    // bool        KeysDown[512];              // Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)
    KeysDown;
    // float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame)
    NavInputs;
    // Functions
    // IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]
    AddInputCharacter(c) {
        this.native.AddInputCharacter(c);
    }
    // IMGUI_API void  AddInputCharacterUTF16(ImWchar16 c);        // Queue new character input from an UTF-16 character, it can be a surrogate
    AddInputCharacterUTF16(c) {
        this.native.AddInputCharacterUTF16(c);
    }
    // IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string
    AddInputCharactersUTF8(utf8_chars) {
        this.native.AddInputCharactersUTF8(utf8_chars);
    }
    // inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually
    ClearInputCharacters() {
        this.native.ClearInputCharacters();
    }
    //------------------------------------------------------------------
    // Output - Retrieve after calling NewFrame()
    //------------------------------------------------------------------
    // bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application. This is set by ImGui when it wants to use your mouse (e.g. unclicked mouse is hovering a window, or a widget is active).
    get WantCaptureMouse() {
        return this.native.WantCaptureMouse;
    }
    set WantCaptureMouse(value) {
        this.native.WantCaptureMouse = value;
    }
    // bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application. This is set by ImGui when it wants to use your keyboard inputs.
    get WantCaptureKeyboard() {
        return this.native.WantCaptureKeyboard;
    }
    set WantCaptureKeyboard(value) {
        this.native.WantCaptureKeyboard = value;
    }
    // bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    get WantTextInput() {
        return this.native.WantTextInput;
    }
    set WantTextInput(value) {
        this.native.WantTextInput = value;
    }
    // bool        WantSetMousePos;              // [BETA-NAV] MousePos has been altered, back-end should reposition mouse on next frame. Set only when 'NavMovesMouse=true'.
    get WantSetMousePos() {
        return this.native.WantSetMousePos;
    }
    set WantSetMousePos(value) {
        this.native.WantSetMousePos = value;
    }
    // bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
    get WantSaveIniSettings() {
        return this.native.WantSaveIniSettings;
    }
    set WantSaveIniSettings(value) {
        this.native.WantSaveIniSettings = value;
    }
    // bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    get NavActive() {
        return this.native.NavActive;
    }
    set NavActive(value) {
        this.native.NavActive = value;
    }
    // bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
    get NavVisible() {
        return this.native.NavVisible;
    }
    set NavVisible(value) {
        this.native.NavVisible = value;
    }
    // float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
    get Framerate() {
        return this.native.Framerate;
    }
    // int         MetricsRenderVertices;      // Vertices output during last call to Render()
    get MetricsRenderVertices() {
        return this.native.MetricsRenderVertices;
    }
    // int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3
    get MetricsRenderIndices() {
        return this.native.MetricsRenderIndices;
    }
    // int         MetricsRenderWindows;       // Number of visible windows
    get MetricsRenderWindows() {
        return this.native.MetricsRenderWindows;
    }
    // int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)
    get MetricsActiveWindows() {
        return this.native.MetricsActiveWindows;
    }
    // int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
    get MetricsActiveAllocations() {
        return this.native.MetricsActiveAllocations;
    }
    // ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
    get MouseDelta() {
        return this.native.MouseDelta;
    }
    //------------------------------------------------------------------
    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
    //------------------------------------------------------------------
    // ImGuiKeyModFlags KeyMods;                   // Key mods flags (same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags), updated by NewFrame()
    // ImVec2      MousePosPrev;               // Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())
    // ImVec2      MouseClickedPos[5];         // Position at time of clicking
    MouseClickedPos;
    // float       MouseClickedTime[5];        // Time of last click (used to figure out double-click)
    // bool        MouseClicked[5];            // Mouse button went from !Down to Down
    // bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?
    // bool        MouseReleased[5];           // Mouse button went from Down to !Down
    // bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.
    // float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)
    MouseDownDuration;
    // float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down
    // ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
    // float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point
    // float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)
    KeysDownDuration;
    // float       KeysDownDurationPrev[512];  // Previous duration the key has been down
    // float       NavInputsDownDuration[ImGuiNavInput_COUNT];
    NavInputsDownDuration;
}
// Context creation and access
// Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.
// None of those functions is reliant on the current context.
// IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
// IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
// IMGUI_API ImGuiContext* GetCurrentContext();
// IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
class ImGuiContext {
    native;
    static current_ctx = null;
    static getTexture(index) {
        if (ImGuiContext.current_ctx === null) {
            throw new Error();
        }
        return ImGuiContext.current_ctx._getTexture(index);
    }
    static setTexture(texture) {
        if (ImGuiContext.current_ctx === null) {
            throw new Error();
        }
        return ImGuiContext.current_ctx._setTexture(texture);
    }
    static textures = [];
    constructor(native){
        this.native = native;
    }
    _getTexture(index) {
        return ImGuiContext.textures[index] || null;
    }
    _setTexture(texture) {
        let index = ImGuiContext.textures.indexOf(texture);
        if (index === -1) {
            for(let i = 0; i < ImGuiContext.textures.length; ++i){
                if (ImGuiContext.textures[i] === null) {
                    ImGuiContext.textures[i] = texture;
                    return i;
                }
            }
            index = ImGuiContext.textures.length;
            ImGuiContext.textures.push(texture);
        }
        return index;
    }
}
function CreateContext(shared_font_atlas = null) {
    const ctx = new ImGuiContext(bind.CreateContext(shared_font_atlas !== null ? shared_font_atlas.native : null));
    if (ImGuiContext.current_ctx === null) {
        ImGuiContext.current_ctx = ctx;
    }
    return ctx;
}
// Main
// IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
// IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame!
// IMGUI_API void          NewFrame();                                 // start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
// IMGUI_API void          EndFrame();                                 // ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
// IMGUI_API void          Render();                                   // ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
// IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render.
function GetIO() {
    return new ImGuiIO(bind.GetIO());
}
function NewFrame$1() {
    bind.NewFrame();
}
function EndFrame() {
    bind.EndFrame();
}
function Render() {
    bind.Render();
}
function GetDrawData() {
    const draw_data = bind.GetDrawData();
    return draw_data === null ? null : new ImDrawData(draw_data);
}
// Styles
// IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)
// IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font
// IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
function StyleColorsDark(dst = null) {
    if (dst === null) {
        bind.StyleColorsDark(null);
    } else if (dst.internal instanceof bind.ImGuiStyle) {
        bind.StyleColorsDark(dst.internal);
    } else {
        const native = new bind.ImGuiStyle();
        const wrap = new ImGuiStyle(native);
        wrap.Copy(dst);
        bind.StyleColorsDark(native);
        dst.Copy(wrap);
        native.delete();
    }
}
// Windows
// - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
// - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
//   which clicking will set the boolean to false when clicked.
// - You may append multiple times to the same window during the same frame by calling Begin()/End() pairs multiple times.
//   Some information such as 'flags' or 'p_open' will only be considered by the first call to Begin().
// - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
//   [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu/EndMenu,
//    BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function
//    returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// - Note that the bottom of window stack always contains a window called "Debug".
// IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
// IMGUI_API void          End();
function Begin(name, open = null, flags = 0) {
    if (open === null) {
        return bind.Begin(name, null, flags);
    } else if (Array.isArray(open)) {
        return bind.Begin(name, open, flags);
    } else {
        const ref_open = [
            open()
        ];
        const opened = bind.Begin(name, ref_open, flags);
        open(ref_open[0]);
        return opened;
    }
}
function End() {
    bind.End();
}
function SetNextWindowSize(pos, cond = 0) {
    bind.SetNextWindowSize(pos, cond);
}
function DragInt(label, v, v_speed = 1.0, v_min = 0, v_max = 0, format = "%d", flags = 0) {
    const _v = import_Scalar(v);
    const ret = bind.DragInt(label, _v, v_speed, v_min, v_max, format, flags);
    export_Scalar(_v, v);
    return ret;
}
function GetMouseCursor() {
    return bind.GetMouseCursor();
}
function LoadIniSettingsFromMemory(ini_data, ini_size = 0) {
    bind.LoadIniSettingsFromMemory(ini_data);
}
function SaveIniSettingsToMemory(out_ini_size = null) {
    return bind.SaveIniSettingsToMemory();
}
// Debug Utilities
// IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx); // This is called by IMGUI_CHECKVERSION() macro.
function DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_draw_vert, sz_draw_idx) {
    return bind.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_draw_vert, sz_draw_idx);
}
class ImGuiWindow {
    native;
    constructor(native){
        this.native = native;
    }
    get ID() {
        return this.native.ID;
    }
    get Flags() {
        return this.native.Flags;
    }
    set Flags(f) {
        this.native.Flags = f;
    }
    get Pos() {
        return this.native.Pos;
    }
    set Pos(v) {
        this.native.Pos.Set(v.x, v.y);
    }
    get Size() {
        return this.native.Size;
    }
    set Size(v) {
        this.native.Size.Set(v.x, v.y);
    }
    get SizeFull() {
        return this.native.SizeFull;
    }
    set SizeFull(v) {
        this.native.SizeFull.Set(v.x, v.y);
    }
    get ContentSize() {
        return this.native.ContentSize;
    }
    set ContentSize(v) {
        this.native.ContentSize.Set(v.x, v.y);
    }
    get ContentSizeIdeal() {
        return this.native.ContentSizeIdeal;
    }
    set ContentSizeIdeal(v) {
        this.native.ContentSizeIdeal.Set(v.x, v.y);
    }
    get ContentSizeExplicit() {
        return this.native.ContentSizeExplicit;
    }
    set ContentSizeExplicit(v) {
        this.native.ContentSizeExplicit.Set(v.x, v.y);
    }
    get WindowPadding() {
        return this.native.WindowPadding;
    }
    set WindowPadding(v) {
        this.native.WindowPadding.Set(v.x, v.y);
    }
    get WindowRounding() {
        return this.native.WindowRounding;
    }
    set WindowRounding(v) {
        this.native.WindowRounding = v;
    }
    get WindowBorderSize() {
        return this.native.WindowBorderSize;
    }
    set WindowBorderSize(v) {
        this.native.WindowBorderSize = v;
    }
    get ClipRect() {
        return this.native.ClipRect;
    }
    set ClipRect(v) {
        this.native.ClipRect.Min.Set(v.Min.x, v.Min.y);
        this.native.ClipRect.Max.Set(v.Max.x, v.Max.y);
    }
    get WorkRect() {
        return this.native.WorkRect;
    }
    set WorkRect(v) {
        this.native.WorkRect.Min.Set(v.Min.x, v.Min.y);
        this.native.WorkRect.Max.Set(v.Max.x, v.Max.y);
    }
    get InnerRect() {
        return this.native.InnerRect;
    }
    set InnerRect(v) {
        this.native.InnerRect.Min.Set(v.Min.x, v.Min.y);
        this.native.InnerRect.Max.Set(v.Max.x, v.Max.y);
    }
    get Scroll() {
        return this.native.Scroll;
    }
    set Scroll(v) {
        this.native.Scroll.Set(v.x, v.y);
    }
    get ScrollMax() {
        return this.native.ScrollMax;
    }
    set ScrollMax(v) {
        this.native.ScrollMax.Set(v.x, v.y);
    }
    get ScrollTarget() {
        return this.native.ScrollTarget;
    }
    set ScrollTarget(v) {
        this.native.ScrollTarget.Set(v.x, v.y);
    }
    get ScrollTargetCenterRatio() {
        return this.native.ScrollTargetCenterRatio;
    }
    set ScrollTargetCenterRatio(v) {
        this.native.ScrollTargetCenterRatio.Set(v.x, v.y);
    }
    get ScrollTargetEdgeSnapDist() {
        return this.native.ScrollTargetEdgeSnapDist;
    }
    set ScrollTargetEdgeSnapDist(v) {
        this.native.ScrollTargetEdgeSnapDist.Set(v.x, v.y);
    }
    get ScrollbarSizes() {
        return this.native.ScrollbarSizes;
    }
    set ScrollbarSizes(v) {
        this.native.ScrollbarSizes.Set(v.x, v.y);
    }
    get ScrollbarX() {
        return this.native.ScrollbarX;
    }
    get ScrollbarY() {
        return this.native.ScrollbarY;
    }
    get Active() {
        return this.native.Active;
    }
    get WasActive() {
        return this.native.WasActive;
    }
    get ItemWidthDefault() {
        return this.native.ItemWidthDefault;
    }
    set ItemWidthDefault(v) {
        this.native.ItemWidthDefault = v;
    }
    get ParentWindow() {
        return this.native.ParentWindow ? new ImGuiWindow(this.native.ParentWindow) : null;
    }
    get RootWindow() {
        return this.native.RootWindow ? new ImGuiWindow(this.native.RootWindow) : null;
    }
    get RootWindowForTitleBarHighlight() {
        return this.native.RootWindowForTitleBarHighlight ? new ImGuiWindow(this.native.RootWindowForTitleBarHighlight) : null;
    }
    get RootWindowForNav() {
        return this.native.RootWindowForNav ? new ImGuiWindow(this.native.RootWindowForNav) : null;
    }
}
function GetHoveredWindow() {
    return bind.GetHoveredWindow() ? new ImGuiWindow(bind.GetHoveredWindow()) : null;
}
function GetHoveredId() {
    return bind.GetHoveredId();
}
function GetActiveId() {
    return bind.GetActiveId();
}
function GetInputTextId() {
    return bind.GetInputTextId();
}

class Renderer {
    /** @internal */ static VERTEX_BUFFER_SIZE = 8192;
    /** @internal */ static INDEX_BUFFER_SIZE = 16384;
    /** @internal */ _device;
    /** @internal */ _primitiveBuffer;
    /** @internal */ _activeBuffer;
    /** @internal */ _drawPosition;
    /** @internal */ _indexPosition;
    /** @internal */ _drawCount;
    /** @internal */ _indexCount;
    /** @internal */ _currentTexture;
    /** @internal */ _program;
    /** @internal */ _textureSampler;
    /** @internal */ _programTexture;
    /** @internal */ _bindGroup;
    /** @internal */ _bindGroupTexture;
    /** @internal */ _renderStateSet;
    /** @internal */ _vertexCache;
    /** @internal */ _indexCache;
    /** @internal */ _projectionMatrix;
    /** @internal */ _flipMatrix;
    /** @internal */ _scissor;
    /** @internal */ _clearBeforeRender;
    /**
   * Creates a renderer instance
   * @param device - The render device
   */ constructor(device){
        this._device = device;
        this._projectionMatrix = new Matrix4x4();
        this._flipMatrix = new Matrix4x4();
        this._program = this.createProgram(false);
        this._programTexture = this.createProgram(true);
        this._bindGroup = this._device.createBindGroup(this._program.bindGroupLayouts[0]);
        this._bindGroupTexture = this._device.createBindGroup(this._programTexture.bindGroupLayouts[0]);
        this._textureSampler = this._device.createSampler({
            magFilter: 'nearest',
            minFilter: 'nearest',
            mipFilter: 'none'
        });
        this._renderStateSet = this.createStateSet();
        this._primitiveBuffer = [];
        this._activeBuffer = 0;
        this._vertexCache = new Uint8Array(Renderer.VERTEX_BUFFER_SIZE * 20);
        this._indexCache = new Uint16Array(Renderer.INDEX_BUFFER_SIZE);
        for(let i = 0; i < 2; i++){
            const opt = {
                vertexBuffers: [
                    {
                        buffer: this._device.createInterleavedVertexBuffer([
                            'position_f32x2',
                            'tex0_f32x2',
                            'diffuse_u8normx4'
                        ], this._vertexCache, {
                            dynamic: true
                        })
                    }
                ],
                indexBuffer: this._device.createIndexBuffer(this._indexCache, {
                    dynamic: true
                })
            };
            this._primitiveBuffer.push(this._device.createVertexLayout(opt));
        }
        this._drawPosition = 0;
        this._indexPosition = 0;
        this._drawCount = 0;
        this._indexCount = 0;
        this._scissor = [
            0,
            0,
            0,
            0
        ];
        this._currentTexture = null;
        this._clearBeforeRender = false;
    }
    /** Gets the render device */ get device() {
        return this._device;
    }
    get clearBeforeRender() {
        return this._clearBeforeRender;
    }
    set clearBeforeRender(val) {
        this._clearBeforeRender = val;
    }
    /** Disposes this renderer */ dispose() {
        this._primitiveBuffer = null;
        this._vertexCache = null;
        this._device = null;
    }
    /** @internal */ getCanvas() {
        return this._device.canvas;
    }
    /** @internal */ getDrawingBufferWidth() {
        return this._device.deviceToScreen(this._device.getDrawingBufferWidth());
    }
    /** @internal */ getDrawingBufferHeight() {
        return this._device.deviceToScreen(this._device.getDrawingBufferHeight());
    }
    /** @internal */ screenToDevice(val) {
        return this._device.screenToDevice(val);
    }
    /** @internal */ deviceToScreen(val) {
        return this._device.deviceToScreen(val);
    }
    /** @internal */ createTexture(width, height, color, linear) {
        const tex = this._device.createTexture2D(linear ? 'rgba8unorm' : 'rgba8unorm-srgb', width, height, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        if (color) {
            this.clearTexture(tex, color);
        }
        return tex;
    }
    /** @internal */ clearTexture(tex, color) {
        const pixels = new Uint8Array(tex.width * tex.height * 4);
        const r = Math.round(color.r * 255);
        const g = Math.round(color.g * 255);
        const b = Math.round(color.b * 255);
        const a = Math.round(color.a * 255);
        for(let i = 0; i < tex.width * tex.height; i++){
            pixels[i * 4 + 0] = r;
            pixels[i * 4 + 1] = g;
            pixels[i * 4 + 2] = b;
            pixels[i * 4 + 3] = a;
        }
        tex.update(pixels, 0, 0, tex.width, tex.height);
    }
    /** @internal */ updateTextureWithImage(texture, bitmap, x, y) {
        const originValues = new Uint8Array(bitmap.data.buffer);
        console.assert(texture.format === 'rgba8unorm');
        texture.update(originValues, x, y, bitmap.width, bitmap.height);
    }
    /** @internal */ updateTextureWithCanvas(texture, ctx, cvsOffsetX, cvsOffsetY, w, h, x, y) {
        texture.updateFromElement(ctx.canvas, x, y, cvsOffsetX, cvsOffsetY, w, h);
    }
    /** @internal */ getTextureWidth(texture) {
        return texture.width;
    }
    /** @internal */ getTextureHeight(texture) {
        return texture.height;
    }
    /** @internal */ disposeTexture(texture) {
        texture?.dispose();
    }
    /** @internal */ setCursorStyle(style) {
        this.getCanvas().style.cursor = style;
    }
    /** @internal */ getCursorStyle() {
        return this.getCanvas().style.cursor;
    }
    /** @internal */ stream(vertexData, indexData, indexOffset, indexCount, texture, scissor) {
        let tex = texture || null;
        if (tex?.disposed) {
            tex = null;
        }
        const vertexCount = vertexData.length / 20;
        const overflow = this._drawPosition + vertexCount > Renderer.VERTEX_BUFFER_SIZE || this._indexPosition + indexCount > Renderer.INDEX_BUFFER_SIZE;
        if (overflow) {
            this._drawPosition = 0;
            this._indexPosition = 0;
            this._activeBuffer = 1 - this._activeBuffer;
        }
        const vertexLayout = this._primitiveBuffer[this._activeBuffer];
        const alignedIndexCount = indexCount + 1 & ~1;
        if (indexData.length < indexOffset + alignedIndexCount) {
            const alignedIndexData = new Uint16Array(alignedIndexCount);
            alignedIndexData.set(indexData.subarray(indexOffset));
            indexData = alignedIndexData;
            indexOffset = 0;
        }
        const vertexBuffer = vertexLayout.getVertexBuffer('position');
        vertexBuffer.bufferSubData(this._drawPosition * 20, vertexData, 0, vertexCount * 20);
        vertexLayout.getIndexBuffer().bufferSubData(this._indexPosition * 2, indexData, indexOffset, alignedIndexCount);
        vertexLayout.setDrawOffset(vertexBuffer, this._drawPosition * 20);
        if (texture) {
            this._device.setProgram(this._programTexture);
            this._bindGroupTexture.setTexture('tex', texture, this._textureSampler);
            this._device.setBindGroup(0, this._bindGroupTexture);
        } else {
            this._device.setProgram(this._program);
            this._device.setBindGroup(0, this._bindGroup);
        }
        this._device.setRenderStates(this._renderStateSet);
        this._device.setVertexLayout(vertexLayout);
        this._device.setScissor(scissor);
        vertexLayout.draw('triangle-list', this._indexPosition, indexCount);
        this._drawPosition += vertexCount;
        this._indexPosition += alignedIndexCount;
    }
    /** @internal */ beginRender() {
        const vp = this._device.getViewport();
        //this._device.setViewport();
        //this._device.setScissor();
        this._projectionMatrix.ortho(0, vp.width, 0, vp.height, -1, 1);
        this._flipMatrix = Matrix4x4.translation(new Vector3(0, vp.height, 0)).scaleRight(new Vector3(1, -1, 1));
        const mvpMatrix = Matrix4x4.multiply(this._projectionMatrix, this._flipMatrix);
        this._bindGroup.setValue('mvpMatrix', mvpMatrix);
        this._bindGroupTexture.setValue('mvpMatrix', mvpMatrix);
        if (this._clearBeforeRender) {
            this._device.clearFrameBuffer(new Vector4(0, 0, 0, 1), 1, 0);
        }
    }
    /** @internal */ endRender() {}
    /** @internal */ createStateSet() {
        const rs = this._device.createRenderStateSet();
        rs.useBlendingState().enable(true).setBlendFunc('one', 'inv-src-alpha');
        rs.useDepthState().enableTest(false).enableWrite(false);
        rs.useRasterizerState().setCullMode('none');
        return rs;
    }
    /** @internal */ createProgram(diffuseMap) {
        return this._device.buildRenderProgram({
            label: 'UI',
            vertex (pb) {
                this.$inputs.pos = pb.vec2().attrib('position');
                this.$inputs.uv = pb.vec2().attrib('texCoord0');
                this.$inputs.diffuse = pb.vec4().attrib('diffuse');
                this.$outputs.outDiffuse = pb.vec4();
                if (diffuseMap) {
                    this.$outputs.outUV = pb.vec2();
                }
                this.mvpMatrix = pb.mat4().uniform(0);
                pb.main(function() {
                    this.$builtins.position = pb.mul(this.mvpMatrix, pb.vec4(this.$inputs.pos, 0, 1));
                    this.$outputs.outDiffuse = this.$inputs.diffuse;
                    if (diffuseMap) {
                        this.$outputs.outUV = this.$inputs.uv;
                    }
                });
            },
            fragment (pb) {
                this.$outputs.outColor = pb.vec4();
                if (diffuseMap) {
                    this.tex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                }
                pb.main(function() {
                    if (diffuseMap) {
                        this.$l.color = pb.mul(pb.textureSample(this.tex, this.$inputs.outUV), this.$inputs.outDiffuse);
                    } else {
                        this.$l.color = this.$inputs.outDiffuse;
                    }
                    this.$outputs.outColor = pb.vec4(pb.mul(this.color.rgb, this.color.a), this.color.a);
                });
            }
        });
    }
}

class Input {
    _dom_input;
    constructor(){
        this._dom_input = document.createElement('input');
        this._dom_input.style.position = 'fixed';
        this._dom_input.style.top = -10000 + 'px';
        this._dom_input.style.left = -10000 + 'px';
        this._dom_input.addEventListener('keydown', (e)=>{
            this.onKeydown(e);
        });
        this._dom_input.addEventListener('keyup', (e)=>{
            this.onKeyup(e);
        });
        this._dom_input.addEventListener('keypress', (e)=>{
            this.onKeypress(e);
        });
        this._dom_input.addEventListener('compositionend', (e)=>{
            this.onCompositionEnd(e);
        });
        document.body.appendChild(this._dom_input);
    }
    onKeydown(e) {
        canvas_on_keydown(e);
    }
    onKeyup(e) {
        canvas_on_keyup(e);
    }
    onKeypress(e) {
        e.preventDefault();
        console.log(`key pressed: `);
        console.log(e);
        canvas_on_keypress(e);
    }
    onCompositionEnd(e) {
        e.preventDefault();
        for(let i = 0; i < e.data.length; i++){
            const io = GetIO();
            io.AddInputCharacter(e.data.charCodeAt(i));
        }
    }
    blur() {
        this._dom_input.blur();
    }
    focus() {
        this._dom_input.focus();
    }
}

let clipboard_text = "";
let renderer = null;
let prev_time = 0;
let g_FontTexture = null;
let glyphManager = null;
const fonts = {};
/*
function document_on_copy(event: ClipboardEvent): void {
    if (event.clipboardData) {
        event.clipboardData.setData("text/plain", clipboard_text);
    }
    // console.log(`${event.type}: "${clipboard_text}"`);
    event.preventDefault();
}

function document_on_cut(event: ClipboardEvent): void {
    if (event.clipboardData) {
        event.clipboardData.setData("text/plain", clipboard_text);
    }
    // console.log(`${event.type}: "${clipboard_text}"`);
    event.preventDefault();
}

function document_on_paste(event: ClipboardEvent): void {
    if (event.clipboardData) {
        clipboard_text = event.clipboardData.getData("text/plain");
    }
    // console.log(`${event.type}: "${clipboard_text}"`);
    event.preventDefault();
}
*/ function window_on_resize() {}
function window_on_gamepadconnected(event /* GamepadEvent */ ) {
    console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.", event.gamepad.index, event.gamepad.id, event.gamepad.buttons.length, event.gamepad.axes.length);
}
function window_on_gamepaddisconnected(event /* GamepadEvent */ ) {
    console.log("Gamepad disconnected at index %d: %s.", event.gamepad.index, event.gamepad.id);
}
function canvas_on_blur(event) {
    const io = GetIO();
    io.KeyCtrl = false;
    io.KeyShift = false;
    io.KeyAlt = false;
    io.KeySuper = false;
    for(let i = 0; i < io.KeysDown.length; ++i){
        io.KeysDown[i] = false;
    }
    for(let i = 0; i < io.MouseDown.length; ++i){
        io.MouseDown[i] = false;
    }
    console.log("canvas_on_blur");
}
const key_code_to_index = {
    "Tab": 9,
    "Backspace": 8,
    "Space": 32,
    "Insert": 45,
    "Delete": 46,
    "Home": 36,
    "End": 35,
    "PageUp": 33,
    "PageDown": 34,
    "Enter": 13,
    "Escape": 27,
    "ArrowLeft": 37,
    "ArrowUp": 38,
    "ArrowRight": 39,
    "ArrowDown": 40,
    "NumpadEnter": 176,
    "KeyA": 65,
    "KeyC": 67,
    "KeyV": 86,
    "KeyX": 88,
    "KeyY": 89,
    "KeyZ": 90
};
function canvas_on_keydown(event) {
    const key_index = key_code_to_index[event.code];
    if (key_index) {
        //console.log(event.type, event.key, event.code, key_index);
        const io = GetIO();
        io.KeyCtrl = event.ctrlKey;
        io.KeyShift = event.shiftKey;
        io.KeyAlt = event.altKey;
        io.KeySuper = event.metaKey;
        ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(io.KeysDown));
        io.KeysDown[key_index] = true;
        // forward to the keypress event
        if (key_index == 9 || io.WantCaptureKeyboard || io.WantTextInput) {
            return true;
        }
    }
    return false;
}
function canvas_on_keyup(event) {
    const key_index = key_code_to_index[event.code];
    if (key_index) {
        //console.log(event.type, event.key, event.code, key_index);
        const io = GetIO();
        io.KeyCtrl = event.ctrlKey;
        io.KeyShift = event.shiftKey;
        io.KeyAlt = event.altKey;
        io.KeySuper = event.metaKey;
        ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(io.KeysDown));
        io.KeysDown[key_index] = false;
        if (io.WantCaptureKeyboard || io.WantTextInput || key_index == 9) {
            return true;
        }
    }
    return false;
}
function canvas_on_keypress(event) {
    //console.log(event);
    const io = GetIO();
    io.AddInputCharacter(event.charCode);
    if (io.WantCaptureKeyboard || io.WantTextInput) {
        return true;
    }
    return false;
}
function canvas_on_pointermove(event) {
    const io = GetIO();
    io.MousePos.x = event.offsetX;
    io.MousePos.y = event.offsetY;
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
// MouseEvent.button
// A number representing a given button:
// 0: Main button pressed, usually the left button or the un-initialized state
// 1: Auxiliary button pressed, usually the wheel button or the middle button (if present)
// 2: Secondary button pressed, usually the right button
// 3: Fourth button, typically the Browser Back button
// 4: Fifth button, typically the Browser Forward button
const mouse_button_map = [
    0,
    2,
    1,
    3,
    4
];
function canvas_on_pointerdown(event) {
    const io = GetIO();
    io.MousePos.x = event.offsetX;
    io.MousePos.y = event.offsetY;
    io.MouseDown[mouse_button_map[event.button]] = true;
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function canvas_on_contextmenu(event) {
    const io = GetIO();
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function canvas_on_pointerup(event) {
    const io = GetIO();
    io.MouseDown[mouse_button_map[event.button]] = false;
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function canvas_on_wheel(event) {
    const io = GetIO();
    let scale = 1.0;
    switch(event.deltaMode){
        case event.DOM_DELTA_PIXEL:
            scale = 0.01;
            break;
        case event.DOM_DELTA_LINE:
            scale = 0.2;
            break;
        case event.DOM_DELTA_PAGE:
            scale = 1.0;
            break;
    }
    io.MouseWheelH = event.deltaX * scale;
    io.MouseWheel = -event.deltaY * scale; // Mouse wheel: 1 unit scrolls about 5 lines text.
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function injectKeyEvent(ev) {
    if (ev.type === 'keydown') {
        return canvas_on_keydown(ev);
    } else if (ev.type === 'keyup') {
        return canvas_on_keyup(ev);
    } else if (ev.type === 'keypress') {
        return canvas_on_keypress(ev);
    }
    return false;
}
function injectWheelEvent(ev) {
    return canvas_on_wheel(ev);
}
function injectPointerEvent(ev) {
    if (ev.type === 'pointermove') {
        return canvas_on_pointermove(ev);
    } else if (ev.type === 'pointerdown') {
        return canvas_on_pointerdown(ev);
    } else if (ev.type === 'pointerup') {
        return canvas_on_pointerup(ev);
    }
    return false;
}
/*
function canvas_on_contextlost(e:Event):void {
    e.preventDefault();
    console.log("canvas_on_contextlost");
    is_contextlost=true;
}

function canvas_on_contextrestored(e:Event):void {
    console.log("canvas_on_contextrestored");
    is_contextlost=false;
}
*/ function Init(device) {
    const io = GetIO();
    if (typeof window !== "undefined") {
        io.BackendPlatformName = "imgui_impl_browser";
        LoadIniSettingsFromMemory(window.localStorage.getItem("imgui.ini") || "");
    } else {
        io.BackendPlatformName = "imgui_impl_console";
    }
    if (typeof navigator !== "undefined") {
        io.ConfigMacOSXBehaviors = navigator.platform.match(/Mac/) !== null;
    }
    /*
    if (typeof(document) !== "undefined") {
        document.body.addEventListener("copy", document_on_copy);
        document.body.addEventListener("cut", document_on_cut);
        document.body.addEventListener("paste", document_on_paste);
    }
    */ io.SetClipboardTextFn = (user_data, text)=>{
        clipboard_text = text;
        // console.log(`set clipboard_text: "${clipboard_text}"`);
        if (typeof navigator !== "undefined" && typeof navigator.clipboard !== "undefined") {
            // console.log(`clipboard.writeText: "${clipboard_text}"`);
            navigator.clipboard.writeText(clipboard_text).then(()=>{
            // console.log(`clipboard.writeText: "${clipboard_text}" done.`);
            });
        }
    };
    io.GetClipboardTextFn = (user_data)=>{
        // if (typeof navigator !== "undefined" && typeof (navigator as any).clipboard !== "undefined") {
        //     console.log(`clipboard.readText: "${clipboard_text}"`);
        //     (navigator as any).clipboard.readText().then((text: string): void => {
        //         clipboard_text = text;
        //         console.log(`clipboard.readText: "${clipboard_text}" done.`);
        //     });
        // }
        // console.log(`get clipboard_text: "${clipboard_text}"`);
        return clipboard_text;
    };
    io.ClipboardUserData = null;
    if (typeof window !== "undefined") {
        window.addEventListener("resize", window_on_resize);
        window.addEventListener("gamepadconnected", window_on_gamepadconnected);
        window.addEventListener("gamepaddisconnected", window_on_gamepaddisconnected);
    }
    renderer = new Renderer(device);
    glyphManager = new GlyphManager(device, 1024, 1024, 1);
    renderer.device.canvas.style.touchAction = "none"; // Disable browser handling of all panning and zooming gestures.
    renderer.device.canvas.addEventListener("blur", canvas_on_blur);
    renderer.device.canvas.addEventListener("contextmenu", canvas_on_contextmenu);
    // Setup back-end capabilities flags
    io.BackendFlags |= ImGuiBackendFlags.HasMouseCursors; // We can honor GetMouseCursor() values (optional)
    // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array.
    io.KeyMap[ImGuiKey.Tab] = 9;
    io.KeyMap[ImGuiKey.LeftArrow] = 37;
    io.KeyMap[ImGuiKey.RightArrow] = 39;
    io.KeyMap[ImGuiKey.UpArrow] = 38;
    io.KeyMap[ImGuiKey.DownArrow] = 40;
    io.KeyMap[ImGuiKey.PageUp] = 33;
    io.KeyMap[ImGuiKey.PageDown] = 34;
    io.KeyMap[ImGuiKey.Home] = 36;
    io.KeyMap[ImGuiKey.End] = 35;
    io.KeyMap[ImGuiKey.Insert] = 45;
    io.KeyMap[ImGuiKey.Delete] = 46;
    io.KeyMap[ImGuiKey.Backspace] = 8;
    io.KeyMap[ImGuiKey.Space] = 32;
    io.KeyMap[ImGuiKey.Enter] = 13;
    io.KeyMap[ImGuiKey.Escape] = 27;
    io.KeyMap[ImGuiKey.KeyPadEnter] = key_code_to_index["NumpadEnter"];
    io.KeyMap[ImGuiKey.A] = 65;
    io.KeyMap[ImGuiKey.C] = 67;
    io.KeyMap[ImGuiKey.V] = 86;
    io.KeyMap[ImGuiKey.X] = 88;
    io.KeyMap[ImGuiKey.Y] = 89;
    io.KeyMap[ImGuiKey.Z] = 90;
    CreateDeviceObjects();
}
function NewFrame(time) {
    const io = GetIO();
    if (io.WantSaveIniSettings) {
        io.WantSaveIniSettings = false;
        if (typeof window !== "undefined") {
            window.localStorage.setItem("imgui.ini", SaveIniSettingsToMemory());
        }
    }
    const viewport = renderer.device.getViewport();
    const w = viewport.width;
    const h = viewport.height;
    const display_w = w * renderer.device.getScale();
    const display_h = h * renderer.device.getScale();
    io.DisplaySize.x = w;
    io.DisplaySize.y = h;
    io.DisplayFramebufferScale.x = w > 0 ? display_w / w : 0;
    io.DisplayFramebufferScale.y = h > 0 ? display_h / h : 0;
    const dt = prev_time === 0 ? 0 : time - prev_time;
    prev_time = time;
    io.DeltaTime = dt / 1000;
    if (io.WantSetMousePos) {
        console.log("TODO: MousePos", io.MousePos.x, io.MousePos.y);
    }
    if (typeof document !== "undefined") {
        if (io.MouseDrawCursor) {
            document.body.style.cursor = "none";
        } else {
            switch(GetMouseCursor()){
                case ImGuiMouseCursor.None:
                    document.body.style.cursor = "none";
                    break;
                default:
                case ImGuiMouseCursor.Arrow:
                    document.body.style.cursor = "default";
                    break;
                case ImGuiMouseCursor.TextInput:
                    document.body.style.cursor = "text";
                    break; // When hovering over InputText, etc.
                case ImGuiMouseCursor.ResizeAll:
                    document.body.style.cursor = "all-scroll";
                    break; // Unused
                case ImGuiMouseCursor.ResizeNS:
                    document.body.style.cursor = "ns-resize";
                    break; // When hovering over an horizontal border
                case ImGuiMouseCursor.ResizeEW:
                    document.body.style.cursor = "ew-resize";
                    break; // When hovering over a vertical border or a column
                case ImGuiMouseCursor.ResizeNESW:
                    document.body.style.cursor = "nesw-resize";
                    break; // When hovering over the bottom-left corner of a window
                case ImGuiMouseCursor.ResizeNWSE:
                    document.body.style.cursor = "nwse-resize";
                    break; // When hovering over the bottom-right corner of a window
                case ImGuiMouseCursor.Hand:
                    document.body.style.cursor = "move";
                    break;
                case ImGuiMouseCursor.NotAllowed:
                    document.body.style.cursor = "not-allowed";
                    break;
            }
        }
    }
    // Gamepad navigation mapping [BETA]
    for(let i = 0; i < io.NavInputs.length; ++i){
    // TODO: This is currently causing an issue and I have no gamepad to test with.
    //       The error is: ''set' on proxy: trap returned falsish for property '21'
    //       I think that the NavInputs are zeroed out by ImGui at the start of each frame anyway
    //       so I am not sure if the following is even necessary.
    //io.NavInputs[i] = 0.0;
    }
    if (io.ConfigFlags & ImGuiConfigFlags.NavEnableGamepad) {
        // Update gamepad inputs
        const gamepads = typeof navigator !== "undefined" && typeof navigator.getGamepads === "function" ? navigator.getGamepads() : [];
        for(let i = 0; i < gamepads.length; ++i){
            const gamepad = gamepads[i];
            if (!gamepad) {
                continue;
            }
            io.BackendFlags |= ImGuiBackendFlags.HasGamepad;
            const buttons_count = gamepad.buttons.length;
            const axes_count = gamepad.axes.length;
            const MAP_BUTTON = function MAP_BUTTON(NAV_NO, BUTTON_NO) {
                if (!gamepad) {
                    return;
                }
                if (buttons_count > BUTTON_NO && gamepad.buttons[BUTTON_NO].pressed) io.NavInputs[NAV_NO] = 1.0;
            };
            const MAP_ANALOG = function MAP_ANALOG(NAV_NO, AXIS_NO, V0, V1) {
                if (!gamepad) {
                    return;
                }
                let v = axes_count > AXIS_NO ? gamepad.axes[AXIS_NO] : V0;
                v = (v - V0) / (V1 - V0);
                if (v > 1.0) v = 1.0;
                if (io.NavInputs[NAV_NO] < v) io.NavInputs[NAV_NO] = v;
            };
            // TODO: map input based on vendor and product id
            // https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/id
            const match = gamepad.id.match(/^([0-9a-f]{4})-([0-9a-f]{4})-.*$/);
            const match_chrome = gamepad.id.match(/^.*\(.*Vendor: ([0-9a-f]{4}) Product: ([0-9a-f]{4})\).*$/);
            const vendor = match && match[1] || match_chrome && match_chrome[1] || "0000";
            const product = match && match[2] || match_chrome && match_chrome[2] || "0000";
            switch(vendor + product){
                case "046dc216":
                    MAP_BUTTON(ImGuiNavInput.Activate, 1); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 2); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 0); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_ANALOG(ImGuiNavInput.DpadLeft, 4, -0.3, -0.9); // D-Pad Left
                    MAP_ANALOG(ImGuiNavInput.DpadRight, 4, +0.3, +0.9); // D-Pad Right
                    MAP_ANALOG(ImGuiNavInput.DpadUp, 5, -0.3, -0.9); // D-Pad Up
                    MAP_ANALOG(ImGuiNavInput.DpadDown, 5, +0.3, +0.9); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 4); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 5); // R1 / RB
                    MAP_BUTTON(ImGuiNavInput.TweakSlow, 6); // L2 / LT
                    MAP_BUTTON(ImGuiNavInput.TweakFast, 7); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
                case "046dc21d":
                    MAP_BUTTON(ImGuiNavInput.Activate, 0); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 1); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 2); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_BUTTON(ImGuiNavInput.DpadLeft, 14); // D-Pad Left
                    MAP_BUTTON(ImGuiNavInput.DpadRight, 15); // D-Pad Right
                    MAP_BUTTON(ImGuiNavInput.DpadUp, 12); // D-Pad Up
                    MAP_BUTTON(ImGuiNavInput.DpadDown, 13); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 4); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 5); // R1 / RB
                    MAP_ANALOG(ImGuiNavInput.TweakSlow, 6, +0.3, +0.9); // L2 / LT
                    MAP_ANALOG(ImGuiNavInput.TweakFast, 7, +0.3, +0.9); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
                case "2dc86001":
                case "2dc86101":
                    MAP_BUTTON(ImGuiNavInput.Activate, 1); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 0); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 4); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_ANALOG(ImGuiNavInput.DpadLeft, 6, -0.3, -0.9); // D-Pad Left
                    MAP_ANALOG(ImGuiNavInput.DpadRight, 6, +0.3, +0.9); // D-Pad Right
                    MAP_ANALOG(ImGuiNavInput.DpadUp, 7, -0.3, -0.9); // D-Pad Up
                    MAP_ANALOG(ImGuiNavInput.DpadDown, 7, +0.3, +0.9); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 6); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 7); // R1 / RB
                    MAP_BUTTON(ImGuiNavInput.TweakSlow, 8); // L2 / LT
                    MAP_BUTTON(ImGuiNavInput.TweakFast, 9); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
                default:
                    MAP_BUTTON(ImGuiNavInput.Activate, 0); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 1); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 2); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_BUTTON(ImGuiNavInput.DpadLeft, 14); // D-Pad Left
                    MAP_BUTTON(ImGuiNavInput.DpadRight, 15); // D-Pad Right
                    MAP_BUTTON(ImGuiNavInput.DpadUp, 12); // D-Pad Up
                    MAP_BUTTON(ImGuiNavInput.DpadDown, 13); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 4); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 5); // R1 / RB
                    MAP_BUTTON(ImGuiNavInput.TweakSlow, 6); // L2 / LT
                    MAP_BUTTON(ImGuiNavInput.TweakFast, 7); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
            }
        }
    }
}
async function font_update(io) {
    io.Fonts.Fonts.forEach((font)=>{
        const fontName = font.FontSize + "px " + font.FontName;
        let deviceFont = fonts[fontName];
        if (!deviceFont) {
            deviceFont = new Font(fontName, renderer.device.getScale());
            fonts[fontName] = deviceFont;
        }
        let glyph = font.GlyphToCreate;
        while(glyph){
            const glyphInfo = glyphManager.getGlyphInfo(String.fromCharCode(glyph.Char), deviceFont);
            glyph.X0 = 0;
            glyph.X1 = glyphInfo.width;
            glyph.Y0 = 0;
            glyph.Y1 = glyphInfo.height;
            glyph.AdvanceX = glyphInfo.width + (glyph.Char < 256 ? font.SpaceX[0] : font.SpaceX[1]);
            glyph.U0 = glyphInfo.uMin;
            glyph.U1 = glyphInfo.uMax;
            glyph.V0 = glyphInfo.vMin;
            glyph.V1 = glyphInfo.vMax;
            glyph.TextureID = glyphManager.getAtlasTexture(glyphInfo.atlasIndex);
            font.GlyphCreated(glyph);
            glyph = font.GlyphToCreate;
        }
    });
}
let current_window_id = 0;
const scroll_acc = new ImVec2(0, 0);
let mouse_first_down = false;
function scroll_update(io) {
    const hoveredWin = GetHoveredWindow();
    const hoveredId = GetHoveredId();
    if (hoveredWin && hoveredId == 0) {
        if (current_window_id != hoveredWin.ID) {
            current_window_id = hoveredWin.ID;
            scroll_acc.Set(0, 0);
            mouse_first_down = true;
        }
        if (hoveredWin.Flags & ImGuiWindowFlags.NoMove) {
            let first_down = false;
            if (io.MouseDown[0]) {
                first_down = mouse_first_down;
                mouse_first_down = false;
            } else {
                mouse_first_down = true;
            }
            const scroll = new ImVec2(hoveredWin.Scroll.x, hoveredWin.Scroll.y);
            if (hoveredWin.ScrollbarY) {
                if (io.MouseDown[0] && !first_down) {
                    scroll.y -= io.MouseDelta.y;
                    scroll_acc.y = io.MouseDelta.y;
                } else if (Math.abs(scroll_acc.y) > 1) {
                    scroll.y -= scroll_acc.y;
                    scroll_acc.y *= 0.8;
                }
                if (scroll.y < 0) scroll.y = 0;
                else if (scroll.y > hoveredWin.ScrollMax.y) {
                    scroll.y = hoveredWin.ScrollMax.y;
                }
                hoveredWin.Scroll = scroll;
            }
            if (hoveredWin.ScrollbarX) {
                if (io.MouseDown[0]) {
                    scroll.x -= io.MouseDelta.x;
                    scroll_acc.x = io.MouseDelta.x;
                }
                if (scroll.x < 0) scroll.x = 0;
                else if (scroll.x > hoveredWin.ScrollMax.x) {
                    scroll.x = hoveredWin.ScrollMax.x;
                }
                hoveredWin.Scroll = scroll;
            }
        }
    }
}
let dom_input;
function input_text_update(io) {
    const activeId = GetActiveId();
    const inpId = GetInputTextId();
    if (!activeId || activeId != inpId) {
        dom_input?.blur();
    } else {
        if (!dom_input) {
            dom_input = new Input();
        }
        dom_input.focus();
    }
}
function RenderDrawData(draw_data = GetDrawData()) {
    const io = GetIO();
    font_update(io);
    scroll_update(io);
    input_text_update();
    if (draw_data === null) {
        throw new Error();
    }
    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
    const fb_width = io.DisplaySize.x * io.DisplayFramebufferScale.x;
    const fb_height = io.DisplaySize.y * io.DisplayFramebufferScale.y;
    if (fb_width === 0 || fb_height === 0) {
        return;
    }
    draw_data.ScaleClipRects(io.DisplayFramebufferScale);
    // Draw
    const pos = draw_data.DisplayPos;
    const scissorOld = renderer.device.getScissor();
    renderer.beginRender();
    draw_data.IterateDrawLists((draw_list)=>{
        const vx = draw_list.VtxBuffer;
        const ix = draw_list.IdxBuffer;
        const ixU16 = new Uint16Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset + ix.byteLength));
        let indexOffset = 0;
        draw_list.IterateDrawCmds((draw_cmd)=>{
            if (draw_cmd.UserCallback !== null) {
                // User callback (registered via ImDrawList::AddCallback)
                draw_cmd.UserCallback(draw_list, draw_cmd);
            } else {
                const clip_rect = new ImVec4(draw_cmd.ClipRect.x - pos.x, draw_cmd.ClipRect.y - pos.y, draw_cmd.ClipRect.z - pos.x, draw_cmd.ClipRect.w - pos.y);
                if (clip_rect.x < fb_width && clip_rect.y < fb_height && clip_rect.z >= 0.0 && clip_rect.w >= 0.0) {
                    // Apply scissor/clipping rectangle
                    // renderer.device.setScissor([clip_rect.x, fb_height - clip_rect.w, clip_rect.z - clip_rect.x, clip_rect.w - clip_rect.y]);
                    const scissorX = renderer.device.deviceToScreen(clip_rect.x);
                    const scissorY = renderer.device.deviceToScreen(fb_height - clip_rect.w);
                    const scissorW = renderer.device.deviceToScreen(clip_rect.z - clip_rect.x);
                    const scissorH = renderer.device.deviceToScreen(clip_rect.w - clip_rect.y);
                    renderer.stream(vx, ixU16, indexOffset, draw_cmd.ElemCount, draw_cmd.TextureId, [
                        scissorX,
                        scissorY,
                        scissorW,
                        scissorH
                    ]);
                }
            }
            indexOffset += draw_cmd.ElemCount;
        });
    });
    renderer.device.setScissor(scissorOld);
}
function CreateFontsTexture() {
    const io = GetIO();
    // Backup GL state
    // const last_texture: WebGLTexture | null = gl && gl.getParameter(gl.TEXTURE_BINDING_2D);
    // Build texture atlas
    // const width: number = 256;
    // const height: number = 256;
    // const pixels: Uint8Array = new Uint8Array(4 * width * height).fill(0xff);
    //const { width, height, pixels } = io.Fonts.GetTexDataAsRGBA32();   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
    const { width, height, pixels } = io.Fonts.GetTexDataAsAlpha8();
    if (width && height && pixels) {
        const rgba8 = new Uint8Array(width * height * 4);
        let i = 0;
        pixels.forEach((p)=>{
            rgba8[i++] = 0xff;
            rgba8[i++] = 0xff;
            rgba8[i++] = 0xff;
            rgba8[i++] = p;
        });
        // Upload texture to graphics system
        g_FontTexture = renderer.device.createTexture2D('rgba8unorm', width, height, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        g_FontTexture.update(rgba8, 0, 0, width, height);
        //gl && gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        // Store our identifier
        io.Fonts.TexID = g_FontTexture || null;
    // console.log("font texture id", g_FontTexture);
    }
}
function CreateDeviceObjects() {
    CreateFontsTexture();
}

/**
 * Initialize the ImGUI bindings
 *
 * @param device - The device object
 * @param fontFamily - Font family, default to arial
 * @param fontSize - Default font size, default to 16
 * @public
 */ async function imGuiInit(device, fontFamily, fontSize) {
    await imgui();
    IMGUI_CHECKVERSION();
    console.log("ImGui.CreateContext() VERSION=", IMGUI_VERSION);
    CreateContext();
    StyleColorsDark();
    const io = GetIO();
    const font = io.Fonts.AddFontDefault();
    font.FontName = fontFamily || "arial";
    font.FontSize = fontSize || 16;
    Init(device);
}
/**
 * Starts a new frame
 * @public
 */ function imGuiNewFrame() {
    NewFrame(Date.now());
    NewFrame$1();
}
/**
 * Ends current frame
 * @public
 */ function imGuiEndFrame() {
    EndFrame();
    Render();
    RenderDrawData(GetDrawData());
}
/**
 * Injects a browser event into the GUI system
 * @param ev - The event object
 * @param type - Event type, default to ev.type if not specified.
 * @returns A boolean value indices if the event was processed by GUI system
 * @public
 */ function imGuiInjectEvent(ev, type) {
    type = type ?? ev.type;
    if (type === 'pointermove' || type === 'pointerdown' || type === 'pointerup') {
        return injectPointerEvent(ev);
    } else if (type === 'keydown' || type === 'keyup' || type === 'keypress') {
        return injectKeyEvent(ev);
    } else if (type === 'wheel') {
        return injectWheelEvent(ev);
    } else {
        return false;
    }
}

(async function() {
    const canvas = document.querySelector('#canvas');
    const device = await backendWebGPU.createDevice(canvas);
    if (!device) {
        alert('WebGPU is not available');
        return;
    }
    await imGuiInit(device);
    canvas.addEventListener('pointerdown', (ev)=>imGuiInjectEvent(ev));
    canvas.addEventListener('pointerup', (ev)=>imGuiInjectEvent(ev));
    canvas.addEventListener('pointermove', (ev)=>imGuiInjectEvent(ev));
    canvas.addEventListener('pointerdown', (ev)=>imGuiInjectEvent(ev));
    canvas.addEventListener('wheel', (ev)=>imGuiInjectEvent(ev));
    canvas.addEventListener('keydown', (ev)=>imGuiInjectEvent(ev));
    canvas.addEventListener('keyup', (ev)=>imGuiInjectEvent(ev));
    canvas.addEventListener('keypress', (ev)=>imGuiInjectEvent(ev));
    function drawSettingsUI() {
        imGuiNewFrame();
        SetNextWindowSize(new ImVec2(0, 0), ImGuiCond.FirstUseEver);
        Begin('Settings');
        const filterSize = [
            settings.filterSize / 2
        ];
        if (DragInt('FilterSize', filterSize, 0.1, 0, 9)) {
            settings.filterSize = filterSize[0] * 2;
            updateSettings();
        }
        const iterations = [
            settings.iterations
        ];
        if (DragInt('Iterations', iterations, 0.1, 1, 9)) {
            settings.iterations = iterations[0];
            updateSettings();
        }
        End();
        imGuiEndFrame();
    }
    const fullScreenQuadProgram = device.buildRenderProgram({
        label: 'fullScreenQuad',
        vertex (pb) {
            this.pos = [
                pb.vec2(1, -1),
                pb.vec2(1, 1),
                pb.vec2(-1, -1),
                pb.vec2(1, 1),
                pb.vec2(-1, 1),
                pb.vec2(-1, -1)
            ];
            this.uv = [
                pb.vec2(1, 1),
                pb.vec2(1, 0),
                pb.vec2(0, 1),
                pb.vec2(1, 0),
                pb.vec2(0, 0),
                pb.vec2(0, 1)
            ];
            this.$outputs.fragUV = pb.vec2();
            pb.main(function() {
                this.$builtins.position = pb.vec4(this.pos.at(this.$builtins.vertexIndex), 0, 1);
                this.$outputs.fragUV = this.uv.at(this.$builtins.vertexIndex);
            });
        },
        fragment (pb) {
            this.texture = pb.tex2D().uniform(0);
            this.$outputs.color = pb.vec4();
            pb.main(function() {
                this.$outputs.color = pb.textureSample(this.texture, this.$inputs.fragUV);
            });
        }
    });
    const blurProgram = device.buildComputeProgram({
        workgroupSize: [
            32,
            1,
            1
        ],
        compute (pb) {
            const structParams = pb.defineStruct([
                pb.uint('filterDim'),
                pb.uint('blockDim')
            ]);
            const structFlip = pb.defineStruct([
                pb.uint('value')
            ]);
            this.params = structParams().uniform(0);
            this.inputTex = pb.tex2D().uniform(1);
            this.outputTex = pb.texStorage2D.rgba8unorm().uniform(1);
            this.flip = structFlip().uniform(1);
            this.tile = pb.vec3[128][4]().workgroup();
            pb.main(function() {
                this.filterOffset = pb.div(pb.sub(this.params.filterDim, 1), 2);
                this.dims = pb.textureDimensions(this.inputTex, 0);
                this.baseIndex = pb.sub(pb.add(pb.mul(this.$builtins.workGroupId.xy, pb.uvec2(this.params.blockDim, 4)), pb.mul(this.$builtins.localInvocationId.xy, pb.uvec2(4, 1))), pb.uvec2(this.filterOffset, 0));
                this.$for(pb.uint('r'), 0, 4, function() {
                    this.$for(pb.uint('c'), 0, 4, function() {
                        this.loadIndex = pb.add(this.baseIndex, pb.uvec2(this.c, this.r));
                        this.$if(pb.notEqual(this.flip.value, 0), function() {
                            this.loadIndex = this.loadIndex.yx;
                        });
                        this.tile.at(this.r).setAt(pb.add(pb.mul(4, this.$builtins.localInvocationId.x), this.c), pb.textureSampleLevel(this.inputTex, pb.div(pb.add(pb.vec2(this.loadIndex), pb.vec2(0.25, 0.25)), pb.vec2(this.dims)), 0).xyz);
                    });
                });
                pb.workgroupBarrier();
                this.$for(pb.uint('r'), 0, 4, function() {
                    this.$for(pb.uint('c'), 0, 4, function() {
                        this.writeIndex = pb.add(this.baseIndex, pb.uvec2(this.c, this.r));
                        this.$if(pb.notEqual(this.flip.value, 0), function() {
                            this.writeIndex = this.writeIndex.yx;
                        });
                        this.center = pb.add(pb.mul(4, this.$builtins.localInvocationId.x), this.c);
                        this.$if(pb.and(pb.and(pb.greaterThanEqual(this.center, this.filterOffset), pb.lessThan(this.center, pb.sub(128, this.filterOffset))), pb.all(pb.lessThan(this.writeIndex, this.dims))), function() {
                            this.acc = pb.vec3(0, 0, 0);
                            this.$for(pb.uint('f'), 0, this.params.filterDim, function() {
                                this.i = pb.sub(pb.add(this.center, this.f), this.filterOffset);
                                this.acc = pb.add(this.acc, pb.mul(pb.div(1, pb.float(this.params.filterDim)), this.tile.at(this.r).at(this.i)));
                            });
                            pb.textureStore(this.outputTex, this.writeIndex, pb.vec4(this.acc, 1));
                        });
                    });
                });
            });
        }
    });
    // load texture
    const img = document.createElement('img');
    img.src = 'dog_01.png';
    await img.decode();
    const bitmap = await createImageBitmap(img, {
        premultiplyAlpha: 'none'
    });
    const texture = device.createTexture2DFromImage(bitmap, true);
    const textures = [
        device.createTexture2D('rgba8unorm', texture.width, texture.height, {
            writable: true,
            samplerOptions: {
                mipFilter: 'none'
            }
        }),
        device.createTexture2D('rgba8unorm', texture.width, texture.height, {
            writable: true,
            samplerOptions: {
                mipFilter: 'none'
            }
        })
    ];
    const computeUniforms = device.createBindGroup(blurProgram.bindGroupLayouts[0]);
    const computeBindGroup0 = device.createBindGroup(blurProgram.bindGroupLayouts[1]);
    computeBindGroup0.setTexture('inputTex', texture);
    computeBindGroup0.setTexture('outputTex', textures[0]);
    computeBindGroup0.setValue('flip', {
        value: 0
    });
    const computeBindGroup1 = device.createBindGroup(blurProgram.bindGroupLayouts[1]);
    computeBindGroup1.setTexture('inputTex', textures[0]);
    computeBindGroup1.setTexture('outputTex', textures[1]);
    computeBindGroup1.setValue('flip', {
        value: 1
    });
    const computeBindGroup2 = device.createBindGroup(blurProgram.bindGroupLayouts[1]);
    computeBindGroup2.setTexture('inputTex', textures[1]);
    computeBindGroup2.setTexture('outputTex', textures[0]);
    computeBindGroup2.setValue('flip', {
        value: 0
    });
    const resultBindGroup = device.createBindGroup(fullScreenQuadProgram.bindGroupLayouts[0]);
    resultBindGroup.setTexture('texture', textures[1]);
    let blockDim;
    const tileDim = 128;
    const batch = [
        4,
        4
    ];
    const settings = {
        filterSize: 2,
        iterations: 2
    };
    const updateSettings = ()=>{
        blockDim = tileDim - (settings.filterSize - 1);
        computeUniforms.setValue('params', {
            filterDim: settings.filterSize,
            blockDim: blockDim
        });
    };
    updateSettings();
    device.runLoop((device)=>{
        device.setProgram(blurProgram);
        device.setBindGroup(0, computeUniforms);
        device.setBindGroup(1, computeBindGroup0);
        device.compute(Math.ceil(texture.width / blockDim), Math.ceil(texture.height / batch[1]), 1);
        device.setBindGroup(1, computeBindGroup1);
        device.compute(Math.ceil(texture.height / blockDim), Math.ceil(texture.width / batch[1]), 1);
        for(let i = 0; i < settings.iterations - 1; i++){
            device.setBindGroup(1, computeBindGroup2);
            device.compute(Math.ceil(texture.width / blockDim), Math.ceil(texture.height / batch[1]), 1);
            device.setBindGroup(1, computeBindGroup1);
            device.compute(Math.ceil(texture.height / blockDim), Math.ceil(texture.width / batch[1]), 1);
        }
        device.clearFrameBuffer(new Vector4(0, 0, 0, 1), 1, 0);
        device.setProgram(fullScreenQuadProgram);
        device.setBindGroup(0, resultBindGroup);
        device.setVertexLayout(null);
        device.draw('triangle-list', 0, 6);
        DrawText.drawText(device, `Device: ${device.type}`, '#ffffff', 30, 30);
        DrawText.drawText(device, `FPS: ${device.frameInfo.FPS.toFixed(2)}`, '#ffff00', 30, 50);
        drawSettingsUI();
    });
})();
//# sourceMappingURL=imageblur.js.map
