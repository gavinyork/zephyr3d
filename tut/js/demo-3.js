const colorNames = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32',
    transparent: 'rgba(0,0,0,0)'
};
/**
 * Wrapper of a http get request
 * @public
 */ class HttpRequest {
    /** @internal */ static _tempElement = null;
    /** @internal */ _urlResolver;
    /** @internal */ _crossOrigin;
    /** @internal */ _headers;
    constructor(){
        this._urlResolver = null;
        this._crossOrigin = '';
        this._headers = {};
    }
    /** Get the custom URL resolver */ get urlResolver() {
        return this._urlResolver;
    }
    set urlResolver(resolver) {
        this._urlResolver = resolver;
    }
    /** Get the cross origin property */ get crossOrigin() {
        return this._crossOrigin;
    }
    set crossOrigin(val) {
        this._crossOrigin = val;
    }
    /** Get the request headers */ get headers() {
        return this._headers;
    }
    set headers(val) {
        this._headers = val;
    }
    /**
   * Resolves a URL string.
   * @param url - The input url string,
   * @returns The resolved URL string.
   */ resolveURL(url) {
        if (!HttpRequest._tempElement) {
            HttpRequest._tempElement = document.createElement('a');
        }
        HttpRequest._tempElement.href = url;
        return HttpRequest._tempElement.href;
    }
    /**
   * Send a GET request.
   * @param url - The remote URL to fetch.
   * @returns The fetch result.
   */ async request(url) {
        url = this._urlResolver ? this._urlResolver(url) : this.resolveURL(url);
        return url ? fetch(url, {
            credentials: this._crossOrigin === 'anonymous' ? 'same-origin' : 'include',
            headers: this._headers || {}
        }) : null;
    }
    /**
   * Fetch a text string from remote.
   * @param url - The remote URL to fetch.
   * @returns The fetch result.
   */ async requestText(url) {
        const response = await this.request(url);
        if (!response.ok) {
            throw new Error(`Asset download failed: ${url}`);
        }
        return response.text();
    }
    /**
   * Fetch an array buffer from remote.
   * @param url - The remote URL to fetch.
   * @returns The fetch result.
   */ async requestArrayBuffer(url) {
        const response = await this.request(url);
        if (!response.ok) {
            throw new Error(`Asset download failed: ${url}`);
        }
        return response.arrayBuffer();
    }
    /**
   * Fetch a blob object from remote.
   * @param url - The remote URL to fetch.
   * @returns The fetch result.
   */ async requestBlob(url) {
        const arrayBuffer = await this.requestArrayBuffer(url);
        return new Blob([
            arrayBuffer
        ]);
    }
}
/**
 * parse a css color value to RGBA color type.
 * @param input - The css color value.
 * @returns The RGBA color value.
 * @public
 */ function parseColor(input) {
    input = input.trim().toLowerCase();
    input = colorNames[input] || input;
    let v = null;
    if (input[0] === '#') {
        const collen = (input.length - 1) / 3;
        const fact = [
            17,
            1,
            0.062272
        ][collen - 1];
        v = {
            r: parseInt(input.substring(1, 1 + collen), 16) * fact / 255,
            g: parseInt(input.substring(1 + collen, 1 + 2 * collen), 16) * fact / 255,
            b: parseInt(input.substring(1 + 2 * collen, 1 + 3 * collen), 16) * fact / 255,
            a: 1
        };
    } else {
        let m;
        if (m = input.match(/^\s*rgb\s*\(\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\s*,\s*(\d\.?\d*)\s*\)\s*$/i)) {
            v = {
                r: Number(m[1]) / 255,
                g: Number(m[2]) / 255,
                b: Number(m[3]) / 255,
                a: 1
            };
        } else if (m = input.match(/^\s*rgba\s*\(\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\s*,\s*([\d*.?\d*]+)\s*,\s*(\d*\.?\d*)\s*\)\s*$/i)) {
            v = {
                r: Number(m[1]) / 255,
                g: Number(m[2]) / 255,
                b: Number(m[3]) / 255,
                a: Number(m[4])
            };
        }
    }
    if (!v || Number.isNaN(v.r) || Number.isNaN(v.g) || Number.isNaN(v.b) || Number.isNaN(v.a)) {
        throw new Error(`parseColor(): invalid color '${input}'`);
    }
    // the RGB color values in CSS are in sRGB color space, convert them to linear color space
    v.r = Math.pow(Math.min(1, v.r), 2.2);
    v.g = Math.pow(Math.min(1, v.g), 2.2);
    v.b = Math.pow(Math.min(1, v.b), 2.2);
    v.a = Math.min(1, v.a);
    return v;
}

/**
 * This mixin make a class an event target
 * @param cls - the class to make
 * @returns - The event target class
 * @public
 */ function makeEventTarget(cls) {
    return function _() {
        return class E extends cls {
            /** @internal */ _listeners;
            constructor(...args){
                super(...args);
                this._listeners = null;
            }
            /**
       * {@inheritDoc IEventTarget.on}
       */ on(type, listener, context) {
                this._listeners = this._internalAddEventListener(this._listeners, type, listener, {
                    context
                });
            }
            /**
       * {@inheritDoc IEventTarget.once}
       */ once(type, listener, context) {
                this._listeners = this._internalAddEventListener(this._listeners, type, listener, {
                    context,
                    once: true
                });
            }
            /**
       * {@inheritDoc IEventTarget.off}
       */ off(type, listener) {
                this._internalRemoveEventListener(this._listeners, type, listener);
            }
            /**
       * {@inheritDoc IEventTarget.dispatchEvent}
       */ dispatchEvent(evt, type) {
                this._invokeLocalListeners(evt, type);
            }
            /** @internal */ _internalAddEventListener(listenerMap, type, listener, options) {
                if (typeof type !== 'string') {
                    return;
                }
                if (!listenerMap) {
                    listenerMap = {};
                }
                const l = listener;
                const o = {
                    once: !!options?.once,
                    context: options?.context
                };
                let handlers = listenerMap[type];
                if (!handlers) {
                    listenerMap[type] = handlers = [];
                }
                handlers.push({
                    handler: l,
                    options: o,
                    removed: false
                });
                return listenerMap;
            }
            /** @internal */ _internalRemoveEventListener(listenerMap, type, listener) {
                if (typeof type !== 'string' || !listenerMap) {
                    return;
                }
                const l = listener;
                const handlers = listenerMap[type];
                if (handlers) {
                    for(let i = 0; i < handlers.length; i++){
                        const handler = handlers[i];
                        if (handler.handler === l) {
                            handlers.splice(i, 1);
                            break;
                        }
                    }
                }
                if (handlers.length === 0) {
                    delete listenerMap[type];
                }
            }
            /** @internal */ _invokeLocalListeners(evt, type) {
                if (!this._listeners) {
                    return;
                }
                const handlers = this._listeners[type ?? evt?.type];
                if (handlers && handlers.length > 0) {
                    const handlersCopy = handlers.slice();
                    for (const handler of handlersCopy){
                        handler.handler.call(handler.options?.context || this, evt);
                        if (handler.options.once) {
                            handler.removed = true;
                        }
                    }
                    for(let i = handlers.length - 1; i >= 0; i--){
                        if (handlers[i].removed) {
                            handlers.splice(i, 1);
                        }
                    }
                }
            }
        };
    };
}

/**
 * The list iterator class
 * @public
 */ class ListIterator {
    /** @internal */ _node;
    /** @internal */ _reverse;
    /** @internal */ _dl;
    /** @internal */ constructor(dl, node, reverse){
        this._dl = dl;
        this._node = node;
        this._reverse = reverse;
    }
    /**
   * Check that the iterator points to a valid list node
   *
   * @returns true if the iterator points to a valid list node, otherwise false
   *
   * @public
   */ valid() {
        return this._node !== this._dl.head;
    }
    /**
   * Let the iterator point to the next list node
   *
   * @returns self
   *
   * @throws Error
   * The exception is thrown if the iterator is not valid
   *
   * @public
   */ next() {
        if (!this.valid()) {
            throw new Error('ListIterator.next(): iterator is invalid');
        }
        this._node = this._reverse ? this._node.prev : this._node.next;
        return this;
    }
    /**
   * Get a new iterator pointing to the next list node
   *
   * @returns the new iterator
   *
   * @throws Error
   * The exception is thrown if the iterator is not valid
   *
   * @public
   */ getNext() {
        if (!this.valid()) {
            throw new Error('ListIterator.getNext(): iterator is invalid');
        }
        return new ListIterator(this._dl, this._reverse ? this._node.prev : this._node.next, this._reverse);
    }
    /**
   * Let the iterator point to the previous list node
   *
   * @returns self
   *
   * @throws Error
   * The exception is thrown if the iterator is not valid
   *
   * @public
   */ prev() {
        if (!this.valid()) {
            throw new Error('ListIterator.prev(): iterator is invalid');
        }
        this._node = this._reverse ? this._node.next : this._node.prev;
        return this;
    }
    /**
   * Get a new iterator pointing to the previous list node
   *
   * @returns the new iterator
   *
   * @throws Error
   * The exception is thrown if the iterator is not valid
   *
   * @public
   */ getPrev() {
        if (!this.valid()) {
            throw new Error('ListIterator.getPrev(): iterator is invalid');
        }
        return new ListIterator(this._dl, this._reverse ? this._node.next : this._node.prev, this._reverse);
    }
    /** @internal */ get node() {
        return this._node;
    }
    /** @internal */ set node(n) {
        this._node = n;
    }
    /**
   * Returns whether the iterator is reversed.
   *
   * @returns true if the iterator is reversed, otherwise false
   *
   * @public
   */ get reversed() {
        return this._reverse;
    }
    /**
   * Returns the list object to which the iterator belongs.
   *
   * @returns The list object to which the iterator belongs.
   *
   * @public
   */ get list() {
        return this._dl;
    }
    /**
   * Gets the data associated with the iterator
   *
   * @throws Error
   * The exception is thrown if the iterator is invalid
   *
   * @public
   */ get data() {
        if (!this.valid()) {
            throw new Error('ListIterator.data: iterator is invalid');
        }
        return this._node.data;
    }
    set data(val) {
        if (this.valid()) {
            this._node.data = val;
        }
    }
}
/**
 * The double list class
 *
 * @typeParam T - The data type associated with the linked list class
 *
 * @public
 */ class List {
    /** @internal */ _head;
    /** @internal */ _length;
    constructor(){
        this._head = new ListNodeImpl();
        this._length = 0;
    }
    /** @internal */ get head() {
        return this._head;
    }
    /**
   * Get the number of elements in the linked list
   *
   * @returns The number of elements in the linked list
   */ get length() {
        return this._length;
    }
    /**
   * Remove all elements in the linked list
   */ clear() {
        while(this._length > 0){
            this.remove(this.begin());
        }
    }
    /**
   * Append an element to the end of the linked list
   *
   * @param data - The data associated to the element
   * @returns An iterator pointing to the newly added element
   *
   * @public
   */ append(data) {
        return this._insertAt(data, this._head);
    }
    /**
   * Add a new element to the linked list header
   *
   * @param data - The data associated to the element
   * @returns An iterator pointing to the newly added element
   *
   * @public
   */ prepend(data) {
        return this._insertAt(data, this._head.next);
    }
    /**
   * Deletes an element from the linked list
   *
   * @param it - An iterator pointing to the element that needs to be removed
   *
   * @public
   */ remove(it) {
        if (it.valid() && it.list === this) {
            const node = it.node;
            it.next();
            this._remove(node);
        }
    }
    /**
   * Inserts an element into the linked list
   * @param data - The data to be inserted to the list
   * @param at - An iterator pointing to the element at the insert position
   * @returns An iterator pointing to the element that was inserted
   *
   * @public
   */ insert(data, at) {
        if (at.list === this) {
            if (at.valid()) {
                if (at.reversed) {
                    return this._insertAt(data, at.node.next);
                } else {
                    return this._insertAt(data, at.node);
                }
            } else {
                return this.append(data);
            }
        }
        return null;
    }
    /**
   * Execute the callback function sequentially for each element of the linked list
   * @param callback - The function to be executed
   *
   * @public
   */ forEach(callback) {
        if (callback) {
            for(let it = this.begin(); it.valid(); it.next()){
                callback(it.data);
            }
        }
    }
    /**
   * Execute the callback function sequentially for each element of the linked list in the reversed order
   * @param callback - The function to be executed
   *
   * @public
   */ forEachReverse(callback) {
        if (callback) {
            for(let it = this.rbegin(); it.valid(); it.next()){
                callback(it.data);
            }
        }
    }
    /**
   * Gets the data associated to the first element in the linked list
   * @returns The data associated to the first element in the linked list
   *
   * @throws Error
   * The exception is thrown if the list is empty
   *
   * @public
   */ front() {
        if (this.length === 0) {
            throw new Error('List.front(): list is empty');
        }
        return this.begin().data;
    }
    /**
   * Gets the data associated to the last element in the linked list
   * @returns The data associated to the last element in the linked list
   *
   * @throws Error
   * The exception is thrown if the list is empty
   *
   * @public
   */ back() {
        if (this.length === 0) {
            throw new Error('List.back(): list is empty');
        }
        return this.rbegin().data;
    }
    /**
   * Returns an iterator pointing to the first element in the list.
   * @returns An iterator to the beginning of the list.
   *
   * @public
   */ begin() {
        return new ListIterator(this, this._length > 0 ? this._head.next : this._head, false);
    }
    /**
   * Returns an iterator referring to the past-the-end element in the list.
   * @returns An iterator to the element past the end of the list.
   *
   * @public
   */ end() {
        return new ListIterator(this, this._head, false);
    }
    /**
   * Returns a reverse iterator pointing to the last element in the list (i.e., its reverse beginning).
   * @returns A reverse iterator to the reverse beginning of the list.
   *
   * @public
   */ rbegin() {
        return new ListIterator(this, this._length > 0 ? this._head.prev : this._head, true);
    }
    /**
   * Returns a reverse iterator pointing to the theoretical element preceding the first element in the list (which is considered its reverse end).
   * @returns A reverse iterator to the reverse end of the list.
   *
   * @public
   */ rend() {
        return new ListIterator(this, this._head, true);
    }
    /** @internal */ _remove(node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        delete node.prev;
        delete node.next;
        this._length--;
    }
    /** @internal */ _insertAt(data, node) {
        const newNode = new ListNode(data);
        newNode.next = node;
        newNode.prev = node.prev;
        node.prev.next = newNode;
        node.prev = newNode;
        this._length++;
        return new ListIterator(this, newNode, false);
    }
}
class ListNodeImpl {
    next;
    prev;
    constructor(){
        this.next = this;
        this.prev = this;
    }
}
class ListNode extends ListNodeImpl {
    data;
    constructor(data){
        super();
        this.data = data;
    }
}

const tmpArrayBuffer = new ArrayBuffer(4);
const tmpFloatArray = new Float32Array(tmpArrayBuffer);
const tmpUint32Array = new Uint32Array(tmpArrayBuffer);
/**
 * Convert a number to 32 bit float value
 * @param val - The number to be converted
 * @returns 32bit float value
 *
 * @public
 */ function toFloat(val) {
    tmpFloatArray[0] = val;
    return tmpFloatArray[0];
}
/**
 * Check if a number is a power of 2.
 *
 * @param value - The number to be checked.
 * @returns true if the number is a power of 2, otherwise false.
 *
 * @public
 */ function isPowerOf2(value) {
    return value % 1 === 0 && value >= 0 && (value & value - 1) === 0;
}
/**
 * Given a number, find the next number power of 2.
 *
 * @param value - The given number.
 * @returns The next number power of 2.
 *
 * @public
 */ function nextPowerOf2(value) {
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;
    return value;
}
/**
 * Converts float value to half float
 *
 * @param val - The float value to be converted.
 * @returns A 16-bits integer presents the half float value
 *
 * @public
 */ function floatToHalf(val) {
    /*
  _floatView[0] = val;
  const x = _int32View[0];
  let bits = (x >> 16) & 0x8000;
  let m = (x >> 12) & 0x07ff;
  const e = (x >> 23) & 0xff;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 0x7c00;
    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
    return bits;
  }
  if (e < 113) {
    m |= 0x0800;
    bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
    return bits;
  }
  bits |= ((e - 112) << 10) | (m >> 1);
  bits += m & 1;
  return bits;
  */ tmpFloatArray[0] = val;
    let ivalue = tmpUint32Array[0];
    let result;
    const sign = (ivalue & 0x80000000) >>> 16;
    ivalue = ivalue & 0x7fffffff;
    if (ivalue >= 0x47800000) {
        // number is too large
        result = 0x7c00 | (ivalue > 0x7f800000 ? 0x200 | ivalue >>> 13 & 0x3ff : 0);
    } else if (ivalue <= 0x33000000) {
        result = 0;
    } else if (ivalue < 0x38800000) {
        const shift = 125 - (ivalue >>> 23);
        ivalue = 0x800000 | ivalue & 0x7fffff;
        result = ivalue >>> shift + 1;
        const s = (ivalue & (1 << shift) - 1) !== 0 ? 1 : 0;
        result += (result | s) & (ivalue >>> shift & 1);
    } else {
        ivalue += 0xc8000000;
        result = ivalue + 0x0fff + (ivalue >>> 13 & 1) >>> 13 & 0x7fff;
    }
    return result | sign;
}
/**
 * Compresses three floats to R11F_G11F_B10F format
 *
 * @remarks
 * The implementation is adopt from https://github.com/microsoft/DirectXMath
 *
 * @param a - first of the three floats
 * @param b - second of the three floats
 * @param c - third of the tree floats
 * @returns The compressed result
 *
 * @public
 */ function packFloat3(a, b, c) {
    /*
  const x = floatToHalf(a);
  const y = floatToHalf(b);
  const z = floatToHalf(c);
  return ((x >> 4) & 0x7ff) | (((y << 7) & 0x3ff800)) | (((z << 17) & 0xffc00000));
  */ const ivalues = [];
    const result = [];
    tmpFloatArray[0] = a;
    ivalues[0] = tmpUint32Array[0];
    tmpFloatArray[0] = b;
    ivalues[1] = tmpUint32Array[0];
    tmpFloatArray[0] = c;
    ivalues[2] = tmpUint32Array[0];
    for(let j = 0; j < 2; j++){
        const sign = ivalues[j] & 0x80000000;
        let I = ivalues[j] & 0x7fffffff;
        if ((I & 0x7f800000) === 0x7f800000) {
            // INF or NAN
            result[j] = 0x7c0;
            if ((I & 0x7fffff) !== 0) {
                result[j] = 0x7ff;
            } else if (sign) {
                // -INF, clamp to 0
                result[j] = 0;
            }
        } else if (sign || I < 0x35800000) {
            // clamp to 0
            result[j] = 0;
        } else if (I > 0x477e0000) {
            // too large, clamp to max
            result[j] = 0x7bf;
        } else {
            if (I < 0x38800000) {
                const shift = 113 - (I >>> 23);
                I = (0x800000 | I & 0x7fffff) >>> shift;
            } else {
                I += 0xc8000000;
            }
            result[j] = I + 0xffff + (I >>> 17 & 1) >>> 17 & 0x7ff;
        }
    }
    const sign = ivalues[2] & 0x80000000;
    let I = ivalues[2] & 0x7fffffff;
    if ((I & 0x7f800000) === 0x7f800000) {
        // INF or NAN
        result[2] = 0x3e0;
        if (I & 0x7fffff) {
            result[2] = 0x3ff;
        } else if (sign || I < 0x36000000) {
            result[2] = 0;
        }
    } else if (sign) {
        result[2] = 0;
    } else if (I > 0x477c0000) {
        result[2] = 0x3df;
    } else {
        if (I < 0x38800000) {
            const shift = 113 - (I >>> 23);
            I = (0x800000 | I & 0x7fffff) >>> shift;
        } else {
            I += 0xc8000000;
        }
        result[2] = I + 0x1ffff + (I >>> 18 & 1) >>> 18 & 0x3ff;
    }
    return result[0] & 0x7ff | (result[1] & 0x7ff) << 11 | (result[2] & 0x3ff) << 22;
}

/**
 * Enumerator used to refer to a box side
 * @public
 */ var BoxSide;
(function(BoxSide) {
    BoxSide[BoxSide[/** Left side (-x) */ "LEFT"] = 0] = "LEFT";
    BoxSide[BoxSide[/** Right side (+x) */ "RIGHT"] = 1] = "RIGHT";
    BoxSide[BoxSide[/** Bottom side (-y) */ "BOTTOM"] = 2] = "BOTTOM";
    BoxSide[BoxSide[/** Top side (+y) */ "TOP"] = 3] = "TOP";
    BoxSide[BoxSide[/** Front side (+z) */ "FRONT"] = 4] = "FRONT";
    BoxSide[BoxSide[/** Back side (-z) */ "BACK"] = 5] = "BACK";
})(BoxSide || (BoxSide = {}));
var ClipState;
(function(ClipState) {
    ClipState[ClipState[/** A does not intersect with B */ "NOT_CLIPPED"] = 0] = "NOT_CLIPPED";
    ClipState[ClipState[/** A is inside B */ "A_INSIDE_B"] = 1] = "A_INSIDE_B";
    ClipState[ClipState[/** B is inside A */ "B_INSIDE_A"] = 2] = "B_INSIDE_A";
    ClipState[ClipState[/** A and B partially overlap */ "CLIPPED"] = 2] = "CLIPPED";
})(ClipState || (ClipState = {}));
var CubeFace;
(function(CubeFace) {
    CubeFace[CubeFace["PX"] = 0] = "PX";
    CubeFace[CubeFace["NX"] = 1] = "NX";
    CubeFace[CubeFace["PY"] = 2] = "PY";
    CubeFace[CubeFace["NY"] = 3] = "NY";
    CubeFace[CubeFace["PZ"] = 4] = "PZ";
    CubeFace[CubeFace["NZ"] = 5] = "NZ";
})(CubeFace || (CubeFace = {}));

const IDENT_MATRIX3x3 = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
]);
const IDENT_MATRIX4x4 = new Float32Array([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
]);
/**
 * Base class for vector and matrix types.
 *
 * @public
 */ class VectorBase extends Float32Array {
    /**
   * Check if all data is close enough to another
   * @param other - The data to be compared with.
   * @param epsilon - The minimal error allowd.
   * @returns true if close enough, otherwise false.
   */ equalsTo(other, epsl) {
        if (!other || this.length !== other.length) {
            return false;
        }
        if (this === other) {
            return true;
        }
        for(let i = 0; i < this.length; i++){
            const a = this[i];
            const b = other[i];
            const e = epsl ?? 0.0001 * Math.max(1, Math.abs(a), Math.abs(b));
            if (Math.abs(a - b) > e) {
                return false;
            }
        }
        return true;
    }
    /**
   * Convert this to string object.
   */ toString() {
        const elements = [
            ...this
        ].map((val)=>val.toFixed(3));
        return `${this.constructor.name}{${elements.join(',')}}`;
    }
    /**
   * Check the data for the presence of NaN.
   *
   * @returns true if NaN is present, otherwise false.
   */ isNaN() {
        for(let i = 0; i < this.length; i++){
            if (Number.isNaN(this[i])) {
                return true;
            }
        }
        return false;
    }
}
/**
 * 2 dimentional vector
 * @public
 */ class Vector2 extends VectorBase {
    constructor(arg0, arg1){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 2);
        } else {
            super(2);
            if (typeof arg0 === 'number' && typeof arg1 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 2) {
                this[0] = arg0[0];
                this[1] = arg0[1];
            } else if (arg0 !== void 0) {
                throw new Error(`Vector2.constructor(): invalid arguments`);
            }
        }
    }
    /**
   * Creates a new Vector2 initialized with values from this vector.
   * @returns The new Vector2.
   */ clone() {
        return new Vector2(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1];
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @returns self
   */ setXY(x, y) {
        this[0] = x;
        this[1] = y;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @returns self
   */ setAndNormalize(x, y) {
        const mag = Math.sqrt(x * x + y * y);
        return this.setXY(x / mag, y / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector2.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector2.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector2.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector2.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector2.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector2.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector2.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector2.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector2.max(this, other, this);
    }
    /**
   * Creates a new Vector2 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector2(0, 0);
    }
    /**
   * Creates a new Vector2 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector2(1, 1);
    }
    /**
   * Creates a new Vector2 pointing in the positive direction of the X axis, i.e. vec2(1, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector2(1, 0);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the X axis, i.e. vec2(-1, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector2(-1, 0);
    }
    /**
   * Creates a new Vector2 pointing in the positive direction of the Y axis, i.e. vec2(0, 1)
   * @returns The new vector
   */ static axisPY() {
        return new Vector2(0, 1);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the Y axis, i.e. vec2(0, -1)
   * @returns The new vector
   */ static axisNY() {
        return new Vector2(0, -1);
    }
    /**
   * Calculates the distance between two Vector2's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns distance between v1 and v2
   */ static distance(v1, v2) {
        return Math.sqrt(this.distanceSq(v1, v2));
    }
    /**
   * Calculates the squared distance between two Vector2's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns squared distance between v1 and v2
   */ static distanceSq(v1, v2) {
        const dx = v1.x - v2.x;
        const dy = v1.y - v2.y;
        return dx * dx + dy * dy;
    }
    /**
   * Normalize a Vector2
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Inverse a Vector2
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Subtract two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Add two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Multiply two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Divide two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Scale a Vector2 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the minimum of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the maximum of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the absolute values of a Vector2.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the dot product of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y;
    }
    /**
   * Calculates the cross product of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns z component of the cross product of the two vectors.
   */ static cross(a, b) {
        return a.x * b.y - a.y * b.x;
    }
}
/**
 * 3 dimentional vector
 * @public
 */ class Vector3 extends VectorBase {
    constructor(arg0, arg1, arg2){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 3);
        } else {
            super(3);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 3) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
            } else if (arg0 !== void 0) {
                throw new Error('Vector3.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Vector3 initialized with values from this vector.
   * @returns The new vector.
   */ clone() {
        return new Vector3(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2];
    }
    /**
   * Creates a new Vector2 initialized with x, y component of this vector.
   * @returns The new vector
   */ xy() {
        return new Vector2(this.x, this.y);
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @returns self
   */ setXYZ(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @returns self
   */ setAndNormalize(x, y, z) {
        const mag = Math.sqrt(x * x + y * y + z * z);
        return this.setXYZ(x / mag, y / mag, z / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector3.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector3.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector3.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector3.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector3.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector3.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector3.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector3.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector3.max(this, other, this);
    }
    /**
   * Creates a new Vector3 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector3(0, 0, 0);
    }
    /**
   * Creates a new Vector3 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector3(1, 1, 1);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the X axis, i.e. vec3(1, 0, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector3(1, 0, 0);
    }
    /**
   * Creates a new Vector3 pointing in the negative direction of the X axis, i.e. vec3(-1, 0, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector3(-1, 0, 0);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the Y axis, i.e. vec3(0, 1, 0)
   * @returns The new vector
   */ static axisPY() {
        return new Vector3(0, 1, 0);
    }
    /**
   * Creates a new Vector3 pointing in the negative direction of the Y axis, i.e. vec3(0, -1, 0)
   * @returns The new vector
   */ static axisNY() {
        return new Vector3(0, -1, 0);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the Z axis, i.e. vec3(0, 0, 1)
   * @returns The new vector
   */ static axisPZ() {
        return new Vector3(0, 0, 1);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the Z axis, i.e. vec3(0, 0, -1)
   * @returns The new vector
   */ static axisNZ() {
        return new Vector3(0, 0, -1);
    }
    /**
   * Calculates the distance between two Vector3's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns distance between v1 and v2
   */ static distance(v1, v2) {
        return Math.sqrt(this.distanceSq(v1, v2));
    }
    /**
   * Calculates the squared distance between two Vector3's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns squared distance between v1 and v2
   */ static distanceSq(v1, v2) {
        const dx = v1.x - v2.x;
        const dy = v1.y - v2.y;
        const dz = v1.z - v2.z;
        return dx * dx + dy * dy + dz * dz;
    }
    /**
   * Normalize a Vector3
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        const z = v.z / len;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Inverse a Vector3
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        const z = 1 / v.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Subtract two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = a.z - b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Add two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        const z = a.z + b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Multiply two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        const z = a.z * b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Divide two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        const z = a.z / b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Scale a Vector3 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        const z = a.z * b;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the minimum of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        const z = a.z < b.z ? a.z : b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the maximum of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        const z = a.z > b.z ? a.z : b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the absolute values of a Vector3.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        const z = a.z < 0 ? -a.z : a.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the dot product of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }
    /**
   * Calculates the cross product of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns the cross product of the two vectors.
   */ static cross(a, b, result) {
        const x = a.y * b.z - a.z * b.y;
        const y = a.z * b.x - a.x * b.z;
        const z = a.x * b.y - a.y * b.x;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
}
/**
 * Observable 3 dimentional vector
 *
 * @public
 */ class ObservableVector3 extends Vector3 {
    /** @internal */ _callback;
    /** The callback function which will be executed when the value changed */ get callback() {
        return this._callback;
    }
    set callback(cb) {
        this._callback = cb;
    }
    /**
   * {@inheritDoc Vector3.x}
   */ get x() {
        return super.x;
    }
    set x(val) {
        val = toFloat(val);
        if (val !== super.x) {
            super.x = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Vector3.y}
   */ get y() {
        return super.y;
    }
    set y(val) {
        val = toFloat(val);
        if (val !== super.y) {
            super.y = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Vector3.z}
   */ get z() {
        return super.z;
    }
    set z(val) {
        val = toFloat(val);
        if (val !== super.z) {
            super.z = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Vector3.setXYZ}
   */ setXYZ(x, y, z) {
        x = toFloat(x);
        y = toFloat(y);
        z = toFloat(z);
        if (x !== super.x || y !== super.y || z !== super.z) {
            super.setXYZ(x, y, z);
            this._callback && this._callback();
        }
        return this;
    }
    /**
   * Inherited from Float32Array.copyWithin
   */ copyWithin(target, start, end) {
        super.copyWithin(target, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.fill
   */ fill(value, start, end) {
        super.fill(value, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.reverse
   */ reverse() {
        super.reverse();
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.set
   */ set(array, offset) {
        super.set(array, offset);
        this._callback && this._callback();
    }
    /**
   * Inherited from Float32Array.sort
   */ sort(compareFn) {
        super.sort(compareFn);
        this._callback && this._callback();
        return this;
    }
}
/**
 * 4 dimentional vector
 * @public
 */ class Vector4 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 4);
        } else {
            super(4);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[3];
            } else if (arg0 !== void 0) {
                throw new Error('Vector4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Vector4 initialized with values from this vector.
   * @returns The new vector.
   */ clone() {
        return new Vector4(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the w component value. */ get w() {
        return this[3];
    }
    set w(v) {
        this[3] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3];
    }
    /**
   * Creates a new Vector2 initialized with x, y component of this vector.
   * @returns The new vector
   */ xy() {
        return new Vector2(this.x, this.y);
    }
    /**
   * Creates a new Vector3 initialized with x, y, z component of this vector.
   * @returns The new vector
   */ xyz() {
        return new Vector3(this.x, this.y, this.z);
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setXYZW(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setAndNormalize(x, y, z, w) {
        const mag = Math.sqrt(x * x + y * y + z * z + w * w);
        return this.setXYZW(x / mag, y / mag, z / mag, w / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector4.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector4.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector4.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector4.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector4.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector4.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector4.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector4.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector4.max(this, other, this);
    }
    /**
   * Creates a new Vector4 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector4(0, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector4(1, 1, 1, 1);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the X axis, i.e. vec4(1, 0, 0, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector4(1, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the X axis, i.e. vec4(-1, 0, 0, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector4(-1, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the Y axis, i.e. vec4(0, 1, 0, 0)
   * @returns The new vector
   */ static axisPY() {
        return new Vector4(0, 1, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the Y axis, i.e. vec4(0, -1, 0, 0)
   * @returns The new vector
   */ static axisNY() {
        return new Vector4(0, -1, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the Z axis, i.e. vec4(0, 0, 1, 0)
   * @returns The new vector
   */ static axisPZ() {
        return new Vector4(0, 0, 1, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the Z axis, i.e. vec4(0, 0, -1, 0)
   * @returns The new vector
   */ static axisNZ() {
        return new Vector4(0, 0, -1, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the W axis, i.e. vec4(0, 0, 0, 1)
   * @returns The new vector
   */ static axisPW() {
        return new Vector4(0, 0, 0, 1);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the W axis, i.e. vec4(0, 0, 0, -1)
   * @returns The new vector
   */ static axisNW() {
        return new Vector4(0, 0, 0, -1);
    }
    /**
   * Normalize a Vector4
   * @param v - The input vector
   * @param result - The output vector (can be the same as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        const z = v.z / len;
        const w = v.w / len;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Inverse a Vector4
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        const z = 1 / v.z;
        const w = 1 / v.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Subtract two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = a.z - b.z;
        const w = a.w - b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Add two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        const z = a.z + b.z;
        const w = a.w + b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Multiply two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        const z = a.z * b.z;
        const w = a.w * b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Divide two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        const z = a.z / b.z;
        const w = a.w / b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Scale a Vector4 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        const z = a.z * b;
        const w = a.w * b;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the minimum of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        const z = a.z < b.z ? a.z : b.z;
        const w = a.w < b.w ? a.w : b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the maximum of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        const z = a.z > b.z ? a.z : b.z;
        const w = a.w > b.w ? a.w : b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the absolute values of a Vector4.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        const z = a.z < 0 ? -a.z : a.z;
        const w = a.w < 0 ? -a.w : a.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the dot product of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
    }
}
/**
 * Quaternion
 * @public
 */ class Quaternion extends VectorBase {
    constructor(arg0, arg1, arg2, arg3){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 4);
        } else {
            super(4);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
            } else if (arg0 instanceof Matrix3x3 || arg0 instanceof Matrix4x4) {
                this.fromRotationMatrix(arg0);
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[3];
            } else if (arg0 === void 0) {
                this[0] = 0;
                this[1] = 0;
                this[2] = 0;
                this[3] = 1;
            } else {
                throw new Error('Quaternion.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Quaternion initialized with values from this quaternion.
   * @returns The new quaternion.
   */ clone() {
        return new Quaternion(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the w component value. */ get w() {
        return this[3];
    }
    set w(v) {
        this[3] = v;
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setXYZW(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this;
    }
    /**
   * Scale this quaternion by a scalar number.
   * @param f - amount to scale this quaternion by.
   * @returns self
   */ scaleBy(f) {
        return Quaternion.scale(this, f, this);
    }
    /**
   * Set component values and then normalize the quaternion.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setAndNormalize(x, y, z, w) {
        const mag = Math.sqrt(x * x + y * y + z * z + w * w);
        return this.setXYZW(x / mag, y / mag, z / mag, w / mag);
    }
    /** Get the length of the quaternion. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3]);
    }
    /** Get the squared length of the quaternion. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3];
    }
    /** Make this quaternion an identity quaternion */ identity() {
        return Quaternion.identity(this);
    }
    /**
   * Normalize this quaternion inplace.
   * @returns self
   */ inplaceNormalize() {
        return Quaternion.normalize(this, this);
    }
    /**
   * Calculates the conjugate of this quaternion inplace.
   * @returns self
   */ inplaceConjugate() {
        return Quaternion.conjugate(this, this);
    }
    /**
   * Multiply this quaternion by another quaternion at the right side inplace.
   * @param other - The quaternion that to be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Quaternion.multiply(this, other, this);
    }
    /**
   * Multiply this quaternion by another quaternion at the left side inplace.
   * @param other - The quaternion that to be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Quaternion.multiply(other, this, this);
    }
    /**
   * Make a quaternion used to rotate a unit vector to another inplace.
   * @param from - The unit vector to be rotated.
   * @param to - The destination unit vector.
   * @returns self
   */ unitVectorToUnitVector(from, to) {
        return Quaternion.unitVectorToUnitVector(from, to, this);
    }
    /**
   * Calculates the quaternion from an euler angle in specific order inplace.
   * @param x - Angle to rotate around X axis in radians.
   * @param y - Angle to rotate around Y axis in radians.
   * @param z - Angle to rotate around Z axis in radians.
   * @param order - Intrinsic order for conversion.
   * @returns self
   */ fromEulerAngle(x, y, z, order) {
        return Quaternion.fromEulerAngle(x, y, z, order, this);
    }
    /**
   * Calculates the quaternion from the given angle and rotation axis inplace.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle.
   * @returns self
   */ fromAxisAngle(axis, angle) {
        return Quaternion.fromAxisAngle(axis, angle, this);
    }
    /**
   * Calculates the rotation axis and angle for this quaternion
   * @param axis - A vector that receives the rotation axis.
   * @returns - The rotation angle
   */ toAxisAngle(axis) {
        const rad = Math.acos(this[3]) * 2;
        const s = Math.sin(rad / 2);
        if (s > 0.000001) {
            axis.setXYZ(this[0] / s, this[1] / 2, this[2] / s);
        } else {
            axis.setXYZ(1, 0, 0);
        }
        return rad;
    }
    /**
   * Convert this rotation to euler angles in ZYX order
   * @param angles - A vector that receives the euler angles. If not given, a new vector will be created.
   * @returns The vector that holds the euler angles.
   */ toEulerAngles(angles) {
        angles = angles ?? new Vector3();
        const t0 = 2 * (this.w * this.x + this.y * this.z);
        const t1 = 1 - 2 * (this.x * this.x + this.y * this.y);
        const roll = Math.atan2(t0, t1);
        const t2 = Math.max(-1, Math.min(1, 2 * (this.w * this.y - this.z * this.x)));
        const pitch = Math.asin(t2);
        const t3 = 2 * (this.w * this.z + this.x * this.y);
        const t4 = 1 - 2 * (this.y * this.y + this.z * this.z);
        const yaw = Math.atan2(t3, t4);
        return angles.setXYZ(roll, pitch, yaw);
    }
    /**
   * Calculates the quaternion from a rotation matrix inplace.
   * @param matrix - The rotation matrix.
   * @returns self
   */ fromRotationMatrix(matrix) {
        return Quaternion.fromRotationMatrix(matrix, this);
    }
    /**
   * Convert this quaternion to a 3x3 rotation matrix.
   * @param matrix - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix.
   */ toMatrix3x3(matrix) {
        const m = matrix || new Matrix3x3();
        this.toMatrix(m);
        return m;
    }
    /**
   * Convert this quaternion to a 4x4 rotation matrix.
   *
   * @remarks
   * Only left top 3x3 part of the matrix will be changed.
   *
   * @param matrix - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix.
   */ toMatrix4x4(matrix) {
        const m = matrix || Matrix4x4.identity();
        this.toMatrix(m);
        return m;
    }
    /**
   * Get the direction of axis x
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis x
   */ getDirectionX(result) {
        result = result ?? new Vector3();
        return result.setXYZ(1 - 2 * (this.y * this.y + this.z * this.z), 2 * (this.x * this.y + this.z * this.w), 2 * (this.z * this.x - this.y * this.w));
    }
    /**
   * Get the direction of axis y
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis y
   */ getDirectionY(result) {
        result = result ?? new Vector3();
        return result.setXYZ(2 * (this.x * this.y - this.z * this.w), 1 - 2 * (this.z * this.z + this.x * this.x), 2 * (this.y * this.z + this.x * this.w));
    }
    /**
   * Get the direction of axis z
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis z
   */ getDirectionZ(result) {
        result = result ?? new Vector3();
        return result.setXYZ(2 * (this.z * this.x + this.y * this.w), 2 * (this.y * this.z - this.x * this.w), 1 - 2 * (this.y * this.y + this.x * this.x));
    }
    /**
   * Get the rotate angle and the rotation axis for this quaternion.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns An vector4 that the x, y, z component presents the axis and the w component presents the angle.
   */ getAxisAngle(result) {
        result = result ?? new Vector4();
        const sign = this.w < 0 ? -1 : 1;
        const x = this.x * sign;
        const y = this.y * sign;
        const z = this.z * sign;
        const w = this.w * sign;
        const halfAngle = Math.acos(w);
        const sinHalf = Math.sin(halfAngle);
        return result.setXYZW(x / sinHalf, y / sinHalf, z / sinHalf, 2 * halfAngle);
    }
    /**
   * Rotate a vector
   * @param v - The vector to be rotated.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The rotation result.
   */ transform(v, result) {
        result = result || new Vector3();
        const x = this.x * 2;
        const y = this.y * 2;
        const z = this.z * 2;
        const xx = this.x * x;
        const yy = this.y * y;
        const zz = this.z * z;
        const xy = this.x * y;
        const xz = this.x * z;
        const yz = this.y * z;
        const wx = this.w * x;
        const wy = this.w * y;
        const wz = this.w * z;
        return result.setXYZ((1 - yy - zz) * v.x + (xy - wz) * v.y + (xz + wy) * v.z, (xy + wz) * v.x + (1 - xx - zz) * v.y + (yz - wx) * v.z, (xz - wy) * v.x + (yz + wx) * v.y + (1 - xx - yy) * v.z);
    }
    /**
   * Scale a Quaternion by a scalar number.
   * @param a - The quaternion to be scaled.
   * @param b - The scalar number.
   * @param result - The output quaternion (can be the same quaternion as a). if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static scale(q, t, result) {
        result = result || q;
        return result.setXYZW(q.x * t, q.y * t, q.z * t, q.w * t);
    }
    /**
   * Calculates the dot product of two Quaternion's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
    }
    /**
   * Create an identity quaternion
   * @param q - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static identity(q) {
        return (q || new Quaternion()).setXYZW(0, 0, 0, 1);
    }
    /**
   * Normalize a quaternion
   * @param q - The input quaternion
   * @param result - The output quaternion (can be the same as q), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static normalize(q, result) {
        const mag = q.magnitude;
        return (result || new Quaternion()).setXYZW(q.x / mag, q.y / mag, q.z / mag, q.w / mag);
    }
    /**
   * Gets the conjugate of a quaternion
   * @param q - The input quaternion
   * @param result - The output quaternion (can be the same as q), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static conjugate(q, result) {
        return (result || new Quaternion()).setXYZW(-q.x, -q.y, -q.z, q.w);
    }
    /**
   * Multiply two Quaternion's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output quaternion (can be the same as a or b). if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static multiply(a, b, result) {
        result = result || new Quaternion();
        const x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
        const y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
        const z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
        const w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        return result.setXYZW(x, y, z, w);
    }
    /**
   * Performs a spherical linear interpolation between two quat.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param t - The interpolation amount, in the range [0-1].
   * @param result - The output quaternion (can be the same as a or b), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static slerp(a, b, t, result) {
        result = result || new Quaternion();
        if (t <= 0) {
            return result.setXYZW(a.x, a.y, a.z, a.w);
        }
        if (t >= 1) {
            return result.setXYZW(b.x, b.y, b.z, b.w);
        }
        const halfCos1 = this.dot(a, b);
        const inv = halfCos1 < 0 ? -1 : 1;
        const ax = a.x;
        const ay = a.y;
        const az = a.z;
        const aw = a.w;
        const bx = b.x * inv;
        const by = b.y * inv;
        const bz = b.z * inv;
        const bw = b.w * inv;
        const halfCos = halfCos1 * inv;
        if (halfCos >= 1) {
            return result.setXYZW(ax, ay, az, aw);
        }
        const halfSinSqr = 1 - halfCos * halfCos;
        if (halfSinSqr <= Number.EPSILON) {
            const s = 1 - t;
            return result.setAndNormalize(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t, a.w * s + b.w * t);
        }
        const halfSin = Math.sqrt(halfSinSqr);
        const halfTheta = Math.atan2(halfSin, halfCos);
        const ratioA = Math.sin((1 - t) * halfTheta) / halfSin;
        const ratioB = Math.sin(t * halfTheta) / halfSin;
        return result.setXYZW(ax * ratioA + bx * ratioB, ay * ratioA + by * ratioB, az * ratioA + bz * ratioB, aw * ratioA + bw * ratioB);
    }
    /**
   * Gets the angular distance between two unit quaternions.
   * @param a - The origin quaternion
   * @param b - The destination quaternion
   * @returns - The angle in radians
   */ static angleBetween(a, b) {
        const x = this.dot(a, b);
        const clamped = x < -1 ? -1 : x > 1 ? 1 : x;
        return 2 * Math.acos(Math.abs(clamped));
    }
    /**
   * Creates a quaternion used to rotate a unit vector to another.
   * @param from - The unit vector to be rotated.
   * @param to - The destination unit vector.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static unitVectorToUnitVector(from, to, result) {
        // assume from and to are unit vectors
        result = result || new Quaternion();
        let r = Vector3.dot(from, to) + 1;
        if (r < 0.000001) {
            r = 0;
            if (Math.abs(from.x) > Math.abs(from.z)) {
                return result.setAndNormalize(-from.y, from.x, 0, r);
            } else {
                return result.setAndNormalize(0, -from.z, from.y, r);
            }
        } else {
            return result.setAndNormalize(from.y * to.z - from.z * to.y, from.z * to.x - from.x * to.z, from.x * to.y - from.y * to.x, r);
        }
    }
    /**
   * Creates a quaternion from an euler angle in specific order.
   * @param x - Angle to rotate around X axis in radians.
   * @param y - Angle to rotate around Y axis in radians.
   * @param z - Angle to rotate around Z axis in radians.
   * @param order - Intrinsic order for conversion.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static fromEulerAngle(a, b, c, order, result) {
        result = result || new Quaternion();
        const c1 = Math.cos(a / 2);
        const c2 = Math.cos(b / 2);
        const c3 = Math.cos(c / 2);
        const s1 = Math.sin(a / 2);
        const s2 = Math.sin(b / 2);
        const s3 = Math.sin(c / 2);
        switch(order){
            case 'XYZ':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'YXZ':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
            case 'ZXY':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'ZYX':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
            case 'YZX':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'XZY':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
        }
    }
    /**
   * Creates a quaternion from the given angle and rotation axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static fromAxisAngle(axis, angle, result) {
        // assume axis is normalized
        result = result || new Quaternion();
        const halfAngle = angle / 2;
        const s = Math.sin(halfAngle);
        return result.setXYZW(axis.x * s, axis.y * s, axis.z * s, Math.cos(halfAngle));
    }
    /**
   * Creates a quaternion from a rotation matrix.
   * @param matrix - The rotation matrix.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns self
   */ static fromRotationMatrix(matrix, result) {
        // assume matrix contains rotation without scaling
        result = result || new Quaternion();
        const trace = matrix.m00 + matrix.m11 + matrix.m22;
        let s;
        if (trace > 0) {
            s = 0.5 / Math.sqrt(trace + 1);
            result.setXYZW((matrix.m21 - matrix.m12) * s, (matrix.m02 - matrix.m20) * s, (matrix.m10 - matrix.m01) * s, 0.25 / s);
        } else if (matrix.m00 > matrix.m11 && matrix.m00 > matrix.m22) {
            s = 2 * Math.sqrt(1 + matrix.m00 - matrix.m11 - matrix.m22);
            result.setXYZW(0.25 * s, (matrix.m01 + matrix.m10) / s, (matrix.m02 + matrix.m20) / s, (matrix.m21 - matrix.m12) / s);
        } else if (matrix.m11 > matrix.m22) {
            s = 2 * Math.sqrt(1 - matrix.m00 + matrix.m11 - matrix.m22);
            result.setXYZW((matrix.m10 + matrix.m01) / s, 0.25 * s, (matrix.m21 + matrix.m12) / s, (matrix.m02 - matrix.m20) / s);
        } else {
            s = 2 * Math.sqrt(1 - matrix.m00 - matrix.m11 + matrix.m22);
            result.setXYZW((matrix.m02 + matrix.m20) / s, (matrix.m12 + matrix.m21) / s, 0.25 * s, (matrix.m10 - matrix.m01) / s);
        }
        return result;
    }
    /** @internal */ toMatrix(matrix) {
        const xx = this.x * this.x;
        const yy = this.y * this.y;
        const zz = this.z * this.z;
        const xy = this.x * this.y;
        const zw = this.z * this.w;
        const zx = this.z * this.x;
        const yw = this.y * this.w;
        const yz = this.y * this.z;
        const xw = this.x * this.w;
        matrix.m00 = 1 - 2 * (yy + zz);
        matrix.m10 = 2 * (xy + zw);
        matrix.m20 = 2 * (zx - yw);
        matrix.m01 = 2 * (xy - zw);
        matrix.m11 = 1 - 2 * (zz + xx);
        matrix.m21 = 2 * (yz + xw);
        matrix.m02 = 2 * (zx + yw);
        matrix.m12 = 2 * (yz - xw);
        matrix.m22 = 1 - 2 * (yy + xx);
    }
}
/**
 * Observable 4 dimentional vector
 *
 * @public
 */ class ObservableQuaternion extends Quaternion {
    /** @internal */ _callback;
    /** The callback function which will be executed when the value changed */ get callback() {
        return this._callback;
    }
    set callback(cb) {
        this._callback = cb;
    }
    /**
   * {@inheritDoc Quaternion.x}
   */ get x() {
        return super.x;
    }
    set x(val) {
        val = toFloat(val);
        if (val !== super.x) {
            super.x = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.y}
   */ get y() {
        return super.y;
    }
    set y(val) {
        val = toFloat(val);
        if (val !== super.y) {
            super.y = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.z}
   */ get z() {
        return super.z;
    }
    set z(val) {
        val = toFloat(val);
        if (val !== super.z) {
            super.z = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.w}
   */ get w() {
        return super.w;
    }
    set w(val) {
        val = toFloat(val);
        if (val !== super.w) {
            super.w = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.setXYZW}
   */ setXYZW(x, y, z, w) {
        x = toFloat(x);
        y = toFloat(y);
        z = toFloat(z);
        w = toFloat(w);
        if (x !== super.x || y !== super.y || z !== super.z || w !== super.w) {
            super.setXYZW(x, y, z, w);
            this._callback && this._callback();
        }
        return this;
    }
    /**
   * Inherited from Float32Array.copyWithin
   */ copyWithin(target, start, end) {
        super.copyWithin(target, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.fill
   */ fill(value, start, end) {
        super.fill(value, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.reverse
   */ reverse() {
        super.reverse();
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.set
   */ set(array, offset) {
        super.set(array, offset);
        this._callback && this._callback();
    }
    /**
   * Inherited from Float32Array.sort
   */ sort(compareFn) {
        super.sort(compareFn);
        this._callback && this._callback();
        return this;
    }
}
/**
 * 3x3 Matrix
 *
 * @remarks
 * The matrix is column-major:
 * | m00, m10, m20 |
 * | m01, m11, m21 |
 * | m02, m12, m22 |
 *
 * @public
 */ class Matrix3x3 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 9);
        } else {
            super(9);
            if (typeof arg0 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
                this[4] = arg4;
                this[5] = arg5;
                this[6] = arg6;
                this[7] = arg7;
                this[8] = arg8;
            } else if (arg0 instanceof Quaternion) {
                arg0.toMatrix3x3(this);
            } else if (arg0 instanceof Matrix4x4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[4];
                this[4] = arg0[5];
                this[5] = arg0[6];
                this[6] = arg0[8];
                this[7] = arg0[9];
                this[8] = arg0[10];
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 9) {
                this.set(arg0);
            } else if (arg0 === void 0) {
                this.identity();
            } else {
                throw new Error('Matrix3x4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Matrix3x3 initialized with values from this matrix.
   * @returns The new matrix.
   */ clone() {
        return new Matrix3x3(this);
    }
    /** Get the element at row 0, column 0 */ get m00() {
        return this[0];
    }
    set m00(v) {
        this[0] = v;
    }
    /** Get the element at row 0, column 1 */ get m10() {
        return this[1];
    }
    set m10(v) {
        this[1] = v;
    }
    /** Get the element at row 0, column 2 */ get m20() {
        return this[2];
    }
    set m20(v) {
        this[2] = v;
    }
    /** Get the element at row 1, column 0 */ get m01() {
        return this[3];
    }
    set m01(v) {
        this[3] = v;
    }
    /** Get the element at row 1, column 1 */ get m11() {
        return this[4];
    }
    set m11(v) {
        this[4] = v;
    }
    /** Get the element at row 1, column 2 */ get m21() {
        return this[5];
    }
    set m21(v) {
        this[5] = v;
    }
    /** Get the element at row 2, column 0 */ get m02() {
        return this[6];
    }
    set m02(v) {
        this[6] = v;
    }
    /** Get the element at row 2, column 1 */ get m12() {
        return this[7];
    }
    set m12(v) {
        this[7] = v;
    }
    /** Get the element at row 2, column 2 */ get m22() {
        return this[8];
    }
    set m22(v) {
        this[8] = v;
    }
    /**
   * Get the values in a row as a Vector3
   * @param row - The row index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getRow(row, result) {
        return (result || new Vector3()).setXYZ(this[row * 3], this[row * 3 + 1], this[row * 3 + 2]);
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param v - The values to be set
   * @returns - self
   */ setRow(row, v) {
        this[row * 3] = v.x;
        this[row * 3 + 1] = v.y;
        this[row * 3 + 2] = v.z;
        return this;
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param x - The first value of the row to be set
   * @param y - The second value of the row to be set
   * @param z - The third value of the row to be set
   * @returns - self
   */ setRowXYZ(row, x, y, z) {
        this[row * 3] = x;
        this[row * 3 + 1] = y;
        this[row * 3 + 2] = z;
        return this;
    }
    /**
   * Get the values in a column as a Vector3
   * @param col - The column index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getCol(col, result) {
        return (result || new Vector3()).setXYZ(this[col], this[3 + col], this[6 + col]);
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param v - The values to be set.
   * @returns self
   */ setCol(col, v) {
        this[col] = v.x;
        this[3 + col] = v.y;
        this[6 + col] = v.z;
        return this;
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param x - The first value of the column to be set.
   * @param y - The second value of the column to be set.
   * @param z - The third value of the column to be set.
   * @returns self
   */ setColXYZ(col, x, y, z) {
        this[col] = x;
        this[3 + col] = y;
        this[6 + col] = z;
        return this;
    }
    /**
   * Adds two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static add(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] + b[i];
        }
        return result;
    }
    /**
   * Subtracts two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns
   */ static sub(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] - b[i];
        }
        return result;
    }
    /**
   * Multiplys two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static mul(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] * b[i];
        }
        return result;
    }
    /**
   * Divides two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static div(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] / b[i];
        }
        return result;
    }
    /**
   * Scales a Matrix3x3 by a scalar number component-wise.
   * @param a - The matrix to be scaled.
   * @param f - The scalar number.
   * @param result - The output matrix (can be the same as a), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scale(a, f, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] * f;
        }
        return result;
    }
    /**
   * Creates an identity Matrix3x3.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static identity(result) {
        result = result || new Matrix3x3();
        result.set(IDENT_MATRIX3x3);
        return result;
    }
    /**
   * Transpose a Matrix3x3.
   * @param matrix - The matrix to be transposed.
   * @param result - The output matrix (can be the same as matrix), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static transpose(matrix, result) {
        result = result || new Matrix3x3();
        if (matrix === result) {
            [result[1], result[3]] = [
                result[3],
                result[1]
            ];
            [result[2], result[6]] = [
                result[6],
                result[2]
            ];
            [result[5], result[7]] = [
                result[7],
                result[5]
            ];
        } else {
            result[0] = matrix[0];
            result[1] = matrix[3];
            result[2] = matrix[6];
            result[3] = matrix[1];
            result[4] = matrix[4];
            result[5] = matrix[7];
            result[6] = matrix[2];
            result[7] = matrix[5];
            result[8] = matrix[8];
        }
        return result;
    }
    /**
   * Inverts a Matrix3x3
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invert(matrix, result) {
        result = result || new Matrix3x3();
        const m00 = matrix[0];
        const m01 = matrix[1];
        const m02 = matrix[2];
        const m10 = matrix[3];
        const m11 = matrix[4];
        const m12 = matrix[5];
        const m20 = matrix[6];
        const m21 = matrix[7];
        const m22 = matrix[8];
        const tmp_0 = m22 * m11 - m12 * m21;
        const tmp_1 = m12 * m20 - m22 * m10;
        const tmp_2 = m21 * m10 - m20 * m11;
        const d = 1 / (m00 * tmp_0 + m01 * tmp_1 + m02 * tmp_2);
        result[0] = tmp_0 * d;
        result[1] = (m02 * m21 - m22 * m01) * d;
        result[2] = (m12 * m01 - m02 * m11) * d;
        result[3] = tmp_1 * d;
        result[4] = (m22 * m00 - m02 * m20) * d;
        result[5] = (m02 * m10 - m12 * m00) * d;
        result[6] = tmp_2 * d;
        result[7] = (m01 * m20 - m21 * m00) * d;
        result[8] = (m11 * m00 - m01 * m10) * d;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around x axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationX(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = c;
        result[5] = s;
        result[6] = 0;
        result[7] = -s;
        result[8] = c;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around y axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationY(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = 0;
        result[2] = -s;
        result[3] = 0;
        result[4] = 1;
        result[5] = 0;
        result[6] = s;
        result[7] = 0;
        result[8] = c;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around z axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationZ(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = s;
        result[2] = 0;
        result[3] = -s;
        result[4] = c;
        result[5] = 0;
        result[6] = 0;
        result[7] = 0;
        result[8] = 1;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around a given axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotation(axis, angle, result) {
        result = result || new Matrix3x3();
        let x = axis.x;
        let y = axis.y;
        let z = axis.z;
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const oneMinusCosine = 1 - c;
        result[0] = xx + (1 - xx) * c;
        result[1] = x * y * oneMinusCosine + z * s;
        result[2] = x * z * oneMinusCosine - y * s;
        result[3] = x * y * oneMinusCosine - z * s;
        result[4] = yy + (1 - yy) * c;
        result[5] = y * z * oneMinusCosine + x * s;
        result[6] = x * z * oneMinusCosine + y * s;
        result[7] = y * z * oneMinusCosine - x * s;
        result[8] = zz + (1 - zz) * c;
        return result;
    }
    /**
   * Multiplies two Matrix3x3's
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiply(m1, m2, result) {
        result = result || new Matrix3x3();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a10 = m1[3];
        const a11 = m1[4];
        const a12 = m1[5];
        const a20 = m1[6];
        const a21 = m1[7];
        const a22 = m1[8];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b10 = m2[3];
        const b11 = m2[4];
        const b12 = m2[5];
        const b20 = m2[6];
        const b21 = m2[7];
        const b22 = m2[8];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = a00 * b10 + a10 * b11 + a20 * b12;
        result[4] = a01 * b10 + a11 * b11 + a21 * b12;
        result[5] = a02 * b10 + a12 * b11 + a22 * b12;
        result[6] = a00 * b20 + a10 * b21 + a20 * b22;
        result[7] = a01 * b20 + a11 * b21 + a21 * b22;
        result[8] = a02 * b20 + a12 * b21 + a22 * b22;
        return result;
    }
    /**
   * Subtract a matrix from this matrix component-wise.
   * @param other - The matrix that will be subtract.
   * @returns self
   */ subBy(other) {
        return Matrix3x3.sub(this, other, this);
    }
    /**
   * Add a matrix to this matrix component-wise.
   * @param other - The matrix that will be added.
   * @returns self
   */ addBy(other) {
        return Matrix3x3.add(this, other, this);
    }
    /**
   * Multiplies this matrix by a matrix component-wise.
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Matrix3x3.mul(this, other, this);
    }
    /**
   * Divide this matrix by a matrix component-wise.
   * @param other - The matrix that will be divide by.
   * @returns self
   */ divBy(other) {
        return Matrix3x3.div(this, other, this);
    }
    /**
   * Scale this matrix by a scalar number component-wise.
   * @param f - amount to scale this matrix by.
   * @returns self
   */ scaleBy(f) {
        return Matrix3x3.scale(this, f, this);
    }
    /**
   * Make this matrix identity.
   * @returns self
   */ identity() {
        return Matrix3x3.identity(this);
    }
    /**
   * Calculate the inverse of this matrix inplace.
   * @returns self
   */ inplaceInvert() {
        return Matrix3x3.invert(this, this);
    }
    /**
   * Calculate the transpose of this matrix inplace.
   * @returns self
   */ transpose() {
        return Matrix3x3.transpose(this, this);
    }
    /**
   * Post-multiply by a matrix inplace.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Matrix3x3.multiply(this, other, this);
    }
    /**
   * Pre-multiply by a matrix inplace.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Matrix3x3.multiply(other, this, this);
    }
    /**
   * Calculates a rotation around x axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationX(angle) {
        return Matrix3x3.rotationX(angle, this);
    }
    /**
   * Calculates a rotation around y axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationY(angle) {
        return Matrix3x3.rotationY(angle, this);
    }
    /**
   * Calculates a rotation around z axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationZ(angle) {
        return Matrix3x3.rotationZ(angle, this);
    }
    /**
   * Calculates a rotation around a given axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotation(axis, angle) {
        return Matrix3x3.rotation(axis, angle, this);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transform(vec, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * vec[0] + this[3] * vec[1] + this[6] * vec[2], this[1] * vec[0] + this[4] * vec[1] + this[7] * vec[2], this[2] * vec[0] + this[5] * vec[1] + this[8] * vec[2]);
    }
    /**
   * {@inheritDoc Matrix3x3.transform}
   */ transformPoint(vec, result) {
        return this.transform(vec, result);
    }
    /**
   * {@inheritDoc Matrix3x3.transform}
   */ transformVector(vec, result) {
        return this.transform(vec, result);
    }
}
/**
 * 4x4 Matrix
 *
 * @remarks
 * The matrix is column-major:
 * | m00, m10, m20, m30 |
 * | m01, m11, m21, m31 |
 * | m02, m12, m22, m32 |
 * | m03, m13, m23, m33 |
 *
 * @public
 */ class Matrix4x4 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 16);
        } else {
            super(16);
            if (typeof arg0 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
                this[4] = arg4;
                this[5] = arg5;
                this[6] = arg6;
                this[7] = arg7;
                this[8] = arg8;
                this[9] = arg9;
                this[10] = arg10;
                this[11] = arg11;
                this[12] = arg12;
                this[13] = arg13;
                this[14] = arg14;
                this[15] = arg15;
            } else if (arg0 instanceof Quaternion) {
                arg0.toMatrix4x4(this);
                this.m03 = 0;
                this.m13 = 0;
                this.m23 = 0;
                this.m30 = 0;
                this.m31 = 0;
                this.m32 = 0;
                this.m33 = 1;
            } else if (arg0 instanceof Matrix3x3) {
                this.m00 = arg0.m00;
                this.m01 = arg0.m01;
                this.m02 = arg0.m02;
                this.m03 = 0;
                this.m10 = arg0.m10;
                this.m11 = arg0.m11;
                this.m12 = arg0.m12;
                this.m13 = 0;
                this.m20 = arg0.m20;
                this.m21 = arg0.m21;
                this.m22 = arg0.m22;
                this.m23 = 0;
                this.m30 = 0;
                this.m31 = 0;
                this.m32 = 0;
                this.m33 = 1;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 16) {
                this.set(arg0);
            } else if (arg0 === void 0) {
                this.identity();
            } else {
                throw new Error('Matrix4x4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Matrix4x4 initialized with values from this matrix.
   * @returns The new matrix.
   */ clone() {
        return new Matrix4x4(this);
    }
    /** Get the element at row 0, column 0 */ get m00() {
        return this[0];
    }
    set m00(v) {
        this[0] = v;
    }
    /** Get the element at row 0, column 1 */ get m10() {
        return this[1];
    }
    set m10(v) {
        this[1] = v;
    }
    /** Get the element at row 0, column 2 */ get m20() {
        return this[2];
    }
    set m20(v) {
        this[2] = v;
    }
    /** Get the element at row 0, column 3 */ get m30() {
        return this[3];
    }
    set m30(v) {
        this[3] = v;
    }
    /** Get the element at row 1, column 0 */ get m01() {
        return this[4];
    }
    set m01(v) {
        this[4] = v;
    }
    /** Get the element at row 1, column 1 */ get m11() {
        return this[5];
    }
    set m11(v) {
        this[5] = v;
    }
    /** Get the element at row 1, column 2 */ get m21() {
        return this[6];
    }
    set m21(v) {
        this[6] = v;
    }
    /** Get the element at row 1, column 3 */ get m31() {
        return this[7];
    }
    set m31(v) {
        this[7] = v;
    }
    /** Get the element at row 2, column 0 */ get m02() {
        return this[8];
    }
    set m02(v) {
        this[8] = v;
    }
    /** Get the element at row 2, column 1 */ get m12() {
        return this[9];
    }
    set m12(v) {
        this[9] = v;
    }
    /** Get the element at row 2, column 2 */ get m22() {
        return this[10];
    }
    set m22(v) {
        this[10] = v;
    }
    /** Get the element at row 2, column 3 */ get m32() {
        return this[11];
    }
    set m32(v) {
        this[11] = v;
    }
    /** Get the element at row 3, column 0 */ get m03() {
        return this[12];
    }
    set m03(v) {
        this[12] = v;
    }
    /** Get the element at row 3, column 1 */ get m13() {
        return this[13];
    }
    set m13(v) {
        this[13] = v;
    }
    /** Get the element at row 3, column 2 */ get m23() {
        return this[14];
    }
    set m23(v) {
        this[14] = v;
    }
    /** Get the element at row 3, column 3 */ get m33() {
        return this[15];
    }
    set m33(v) {
        this[15] = v;
    }
    /**
   * Get the values in a row as a Vector4
   * @param row - The row index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getRow(row, result) {
        return (result || new Vector4()).setXYZW(this[row * 4], this[row * 4 + 1], this[row * 4 + 2], this[row * 4 + 3]);
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param v - The values to be set
   * @returns - self
   */ setRow(row, v) {
        this[row * 4] = v.x;
        this[row * 4 + 1] = v.y;
        this[row * 4 + 2] = v.z;
        this[row * 4 + 3] = v.w;
        return this;
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param x - The first value of the row to be set
   * @param y - The second value of the row to be set
   * @param z - The third value of the row to be set
   * @param w - The fourth value of the row to be set
   * @returns - self
   */ setRowXYZW(row, x, y, z, w) {
        this[row * 4] = x;
        this[row * 4 + 1] = y;
        this[row * 4 + 2] = z;
        this[row * 4 + 3] = w;
        return this;
    }
    /**
   * Get the values in a column as a Vector4
   * @param col - The column index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getCol(col, result) {
        return (result || new Vector4()).setXYZW(this[col], this[4 + col], this[8 + col], this[12 + col]);
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param v - The values to be set.
   * @returns self
   */ setCol(col, v) {
        this[col] = v.x;
        this[4 + col] = v.y;
        this[8 + col] = v.z;
        this[12 + col] = v.w;
        return this;
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param x - The first value of the column to be set.
   * @param y - The second value of the column to be set.
   * @param z - The third value of the column to be set.
   * @param w - The fourth value of the column to be set.
   * @returns self
   */ setColXYZW(col, x, y, z, w) {
        this[col] = x;
        this[4 + col] = y;
        this[8 + col] = z;
        this[12 + col] = w;
        return this;
    }
    /**
   * Adds two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static add(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] + b[i];
        }
        return result;
    }
    /**
   * Subtracts two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns
   */ static sub(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] - b[i];
        }
        return result;
    }
    /**
   * Multiplys two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static mul(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] * b[i];
        }
        return result;
    }
    /**
   * Divides two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static div(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] / b[i];
        }
        return result;
    }
    /**
   * Scales a Matrix4x4 by a scalar number component-wise.
   * @param a - The matrix to be scaled.
   * @param f - The scalar number.
   * @param result - The output matrix (can be the same as a), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scale(a, f, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] * f;
        }
        return result;
    }
    /**
   * Creates an identity Matrix4x4.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static identity(result) {
        result = result || new Matrix4x4();
        result.set(IDENT_MATRIX4x4);
        return result;
    }
    /**
   * Creates an orthogonal projection matrix from a given frustum.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static ortho(left, right, bottom, top, near, far, result) {
        result = result || new Matrix4x4();
        result[0] = 2 / (right - left);
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 2 / (top - bottom);
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 2 / (near - far);
        result[11] = 0;
        result[12] = (left + right) / (left - right);
        result[13] = (bottom + top) / (bottom - top);
        result[14] = (near + far) / (near - far);
        result[15] = 1;
        return result;
    }
    /**
   * Creates a reflection matrix from a plane.
   * @param nx - The x component of the plane normal.
   * @param ny - The y component of the plane normal.
   * @param nz - The z component of the plane normal.
   * @param d - The plane distance.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static reflection(nx, ny, nz, d, result) {
        result = result || new Matrix4x4();
        result.m00 = 1 - 2 * nx * nx;
        result.m01 = -2 * nx * ny;
        result.m02 = -2 * nx * nz;
        result.m03 = -2 * nx * d;
        result.m10 = -2 * nx * ny;
        result.m11 = 1 - 2 * ny * ny;
        result.m12 = -2 * ny * nz;
        result.m13 = -2 * ny * d;
        result.m20 = -2 * nx * nz;
        result.m21 = -2 * ny * nz;
        result.m22 = 1 - 2 * nz * nz;
        result.m23 = -2 * nz * d;
        result.m30 = 0;
        result.m31 = 0;
        result.m32 = 0;
        result.m33 = 1;
        return result;
    }
    /**
   * Creates a right-handed perspective projection matrix.
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio.
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static perspective(fovY, aspect, znear, zfar, result) {
        const h = znear * Math.tan(fovY * 0.5);
        const w = h * aspect;
        return this.frustum(-w, w, -h, h, znear, zfar, result);
    }
    static obliqueProjection(projectionMatrix, clipPlane) {
        const result = new Matrix4x4(projectionMatrix);
        const q = Matrix4x4.invert(projectionMatrix).transform(new Vector4(clipPlane.a > 0 ? 1 : -1, clipPlane.b > 0 ? 1 : -1, 1, 1));
        const s = 2 / (q.x * clipPlane.a + q.y * clipPlane.b + q.z * clipPlane.c + q.w * clipPlane.d);
        result[2] = clipPlane.a * s - result[3];
        result[6] = clipPlane.b * s - result[7];
        result[10] = clipPlane.c * s - result[11];
        result[14] = clipPlane.d * s - result[15];
        return result;
    }
    static obliquePerspective(perspectiveMatrix, nearPlane) {
        const result = new Matrix4x4(perspectiveMatrix);
        const q = new Vector4(((nearPlane.x > 0 ? 1 : nearPlane.x < 0 ? -1 : 0) + perspectiveMatrix.m02) / perspectiveMatrix.m00, ((nearPlane.y > 0 ? 1 : nearPlane.y < 0 ? -1 : 0) + perspectiveMatrix.m12) / perspectiveMatrix.m11, -1, (1 + perspectiveMatrix.m22) / perspectiveMatrix.m23);
        const c = Vector4.scale(nearPlane, 2 / Vector4.dot(nearPlane, q));
        result.m20 = c.x;
        result.m21 = c.y;
        result.m22 = c.z + 1;
        result.m23 = c.w;
        return result;
    /*
        float       matrix[16];
        Vector4D    q;

        // Grab the current projection matrix from OpenGL
        glGetFloatv(GL_PROJECTION_MATRIX, matrix);

        // Calculate the clip-space corner point opposite the clipping plane
        // as (sgn(clipPlane.x), sgn(clipPlane.y), 1, 1) and
        // transform it into camera space by multiplying it
        // by the inverse of the projection matrix

        q.x = (sgn(clipPlane.x) + matrix[8]) / matrix[0];
        q.y = (sgn(clipPlane.y) + matrix[9]) / matrix[5];
        q.z = -1.0F;
        q.w = (1.0F + matrix[10]) / matrix[14];

        // Calculate the scaled plane vector
        Vector4D c = clipPlane * (2.0F / Dot(clipPlane, q));

        // Replace the third row of the projection matrix
        matrix[2] = c.x;
        matrix[6] = c.y;
        matrix[10] = c.z + 1.0F;
        matrix[14] = c.w;

        // Load it back into OpenGL
        glMatrixMode(GL_PROJECTION);
        glLoadMatrix(matrix);
    }
    */ }
    /**
   * Creates a perspective projection matrix from a frustum.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param znear - Near bound of the frustum.
   * @param zfar - Far bound of the frustum.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static frustum(left, right, bottom, top, znear, zfar, result) {
        result = result || new Matrix4x4();
        const dx = right - left;
        const dy = top - bottom;
        const dz = znear - zfar;
        result[0] = 2 * znear / dx;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 2 * znear / dy;
        result[6] = 0;
        result[7] = 0;
        result[8] = (left + right) / dx;
        result[9] = (top + bottom) / dy;
        result[10] = (znear + zfar) / dz;
        result[11] = -1;
        result[12] = 0;
        result[13] = 0;
        result[14] = 2 * znear * zfar / dz;
        result[15] = 0;
        return result;
    }
    /**
   * Transpose a Matrix4x4.
   * @param matrix - The matrix to be transposed.
   * @param result - The output matrix (can be the same as matrix), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static transpose(matrix, result) {
        result = result || new Matrix4x4();
        if (matrix === result) {
            [result[1], result[4]] = [
                result[4],
                result[1]
            ];
            [result[2], result[8]] = [
                result[8],
                result[2]
            ];
            [result[3], result[12]] = [
                result[12],
                result[3]
            ];
            [result[6], result[9]] = [
                result[9],
                result[6]
            ];
            [result[7], result[13]] = [
                result[13],
                result[7]
            ];
            [result[11], result[14]] = [
                result[14],
                result[11]
            ];
        } else {
            result[0] = matrix[0];
            result[1] = matrix[4];
            result[2] = matrix[8];
            result[3] = matrix[12];
            result[4] = matrix[1];
            result[5] = matrix[5];
            result[6] = matrix[9];
            result[7] = matrix[13];
            result[8] = matrix[2];
            result[9] = matrix[6];
            result[10] = matrix[10];
            result[11] = matrix[14];
            result[12] = matrix[3];
            result[13] = matrix[7];
            result[14] = matrix[11];
            result[15] = matrix[15];
        }
        return result;
    }
    /**
   * Inverts a Matrix4x4
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invert(matrix, result) {
        result = result || new Matrix4x4();
        const m00 = matrix[0 * 4 + 0];
        const m01 = matrix[0 * 4 + 1];
        const m02 = matrix[0 * 4 + 2];
        const m03 = matrix[0 * 4 + 3];
        const m10 = matrix[1 * 4 + 0];
        const m11 = matrix[1 * 4 + 1];
        const m12 = matrix[1 * 4 + 2];
        const m13 = matrix[1 * 4 + 3];
        const m20 = matrix[2 * 4 + 0];
        const m21 = matrix[2 * 4 + 1];
        const m22 = matrix[2 * 4 + 2];
        const m23 = matrix[2 * 4 + 3];
        const m30 = matrix[3 * 4 + 0];
        const m31 = matrix[3 * 4 + 1];
        const m32 = matrix[3 * 4 + 2];
        const m33 = matrix[3 * 4 + 3];
        const tmp_0 = m22 * m33;
        const tmp_1 = m32 * m23;
        const tmp_2 = m12 * m33;
        const tmp_3 = m32 * m13;
        const tmp_4 = m12 * m23;
        const tmp_5 = m22 * m13;
        const tmp_6 = m02 * m33;
        const tmp_7 = m32 * m03;
        const tmp_8 = m02 * m23;
        const tmp_9 = m22 * m03;
        const tmp_10 = m02 * m13;
        const tmp_11 = m12 * m03;
        const tmp_12 = m20 * m31;
        const tmp_13 = m30 * m21;
        const tmp_14 = m10 * m31;
        const tmp_15 = m30 * m11;
        const tmp_16 = m10 * m21;
        const tmp_17 = m20 * m11;
        const tmp_18 = m00 * m31;
        const tmp_19 = m30 * m01;
        const tmp_20 = m00 * m21;
        const tmp_21 = m20 * m01;
        const tmp_22 = m00 * m11;
        const tmp_23 = m10 * m01;
        const t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
        const t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
        const t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
        const t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
        const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        result[0] = d * t0;
        result[1] = d * t1;
        result[2] = d * t2;
        result[3] = d * t3;
        result[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
        result[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
        result[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
        result[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
        result[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
        result[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
        result[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
        result[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
        result[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
        result[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
        result[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
        result[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));
        return result;
    }
    /**
   * Inverts a Matrix4x4 which presents an affine transformation.
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invertAffine(matrix, result) {
        result = result || new Matrix4x4();
        const m00 = matrix[0 * 4 + 0];
        const m01 = matrix[0 * 4 + 1];
        const m02 = matrix[0 * 4 + 2];
        const m10 = matrix[1 * 4 + 0];
        const m11 = matrix[1 * 4 + 1];
        const m12 = matrix[1 * 4 + 2];
        const m20 = matrix[2 * 4 + 0];
        const m21 = matrix[2 * 4 + 1];
        const m22 = matrix[2 * 4 + 2];
        const m30 = matrix[3 * 4 + 0];
        const m31 = matrix[3 * 4 + 1];
        const m32 = matrix[3 * 4 + 2];
        const t0 = m22 * m11 - m12 * m21;
        const t1 = m02 * m21 - m22 * m01;
        const t2 = m12 * m01 - m02 * m11;
        const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2);
        result[0] = d * t0;
        result[1] = d * t1;
        result[2] = d * t2;
        result[3] = 0;
        result[4] = d * (m12 * m20 - m22 * m10);
        result[5] = d * (m22 * m00 - m02 * m20);
        result[6] = d * (m02 * m10 - m12 * m00);
        result[7] = 0;
        result[8] = d * (m10 * m21 - m20 * m11);
        result[9] = d * (m20 * m01 - m00 * m21);
        result[10] = d * (m00 * m11 - m10 * m01);
        result[11] = 0;
        result[12] = d * (m10 * m31 * m22 + m20 * m11 * m32 + m30 * m21 * m12 - (m10 * m21 * m32 + m20 * m31 * m12 + m30 * m11 * m22));
        result[13] = d * (m00 * m21 * m32 + m20 * m31 * m02 + m30 * m01 * m22 - (m00 * m31 * m22 + m20 * m01 * m32 + m30 * m21 * m02));
        result[14] = d * (m00 * m31 * m12 + m10 * m01 * m32 + m30 * m11 * m02 - (m00 * m11 * m32 + m10 * m31 * m02 + m30 * m01 * m12));
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a translation.
   * @param t - The translate vector.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translation(t, result) {
        result = result || new Matrix4x4();
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 1;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 1;
        result[11] = 0;
        result[12] = t.x;
        result[13] = t.y;
        result[14] = t.z;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a scaling.
   * @param s - The scale vector.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaling(s, result) {
        result = result || new Matrix4x4();
        result[0] = s.x;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = s.y;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = s.z;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the x axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationX(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = c;
        result[6] = s;
        result[7] = 0;
        result[8] = 0;
        result[9] = -s;
        result[10] = c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the y axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationY(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = 0;
        result[2] = -s;
        result[3] = 0;
        result[4] = 0;
        result[5] = 1;
        result[6] = 0;
        result[7] = 0;
        result[8] = s;
        result[9] = 0;
        result[10] = c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the z axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationZ(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = s;
        result[2] = 0;
        result[3] = 0;
        result[4] = -s;
        result[5] = c;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 1;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around a given axis.
   * @param axis - The axis vector.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotation(axis, angle, result) {
        result = result || new Matrix4x4();
        let x = axis.x;
        let y = axis.y;
        let z = axis.z;
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const oneMinusCosine = 1 - c;
        result[0] = xx + (1 - xx) * c;
        result[1] = x * y * oneMinusCosine + z * s;
        result[2] = x * z * oneMinusCosine - y * s;
        result[3] = 0;
        result[4] = x * y * oneMinusCosine - z * s;
        result[5] = yy + (1 - yy) * c;
        result[6] = y * z * oneMinusCosine + x * s;
        result[7] = 0;
        result[8] = x * z * oneMinusCosine + y * s;
        result[9] = y * z * oneMinusCosine - x * s;
        result[10] = zz + (1 - zz) * c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a look-at matrix.
   * @param eye - Position of the eye.
   * @param target - The point that the eye is looking at.
   * @param up - The up vector.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static lookAt(eye, target, up, result) {
        result = result || new Matrix4x4();
        const zAxis = Vector3.normalize(Vector3.sub(eye, target));
        const xAxis = Vector3.normalize(Vector3.cross(up, zAxis));
        const yAxis = Vector3.normalize(Vector3.cross(zAxis, xAxis));
        result[0] = xAxis.x;
        result[1] = xAxis.y;
        result[2] = xAxis.z;
        result[3] = 0;
        result[4] = yAxis.x;
        result[5] = yAxis.y;
        result[6] = yAxis.z;
        result[7] = 0;
        result[8] = zAxis.x;
        result[9] = zAxis.y;
        result[10] = zAxis.z;
        result[11] = 0;
        result[12] = eye.x;
        result[13] = eye.y;
        result[14] = eye.z;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a matrix, which presents a transform of looking at given cube face.
   * @param face - The cube face to be looked at.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static lookAtCubeFace(face, pos, result) {
        switch(face){
            case CubeFace.PX:
                return this.lookAt(pos, new Vector3(pos.x + 1, pos.y, pos.z), new Vector3(0, -1, 0), result);
            case CubeFace.NX:
                return this.lookAt(pos, new Vector3(pos.x - 1, pos.y, pos.z), new Vector3(0, -1, 0), result);
            case CubeFace.PY:
                return this.lookAt(pos, new Vector3(pos.x, pos.y + 1, pos.z), new Vector3(0, 0, 1), result);
            case CubeFace.NY:
                return this.lookAt(pos, new Vector3(pos.x, pos.y - 1, pos.z), new Vector3(0, 0, -1), result);
            case CubeFace.PZ:
                return this.lookAt(pos, new Vector3(pos.x, pos.y, pos.z + 1), new Vector3(0, -1, 0), result);
            case CubeFace.NZ:
                return this.lookAt(pos, new Vector3(pos.x, pos.y, pos.z - 1), new Vector3(0, -1, 0), result);
            default:
                return null;
        }
    }
    /**
   * Multiplies two Matrix4x4's
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiply(m1, m2, result) {
        result = result || new Matrix4x4();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a03 = m1[3];
        const a10 = m1[4];
        const a11 = m1[5];
        const a12 = m1[6];
        const a13 = m1[7];
        const a20 = m1[8];
        const a21 = m1[9];
        const a22 = m1[10];
        const a23 = m1[11];
        const a30 = m1[12];
        const a31 = m1[13];
        const a32 = m1[14];
        const a33 = m1[15];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b03 = m2[3];
        const b10 = m2[4];
        const b11 = m2[5];
        const b12 = m2[6];
        const b13 = m2[7];
        const b20 = m2[8];
        const b21 = m2[9];
        const b22 = m2[10];
        const b23 = m2[11];
        const b30 = m2[12];
        const b31 = m2[13];
        const b32 = m2[14];
        const b33 = m2[15];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
        result[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
        result[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
        result[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
        result[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
        return result;
    }
    /**
   * Multiplies two Matrix4x4's which present affine transformations.
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiplyAffine(m1, m2, result) {
        result = result || new Matrix4x4();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a10 = m1[4];
        const a11 = m1[5];
        const a12 = m1[6];
        const a20 = m1[8];
        const a21 = m1[9];
        const a22 = m1[10];
        const a30 = m1[12];
        const a31 = m1[13];
        const a32 = m1[14];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b10 = m2[4];
        const b11 = m2[5];
        const b12 = m2[6];
        const b20 = m2[8];
        const b21 = m2[9];
        const b22 = m2[10];
        const b30 = m2[12];
        const b31 = m2[13];
        const b32 = m2[14];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = 0;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = 0;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = 0;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32;
        result[15] = 1;
        return result;
    }
    /**
   * Post-translate a Matrix4x4 by a vector.
   *
   * @remarks
   * result = m * (translate matrix for t)
   *
   * @param m - The matrix that will be translated.
   * @param t - The translate vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translateRight(m, t, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0];
            result[1] = m[1];
            result[2] = m[2];
            result[3] = m[3];
            result[4] = m[4];
            result[5] = m[5];
            result[6] = m[6];
            result[7] = m[7];
            result[8] = m[8];
            result[9] = m[9];
            result[10] = m[10];
            result[11] = m[11];
            result[12] = m[0] * t.x + m[4] * t.y + m[8] * t.z + m[12];
            result[13] = m[1] * t.x + m[5] * t.y + m[9] * t.z + m[13];
            result[14] = m[2] * t.x + m[6] * t.y + m[10] * t.z + m[14];
            result[15] = m[15];
        } else {
            const x = m[0] * t.x + m[4] * t.y + m[8] * t.z + m[12];
            const y = m[1] * t.x + m[5] * t.y + m[9] * t.z + m[13];
            const z = m[2] * t.x + m[6] * t.y + m[10] * t.z + m[14];
            result[12] = x;
            result[13] = y;
            result[14] = z;
        }
        return result;
    }
    /**
   * Pre-translate a Matrix4x4 by a vector.
   *
   * @remarks
   * result = (translate matrix for t) * m
   *
   * @param m - The matrix that will be translated.
   * @param t - The translate vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translateLeft(m, t, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0];
            result[1] = m[1];
            result[2] = m[2];
            result[3] = m[3];
            result[4] = m[4];
            result[5] = m[5];
            result[6] = m[6];
            result[7] = m[7];
            result[8] = m[8];
            result[9] = m[9];
            result[10] = m[10];
            result[11] = m[11];
            result[12] = m[12] + t.x;
            result[13] = m[13] + t.y;
            result[14] = m[14] + t.z;
            result[15] = m[15];
        } else {
            result[12] += t.x;
            result[13] += t.y;
            result[14] += t.z;
        }
        return result;
    }
    /**
   * Post-scale a Matrix4x4 by a vector.
   *
   * @remarks
   * result = m * (scale matrix for s)
   *
   * @param m - The matrix that will be scaled.
   * @param s - The scale vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaleRight(m, s, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0] * s.x;
            result[1] = m[1] * s.x;
            result[2] = m[2] * s.x;
            result[3] = m[3] * s.x;
            result[4] = m[4] * s.y;
            result[5] = m[5] * s.y;
            result[6] = m[6] * s.y;
            result[7] = m[7] * s.y;
            result[8] = m[8] * s.z;
            result[9] = m[9] * s.z;
            result[10] = m[10] * s.z;
            result[11] = m[11] * s.z;
            result[12] = m[12];
            result[13] = m[13];
            result[14] = m[14];
            result[15] = m[15];
        } else {
            result[0] *= s.x;
            result[1] *= s.x;
            result[2] *= s.x;
            result[3] *= s.x;
            result[4] *= s.y;
            result[5] *= s.y;
            result[6] *= s.y;
            result[7] *= s.y;
            result[8] *= s.z;
            result[9] *= s.z;
            result[10] *= s.z;
            result[11] *= s.z;
        }
        return result;
    }
    /**
   * Pre-scale a Matrix4x4 by a vector.
   *
   * @remarks
   * result = (scale matrix for s) * m
   *
   * @param m - The matrix that will be translated.
   * @param s - The scale vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaleLeft(m, s, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0] * s.x;
            result[1] = m[1] * s.y;
            result[2] = m[2] * s.z;
            result[3] = m[3];
            result[4] = m[4] * s.x;
            result[5] = m[5] * s.y;
            result[6] = m[6] * s.z;
            result[7] = m[7];
            result[8] = m[8] * s.x;
            result[9] = m[9] * s.y;
            result[10] = m[10] * s.z;
            result[11] = m[11];
            result[12] = m[12] * s.x;
            result[13] = m[13] * s.y;
            result[14] = m[14] * s.z;
            result[15] = m[15];
        } else {
            result[0] *= s.x;
            result[1] *= s.y;
            result[2] *= s.z;
            result[4] *= s.x;
            result[5] *= s.y;
            result[6] *= s.z;
            result[8] *= s.x;
            result[9] *= s.y;
            result[10] *= s.z;
            result[12] *= s.x;
            result[13] *= s.y;
            result[14] *= s.z;
        }
        return result;
    }
    /**
   * Post-rotate a Matrix4x4 by a rotation matrix or quaternion.
   *
   * @remarks
   * result = m * r
   *
   * @param m - The matrix that will be translated.
   * @param r - The rotate matrix or quaternion.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotateRight(m, r, result) {
        result = result || new Matrix4x4();
        const b = r instanceof Quaternion ? new Matrix3x3(r) : r;
        const a00 = m[0];
        const a01 = m[1];
        const a02 = m[2];
        const a03 = m[3];
        const a10 = m[4];
        const a11 = m[5];
        const a12 = m[6];
        const a13 = m[7];
        const a20 = m[8];
        const a21 = m[9];
        const a22 = m[10];
        const a23 = m[11];
        const a30 = m[12];
        const a31 = m[13];
        const a32 = m[14];
        const a33 = m[15];
        const b00 = b.m00;
        const b01 = b.m10;
        const b02 = b.m20;
        const b10 = b.m01;
        const b11 = b.m11;
        const b12 = b.m21;
        const b20 = b.m02;
        const b21 = b.m12;
        const b22 = b.m22;
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = a03 * b00 + a13 * b01 + a23 * b02;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = a03 * b10 + a13 * b11 + a23 * b12;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = a03 * b20 + a13 * b21 + a23 * b22;
        result[12] = a30;
        result[13] = a31;
        result[14] = a32;
        result[15] = a33;
        return result;
    }
    /**
   * Pre-rotate a Matrix4x4 by a rotation matrix or quaternion.
   *
   * @remarks
   * result = r * m
   *
   * @param m - The matrix that will be translated.
   * @param r - The rotate matrix or quaternion.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotateLeft(m, r, result) {
        result = result || new Matrix4x4();
        const a = r instanceof Quaternion ? new Matrix3x3(r) : r;
        const a00 = a.m00;
        const a01 = a.m10;
        const a02 = a.m20;
        const a10 = a.m01;
        const a11 = a.m11;
        const a12 = a.m21;
        const a20 = a.m02;
        const a21 = a.m12;
        const a22 = a.m22;
        const b00 = m[0];
        const b01 = m[1];
        const b02 = m[2];
        const b03 = m[3];
        const b10 = m[4];
        const b11 = m[5];
        const b12 = m[6];
        const b13 = m[7];
        const b20 = m[8];
        const b21 = m[9];
        const b22 = m[10];
        const b23 = m[11];
        const b30 = m[12];
        const b31 = m[13];
        const b32 = m[14];
        const b33 = m[15];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = b03;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = b13;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = b23;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32;
        result[15] = b33;
        return result;
    }
    /**
   * Subtract a matrix from this matrix component-wise.
   * @param other - The matrix that will be subtract.
   * @returns self
   */ subBy(other) {
        return Matrix4x4.sub(this, other, this);
    }
    /**
   * Add a matrix to this matrix component-wise.
   * @param other - The matrix that will be added.
   * @returns self
   */ addBy(other) {
        return Matrix4x4.add(this, other, this);
    }
    /**
   * Multiplies this matrix by a matrix component-wise.
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Matrix4x4.mul(this, other, this);
    }
    /**
   * Divide this matrix by a matrix component-wise.
   * @param other - The matrix that will be divide by.
   * @returns self
   */ divBy(other) {
        return Matrix4x4.div(this, other, this);
    }
    /**
   * Scale this matrix by a scalar number component-wise.
   * @param f - amount to scale this matrix by.
   * @returns self
   */ scaleBy(f) {
        return Matrix4x4.scale(this, f, this);
    }
    /**
   * Make this matrix identity.
   * @returns self
   */ identity() {
        return Matrix4x4.identity(this);
    }
    /**
   * Calculates a right-handed perspective projection matrix inplace.
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio.
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @returns self
   */ perspective(fovY, aspect, znear, zfar) {
        return Matrix4x4.perspective(fovY, aspect, znear, zfar, this);
    }
    /**
   * Calculates a perspective projection matrix from a frustum inplace.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param znear - Near bound of the frustum.
   * @param zfar - Far bound of the frustum.
   * @returns self
   */ frustum(left, right, bottom, top, znear, zfar) {
        return Matrix4x4.frustum(left, right, bottom, top, znear, zfar, this);
    }
    /**
   * Calculates an orthogonal projection matrix inplace.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @returns self
   */ ortho(left, right, bottom, top, near, far) {
        return Matrix4x4.ortho(left, right, bottom, top, near, far, this);
    }
    /**
   * Check if this matrix is orthogonal projection matrix.
   *
   * @remarks
   * This method assumes that this is an affine transform matrix or a projection matrix (perspective or orthogonal).
   *
   * @returns true if this is an orthogonal projection matrix, otherwise false
   */ isOrtho() {
        // assum this is a projection matrix
        return this[15] === 1;
    }
    /**
   * Check if this matrix is perspective projection matrix.
   *
   * @remarks
   * This method assumes that this is an affine transform matrix or a projection matrix (perspective or orthogonal).
   *
   * @returns true if this is a perspective projection matrix, otherwise false
   */ isPerspective() {
        // assum this is a projection matrix
        return this[15] === 0;
    }
    /**
   * Get width of the near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Width of the near clip plane
   */ getNearPlaneWidth() {
        if (this.isPerspective()) {
            return 2 * this.getNearPlane() / this[0];
        } else {
            return 2 / this[0];
        }
    }
    /**
   * Get height of the near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Height of the near clip plane
   */ getNearPlaneHeight() {
        if (this.isPerspective()) {
            return 2 * this.getNearPlane() / this[5];
        } else {
            return 2 / this[5];
        }
    }
    /**
   * Get near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns The near clip plane
   */ getNearPlane() {
        if (this.isPerspective()) {
            return this[14] / (this[10] - 1);
        } else {
            return (this[14] + 1) / this[10];
        }
    }
    /**
   * Get width of the far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Width of the far clip plane
   */ getFarPlaneWidth() {
        if (this.isPerspective()) {
            return this.getNearPlaneWidth() * this.getFarPlane() / this.getNearPlane();
        } else {
            return this.getNearPlaneWidth();
        }
    }
    /**
   * Get height of the far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Height of the far clip plane
   */ getFarPlaneHeight() {
        if (this.isPerspective()) {
            return this.getNearPlaneHeight() * this.getFarPlane() / this.getNearPlane();
        } else {
            return this.getNearPlaneHeight();
        }
    }
    /**
   * Get far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns The far clip plane
   */ getFarPlane() {
        if (this.isPerspective()) {
            return this[14] / (this[10] + 1);
        } else {
            return (this[14] - 1) / this[10];
        }
    }
    /**
   * Get the vertical field of view in radians.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns 0 if this is an orthogonal projection matrix, otherwise the vertical field of view
   */ getFov() {
        // assum this is a projection matrix
        return this.isOrtho() ? 0 : Math.atan(1 / this[5]) * 2;
    }
    /**
   * Get tangent value of half of the vertical field of view.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   * If the matrix is orthogonal, 0 is returned.
   *
   * @returns 0 if this is an orthogonal projection matrix, otherwise the tangent value of half of the vertical field of view
   */ getTanHalfFov() {
        // assum this is a projection matrix
        return this.isOrtho() ? 0 : 1 / this[5];
    }
    /**
   * Get the aspect ratio.
   *
   * @remarks
   * This method assumes that the matrix is a perspective projection matrix.
   *
   * @returns The aspect ratio
   */ getAspect() {
        // assum this is a projection matrix
        return this[5] / this[0];
    }
    /**
   * Get the left clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The left clip plane
   */ getLeftPlane() {
        // assum this is an orthogonal projection matrix
        return (-1 - this[12]) / this[0];
    }
    /**
   * Get the right clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The right clip plane
   */ getRightPlane() {
        // assum this is an orthogonal projection matrix
        return (1 - this[12]) / this[0];
    }
    /**
   * Get the top clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The top clip plane
   */ getTopPlane() {
        // assum this is an orthogonal projection matrix
        return (1 - this[13]) / this[5];
    }
    /**
   * Get the bottom clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The bottom clip plane
   */ getBottomPlane() {
        // assum this is an orthogonal projection matrix
        return (-1 - this[13]) / this[5];
    }
    /**
   * Set the near clip plane and far clip plane.
   *
   * @remarks
   * This method assumes that the matrix is a projection matrix (perspective or orthogonal).
   *
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @returns self
   */ setNearFar(znear, zfar) {
        if (this.isPerspective()) {
            this.perspective(this.getFov(), this.getAspect(), znear, zfar);
        } else {
            this[10] = 2 / (znear - zfar);
            this[14] = (znear + zfar) / (znear - zfar);
        }
        return this;
    }
    /**
   * Calculate a translation matrix inplace.
   * @param t - The translate vector.
   * @returns self
   */ translation(t) {
        return Matrix4x4.translation(t, this);
    }
    /**
   * Calculates a scale matrix inplace.
   * @param s - The scale vector.
   * @returns self
   */ scaling(s) {
        return Matrix4x4.scaling(s, this);
    }
    /**
   * Invert this matrix inplace.
   * @returns self
   */ inplaceInvert() {
        return Matrix4x4.invert(this, this);
    }
    /**
   * Invert this matrix inplace, assuming this matrix presents an affine transformation.
   * @returns self
   */ inplaceInvertAffine() {
        return Matrix4x4.invertAffine(this, this);
    }
    /**
   * Calculates the transpose of this matrix inplace.
   * @returns self
   */ transpose() {
        return Matrix4x4.transpose(this, this);
    }
    /**
   * Post-multiply by a matrix inplace.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Matrix4x4.multiply(this, other, this);
    }
    /**
   * Post-multiply by a matrix inplace, assuming both matrices present affine transformations.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRightAffine(other) {
        return Matrix4x4.multiplyAffine(this, other, this);
    }
    /**
   * Pre-multiply by a matrix inplace.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Matrix4x4.multiply(other, this, this);
    }
    /**
   * Pre-multiply by a matrix inplace, assuming both matrices present affine transformations.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeftAffine(other) {
        return Matrix4x4.multiplyAffine(other, this, this);
    }
    /**
   * Calculates a rotation around x axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationX(angle) {
        return Matrix4x4.rotationX(angle, this);
    }
    /**
   * Calculates a rotation around y axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationY(angle) {
        return Matrix4x4.rotationY(angle, this);
    }
    /**
   * Calculates a rotation around z axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationZ(angle) {
        return Matrix4x4.rotationZ(angle, this);
    }
    /**
   * Calculates a rotation around a given axis inplace.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotation(axis, angle) {
        return Matrix4x4.rotation(axis, angle, this);
    }
    /**
   * Post-translate by a vector inplace.
   *
   * @remarks
   * this = this * (translate matrix for t)
   *
   * @param t - The translate vector.
   * @returns self
   */ translateRight(t) {
        return Matrix4x4.translateRight(this, t, this);
    }
    /**
   * Pre-translate by a vector inplace.
   *
   * @remarks
   * this = (translate matrix for t) * this
   *
   * @param t - The translate vector.
   * @returns self
   */ translateLeft(t) {
        return Matrix4x4.translateLeft(this, t, this);
    }
    /**
   * Post-scale by a vector inplace.
   *
   * @remarks
   * this = this * (scale matrix for s)
   *
   * @param s - The scale vector.
   * @returns self
   */ scaleRight(s) {
        return Matrix4x4.scaleRight(this, s, this);
    }
    /**
   * Pre-scale by a vector inplace.
   *
   * @remarks
   * this = (scale matrix for s) * this
   *
   * @param s - The scale vector.
   * @returns self
   */ scaleLeft(s) {
        return Matrix4x4.scaleLeft(this, s, this);
    }
    /**
   * Post-rotate by a rotation matrix or quaternion inplace.
   *
   * @remarks
   * this = this * r
   *
   * @param r - The rotation matrix or quaternion.
   * @returns self
   */ rotateRight(r) {
        return Matrix4x4.rotateRight(this, r, this);
    }
    /**
   * Pre-rotate by a rotation matrix or quaternion inplace.
   *
   * @remarks
   * this = r * this
   *
   * @param r - The rotation matrix or quaternion.
   * @returns self
   */ rotateLeft(r) {
        return Matrix4x4.rotateLeft(this, r, this);
    }
    /**
   * Calculates a look-at matrix inplace.
   * @param eye - Position of the eye.
   * @param target - The point that the eye is looking at.
   * @param up - The up vector.
   * @returns self
   */ lookAt(eye, target, up) {
        return Matrix4x4.lookAt(eye, target, up, this);
    }
    /**
   * Transform a point by this matrix.
   * @param point - The point to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPoint(point, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12], this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13], this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14], this[3] * point[0] + this[7] * point[1] + this[11] * point[2] + this[15]);
    }
    /**
   * Transform a point by this matrix and then do a perspective divide.
   * @param point - The point to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPointP(point, result) {
        result = result || new Vector3();
        const x = this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12];
        const y = this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13];
        const z = this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14];
        const w = this[3] * point[0] + this[7] * point[1] + this[11] * point[2] + this[15];
        return result.setXYZ(x / w, y / w, z / w);
    }
    /**
   * Transform a point by this matrix, assuming this matrix presents an affine transformation.
   * @param point - The point to be transformed.
   * @param result - The output vector (can be the same as point), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPointAffine(point, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12], this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13], this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14]);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformVector(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2], this[3] * vec[0] + this[7] * vec[1] + this[11] * vec[2]);
    }
    /**
   * Transform a vector by this matrix assuming this matrix presents an affine transformation.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformVectorAffine(vec, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2]);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transform(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2] + this[12] * vec[3], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2] + this[13] * vec[3], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2] + this[14] * vec[3], this[3] * vec[0] + this[7] * vec[1] + this[11] * vec[2] + this[15] * vec[3]);
    }
    /**
   * Transform a vector by this matrix, assuming this matrix presents an affine transformation.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformAffine(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2] + this[12] * vec[3], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2] + this[13] * vec[3], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2] + this[14] * vec[3], vec.w);
    }
    /**
   * Calculates the determinant of this matrix.
   * @returns The determinant
   */ det() {
        const m00 = this[0], m01 = this[1], m02 = this[2], m03 = this[3];
        const m10 = this[4], m11 = this[5], m12 = this[6], m13 = this[7];
        const m20 = this[8], m21 = this[9], m22 = this[10], m23 = this[11];
        const m30 = this[12], m31 = this[13], m32 = this[14], m33 = this[15];
        const det_22_33 = m22 * m33 - m32 * m23;
        const det_21_33 = m21 * m33 - m31 * m23;
        const det_21_32 = m21 * m32 - m31 * m22;
        const det_20_33 = m20 * m33 - m30 * m23;
        const det_20_32 = m20 * m32 - m22 * m30;
        const det_20_31 = m20 * m31 - m30 * m21;
        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    }
    /**
   * Decompose this matrix into its rotation, translation and scale components.
   * @param scale - The output scale vector.
   * @param rotation - The output rotation matrix or quaternion.
   * @param translation - The output translation vector.
   * @returns self
   */ decompose(scale, rotation, translation) {
        if (translation) {
            translation.setXYZ(this[12], this[13], this[14]);
        }
        const sign = this.det() <= 0 ? -1 : 1;
        const sx = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        const sy = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]) * sign;
        const sz = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        if (scale) {
            scale.setXYZ(sx, sy, sz);
        }
        if (rotation instanceof Quaternion) {
            const rotationMatrix = new Matrix3x3(this);
            rotationMatrix[0] /= sx;
            rotationMatrix[1] /= sx;
            rotationMatrix[2] /= sx;
            rotationMatrix[3] /= sy;
            rotationMatrix[4] /= sy;
            rotationMatrix[5] /= sy;
            rotationMatrix[6] /= sz;
            rotationMatrix[7] /= sz;
            rotationMatrix[8] /= sz;
            rotation.fromRotationMatrix(rotationMatrix);
        } else if (rotation instanceof Matrix3x3) {
            rotation[0] = this[0] / sx;
            rotation[1] = this[1] / sx;
            rotation[2] = this[2] / sx;
            rotation[3] = this[4] / sy;
            rotation[4] = this[5] / sy;
            rotation[5] = this[6] / sy;
            rotation[6] = this[8] / sz;
            rotation[7] = this[9] / sz;
            rotation[8] = this[10] / sz;
        } else if (rotation instanceof Matrix4x4) {
            rotation[0] = this[0] / sx;
            rotation[1] = this[1] / sx;
            rotation[2] = this[2] / sx;
            rotation[3] = 0;
            rotation[4] = this[4] / sy;
            rotation[5] = this[5] / sy;
            rotation[6] = this[6] / sy;
            rotation[7] = 0;
            rotation[8] = this[8] / sz;
            rotation[9] = this[9] / sz;
            rotation[10] = this[10] / sz;
            rotation[11] = 0;
            rotation[12] = 0;
            rotation[13] = 0;
            rotation[14] = 0;
            rotation[15] = 1;
        }
        return this;
    }
    /**
   * Decompose this matrix into a look-at form.
   * @param eye - The output eye vector.
   * @param target - The output target vector.
   * @param up - The output up vector.
   * @returns self
   */ decomposeLookAt(eye, target, up) {
        eye && eye.setXYZ(this[12], this[13], this[14]);
        up && up.setXYZ(this[4], this[5], this[6]);
        target && target.setXYZ(this[12] - this[8], this[13] - this[9], this[14] - this[10]);
        return this;
    }
    /** @internal */ toDualQuaternion() {
        const t = new Vector3();
        const r = new Quaternion();
        const s = new Vector3();
        this.decompose(s, r, t);
        const translation = new Quaternion(this.m03 * 0.5, this.m13 * 0.5, this.m23 * 0.5, 0);
        const dual = Quaternion.multiply(translation, r);
        return {
            real: r,
            dual: dual,
            scale: s
        };
    }
}

/**
 * The plane class
 * @public
 */ class Plane extends VectorBase {
    /** @internal */ _px;
    /** @internal */ _py;
    /** @internal */ _pz;
    /** @internal */ _nx;
    /** @internal */ _ny;
    /** @internal */ _nz;
    /** @internal */ _npDirty;
    constructor(arg0, arg1, arg2, arg3){
        super(4);
        switch(arguments.length){
            case 0:
                {
                    this[0] = 0;
                    this[1] = 1;
                    this[2] = 0;
                    this[3] = 0;
                    this._npDirty = true;
                    break;
                }
            case 1:
                {
                    this.set(arg0);
                    break;
                }
            case 2:
                {
                    this.initWithOriginNormal(arg0, arg1);
                    break;
                }
            case 3:
                {
                    this.initWithPoints(arg0, arg1, arg2);
                    break;
                }
            case 4:
                {
                    this.setEquation(arg0, arg1, arg2, arg3);
                    break;
                }
            default:
                {
                    console.log('ERROR: Plane constructor must have 0/2/3/4 arguments');
                }
        }
    }
    /** Get the coefficient A of the plane equation */ get a() {
        return this[0];
    }
    set a(val) {
        this[0] = val;
        this._npDirty = true;
    }
    /** Get the coefficient B of the plane equation */ get b() {
        return this[1];
    }
    set b(val) {
        this[1] = val;
        this._npDirty = true;
    }
    /** Get the coefficient C of the plane equation */ get c() {
        return this[2];
    }
    set c(val) {
        this[2] = val;
        this._npDirty = true;
    }
    /** Get the coefficient D of the plane equation */ get d() {
        return this[3];
    }
    set d(val) {
        this[3] = val;
        this._npDirty = true;
    }
    /** @internal */ get px() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._px;
    }
    /** @internal */ get py() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._py;
    }
    /** @internal */ get pz() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._pz;
    }
    /** @internal */ get nx() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._nx;
    }
    /** @internal */ get ny() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._ny;
    }
    /** @internal */ get nz() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._nz;
    }
    /**
   * Set coefficients of the plane equation.
   * @param other - An array holding the coefficients.
   * @returns self
   */ assign(other) {
        this._npDirty = true;
        super.set(other);
        return this;
    }
    /**
   * Set coefficients of the plane equation.
   * @param a - The coefficient A of the equation
   * @param b - The coefficient B of the equation
   * @param c - The coefficient C of the equation
   * @param d - The coefficient D of the equation
   * @returns self
   */ setEquation(a, b, c, d) {
        this[0] = a;
        this[1] = b;
        this[2] = c;
        this[3] = d;
        this._npDirty = true;
        return this;
    }
    /**
   * Initialize the plane by normal vector and a point on the plane.
   * @param origin - A point on the plane.
   * @param normal - Normal of the plane.
   * @returns self
   */ initWithOriginNormal(origin, normal) {
        // assume normal is normalized
        return this.setEquation(normal.x, normal.y, normal.z, -Vector3.dot(origin, normal));
    }
    /**
   * Initialize the plane by three points on the plane.
   * @param p0 - The first point.
   * @param p1 - The second point.
   * @param p2 - The third point.
   * @returns self
   */ initWithPoints(p0, p1, p2) {
        const normal = Vector3.cross(Vector3.sub(p1, p0), Vector3.sub(p2, p0)).inplaceNormalize();
        return this.initWithOriginNormal(p0, normal);
    }
    /**
   * Calculate the distance from a point to the plane.
   * @param p - The point
   * @returns The distance value.
   */ distanceToPoint(p) {
        return p.x * this[0] + p.y * this[1] + p.z * this[2] + this[3];
    }
    /**
   * Given a point, calucate the closest point on the plane to that point.
   * @param p - The given point.
   * @param result - A point object to which the result will be written, if not specified, a new point object will be returned.
   * @returns The result value.
   */ nearestPointToPoint(p, result) {
        const d = this.distanceToPoint(p);
        return (result || new Vector3()).setXYZ(p.x - this[0] * d, p.y - this[1] * d, p.z - this[2] * d);
    }
    /**
   * Get normal vector of the plane.
   * @param result - A vector object to which the result will be written, if not specified, a new vector will be returned.
   * @returns The result vector.
   */ getNormal(result) {
        return (result || new Vector3()).setXYZ(this[0], this[1], this[2]);
    }
    /** Inplace flip the normal vector . */ inplaceFlip() {
        return Plane.flip(this, this);
    }
    /** Inplace normalize the plane equation. */ inplaceNormalize() {
        return Plane.normalize(this, this);
    }
    /**
   * Create a new plane object by flipping another plane's normal.
   * @param plane - The plane to which the normal will be flipped.
   * @param result - A plane object to which the result will be written, if not specified, a new plane object will be returned.
   * @returns The result plane.
   */ static flip(plane, result) {
        return (result || new Plane()).setEquation(-plane[0], -plane[1], -plane[2], -plane[3]);
    }
    /**
   * Create a new plane object by normalizing another plane.
   * @param plane - The plane that will be normalized.
   * @param result - A plane object to which the result will be written, if not specified, a new plane object will be returned.
   * @returns The result plane.
   */ static normalize(plane, result) {
        const len = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
        return (result || new Plane()).setEquation(plane[0] / len, plane[1] / len, plane[2] / len, plane[3] / len);
    }
    /**
   * Create a new plane object by transforming another plane.
   * @param plane - The plane that will be transformed.
   * @param matrix - The transform matrix.
   * @param result - A plane object to which the result will be written, if not specified, a new plane object will be returned.
   * @returns The result plane.
   */ static transform(plane, matrix, result) {
        const adjMatrix = Matrix4x4.transpose(Matrix4x4.invertAffine(matrix));
        const p = adjMatrix.transform(new Vector4(plane[0], plane[1], plane[2], plane[3]));
        const ret = result || plane;
        ret.setEquation(p.x, p.y, p.z, p.w);
        return ret.inplaceNormalize();
    }
    /** @internal */ _calcNP() {
        this._px = this[0] > 0 ? 1 : -1;
        this._py = this[1] > 0 ? 1 : -1;
        this._pz = this[2] > 0 ? 1 : -1;
        this._nx = -this._px;
        this._ny = -this._py;
        this._nz = -this._pz;
    }
}

const npn = [
    -1,
    1,
    -1
];
const npp = [
    -1,
    1,
    1
];
const ppp = [
    1,
    1,
    1
];
const ppn = [
    1,
    1,
    -1
];
const nnn = [
    -1,
    -1,
    -1
];
const nnp = [
    -1,
    -1,
    1
];
const pnp = [
    1,
    -1,
    1
];
const pnn = [
    1,
    -1,
    -1
];
class BoundingBoxData {
    static ndcVertices = [
        npn,
        npp,
        ppp,
        ppn,
        nnn,
        nnp,
        pnp,
        pnn
    ];
    static generateVertexData(v) {
        return [
            ...v[0],
            ...v[1],
            ...v[2],
            ...v[3],
            ...v[1],
            ...v[5],
            ...v[6],
            ...v[2],
            ...v[2],
            ...v[6],
            ...v[7],
            ...v[3],
            ...v[3],
            ...v[7],
            ...v[4],
            ...v[0],
            ...v[0],
            ...v[4],
            ...v[5],
            ...v[1],
            ...v[5],
            ...v[4],
            ...v[7],
            ...v[6]
        ];
    }
    static ndcBoxVertices = new Float32Array([
        ...npn,
        ...npp,
        ...ppp,
        ...ppn,
        ...npp,
        ...nnp,
        ...pnp,
        ...ppp,
        ...ppp,
        ...pnp,
        ...pnn,
        ...ppn,
        ...ppn,
        ...pnn,
        ...nnn,
        ...npn,
        ...npn,
        ...nnn,
        ...nnp,
        ...npp,
        ...nnp,
        ...nnn,
        ...pnn,
        ...pnp
    ]);
    static boxBarycentric = new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        0
    ]);
    static boxIndices = new Uint16Array([
        0,
        1,
        2,
        0,
        2,
        3,
        4,
        5,
        6,
        4,
        6,
        7,
        8,
        9,
        10,
        8,
        10,
        11,
        12,
        13,
        14,
        12,
        14,
        15,
        16,
        17,
        18,
        16,
        18,
        19,
        20,
        21,
        22,
        20,
        22,
        23
    ]);
}
/**
 * The frustum class
 *
 * @public
 */ class Frustum {
    static CORNER_LEFT_TOP_NEAR = 0;
    static CORNER_LEFT_TOP_FAR = 1;
    static CORNER_RIGHT_TOP_FAR = 2;
    static CORNER_RIGHT_TOP_NEAR = 3;
    static CORNER_LEFT_BOTTOM_NEAR = 4;
    static CORNER_LEFT_BOTTOM_FAR = 5;
    static CORNER_RIGHT_BOTTOM_FAR = 6;
    static CORNER_RIGHT_BOTTOM_NEAR = 7;
    /** @internal */ _planes;
    /** @internal */ _corners;
    constructor(arg0){
        this._planes = null;
        this._corners = null;
        if (arg0 instanceof Frustum) {
            this._planes = arg0._planes.map((plane)=>new Plane(plane));
            this._corners = arg0._corners.map((vec)=>new Vector3(vec));
        } else {
            this.initWithMatrix(arg0);
        }
    }
    /**
   * Get the frustum planes.
   */ get planes() {
        return this._planes;
    }
    /**
   * Get the corner points.
   */ get corners() {
        return this._corners;
    }
    /**
   * Get the point of a given corner.
   *
   * @remarks
   * The possible values of argument 'pos' are:
   * <ul>
   * <li>{@link Frustum.CORNER_LEFT_TOP_NEAR}</li>
   * <li>{@link Frustum.CORNER_LEFT_TOP_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_NEAR}</li>
   * <li>{@link Frustum.CORNER_LEFT_BOTTOM_NEAR}</li>
   * <li>{@link Frustum.CORNER_LEFT_BOTTOM_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_NEAR}</li>
   * </ul>
   *
   * @param pos - The corner index.
   *
   * @returns The point of given corner
   */ getCorner(pos) {
        return this.corners[pos];
    }
    /**
   * Tests if a point is inside the frustum.
   *
   * @param pt - The point to test.
   * @returns true if the point is inside the frustum, otherwise false
   */ containsPoint(pt) {
        for (const p of this.planes){
            if (p.distanceToPoint(pt) < 0) {
                return false;
            }
        }
        return true;
    }
    /**
   * Initialize the frustum by given model-view matrix
   * @param transform - Model-view matrix used to initialize the frustum
   * @returns self
   */ initWithMatrix(transform) {
        this._planes = this._planes || Array.from({
            length: 6
        }).map(()=>new Plane());
        this._planes[BoxSide.LEFT].setEquation(transform.m30 + transform.m00, transform.m31 + transform.m01, transform.m32 + transform.m02, transform.m33 + transform.m03).inplaceNormalize();
        this._planes[BoxSide.RIGHT].setEquation(transform.m30 - transform.m00, transform.m31 - transform.m01, transform.m32 - transform.m02, transform.m33 - transform.m03).inplaceNormalize();
        this._planes[BoxSide.BOTTOM].setEquation(transform.m30 + transform.m10, transform.m31 + transform.m11, transform.m32 + transform.m12, transform.m33 + transform.m13).inplaceNormalize();
        this._planes[BoxSide.TOP].setEquation(transform.m30 - transform.m10, transform.m31 - transform.m11, transform.m32 - transform.m12, transform.m33 - transform.m13).inplaceNormalize();
        this._planes[BoxSide.FRONT].setEquation(transform.m30 + transform.m20, transform.m31 + transform.m21, transform.m32 + transform.m22, transform.m33 + transform.m23).inplaceNormalize();
        this._planes[BoxSide.BACK].setEquation(transform.m30 - transform.m20, transform.m31 - transform.m21, transform.m32 - transform.m22, transform.m33 - transform.m23).inplaceNormalize();
        const invMatrix = Matrix4x4.invert(transform);
        const ndcVertices = BoundingBoxData.ndcVertices.map((v)=>new Vector3(v[0], v[1], v[2]));
        this._corners = this._corners || [];
        for(let i = 0; i < 8; i++){
            const v = invMatrix.transformPoint(ndcVertices[i]);
            this._corners[i] = v.scaleBy(1 / v.w).xyz();
        }
        return this;
    }
}

/**
 * Axis aligned bounding box
 * @public
 */ class AABB {
    /** Clip to the left side */ static ClipLeft = 1 << BoxSide.LEFT;
    /** Clip to the right side */ static ClipRight = 1 << BoxSide.RIGHT;
    /** Clip to the bottom side */ static ClipBottom = 1 << BoxSide.BOTTOM;
    /** Clip to the top side */ static ClipTop = 1 << BoxSide.TOP;
    /** Clip to the front side */ static ClipFront = 1 << BoxSide.FRONT;
    /** Clip to the back side */ static ClipBack = 1 << BoxSide.BACK;
    /** @internal */ _minPoint;
    /** @internal */ _maxPoint;
    constructor(arg0, arg1){
        if (arg0 instanceof AABB) {
            this._minPoint = new Vector3(arg0.minPoint);
            this._maxPoint = new Vector3(arg0.maxPoint);
        } else if (arg0 instanceof Vector3) {
            this._minPoint = new Vector3(arg0);
            this._maxPoint = new Vector3(arg1);
        } else {
            this._minPoint = new Vector3(0, 0, 0);
            this._maxPoint = new Vector3(0, 0, 0);
        }
    }
    /** Get the min point of the AABB. */ get minPoint() {
        return this._minPoint;
    }
    set minPoint(p) {
        this._minPoint.set(p);
    }
    /** Get the max point of the AABB. */ get maxPoint() {
        return this._maxPoint;
    }
    set maxPoint(p) {
        this._maxPoint.set(p);
    }
    /** Get half size of the AABB. */ get extents() {
        return Vector3.sub(this._maxPoint, this._minPoint).scaleBy(0.5);
    }
    /** Get center point of the AABB. */ get center() {
        return Vector3.add(this._maxPoint, this._minPoint).scaleBy(0.5);
    }
    /** Get size of the AABB. */ get size() {
        return Vector3.sub(this._maxPoint, this._minPoint);
    }
    /** Get the diagonal length of the AABB. */ get diagonalLength() {
        return Vector3.sub(this._maxPoint, this._minPoint).magnitude;
    }
    /**
   * Calculate the coordinates of the eight corners of the AABB.
   * @returns the coordinates of the eight corners of the AABB.
   */ computePoints() {
        const { x: minx, y: miny, z: minz } = this._minPoint;
        const { x: maxx, y: maxy, z: maxz } = this._maxPoint;
        return [
            new Vector3(minx, miny, minz),
            new Vector3(minx, maxy, minz),
            new Vector3(maxx, miny, minz),
            new Vector3(maxx, maxy, minz),
            new Vector3(minx, miny, maxz),
            new Vector3(minx, maxy, maxz),
            new Vector3(maxx, miny, maxz),
            new Vector3(maxx, maxy, maxz)
        ];
    }
    /**
   * Inplace transform the AABB.
   * @param matrix - The transform matrix.
   * @returns self
   */ inplaceTransform(matrix) {
        return AABB.transform(this, matrix, this);
    }
    /** Invalidate the min/max point so that we can start extending the AABB. */ beginExtend() {
        this._minPoint.setXYZ(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        this._maxPoint.setXYZ(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    }
    /**
   * Extend the AABB so that it can contain specified point.
   * @param v - The point used to extend the AABB.
   */ extend(v) {
        this._minPoint.inplaceMin(v);
        this._maxPoint.inplaceMax(v);
    }
    /**
   * Extend the AABB so that it can contain specified point.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   */ extend3(x, y, z) {
        if (x < this._minPoint.x) this._minPoint.x = x;
        if (x > this._maxPoint.x) this._maxPoint.x = x;
        if (y < this._minPoint.y) this._minPoint.y = y;
        if (y > this._maxPoint.y) this._maxPoint.y = y;
        if (z < this._minPoint.z) this._minPoint.z = z;
        if (z > this._maxPoint.z) this._maxPoint.z = z;
    }
    /**
   * Merge the AABB with another AABB.
   * @param other - The AABB to be merged with.
   * @returns self
   */ union(other) {
        if (other && other.isValid()) {
            this.extend(other._minPoint);
            this.extend(other._maxPoint);
        }
        return this;
    }
    /**
   * Check if the AABB is valid.
   * @returns true if the AABB is valid, otherwise false.
   */ isValid() {
        return this._minPoint.x <= this._maxPoint.x && this._minPoint.y <= this._maxPoint.y && this._minPoint.z <= this._maxPoint.z;
    }
    /**
   * Check if the AABB is close enough to another AABB.
   * @param other - The AABB to be compared with.
   * @param epsl - The epsilon for comparison.
   * @returns true if the comparison error is less than epsl, otherwise false.
   */ equalsTo(other, epsl) {
        return this._minPoint.equalsTo(other._minPoint, epsl) && this._maxPoint.equalsTo(other._maxPoint, epsl);
    }
    /**
   * Check if the AABB intersects with another AABB.
   * @param other - The destination AABB.
   * @returns true if the AABB intersects with other, otherwise false.
   */ intersectedWithBox(other) {
        return !(this._maxPoint.x <= other._minPoint.x || this._minPoint.x >= other._maxPoint.x || this._maxPoint.y <= other._minPoint.y || this._minPoint.y >= other._maxPoint.y || this._maxPoint.z <= other._minPoint.z || this._minPoint.z >= other._maxPoint.z);
    }
    /**
   * Check if the box contains specified point.
   * @param pt - The point to be checked.
   * @returns true if the box contains the point, otherwise false.s
   */ containsPoint(pt) {
        return this._minPoint.x <= pt.x && this._maxPoint.x >= pt.x && this._minPoint.y <= pt.y && this._maxPoint.y >= pt.y && this._minPoint.z <= pt.z && this._maxPoint.z >= pt.z;
    }
    /**
   * Check if the AABB contains all of the eight corner point of another AABB
   * @param other - The AABB to be checked.
   * @returns true if all contains, otherwise false.
   */ containsBox(other) {
        return this._minPoint.x <= other._minPoint.x && this._maxPoint.x >= other._maxPoint.x && this._minPoint.y <= other._minPoint.y && this._maxPoint.y >= other._maxPoint.y && this._minPoint.z <= other._minPoint.z && this._maxPoint.z >= other._maxPoint.z;
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param viewProjMatrix - The view projection matrix of the frustum.
   * @param mask - The frustum planes that needs to be tested.
   * @returns The clip test result.
   */ getClipStateMask(viewProjMatrix, mask) {
        let andFlags = 0xffff;
        let orFlags = 0;
        const v0 = new Vector3();
        const v1 = new Vector4();
        const clipLeft = mask & AABB.ClipLeft;
        const clipRight = mask & AABB.ClipRight;
        const clipTop = mask & AABB.ClipTop;
        const clipBottom = mask & AABB.ClipBottom;
        const clipNear = mask & AABB.ClipFront;
        const clipFar = mask & AABB.ClipBack;
        const minPoint = this._minPoint;
        const maxPoint = this._maxPoint;
        for(let i = 0; i < 8; i++){
            let clip = 0;
            v0.setXYZ(i & 1 ? minPoint.x : maxPoint.x, i & 2 ? minPoint.y : maxPoint.y, i & 3 ? minPoint.z : maxPoint.z);
            viewProjMatrix.transformPoint(v0, v1);
            if (clipLeft && v1.x < -v1.w) {
                clip |= AABB.ClipLeft;
            } else if (clipRight && v1.x > v1.w) {
                clip |= AABB.ClipRight;
            }
            if (clipBottom && v1.y < -v1.w) {
                clip |= AABB.ClipBottom;
            } else if (clipTop && v1.y > v1.w) {
                clip |= AABB.ClipTop;
            }
            if (clipFar && v1.z < -v1.w) {
                clip |= AABB.ClipBack;
            } else if (clipNear && v1.z > v1.w) {
                clip |= AABB.ClipFront;
            }
            andFlags &= clip;
            orFlags |= clip;
        }
        if (orFlags === 0) {
            return ClipState.A_INSIDE_B;
        } else if (andFlags !== 0) {
            return ClipState.NOT_CLIPPED;
        } else {
            return ClipState.CLIPPED;
        }
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param viewProjMatrix - The view projection matrix of the frustum.
   * @returns The clip test result.
   */ getClipState(viewProjMatrix) {
        let andFlags = 0xffff;
        let orFlags = 0;
        const v0 = new Vector3();
        const v1 = new Vector4();
        const minPoint = this._minPoint;
        const maxPoint = this._maxPoint;
        for(let i = 0; i < 8; i++){
            let clip = 0;
            v0.setXYZ(i & 1 ? minPoint.x : maxPoint.x, i & 2 ? minPoint.y : maxPoint.y, i & 3 ? minPoint.z : maxPoint.z);
            viewProjMatrix.transformPoint(v0, v1);
            if (v1.x < -v1.w) {
                clip |= AABB.ClipLeft;
            } else if (v1.x > v1.w) {
                clip |= AABB.ClipRight;
            }
            if (v1.y < -v1.w) {
                clip |= AABB.ClipBottom;
            } else if (v1.y > v1.w) {
                clip |= AABB.ClipTop;
            }
            if (v1.z < -v1.w) {
                clip |= AABB.ClipBack;
            } else if (v1.z > v1.w) {
                clip |= AABB.ClipFront;
            }
            andFlags &= clip;
            orFlags |= clip;
        }
        if (orFlags === 0) {
            return ClipState.A_INSIDE_B;
        } else if (andFlags !== 0) {
            return ClipState.NOT_CLIPPED;
        } else {
            return ClipState.CLIPPED;
        }
    }
    /**
   * Check if the box is behind a plane.
   * @param p - The plane to be tested.
   * @returns true if the box is behind the plane, otherwise false.
   */ behindPlane(p) {
        const cx = (this._maxPoint.x + this._minPoint.x) * 0.5;
        const cy = (this._maxPoint.y + this._minPoint.y) * 0.5;
        const cz = (this._maxPoint.z + this._minPoint.z) * 0.5;
        const ex = this._maxPoint.x - cx;
        const ey = this._maxPoint.y - cy;
        const ez = this._maxPoint.z - cz;
        return p.a * (cx + p.px * ex) + p.b * (cy + p.py * ey) + p.c * (cz + p.pz * ez) + p.d < 0;
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param frustum - The frustum object.
   * @returns The clip test result.
   */ getClipStateWithFrustum(frustum) {
        let badIntersect = false;
        const cx = (this._maxPoint.x + this._minPoint.x) * 0.5;
        const cy = (this._maxPoint.y + this._minPoint.y) * 0.5;
        const cz = (this._maxPoint.z + this._minPoint.z) * 0.5;
        const ex = this._maxPoint.x - cx;
        const ey = this._maxPoint.y - cy;
        const ez = this._maxPoint.z - cz;
        for(let i = 0; i < 6; i++){
            const p = frustum.planes[i];
            if (p.a * (cx + p.px * ex) + p.b * (cy + p.py * ey) + p.c * (cz + p.pz * ez) + p.d < 0) {
                return ClipState.NOT_CLIPPED;
            }
            if (p.a * (cx + p.nx * ex) + p.b * (cy + p.ny * ey) + p.c * (cz + p.nz * ez) + p.d < 0) {
                badIntersect = true;
            }
        }
        return badIntersect ? ClipState.CLIPPED : ClipState.A_INSIDE_B;
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param frustum - The frustum object.
   * @param mask - The frustum planes that needs to be tested.
   * @returns The clip test result.
   */ getClipStateWithFrustumMask(frustum, mask) {
        let badIntersect = false;
        const cx = (this._maxPoint.x + this._minPoint.x) * 0.5;
        const cy = (this._maxPoint.y + this._minPoint.y) * 0.5;
        const cz = (this._maxPoint.z + this._minPoint.z) * 0.5;
        const ex = this._maxPoint.x - cx;
        const ey = this._maxPoint.y - cy;
        const ez = this._maxPoint.z - cz;
        for(let i = 0; i < 6; i++){
            if (mask & 1 << i) {
                const p = frustum.planes[i];
                if (p.a * (cx + p.px * ex) + p.b * (cy + p.py * ey) + p.c * (cz + p.pz * ez) + p.d < 0) {
                    return ClipState.NOT_CLIPPED;
                }
                if (p.a * (cx + p.nx * ex) + p.b * (cy + p.ny * ey) + p.c * (cz + p.nz * ez) + p.d < 0) {
                    badIntersect = true;
                }
            }
        }
        return badIntersect ? ClipState.CLIPPED : ClipState.A_INSIDE_B;
    }
    /**
   * Get an AABB by transforming another AABB
   * @param bbox - The AABB to be transformed.
   * @param matrix - The transform matrix.
   * @param result - The out AABB to be write to.
   * @returns The out AABB.
   */ static transform(bbox, matrix, result) {
        const ret = result || new AABB();
        const minp = [
            0,
            0,
            0
        ];
        const maxp = [
            0,
            0,
            0
        ];
        const v1 = bbox.minPoint;
        const v2 = bbox.maxPoint;
        let r;
        for(let col = 0; col < 3; ++col){
            r = col;
            minp[col] = maxp[col] = matrix[12 + col];
            for(let row = 0; row < 3; ++row){
                const e = matrix[r] * v1[row];
                const f = matrix[r] * v2[row];
                if (e < f) {
                    minp[col] += e;
                    maxp[col] += f;
                } else {
                    minp[col] += f;
                    maxp[col] += e;
                }
                r += 4;
            }
        }
        ret.minPoint.set(minp);
        ret.maxPoint.set(maxp);
        return ret;
    }
}

// reduce GC
const tmpV0$1 = new Vector3();
const tmpV1$1 = new Vector3();
const tmpV2$1 = new Vector3();
const tmpV3$1 = new Vector3();
const tmpV4 = new Vector3();
/**
 * The ray class
 * @public
 */ class Ray {
    /** @internal */ _origin;
    /** @internal */ _direction;
    /** @internal */ _ii;
    /** @internal */ _ij;
    /** @internal */ _ik;
    /** @internal */ _ibyj;
    /** @internal */ _jbyi;
    /** @internal */ _kbyj;
    /** @internal */ _jbyk;
    /** @internal */ _ibyk;
    /** @internal */ _kbyi;
    /** @internal */ _c_xy;
    /** @internal */ _c_xz;
    /** @internal */ _c_yx;
    /** @internal */ _c_yz;
    /** @internal */ _c_zx;
    /** @internal */ _c_zy;
    /**
   * Do a intersection test with an AABB.
   * @param bbox - The box to be test.
   * @returns true if the ray intersect with the box, otherwise false.
   */ bboxIntersectionTest;
    /**
   * Do a intersection test with an AABB.
   * @param bbox - The box to be test.
   * @returns The distance from the origin to intersected point if the ray intersect with the box, otherwise null.
   */ bboxIntersectionTestEx;
    /**
   * Construct a ray from origin and normalized direction vector.
   * @param origin - The ray origin if not specified, zero vector will be used.
   * @param directionNormalized - The normalized direction vector. if not specified, (0, 0, 1) will be used.
   */ constructor(origin, directionNormalized){
        this._origin = origin ? new Vector3(origin) : Vector3.zero();
        this._direction = directionNormalized ? new Vector3(directionNormalized) : Vector3.axisPZ();
        this.prepare();
    }
    /** Get the ray origin point */ get origin() {
        return this._origin;
    }
    /** Get the ray direction vector */ get direction() {
        return this._direction;
    }
    /**
   * Set the ray origin and normalized direction vector.
   * @param origin - The ray origin point.
   * @param directionNormalized - The normalized direction vector.
   */ set(origin, directionNormalized) {
        this._origin.set(origin);
        this._direction.set(directionNormalized);
        this.prepare();
    }
    /**
   * Transform the ray.
   * @param matrix - The transform matrix.
   * @param other - A ray object to which the result will be written, if not specified, a new ray object will be returned.
   * @returns The transform result.
   */ transform(matrix, other) {
        if (other) {
            matrix.transformPointAffine(this._origin, other._origin);
            matrix.transformPointAffine(Vector3.add(this._origin, this._direction), other._direction).subBy(other._origin).inplaceNormalize();
            other.prepare();
        } else {
            const origin = matrix.transformPointAffine(this._origin);
            const direction = matrix.transformPointAffine(Vector3.add(this._origin, this._direction)).subBy(origin).inplaceNormalize();
            other = new Ray(origin, direction);
        }
        return other;
    }
    /**
   * Do a ray triangle intersection test.
   * @param v1 - The first triangle vertex.
   * @param v2 - The second triangle vertex.
   * @param v3 - The third triangle vertex.
   * @param cull - Allow back side intersection if true.
   * @returns Distance from origin to the intersected point if the ray intersects with the triangle, otherwise null.
   */ intersectionTestTriangle(v1, v2, v3, cull) {
        const start = this._origin;
        const normal = this._direction;
        const edge1 = Vector3.sub(v2, v1, tmpV0$1);
        const edge2 = Vector3.sub(v3, v1, tmpV1$1);
        const pvec = Vector3.cross(normal, edge2, tmpV2$1);
        const det = Vector3.dot(edge1, pvec);
        if (!cull) {
            if (det > -0.0001 && det < 0.0001) {
                return null;
            }
            const inv_det = 1.0 / det;
            const tvec = Vector3.sub(start, v1, tmpV3$1);
            const u = inv_det * Vector3.dot(tvec, pvec);
            if (u < 0 || u > 1) {
                return null;
            }
            const qvec = Vector3.cross(tvec, edge1, tmpV4);
            const v = inv_det * Vector3.dot(normal, qvec);
            if (v < 0 || u + v > 1) {
                return null;
            }
            return Vector3.dot(edge2, qvec) * inv_det;
        } else {
            if (det < 0) {
                return null;
            }
            const tvec = Vector3.sub(start, v1, tmpV3$1);
            const u = Vector3.dot(tvec, pvec);
            if (u < 0 || u > det) {
                return null;
            }
            const qvec = Vector3.cross(tvec, edge1, tmpV4);
            const v = Vector3.dot(normal, qvec);
            if (v < 0 || u + v > det) {
                return null;
            }
            return Vector3.dot(edge2, qvec) / det;
        }
    }
    /** @internal */ qtestMMM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y < y0 || this._origin.z < z0 || this._jbyi * x0 - y1 + this._c_xy > 0 || this._ibyj * y0 - x1 + this._c_yx > 0 || this._jbyk * z0 - y1 + this._c_zy > 0 || this._kbyj * y0 - z1 + this._c_yz > 0 || this._kbyi * x0 - z1 + this._c_xz > 0 || this._ibyk * z0 - x1 + this._c_zx > 0) {
            return false;
        }
        return true;
    }
    /** @internal */ qtestMMMEx(bbox) {
        if (!this.qtestMMM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestMMP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y < y0 || this._origin.z > z1 || this._jbyi * x0 - y1 + this._c_xy > 0 || this._ibyj * y0 - x1 + this._c_yx > 0 || this._jbyk * z1 - y1 + this._c_zy > 0 || this._kbyj * y0 - z0 + this._c_yz < 0 || this._kbyi * x0 - z0 + this._c_xz < 0 || this._ibyk * z1 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMMPEx(bbox) {
        if (!this.qtestMMP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestMPM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y > y1 || this._origin.z < z0 || this._jbyi * x0 - y0 + this._c_xy < 0 || this._ibyj * y1 - x1 + this._c_yx > 0 || this._jbyk * z0 - y0 + this._c_zy < 0 || this._kbyj * y1 - z1 + this._c_yz > 0 || this._kbyi * x0 - z1 + this._c_xz > 0 || this._ibyk * z0 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMPMEx(bbox) {
        if (!this.qtestMPM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestMPP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y > y1 || this._origin.z > z1 || this._jbyi * x0 - y0 + this._c_xy < 0 || this._ibyj * y1 - x1 + this._c_yx > 0 || this._jbyk * z1 - y0 + this._c_zy < 0 || this._kbyj * y1 - z0 + this._c_yz < 0 || this._kbyi * x0 - z0 + this._c_xz < 0 || this._ibyk * z1 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMPPEx(bbox) {
        if (!this.qtestMPP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestPMM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y < y0 || this._origin.z < z0 || this._jbyi * x1 - y1 + this._c_xy > 0 || this._ibyj * y0 - x0 + this._c_yx < 0 || this._jbyk * z0 - y1 + this._c_zy > 0 || this._kbyj * y0 - z1 + this._c_yz > 0 || this._kbyi * x1 - z1 + this._c_xz > 0 || this._ibyk * z0 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPMMEx(bbox) {
        if (!this.qtestPMM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestPMP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y < y0 || this._origin.z > z1 || this._jbyi * x1 - y1 + this._c_xy > 0 || this._ibyj * y0 - x0 + this._c_yx < 0 || this._jbyk * z1 - y1 + this._c_zy > 0 || this._kbyj * y0 - z0 + this._c_yz < 0 || this._kbyi * x1 - z0 + this._c_xz < 0 || this._ibyk * z1 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPMPEx(bbox) {
        if (!this.qtestPMP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) t = t1;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPPM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y > y1 || this._origin.z < z0 || this._jbyi * x1 - y0 + this._c_xy < 0 || this._ibyj * y1 - x0 + this._c_yx < 0 || this._jbyk * z0 - y0 + this._c_zy < 0 || this._kbyj * y1 - z1 + this._c_yz > 0 || this._kbyi * x1 - z1 + this._c_xz > 0 || this._ibyk * z0 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPPMEx(bbox) {
        if (!this.qtestPPM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) t = t1;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPPP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y > y1 || this._origin.z > z1 || this._jbyi * x1 - y0 + this._c_xy < 0 || this._ibyj * y1 - x0 + this._c_yx < 0 || this._jbyk * z1 - y0 + this._c_zy < 0 || this._kbyj * y1 - z0 + this._c_yz < 0 || this._kbyi * x1 - z0 + this._c_xz < 0 || this._ibyk * z1 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPPPEx(bbox) {
        if (!this.qtestPPP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) t = t1;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOMM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.z < z0 || this._jbyk * z0 - y1 + this._c_zy > 0 || this._kbyj * y0 - z1 + this._c_yz > 0) return false;
        return true;
    }
    /** @internal */ qtestOMMEx(bbox) {
        if (!this.qtestOMM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOMP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.z > z1 || this._jbyk * z1 - y1 + this._c_zy > 0 || this._kbyj * y0 - z0 + this._c_yz < 0) return false;
        return true;
    }
    /** @internal */ qtestOMPEx(bbox) {
        if (!this.qtestOMP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOPM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y > y1 || this._origin.z < z0 || this._jbyk * z0 - y0 + this._c_zy < 0 || this._kbyj * y1 - z1 + this._c_yz > 0) return false;
        return true;
    }
    /** @internal */ qtestOPMEx(bbox) {
        if (!this.qtestOPM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOPP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y > y1 || this._origin.z > z1 || this._jbyk * z1 - y0 + this._c_zy < 0 || this._kbyj * y1 - z0 + this._c_yz < 0) return false;
        return true;
    }
    /** @internal */ qtestOPPEx(bbox) {
        if (!this.qtestOPP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMOM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x < x0 || this._origin.z < z0 || this._kbyi * x0 - z1 + this._c_xz > 0 || this._ibyk * z0 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMOMEx(bbox) {
        if (!this.qtestMOM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMOP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x < x0 || this._origin.z > z1 || this._kbyi * x0 - z0 + this._c_xz < 0 || this._ibyk * z1 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMOPEx(bbox) {
        if (!this.qtestMOP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPOM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x > x1 || this._origin.z < z0 || this._kbyi * x1 - z1 + this._c_xz > 0 || this._ibyk * z0 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPOMEx(bbox) {
        if (!this.qtestPOM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPOP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x > x1 || this._origin.z > z1 || this._kbyi * x1 - z0 + this._c_xz < 0 || this._ibyk * z1 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPOPEx(bbox) {
        if (!this.qtestPOP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMMO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x < x0 || this._origin.y < y0 || this._jbyi * x0 - y1 + this._c_xy > 0 || this._ibyj * y0 - x1 + this._c_yx > 0) return false;
        return true;
    }
    /** @internal */ qtestMMOEx(bbox) {
        if (!this.qtestMMO(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMPO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x < x0 || this._origin.y > y1 || this._jbyi * x0 - y0 + this._c_xy < 0 || this._ibyj * y1 - x1 + this._c_yx > 0) return false;
        return true;
    }
    /** @internal */ qtestMPOEx(bbox) {
        if (!this.qtestMPO(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPMO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x > x1 || this._origin.y < y0 || this._jbyi * x1 - y1 + this._c_xy > 0 || this._ibyj * y0 - x0 + this._c_yx < 0) return false;
        return true;
    }
    /** @internal */ qtestPMOEx(bbox) {
        if (!this.qtestPMO(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPPO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x > x1 || this._origin.y > y1 || this._jbyi * x1 - y0 + this._c_xy < 0 || this._ibyj * y1 - x0 + this._c_yx < 0) return false;
        return true;
    }
    /** @internal */ qtestPPOEx(bbox) {
        if (!this.qtestPPO(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMOO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y < y0 || this._origin.y > y1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestMOOEx(bbox) {
        if (!this.qtestMOO(bbox)) {
            return null;
        }
        const t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        return t;
    }
    /** @internal */ qtestPOO(bbox) {
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y < y0 || this._origin.y > y1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestPOOEx(bbox) {
        if (!this.qtestPOO(bbox)) {
            return null;
        }
        const t = (bbox.minPoint.x - this._origin.x) * this._ii;
        return t;
    }
    /** @internal */ qtestOMO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.x < x0 || this._origin.x > x1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestOMOEx(bbox) {
        if (!this.qtestOMO(bbox)) {
            return null;
        }
        const t = (bbox.maxPoint.y - this._origin.y) * this._ij;
        return t;
    }
    /** @internal */ qtestOPO(bbox) {
        const x0 = bbox.minPoint.x;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y > y1 || this._origin.x < x0 || this._origin.x > x1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestOPOEx(bbox) {
        if (!this.qtestOPO(bbox)) {
            return null;
        }
        const t = (bbox.minPoint.y - this._origin.y) * this._ij;
        return t;
    }
    /** @internal */ qtestOOM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        if (this._origin.z < z0 || this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.y > y1) return false;
        return true;
    }
    /** @internal */ qtestOOMEx(bbox) {
        if (!this.qtestOOM(bbox)) {
            return null;
        }
        const t = (bbox.maxPoint.z - this._origin.z) * this._ik;
        return t;
    }
    /** @internal */ qtestOOP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z > z1 || this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.y > y1) return false;
        return true;
    }
    /** @internal */ qtestOOPEx(bbox) {
        if (!this.qtestOOP(bbox)) {
            return null;
        }
        const t = (bbox.minPoint.z - this._origin.z) * this._ik;
        return t;
    }
    /** @internal */ prepare() {
        const x = this._origin.x;
        const y = this._origin.y;
        const z = this._origin.z;
        const i = this._direction.x;
        const j = this._direction.y;
        const k = this._direction.z;
        this._ii = 1.0 / i;
        this._ij = 1.0 / j;
        this._ik = 1.0 / k;
        this._ibyj = i * this._ij;
        this._jbyi = j * this._ii;
        this._jbyk = j * this._ik;
        this._kbyj = k * this._ij;
        this._ibyk = i * this._ik;
        this._kbyi = k * this._ii;
        this._c_xy = y - this._jbyi * x;
        this._c_xz = z - this._kbyi * x;
        this._c_yx = x - this._ibyj * y;
        this._c_yz = z - this._kbyj * y;
        this._c_zx = x - this._ibyk * z;
        this._c_zy = y - this._jbyk * z;
        if (i < 0) {
            if (j < 0) {
                if (k < 0) {
                    this.bboxIntersectionTest = this.qtestMMM;
                    this.bboxIntersectionTestEx = this.qtestMMMEx;
                } else if (k > 0) {
                    this.bboxIntersectionTest = this.qtestMMP;
                    this.bboxIntersectionTestEx = this.qtestMMPEx;
                } else {
                    this.bboxIntersectionTest = this.qtestMMO;
                    this.bboxIntersectionTestEx = this.qtestMMOEx;
                }
            } else {
                if (k < 0) {
                    this.bboxIntersectionTest = j > 0 ? this.qtestMPM : this.qtestMOM;
                    this.bboxIntersectionTestEx = j > 0 ? this.qtestMPMEx : this.qtestMOMEx;
                } else {
                    if (j === 0 && k === 0) {
                        this.bboxIntersectionTest = this.qtestMOO;
                        this.bboxIntersectionTestEx = this.qtestMOOEx;
                    } else if (k === 0) {
                        this.bboxIntersectionTest = this.qtestMPO;
                        this.bboxIntersectionTestEx = this.qtestMPOEx;
                    } else if (j === 0) {
                        this.bboxIntersectionTest = this.qtestMOP;
                        this.bboxIntersectionTestEx = this.qtestMOPEx;
                    } else {
                        this.bboxIntersectionTest = this.qtestMPP;
                        this.bboxIntersectionTestEx = this.qtestMPPEx;
                    }
                }
            }
        } else {
            if (j < 0) {
                if (k < 0) {
                    this.bboxIntersectionTest = i > 0 ? this.qtestPMM : this.qtestOMM;
                    this.bboxIntersectionTestEx = i > 0 ? this.qtestPMMEx : this.qtestOMMEx;
                } else {
                    if (i === 0 && k === 0) {
                        this.bboxIntersectionTest = this.qtestOMO;
                        this.bboxIntersectionTestEx = this.qtestOMOEx;
                    } else if (k === 0) {
                        this.bboxIntersectionTest = this.qtestPMO;
                        this.bboxIntersectionTestEx = this.qtestPMOEx;
                    } else if (i === 0) {
                        this.bboxIntersectionTest = this.qtestOMP;
                        this.bboxIntersectionTestEx = this.qtestOMPEx;
                    } else {
                        this.bboxIntersectionTest = this.qtestPMP;
                        this.bboxIntersectionTestEx = this.qtestPMPEx;
                    }
                }
            } else {
                if (k < 0) {
                    if (i === 0 && j === 0) {
                        this.bboxIntersectionTest = this.qtestOOM;
                        this.bboxIntersectionTestEx = this.qtestOOMEx;
                    } else if (i === 0) {
                        this.bboxIntersectionTest = this.qtestOPM;
                        this.bboxIntersectionTestEx = this.qtestOPMEx;
                    } else if (j === 0) {
                        this.bboxIntersectionTest = this.qtestPOM;
                        this.bboxIntersectionTestEx = this.qtestPOMEx;
                    } else {
                        this.bboxIntersectionTest = this.qtestPPM;
                        this.bboxIntersectionTestEx = this.qtestPPMEx;
                    }
                } else {
                    if (i === 0) {
                        if (j === 0) {
                            this.bboxIntersectionTest = this.qtestOOP;
                            this.bboxIntersectionTestEx = this.qtestOOPEx;
                        } else if (k === 0) {
                            this.bboxIntersectionTest = this.qtestOPO;
                            this.bboxIntersectionTestEx = this.qtestOPOEx;
                        } else {
                            this.bboxIntersectionTest = this.qtestOPP;
                            this.bboxIntersectionTestEx = this.qtestOPPEx;
                        }
                    } else {
                        if (j === 0 && k === 0) {
                            this.bboxIntersectionTest = this.qtestPOO;
                            this.bboxIntersectionTestEx = this.qtestPOOEx;
                        } else if (j === 0) {
                            this.bboxIntersectionTest = this.qtestPOP;
                            this.bboxIntersectionTestEx = this.qtestPOPEx;
                        } else if (k === 0) {
                            this.bboxIntersectionTest = this.qtestPPO;
                            this.bboxIntersectionTestEx = this.qtestPPOEx;
                        } else {
                            this.bboxIntersectionTest = this.qtestPPP;
                            this.bboxIntersectionTestEx = this.qtestPPPEx;
                        }
                    }
                }
            }
        }
    }
}

const tmpQuat1 = new Quaternion();
const tmpQuat2 = new Quaternion();
const tmpQuat3 = new Quaternion();
const strideMap = {
    number: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    quat: 4
};
function numberClamp(x, min, max) {
    return x < min ? min : x > max ? max : x;
}
/**
 * The interpolator class
 * @public
 */ class Interpolator {
    /** @internal */ _prevKey;
    /** @internal */ _prevT;
    /** @internal */ _inputs;
    /** @internal */ _outputs;
    /** @internal */ _mode;
    /** @internal */ _target;
    /** @internal */ _stride;
    /** @internal */ _maxTime;
    /**
   * Interpolation target to stride
   * @param target - The interpolation target
   * @returns Stride of the target
   */ static getTargetStride(target) {
        return strideMap[target] ?? 0;
    }
    /**
   * Creates a interpolator instance
   * @param mode - The interpolation mode
   * @param target - The interpolation target
   * @param inputs - Linear time in seconds
   * @param outputs - Vector or scalars representing the properties to be interpolated
   * @param stride - Stride of outputs
   */ constructor(mode, target, inputs, outputs){
        this._prevKey = 0;
        this._prevT = 0;
        this._inputs = inputs;
        this._outputs = outputs;
        this._mode = mode;
        this._target = target;
        this._stride = strideMap[target] ?? 0;
        this._maxTime = inputs[inputs.length - 1];
    }
    /** Gets the interpolation mode */ get mode() {
        return this._mode;
    }
    /** Gets the interpolation target */ get target() {
        return this._target;
    }
    get maxTime() {
        return this._maxTime;
    }
    /** @internal */ slerpQuat(q1, q2, t, result) {
        return Quaternion.slerp(Quaternion.normalize(q1), Quaternion.normalize(q2), t, result).inplaceNormalize();
    }
    /**
   * Calculates the interpolated value at a given time
   * @param t - The time to calcuate interpolation
   * @param maxTime - The maxmium time duration
   * @param result - The calculated interpolation value
   * @returns The calcuated interpolation value
   */ interpolate(t, maxTime, result) {
        if (t === undefined) {
            return undefined;
        }
        const input = this._inputs;
        const output = this._outputs;
        if (output.length === this._stride) {
            for(let i = 0; i < this._stride; i++){
                result[i] = output[i];
            }
            return result;
        }
        t = numberClamp(t % maxTime, input[0], input[input.length - 1]);
        if (this._prevT > t) {
            this._prevKey = 0;
        }
        this._prevT = t;
        let nextKey;
        for(let i = this._prevKey; i < input.length; ++i){
            if (t <= input[i]) {
                nextKey = numberClamp(i, 1, input.length - 1);
                break;
            }
        }
        this._prevKey = numberClamp(nextKey - 1, 0, nextKey);
        const keyDelta = input[nextKey] - input[this._prevKey];
        const tn = (t - input[this._prevKey]) / keyDelta;
        if (this._target === 'quat') {
            if (this._mode === 'cubicspline') {
                this.cubicSpline(this._prevKey, nextKey, keyDelta, tn, tmpQuat3);
                result.set(tmpQuat3);
                return result;
            } else if (this._mode === 'linear') {
                this.getQuat(this._prevKey, tmpQuat1);
                this.getQuat(nextKey, tmpQuat2);
                this.slerpQuat(tmpQuat1, tmpQuat2, tn, tmpQuat3);
                result.set(tmpQuat3);
                return result;
            } else {
                return this.getQuat(this._prevKey, result);
            }
        }
        switch(this._mode){
            case 'step':
                return this.step(this._prevKey, result);
            case 'cubicspline':
                return this.cubicSpline(this._prevKey, nextKey, keyDelta, tn, result);
            case 'linear':
            default:
                return this.linear(this._prevKey, nextKey, tn, result);
        }
    }
    /** @internal */ getQuat(index, result) {
        result[0] = this._outputs[4 * index];
        result[1] = this._outputs[4 * index + 1];
        result[2] = this._outputs[4 * index + 2];
        result[3] = this._outputs[4 * index + 3];
        return result;
    }
    /** @internal */ step(prevKey, result) {
        for(let i = 0; i < this._stride; i++){
            result[i] = this._outputs[prevKey * this._stride + i];
        }
        return result;
    }
    /** @internal */ linear(prevKey, nextKey, t, result) {
        for(let i = 0; i < this._stride; i++){
            result[i] = this._outputs[prevKey * this._stride + i] * (1 - t) + this._outputs[nextKey * this._stride + i] * t;
        }
        return result;
    }
    /** @internal */ cubicSpline(prevKey, nextKey, keyDelta, t, result) {
        const prevIndex = prevKey * this._stride * 3;
        const nextIndex = nextKey * this._stride * 3;
        const A = 0;
        const V = this._stride;
        const B = 2 * this._stride;
        const tSq = t * t;
        const tCub = tSq * t;
        for(let i = 0; i < this._stride; i++){
            const v0 = this._outputs[prevIndex + i + V];
            const a = keyDelta * this._outputs[nextIndex + i + A];
            const b = keyDelta * this._outputs[prevIndex + i + B];
            const v1 = this._outputs[nextIndex + i + V];
            result[i] = (2 * tCub - 3 * tSq + 1) * v0 + (tCub - 2 * tSq + t) * b + (-2 * tCub + 3 * tSq) * v1 + (tCub - tSq) * a;
        }
        return result;
    }
}

/**
 * The rectangle packer class
 * @public
 */ class RectsPacker {
    /** @internal */ _bins;
    /** @internal */ _maxBins;
    /** @internal */ _width;
    /** @internal */ _height;
    /**
   * @param width - width of image bin
   * @param height - height of image bin
   * @param maxBins - max count of image bins
   */ constructor(width, height, maxBins = 0){
        this._width = width;
        this._height = height;
        this._maxBins = maxBins;
        this._bins = [
            new Bin(this._width, this._height)
        ];
    }
    /** Clear all image bins of the packer */ clear() {
        this._bins = [
            new Bin(this._width, this._height)
        ];
    }
    /**
   * Inserts a new rectangle
   * @param width - Width of the rectangle.
   * @param height - Height of the rectangle.
   * @returns The pack result.
   */ insert(width, height) {
        if (width > this._width || height > this._height) {
            return null;
        }
        const rect = this._bins[this._bins.length - 1].insert(width, height);
        if (rect) {
            return {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                binIndex: this._bins.length - 1
            };
        }
        if (this._maxBins === 0 || this._bins.length < this._maxBins) {
            this._bins.push(new Bin(this._width, this._height));
            const rect = this._bins[this._bins.length - 1].insert(width, height);
            return {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                binIndex: this._bins.length - 1
            };
        }
        return null;
    }
}
class Bin {
    freeRects;
    constructor(width, height){
        this.freeRects = [
            {
                x: 0,
                y: 0,
                width,
                height
            }
        ];
    }
    insert(width, height) {
        const newRect = this.findBestFit(width, height);
        if (!newRect) {
            return null;
        }
        let numRectsToProcess = this.freeRects.length;
        let i = 0;
        while(i < numRectsToProcess){
            if (this.splitFreeRect(this.freeRects[i], newRect)) {
                this.freeRects.splice(i, 1);
                --numRectsToProcess;
                --i;
            }
            ++i;
        }
        this.pruneFreeRects();
        return newRect;
    }
    findBestFit(width, height) {
        let score = Number.MAX_VALUE;
        let rect = null;
        for (const freeRect of this.freeRects){
            if (freeRect.width >= width && freeRect.height >= height) {
                const areaFit = freeRect.width * freeRect.height - width * height;
                if (areaFit < score) {
                    if (!rect) {
                        rect = {
                            width,
                            height
                        };
                    }
                    rect.x = freeRect.x;
                    rect.y = freeRect.y;
                    score = areaFit;
                }
            }
        }
        return rect;
    }
    splitFreeRect(free, used) {
        if (used.x >= free.x + free.width || used.x + used.width <= free.x || used.y >= free.y + free.height || used.y + used.height <= free.y) {
            return false;
        }
        if (used.x < free.x + free.width && used.x + used.width > free.x) {
            if (used.y > free.y && used.y < free.y + free.height) {
                this.freeRects.push({
                    x: free.x,
                    y: free.y,
                    width: free.width,
                    height: used.y - free.y
                });
            }
            if (used.y + used.height < free.y + free.height) {
                this.freeRects.push({
                    x: free.x,
                    y: used.y + used.height,
                    width: free.width,
                    height: free.y + free.height - used.y - used.height
                });
            }
        }
        if (used.y < free.y + free.height && used.y + used.height > free.y) {
            if (used.x > free.x && used.x < free.x + free.width) {
                this.freeRects.push({
                    x: free.x,
                    y: free.y,
                    width: used.x - free.x,
                    height: free.height
                });
            }
            if (used.x + used.width < free.x + free.width) {
                this.freeRects.push({
                    x: used.x + used.width,
                    y: free.y,
                    width: free.x + free.width - used.x - used.width,
                    height: free.height
                });
            }
        }
        return true;
    }
    pruneFreeRects() {
        let i = 0;
        let j = 0;
        let len = this.freeRects.length;
        while(i < len){
            j = i + 1;
            const rect1 = this.freeRects[i];
            while(j < len){
                const rect2 = this.freeRects[j];
                if (this.isRectInRect(rect1, rect2)) {
                    this.freeRects.splice(i, 1);
                    --i;
                    --len;
                    break;
                }
                if (this.isRectInRect(rect2, rect1)) {
                    this.freeRects.splice(j, 1);
                    --j;
                    --len;
                }
                j++;
            }
            i++;
        }
    }
    isRectInRect(test, container) {
        return test.x >= container.x && test.y >= container.y && test.x + test.width <= container.x + container.width && test.y + test.height <= container.y + container.height;
    }
}

/**
 * Pseudorandom number generator
 * @public
 */ class PRNG {
    /** @internal */ _generator;
    /**
   * Creates an instance of PRNG
   * @param seed - The random seed
   */ constructor(seed = 0){
        // mulberry32 algorithm
        this._generator = ()=>{
            let t = seed += 0x6d2b79f5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }
    /** Gets next random value between 0 and 1 */ get() {
        return this._generator();
    }
}

/**
 * Input manager class
 * @public
 */ class InputManager {
    _app;
    _target;
    _started;
    _clickDistTolerance;
    _clickTimeTolerance;
    _dblclickDistTolerance;
    _dblclickTimeTolerance;
    _pointerDownHandler;
    _pointerUpHandler;
    _pointerMoveHandler;
    _pointerCancelHandler;
    _keyboardHandler;
    _dragHandler;
    _wheelHandler;
    _captureId;
    _middlewares;
    _lastEventDatas;
    /**
   * Creates an instance of InputManager
   * @param app
   */ constructor(app){
        this._app = app;
        this._target = app.options.canvas;
        this._started = false;
        this._clickDistTolerance = 4 * 4;
        this._clickTimeTolerance = 400;
        this._dblclickDistTolerance = 4 * 4;
        this._dblclickTimeTolerance = 400;
        this._lastEventDatas = [];
        this._pointerDownHandler = this._getPointerDownHandler();
        this._pointerUpHandler = this._getPointerUpHandler();
        this._pointerMoveHandler = this._getPointerMoveHander();
        this._pointerCancelHandler = this._getPointerCancelHandler();
        this._keyboardHandler = this._getKeyboardHandler();
        this._dragHandler = this._getDragHandler();
        this._wheelHandler = this._getWheelHandler();
        this._captureId = -1;
        this._middlewares = [];
    }
    /** @internal */ start() {
        if (!this._started) {
            this._started = true;
            this._target.addEventListener('pointerdown', this._pointerDownHandler);
            this._target.addEventListener('pointerup', this._pointerUpHandler);
            this._target.addEventListener('pointermove', this._pointerMoveHandler);
            this._target.addEventListener('pointercancel', this._pointerCancelHandler);
            this._target.addEventListener('keydown', this._keyboardHandler);
            this._target.addEventListener('keyup', this._keyboardHandler);
            this._target.addEventListener('keypress', this._keyboardHandler);
            this._target.addEventListener('drag', this._dragHandler);
            this._target.addEventListener('dragenter', this._dragHandler);
            this._target.addEventListener('dragleave', this._dragHandler);
            this._target.addEventListener('dragstart', this._dragHandler);
            this._target.addEventListener('dragend', this._dragHandler);
            this._target.addEventListener('dragover', this._dragHandler);
            this._target.addEventListener('drop', this._dragHandler);
            this._target.addEventListener('wheel', this._wheelHandler);
        }
    }
    /** @internal */ stop() {
        if (this._started) {
            this._started = false;
            this._target.removeEventListener('pointerdown', this._pointerDownHandler);
            this._target.removeEventListener('pointerup', this._pointerUpHandler);
            this._target.removeEventListener('pointermove', this._pointerMoveHandler);
            this._target.removeEventListener('pointercancel', this._pointerCancelHandler);
            this._target.removeEventListener('keydown', this._keyboardHandler);
            this._target.removeEventListener('keyup', this._keyboardHandler);
            this._target.removeEventListener('keypress', this._keyboardHandler);
            this._target.removeEventListener('drag', this._dragHandler);
            this._target.removeEventListener('dragenter', this._dragHandler);
            this._target.removeEventListener('dragleave', this._dragHandler);
            this._target.removeEventListener('dragstart', this._dragHandler);
            this._target.removeEventListener('dragend', this._dragHandler);
            this._target.removeEventListener('dragover', this._dragHandler);
            this._target.removeEventListener('drop', this._dragHandler);
            this._target.removeEventListener('wheel', this._wheelHandler);
            this._lastEventDatas = [];
        }
    }
    /**
   * Adds a event handler middleware.
   *
   * @remarks
   * All handlers will be called in the order in which they were added
   * until a handler returns true.
   * If either handler returns true, the event that the Application
   * listens to will not be triggered
   *
   * @param handler The event handler to be added
   * @returns self
   */ use(handler) {
        if (handler) {
            this._middlewares.push(handler);
        }
        return this;
    }
    _callMiddlewares(ev, type) {
        for (const handler of this._middlewares){
            if (handler(ev, type ?? ev.type)) {
                return true;
            }
        }
        return false;
    }
    _getPointerCancelHandler() {
        const that = this;
        return function(ev) {
            const eventData = that._getPointerEventData(ev.pointerId);
            eventData.lastDown = false;
            eventData.lastClick = false;
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerMoveHander() {
        const that = this;
        return function(ev) {
            const eventData = that._getPointerEventData(ev.pointerId);
            eventData.lastMoveX = ev.offsetX;
            eventData.lastMoveY = ev.offsetY;
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerDownHandler() {
        const that = this;
        return function(ev) {
            if (ev.pointerType === 'mouse' && ev.button === 0) {
                that._captureId = ev.pointerId;
                that._app.options.canvas.setPointerCapture(ev.pointerId);
            }
            const eventData = that._getPointerEventData(ev.pointerId);
            eventData.lastDown = true;
            eventData.lastDownX = ev.offsetX;
            eventData.lastDownY = ev.offsetY;
            eventData.lastDownTime = Date.now();
            that._app.focus();
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerUpHandler() {
        const that = this;
        return function(ev) {
            if (ev.pointerType === 'mouse' && ev.button === 0 && that._captureId === ev.pointerId) {
                that._app.options.canvas.releasePointerCapture(ev.pointerId);
                that._captureId = -1;
            }
            const eventData = that._getPointerEventData(ev.pointerId);
            let emitClickEvent = false;
            let emitDoubleClickEvent = false;
            const now = Date.now();
            if (eventData.lastDown) {
                if (now <= eventData.lastDownTime + that._clickTimeTolerance) {
                    let deltaX = ev.offsetX - eventData.lastDownX;
                    let deltaY = ev.offsetY - eventData.lastDownY;
                    if (deltaX * deltaX + deltaY * deltaY <= that._clickDistTolerance) {
                        emitClickEvent = true;
                        if (eventData.lastClick && now <= eventData.lastClickTime + that._dblclickTimeTolerance) {
                            deltaX = ev.offsetX - eventData.lastClickX;
                            deltaY = ev.offsetY - eventData.lastClickY;
                            if (deltaX * deltaX + deltaY * deltaY <= that._dblclickDistTolerance) {
                                emitDoubleClickEvent = true;
                            }
                        }
                    }
                }
            }
            eventData.lastDown = false;
            eventData.lastMoveX = ev.offsetX;
            eventData.lastMoveY = ev.offsetY;
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
            if (emitClickEvent) {
                if (!that._callMiddlewares(ev, 'click')) {
                    that._app.dispatchEvent(ev, 'click');
                }
                if (emitDoubleClickEvent) {
                    if (!that._callMiddlewares(ev, 'dblclick')) {
                        that._app.dispatchEvent(ev, 'dblclick');
                    }
                    eventData.lastClick = false;
                } else {
                    eventData.lastClick = true;
                    eventData.lastClickX = ev.offsetX;
                    eventData.lastClickY = ev.offsetY;
                    eventData.lastClickTime = now;
                }
            }
        };
    }
    _getKeyboardHandler() {
        const that = this;
        return function(ev) {
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getDragHandler() {
        const that = this;
        return function(ev) {
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getWheelHandler() {
        const that = this;
        return function(ev) {
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerEventData(pointerId) {
        return this._lastEventDatas[pointerId] ?? (this._lastEventDatas[pointerId] = {
            lastClick: false,
            lastClickX: 0,
            lastClickY: 0,
            lastClickTime: 0,
            lastDown: false,
            lastDownX: 0,
            lastDownY: 0,
            lastDownTime: 0,
            lastMoveX: 0,
            lastMoveY: 0
        });
    }
}

/**
 * Event that will be fired every frame
 *
 * @remarks
 * This is where all the rendering work is done.
 *
 * @public
 */ class AppTickEvent {
    type = 'tick';
}
/**
 * This event will be fired whenever the device size changes
 * @public
 */ class AppResizeEvent {
    width;
    height;
    type;
    constructor(width, height){
        this.type = 'resize';
        this.width = width;
        this.height = height;
    }
}
/**
 * Application class
 *
 * @remarks
 * This is the entry point of your application.
 * The Application is responsible for initializing the rendering device
 * and doing the rendering loop.
 * The Application can not be created more than once. You can get the
 * instance by calling the 'Application.instance' static method.
 *
 * @public
 */ class Application extends makeEventTarget(Object)() {
    _options;
    _device;
    _inputManager;
    _running;
    _ready;
    _canRender;
    _drawEvent;
    _logger;
    _elapsed;
    static _instance;
    /**
   * Creates an instance of Application
   * @param opt - The creation options
   */ constructor(opt){
        super();
        if (Application._instance) {
            throw new Error('It is not allowed to have multiple Application instances');
        }
        Application._instance = this;
        this._options = {
            backend: opt.backend,
            enableMSAA: opt.enableMSAA ?? false,
            pixelRatio: opt.pixelRatio ?? window.devicePixelRatio ?? 1,
            canvas: opt.canvas
        };
        this._inputManager = new InputManager(this);
        this._running = null;
        this._ready = false;
        this._canRender = false;
        this._elapsed = 0;
        this._drawEvent = new AppTickEvent();
        this._logger = {
            log (text, mode) {
                if (mode === 'warn') {
                    console.warn(text);
                } else if (mode === 'error') {
                    console.error(text);
                } else if (mode === 'debug') {
                    console.debug(text);
                } else if (mode === 'info') {
                    console.info(text);
                } else {
                    console.log(text);
                }
            }
        };
    }
    /** The input manager instance */ get inputManager() {
        return this._inputManager;
    }
    /** The options that was used to create the application */ get options() {
        return this._options;
    }
    /**
   * Query if the device is ok to render objects now.
   *
   * @remarks
   * False will be returned if the device is lost.
   */ get canRender() {
        return this._canRender;
    }
    /**
   * Query time elapsed since last frame in seconds
   */ get timeElapsedInSeconds() {
        return this._elapsed;
    }
    /** Gets the singleton instance of the application */ static get instance() {
        return this._instance;
    }
    /** The rendering device that was initialized by the application */ get device() {
        return this._device;
    }
    /** Gets the device type */ get deviceType() {
        return this._options.backend.typeName();
    }
    /** The logger object */ get logger() {
        return this._logger;
    }
    set logger(val) {
        this._logger = val;
    }
    /** Set focus */ focus() {
        this._device.canvas.focus();
    }
    /** Wait until the application is ready. */ async ready() {
        if (!this._ready) {
            this._device = await this._options.backend.createDevice(this._options.canvas, {
                dpr: this._options.pixelRatio,
                msaa: !!this._options.enableMSAA
            });
            if (!this._device) {
                throw new Error('App.init(): create device failed');
            }
            this._device.canvas.focus();
            this._inputManager.start();
            this._device.on('resize', (ev)=>{
                this.dispatchEvent(new AppResizeEvent(ev.width, ev.height));
            });
            this._ready = true;
        }
    }
    /** Render one frame */ frame() {
        if (this._ready) {
            this._canRender = this.device.beginFrame();
            this._elapsed = this.device.frameInfo.elapsedFrame * 0.001;
            this.device.setFramebuffer(null);
            this.device.setViewport(null);
            this.device.setScissor(null);
            this.dispatchEvent(this._drawEvent);
            this.device.endFrame();
        }
    }
    /** Start running the rendering loop */ run() {
        if (this._running) {
            return;
        }
        const that = this;
        (function entry() {
            that._running = requestAnimationFrame(entry);
            that.frame();
        })();
    }
    /** Stop running the rendering loop */ stop() {
        if (this._running) {
            cancelAnimationFrame(this._running);
            this._running = null;
        }
    }
    /** Message log */ log(text, mode) {
        this._logger?.log(text, mode);
    }
}

let vertexLayout = null;
let renderStates = null;
const programs = {};
const faceDirections = [
    [
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0),
        new Vector3(1, 0, 0)
    ],
    [
        new Vector3(0, 0, 1),
        new Vector3(0, -1, 0),
        new Vector3(-1, 0, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, 1)
    ],
    [
        new Vector3(-1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, -1)
    ]
];
function init() {
    const device = Application.instance.device;
    const vertices = new Float32Array([
        1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        -1
    ]);
    const indices = new Uint16Array([
        0,
        1,
        2,
        0,
        2,
        3
    ]);
    vertexLayout = device.createVertexLayout({
        vertexBuffers: [
            {
                buffer: device.createVertexBuffer('position_f32x2', vertices)
            }
        ],
        indexBuffer: device.createIndexBuffer(indices)
    });
    renderStates = device.createRenderStateSet();
    renderStates.useRasterizerState().setCullMode('none');
    renderStates.useDepthState().enableTest(false).enableWrite(false);
}
function getProgramInfo(type, numSamples) {
    const device = Application.instance.device;
    const hash = `${type}:${numSamples}`;
    let ret = programs[hash];
    if (!ret) {
        const program = createPMREMProgram(type, numSamples);
        const bindgroup = device.createBindGroup(program.bindGroupLayouts[0]);
        programs[hash] = ret = {
            program,
            bindgroup
        };
    }
    return ret;
}
function createPMREMProgram(type, numSamples) {
    const device = Application.instance.device;
    const pb = device;
    return pb.buildRenderProgram({
        vertex (pb) {
            this.$inputs.pos = pb.vec2().attrib('position');
            this.up = pb.vec3().uniform(0);
            this.right = pb.vec3().uniform(0);
            this.front = pb.vec3().uniform(0);
            pb.main(function() {
                this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                this.$outputs.direction = pb.mul(pb.mat3(this.up, this.right, this.front), pb.vec3(this.$inputs.pos, 1));
                if (device.type === 'webgpu') {
                    this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                }
            });
        },
        fragment (pb) {
            if (type === 'ggx') {
                this.alphaG = pb.float().uniform(0);
            }
            this.vFilteringInfo = pb.vec2().uniform(0);
            this.hdrScale = pb.float().uniform(0);
            this.inputTexture = pb.texCube().uniform(0);
            this.NUM_SAMPLES_FLOAT = pb.float(numSamples);
            this.NUM_SAMPLES_FLOAT_INVERSED = pb.float(1 / numSamples);
            this.K = pb.float(4);
            this.$outputs.outcolor = pb.vec4();
            if (device.type === 'webgl') {
                pb.func('radicalInverse_VdC', [
                    pb.int('bits')
                ], function() {
                    this.$l.rand = pb.float(0);
                    this.$l.denom = pb.float(1);
                    this.$l.invBase = pb.float(0.5);
                    this.$l.n = this.bits;
                    this.$for(pb.int('i'), 0, 32, function() {
                        this.denom = pb.mul(this.denom, 2);
                        this.rand = pb.add(this.rand, pb.div(pb.mod(pb.float(this.n), 2), this.denom));
                        this.n = pb.div(this.n, 2);
                        this.$if(pb.equal(this.n, 0), function() {
                            this.$break();
                        });
                    });
                    this.$return(this.rand);
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(this.i)));
                });
            } else {
                pb.func('radicalInverse_VdC', [
                    pb.uint('bits')
                ], function() {
                    this.$l.n = this.bits;
                    this.n = pb.compOr(pb.sal(this.n, 16), pb.sar(this.n, 16));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x55555555), 1), pb.sar(pb.compAnd(this.n, 0xaaaaaaaa), 1));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x33333333), 2), pb.sar(pb.compAnd(this.n, 0xcccccccc), 2));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x0f0f0f0f), 4), pb.sar(pb.compAnd(this.n, 0xf0f0f0f0), 4));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x00ff00ff), 8), pb.sar(pb.compAnd(this.n, 0xff00ff00), 8));
                    this.$return(pb.mul(pb.float(this.n), 2.3283064365386963e-10));
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(pb.uint(this.i))));
                });
            }
            pb.func('log4', [
                pb.float('x')
            ], function() {
                this.$return(pb.mul(pb.log2(this.x), 0.5));
            });
            if (type === 'lambertian') {
                pb.func('hemisphereCosSample', [
                    pb.vec2('u')
                ], function() {
                    this.$l.phi = pb.mul(this.u.x, 2 * Math.PI);
                    this.$l.cosTheta2 = pb.sub(1, this.u.y);
                    this.$l.cosTheta = pb.sqrt(this.cosTheta2);
                    this.$l.sinTheta = pb.sqrt(pb.sub(1, this.cosTheta2));
                    this.$return(pb.vec3(pb.mul(this.sinTheta, pb.cos(this.phi)), pb.mul(this.sinTheta, pb.sin(this.phi)), this.cosTheta));
                });
                pb.func('irradiance', [
                    pb.vec3('direction'),
                    pb.vec2('vFilteringInfo')
                ], function() {
                    this.$l.n = pb.normalize(this.direction);
                    this.$l.result = pb.vec3(0);
                    this.$l.tangent = pb.vec3();
                    this.$if(pb.lessThan(pb.abs(this.n.z), 0.999), function() {
                        this.tangent = pb.vec3(0, 0, 1);
                    }).$else(function() {
                        this.tangent = pb.vec3(1, 0, 0);
                    });
                    this.tangent = pb.normalize(pb.cross(this.tangent, this.n));
                    this.$l.bitangent = pb.cross(this.n, this.tangent);
                    this.$l.tbn = pb.mat3(this.tangent, this.bitangent, this.n);
                    this.$l.maxLevel = this.vFilteringInfo.y;
                    this.$l.dim0 = this.vFilteringInfo.x;
                    this.$l.omegaP = pb.div(4 * Math.PI, pb.mul(this.dim0, this.dim0, 6));
                    this.$for(pb.int('i'), 0, numSamples, function() {
                        this.$l.Xi = this.hammersley2d(this.i, numSamples);
                        this.$l.Ls = pb.normalize(this.hemisphereCosSample(this.Xi));
                        this.$l.Ns = pb.vec3(0, 0, 1);
                        this.$l.NoL = pb.dot(this.Ns, this.Ls);
                        this.$if(pb.greaterThan(this.NoL, 0), function() {
                            this.$l.pdf_inversed = pb.div(Math.PI, this.NoL);
                            this.$l.omegaS = pb.mul(this.pdf_inversed, this.NUM_SAMPLES_FLOAT_INVERSED);
                            this.$l.l = pb.add(pb.sub(this.log4(this.omegaS), this.log4(this.omegaP)), this.log4(this.K));
                            this.$l.mipLevel = pb.clamp(this.l, 0, this.maxLevel);
                            this.$l.c = pb.textureSampleLevel(this.inputTexture, pb.mul(this.tbn, this.Ls), this.mipLevel).rgb;
                            this.result = pb.add(this.result, this.c);
                        });
                    });
                    this.result = pb.mul(this.result, this.NUM_SAMPLES_FLOAT_INVERSED);
                    this.$return(this.result);
                });
            }
            if (type === 'ggx') {
                pb.func('hemisphereImportanceSampleDggx', [
                    pb.vec2('u'),
                    pb.float('a')
                ], function() {
                    this.$l.phi = pb.mul(this.u.x, 2 * Math.PI);
                    this.$l.cosTheta2 = pb.div(pb.sub(1, this.u.y), pb.add(pb.mul(pb.add(this.a, 1), pb.sub(this.a, 1), this.u.y), 1));
                    this.$l.cosTheta = pb.sqrt(this.cosTheta2);
                    this.$l.sinTheta = pb.sqrt(pb.sub(1, this.cosTheta2));
                    this.$return(pb.vec3(pb.mul(pb.cos(this.phi), this.sinTheta), pb.mul(pb.sin(this.phi), this.sinTheta), this.cosTheta));
                });
                pb.func('normalDistributionFunction_TrowbridgeReitzGGX', [
                    pb.float('NoH'),
                    pb.float('alphaG')
                ], function() {
                    this.$l.a2 = pb.mul(this.alphaG, this.alphaG);
                    this.$l.d = pb.add(pb.mul(this.NoH, this.NoH, pb.sub(this.a2, 1)), 1);
                    this.$return(pb.div(this.a2, pb.mul(this.d, this.d, Math.PI)));
                });
                pb.func('radiance', [
                    pb.float('alphaG'),
                    pb.vec3('direction'),
                    pb.vec2('vFilteringInfo')
                ], function() {
                    this.$l.n = pb.normalize(this.direction);
                    this.$if(pb.equal(this.alphaG, 0), function() {
                        this.$l.c = pb.textureSampleLevel(this.inputTexture, this.n, 0).rgb;
                        this.$return(this.c);
                    }).$else(function() {
                        this.$l.result = pb.vec3(0);
                        this.$l.tangent = pb.vec3();
                        this.$if(pb.lessThan(pb.abs(this.n.z), 0.999), function() {
                            this.tangent = pb.vec3(0, 0, 1);
                        }).$else(function() {
                            this.tangent = pb.vec3(1, 0, 0);
                        });
                        this.tangent = pb.normalize(pb.cross(this.tangent, this.n));
                        this.$l.bitangent = pb.cross(this.n, this.tangent);
                        this.$l.tbn = pb.mat3(this.tangent, this.bitangent, this.n);
                        this.$l.maxLevel = this.vFilteringInfo.y;
                        this.$l.dim0 = this.vFilteringInfo.x;
                        this.$l.omegaP = pb.div(4 * Math.PI, pb.mul(this.dim0, this.dim0, 6));
                        this.$l.weight = pb.float(0);
                        this.$for(pb.int('i'), 0, numSamples, function() {
                            this.$l.Xi = this.hammersley2d(this.i, numSamples);
                            this.$l.H = this.hemisphereImportanceSampleDggx(this.Xi, this.alphaG);
                            this.$l.NoV = pb.float(1);
                            this.$l.NoH = this.H.z;
                            this.$l.NoH2 = pb.mul(this.H.z, this.H.z);
                            this.$l.NoL = pb.sub(pb.mul(this.NoH2, 2), 1);
                            this.$l.L = pb.normalize(pb.vec3(pb.mul(this.NoH, this.H.x, 2), pb.mul(this.NoH, this.H.y, 2), this.NoL));
                            this.$if(pb.greaterThan(this.NoL, 0), function() {
                                this.$l.pdf_inversed = pb.div(4, this.normalDistributionFunction_TrowbridgeReitzGGX(this.NoH, this.alphaG));
                                this.$l.omegaS = pb.mul(this.pdf_inversed, this.NUM_SAMPLES_FLOAT_INVERSED);
                                this.$l.l = pb.add(pb.sub(this.log4(this.omegaS), this.log4(this.omegaP)), this.log4(this.K));
                                this.$l.mipLevel = pb.clamp(this.l, 0, this.maxLevel);
                                this.weight = pb.add(this.weight, this.NoL);
                                this.$l.c = pb.textureSampleLevel(this.inputTexture, pb.mul(this.tbn, this.L), this.mipLevel).rgb;
                                this.result = pb.add(this.result, pb.mul(this.c, this.NoL));
                            });
                        });
                        this.result = pb.div(this.result, this.weight);
                        this.$return(this.result);
                    });
                });
            }
            pb.main(function() {
                if (type === 'ggx') {
                    this.$l.color = this.radiance(this.alphaG, this.$inputs.direction, this.vFilteringInfo);
                }
                if (type === 'lambertian') {
                    this.$l.color = this.irradiance(this.$inputs.direction, this.vFilteringInfo);
                }
                this.$outputs.outcolor = pb.vec4(pb.mul(this.color, this.hdrScale), 1);
            });
        }
    });
}
function doPrefilterCubemap(type, roughness, miplevel, srcTexture, dstTexture, filteringInfo, numSamples) {
    const device = Application.instance.device;
    const framebuffer = device.createFrameBuffer([
        dstTexture
    ], null);
    framebuffer.setColorAttachmentMipLevel(0, miplevel);
    framebuffer.setColorAttachmentGenerateMipmaps(0, false);
    const { program, bindgroup } = getProgramInfo(type, numSamples);
    bindgroup.setValue('vFilteringInfo', filteringInfo);
    bindgroup.setValue('hdrScale', 1);
    bindgroup.setTexture('inputTexture', srcTexture);
    if (type === 'ggx') {
        bindgroup.setValue('alphaG', roughness);
    }
    device.setProgram(program);
    device.setBindGroup(0, bindgroup);
    device.setFramebuffer(framebuffer);
    for(let i = 0; i < 6; i++){
        framebuffer.setColorAttachmentCubeFace(0, i);
        device.setVertexLayout(vertexLayout);
        device.setRenderStates(renderStates);
        bindgroup.setValue('up', faceDirections[i][0]);
        bindgroup.setValue('right', faceDirections[i][1]);
        bindgroup.setValue('front', faceDirections[i][2]);
        device.draw('triangle-list', 0, 6);
    }
}
/**
 * Prefilters an environment cubemap
 *
 * @param tex - The environment cubemap
 * @param type - The prefilter type
 * @param destTex - The output cubemap
 *
 * @public
 */ function prefilterCubemap(tex, type, destTex, numSamples) {
    if (!tex || !tex.isTextureCube()) {
        console.error('prefilterCubemap(): source texture must be cube texture');
        return;
    }
    const device = Application.instance.device;
    if (!vertexLayout) {
        init();
    }
    device.pushDeviceStates();
    const rs = device.getRenderStates();
    const srcTex = tex;
    const width = tex.width;
    const mipmapsCount = tex.mipLevelCount;
    const filteringInfo = new Vector2(width, mipmapsCount);
    const mips = type === 'ggx' ? destTex.mipLevelCount : 1;
    for(let i = 0; i < mips; i++){
        const alpha = i === 0 ? 0 : Math.pow(2, i) / width;
        doPrefilterCubemap(type, alpha, i, srcTex, destTex, filteringInfo, numSamples ?? 64);
    }
    device.popDeviceStates();
    device.setRenderStates(rs);
}

const RED_SHIFT = 0;
const GREEN_SHIFT = 1;
const BLUE_SHIFT = 2;
const ALPHA_SHIFT = 3;
const DEPTH_SHIFT = 4;
const STENCIL_SHIFT = 5;
const FLOAT_SHIFT = 6;
const INTEGER_SHIFT = 7;
const SIGNED_SHIFT = 8;
const SRGB_SHIFT = 9;
const BGR_SHIFT = 10;
const BLOCK_SIZE_SHIFT = 11;
const BLOCK_SIZE_MASK = 0x1f << BLOCK_SIZE_SHIFT;
const BLOCK_WIDTH_SHIFT = 16;
const BLOCK_WIDTH_MASK = 0xf << BLOCK_WIDTH_SHIFT;
const BLOCK_HEIGHT_SHIFT = 20;
const BLOCK_HEIGHT_MASK = 0xf << BLOCK_HEIGHT_SHIFT;
const COMPRESSED_FORMAT_SHIFT = 24;
const COMPRESSION_FORMAT_BC1 = 1 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC2 = 2 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC3 = 3 << COMPRESSED_FORMAT_SHIFT;
/*
const COMPRESSION_FORMAT_BC4 = 4 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC5 = 5 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC6 = 6 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC7 = 7 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGB8 = 8 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGB8_A1 = 9 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGBA8 = 10 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_4x4 = 11 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_5x4 = 12 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_5x5 = 13 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_6x5 = 14 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_6x6 = 15 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x5 = 16 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x6 = 17 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x8 = 18 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x5 = 19 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x6 = 20 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x8 = 21 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x10 = 22 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_12x10 = 23 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_12x12 = 24 << COMPRESSED_FORMAT_SHIFT;
*/ const COMPRESSION_FORMAT_BITMASK = 0x1f << COMPRESSED_FORMAT_SHIFT;
const RED_BITMASK = 1 << RED_SHIFT;
const GREEN_BITMASK = 1 << GREEN_SHIFT;
const BLUE_BITMASK = 1 << BLUE_SHIFT;
const ALPHA_BITMASK = 1 << ALPHA_SHIFT;
const DEPTH_BITMASK = 1 << DEPTH_SHIFT;
const STENCIL_BITMASK = 1 << STENCIL_SHIFT;
const FLOAT_BITMASK = 1 << FLOAT_SHIFT;
const INTEGER_BITMASK = 1 << INTEGER_SHIFT;
const SIGNED_BITMASK = 1 << SIGNED_SHIFT;
const SRGB_BITMASK = 1 << SRGB_SHIFT;
const BGR_BITMASK = 1 << BGR_SHIFT;
function makeTextureFormat(compression, r, g, b, a, depth, stencil, float, integer, signed, srgb, bgr, blockWidth, blockHeight, blockSize) {
    const compressionBits = compression;
    const colorBits = (r ? RED_BITMASK : 0) | (g ? GREEN_BITMASK : 0) | (b ? BLUE_BITMASK : 0) | (a ? ALPHA_BITMASK : 0);
    const depthStencilBits = (depth ? DEPTH_BITMASK : 0) | (stencil ? STENCIL_BITMASK : 0);
    const floatBits = float ? FLOAT_BITMASK : 0;
    const integerBits = integer ? INTEGER_BITMASK : 0;
    const signedBits = signed ? SIGNED_BITMASK : 0;
    const srgbBits = srgb ? SRGB_BITMASK : 0;
    const bgrBits = bgr ? BGR_BITMASK : 0;
    const blockBits = blockWidth << BLOCK_WIDTH_SHIFT | blockHeight << BLOCK_HEIGHT_SHIFT | blockSize << BLOCK_SIZE_SHIFT;
    return compressionBits | colorBits | depthStencilBits | floatBits | integerBits | signedBits | srgbBits | bgrBits | blockBits;
}
const textureFormatMap$1 = {
    unknown: 0,
    r8unorm: makeTextureFormat(0, true, false, false, false, false, false, false, false, false, false, false, 1, 1, 1),
    r8snorm: makeTextureFormat(0, true, false, false, false, false, false, false, false, true, false, false, 1, 1, 1),
    r16f: makeTextureFormat(0, true, false, false, false, false, false, true, false, true, false, false, 1, 1, 2),
    r32f: makeTextureFormat(0, true, false, false, false, false, false, true, false, true, false, false, 1, 1, 4),
    r8ui: makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 1),
    r8i: makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 1),
    r16ui: makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 2),
    r16i: makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 2),
    r32ui: makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 4),
    r32i: makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 4),
    rg8unorm: makeTextureFormat(0, true, true, false, false, false, false, false, false, false, false, false, 1, 1, 2),
    rg8snorm: makeTextureFormat(0, true, true, false, false, false, false, false, false, true, false, false, 1, 1, 2),
    rg16f: makeTextureFormat(0, true, true, false, false, false, false, true, false, true, false, false, 1, 1, 4),
    rg32f: makeTextureFormat(0, true, true, false, false, false, false, true, false, true, false, false, 1, 1, 8),
    rg8ui: makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 2),
    rg8i: makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 2),
    rg16ui: makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 4),
    rg16i: makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 4),
    rg32ui: makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 8),
    rg32i: makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 8),
    rgba8unorm: makeTextureFormat(0, true, true, true, true, false, false, false, false, false, false, false, 1, 1, 4),
    'rgba8unorm-srgb': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, true, false, 1, 1, 4),
    rgba8snorm: makeTextureFormat(0, true, true, true, true, false, false, false, false, true, false, false, 1, 1, 4),
    bgra8unorm: makeTextureFormat(0, true, true, true, true, false, false, false, false, false, false, true, 1, 1, 4),
    'bgra8unorm-srgb': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, true, true, 1, 1, 4),
    rgba16f: makeTextureFormat(0, true, true, true, true, false, false, true, false, true, false, false, 1, 1, 8),
    rgba32f: makeTextureFormat(0, true, true, true, true, false, false, true, false, true, false, false, 1, 1, 16),
    rgba8ui: makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 4),
    rgba8i: makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 4),
    rgba16ui: makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 8),
    rgba16i: makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 8),
    rgba32ui: makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 16),
    rgba32i: makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 16),
    rg11b10uf: makeTextureFormat(0, true, true, true, false, false, false, true, false, false, false, false, 1, 1, 4),
    d16: makeTextureFormat(0, false, false, false, false, true, false, false, false, false, false, false, 1, 1, 2),
    d24: makeTextureFormat(0, false, false, false, false, true, false, false, false, false, false, false, 0, 0, 0),
    d32f: makeTextureFormat(0, false, false, false, false, true, false, true, false, true, false, false, 1, 1, 4),
    d24s8: makeTextureFormat(0, false, false, false, false, true, true, false, false, false, false, false, 1, 1, 4),
    d32fs8: makeTextureFormat(0, false, false, false, false, true, true, true, false, true, false, false, 1, 1, 5),
    // compressed texture formats
    dxt1: makeTextureFormat(COMPRESSION_FORMAT_BC1, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 8),
    'dxt1-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC1, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 8),
    dxt3: makeTextureFormat(COMPRESSION_FORMAT_BC2, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 16),
    'dxt3-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC2, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 16),
    dxt5: makeTextureFormat(COMPRESSION_FORMAT_BC3, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 16),
    'dxt5-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC3, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 16)
};
/**
 * Converts a non-sRGB texture format to the corresponding sRGB texture format
 * @param format - The texture format to be converted
 * @returns The sRGB texture format
 * @public
 */ function linearTextureFormatToSRGB(format) {
    switch(format){
        case 'rgba8unorm':
            return 'rgba8unorm-srgb';
        case 'bgra8unorm':
            return 'bgra8unorm-srgb';
        case 'dxt1':
            return 'dxt1-srgb';
        case 'dxt3':
            return 'dxt3-srgb';
        case 'dxt5':
            return 'dxt5-srgb';
        default:
            return format;
    }
}
/**
 * Check if a given texture format contains an alpha channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains an alpha channel, otherwise false
 * @public
 */ function hasAlphaChannel(format) {
    return !!(textureFormatMap$1[format] & ALPHA_BITMASK);
}
/**
 * Check if a given texture format contains a red channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a red channel, otherwise false
 * @public
 */ function hasRedChannel(format) {
    return !!(textureFormatMap$1[format] & RED_BITMASK);
}
/**
 * Check if a given texture format contains a green channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a green channel, otherwise false
 * @public
 */ function hasGreenChannel(format) {
    return !!(textureFormatMap$1[format] & GREEN_BITMASK);
}
/**
 * Check if a given texture format contains a blue channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a blue channel, otherwise false
 * @public
 */ function hasBlueChannel(format) {
    return !!(textureFormatMap$1[format] & BLUE_BITMASK);
}
/**
 * Check if a given texture format contains a depth channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a depth channel, otherwise false
 * @public
 */ function hasDepthChannel(format) {
    return !!(textureFormatMap$1[format] & DEPTH_BITMASK);
}
/**
 * Check if a given texture format contains a stencil channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a stencil channel, otherwise false
 * @public
 */ function hasStencilChannel(format) {
    return !!(textureFormatMap$1[format] & STENCIL_BITMASK);
}
/**
 * Check whether a given texture format is floating-point.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is floating-point, otherwise false
 * @public
 */ function isFloatTextureFormat(format) {
    return !!(textureFormatMap$1[format] & FLOAT_BITMASK);
}
/**
 * Check whether a given texture format is integer.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is integer, otherwise false
 * @public
 */ function isIntegerTextureFormat(format) {
    return !!(textureFormatMap$1[format] & INTEGER_BITMASK);
}
/**
 * Check whether a given texture format is signed.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is signed, otherwise false
 * @public
 */ function isSignedTextureFormat(format) {
    return !!(textureFormatMap$1[format] & SIGNED_BITMASK);
}
/**
 * Check whether a given texture format is a compressed format.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is a compressed format, otherwise false
 * @public
 */ function isCompressedTextureFormat(format) {
    return !!(textureFormatMap$1[format] & COMPRESSION_FORMAT_BITMASK);
}
/**
 * Check whether a given texture format is sRGB format.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is sRGB format, otherwise false
 * @public
 */ function isSRGBTextureFormat(format) {
    return !!(textureFormatMap$1[format] & SRGB_BITMASK);
}
/**
 * Get block size of given texture format
 * @param format - The texture format
 * @returns The block size
 * @public
 */ function getTextureFormatBlockSize(format) {
    return (textureFormatMap$1[format] & BLOCK_SIZE_MASK) >> BLOCK_SIZE_SHIFT;
}
/**
 * Get block width of given texture format
 * @param format - The texture format
 * @returns The block width
 * @public
 */ function getTextureFormatBlockWidth(format) {
    return (textureFormatMap$1[format] & BLOCK_WIDTH_MASK) >> BLOCK_WIDTH_SHIFT;
}
/**
 * Get block height of given texture format
 * @param format - The texture format
 * @returns The block height
 * @public
 */ function getTextureFormatBlockHeight(format) {
    return (textureFormatMap$1[format] & BLOCK_HEIGHT_MASK) >> BLOCK_HEIGHT_SHIFT;
}
var ShaderType;
(function(ShaderType) {
    ShaderType[ShaderType["Vertex"] = 1] = "Vertex";
    ShaderType[ShaderType["Fragment"] = 2] = "Fragment";
    ShaderType[ShaderType["Compute"] = 4] = "Compute";
})(ShaderType || (ShaderType = {}));
/**
 * Event that will be fired when device is lost
 * @public
 */ class DeviceLostEvent {
    /** The event name */ static NAME = 'devicelost';
    type = DeviceLostEvent.NAME;
}
/**
 * Event that will be fired when device has just been restored
 * @public
 */ class DeviceRestoreEvent {
    /** The event name */ static NAME = 'devicerestored';
    type = DeviceRestoreEvent.NAME;
}
/**
 * Event that will be fired when size of back buffer has changed
 * @public
 */ class DeviceResizeEvent {
    /** The event name */ static NAME = 'resize';
    width;
    height;
    type = DeviceResizeEvent.NAME;
    constructor(width, height){
        this.width = width;
        this.height = height;
    }
}
/**
 * Event that will be fired when any gpu object is created
 * @public
 */ class DeviceGPUObjectAddedEvent {
    /** the event name */ static NAME = 'gpuobject_added';
    object;
    type = DeviceGPUObjectAddedEvent.NAME;
    constructor(obj){
        this.object = obj;
    }
}
/**
 * Event that will be fired when any gpu object is disposed
 * @public
 */ class DeviceGPUObjectRemovedEvent {
    /** The event name */ static NAME = 'gpuobject_removed';
    object;
    type = DeviceGPUObjectRemovedEvent.NAME;
    constructor(obj){
        this.object = obj;
    }
}
/**
 * Event that will be fired when any gpu object name is changed
 * @public
 */ class DeviceGPUObjectRenameEvent {
    /** The event name */ static NAME = 'gpuobject_rename';
    object;
    lastName;
    type = DeviceGPUObjectRenameEvent.NAME;
    constructor(obj, lastName){
        this.object = obj;
        this.lastName = lastName;
    }
}

const F16_BITMASK = 1;
const F32_BITMASK = 2;
const BOOL_BITMASK = 3;
const I8_BITMASK = 4;
const I16_BITMASK = 5;
const I32_BITMASK = 6;
const U8_BITMASK = 7;
const U16_BITMASK = 8;
const U32_BITMASK = 9;
const SCALAR_TYPE_BITMASK = 15;
const ROWS_BITMASK = 7;
const ROWS_BITSHIFT = 4;
const COLS_BITMASK = 7;
const COLS_BITSHIFT = 7;
const NORM_BITMASK = 1;
const NORM_BITSHIFT = 10;
function align(n, alignment) {
    return n + alignment - 1 & ~(alignment - 1);
}
function getAlignment(type) {
    if (type.isPrimitiveType()) {
        return type.isScalarType() ? 4 : 1 << Math.min(4, type.cols + 1);
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 1 : getAlignment(type.elementType);
    } else {
        let alignment = 0;
        for (const member of type.structMembers){
            alignment = Math.max(alignment, getAlignment(member.type));
        }
        return Math.max(alignment, 16);
    }
}
function getAlignmentPacked(type) {
    return 1;
}
function getSize(type) {
    if (type.isPrimitiveType()) {
        return type.isMatrixType() ? type.rows * getAlignment(PBPrimitiveTypeInfo.getCachedTypeInfo(type.resizeType(1, type.cols))) : 4 * type.cols;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 0 : type.dimension * align(getSize(type.elementType), getAlignment(type.elementType));
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else {
        let size = 0;
        let structAlignment = 0;
        for (const member of type.structMembers){
            const memberAlignment = getAlignment(member.type);
            size = align(size, memberAlignment);
            size += getSize(member.type);
            structAlignment = Math.max(structAlignment, memberAlignment);
        }
        return align(size, structAlignment);
    }
}
function getSizePacked(type) {
    if (type.isPrimitiveType()) {
        let scalarSize;
        switch(type.scalarType){
            case PBPrimitiveType.U8:
            case PBPrimitiveType.U8_NORM:
            case PBPrimitiveType.I8:
            case PBPrimitiveType.I8_NORM:
                scalarSize = 1;
                break;
            case PBPrimitiveType.F16:
            case PBPrimitiveType.I16:
            case PBPrimitiveType.I16_NORM:
            case PBPrimitiveType.U16:
            case PBPrimitiveType.U16_NORM:
                scalarSize = 2;
                break;
            default:
                scalarSize = 4;
                break;
        }
        return type.rows * type.cols * scalarSize;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 0 : type.dimension * getSizePacked(type.elementType);
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else {
        let size = 0;
        for (const member of type.structMembers){
            size += getSizePacked(member.type);
        }
        return size;
    }
}
function makePrimitiveType(scalarTypeMask, rows, cols, norm) {
    return scalarTypeMask | rows << ROWS_BITSHIFT | cols << COLS_BITSHIFT | norm << NORM_BITSHIFT;
}
function typeToTypedArray(type) {
    if (type.isPrimitiveType()) {
        return type.scalarType;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? null : typeToTypedArray(type.elementType);
    } else {
        return PBPrimitiveType.U8;
    }
}
var PBPrimitiveType;
(function(PBPrimitiveType) {
    PBPrimitiveType[PBPrimitiveType["NONE"] = 0] = "NONE";
    PBPrimitiveType[PBPrimitiveType["F16"] = makePrimitiveType(F16_BITMASK, 1, 1, 0)] = "F16";
    PBPrimitiveType[PBPrimitiveType["F16VEC2"] = makePrimitiveType(F16_BITMASK, 1, 2, 0)] = "F16VEC2";
    PBPrimitiveType[PBPrimitiveType["F16VEC3"] = makePrimitiveType(F16_BITMASK, 1, 3, 0)] = "F16VEC3";
    PBPrimitiveType[PBPrimitiveType["F16VEC4"] = makePrimitiveType(F16_BITMASK, 1, 4, 0)] = "F16VEC4";
    PBPrimitiveType[PBPrimitiveType["F32"] = makePrimitiveType(F32_BITMASK, 1, 1, 0)] = "F32";
    PBPrimitiveType[PBPrimitiveType["F32VEC2"] = makePrimitiveType(F32_BITMASK, 1, 2, 0)] = "F32VEC2";
    PBPrimitiveType[PBPrimitiveType["F32VEC3"] = makePrimitiveType(F32_BITMASK, 1, 3, 0)] = "F32VEC3";
    PBPrimitiveType[PBPrimitiveType["F32VEC4"] = makePrimitiveType(F32_BITMASK, 1, 4, 0)] = "F32VEC4";
    PBPrimitiveType[PBPrimitiveType["BOOL"] = makePrimitiveType(BOOL_BITMASK, 1, 1, 0)] = "BOOL";
    PBPrimitiveType[PBPrimitiveType["BVEC2"] = makePrimitiveType(BOOL_BITMASK, 1, 2, 0)] = "BVEC2";
    PBPrimitiveType[PBPrimitiveType["BVEC3"] = makePrimitiveType(BOOL_BITMASK, 1, 3, 0)] = "BVEC3";
    PBPrimitiveType[PBPrimitiveType["BVEC4"] = makePrimitiveType(BOOL_BITMASK, 1, 4, 0)] = "BVEC4";
    PBPrimitiveType[PBPrimitiveType["I8"] = makePrimitiveType(I8_BITMASK, 1, 1, 0)] = "I8";
    PBPrimitiveType[PBPrimitiveType["I8VEC2"] = makePrimitiveType(I8_BITMASK, 1, 2, 0)] = "I8VEC2";
    PBPrimitiveType[PBPrimitiveType["I8VEC3"] = makePrimitiveType(I8_BITMASK, 1, 3, 0)] = "I8VEC3";
    PBPrimitiveType[PBPrimitiveType["I8VEC4"] = makePrimitiveType(I8_BITMASK, 1, 4, 0)] = "I8VEC4";
    PBPrimitiveType[PBPrimitiveType["I8_NORM"] = makePrimitiveType(I8_BITMASK, 1, 1, 1)] = "I8_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC2_NORM"] = makePrimitiveType(I8_BITMASK, 1, 2, 1)] = "I8VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC3_NORM"] = makePrimitiveType(I8_BITMASK, 1, 3, 1)] = "I8VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC4_NORM"] = makePrimitiveType(I8_BITMASK, 1, 4, 1)] = "I8VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["I16"] = makePrimitiveType(I16_BITMASK, 1, 1, 0)] = "I16";
    PBPrimitiveType[PBPrimitiveType["I16VEC2"] = makePrimitiveType(I16_BITMASK, 1, 2, 0)] = "I16VEC2";
    PBPrimitiveType[PBPrimitiveType["I16VEC3"] = makePrimitiveType(I16_BITMASK, 1, 3, 0)] = "I16VEC3";
    PBPrimitiveType[PBPrimitiveType["I16VEC4"] = makePrimitiveType(I16_BITMASK, 1, 4, 0)] = "I16VEC4";
    PBPrimitiveType[PBPrimitiveType["I16_NORM"] = makePrimitiveType(I16_BITMASK, 1, 1, 1)] = "I16_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC2_NORM"] = makePrimitiveType(I16_BITMASK, 1, 2, 1)] = "I16VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC3_NORM"] = makePrimitiveType(I16_BITMASK, 1, 3, 1)] = "I16VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC4_NORM"] = makePrimitiveType(I16_BITMASK, 1, 4, 1)] = "I16VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["I32"] = makePrimitiveType(I32_BITMASK, 1, 1, 0)] = "I32";
    PBPrimitiveType[PBPrimitiveType["I32VEC2"] = makePrimitiveType(I32_BITMASK, 1, 2, 0)] = "I32VEC2";
    PBPrimitiveType[PBPrimitiveType["I32VEC3"] = makePrimitiveType(I32_BITMASK, 1, 3, 0)] = "I32VEC3";
    PBPrimitiveType[PBPrimitiveType["I32VEC4"] = makePrimitiveType(I32_BITMASK, 1, 4, 0)] = "I32VEC4";
    PBPrimitiveType[PBPrimitiveType["I32_NORM"] = makePrimitiveType(I32_BITMASK, 1, 1, 1)] = "I32_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC2_NORM"] = makePrimitiveType(I32_BITMASK, 1, 2, 1)] = "I32VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC3_NORM"] = makePrimitiveType(I32_BITMASK, 1, 3, 1)] = "I32VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC4_NORM"] = makePrimitiveType(I32_BITMASK, 1, 4, 1)] = "I32VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U8"] = makePrimitiveType(U8_BITMASK, 1, 1, 0)] = "U8";
    PBPrimitiveType[PBPrimitiveType["U8VEC2"] = makePrimitiveType(U8_BITMASK, 1, 2, 0)] = "U8VEC2";
    PBPrimitiveType[PBPrimitiveType["U8VEC3"] = makePrimitiveType(U8_BITMASK, 1, 3, 0)] = "U8VEC3";
    PBPrimitiveType[PBPrimitiveType["U8VEC4"] = makePrimitiveType(U8_BITMASK, 1, 4, 0)] = "U8VEC4";
    PBPrimitiveType[PBPrimitiveType["U8_NORM"] = makePrimitiveType(U8_BITMASK, 1, 1, 1)] = "U8_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC2_NORM"] = makePrimitiveType(U8_BITMASK, 1, 2, 1)] = "U8VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC3_NORM"] = makePrimitiveType(U8_BITMASK, 1, 3, 1)] = "U8VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC4_NORM"] = makePrimitiveType(U8_BITMASK, 1, 4, 1)] = "U8VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U16"] = makePrimitiveType(U16_BITMASK, 1, 1, 0)] = "U16";
    PBPrimitiveType[PBPrimitiveType["U16VEC2"] = makePrimitiveType(U16_BITMASK, 1, 2, 0)] = "U16VEC2";
    PBPrimitiveType[PBPrimitiveType["U16VEC3"] = makePrimitiveType(U16_BITMASK, 1, 3, 0)] = "U16VEC3";
    PBPrimitiveType[PBPrimitiveType["U16VEC4"] = makePrimitiveType(U16_BITMASK, 1, 4, 0)] = "U16VEC4";
    PBPrimitiveType[PBPrimitiveType["U16_NORM"] = makePrimitiveType(U16_BITMASK, 1, 1, 1)] = "U16_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC2_NORM"] = makePrimitiveType(U16_BITMASK, 1, 2, 1)] = "U16VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC3_NORM"] = makePrimitiveType(U16_BITMASK, 1, 3, 1)] = "U16VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC4_NORM"] = makePrimitiveType(U16_BITMASK, 1, 4, 1)] = "U16VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U32"] = makePrimitiveType(U32_BITMASK, 1, 1, 0)] = "U32";
    PBPrimitiveType[PBPrimitiveType["U32VEC2"] = makePrimitiveType(U32_BITMASK, 1, 2, 0)] = "U32VEC2";
    PBPrimitiveType[PBPrimitiveType["U32VEC3"] = makePrimitiveType(U32_BITMASK, 1, 3, 0)] = "U32VEC3";
    PBPrimitiveType[PBPrimitiveType["U32VEC4"] = makePrimitiveType(U32_BITMASK, 1, 4, 0)] = "U32VEC4";
    PBPrimitiveType[PBPrimitiveType["U32_NORM"] = makePrimitiveType(U32_BITMASK, 1, 1, 1)] = "U32_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC2_NORM"] = makePrimitiveType(U32_BITMASK, 1, 2, 1)] = "U32VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC3_NORM"] = makePrimitiveType(U32_BITMASK, 1, 3, 1)] = "U32VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC4_NORM"] = makePrimitiveType(U32_BITMASK, 1, 4, 1)] = "U32VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["MAT2"] = makePrimitiveType(F32_BITMASK, 2, 2, 0)] = "MAT2";
    PBPrimitiveType[PBPrimitiveType["MAT2x3"] = makePrimitiveType(F32_BITMASK, 2, 3, 0)] = "MAT2x3";
    PBPrimitiveType[PBPrimitiveType["MAT2x4"] = makePrimitiveType(F32_BITMASK, 2, 4, 0)] = "MAT2x4";
    PBPrimitiveType[PBPrimitiveType["MAT3x2"] = makePrimitiveType(F32_BITMASK, 3, 2, 0)] = "MAT3x2";
    PBPrimitiveType[PBPrimitiveType["MAT3"] = makePrimitiveType(F32_BITMASK, 3, 3, 0)] = "MAT3";
    PBPrimitiveType[PBPrimitiveType["MAT3x4"] = makePrimitiveType(F32_BITMASK, 3, 4, 0)] = "MAT3x4";
    PBPrimitiveType[PBPrimitiveType["MAT4x2"] = makePrimitiveType(F32_BITMASK, 4, 2, 0)] = "MAT4x2";
    PBPrimitiveType[PBPrimitiveType["MAT4x3"] = makePrimitiveType(F32_BITMASK, 4, 3, 0)] = "MAT4x3";
    PBPrimitiveType[PBPrimitiveType["MAT4"] = makePrimitiveType(F32_BITMASK, 4, 4, 0)] = "MAT4";
})(PBPrimitiveType || (PBPrimitiveType = {}));
const primitiveTypeMapWebGL = {
    [PBPrimitiveType.F32]: 'float',
    [PBPrimitiveType.F32VEC2]: 'vec2',
    [PBPrimitiveType.F32VEC3]: 'vec3',
    [PBPrimitiveType.F32VEC4]: 'vec4',
    [PBPrimitiveType.BOOL]: 'bool',
    [PBPrimitiveType.BVEC2]: 'bvec2',
    [PBPrimitiveType.BVEC3]: 'bvec3',
    [PBPrimitiveType.BVEC4]: 'bvec4',
    [PBPrimitiveType.I32]: 'int',
    [PBPrimitiveType.I32VEC2]: 'ivec2',
    [PBPrimitiveType.I32VEC3]: 'ivec3',
    [PBPrimitiveType.I32VEC4]: 'ivec4',
    [PBPrimitiveType.U32]: 'uint',
    [PBPrimitiveType.U32VEC2]: 'uvec2',
    [PBPrimitiveType.U32VEC3]: 'uvec3',
    [PBPrimitiveType.U32VEC4]: 'uvec4',
    [PBPrimitiveType.MAT2]: 'mat2',
    [PBPrimitiveType.MAT2x3]: 'mat2x3',
    [PBPrimitiveType.MAT2x4]: 'mat2x4',
    [PBPrimitiveType.MAT3x2]: 'mat3x2',
    [PBPrimitiveType.MAT3]: 'mat3',
    [PBPrimitiveType.MAT3x4]: 'mat3x4',
    [PBPrimitiveType.MAT4x2]: 'mat4x2',
    [PBPrimitiveType.MAT4x3]: 'mat4x3',
    [PBPrimitiveType.MAT4]: 'mat4'
};
const primitiveTypeMapWGSL = {
    [PBPrimitiveType.F32]: 'f32',
    [PBPrimitiveType.F32VEC2]: 'vec2<f32>',
    [PBPrimitiveType.F32VEC3]: 'vec3<f32>',
    [PBPrimitiveType.F32VEC4]: 'vec4<f32>',
    [PBPrimitiveType.BOOL]: 'bool',
    [PBPrimitiveType.BVEC2]: 'vec2<bool>',
    [PBPrimitiveType.BVEC3]: 'vec3<bool>',
    [PBPrimitiveType.BVEC4]: 'vec4<bool>',
    [PBPrimitiveType.I32]: 'i32',
    [PBPrimitiveType.I32VEC2]: 'vec2<i32>',
    [PBPrimitiveType.I32VEC3]: 'vec3<i32>',
    [PBPrimitiveType.I32VEC4]: 'vec4<i32>',
    [PBPrimitiveType.U32]: 'u32',
    [PBPrimitiveType.U32VEC2]: 'vec2<u32>',
    [PBPrimitiveType.U32VEC3]: 'vec3<u32>',
    [PBPrimitiveType.U32VEC4]: 'vec4<u32>',
    [PBPrimitiveType.MAT2]: 'mat2x2<f32>',
    [PBPrimitiveType.MAT2x3]: 'mat2x3<f32>',
    [PBPrimitiveType.MAT2x4]: 'mat2x4<f32>',
    [PBPrimitiveType.MAT3x2]: 'mat3x2<f32>',
    [PBPrimitiveType.MAT3]: 'mat3x3<f32>',
    [PBPrimitiveType.MAT3x4]: 'mat3x4<f32>',
    [PBPrimitiveType.MAT4x2]: 'mat4x2<f32>',
    [PBPrimitiveType.MAT4x3]: 'mat4x3<f32>',
    [PBPrimitiveType.MAT4]: 'mat4x4<f32>'
};
const BITFLAG_1D = 1 << 0;
const BITFLAG_2D = 1 << 1;
const BITFLAG_3D = 1 << 2;
const BITFLAG_CUBE = 1 << 3;
const BITFLAG_ARRAY = 1 << 4;
const BITFLAG_MULTISAMPLED = 1 << 5;
const BITFLAG_STORAGE = 1 << 6;
const BITFLAG_DEPTH = 1 << 7;
const BITFLAG_FLOAT = 1 << 8;
const BITFLAG_INT = 1 << 9;
const BITFLAG_UINT = 1 << 10;
const BITFLAG_EXTERNAL = 1 << 11;
var PBTextureType;
(function(PBTextureType) {
    PBTextureType[PBTextureType["TEX_1D"] = BITFLAG_1D | BITFLAG_FLOAT] = "TEX_1D";
    PBTextureType[PBTextureType["ITEX_1D"] = BITFLAG_1D | BITFLAG_INT] = "ITEX_1D";
    PBTextureType[PBTextureType["UTEX_1D"] = BITFLAG_1D | BITFLAG_UINT] = "UTEX_1D";
    PBTextureType[PBTextureType["TEX_2D"] = BITFLAG_2D | BITFLAG_FLOAT] = "TEX_2D";
    PBTextureType[PBTextureType["ITEX_2D"] = BITFLAG_2D | BITFLAG_INT] = "ITEX_2D";
    PBTextureType[PBTextureType["UTEX_2D"] = BITFLAG_2D | BITFLAG_UINT] = "UTEX_2D";
    PBTextureType[PBTextureType["TEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_FLOAT | BITFLAG_ARRAY] = "TEX_2D_ARRAY";
    PBTextureType[PBTextureType["ITEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_INT | BITFLAG_ARRAY] = "ITEX_2D_ARRAY";
    PBTextureType[PBTextureType["UTEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_UINT | BITFLAG_ARRAY] = "UTEX_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_3D"] = BITFLAG_3D | BITFLAG_FLOAT] = "TEX_3D";
    PBTextureType[PBTextureType["ITEX_3D"] = BITFLAG_3D | BITFLAG_INT] = "ITEX_3D";
    PBTextureType[PBTextureType["UTEX_3D"] = BITFLAG_3D | BITFLAG_UINT] = "UTEX_3D";
    PBTextureType[PBTextureType["TEX_CUBE"] = BITFLAG_CUBE | BITFLAG_FLOAT] = "TEX_CUBE";
    PBTextureType[PBTextureType["ITEX_CUBE"] = BITFLAG_CUBE | BITFLAG_INT] = "ITEX_CUBE";
    PBTextureType[PBTextureType["UTEX_CUBE"] = BITFLAG_CUBE | BITFLAG_UINT] = "UTEX_CUBE";
    PBTextureType[PBTextureType["TEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_FLOAT | BITFLAG_ARRAY] = "TEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["ITEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_INT | BITFLAG_ARRAY] = "ITEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["UTEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_UINT | BITFLAG_ARRAY] = "UTEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["TEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_FLOAT | BITFLAG_MULTISAMPLED] = "TEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["ITEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_INT | BITFLAG_MULTISAMPLED] = "ITEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["UTEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_UINT | BITFLAG_MULTISAMPLED] = "UTEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["TEX_STORAGE_1D"] = BITFLAG_1D | BITFLAG_STORAGE] = "TEX_STORAGE_1D";
    PBTextureType[PBTextureType["TEX_STORAGE_2D"] = BITFLAG_2D | BITFLAG_STORAGE] = "TEX_STORAGE_2D";
    PBTextureType[PBTextureType["TEX_STORAGE_2D_ARRAY"] = BITFLAG_2D | BITFLAG_ARRAY | BITFLAG_STORAGE] = "TEX_STORAGE_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_STORAGE_3D"] = BITFLAG_3D | BITFLAG_STORAGE] = "TEX_STORAGE_3D";
    PBTextureType[PBTextureType["TEX_DEPTH_2D"] = BITFLAG_2D | BITFLAG_DEPTH] = "TEX_DEPTH_2D";
    PBTextureType[PBTextureType["TEX_DEPTH_2D_ARRAY"] = BITFLAG_2D | BITFLAG_ARRAY | BITFLAG_DEPTH] = "TEX_DEPTH_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_DEPTH_CUBE"] = BITFLAG_CUBE | BITFLAG_DEPTH] = "TEX_DEPTH_CUBE";
    PBTextureType[PBTextureType["TEX_DEPTH_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_ARRAY | BITFLAG_DEPTH] = "TEX_DEPTH_CUBE_ARRAY";
    PBTextureType[PBTextureType["TEX_DEPTH_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_MULTISAMPLED | BITFLAG_DEPTH] = "TEX_DEPTH_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["TEX_EXTERNAL"] = BITFLAG_EXTERNAL] = "TEX_EXTERNAL";
})(PBTextureType || (PBTextureType = {}));
const textureTypeMapWebGL = {
    [PBTextureType.TEX_1D]: 'highp sampler2D',
    [PBTextureType.TEX_2D]: 'highp sampler2D',
    [PBTextureType.TEX_CUBE]: 'highp samplerCube',
    [PBTextureType.TEX_EXTERNAL]: 'highp sampler2D'
};
const textureTypeMapWebGL2 = {
    [PBTextureType.TEX_1D]: 'highp sampler2D',
    [PBTextureType.TEX_2D]: 'highp sampler2D',
    [PBTextureType.ITEX_1D]: 'highp isampler2D',
    [PBTextureType.ITEX_2D]: 'highp isampler2D',
    [PBTextureType.UTEX_1D]: 'highp usampler2D',
    [PBTextureType.UTEX_2D]: 'highp usampler2D',
    [PBTextureType.TEX_2D_ARRAY]: 'highp sampler2DArray',
    [PBTextureType.ITEX_2D_ARRAY]: 'highp isampler2DArray',
    [PBTextureType.UTEX_2D_ARRAY]: 'highp usampler2DArray',
    [PBTextureType.TEX_3D]: 'highp sampler3D',
    [PBTextureType.ITEX_3D]: 'highp isampler3D',
    [PBTextureType.UTEX_3D]: 'highp usampler3D',
    [PBTextureType.TEX_CUBE]: 'highp samplerCube',
    [PBTextureType.ITEX_CUBE]: 'highp isamplerCube',
    [PBTextureType.UTEX_CUBE]: 'highp usamplerCube',
    [PBTextureType.TEX_DEPTH_2D]: 'highp sampler2DShadow',
    [PBTextureType.TEX_DEPTH_2D_ARRAY]: 'highp sampler2DArrayShadow',
    [PBTextureType.TEX_DEPTH_CUBE]: 'highp samplerCubeShadow',
    [PBTextureType.TEX_EXTERNAL]: 'highp sampler2D'
};
const textureTypeMapWGSL = {
    [PBTextureType.TEX_1D]: 'texture_1d<f32>',
    [PBTextureType.ITEX_1D]: 'texture_1d<i32>',
    [PBTextureType.UTEX_1D]: 'texture_1d<u32>',
    [PBTextureType.TEX_2D]: 'texture_2d<f32>',
    [PBTextureType.ITEX_2D]: 'texture_2d<i32>',
    [PBTextureType.UTEX_2D]: 'texture_2d<u32>',
    [PBTextureType.TEX_2D_ARRAY]: 'texture_2d_array<f32>',
    [PBTextureType.ITEX_2D_ARRAY]: 'texture_2d_array<i32>',
    [PBTextureType.UTEX_2D_ARRAY]: 'texture_2d_array<u32>',
    [PBTextureType.TEX_3D]: 'texture_3d<f32>',
    [PBTextureType.ITEX_3D]: 'texture_3d<i32>',
    [PBTextureType.UTEX_3D]: 'texture_3d<u32>',
    [PBTextureType.TEX_CUBE]: 'texture_cube<f32>',
    [PBTextureType.ITEX_CUBE]: 'texture_cube<i32>',
    [PBTextureType.UTEX_CUBE]: 'texture_cube<u32>',
    [PBTextureType.TEX_CUBE_ARRAY]: 'texture_cube_array<f32>',
    [PBTextureType.ITEX_CUBE_ARRAY]: 'texture_cube_array<i32>',
    [PBTextureType.UTEX_CUBE_ARRAY]: 'texture_cube_array<u32>',
    [PBTextureType.TEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<f32>',
    [PBTextureType.ITEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<i32>',
    [PBTextureType.UTEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<u32>',
    [PBTextureType.TEX_STORAGE_1D]: 'texture_storage_1d',
    [PBTextureType.TEX_STORAGE_2D]: 'texture_storage_2d',
    [PBTextureType.TEX_STORAGE_2D_ARRAY]: 'texture_storage_2d_array',
    [PBTextureType.TEX_STORAGE_3D]: 'texture_storage_3d',
    [PBTextureType.TEX_DEPTH_2D]: 'texture_depth_2d',
    [PBTextureType.TEX_DEPTH_2D_ARRAY]: 'texture_depth_2d_array',
    [PBTextureType.TEX_DEPTH_CUBE]: 'texture_depth_cube',
    [PBTextureType.TEX_DEPTH_CUBE_ARRAY]: 'texture_depth_cube_array',
    [PBTextureType.TEX_DEPTH_MULTISAMPLED_2D]: 'texture_depth_multisampled_2d',
    [PBTextureType.TEX_EXTERNAL]: 'texture_external'
};
const storageTexelFormatMap = {
    rgba8unorm: 'rgba8unorm',
    rgba8snorm: 'rgba8snorm',
    bgra8unorm: 'bgra8unorm',
    rgba8ui: 'rgba8uint',
    rgba8i: 'rgba8sint',
    rgba16ui: 'rgba16uint',
    rgba16i: 'rgba16sint',
    rgba16f: 'rgba16float',
    r32f: 'r32float',
    r32ui: 'r32uint',
    r32i: 'r32sint',
    rg32f: 'rg32float',
    rg32ui: 'rg32uint',
    rg32i: 'rg32sint',
    rgba32f: 'rgba32float',
    rgba32ui: 'rgba32uint',
    rgba32i: 'rgba32sint'
};
var PBSamplerAccessMode;
(function(PBSamplerAccessMode) {
    PBSamplerAccessMode[PBSamplerAccessMode["UNKNOWN"] = 0] = "UNKNOWN";
    PBSamplerAccessMode[PBSamplerAccessMode["SAMPLE"] = 1] = "SAMPLE";
    PBSamplerAccessMode[PBSamplerAccessMode["COMPARISON"] = 2] = "COMPARISON";
})(PBSamplerAccessMode || (PBSamplerAccessMode = {}));
var PBAddressSpace;
(function(PBAddressSpace) {
    PBAddressSpace["UNKNOWN"] = 'unknown';
    PBAddressSpace["FUNCTION"] = 'function';
    PBAddressSpace["PRIVATE"] = 'private';
    PBAddressSpace["WORKGROUP"] = 'workgroup';
    PBAddressSpace["UNIFORM"] = 'uniform';
    PBAddressSpace["STORAGE"] = 'storage';
})(PBAddressSpace || (PBAddressSpace = {}));
var PBTypeClass;
(function(PBTypeClass) {
    PBTypeClass[PBTypeClass["UNKNOWN"] = 0] = "UNKNOWN";
    PBTypeClass[PBTypeClass["PLAIN"] = 1] = "PLAIN";
    PBTypeClass[PBTypeClass["ARRAY"] = 2] = "ARRAY";
    PBTypeClass[PBTypeClass["POINTER"] = 3] = "POINTER";
    PBTypeClass[PBTypeClass["ATOMIC_I32"] = 4] = "ATOMIC_I32";
    PBTypeClass[PBTypeClass["ATOMIC_U32"] = 5] = "ATOMIC_U32";
    PBTypeClass[PBTypeClass["TEXTURE"] = 6] = "TEXTURE";
    PBTypeClass[PBTypeClass["SAMPLER"] = 7] = "SAMPLER";
    PBTypeClass[PBTypeClass["FUNCTION"] = 8] = "FUNCTION";
    PBTypeClass[PBTypeClass["VOID"] = 9] = "VOID";
    PBTypeClass[PBTypeClass["ANY"] = 10] = "ANY";
})(PBTypeClass || (PBTypeClass = {}));
/**
 * Abstract base class for any type
 * @public
 */ class PBTypeInfo {
    /** @internal */ cls;
    /** @internal */ detail;
    /** @internal */ id;
    /** @internal */ constructor(cls, detail){
        this.cls = cls;
        this.detail = detail;
        this.id = null;
    }
    /** Get unique id for this type */ get typeId() {
        if (!this.id) {
            this.id = this.genTypeId();
        }
        return this.id;
    }
    /** returns true if this is a void type */ isVoidType() {
        return false;
    }
    /** returns true if this is an any type */ isAnyType() {
        return false;
    }
    /** returns true if this is a primitive type */ isPrimitiveType() {
        return false;
    }
    /** returns true if this is a struct type */ isStructType() {
        return false;
    }
    /** returns true if this is an array type */ isArrayType() {
        return false;
    }
    /** returns true if this is a pointer type */ isPointerType() {
        return false;
    }
    /** returns true if this is an atomic int type */ isAtomicI32() {
        return false;
    }
    /** returns true if this is an atomic uint type */ isAtomicU32() {
        return false;
    }
    /** returns true if this is a sampler type */ isSamplerType() {
        return false;
    }
    /** returns true if this is a texture type */ isTextureType() {
        return false;
    }
    /** @internal */ isHostSharable() {
        return false;
    }
    /** @internal */ isConstructible() {
        return false;
    }
    /** @internal */ isStorable() {
        return false;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        return [];
    }
    /**
   * Check whether a given type is compatible with this type
   * @param other - The type to be checked
   * @returns true if the given type is compatible with this type, othewise false
   */ isCompatibleType(other) {
        return other.typeId === this.typeId;
    }
}
/**
 * The void type info
 * @public
 */ class PBVoidTypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.VOID, null);
    }
    /** {@inheritDoc PBTypeInfo.isVoidType} */ isVoidType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        return 'void';
    }
    /** @internal */ genTypeId() {
        return 'void';
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
}
/**
 * The void type info
 * @public
 */ class PBAnyTypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ANY, null);
    }
    /** {@inheritDoc PBTypeInfo.isAnyType} */ isAnyType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        return 'any';
    }
    /** @internal */ genTypeId() {
        return 'any';
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** {@inheritDoc PBTypeInfo.isCompatibleType} */ isCompatibleType(other) {
        return true;
    }
}
/**
 * The primitive type info
 * @public
 */ class PBPrimitiveTypeInfo extends PBTypeInfo {
    /** @internal */ static cachedTypes = {};
    /** @internal */ static cachedCtorOverloads = {};
    constructor(type){
        super(PBTypeClass.PLAIN, {
            primitiveType: type
        });
    }
    /** Get or create a PBPrimitiveTypeInfo instance for a given prmitive type */ static getCachedTypeInfo(primitiveType) {
        let typeinfo = this.cachedTypes[primitiveType];
        if (!typeinfo) {
            typeinfo = new PBPrimitiveTypeInfo(primitiveType);
            this.cachedTypes[primitiveType] = typeinfo;
        }
        return typeinfo;
    }
    /** @internal */ static getCachedOverloads(deviceType, primitiveType) {
        let deviceOverloads = this.cachedCtorOverloads[deviceType];
        if (!deviceOverloads) {
            deviceOverloads = {};
            this.cachedCtorOverloads[deviceType] = deviceOverloads;
        }
        let result = deviceOverloads[primitiveType];
        if (!result) {
            const typeinfo = this.getCachedTypeInfo(primitiveType);
            const name = typeinfo.toTypeName(deviceType);
            result = [
                new PBFunctionTypeInfo(name, typeinfo, [])
            ];
            if (typeinfo.isScalarType()) {
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.F32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.I32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.U32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.BOOL)
                    }
                ]));
            } else if (typeinfo.isVectorType()) {
                const scalarTypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.scalarType)
                };
                const vec2TypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.resizeType(1, 2))
                };
                const vec3TypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.resizeType(1, 3))
                };
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    scalarTypeInfo
                ]));
                switch(typeinfo.cols){
                    case 2:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec2$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec2$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec2$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec2
                            }
                        ]));
                        break;
                    case 3:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec3$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec3$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec3$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec3
                            }
                        ]));
                        break;
                    case 4:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec2TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec3TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec3TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec4$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec4$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec4$1
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec4
                            }
                        ]));
                }
            } else if (typeinfo.isMatrixType()) {
                const colType = this.getCachedTypeInfo(typeinfo.resizeType(1, typeinfo.cols));
                result.push(new PBFunctionTypeInfo(name, typeinfo, Array.from({
                    length: typeinfo.rows
                }).map(()=>({
                        type: colType
                    }))));
                result.push(new PBFunctionTypeInfo(name, typeinfo, Array.from({
                    length: typeinfo.rows * typeinfo.cols
                }).map(()=>({
                        type: typeF32$1
                    }))));
            }
            deviceOverloads[primitiveType] = result;
        }
        return result;
    }
    /** Get the primitive type */ get primitiveType() {
        return this.detail.primitiveType;
    }
    /** Whether the type is signed or unsigned integer scalar or vector */ isInteger() {
        const st = this.primitiveType & SCALAR_TYPE_BITMASK;
        return st === I8_BITMASK || st === U8_BITMASK || st === I16_BITMASK || st === U16_BITMASK || st === I32_BITMASK || st === U32_BITMASK;
    }
    /** Get the scalar type */ get scalarType() {
        return this.resizeType(1, 1);
    }
    /** Get number of rows */ get rows() {
        return this.primitiveType >> ROWS_BITSHIFT & ROWS_BITMASK;
    }
    /** Get number of columns */ get cols() {
        return this.primitiveType >> COLS_BITSHIFT & COLS_BITMASK;
    }
    /** Get if this is a normalized primitive type */ get normalized() {
        return !!(this.primitiveType >> NORM_BITSHIFT & NORM_BITMASK);
    }
    /** @internal */ getLayoutAlignment(layout) {
        return layout === 'packed' ? 1 : this.isScalarType() ? 4 : 1 << Math.min(4, this.cols + 1);
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        let scalarSize;
        switch(this.scalarType){
            case PBPrimitiveType.BOOL:
            case PBPrimitiveType.I32:
            case PBPrimitiveType.I32_NORM:
            case PBPrimitiveType.U32:
            case PBPrimitiveType.U32_NORM:
            case PBPrimitiveType.F32:
                scalarSize = 4;
                break;
            case PBPrimitiveType.F16:
            case PBPrimitiveType.I16:
            case PBPrimitiveType.I16_NORM:
            case PBPrimitiveType.U16:
            case PBPrimitiveType.U16_NORM:
                scalarSize = 2;
                break;
            default:
                scalarSize = 1;
                break;
        }
        return scalarSize * this.cols * this.rows;
    }
    /**
   * Creates a new primitive type info by changing row and column of this type
   * @param rows - The new value of row
   * @param cols - The new value of column
   * @returns The new primitive type
   */ resizeType(rows, cols) {
        return makePrimitiveType(this.primitiveType & SCALAR_TYPE_BITMASK, rows, cols, this.normalized ? 1 : 0);
    }
    /** Returns true if this is a scalar type */ isScalarType() {
        return this.rows === 1 && this.cols === 1;
    }
    /** Returns true if this is a vector type */ isVectorType() {
        return this.rows === 1 && this.cols > 1;
    }
    /** Returns true if this is a matrix type */ isMatrixType() {
        return this.rows > 1 && this.cols > 1;
    }
    /** {@inheritDoc PBTypeInfo.isPrimitiveType} */ isPrimitiveType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.scalarType !== PBPrimitiveType.BOOL;
    }
    /** @internal */ isConstructible() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        return PBPrimitiveTypeInfo.getCachedOverloads(deviceType, this.primitiveType);
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = primitiveTypeMapWGSL[this.primitiveType];
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            const typename = primitiveTypeMapWebGL[this.primitiveType];
            return varName ? `${typename} ${varName}` : typename;
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `PRIM:${this.primitiveType}`;
    }
}
/**
 * The struct type info
 * @public
 */ class PBStructTypeInfo extends PBTypeInfo {
    constructor(name, layout, members){
        super(PBTypeClass.PLAIN, {
            layout: layout || 'default',
            structName: name,
            structMembers: members.map((val)=>{
                const defaultAlignment = getAlignment(val.type);
                const defaultSize = getSize(val.type);
                return {
                    name: val.name,
                    type: val.type,
                    alignment: defaultAlignment,
                    size: defaultSize,
                    defaultAlignment: defaultAlignment,
                    defaultSize: defaultSize
                };
            })
        });
        if (this.layout === 'std140') {
            this.calcAlignmentAndSizeSTD140();
        } else if (this.layout === 'std430') {
            this.calcAlignmentAndSizePacked();
        }
    }
    /** Get the layout type */ get layout() {
        return this.detail.layout;
    }
    /** Get name of the struct type */ get structName() {
        return this.detail.structName;
    }
    set structName(val) {
        this.detail.structName = val;
    }
    /** Get member types of the struct type */ get structMembers() {
        return this.detail.structMembers;
    }
    /**
   * Creates a new struct type by extending this type
   * @param name - Name of the new struct type
   * @param members - additional struct members
   * @returns The new struct type
   */ extends(name, members) {
        const oldMembers = this.structMembers.map((member)=>({
                name: member.name,
                type: member.type
            }));
        return new PBStructTypeInfo(name, this.layout, [
            ...oldMembers,
            ...members
        ]);
    }
    /** {@inheritDoc PBTypeInfo.isStructType} */ isStructType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.detail.structMembers.every((val)=>val.type.isHostSharable());
    }
    /** @internal */ isConstructible() {
        return this.detail.structMembers.every((val)=>val.type.isConstructible());
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads() {
        const result = [
            new PBFunctionTypeInfo(this.structName, this, [])
        ];
        if (this.isConstructible()) {
            result.push(new PBFunctionTypeInfo(this.structName, this, this.structMembers.map((val)=>({
                    type: val.type
                }))));
        }
        return result;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            return varName ? `${varName}: ${this.structName}` : this.structName;
        } else {
            return varName ? `${this.structName} ${varName}` : this.structName;
        }
    }
    /** @internal */ isWritable() {
        for (const member of this.structMembers){
            if (member.type.isAtomicI32() || member.type.isAtomicU32()) {
                return true;
            }
            if (member.type.isStructType() && member.type.isWritable()) {
                return true;
            }
        }
        return false;
    }
    /** @internal */ getLayoutAlignment(layout) {
        if (layout === 'packed') {
            return 1;
        }
        let alignment = 0;
        for (const member of this.structMembers){
            alignment = Math.max(alignment, member.type.getLayoutAlignment(layout));
        }
        if (layout === 'std140') {
            alignment = align(alignment, 16);
        }
        return alignment;
    }
    /** @internal */ getLayoutSize(layout) {
        let size = 0;
        let structAlignment = 0;
        for (const member of this.structMembers){
            const memberAlignment = member.type.getLayoutAlignment(layout);
            size = align(size, memberAlignment);
            size += member.type.getLayoutSize(layout);
            structAlignment = Math.max(structAlignment, memberAlignment);
        }
        return align(size, structAlignment);
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset, layout) {
        const bufferLayout = {
            byteSize: 0,
            entries: []
        };
        const start = offset;
        for (const member of this.structMembers){
            offset = align(offset, member.type.getLayoutAlignment(layout));
            const size = member.type.getLayoutSize(layout);
            bufferLayout.entries.push({
                name: member.name,
                offset: offset,
                byteSize: size,
                type: typeToTypedArray(member.type),
                subLayout: member.type.isStructType() ? member.type.toBufferLayout(offset, layout) : null,
                arraySize: member.type.isArrayType() ? member.type.dimension : 0
            });
            offset += size;
        }
        bufferLayout.byteSize = layout === 'std140' ? align(offset - start, 16) : offset - start;
        return bufferLayout;
    }
    /** @internal */ clone(newName) {
        return new PBStructTypeInfo(newName || this.structName, this.layout, this.structMembers);
    }
    /** @internal */ reset(name, layout, members) {
        this.detail = {
            layout: layout || 'default',
            structName: name,
            structMembers: members.map((val)=>{
                const defaultAlignment = getAlignment(val.type);
                const defaultSize = getSize(val.type);
                return {
                    name: val.name,
                    type: val.type,
                    alignment: defaultAlignment,
                    size: defaultSize,
                    defaultAlignment: defaultAlignment,
                    defaultSize: defaultSize
                };
            })
        };
        if (this.layout === 'std140') {
            this.calcAlignmentAndSizeSTD140();
        } else if (this.layout === 'std430') {
            this.calcAlignmentAndSizePacked();
        }
        this.id = null;
    }
    /** @internal */ genTypeId() {
        return `STRUCT:${this.structName}:${this.layout}:${this.structMembers.map((val)=>`${val.name}(${val.type.typeId})`).join(':')}`;
    }
    /** @internal */ calcAlignmentAndSizeSTD140() {
        for (const member of this.structMembers){
            if (member.type.isPrimitiveType()) {
                if (member.type.isMatrixType() && member.type.cols === 2) {
                    throw new Error(`matrix${member.type.rows}x${member.type.cols} can not be used in std140 layout`);
                }
            } else if (member.type.isArrayType() && (member.type.elementType.isAnyType() || getAlignment(member.type.elementType) !== 16)) {
                throw new Error('array element must be 16 bytes aligned in std140 layout');
            } else if (member.type.isStructType()) {
                member.alignment = 16;
                member.size = align(member.defaultSize, 16);
            }
        }
    }
    /** @internal */ calcAlignmentAndSizePacked() {
        for (const member of this.structMembers){
            member.alignment = getAlignmentPacked(member.type);
            member.size = getSizePacked(member.type);
        }
    }
}
/**
 * The array type info
 * @public
 */ class PBArrayTypeInfo extends PBTypeInfo {
    constructor(elementType, dimension){
        super(PBTypeClass.ARRAY, {
            elementType: elementType,
            dimension: Number(dimension) || 0
        });
    }
    /** Get the element type */ get elementType() {
        return this.detail.elementType;
    }
    /** Get dimension of the array type */ get dimension() {
        return this.detail.dimension;
    }
    /** {@inheritDoc PBTypeInfo.isArrayType} */ isArrayType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.detail.elementType.isHostSharable();
    }
    /** @internal */ isConstructible() {
        return this.dimension && this.detail.elementType.isConstructible();
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        const name = this.toTypeName(deviceType);
        const result = [
            new PBFunctionTypeInfo(name, this, [])
        ];
        if (deviceType !== 'webgl' && this.isConstructible()) {
            result.push(new PBFunctionTypeInfo(name, this, Array.from({
                length: this.dimension
            }).map(()=>({
                    type: this.elementType
                }))));
        }
        return result;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const elementTypeName = this.elementType.toTypeName(deviceType);
            const typename = `array<${elementTypeName}${this.dimension ? ', ' + this.dimension : ''}>`;
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            console.assert(!!this.dimension, 'runtime-sized array not supported for webgl');
            console.assert(!this.elementType.isArrayType(), 'multi-dimensional arrays not supported for webgl');
            const elementTypeName = this.elementType.toTypeName(deviceType, varName);
            return `${elementTypeName}[${this.dimension}]`;
        }
    }
    /** @internal */ getLayoutAlignment(layout) {
        return layout === 'packed' || this.elementType.isAnyType() ? 1 : layout === 'std430' ? this.elementType.getLayoutAlignment(layout) : align(this.elementType.getLayoutAlignment(layout), 16);
    }
    /** @internal */ getLayoutSize(layout) {
        const elementAlignment = this.elementType.isAnyType() ? 1 : this.elementType.getLayoutAlignment(layout);
        if (layout === 'std140' && !!(elementAlignment & 15)) {
            // array element stride of std140 layout must be multiple of 16
            throw new Error('Error: array element stride of std140 must be multiple of 16');
        }
        return this.elementType.isAnyType() ? 0 : this.dimension * align(this.elementType.getLayoutSize(layout), elementAlignment);
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    isCompatibleType(other) {
        if (!other.isArrayType()) {
            return false;
        }
        if (this.dimension !== 0 && other.dimension !== this.dimension) {
            return false;
        }
        return this.elementType.isCompatibleType(other.elementType);
    }
    /** @internal */ genTypeId() {
        return `ARRAY:(${this.elementType.typeId})[${this.dimension}]`;
    }
}
/**
 * The pointer type info
 * @public
 */ class PBPointerTypeInfo extends PBTypeInfo {
    /** @internal */ writable;
    constructor(pointerType, addressSpace){
        super(PBTypeClass.POINTER, {
            pointerType,
            addressSpace
        });
        console.assert(pointerType.isStorable(), 'the pointee type must be storable');
        this.writable = false;
    }
    /** Get type of the pointer */ get pointerType() {
        return this.detail.pointerType;
    }
    /** Get address space of the pointer */ get addressSpace() {
        return this.detail.addressSpace;
    }
    set addressSpace(val) {
        if (this.detail.addressSpace !== val) {
            this.detail.addressSpace = val;
            this.id = null;
        }
    }
    /** {@inheritDoc PBTypeInfo.isPointerType} */ isPointerType() {
        return true;
    }
    /** @internal */ toTypeName(device, varName) {
        if (device === 'webgpu') {
            const addressSpace = this.addressSpace === PBAddressSpace.UNKNOWN ? PBAddressSpace.FUNCTION : this.addressSpace;
            /*
      const mode = addressSpace === PBAddressSpace.UNIFORM || (addressSpace === PBAddressSpace.STORAGE && !this.writable) ? 'read' : 'read_write'
      const typename = `ptr<${addressSpace}, ${this.pointerType.toTypeName(device)}, ${mode}>`;
      */ /* WGSL spec:
        When writing a variable declaration or a pointer type in WGSL source:
        For the storage address space, the access mode is optional, and defaults to read.
        For other address spaces, the access mode must not be written.
      */ const mode = addressSpace === PBAddressSpace.STORAGE && this.writable ? ', read_write' : '';
            const typename = `ptr<${addressSpace}, ${this.pointerType.toTypeName(device)} ${mode}>`;
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('pointer type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `PTR:(${this.pointerType.typeId})`;
    }
}
/**
 * The atomic int type info
 * @public
 */ class PBAtomicI32TypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ATOMIC_I32, null);
    }
    /** @internal */ isAtomicI32() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = 'atomic<i32>';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('atomic type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ getLayoutAlignment(layout) {
        return 4;
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        return 4;
    }
    /** @internal */ genTypeId() {
        return `ATOMICI32`;
    }
}
/**
 * The atomic int type info
 * @public
 */ class PBAtomicU32TypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ATOMIC_U32, null);
    }
    /** @internal */ isAtomicU32() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = 'atomic<u32>';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('atomic type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ getLayoutAlignment(layout) {
        return 4;
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        return 4;
    }
    /** @internal */ genTypeId() {
        return `ATOMICU32`;
    }
}
/**
 * The sampler type info
 * @public
 */ class PBSamplerTypeInfo extends PBTypeInfo {
    constructor(accessMode){
        super(PBTypeClass.SAMPLER, {
            accessMode: accessMode
        });
    }
    /** Get the access mode */ get accessMode() {
        return this.detail.accessMode;
    }
    /** @internal */ isSamplerType() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = this.accessMode === PBSamplerAccessMode.SAMPLE ? 'sampler' : 'sampler_comparison';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('sampler type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `SAMPLER:${this.accessMode}`;
    }
}
/**
 * The texture type info
 * @public
 */ class PBTextureTypeInfo extends PBTypeInfo {
    constructor(textureType, texelFormat, readable, writable){
        super(PBTypeClass.TEXTURE, {
            textureType: textureType,
            readable,
            writable,
            storageTexelFormat: texelFormat || null
        });
        console.assert(!!textureTypeMapWGSL[textureType], 'unsupported texture type');
        console.assert(!(textureType & BITFLAG_STORAGE) || !!storageTexelFormatMap[texelFormat], 'invalid texel format for storage texture');
    }
    /** Get the texture type */ get textureType() {
        return this.detail.textureType;
    }
    /** Get texture format if this is a storage texture */ get storageTexelFormat() {
        return this.detail.storageTexelFormat;
    }
    /** Returns true if this is a readable storage texture type */ get readable() {
        return this.detail.readable;
    }
    /** Returns true if this is a writable storage texture type */ get writable() {
        return this.detail.writable;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ is1DTexture() {
        return !!(this.detail.textureType & BITFLAG_1D);
    }
    /** Returns true if this is a 2D texture type */ is2DTexture() {
        return !!(this.detail.textureType & BITFLAG_2D);
    }
    /** Returns true if this is a 3D texture type */ is3DTexture() {
        return !!(this.detail.textureType & BITFLAG_3D);
    }
    /** Returns true if this is a cube texture type */ isCubeTexture() {
        return !!(this.detail.textureType & BITFLAG_CUBE);
    }
    /** Returns true if this is an array texture type */ isArrayTexture() {
        return !!(this.detail.textureType & BITFLAG_ARRAY);
    }
    /** Returns true if this is a storage texture type */ isStorageTexture() {
        return !!(this.detail.textureType & BITFLAG_STORAGE);
    }
    /** Return s true if this is a depth texture type */ isDepthTexture() {
        return !!(this.detail.textureType & BITFLAG_DEPTH);
    }
    /** Returns true if this is a multisampled texture type */ isMultisampledTexture() {
        return !!(this.detail.textureType & BITFLAG_MULTISAMPLED);
    }
    /** Returns true if this is an external texture type */ isExternalTexture() {
        return !!(this.detail.textureType & BITFLAG_EXTERNAL);
    }
    /** Returns true if the texture format is of type integer  */ isIntTexture() {
        return !!(this.detail.textureType & BITFLAG_INT);
    }
    /** Returns true if the texture format is of type unsigned integer  */ isUIntTexture() {
        return !!(this.detail.textureType & BITFLAG_UINT);
    }
    /** @internal */ isTextureType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            let typename = textureTypeMapWGSL[this.textureType];
            if (this.isStorageTexture()) {
                const storageTexelFormat = storageTexelFormatMap[this.storageTexelFormat];
                // storage textures currently only support 'write' access control
                const accessMode = 'write'; //this.readable ? (this.writable ? 'read_write' : 'read') : 'write';
                typename = `${typename}<${storageTexelFormat}, ${accessMode}>`;
            }
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            const typename = (deviceType === 'webgl' ? textureTypeMapWebGL : textureTypeMapWebGL2)[this.textureType];
            console.assert(!!typename, 'unsupported texture type');
            return varName ? `${typename} ${varName}` : typename;
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `TEXTURE:${this.textureType}`;
    }
}
/**
 * The function type info
 * @public
 */ class PBFunctionTypeInfo extends PBTypeInfo {
    constructor(name, returnType, argTypes){
        super(PBTypeClass.FUNCTION, {
            name,
            returnType,
            argTypes
        });
    }
    /** Get name of the function */ get name() {
        return this.detail.name;
    }
    /** Get return type of the function */ get returnType() {
        return this.detail.returnType;
    }
    /** Get all the argument types for this function */ get argTypes() {
        return this.detail.argTypes;
    }
    /** Get hash for parameter types */ get argHash() {
        return this.argTypes.map((val)=>val.type.typeId).join(',');
    }
    /** @internal */ genTypeId() {
        return `fn(${this.argHash}):${this.returnType.typeId}`;
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        throw new Error('not supported');
    }
}
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC4);
/** @internal */ const typeF32$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32);
/** @internal */ const typeF32Vec2$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC2);
/** @internal */ const typeF32Vec3$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC3);
/** @internal */ const typeF32Vec4$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4_NORM);
/** @internal */ const typeAtomicI32 = new PBAtomicI32TypeInfo();
/** @internal */ const typeAtomicU32 = new PBAtomicU32TypeInfo();
/** @internal */ const typeI32$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
/** @internal */ const typeI32Vec2$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2);
/** @internal */ const typeI32Vec3$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3);
/** @internal */ const typeI32Vec4$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4_NORM);
/** @internal */ const typeU32$3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
/** @internal */ const typeU32Vec2$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2);
/** @internal */ const typeU32Vec3$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3);
/** @internal */ const typeU32Vec4$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4_NORM);
/** @internal */ const typeBool = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BOOL);
/** @internal */ const typeBVec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC2);
/** @internal */ const typeBVec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC3);
/** @internal */ const typeBVec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC4);
/** @internal */ const typeMat2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2);
/** @internal */ const typeMat2x3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2x3);
/** @internal */ const typeMat2x4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2x4);
/** @internal */ const typeMat3x2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3x2);
/** @internal */ const typeMat3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3);
/** @internal */ const typeMat3x4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3x4);
/** @internal */ const typeMat4x2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4x2);
/** @internal */ const typeMat4x3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4x3);
/** @internal */ const typeMat4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4);
/** @internal */ const typeTex1D = new PBTextureTypeInfo(PBTextureType.TEX_1D);
/** @internal */ const typeITex1D = new PBTextureTypeInfo(PBTextureType.ITEX_1D);
/** @internal */ const typeUTex1D = new PBTextureTypeInfo(PBTextureType.UTEX_1D);
/** @internal */ const typeTex2D = new PBTextureTypeInfo(PBTextureType.TEX_2D);
/** @internal */ const typeITex2D = new PBTextureTypeInfo(PBTextureType.ITEX_2D);
/** @internal */ const typeUTex2D = new PBTextureTypeInfo(PBTextureType.UTEX_2D);
/** @internal */ const typeTex2DArray = new PBTextureTypeInfo(PBTextureType.TEX_2D_ARRAY);
/** @internal */ const typeITex2DArray = new PBTextureTypeInfo(PBTextureType.ITEX_2D_ARRAY);
/** @internal */ const typeUTex2DArray = new PBTextureTypeInfo(PBTextureType.UTEX_2D_ARRAY);
/** @internal */ const typeTex3D = new PBTextureTypeInfo(PBTextureType.TEX_3D);
/** @internal */ const typeITex3D = new PBTextureTypeInfo(PBTextureType.ITEX_3D);
/** @internal */ const typeUTex3D = new PBTextureTypeInfo(PBTextureType.UTEX_3D);
/** @internal */ const typeTexCube = new PBTextureTypeInfo(PBTextureType.TEX_CUBE);
/** @internal */ const typeITexCube = new PBTextureTypeInfo(PBTextureType.ITEX_CUBE);
/** @internal */ const typeUTexCube = new PBTextureTypeInfo(PBTextureType.UTEX_CUBE);
/** @internal */ const typeTexExternal = new PBTextureTypeInfo(PBTextureType.TEX_EXTERNAL);
/** @internal */ const typeTexCubeArray = new PBTextureTypeInfo(PBTextureType.TEX_CUBE_ARRAY);
/** @internal */ const typeITexCubeArray = new PBTextureTypeInfo(PBTextureType.ITEX_CUBE_ARRAY);
/** @internal */ const typeUTexCubeArray = new PBTextureTypeInfo(PBTextureType.UTEX_CUBE_ARRAY);
/** @internal */ const typeTexMultisampled2D = new PBTextureTypeInfo(PBTextureType.TEX_MULTISAMPLED_2D);
/** @internal */ const typeITexMultisampled2D = new PBTextureTypeInfo(PBTextureType.ITEX_MULTISAMPLED_2D);
/** @internal */ const typeUTexMultisampled2D = new PBTextureTypeInfo(PBTextureType.UTEX_MULTISAMPLED_2D);
/** @internal */ const typeTexStorage1D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8unorm');
/** @internal */ const typeTexStorage1D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8unorm');
/** @internal */ const typeTexStorage1D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8ui');
/** @internal */ const typeTexStorage1D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8i');
/** @internal */ const typeTexStorage1D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16ui');
/** @internal */ const typeTexStorage1D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16i');
/** @internal */ const typeTexStorage1D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16f');
/** @internal */ const typeTexStorage1D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32ui');
/** @internal */ const typeTexStorage1D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32i');
/** @internal */ const typeTexStorage1D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32f');
/** @internal */ const typeTexStorage1D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32ui');
/** @internal */ const typeTexStorage1D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32i');
/** @internal */ const typeTexStorage1D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32f');
/** @internal */ const typeTexStorage1D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32ui');
/** @internal */ const typeTexStorage1D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32i');
/** @internal */ const typeTexStorage1D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32f');
/** @internal */ const typeTexStorage2D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8unorm');
/** @internal */ const typeTexStorage2D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'bgra8unorm');
/** @internal */ const typeTexStorage2D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8ui');
/** @internal */ const typeTexStorage2D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8i');
/** @internal */ const typeTexStorage2D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16ui');
/** @internal */ const typeTexStorage2D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16i');
/** @internal */ const typeTexStorage2D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16f');
/** @internal */ const typeTexStorage2D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32ui');
/** @internal */ const typeTexStorage2D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32i');
/** @internal */ const typeTexStorage2D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32f');
/** @internal */ const typeTexStorage2D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32ui');
/** @internal */ const typeTexStorage2D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32i');
/** @internal */ const typeTexStorage2D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32f');
/** @internal */ const typeTexStorage2D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32ui');
/** @internal */ const typeTexStorage2D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32i');
/** @internal */ const typeTexStorage2D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32f');
/** @internal */ const typeTexStorage2DArray_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8unorm');
/** @internal */ const typeTexStorage2DArray_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'bgra8unorm');
/** @internal */ const typeTexStorage2DArray_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8ui');
/** @internal */ const typeTexStorage2DArray_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8i');
/** @internal */ const typeTexStorage2DArray_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16ui');
/** @internal */ const typeTexStorage2DArray_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16i');
/** @internal */ const typeTexStorage2DArray_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16f');
/** @internal */ const typeTexStorage2DArray_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32ui');
/** @internal */ const typeTexStorage2DArray_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32i');
/** @internal */ const typeTexStorage2DArray_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32f');
/** @internal */ const typeTexStorage2DArray_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32ui');
/** @internal */ const typeTexStorage2DArray_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32i');
/** @internal */ const typeTexStorage2DArray_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32f');
/** @internal */ const typeTexStorage2DArray_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32ui');
/** @internal */ const typeTexStorage2DArray_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32i');
/** @internal */ const typeTexStorage2DArray_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32f');
/** @internal */ const typeTexStorage3D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8unorm');
/** @internal */ const typeTexStorage3D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'bgra8unorm');
/** @internal */ const typeTexStorage3D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8ui');
/** @internal */ const typeTexStorage3D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8i');
/** @internal */ const typeTexStorage3D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16ui');
/** @internal */ const typeTexStorage3D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16i');
/** @internal */ const typeTexStorage3D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16f');
/** @internal */ const typeTexStorage3D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32ui');
/** @internal */ const typeTexStorage3D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32i');
/** @internal */ const typeTexStorage3D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32f');
/** @internal */ const typeTexStorage3D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32ui');
/** @internal */ const typeTexStorage3D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32i');
/** @internal */ const typeTexStorage3D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32f');
/** @internal */ const typeTexStorage3D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32ui');
/** @internal */ const typeTexStorage3D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32i');
/** @internal */ const typeTexStorage3D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32f');
/** @internal */ const typeTexDepth2D = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_2D);
/** @internal */ const typeTexDepth2DArray = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_2D_ARRAY);
/** @internal */ const typeTexDepthCube = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_CUBE);
/** @internal */ const typeTexDepthCubeArray = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_CUBE_ARRAY);
/** @internal */ const typeTexDepthMultisampled2D = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_MULTISAMPLED_2D);
/** @internal */ const typeSampler = new PBSamplerTypeInfo(PBSamplerAccessMode.SAMPLE);
/** @internal */ const typeSamplerComparison = new PBSamplerTypeInfo(PBSamplerAccessMode.COMPARISON);
/** @internal */ const typeVoid = new PBVoidTypeInfo();
/** @internal */ new PBAnyTypeInfo();
/** @internal */ const typeFrexpResult = new PBStructTypeInfo('FrexpResult', 'default', [
    {
        name: 'sig',
        type: typeF32$1
    },
    {
        name: 'exp',
        type: typeI32$1
    }
]);
/** @internal */ const typeFrexpResultVec2 = new PBStructTypeInfo('FrexpResultVec2', 'default', [
    {
        name: 'sig',
        type: typeF32Vec2$1
    },
    {
        name: 'exp',
        type: typeI32Vec2$1
    }
]);
/** @internal */ const typeFrexpResultVec3 = new PBStructTypeInfo('FrexpResultVec3', 'default', [
    {
        name: 'sig',
        type: typeF32Vec3$1
    },
    {
        name: 'exp',
        type: typeI32Vec3$1
    }
]);
/** @internal */ const typeFrexpResultVec4 = new PBStructTypeInfo('FrexpResultVec4', 'default', [
    {
        name: 'sig',
        type: typeF32Vec4$1
    },
    {
        name: 'exp',
        type: typeI32Vec4$1
    }
]);

/** @internal */ const MAX_VERTEX_ATTRIBUTES = 16;
/** @internal */ const MAX_BINDING_GROUPS = 4;
/** @internal */ const VERTEX_ATTRIB_POSITION = 0;
/** @internal */ const VERTEX_ATTRIB_NORMAL = 1;
/** @internal */ const VERTEX_ATTRIB_DIFFUSE = 2;
/** @internal */ const VERTEX_ATTRIB_TANGENT = 3;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD0 = 4;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD1 = 5;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD2 = 6;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD3 = 7;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD4 = 8;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD5 = 9;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD6 = 10;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD7 = 11;
/** @internal */ const VERTEX_ATTRIB_BLEND_WEIGHT = 12;
/** @internal */ const VERTEX_ATTRIB_BLEND_INDICES = 13;
const vertexAttribFormatMap = {
    position_u8normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    position_u8normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    position_i8normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    position_i8normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    position_u16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    position_u16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    position_i16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    position_i16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    position_u16normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    position_u16normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    position_i16normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    position_i16normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    position_f16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    position_f16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    position_f32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    position_f32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    position_f32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    position_f32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    position_i32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    position_i32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    position_i32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    position_i32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    position_u32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    position_u32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    position_u32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    position_u32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    normal_f16x4: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    normal_f32x3: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    normal_f32x4: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    diffuse_u8normx4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    diffuse_u16x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    diffuse_u16normx4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    diffuse_f16x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    diffuse_f32x3: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    diffuse_f32x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    diffuse_u32x3: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    diffuse_u32x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tangent_f16x4: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tangent_f32x3: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tangent_f32x4: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex0_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex0_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex0_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex0_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex0_u16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex0_u16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex0_i16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex0_i16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex0_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex0_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex0_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex0_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex0_f16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex0_f16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex0_f32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex0_f32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex0_f32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex0_f32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex0_i32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex0_i32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex0_i32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex0_i32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex0_u32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex0_u32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex0_u32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex0_u32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex1_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex1_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex1_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex1_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex1_u16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex1_u16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex1_i16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex1_i16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex1_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex1_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex1_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex1_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex1_f16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex1_f16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex1_f32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex1_f32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex1_f32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex1_f32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex1_i32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex1_i32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex1_i32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex1_i32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex1_u32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex1_u32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex1_u32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex1_u32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex2_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex2_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex2_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex2_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex2_u16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex2_u16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex2_i16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex2_i16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex2_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex2_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex2_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex2_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex2_f16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex2_f16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex2_f32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex2_f32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex2_f32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex2_f32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex2_i32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex2_i32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex2_i32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex2_i32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex2_u32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex2_u32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex2_u32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex2_u32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex3_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex3_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex3_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex3_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex3_u16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex3_u16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex3_i16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex3_i16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex3_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex3_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex3_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex3_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex3_f16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex3_f16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex3_f32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex3_f32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex3_f32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex3_f32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex3_i32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex3_i32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex3_i32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex3_i32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex3_u32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex3_u32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex3_u32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex3_u32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex4_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex4_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex4_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex4_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex4_u16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex4_u16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex4_i16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex4_i16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex4_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex4_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex4_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex4_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex4_f16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex4_f16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex4_f32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex4_f32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex4_f32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex4_f32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex4_i32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex4_i32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex4_i32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex4_i32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex4_u32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex4_u32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex4_u32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex4_u32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex5_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex5_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex5_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex5_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex5_u16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex5_u16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex5_i16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex5_i16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex5_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex5_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex5_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex5_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex5_f16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex5_f16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex5_f32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex5_f32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex5_f32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex5_f32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex5_i32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex5_i32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex5_i32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex5_i32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex5_u32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex5_u32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex5_u32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex5_u32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex6_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex6_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex6_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex6_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex6_u16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex6_u16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex6_i16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex6_i16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex6_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex6_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex6_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex6_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex6_f16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex6_f16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex6_f32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex6_f32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex6_f32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex6_f32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex6_i32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex6_i32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex6_i32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex6_i32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex6_u32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex6_u32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex6_u32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex6_u32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex7_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex7_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex7_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex7_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex7_u16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex7_u16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex7_i16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex7_i16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex7_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex7_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex7_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex7_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex7_f16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex7_f16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex7_f32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex7_f32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex7_f32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex7_f32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex7_i32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex7_i32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex7_i32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex7_i32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex7_u32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex7_u32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex7_u32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex7_u32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    blendweights_f16x4: [
        VERTEX_ATTRIB_BLEND_WEIGHT,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    blendweights_f32x4: [
        VERTEX_ATTRIB_BLEND_WEIGHT,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    blendindices_u16x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    blendindices_f16x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    blendindices_f32x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    blendindices_u32x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ]
};
const vertexAttribNameMap = {
    position: VERTEX_ATTRIB_POSITION,
    normal: VERTEX_ATTRIB_NORMAL,
    diffuse: VERTEX_ATTRIB_DIFFUSE,
    tangent: VERTEX_ATTRIB_TANGENT,
    blendIndices: VERTEX_ATTRIB_BLEND_INDICES,
    blendWeights: VERTEX_ATTRIB_BLEND_WEIGHT,
    texCoord0: VERTEX_ATTRIB_TEXCOORD0,
    texCoord1: VERTEX_ATTRIB_TEXCOORD1,
    texCoord2: VERTEX_ATTRIB_TEXCOORD2,
    texCoord3: VERTEX_ATTRIB_TEXCOORD3,
    texCoord4: VERTEX_ATTRIB_TEXCOORD4,
    texCoord5: VERTEX_ATTRIB_TEXCOORD5,
    texCoord6: VERTEX_ATTRIB_TEXCOORD6,
    texCoord7: VERTEX_ATTRIB_TEXCOORD7
};
const vertexAttribNameRevMap = {
    [VERTEX_ATTRIB_POSITION]: 'position',
    [VERTEX_ATTRIB_NORMAL]: 'normal',
    [VERTEX_ATTRIB_DIFFUSE]: 'diffuse',
    [VERTEX_ATTRIB_TANGENT]: 'tangent',
    [VERTEX_ATTRIB_BLEND_INDICES]: 'blendIndices',
    [VERTEX_ATTRIB_BLEND_WEIGHT]: 'blendWeights',
    [VERTEX_ATTRIB_TEXCOORD0]: 'texCoord0',
    [VERTEX_ATTRIB_TEXCOORD1]: 'texCoord1',
    [VERTEX_ATTRIB_TEXCOORD2]: 'texCoord2',
    [VERTEX_ATTRIB_TEXCOORD3]: 'texCoord3',
    [VERTEX_ATTRIB_TEXCOORD4]: 'texCoord4',
    [VERTEX_ATTRIB_TEXCOORD5]: 'texCoord5',
    [VERTEX_ATTRIB_TEXCOORD6]: 'texCoord6',
    [VERTEX_ATTRIB_TEXCOORD7]: 'texCoord7'
};
var GPUResourceUsageFlags;
(function(GPUResourceUsageFlags) {
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_LINEAR_COLOR_SPACE"] = 2] = "TF_LINEAR_COLOR_SPACE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_NO_MIPMAP"] = 4] = "TF_NO_MIPMAP";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_WRITABLE"] = 8] = "TF_WRITABLE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_NO_GC"] = 16] = "TF_NO_GC";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_VERTEX"] = 32] = "BF_VERTEX";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_INDEX"] = 64] = "BF_INDEX";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_READ"] = 128] = "BF_READ";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_WRITE"] = 256] = "BF_WRITE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_UNIFORM"] = 512] = "BF_UNIFORM";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_STORAGE"] = 1024] = "BF_STORAGE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["DYNAMIC"] = 2048] = "DYNAMIC";
    GPUResourceUsageFlags[GPUResourceUsageFlags["MANAGED"] = 4096] = "MANAGED";
})(GPUResourceUsageFlags || (GPUResourceUsageFlags = {}));
/**
 * Get vertex attribute index by semantic
 * @internal
 */ function getVertexAttribByName(name) {
    return vertexAttribNameMap[name];
}
/**
 * Get vertex semantic by attribute index
 * @internal
 */ function getVertexAttribName(attrib) {
    return vertexAttribNameRevMap[attrib];
}
/**
 * Get byte size of specified vertex format
 * @internal
 */ function getVertexFormatSize(fmt) {
    return vertexAttribFormatMap[fmt][2];
}
/**
 * Get vertex format by semantic and component type and component count
 * @param semantic - The vertex semantic
 * @param type - Data type of vertex component
 * @param count - The count of vertex components
 * @returns Vertex format
 * @public
 */ function getVertexAttribFormat(semantic, type, count) {
    const loc = getVertexAttribByName(semantic);
    for(const k in vertexAttribFormatMap){
        const v = vertexAttribFormatMap[k];
        if (v[0] === loc && v[3] === type && v[4] === count) {
            return k;
        }
    }
    return null;
}
/**
 * Get byte stride of a vertex buffer by specified structure type of the vertex buffer
 * @param vertexBufferType - The structure type of the vertex buffer
 * @returns The byte stride of the vertex buffer
 * @public
 */ function getVertexBufferStride(vertexBufferType) {
    const vertexType = vertexBufferType.structMembers[0].type.elementType;
    if (vertexType.isStructType()) {
        let stride = 0;
        for (const member of vertexType.structMembers){
            stride += member.type.getSize();
        }
        return stride;
    } else {
        return vertexType.getSize();
    }
}
/**
 * Get primitive type of a vertex attribute by specified vertex semantic
 * @param vertexBufferType - The structure type of the vertex buffer
 * @param semantic - The vertex semantic
 * @returns - The primitive type of the vertex attribute
 * @public
 */ function getVertexBufferAttribTypeBySemantic(vertexBufferType, semantic) {
    const k = vertexBufferType.structMembers[0];
    const vertexType = k.type.elementType;
    if (vertexType.isStructType()) {
        for (const member of vertexType.structMembers){
            if (member.name === semantic) {
                return member.type;
            }
        }
        return null;
    } else {
        return k.name === semantic ? vertexType : null;
    }
}
/**
 * Get primitive type of a vertex attribute by specified vertex attribute index
 * @param vertexBufferType - The structure type of the vertex buffer
 * @param semantic - The vertex attribute index
 * @returns - The primitive type of the vertex attribute
 * @public
 */ function getVertexBufferAttribType(vertexBufferType, attrib) {
    const attribName = getVertexAttribName(attrib);
    if (!attribName) {
        return null;
    }
    return getVertexBufferAttribTypeBySemantic(vertexBufferType, attribName);
}
/**
 * Get the structure type of a vertex buffer by specified vertex attribute formats and the length of the vertex buffer
 * @param length - The length of the vertex buffer
 * @param attributes - The vertex attributes
 * @returns The structure type of the vertex buffer
 * @public
 */ function makeVertexBufferType(length, ...attributes) {
    if (attributes.length === 0) {
        return null;
    }
    if (attributes.length === 1) {
        const format = vertexAttribFormatMap[attributes[0]];
        return new PBStructTypeInfo(null, 'packed', [
            {
                name: getVertexAttribName(format[0]),
                type: new PBArrayTypeInfo(PBPrimitiveTypeInfo.getCachedTypeInfo(format[1]), length)
            }
        ]);
    } else {
        const vertexType = new PBStructTypeInfo(null, 'packed', attributes.map((attrib)=>({
                name: getVertexAttribName(vertexAttribFormatMap[attrib][0]),
                type: PBPrimitiveTypeInfo.getCachedTypeInfo(vertexAttribFormatMap[attrib][1])
            })));
        return new PBStructTypeInfo(null, 'packed', [
            {
                name: 'value',
                type: new PBArrayTypeInfo(vertexType, length)
            }
        ]);
    }
}
/**
 * Vertex semantic list
 * @public
 */ const semanticList = function() {
    const list = [];
    for(let i = 0; i < MAX_VERTEX_ATTRIBUTES; i++){
        list.push(semanticToAttrib(i));
    }
    return list;
}();
/** @internal */ function semanticToAttrib(semantic) {
    switch(semantic){
        case VERTEX_ATTRIB_POSITION:
            return 'a_position';
        case VERTEX_ATTRIB_NORMAL:
            return 'a_normal';
        case VERTEX_ATTRIB_DIFFUSE:
            return 'a_diffuse';
        case VERTEX_ATTRIB_TANGENT:
            return 'a_tangent';
        case VERTEX_ATTRIB_TEXCOORD0:
            return 'a_texcoord0';
        case VERTEX_ATTRIB_TEXCOORD1:
            return 'a_texcoord1';
        case VERTEX_ATTRIB_TEXCOORD2:
            return 'a_texcoord2';
        case VERTEX_ATTRIB_TEXCOORD3:
            return 'a_texcoord3';
        case VERTEX_ATTRIB_TEXCOORD4:
            return 'a_texcoord4';
        case VERTEX_ATTRIB_TEXCOORD5:
            return 'a_texcoord5';
        case VERTEX_ATTRIB_TEXCOORD6:
            return 'a_texcoord6';
        case VERTEX_ATTRIB_TEXCOORD7:
            return 'a_texcoord7';
        case VERTEX_ATTRIB_BLEND_INDICES:
            return 'a_indices';
        case VERTEX_ATTRIB_BLEND_WEIGHT:
            return 'a_weight';
        default:
            return null;
    }
}
/**
 * Creates the default name for the type of given gpu object
 * @param obj - The gpu object
 * @returns The default name
 * @public
 */ function genDefaultName(obj) {
    if (obj.isTexture2D()) {
        return 'texture_2d';
    } else if (obj.isTexture2DArray()) {
        return 'texture_2darray';
    } else if (obj.isTexture3D()) {
        return 'texture_3d';
    } else if (obj.isTextureCube()) {
        return 'texture_cube';
    } else if (obj.isTextureVideo()) {
        return 'texture_video';
    } else if (obj.isBuffer()) {
        return 'buffer';
    } else if (obj.isFramebuffer()) {
        return 'framebuffer';
    } else if (obj.isProgram()) {
        return 'program';
    } else if (obj.isSampler()) {
        return 'sampler';
    } else if (obj.isVertexLayout()) {
        return 'vbo';
    } else {
        return 'unknown';
    }
}

/**
 * The vertex data class
 * @public
 */ class VertexData {
    /** @internal */ _vertexBuffers;
    /** @internal */ _indexBuffer;
    /** @internal */ _drawOffset;
    constructor(){
        this._vertexBuffers = [];
        for(let i = 0; i < MAX_VERTEX_ATTRIBUTES; i++){
            this._vertexBuffers.push(null);
        }
        this._indexBuffer = null;
        this._drawOffset = 0;
    }
    /**
   * Creates a new instance of VertexData by copying from this object
   * @returns New instance of VertexData
   */ clone() {
        const newVertexData = new VertexData();
        newVertexData._vertexBuffers = this._vertexBuffers.slice();
        newVertexData._indexBuffer = this._indexBuffer;
        newVertexData._drawOffset = this._drawOffset;
        return newVertexData;
    }
    /** Vertex buffer information list */ get vertexBuffers() {
        return this._vertexBuffers;
    }
    /** Index buffer */ get indexBuffer() {
        return this._indexBuffer;
    }
    /** Draw offset */ getDrawOffset() {
        return this._drawOffset;
    }
    setDrawOffset(offset) {
        if (offset !== this._drawOffset) {
            this._drawOffset = offset;
        }
    }
    /**
   * Gets the vertex buffer by specific vertex semantic
   * @param semantic - The vertex semantic
   * @returns Vertex buffer of the given semantic
   */ getVertexBuffer(semantic) {
        return this._vertexBuffers[getVertexAttribByName(semantic)]?.buffer ?? null;
    }
    /**
   * Gets the vertex buffer information by specific vertex semantic
   * @param semantic - The vertex semantic
   * @returns Vertex buffer information of the given semantic
   */ getVertexBufferInfo(semantic) {
        return this._vertexBuffers[getVertexAttribByName(semantic)] ?? null;
    }
    /**
   * Gets the index buffer
   * @returns The index buffer
   */ getIndexBuffer() {
        return this._indexBuffer || null;
    }
    /**
   * Sets a vertex buffer
   * @param buffer - The vertex buffer object
   * @param stepMode - Step mode of the buffer
   * @returns The buffer that was set
   */ setVertexBuffer(buffer, stepMode) {
        if (!buffer || !(buffer.usage & GPUResourceUsageFlags.BF_VERTEX)) {
            throw new Error('setVertexBuffer() failed: buffer is null or buffer has not Vertex usage flag');
        }
        stepMode = stepMode || 'vertex';
        const vertexType = buffer.structure.structMembers[0].type.elementType;
        if (vertexType.isStructType()) {
            let offset = 0;
            for (const attrib of vertexType.structMembers){
                const loc = getVertexAttribByName(attrib.name);
                this.internalSetVertexBuffer(loc, buffer, offset, stepMode);
                offset += attrib.size;
            }
        } else {
            const loc = getVertexAttribByName(buffer.structure.structMembers[0].name);
            this.internalSetVertexBuffer(loc, buffer, 0, stepMode);
        }
        return buffer;
    }
    /**
   * Removes a vertex buffer
   * @param buffer - Vertex buffer to be removed
   * @returns true if the buffer was successfully removed, otherwise false
   */ removeVertexBuffer(buffer) {
        let removed = false;
        for(let loc = 0; loc < this._vertexBuffers.length; loc++){
            const info = this._vertexBuffers[loc];
            const remove = info?.buffer === buffer;
            if (remove) {
                this._vertexBuffers[loc] = null;
                removed = true;
            }
        }
        return removed;
    }
    /**
   * Sets the index buffer
   * @param buffer - Index buffer to be set
   * @returns The index buffer that was set
   */ setIndexBuffer(buffer) {
        if (buffer !== this._indexBuffer) {
            this._indexBuffer = buffer || null;
        }
        return buffer;
    }
    /** @internal */ internalSetVertexBuffer(loc, buffer, offset, stepMode) {
        if (loc < 0 || loc >= MAX_VERTEX_ATTRIBUTES) {
            throw new Error(`setVertexBuffer() failed: location out of bounds: ${loc}`);
        }
        offset = Number(offset) || 0;
        stepMode = stepMode || 'vertex';
        const old = this._vertexBuffers[loc];
        if (!old || old.buffer !== buffer || old.offset !== offset || old.stepMode !== stepMode) {
            this._vertexBuffers[loc] = {
                buffer: buffer,
                offset: offset,
                type: getVertexBufferAttribType(buffer.structure, loc),
                stride: getVertexBufferStride(buffer.structure),
                drawOffset: 0,
                stepMode: stepMode
            };
            return buffer;
        }
        return null;
    }
}

/**
 * Abstract timer interface
 * @public
 */ /**
 * CPU timer class
 * @public
 */ class CPUTimer {
    /** @internal */ _cpuTimer;
    /** @internal */ _cpuStart;
    /** @internal */ _cpuTime;
    /** @internal */ _ended;
    constructor(){
        this._cpuTimer = window.performance || window.Date;
        this._cpuTime = null;
        this._ended = false;
    }
    now() {
        return this._cpuTimer.now();
    }
    begin() {
        this._cpuStart = this.now();
        this._cpuTime = null;
        this._ended = false;
    }
    end() {
        this._cpuTime = this.now() - this._cpuStart;
        this._ended = true;
    }
    ended() {
        return this._ended;
    }
    elapsed() {
        return this._cpuTime;
    }
}

/** @internal */ function expValueToString(deviceType, value) {
    if (typeof value === 'number' || typeof value === 'boolean' || Array.isArray(value)) {
        return `${value}`;
    } else {
        return value.$ast?.toString(deviceType);
    }
}
/** @internal */ function expValueTypeToString(deviceType, type) {
    return type?.toTypeName(deviceType);
}
/** @internal */ class PBError extends Error {
}
/** @internal */ class PBValueOutOfRange extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `value out of range: ${this.value}`;
    }
}
/** @internal */ class PBTypeCastError extends PBError {
    value;
    valueType;
    expectedType;
    constructor(value, valueType, expectedType){
        super();
        this.value = value;
        this.valueType = valueType;
        this.expectedType = expectedType;
    }
    getMessage(deviceType) {
        const valueStr = typeof this.value === 'string' ? this.value : expValueToString(deviceType, this.value);
        const valueTypeStr = typeof this.valueType === 'string' ? this.valueType : expValueTypeToString(deviceType, this.valueType);
        const expectedTypeStr = typeof this.expectedType === 'string' ? this.expectedType : expValueTypeToString(deviceType, this.expectedType);
        return `cannot convert '${valueStr}' of type '${valueTypeStr}' to type ${expectedTypeStr}`;
    }
}
/** @internal */ class PBParamLengthError extends PBError {
    func;
    constructor(func){
        super();
        this.func = func;
    }
    getMessage(deviceType) {
        return `wrong argument count for function '${this.func}'`;
    }
}
/** @internal */ class PBParamTypeError extends PBError {
    func;
    param;
    constructor(func, param){
        super();
        this.func = func;
        this.param = param || null;
    }
    getMessage(deviceType) {
        return `parameter type error for function '${this.func}': ${this.param}`;
    }
}
/** @internal */ class PBParamValueError extends PBError {
    func;
    param;
    reason;
    constructor(func, param, reason){
        super();
        this.func = func;
        this.param = param || null;
        this.reason = reason || null;
    }
    getMessage(deviceType) {
        return `invalid parameter value for function '${this.func}'${this.param ? ': ' + this.param : ''}${this.reason ? ': ' + this.reason : ''}}`;
    }
}
/** @internal */ class PBOverloadingMatchError extends PBError {
    func;
    constructor(func){
        super();
        this.func = func;
    }
    getMessage(deviceType) {
        return `No matched overloading found for function '${this.func}'`;
    }
}
/** @internal */ class PBReferenceValueRequired extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `'${expValueToString(deviceType, this.value)}' is not a reference type`;
    }
}
/** @internal */ class PBPointerValueRequired extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `'${expValueToString(deviceType, this.value)}' is not a pointer type`;
    }
}
/** @internal */ class PBDeviceNotSupport extends PBError {
    feature;
    constructor(feature){
        super();
        this.feature = feature;
    }
    getMessage(deviceType) {
        return `feature not support for ${deviceType} device: ${this.feature}`;
    }
}
/** @internal */ class PBNonScopedFunctionCall extends PBError {
    funcName;
    constructor(funcName){
        super();
        this.funcName = funcName;
    }
    getMessage(deviceType) {
        return `function call must be made inside a function scope: ${this.funcName}()`;
    }
}
/** @internal */ class PBASTError extends PBError {
    ast;
    text;
    constructor(ast, text){
        super();
        this.ast = ast;
        this.text = text;
    }
    getMessage(deviceType) {
        return `${this.text}: ${this.ast.toString(deviceType)}`;
    }
}
/** @internal */ class PBInternalError extends PBError {
    constructor(desc){
        super(desc);
    }
    getMessage(deviceType) {
        return `Internal error: ${this.message}`;
    }
}

const BuiltinInputStructNameVS = 'zVSInput';
const BuiltinOutputStructNameVS = 'zVSOutput';
const BuiltinInputStructNameFS = 'zFSInput';
const BuiltinOutputStructNameFS = 'zFSOutput';
const BuiltinInputStructNameCS = 'zCSInput';
const BuiltinOutputStructNameCS = 'zCSOutput';
const BuiltinParamNameVS = 'zVertexInput';
const BuiltinParamNameFS = 'zVertexOutput';
const BuiltinParamNameCS = 'zComputeInput';
const BuiltinInputStructInstanceNameVS = 'zVSInputCpy';
const BuiltinOutputStructInstanceNameVS = 'zVSOutputCpy';
const BuiltinInputStructInstanceNameFS = 'zFSInputCpy';
const BuiltinOutputStructInstanceNameFS = 'zFSOutputCpy';
const BuiltinInputStructInstanceNameCS = 'zCSInputCpy';
const BuiltinOutputStructInstanceNameCS = 'zCSOutputCpy';
var DeclareType;
(function(DeclareType) {
    DeclareType[DeclareType["DECLARE_TYPE_NONE"] = 0] = "DECLARE_TYPE_NONE";
    DeclareType[DeclareType["DECLARE_TYPE_IN"] = 1] = "DECLARE_TYPE_IN";
    DeclareType[DeclareType["DECLARE_TYPE_OUT"] = 2] = "DECLARE_TYPE_OUT";
    DeclareType[DeclareType["DECLARE_TYPE_WORKGROUP"] = 3] = "DECLARE_TYPE_WORKGROUP";
    DeclareType[DeclareType["DECLARE_TYPE_UNIFORM"] = 4] = "DECLARE_TYPE_UNIFORM";
    DeclareType[DeclareType["DECLARE_TYPE_STORAGE"] = 5] = "DECLARE_TYPE_STORAGE";
})(DeclareType || (DeclareType = {}));
var ShaderPrecisionType;
(function(ShaderPrecisionType) {
    ShaderPrecisionType[ShaderPrecisionType["NONE"] = 0] = "NONE";
    ShaderPrecisionType[ShaderPrecisionType["HIGH"] = 1] = "HIGH";
    ShaderPrecisionType[ShaderPrecisionType["MEDIUM"] = 2] = "MEDIUM";
    ShaderPrecisionType[ShaderPrecisionType["LOW"] = 3] = "LOW";
})(ShaderPrecisionType || (ShaderPrecisionType = {}));
/** @internal */ function getBuiltinParamName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinParamNameVS;
        case ShaderType.Fragment:
            return BuiltinParamNameFS;
        case ShaderType.Compute:
            return BuiltinParamNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinInputStructInstanceName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinInputStructInstanceNameVS;
        case ShaderType.Fragment:
            return BuiltinInputStructInstanceNameFS;
        case ShaderType.Compute:
            return BuiltinInputStructInstanceNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinOutputStructInstanceName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinOutputStructInstanceNameVS;
        case ShaderType.Fragment:
            return BuiltinOutputStructInstanceNameFS;
        case ShaderType.Compute:
            return BuiltinOutputStructInstanceNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinInputStructName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinInputStructNameVS;
        case ShaderType.Fragment:
            return BuiltinInputStructNameFS;
        case ShaderType.Compute:
            return BuiltinInputStructNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinOutputStructName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinOutputStructNameVS;
        case ShaderType.Fragment:
            return BuiltinOutputStructNameFS;
        case ShaderType.Compute:
            return BuiltinOutputStructNameCS;
        default:
            return null;
    }
}
/** @internal */ function getTextureSampleType(type) {
    switch(type.textureType){
        case PBTextureType.TEX_1D:
        case PBTextureType.TEX_STORAGE_1D:
        case PBTextureType.TEX_2D:
        case PBTextureType.TEX_STORAGE_2D:
        case PBTextureType.TEX_2D_ARRAY:
        case PBTextureType.TEX_STORAGE_2D_ARRAY:
        case PBTextureType.TEX_3D:
        case PBTextureType.TEX_STORAGE_3D:
        case PBTextureType.TEX_CUBE:
        case PBTextureType.TEX_EXTERNAL:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4);
        case PBTextureType.TEX_DEPTH_2D_ARRAY:
        case PBTextureType.TEX_DEPTH_2D:
        case PBTextureType.TEX_DEPTH_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.F32);
        case PBTextureType.ITEX_2D_ARRAY:
        case PBTextureType.ITEX_1D:
        case PBTextureType.ITEX_2D:
        case PBTextureType.ITEX_3D:
        case PBTextureType.ITEX_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.I32);
        case PBTextureType.UTEX_2D_ARRAY:
        case PBTextureType.UTEX_1D:
        case PBTextureType.UTEX_2D:
        case PBTextureType.UTEX_3D:
        case PBTextureType.UTEX_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.U32);
        default:
            return null;
    }
}
/** @internal */ function genSamplerName(textureName, comparison) {
    return `ch_auto_sampler_${textureName}${comparison ? '_comparison' : ''}`;
}
/** @internal */ const builtinVariables = {
    webgl: {
        position: {
            name: 'gl_Position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'vertex'
        },
        pointSize: {
            name: 'gl_PointSize',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'vertex'
        },
        fragCoord: {
            name: 'gl_FragCoord',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'fragment'
        },
        frontFacing: {
            name: 'gl_FrontFacing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            stage: 'fragment'
        },
        fragDepth: {
            name: 'gl_FragDepthEXT',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            inOrOut: 'out',
            extension: 'GL_EXT_frag_depth',
            stage: 'fragment'
        }
    },
    webgl2: {
        vertexIndex: {
            name: 'gl_VertexID',
            semantic: 'vertex_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        instanceIndex: {
            name: 'gl_InstanceID',
            semantic: 'instance_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        position: {
            name: 'gl_Position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'vertex'
        },
        pointSize: {
            name: 'gl_PointSize',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'vertex'
        },
        fragCoord: {
            name: 'gl_FragCoord',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'fragment'
        },
        frontFacing: {
            name: 'gl_FrontFacing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            stage: 'fragment'
        },
        fragDepth: {
            name: 'gl_FragDepth',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'fragment'
        }
    },
    webgpu: {
        vertexIndex: {
            name: 'zVertexId',
            semantic: 'vertex_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        instanceIndex: {
            name: 'zInstanceId',
            semantic: 'instance_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        position: {
            name: 'zPosition',
            semantic: 'position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            inOrOut: 'out',
            stage: 'vertex'
        },
        fragCoord: {
            name: 'zFragCoord',
            semantic: 'position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            inOrOut: 'in',
            stage: 'fragment'
        },
        frontFacing: {
            name: 'zFrontFacing',
            semantic: 'front_facing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            inOrOut: 'in',
            stage: 'fragment'
        },
        fragDepth: {
            name: 'zFragDepth',
            semantic: 'frag_depth',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            inOrOut: 'out',
            stage: 'fragment'
        },
        localInvocationId: {
            name: 'zLocalInvocationId',
            semantic: 'local_invocation_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        globalInvocationId: {
            name: 'zGlobalInvocationId',
            semantic: 'global_invocation_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        workGroupId: {
            name: 'zWorkGroupId',
            semantic: 'workgroup_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        numWorkGroups: {
            name: 'zNumWorkGroups',
            semantic: 'num_workgroups',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        sampleMaskIn: {
            name: 'zSampleMaskIn',
            semantic: 'sample_mask_in',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'fragment'
        },
        sampleMaskOut: {
            name: 'zSampleMaskOut',
            semantic: 'sample_mask_out',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'out',
            stage: 'fragment'
        },
        sampleIndex: {
            name: 'zSampleIndex',
            semantic: 'sample_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'fragment'
        }
    }
};
function toFixed(n) {
    return n % 1 === 0 ? n.toFixed(1) : String(n);
}
function toInt(n) {
    return String(n | 0);
}
function toUint(n) {
    return String(n >>> 0);
}
function unbracket(e) {
    e = e.trim();
    if (e[0] === '(' && e[e.length - 1] === ')') {
        let match = 0;
        for(let i = 1; i < e.length - 1; i++){
            if (e[i] === '(') {
                match++;
            } else if (e[i] === ')') {
                match--;
                if (match < 0) {
                    break;
                }
            }
        }
        if (match > 0) {
            throw new PBInternalError(`Invalid expression: ${e}`);
        } else if (match === 0) {
            return e.substring(1, e.length - 1);
        }
    }
    return e;
}
/** @internal */ class ShaderAST {
    isReference() {
        return false;
    }
    isPointer() {
        return !!this.getType()?.isPointerType();
    }
    getType() {
        return null;
    }
    toWebGL(indent, ctx) {
        return '';
    }
    toWebGL2(indent, ctx) {
        return '';
    }
    toWGSL(indent, ctx) {
        return '';
    }
    toString(deviceType) {
        return this.constructor.name;
    }
}
/** @internal */ class ASTExpression extends ShaderAST {
}
/** @internal */ class ASTFunctionParameter extends ASTExpression {
    /** @internal */ paramAST;
    /** @internal */ writable;
    constructor(init){
        super();
        this.paramAST = init;
        this.writable = false;
    }
    getType() {
        return this.paramAST.getType();
    }
    markWritable() {
        if (this.paramAST instanceof ASTPrimitive) {
            console.warn(`Write to non-output parameter ${this.paramAST.value.$str}`);
        }
        this.writable = true;
    }
    isWritable() {
        return this.writable;
    }
    getAddressSpace() {
        return this.paramAST.getAddressSpace();
    }
    isConstExp() {
        return this.paramAST.isConstExp();
    }
    isReference() {
        return this.paramAST.isReference();
    }
    toWebGL(indent, ctx) {
        return this.paramAST.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.paramAST.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.paramAST.toWGSL(indent, ctx);
    }
}
/** @internal */ class ASTScope extends ShaderAST {
    statements;
    constructor(){
        super();
        this.statements = [];
    }
    toWebGL(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>stmt.toWebGL(indent, ctx)).join('');
    }
    toWebGL2(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>stmt.toWebGL2(indent, ctx)).join('');
    }
    toWGSL(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>{
            if (stmt instanceof ASTCallFunction) {
                if (!stmt.getType().isVoidType()) {
                    return `${indent}_ = ${stmt.toWGSL('', ctx)}`;
                }
            }
            return stmt.toWGSL(indent, ctx);
        }).join('');
    }
}
/** @internal */ class ASTNakedScope extends ASTScope {
    toWebGL(indent, ctx) {
        return `${indent}{\n${super.toWebGL(indent + ' ', ctx)}${indent}}\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}{\n${super.toWebGL2(indent + ' ', ctx)}${indent}}\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}{\n${super.toWGSL(indent + ' ', ctx)}${indent}}\n`;
    }
}
/** @internal */ class ASTGlobalScope extends ASTScope {
    /** @internal */ uniforms;
    constructor(){
        super();
        this.uniforms = [];
    }
    findFunctions(name) {
        const result = [];
        for (const stmt of this.statements){
            if (stmt instanceof ASTFunction && stmt.name === name) {
                result.push(stmt);
            }
        }
        return result;
    }
    toWebGL(indent, ctx) {
        // TODO: precision
        const precisions = `${indent}precision highp float;\n${indent}precision highp int;\n`;
        const version = `${indent}#version 100\n`;
        const body = ctx.types.map((val)=>val.toWebGL(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWebGL(indent, ctx)).join('') + ctx.inputs.map((input)=>input.toWebGL(indent, ctx)).join('') + ctx.outputs.map((output)=>output.toWebGL(indent, ctx)).join('') + super.toWebGL(indent, ctx);
        for (const k of ctx.builtins){
            const info = builtinVariables.webgl[k];
            if (info.extension) {
                ctx.extensions.add(info.extension);
            }
        }
        const extensions = [
            ...ctx.extensions
        ].map((s)=>`${indent}#extension ${s}: enable\n`).join('');
        const defines = ctx.defines.join('');
        return version + extensions + precisions + defines + body;
    }
    toWebGL2(indent, ctx) {
        const precisions = `${indent}precision highp float;\n${indent}precision highp int;\n`;
        const version = `${indent}#version 300 es\n`;
        const body = ctx.types.map((val)=>val.toWebGL2(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWebGL2(indent, ctx)).join('') + ctx.inputs.map((input)=>input.toWebGL2(indent, ctx)).join('') + ctx.outputs.map((output)=>output.toWebGL2(indent, ctx)).join('') + super.toWebGL2(indent, ctx);
        for (const k of ctx.builtins){
            const info = builtinVariables.webgl2[k];
            if (info.extension) {
                ctx.extensions.add(info.extension);
            }
        }
        const extensions = [
            ...ctx.extensions
        ].map((s)=>`${indent}#extension ${s}: enable\n`).join('');
        const defines = ctx.defines.join('');
        return version + extensions + precisions + defines + body;
    }
    toWGSL(indent, ctx) {
        const structNames = ctx.type === ShaderType.Vertex ? [
            BuiltinInputStructNameVS,
            BuiltinOutputStructNameVS
        ] : ctx.type === ShaderType.Fragment ? [
            BuiltinInputStructNameFS,
            BuiltinOutputStructNameFS
        ] : [
            BuiltinInputStructNameCS
        ];
        const usedBuiltins = [];
        for (const k of ctx.builtins){
            usedBuiltins.push(builtinVariables.webgpu[k].name);
        }
        const allBuiltins = Object.keys(builtinVariables.webgpu).map((val)=>builtinVariables.webgpu[val].name);
        for (const type of ctx.types){
            if (type instanceof ASTStructDefine && structNames.indexOf(type.type.structName) >= 0) {
                for(let i = type.type.structMembers.length - 1; i >= 0; i--){
                    const member = type.type.structMembers[i];
                    if (allBuiltins.indexOf(member.name) >= 0 && usedBuiltins.indexOf(member.name) < 0) {
                        type.type.structMembers.splice(i, 1);
                        type.prefix.splice(i, 1);
                    }
                }
            }
        }
        ctx.types = ctx.types.filter((val)=>!(val instanceof ASTStructDefine) || val.type.structMembers.length > 0);
        return ctx.types.map((val)=>val.toWGSL(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWGSL(indent, ctx)).join('') + super.toWGSL(indent, ctx);
    }
}
/** @internal */ class ASTPrimitive extends ASTExpression {
    /** @internal */ value;
    /** @internal */ ref;
    /** @internal */ writable;
    /** @internal */ constExp;
    constructor(value){
        super();
        this.value = value;
        this.ref = null;
        this.writable = false;
        this.constExp = false;
    }
    get name() {
        return this.value.$str;
    }
    isReference() {
        return true;
    }
    isConstExp() {
        return this.constExp;
    }
    markWritable() {
        this.writable = true;
        this.constExp = false;
        if (this.ref) {
            this.ref.markWritable();
        }
    }
    isWritable() {
        const type = this.getType();
        return this.writable || type.isAtomicI32() || type.isAtomicU32() || type.isStructType() && type.isWritable();
    }
    getAddressSpace() {
        switch(this.value.$declareType){
            case DeclareType.DECLARE_TYPE_UNIFORM:
                return PBAddressSpace.UNIFORM;
            case DeclareType.DECLARE_TYPE_STORAGE:
                return PBAddressSpace.STORAGE;
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
                return null;
            default:
                return this.value.$global ? PBAddressSpace.PRIVATE : PBAddressSpace.FUNCTION;
        }
    }
    getType() {
        return this.value.$typeinfo;
    }
    toWebGL(indent, ctx) {
        return this.name;
    }
    toWebGL2(indent, ctx) {
        return this.name;
    }
    toWGSL(indent, ctx) {
        if (this.value.$declareType === DeclareType.DECLARE_TYPE_IN) {
            const structName = getBuiltinInputStructInstanceName(ctx.type);
            return ctx.global[structName][this.name].$ast.toWGSL(indent, ctx);
        } else if (this.value.$declareType === DeclareType.DECLARE_TYPE_OUT) {
            const structName = getBuiltinOutputStructInstanceName(ctx.type);
            return ctx.global[structName][this.name].$ast.toWGSL(indent, ctx);
        } else {
            return this.name;
        }
    }
    toString(deviceType) {
        return this.name;
    }
}
/** @internal */ class ASTLValue extends ShaderAST {
}
/** @internal */ class ASTLValueScalar extends ASTLValue {
    /** @internal */ value;
    constructor(value){
        super();
        if (value.getAddressSpace() === PBAddressSpace.UNIFORM) {
            throw new PBASTError(value, 'cannot assign to uniform variable');
        }
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        return this.value.getType();
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isReference() {
        return this.value.isReference();
    }
    toWebGL(indent, ctx) {
        return this.value.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.value.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.value.toWGSL(indent, ctx);
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTLValueHash extends ASTLValue {
    /** @internal */ scope;
    /** @internal */ field;
    /** @internal */ type;
    constructor(scope, field, type){
        super();
        this.scope = scope;
        this.field = field;
        this.type = type;
    }
    getType() {
        return this.type;
    }
    markWritable() {
        this.scope.markWritable();
    }
    isWritable() {
        return this.scope.isWritable();
    }
    isReference() {
        return this.scope.isReference();
    }
    toWebGL(indent, ctx) {
        return `${this.scope.toWebGL(indent, ctx)}.${this.field}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.scope.toWebGL2(indent, ctx)}.${this.field}`;
    }
    toWGSL(indent, ctx) {
        const scope = this.scope.isPointer() ? new ASTReferenceOf(this.scope) : this.scope;
        return `${scope.toWGSL(indent, ctx)}.${this.field}`;
    }
    toString(deviceType) {
        const scope = this.scope.isPointer() ? new ASTReferenceOf(this.scope) : this.scope;
        return `${scope.toString(deviceType)}.${this.field}`;
    }
}
/** @internal */ class ASTLValueArray extends ASTLValue {
    /** @internal */ value;
    /** @internal */ index;
    /** @internal */ type;
    constructor(value, index, type){
        super();
        this.value = value;
        this.index = index;
        this.type = type;
        if (this.index instanceof ASTCallFunction) {
            this.index.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isReference() {
        return this.value.isReference();
    }
    toWebGL(indent, ctx) {
        return `${this.value.toWebGL(indent, ctx)}[${this.index.toWebGL(indent, ctx)}]`;
    }
    toWebGL2(indent, ctx) {
        return `${this.value.toWebGL2(indent, ctx)}[${this.index.toWebGL2(indent, ctx)}]`;
    }
    toWGSL(indent, ctx) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${value.toWGSL(indent, ctx)}[${this.index.toWGSL(indent, ctx)}]`;
    }
    toString(deviceType) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${value.toString(deviceType)}[${this.index.toString(deviceType)}]`;
    }
}
/** @internal */ class ASTLValueDeclare extends ASTLValue {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        this.value.constExp = true;
    }
    getType() {
        return this.value.getType();
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isReference() {
        return true;
    }
    toWebGL(indent, ctx) {
        let prefix = '';
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                prefix = this.value.constExp && !this.value.isWritable() && !this.getType().isStructType() ? 'const ' : '';
                break;
        }
        {
            return `${prefix}${this.getType().toTypeName('webgl', this.value.name)}`;
        }
    }
    toWebGL2(indent, ctx) {
        let prefix = '';
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                prefix = this.value.constExp && !this.value.isWritable() && !this.getType().isStructType() ? 'const ' : '';
                break;
        }
        {
            return `${prefix}${this.getType().toTypeName('webgl2', this.value.name)}`;
        }
    }
    toWGSL(indent, ctx) {
        let prefix;
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                {
                    const addressSpace = this.value.getAddressSpace();
                    const readonly = this.getType().isPointerType() || !this.value.isWritable() && (addressSpace === PBAddressSpace.PRIVATE || addressSpace === PBAddressSpace.FUNCTION);
                    const moduleScope = addressSpace === PBAddressSpace.PRIVATE;
                    const storageAccessMode = addressSpace === PBAddressSpace.STORAGE && this.value.isWritable() ? ', read_write' : '';
                    const decorator = addressSpace !== PBAddressSpace.FUNCTION ? `<${addressSpace}${storageAccessMode}>` : '';
                    prefix = readonly ? moduleScope ? 'const ' : 'let ' : `var${decorator} `;
                    break;
                }
        }
        {
            // const decl = this.value.value.$global ? this.getType().toTypeName('webgpu', this.value.name) : this.value.name;
            const type = this.getType();
            if (type.isPointerType() && (this.value.isWritable() || this.value.ref.isWritable())) {
                type.writable = true;
            }
            const decl = type.toTypeName('webgpu', this.value.name);
            return `${prefix}${decl}`;
        }
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTShaderExpConstructor extends ASTExpression {
    /** @internal */ type;
    /** @internal */ args;
    /** @internal */ constExp;
    constructor(type, args){
        super();
        this.type = type;
        this.args = args;
        this.constExp = true;
        for (const arg of args){
            if (arg === null || arg === undefined) {
                throw new Error('invalid constructor argument');
            }
            if (arg instanceof ASTCallFunction) {
                arg.isStatement = false;
            }
            this.constExp &&= !(arg instanceof ASTExpression) || arg.isConstExp();
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.constExp;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        console.assert(!this.type.isArrayType(), 'array constructor not supported in webgl1 device');
        console.assert(this.type.isConstructible(), `type '${this.type.toTypeName('webgl')}' is not constructible`);
        const overloads = this.type.getConstructorOverloads('webgl');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWebGL(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgl')}`);
    }
    toWebGL2(indent, ctx) {
        console.assert(this.type.isConstructible(), `type '${this.type.toTypeName('webgl2')}' is not constructible`, true);
        const overloads = this.type.getConstructorOverloads('webgl2');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWebGL2(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgl2')}`);
    }
    toWGSL(indent, ctx) {
        /*
    console.assert(
      this.type.isConstructible(),
      `type '${this.type.toTypeName('webgpu')}' is not constructible`,
      true
    );
    */ const overloads = this.type.getConstructorOverloads('webgpu');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWGSL(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgpu')}`);
    }
    toString(deviceType) {
        return 'constructor';
    }
}
/** @internal */ class ASTScalar extends ASTExpression {
    /** @internal */ value;
    /** @internal */ type;
    constructor(value, type){
        super();
        this.value = value;
        this.type = type;
        if (typeof value === 'number') {
            if (type.primitiveType === PBPrimitiveType.BOOL) {
                throw new PBTypeCastError(value, typeof value, type);
            }
            if (type.primitiveType === PBPrimitiveType.I32 && (!Number.isInteger(value) || value < 0x80000000 >> 0 || value > 0xffffffff)) {
                throw new PBTypeCastError(value, typeof value, type);
            }
            if (value < 0 && type.primitiveType === PBPrimitiveType.U32 && (!Number.isInteger(value) || value < 0 || value > 0xffffffff)) {
                throw new PBTypeCastError(value, typeof value, type);
            }
        } else if (type.primitiveType !== PBPrimitiveType.BOOL) {
            throw new PBTypeCastError(value, typeof value, type);
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return true;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return toUint(this.value);
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toWebGL2(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return `${toUint(this.value)}u`;
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toWGSL(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return `${toUint(this.value)}u`;
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toString(deviceType) {
        return `${this.value}`;
    }
}
/** @internal */ class ASTHash extends ASTExpression {
    /** @internal */ source;
    /** @internal */ field;
    /** @internal */ type;
    constructor(source, field, type){
        super();
        this.source = source;
        this.field = field;
        this.type = type;
        if (this.source instanceof ASTCallFunction) {
            this.source.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    isReference() {
        return this.source.isReference();
    }
    isConstExp() {
        return this.source.isConstExp();
    }
    markWritable() {
        this.source.markWritable();
    }
    isWritable() {
        return this.source.isWritable();
    }
    getAddressSpace() {
        return this.source.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        return `${this.source.toWebGL(indent, ctx)}.${this.field}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.source.toWebGL2(indent, ctx)}.${this.field}`;
    }
    toWGSL(indent, ctx) {
        const source = this.source.isPointer() ? new ASTReferenceOf(this.source) : this.source;
        return `${source.toWGSL(indent, ctx)}.${this.field}`;
    }
    toString(deviceType) {
        const source = this.source.isPointer() ? new ASTReferenceOf(this.source) : this.source;
        return `${source.toString(deviceType)}.${this.field}`;
    }
}
/** @internal */ class ASTCast extends ASTExpression {
    /** @internal */ sourceValue;
    /** @internal */ castType;
    constructor(source, type){
        super();
        this.sourceValue = source;
        this.castType = type;
        if (this.sourceValue instanceof ASTCallFunction) {
            this.sourceValue.isStatement = false;
        }
    }
    getType() {
        return this.castType;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.sourceValue.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgl')}(${unbracket(this.sourceValue.toWebGL(indent, ctx))})`;
        } else {
            return this.sourceValue.toWebGL(indent, ctx);
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgl2')}(${unbracket(this.sourceValue.toWebGL2(indent, ctx))})`;
        } else {
            return this.sourceValue.toWebGL2(indent, ctx);
        }
    }
    toWGSL(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgpu')}(${unbracket(this.sourceValue.toWGSL(indent, ctx))})`;
        } else {
            return this.sourceValue.toWGSL(indent, ctx);
        }
    }
    toString(deviceType) {
        return `${this.castType.toTypeName(deviceType)}(${unbracket(this.sourceValue.toString(deviceType))})`;
    }
}
/** @internal */ class ASTAddressOf extends ASTExpression {
    /** @internal */ value;
    /** @internal */ type;
    constructor(value){
        super();
        console.assert(value.isReference(), 'no pointer type for non-reference values', true);
        this.value = value;
        this.type = new PBPointerTypeInfo(value.getType(), value.getAddressSpace());
    }
    getType() {
        return this.type;
    }
    isConstExp() {
        return false;
    }
    markWritable() {
        const addressSpace = this.value.getAddressSpace();
        if (addressSpace === PBAddressSpace.UNIFORM) {
            throw new PBASTError(this.value, 'uniforms are not writable');
        }
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    getAddressSpace() {
        return this.value.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        throw new Error('GLSL does not support pointer type');
    }
    toWebGL2(indent, ctx) {
        throw new Error('GLSL does not support pointer type');
    }
    toWGSL(indent, ctx) {
        const ast = this.value instanceof ASTFunctionParameter ? this.value.paramAST : this.value;
        return ast instanceof ASTReferenceOf ? ast.value.toWGSL(indent, ctx) : `(&${ast.toWGSL(indent, ctx)})`;
    }
    toString(deviceType) {
        const ast = this.value instanceof ASTFunctionParameter ? this.value.paramAST : this.value;
        return ast instanceof ASTReferenceOf ? ast.value.toString(deviceType) : `(&${ast.toString(deviceType)})`;
    }
}
/** @internal */ class ASTReferenceOf extends ASTExpression {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        const type = this.value.getType();
        return type.isPointerType() ? type.pointerType : type;
    }
    isReference() {
        return true;
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isConstExp() {
        return false;
    }
    getAddressSpace() {
        return this.value instanceof ASTExpression ? this.value.getAddressSpace() : null;
    }
    toWebGL(indent, ctx) {
        return this.value.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.value.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.value.getType().isPointerType() ? `(*${this.value.toWGSL(indent, ctx)})` : this.value.toWGSL(indent, ctx);
    }
    toString(deviceType) {
        return `*${this.value.toString(deviceType)}`;
    }
}
/** @internal */ class ASTUnaryFunc extends ASTExpression {
    /** @internal */ value;
    /** @internal */ op;
    /** @internal */ type;
    constructor(value, op, type){
        super();
        this.value = value;
        this.op = op;
        this.type = type;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.value.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `${this.op}${this.value.toWebGL(indent, ctx)}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.op}${this.value.toWebGL2(indent, ctx)}`;
    }
    toWGSL(indent, ctx) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${this.op}${value.toWGSL(indent, ctx)}`;
    }
    toString(deviceType) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${this.op}${value.toString(deviceType)}`;
    }
}
/** @internal */ class ASTBinaryFunc extends ASTExpression {
    /** @internal */ left;
    /** @internal */ right;
    /** @internal */ type;
    /** @internal */ op;
    constructor(left, right, op, type){
        super();
        this.left = left;
        this.right = right;
        this.op = op;
        this.type = type;
        if (this.left instanceof ASTCallFunction) {
            this.left.isStatement = false;
        }
        if (this.right instanceof ASTCallFunction) {
            this.right.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.left.isConstExp() && this.right.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `(${this.left.toWebGL(indent, ctx)} ${this.op} ${this.right.toWebGL(indent, ctx)})`;
    }
    toWebGL2(indent, ctx) {
        return `(${this.left.toWebGL2(indent, ctx)} ${this.op} ${this.right.toWebGL2(indent, ctx)})`;
    }
    toWGSL(indent, ctx) {
        const left = this.left.isPointer() ? new ASTReferenceOf(this.left) : this.left;
        const right = this.right.isPointer() ? new ASTReferenceOf(this.right) : this.right;
        return `(${left.toWGSL(indent, ctx)} ${this.op} ${right.toWGSL(indent, ctx)})`;
    }
    toString(deviceType) {
        const left = this.left.isPointer() ? new ASTReferenceOf(this.left) : this.left;
        const right = this.right.isPointer() ? new ASTReferenceOf(this.right) : this.right;
        return `(${left.toString(deviceType)} ${this.op} ${right.toString(deviceType)})`;
    }
}
/** @internal */ class ASTArrayIndex extends ASTExpression {
    /** @internal */ source;
    /** @internal */ index;
    /** @internal */ type;
    constructor(source, index, type){
        super();
        this.source = source;
        this.index = index;
        this.type = type;
        if (this.source instanceof ASTCallFunction) {
            this.source.isStatement = false;
        }
        if (this.index instanceof ASTCallFunction) {
            this.index.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    isReference() {
        return this.source.isReference();
    }
    markWritable() {
        this.source.markWritable();
    }
    isWritable() {
        return this.source.isWritable();
    }
    isConstExp() {
        return this.source.isConstExp() && this.index.isConstExp();
    }
    getAddressSpace() {
        return this.source.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        return `${this.source.toWebGL(indent, ctx)}[${unbracket(this.index.toWebGL(indent, ctx))}]`;
    }
    toWebGL2(indent, ctx) {
        return `${this.source.toWebGL2(indent, ctx)}[${unbracket(this.index.toWebGL2(indent, ctx))}]`;
    }
    toWGSL(indent, ctx) {
        return `${this.source.toWGSL(indent, ctx)}[${unbracket(this.index.toWGSL(indent, ctx))}]`;
    }
    toString(deviceType) {
        return `${this.source.toString(deviceType)}[${unbracket(this.index.toString(deviceType))}]`;
    }
}
/** @internal */ class ASTTouch extends ShaderAST {
    /** @internal */ value;
    constructor(value){
        super();
        if (value.getType().isVoidType()) {
            throw new Error('can not touch void type');
        }
        if (value instanceof ASTCallFunction) {
            value.isStatement = false;
        }
        this.value = value;
    }
    toWebGL(indent, ctx) {
        return `${indent}${this.value.toWebGL('', ctx)};\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}${this.value.toWebGL2('', ctx)};\n`;
    }
    toWGSL(indent, ctx) {
        if (!this.value.getType().isVoidType()) {
            return `${indent}_ = ${this.value.toWGSL('', ctx)};\n`;
        } else {
            return `${indent}${this.value.toWGSL('', ctx)};\n`;
        }
    }
}
/** @internal */ class ASTSelect extends ASTExpression {
    /** @internal */ condition;
    /** @internal */ first;
    /** @internal */ second;
    /** @internal */ type;
    constructor(condition, first, second){
        super();
        this.condition = condition instanceof ASTExpression ? condition : new ASTScalar(condition, typeBool);
        let firstType = null;
        let secondType = null;
        if (first instanceof ASTExpression) {
            firstType = first.getType();
            this.first = first;
            if (first instanceof ASTCallFunction) {
                first.isStatement = false;
            }
        } else if (typeof first === 'number') {
            if (!Number.isInteger(first)) {
                this.first = new ASTScalar(first, typeF32$1);
                firstType = typeF32$1;
            }
        } else if (typeof first === 'boolean') {
            this.first = new ASTScalar(first, typeBool);
            firstType = typeBool;
        } else {
            throw new Error('select: invalid first value');
        }
        if (second instanceof ASTExpression) {
            secondType = second.getType();
            this.second = second;
            if (second instanceof ASTCallFunction) {
                second.isStatement = false;
            }
        } else if (typeof second === 'number') {
            if (!Number.isInteger(second)) {
                this.second = new ASTScalar(second, typeF32$1);
                secondType = typeF32$1;
            }
        } else if (typeof second === 'boolean') {
            this.second = new ASTScalar(second, typeBool);
            secondType = typeBool;
        } else {
            throw new Error('select: invalid second value');
        }
        if (!firstType && !secondType) {
            throw new Error('select: cannot determine the value types');
        }
        if (firstType && secondType) {
            if (!firstType.isCompatibleType(secondType)) {
                throw new Error('select: first value and second value must be the same type');
            } else {
                this.type = firstType;
            }
        } else if (!firstType) {
            if (secondType.typeId === typeF32$1.typeId) {
                this.first = new ASTScalar(first, typeF32$1);
            } else if (secondType.typeId === typeI32$1.typeId) {
                this.first = new ASTScalar(first, typeI32$1);
            } else if (secondType.typeId === typeU32$3.typeId) {
                this.first = new ASTScalar(first, typeU32$3);
            } else {
                throw new Error('select: invalid type of the first value');
            }
            this.type = secondType;
        } else {
            if (firstType.typeId === typeF32$1.typeId) {
                this.second = new ASTScalar(second, typeF32$1);
            } else if (firstType.typeId === typeI32$1.typeId) {
                this.second = new ASTScalar(second, typeI32$1);
            } else if (firstType.typeId === typeU32$3.typeId) {
                this.second = new ASTScalar(second, typeU32$3);
            } else {
                throw new Error('select: invalid type of the second value');
            }
            this.type = firstType;
        }
    }
    getType() {
        return this.type;
    }
    isConstExp() {
        return false;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `${indent}(${this.condition.toWebGL('', ctx)} ? ${this.first.toWebGL('', ctx)} : ${this.second.toWebGL('', ctx)})`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}(${this.condition.toWebGL2('', ctx)} ? ${this.first.toWebGL2('', ctx)} : ${this.second.toWebGL2('', ctx)})`;
    }
    toWGSL(indent, ctx) {
        return `${indent}select(${this.second.toWGSL('', ctx)}, ${this.first.toWGSL('', ctx)}, ${this.condition.toWGSL('', ctx)})`;
    //return `${indent}${this.condition.toWGSL('', ctx)} ? ${this.first.toWGSL('', ctx)} : ${this.second.toWGSL('', ctx)}`;
    }
}
/** @internal */ class ASTAssignment extends ShaderAST {
    /** @internal */ lvalue;
    /** @internal */ rvalue;
    constructor(lvalue, rvalue){
        super();
        if (!lvalue.isReference()) {
            throw new Error('assignment: l-value required');
        }
        this.lvalue = lvalue;
        this.rvalue = rvalue;
        if (!(this.lvalue instanceof ASTLValueDeclare)) {
            if (this.lvalue.getType().isPointerType()) {
                throw new PBASTError(this.lvalue, 'cannot assign to read-only variable');
            }
            this.lvalue.markWritable();
        } else if (this.lvalue.getType().isPointerType()) {
            if (this.rvalue instanceof ASTPrimitive) {
                this.lvalue.value.ref = this.rvalue.ref;
            } else if (this.rvalue instanceof ASTAddressOf) {
                this.lvalue.value.ref = this.rvalue.value;
            } else {
                throw new PBASTError(this.lvalue, 'invalid pointer assignment');
            }
        } else if (this.rvalue instanceof ASTExpression) {
            this.lvalue.value.constExp = this.rvalue.isConstExp();
        }
        if (this.rvalue instanceof ASTCallFunction) {
            this.rvalue.isStatement = false;
        }
    }
    getType() {
        return null;
    }
    toWebGL(indent, ctx) {
        let rhs = null;
        const ltype = this.lvalue.getType();
        const rtype = this.checkScalarType(this.rvalue, ltype);
        if (!ltype.isCompatibleType(rtype)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgl') : `${this.rvalue}`, rtype, ltype);
        }
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWebGL(indent, ctx));
        }
        if (this.lvalue instanceof ASTLValueDeclare) {
            this.lvalue.value.constExp &&= !(this.rvalue instanceof ASTExpression) || this.rvalue.isConstExp();
        }
        return `${indent}${this.lvalue.toWebGL(indent, ctx)} = ${rhs};\n`;
    }
    toWebGL2(indent, ctx) {
        let rhs = null;
        const ltype = this.lvalue.getType();
        const rtype = this.checkScalarType(this.rvalue, ltype);
        if (!ltype.isCompatibleType(rtype)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgl2') : `${this.rvalue}`, rtype, ltype);
        }
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWebGL2(indent, ctx));
        }
        if (this.lvalue instanceof ASTLValueDeclare) {
            this.lvalue.value.constExp &&= !(this.rvalue instanceof ASTExpression) || this.rvalue.isConstExp();
        }
        return `${indent}${this.lvalue.toWebGL2(indent, ctx)} = ${rhs};\n`;
    }
    toWGSL(indent, ctx) {
        const ltype = this.lvalue.getType();
        const [valueTypeLeft, lvalueIsPtr] = ltype.isPointerType() ? [
            ltype.pointerType,
            true
        ] : [
            ltype,
            false
        ];
        const rtype = this.checkScalarType(this.rvalue, valueTypeLeft);
        const rvalueIsPtr = rtype && rtype.isPointerType();
        const valueTypeRight = rvalueIsPtr ? rtype.pointerType : rtype;
        if (!valueTypeLeft.isCompatibleType(valueTypeRight)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgpu') : `${this.rvalue}`, rtype, ltype);
        }
        if (this.lvalue instanceof ASTLValueScalar || this.lvalue instanceof ASTLValueDeclare) {
            const structName = valueTypeLeft.isStructType() ? valueTypeLeft.structName : null;
            if (structName && ctx.types.findIndex((val)=>val instanceof ASTStructDefine && val.type.structName === structName) < 0) {
                return '';
            }
        }
        let rhs;
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWGSL(indent, ctx));
        }
        const name = this.lvalue.toWGSL(indent, ctx);
        if (lvalueIsPtr && !rvalueIsPtr) {
            if (this.lvalue instanceof ASTLValueDeclare) {
                throw new Error(`rvalue must be pointer type: ${rhs}`);
            } else {
                return `${indent}*(${name}) = ${rhs};\n`;
            }
        } else if (rvalueIsPtr && !lvalueIsPtr) {
            return `${indent}${name} = *(${rhs});\n`;
        } else {
            return `${indent}${name} = ${rhs};\n`;
        }
    }
    checkScalarType(value, targetType) {
        if (value instanceof ASTExpression) {
            return value.getType();
        }
        const isBool = typeof value === 'boolean';
        const isInt = typeof value === 'number' && Number.isInteger(value) && value >= 0x80000000 >> 0 && value <= 0x7fffffff;
        const isUint = typeof value === 'number' && Number.isInteger(value) && value >= 0 && value <= 0xffffffff;
        const isFloat = typeof value === 'number';
        if (targetType.isPrimitiveType()) {
            switch(targetType.primitiveType){
                case PBPrimitiveType.BOOL:
                    return isBool ? targetType : isInt ? typeI32$1 : isUint ? typeU32$3 : typeF32$1;
                case PBPrimitiveType.F32:
                    return isFloat ? targetType : typeBool;
                case PBPrimitiveType.I32:
                    return isInt ? targetType : isBool ? typeBool : isUint ? typeU32$3 : typeF32$1;
                case PBPrimitiveType.U32:
                    return isUint ? targetType : isBool ? typeBool : isInt ? typeI32$1 : typeF32$1;
                default:
                    return null;
            }
        } else {
            return isBool ? typeBool : isInt ? typeI32$1 : isUint ? typeU32$3 : typeF32$1;
        }
    }
}
/** @internal */ class ASTDiscard extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}discard;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}discard;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}discard;\n`;
    }
}
/** @internal */ class ASTBreak extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}break;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}break;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}break;\n`;
    }
}
/** @internal */ class ASTContinue extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}continue;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}continue;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}continue;\n`;
    }
}
/** @internal */ class ASTReturn extends ShaderAST {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWebGL(indent, ctx))};\n` : `${indent}return;\n`;
    }
    toWebGL2(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWebGL2(indent, ctx))};\n` : `${indent}return;\n`;
    }
    toWGSL(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWGSL(indent, ctx))};\n` : `${indent}return;\n`;
    }
}
/** @internal */ class ASTCallFunction extends ASTExpression {
    /** @internal */ name;
    /** @internal */ args;
    /** @internal */ retType;
    /** @internal */ func;
    /** @internal */ isStatement;
    constructor(name, args, func, deviceType, retType){
        super();
        this.name = name;
        this.args = args;
        this.retType = func?.returnType ?? retType ?? typeVoid;
        this.func = func;
        this.isStatement = true;
        if (func) {
            if (func.funcType.argTypes.length !== this.args.length) {
                throw new PBInternalError(`ASTCallFunction(): number of parameters mismatch`);
            }
            for(let i = 0; i < this.args.length; i++){
                const funcArg = func.funcType.argTypes[i];
                if (funcArg.byRef) {
                    if (deviceType === 'webgpu') {
                        const argAddressSpace = args[i].getAddressSpace();
                        if (argAddressSpace !== PBAddressSpace.FUNCTION && argAddressSpace !== PBAddressSpace.PRIVATE) {
                            throw new PBParamTypeError(name, 'pointer type of function parameter must be function or private');
                        }
                        const argType = funcArg.type;
                        if (!argType.isPointerType()) {
                            throw new PBInternalError(`ASTCallFunction(): invalid reference type`);
                        }
                        if (argType.addressSpace === PBAddressSpace.UNKNOWN) {
                            argType.addressSpace = argAddressSpace;
                        } else if (argType.addressSpace !== argAddressSpace) {
                            throw new PBParamTypeError(name, `invalid pointer parameter address space '${argAddressSpace}', should be '${argType.addressSpace}`);
                        }
                    }
                    this.args[i].markWritable();
                }
            }
        }
        for (const arg of this.args){
            if (arg instanceof ASTCallFunction) {
                arg.isStatement = false;
            }
        }
    }
    getType() {
        return this.retType;
    }
    isConstExp() {
        return false;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        if (this.name === 'dFdx' || this.name === 'dFdy' || this.name === 'fwidth') {
            ctx.extensions.add('GL_OES_standard_derivatives');
        } else if (this.name === 'texture2DLodEXT' || this.name === 'texture2DProjLodEXT' || this.name === 'textureCubeLodEXT' || this.name === 'texture2DGradEXT' || this.name === 'texture2DProjGradEXT' || this.name === 'textureCubeGradEXT') {
            ctx.extensions.add('GL_EXT_shader_texture_lod');
        }
        const args = this.args.map((arg)=>unbracket(arg.toWebGL(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toWebGL2(indent, ctx) {
        const args = this.args.map((arg)=>unbracket(arg.toWebGL2(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toWGSL(indent, ctx) {
        let thisArgs = this.args;
        if (this.func) {
            let argsNew;
            const convertedArgs = convertArgs(thisArgs, this.func.funcType);
            if (convertedArgs) {
                argsNew = convertedArgs.args;
            }
            if (!argsNew) {
                throw new Error(`no matching overloading found for function '${this.name}'`);
            }
            thisArgs = argsNew.filter((val)=>{
                const type = val.getType();
                if (type.isStructType() && ctx.types.findIndex((t)=>t instanceof ASTStructDefine && t.type.structName === type.structName) < 0) {
                    return false;
                }
                return true;
            });
        }
        const args = thisArgs.map((arg)=>unbracket(arg.toWGSL(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toString(deviceType) {
        return `${this.name}(...)`;
    }
}
/** @internal */ class ASTDeclareVar extends ShaderAST {
    /** @internal */ value;
    /** @internal */ group;
    /** @internal */ binding;
    /** @internal */ blockName;
    constructor(exp){
        super();
        this.value = exp;
        this.group = 0;
        this.binding = 0;
    }
    isReference() {
        return true;
    }
    isPointer() {
        return this.value.getType().isPointerType();
    }
    toWebGL(indent, ctx) {
        let prefix = '';
        let builtin = false;
        let valueType = this.value.getType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
                if (ctx.type === ShaderType.Vertex) {
                    prefix = 'attribute ';
                    ctx.defines.push(`#define ${this.value.name} ${semanticToAttrib(ctx.vertexAttributes[this.value.value.$location])}\n`);
                } else {
                    prefix = 'varying ';
                // ctx.defines.push(`#define ${this.value.$str} ch_varying_${this.value.$location}\n`);
                }
                break;
            case DeclareType.DECLARE_TYPE_OUT:
                if (ctx.type === ShaderType.Vertex) {
                    prefix = 'varying ';
                // ctx.defines.push(`#define ${this.value.$str} ch_varying_${this.value.$location}\n`);
                } else {
                    builtin = true;
                    if (ctx.mrt) {
                        ctx.defines.push(`#define ${this.value.name} gl_FragData[${this.value.value.$location}]\n`);
                        ctx.extensions.add('GL_EXT_draw_buffers');
                    } else {
                        ctx.defines.push(`#define ${this.value.name} gl_FragColor\n`);
                    }
                }
                break;
            case DeclareType.DECLARE_TYPE_UNIFORM:
                prefix = 'uniform ';
                valueType = ctx.typeReplacement?.get(this.value.value) || valueType;
                break;
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error(`invalid variable declare type: ${this.value.name}`);
        }
        if (!builtin) {
            return `${indent}${prefix}${valueType.toTypeName('webgl', this.value.name)};\n`;
        }
    }
    toWebGL2(indent, ctx) {
        let prefix = '';
        let valueType = this.value.getType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
                if (ctx.type === ShaderType.Fragment && valueType.isPrimitiveType() && valueType.isInteger()) {
                    prefix = 'flat in ';
                } else {
                    prefix = 'in ';
                }
                if (ctx.type === ShaderType.Vertex) {
                    ctx.defines.push(`#define ${this.value.name} ${semanticToAttrib(ctx.vertexAttributes[this.value.value.$location])}\n`);
                }
                break;
            case DeclareType.DECLARE_TYPE_OUT:
                if (ctx.type === ShaderType.Vertex) {
                    if (valueType.isPrimitiveType() && valueType.isInteger()) {
                        prefix = 'flat out ';
                    } else {
                        prefix = 'out ';
                    }
                } else {
                    prefix = `layout(location = ${this.value.value.$location}) out `;
                }
                break;
            case DeclareType.DECLARE_TYPE_UNIFORM:
                if (valueType.isStructType()) {
                    /*
          if (valueType.layout !== 'std140') {
            throw new errors.PBASTError(this, 'uniform buffer layout must be std140');
          }
          */ return `${indent}layout(std140) uniform ${this.blockName} { ${valueType.structName} ${this.value.name}; };\n`;
                } else {
                    valueType = ctx.typeReplacement?.get(this.value.value) || valueType;
                    return `${indent}uniform ${valueType.toTypeName('webgl2', this.value.name)};\n`;
                }
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error(`invalid variable declare type: ${this.value.name}`);
        }
        {
            return `${indent}${prefix}${this.value.getType().toTypeName('webgl2', this.value.name)};\n`;
        }
    }
    toWGSL(indent, ctx) {
        let prefix;
        const isBlock = this.value.getType().isPrimitiveType() || this.value.getType().isStructType() || this.value.getType().isArrayType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
                // prefix = `@location(${this.value.value.$location}) var<out> `;
                throw new Error(`Internal error`);
            case DeclareType.DECLARE_TYPE_UNIFORM:
                if (this.group === undefined) {
                    debugger;
                }
                prefix = `@group(${this.group}) @binding(${this.binding}) var${isBlock ? '<uniform>' : ''} `;
                break;
            case DeclareType.DECLARE_TYPE_STORAGE:
                prefix = `@group(${this.group}) @binding(${this.binding}) var<storage, ${this.value.isWritable() ? 'read_write' : 'read'}> `;
                break;
            case DeclareType.DECLARE_TYPE_WORKGROUP:
                prefix = `var<workgroup> `;
                break;
            default:
                prefix = `${this.value.getType().isPointerType() ? 'let' : 'var'}${this.value.value.$global && !this.value.getType().isPointerType() ? '<private>' : ''} `;
        }
        {
            const type = this.value.getType();
            const structName = type.isStructType() ? type.structName : null;
            if (structName && ctx.types.findIndex((val)=>val instanceof ASTStructDefine && val.type.structName === structName) < 0) {
                return '';
            } else {
                return `${indent}${prefix}${type.toTypeName('webgpu', this.value.name)};\n`;
            }
        }
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTFunction extends ASTScope {
    /** @internal */ name;
    /** @internal */ args;
    /** @internal */ isBuiltin;
    /** @internal */ isMainFunc;
    /** @internal */ funcType;
    /** @internal */ builtins;
    /** @internal */ returnType;
    constructor(name, args, isMainFunc, type, isBuiltin = false){
        super();
        this.name = name;
        this.args = args;
        this.funcType = type;
        this.builtins = [];
        this.isBuiltin = isBuiltin;
        this.isMainFunc = isMainFunc;
        this.returnType = type ? type.returnType : null;
    }
    toWebGL(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [];
            for (const param of this.args){
                let exp;
                let name;
                let qualifier;
                if (param.paramAST instanceof ASTPrimitive) {
                    exp = param.paramAST.value;
                    name = param.paramAST.name;
                    qualifier = '';
                } else {
                    exp = param.paramAST.value.value;
                    name = param.paramAST.value.name;
                    qualifier = `${exp.$inout} `;
                }
                p.push(`${qualifier}${param.getType().toTypeName('webgl', name)}`);
            }
            str += `${indent}${this.returnType.toTypeName('webgl')} ${this.name}(${p.join(',')}) {\n`;
            str += super.toWebGL(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [];
            for (const param of this.args){
                let exp;
                let name;
                let qualifier;
                if (param.paramAST instanceof ASTPrimitive) {
                    exp = param.paramAST.value;
                    name = param.paramAST.name;
                    qualifier = '';
                } else {
                    exp = param.paramAST.value.value;
                    name = param.paramAST.value.name;
                    qualifier = `${exp.$inout} `;
                }
                p.push(`${qualifier}${param.getType().toTypeName('webgl2', name)}`);
            }
            str += `${indent}${this.returnType.toTypeName('webgl2')} ${this.name}(${p.join(',')}) {\n`;
            str += super.toWebGL2(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
    toWGSL(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [
                ...this.builtins
            ];
            for (const param of this.args){
                const name = param.paramAST instanceof ASTPrimitive ? param.paramAST.name : param.paramAST.value.name;
                const paramType = param.paramAST instanceof ASTPrimitive ? param.paramAST.getType() : param.paramAST.value.getType();
                const dataType = paramType.isPointerType() ? paramType.pointerType : paramType;
                if (dataType.isStructType() && ctx.types.findIndex((t)=>t instanceof ASTStructDefine && t.type.structName === dataType.structName) < 0) {
                    continue;
                }
                p.push(`${paramType.toTypeName('webgpu', name)}`);
            }
            let t = '';
            if (this.isMainFunc) {
                switch(ctx.type){
                    case ShaderType.Vertex:
                        t = '@vertex ';
                        break;
                    case ShaderType.Fragment:
                        t = '@fragment ';
                        break;
                    case ShaderType.Compute:
                        t = `@compute @workgroup_size(${ctx.workgroupSize[0]}, ${ctx.workgroupSize[1]}, ${ctx.workgroupSize[2]}) `;
                        break;
                }
            }
            const retName = this.returnType.isVoidType() ? null : this.returnType.toTypeName('webgpu');
            const retStr = retName ? ` -> ${retName}` : '';
            str += `${indent}${t}fn ${this.name}(${p.join(',')})${retStr} {\n`;
            str += super.toWGSL(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
}
/** @internal */ class ASTIf extends ASTScope {
    /** @internal */ keyword;
    /** @internal */ condition;
    /** @internal */ nextElse;
    constructor(keyword, condition){
        super();
        this.keyword = keyword;
        this.condition = condition;
        this.nextElse = null;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWebGL(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWebGL(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWebGL(indent, ctx);
        }
        return str;
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWebGL2(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWebGL2(indent, ctx);
        }
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWGSL(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWGSL(indent, ctx);
        }
        return str;
    }
}
/** @internal */ class ASTRange extends ASTScope {
    /** @internal */ init;
    /** @internal */ start;
    /** @internal */ end;
    /** @internal */ open;
    constructor(init, start, end, open){
        super();
        this.init = init;
        this.start = start;
        this.end = end;
        this.open = open;
        this.statements = [];
        if (this.start instanceof ASTCallFunction) {
            this.start.isStatement = false;
        }
        if (this.end instanceof ASTCallFunction) {
            this.end.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        const init = this.init.getType().toTypeName('webgl', this.init.name);
        const start = unbracket(this.start.toWebGL(indent, ctx));
        const end = unbracket(this.end.toWebGL(indent, ctx));
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name}++) {\n`;
        str += super.toWebGL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWebGL2(indent, ctx) {
        const init = this.init.getType().toTypeName('webgl2', this.init.name);
        const start = unbracket(this.start.toWebGL2(indent, ctx));
        const end = unbracket(this.end.toWebGL2(indent, ctx));
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name}++) {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        const init = `var ${this.init.getType().toTypeName('webgpu', this.init.name)}`;
        const start = unbracket(this.start.toWGSL(indent, ctx));
        const end = unbracket(this.end.toWGSL(indent, ctx));
        const incr = new ASTScalar(1, this.init.getType()).toWGSL(indent, ctx);
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name} = ${this.init.name} + ${incr}) {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
}
/** @internal */ class ASTDoWhile extends ASTScope {
    /** @internal */ condition;
    constructor(condition){
        super();
        this.condition = condition;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        throw new Error(`No do-while() loop support for WebGL1.0 device`);
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}do {\n`;
        str += super.toWebGL2(indent + ' ', ctx);
        str += `${indent}} while(${unbracket(this.condition.toWebGL2(indent, ctx))});\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}loop {\n`;
        str += super.toWGSL(indent + ' ', ctx);
        str += `${indent}  if (!(${unbracket(this.condition.toWGSL(indent, ctx))})) { break; }\n`;
        str += `${indent}}\n`;
        return str;
    }
}
/** @internal */ class ASTWhile extends ASTScope {
    /** @internal */ condition;
    constructor(condition){
        super();
        this.condition = condition;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        let str = `${indent}for(int z_tmp_counter = 0; z_tmp_counter == 0; z_tmp_counter += 0) {\n`;
        const indent2 = indent + '  ';
        str += `${indent2}if(!(${unbracket(this.condition.toWebGL(indent, ctx))})){ break; }\n`;
        str += super.toWebGL(indent2, ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}while(${unbracket(this.condition.toWebGL2(indent, ctx))}) {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}for(;${unbracket(this.condition.toWGSL(indent, ctx))};) {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    /*
    let str = `${indent}loop {\n`;
    const newIndent = indent + '  ';
    str += `${newIndent}if (!(${unbracket(this.condition.toWGSL(indent, ctx))})) { break; }\n`;
    str += super.toWGSL(newIndent, ctx);
    str += `${indent}}\n`;
    return str;
    */ }
}
/** @internal */ class ASTStructDefine extends ShaderAST {
    /** @internal */ type;
    /** @internal */ prefix;
    /** @internal */ builtin;
    constructor(type, builtin){
        super();
        this.prefix = null;
        this.builtin = builtin;
        this.type = type;
    }
    getType() {
        return this.type;
    }
    toWebGL(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            for (const arg of this.type.structMembers){
                str += `${indent}  ${arg.type.toTypeName('webgl', arg.name)};\n`;
            }
            str += `${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            for (const arg of this.type.structMembers){
                str += `${indent}  ${arg.type.toTypeName('webgl2', arg.name)};\n`;
            }
            str += `${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
    toWGSL(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            str += this.type.structMembers.map((arg, i)=>{
                const prefix = this.prefix ? this.prefix[i] : '';
                const sizePrefix = arg.type.getLayoutSize(this.type.layout) !== arg.type.getLayoutSize('default') ? `@size(${arg.type.getLayoutSize(this.type.layout)}) ` : '';
                const alignPrefix = i > 0 && arg.type.getLayoutAlignment(this.type.layout) !== arg.type.getLayoutAlignment('default') ? `@align(${arg.type.getLayoutAlignment(this.type.layout)}) ` : '';
                return `${indent}  ${prefix}${alignPrefix}${sizePrefix}${arg.type.toTypeName('webgpu', arg.name)}`;
            }).join(',\n');
            str += `\n${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
}
function convertArgs(args, overload) {
    if (args.length !== overload.argTypes.length) {
        return null;
    }
    const result = [];
    for(let i = 0; i < args.length; i++){
        const isRef = !!overload.argTypes[i].byRef;
        const argType = isRef ? overload.argTypes[i].type.pointerType : overload.argTypes[i].type;
        const arg = args[i];
        if (typeof arg === 'number') {
            if (!isRef && argType.isPrimitiveType() && argType.isScalarType() && argType.primitiveType !== PBPrimitiveType.BOOL) {
                result.push(new ASTScalar(arg, argType));
            } else {
                return null;
            }
        } else if (typeof arg === 'boolean') {
            if (!isRef && argType.isPrimitiveType() && argType.primitiveType === PBPrimitiveType.BOOL) {
                result.push(new ASTScalar(arg, argType));
            } else {
                return null;
            }
        } else if (argType.isCompatibleType(arg.getType())) {
            if (isRef) {
                arg.markWritable();
                result.push(new ASTAddressOf(arg));
            } else {
                result.push(arg);
            }
        } else {
            return null;
        }
    }
    return {
        name: overload.name,
        args: result
    };
}

/**
 * Reflection interface for program builder
 * @public
 */ class PBReflection {
    /** @internal */ _builder;
    /** @internal */ _tagList;
    /** @internal */ _attribList;
    constructor(builder){
        this._builder = builder;
        this._tagList = {};
        this._attribList = {};
    }
    /** Gets all the vertex attributes that was used by the program */ get vertexAttributes() {
        return this._builder.getVertexAttributes();
    }
    /**
   * Check if specified vertex attribute was used by the program
   * @param attrib - The vertex attribute to check
   */ hasVertexAttribute(attrib) {
        return this.vertexAttributes.indexOf(attrib) >= 0;
    }
    /**
   * Clear all contents
   */ clear() {
        this._tagList = {};
        this._attribList = {};
    }
    tag(arg0, arg1) {
        if (typeof arg0 === 'string') {
            if (arg1 === undefined) {
                return this.getTag(arg0);
            } else {
                this.addTag(arg0, arg1);
            }
        } else {
            for (const k of Object.keys(arg0)){
                this.addTag(k, arg0[k]);
            }
        }
    }
    /**
   * Gets the variable which is the vertex attribute of specified semantic
   * @param attrib - The vertex semantic
   */ attribute(attrib) {
        return this._attribList[attrib] || null;
    }
    /** @internal */ setAttrib(attrib, exp) {
        this._attribList[attrib] = exp;
    }
    /** @internal */ addTag(name, exp) {
        this._tagList[name] = exp;
    }
    /** @internal */ getTag(name) {
        const getter = this._tagList[name];
        return getter ? getter(this._builder.getGlobalScope()) : null;
    }
}

let currentProgramBuilder = null;
const constructorCache = new Map();
/** @internal */ function setCurrentProgramBuilder(pb) {
    currentProgramBuilder = pb;
}
/** @internal */ function getCurrentProgramBuilder() {
    return currentProgramBuilder;
}
/** @internal */ function makeConstructor(typeFunc, elementType) {
    const wrappedTypeFunc = new Proxy(typeFunc, {
        get: function(target, prop) {
            if (typeof prop === 'symbol' || prop in target) {
                return target[prop];
            }
            let entries = constructorCache.get(typeFunc);
            if (!entries) {
                entries = {};
                constructorCache.set(typeFunc, entries);
            }
            let ctor = entries[prop];
            if (!ctor) {
                if (elementType.isPrimitiveType() || elementType.isStructType() || elementType.isArrayType()) {
                    if (prop === 'ptr') {
                        const pointerType = new PBPointerTypeInfo(elementType, PBAddressSpace.FUNCTION);
                        ctor = function pointerCtor(...args) {
                            if (args.length === 1 && typeof args[0] === 'string') {
                                return new PBShaderExp(args[0], pointerType);
                            } else {
                                throw new Error(`Invalid pointer type constructor`);
                            }
                        };
                    } else {
                        const dim = Number(prop);
                        if (Number.isInteger(dim) && dim >= 0) {
                            const arrayType = new PBArrayTypeInfo(elementType, dim);
                            const arrayTypeFunc = function arrayCtor(...args) {
                                if (args.length === 1 && typeof args[0] === 'string') {
                                    return new PBShaderExp(args[0], arrayType);
                                } else {
                                    const exp = new PBShaderExp('', arrayType);
                                    exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, args.map((arg)=>arg instanceof PBShaderExp ? arg.$ast : arg));
                                    return exp;
                                }
                            };
                            ctor = makeConstructor(arrayTypeFunc, arrayType);
                        }
                    }
                }
            }
            if (ctor) {
                entries[prop] = ctor;
            }
            return ctor;
        }
    });
    return wrappedTypeFunc;
}
/**
 * Base class for proxiable object
 * @public
 */ class Proxiable {
    /** @internal */ proxy;
    constructor(){
        this.proxy = new Proxy(this, {
            get: function(target, prop) {
                return typeof prop === 'string' ? target.$get(prop) : undefined;
            },
            set: function(target, prop, value) {
                return typeof prop === 'string' ? target.$set(prop, value) : false;
            }
        });
        return this.proxy;
    }
    get $thisProxy() {
        return this.proxy;
    }
}
let uidExp = 0;
/**
 * Base class for a expression in the shader
 * @public
 */ class PBShaderExp extends Proxiable {
    /** @internal */ $uid;
    /** @internal */ $str;
    /** @internal */ $location;
    /** @internal */ $typeinfo;
    /** @internal */ $global;
    /** @internal */ $sampleType;
    /** @internal */ $precision;
    /** @internal */ $ast;
    /** @internal */ $inout;
    /** @internal */ $memberCache;
    /** @internal */ $attrib;
    /** @internal */ $tags;
    /** @internal */ $_group;
    /** @internal */ $declareType;
    /** @internal */ $isBuffer;
    /** @internal */ constructor(str, typeInfo){
        super();
        if (!str && typeInfo.isPointerType()) {
            throw new Error('no default constructor for pointer type');
        }
        this.$uid = uidExp++;
        this.$str = str || '';
        this.$location = 0;
        this.$global = false;
        this.$typeinfo = typeInfo;
        this.$qualifier = null;
        this.$precision = ShaderPrecisionType.NONE;
        this.$ast = new ASTPrimitive(this);
        this.$inout = null;
        this.$memberCache = {};
        this.$attrib = null;
        this.$tags = [];
        this.$_group = null;
        this.$declareType = DeclareType.DECLARE_TYPE_NONE;
        this.$isBuffer = false;
        if (typeInfo.isTextureType()) {
            if (typeInfo.isDepthTexture()) {
                this.$sampleType = 'depth';
            } else {
                const t = getTextureSampleType(typeInfo);
                if (t.primitiveType === PBPrimitiveType.I32) {
                    this.$sampleType = 'sint';
                } else if (t.primitiveType === PBPrimitiveType.U32) {
                    this.$sampleType = 'uint';
                } else {
                    this.$sampleType = 'float';
                }
            }
        }
    }
    get $group() {
        return this.$_group;
    }
    set $group(val) {
        this.$_group = val;
        if (this.$_group === undefined) {
            debugger;
        }
    }
    /**
   * Point out that the variable should be in uniform address space
   * @param group - The bind group index
   * @returns self
   */ uniform(group) {
        this.$declareType = DeclareType.DECLARE_TYPE_UNIFORM;
        this.$group = group;
        this.$isBuffer = false;
        return this;
    }
    /**
   * Point out that the variable should be an uniform buffer
   * @param group - The bind group index
   * @returns self
   */ uniformBuffer(group) {
        if (!this.$typeinfo.isPrimitiveType() && !this.$typeinfo.isArrayType() && !this.$typeinfo.isStructType()) {
            throw new PBASTError(this.$ast, 'only primitive type, array type or structure type can be set as uniform buffer');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_UNIFORM;
        this.$group = group;
        this.$isBuffer = true;
        return this;
    }
    /**
   * Point out that the variable should be in workgroup address space
   *
   * @remarks
   * WebGPU device only
   *
   * @returns self
   */ workgroup() {
        this.$declareType = DeclareType.DECLARE_TYPE_WORKGROUP;
        return this;
    }
    /**
   * Point out that the variable should be in storage address space
   * @param group - The bind group index
   * @returns self
   */ storage(group) {
        if (!this.$typeinfo.isHostSharable()) {
            throw new PBASTError(this.$ast, 'type cannot be declared in storage address space');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_STORAGE;
        this.$group = group;
        this.$isBuffer = false;
        return this;
    }
    /**
   * Point out that the variable should be a storage buffer
   * @param group - The bind group index
   * @returns self
   */ storageBuffer(group) {
        if (!this.$typeinfo.isPrimitiveType() && !this.$typeinfo.isArrayType() && !this.$typeinfo.isStructType()) {
            throw new PBASTError(this.$ast, 'only primitive type, array type or structure type can be set as storage buffer');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_STORAGE;
        this.$group = group;
        this.$isBuffer = true;
        return this;
    }
    inout() {
        this.$inout = 'inout';
        return this;
    }
    out() {
        this.$inout = 'out';
        return this;
    }
    /**
   * Point out that the variable is a input vertex attribute
   * @param attr - The vertex semantic
   * @returns self
   */ attrib(attr) {
        this.$declareType = DeclareType.DECLARE_TYPE_IN;
        this.$attrib = attr;
        return this;
    }
    /**
   * Create tags for the variable
   * @param args - tags
   * @returns self
   */ tag(...args) {
        args.forEach((val)=>{
            if (this.$tags.indexOf(val) < 0) {
                this.$tags.push(val);
            }
        });
        return this;
    }
    /**
   * Set sample type for the variable if the variable is of type texture
   * @param type - sample type
   * @returns self
   */ sampleType(type) {
        if (type) {
            this.$sampleType = type;
        }
        return this;
    }
    /**
   * Get element in the array by index
   * @param index - index of the element
   * @returns the element variable
   */ at(index) {
        const varType = this.$ast.getType();
        if (!varType.isArrayType() && (!varType.isPrimitiveType() || !varType.isVectorType() && !varType.isMatrixType())) {
            throw new Error('at() function must be used with array types');
        }
        let elementType = null;
        let dimension;
        if (varType.isArrayType()) {
            elementType = varType.elementType;
            dimension = varType.dimension;
        } else if (varType.isVectorType()) {
            elementType = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, 1));
            dimension = varType.cols;
        } else if (varType.isMatrixType()) {
            elementType = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
            dimension = varType.rows;
        }
        const result = new PBShaderExp('', elementType);
        if (typeof index === 'number') {
            if (!Number.isInteger(index)) {
                throw new Error('at() array index must be integer type');
            }
            if (index < 0 || dimension > 0 && index >= dimension) {
                throw new Error('at() array index out of bounds');
            }
            result.$ast = new ASTArrayIndex(this.$ast, new ASTScalar(index, typeI32$1), elementType);
        } else {
            const type = index.$ast.getType();
            if (!type.isPrimitiveType() || !type.isScalarType()) {
                throw new Error('at() array index must be scalar type');
            }
            let ast = index.$ast;
            if (type.scalarType !== PBPrimitiveType.I32 && type.scalarType !== PBPrimitiveType.U32) {
                ast = new ASTCast(ast, typeI32$1);
            }
            result.$ast = new ASTArrayIndex(this.$ast, ast, elementType);
        }
        return result;
    }
    /**
   * Set element in the array by index
   * @param index - index of the element
   * @param val - value to set
   */ setAt(index, val) {
        const varType = this.$ast.getType();
        if (!varType.isArrayType()) {
            throw new Error('setAt() function must be used with array types');
        }
        if (typeof index === 'number') {
            if (!Number.isInteger(index)) {
                throw new Error('setAt() array index must be integer type');
            }
            if (index < 0 || varType.dimension > 0 && index >= varType.dimension) {
                throw new Error('setAt() array index out of bounds');
            }
        }
        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), typeof index === 'number' ? new ASTScalar(index, typeI32$1) : index.$ast, varType.elementType), val instanceof PBShaderExp ? val.$ast : val));
    }
    /**
   * Point out that the variable should be in high precision
   * @returns self
   */ highp() {
        this.$precision = ShaderPrecisionType.HIGH;
        return this;
    }
    /**
   * Points out that the variable should be in medium precision
   * @returns self
   */ mediump() {
        this.$precision = ShaderPrecisionType.MEDIUM;
        return this;
    }
    /**
   * Points out that the variable should be in low precision
   * @returns self
   */ lowp() {
        this.$precision = ShaderPrecisionType.LOW;
        return this;
    }
    /**
   * Whether this is a constructor
   * @returns true if this is a constructor
   */ isConstructor() {
        return this.$ast instanceof ASTShaderExpConstructor && this.$ast.args.length === 0;
    }
    /**
   * Determine if this variable is of vector type
   * @returns true if the variable is of vector type, otherwise false
   */ isVector() {
        const varType = this.$ast.getType();
        return varType.isPrimitiveType() && varType.isVectorType();
    }
    /**
   * Get vector component count of the variable if this variable is of vector type
   * @returns the vector component count
   */ numComponents() {
        const varType = this.$ast.getType();
        return varType.isPrimitiveType() ? varType.cols : 0;
    }
    /**
   * Get type name of this variable
   * @returns The type name of this variable
   */ getTypeName() {
        return this.$ast.getType().toTypeName(currentProgramBuilder.getDevice().type);
    }
    /** @internal */ $get(prop) {
        if (typeof prop === 'string') {
            if (prop[0] === '$' || prop in this) {
                return this[prop];
            } else {
                let exp = this.$memberCache[prop];
                if (!exp) {
                    const varType = this.$ast?.getType() || this.$typeinfo;
                    const num = Number(prop);
                    if (Number.isNaN(num)) {
                        if (varType.isStructType()) {
                            const elementIndex = varType.structMembers.findIndex((val)=>val.name === prop);
                            if (elementIndex < 0) {
                                throw new Error(`unknown struct member '${prop}'`);
                            }
                            const element = varType.structMembers[elementIndex];
                            if (element.type.isStructType()) {
                                const ctor = currentProgramBuilder.structInfo.structs[element.type.structName];
                                exp = ctor.call(currentProgramBuilder, `${this.$str}.${prop}`);
                            } else {
                                exp = new PBShaderExp(`${this.$str}.${prop}`, element.type);
                            }
                            exp.$ast = new ASTHash(this.$ast, prop, element.type);
                        } else {
                            if (!varType.isPrimitiveType() || !varType.isVectorType()) {
                                throw new Error(`invalid index operation: ${this.$ast.toString(currentProgramBuilder.getDevice().type)}[${prop}]`);
                            }
                            if (prop.length === 0 || prop.length > 4 || [
                                ...prop
                            ].some((val)=>'xyzw'.slice(0, varType.cols).indexOf(val) < 0) && [
                                ...prop
                            ].some((val)=>'rgba'.slice(0, varType.cols).indexOf(val) < 0)) {
                                throw new Error(`unknown swizzle target: ${this.$ast.toString(currentProgramBuilder.getDevice().type)}[${prop}]`);
                            }
                            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, prop.length));
                            exp = new PBShaderExp('', type);
                            exp.$ast = new ASTHash(this.$ast, prop, type);
                        }
                    } else {
                        if (varType.isArrayType()) {
                            exp = this.at(num);
                        } else if (varType.isPrimitiveType() && varType.isVectorType()) {
                            if (num >= varType.cols) {
                                throw new Error(`component index out of bounds: ${this.$str}[${num}]`);
                            }
                            exp = this.$get('xyzw'[num]);
                        } else if (varType.isPrimitiveType() && varType.isMatrixType()) {
                            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
                            exp = new PBShaderExp('', type);
                            exp.$ast = new ASTArrayIndex(this.$ast, new ASTScalar(num, typeI32$1), type);
                        } else {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                    }
                    this.$memberCache[prop] = exp;
                }
                return exp;
            }
        } else {
            return undefined;
        }
    }
    /** @internal */ $set(prop, value) {
        if (typeof prop === 'string') {
            if (prop[0] === '$' || prop in this) {
                this[prop] = value;
            } else {
                if (typeof value !== 'number' && typeof value !== 'boolean' && !(value instanceof PBShaderExp)) {
                    throw new Error(`Invalid output value assignment`);
                }
                const varType = this.$ast?.getType() || this.$typeinfo;
                const num = Number(prop);
                if (Number.isNaN(num)) {
                    if (varType.isStructType()) {
                        const elementIndex = varType.structMembers.findIndex((val)=>val.name === prop);
                        if (elementIndex < 0) {
                            throw new Error(`unknown struct member '${prop}`);
                        }
                        const element = varType.structMembers[elementIndex];
                        let dstAST;
                        if (typeof value === 'number' || typeof value === 'boolean') {
                            if (!element.type.isPrimitiveType() || !element.type.isScalarType()) {
                                throw new Error(`can not set struct member '${prop}: invalid value type`);
                            }
                            dstAST = new ASTScalar(value, element.type);
                        } else if (value instanceof PBShaderExp) {
                            dstAST = value.$ast;
                        }
                        if (!dstAST) {
                            throw new Error(`can not set struct member '${prop}: invalid value type`);
                        }
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, element.type), dstAST));
                    } else {
                        // FIXME: WGSL does not support l-value swizzling
                        if (prop.length > 1 || 'xyzw'.indexOf(prop) < 0 && 'rgba'.indexOf(prop) < 0) {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                        if (!varType.isPrimitiveType() || !varType.isVectorType()) {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                        const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.scalarType);
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, type), value instanceof PBShaderExp ? value.$ast : value));
                    }
                } else {
                    if (varType.isArrayType()) {
                        this.setAt(num, value);
                    } else if (varType.isPrimitiveType() && varType.isVectorType()) {
                        if (num >= varType.cols) {
                            throw new Error(`component index out of bounds: ${this.$str}[${num}]`);
                        }
                        this.$set('xyzw'[num], value);
                    } else if (varType.isPrimitiveType() && varType.isMatrixType()) {
                        if (!(value instanceof PBShaderExp)) {
                            throw new Error(`invalid matrix column vector assignment: ${this.$str}[${num}]`);
                        }
                        const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), new ASTScalar(num, typeI32$1), type), value.$ast));
                    } else {
                        throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                    }
                }
            }
            return true;
        }
        return false;
    }
}

const genTypeList = [
    [
        typeF32$1,
        typeF32Vec2$1,
        typeF32Vec3$1,
        typeF32Vec4$1
    ],
    [
        typeI32$1,
        typeI32Vec2$1,
        typeI32Vec3$1,
        typeI32Vec4$1
    ],
    [
        typeU32$3,
        typeU32Vec2$1,
        typeU32Vec3$1,
        typeU32Vec4$1
    ],
    [
        typeBool,
        typeBVec2,
        typeBVec3,
        typeBVec4
    ]
];
const genMatrixTypeList = [
    typeMat2,
    typeMat2x3,
    typeMat2x4,
    typeMat3x2,
    typeMat3,
    typeMat3x4,
    typeMat4x2,
    typeMat4x3,
    typeMat4
];
function matchFunctionOverloadings(pb, name, ...args) {
    const bit = pb.getDevice().type === 'webgl' ? MASK_WEBGL1 : pb.getDevice().type === 'webgl2' ? MASK_WEBGL2 : MASK_WEBGPU;
    const overloadings = builtinFunctionsAll?.[name].overloads.filter((val)=>!!(val[1] & bit)).map((val)=>val[0]);
    if (!overloadings || overloadings.length === 0) {
        throw new PBDeviceNotSupport(`builtin shader function '${name}'`);
    }
    const argsNonArray = args.map((val)=>pb.normalizeExpValue(val));
    const matchResult = pb._matchFunctionOverloading(overloadings, argsNonArray);
    if (!matchResult) {
        throw new PBOverloadingMatchError(name);
    }
    return matchResult;
}
function callBuiltinChecked(pb, matchResult) {
    return pb.$callFunction(matchResult[0].name, matchResult[1], matchResult[0]);
}
function callBuiltin(pb, name, ...args) {
    return callBuiltinChecked(pb, matchFunctionOverloadings(pb, name, ...args));
}
function genMatrixType(name, shaderTypeMask, r, args) {
    const result = [];
    for(let i = 0; i < genMatrixTypeList.length; i++){
        const returnType = r || genMatrixTypeList[i];
        const argTypes = args.map((arg)=>{
            return {
                type: arg || genMatrixTypeList[i]
            };
        });
        result.push([
            new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, returnType, argTypes), true),
            shaderTypeMask
        ]);
    }
    return result;
}
function genType(name, shaderTypeMask, r, args, vecOnly) {
    if (args.findIndex((val)=>typeof val === 'number') < 0) {
        return [
            [
                new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, r, args.map((arg)=>({
                        type: arg
                    }))), true),
                shaderTypeMask
            ]
        ];
    } else {
        const result = [];
        let i = vecOnly ? 1 : 0;
        for(; i < 4; i++){
            const returnType = typeof r === 'number' ? genTypeList[r][i] : r;
            const argTypes = args.map((arg)=>{
                if (typeof arg === 'number') {
                    return {
                        type: genTypeList[arg][i]
                    };
                } else {
                    return {
                        type: arg
                    };
                }
            });
            result.push([
                new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, returnType, argTypes), true),
                shaderTypeMask
            ]);
        }
        return result;
    }
}
function unaryFunc(a, op, type) {
    const exp = new PBShaderExp('', type);
    exp.$ast = new ASTUnaryFunc(a, op, type);
    return exp;
}
function binaryFunc(a, b, op, type) {
    const exp = new PBShaderExp('', type);
    exp.$ast = new ASTBinaryFunc(a, b, op, type);
    return exp;
}
const MASK_WEBGL1 = 1 << 0;
const MASK_WEBGL2 = 1 << 1;
const MASK_WEBGPU = 1 << 2;
const MASK_WEBGL = MASK_WEBGL1 | MASK_WEBGL2;
const MASK_ALL = MASK_WEBGL | MASK_WEBGPU;
const builtinFunctionsAll = {
    add_2: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$3,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$3,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$3
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                null
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {
                return args[0] + args[1];
            }
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '+', matchResult[0].returnType);
        }
    },
    add: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('add');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.add_2(result, args[i]);
            }
            return result;
        }
    },
    sub: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$3,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$3,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$3
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                null
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '-', matchResult[0].returnType);
        }
    },
    div: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$3,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$3,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '/', matchResult[0].returnType);
        }
    },
    mul_2: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32$1,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32$1,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32$1,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32$1,
                typeI32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec2$1, [
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32$1,
                typeI32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec3$1, [
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeI32Vec4$1, [
                typeI32Vec4$1,
                typeI32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32$3,
                typeU32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec2$1, [
                typeU32Vec2$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32$3,
                typeU32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3$1, [
                typeU32Vec3$1,
                typeU32$3
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4$1, [
                typeU32Vec4$1,
                typeU32$3
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                typeF32$1,
                null
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                typeF32$1
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat2,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat2,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat2,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeMat2,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec2$1,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat2x3,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat2x3,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat2x3,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeMat2x3,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec3$1,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat2x4,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat2x4,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat2x4,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeMat2x4,
                typeF32Vec2$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeF32Vec4$1,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat3x2,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat3x2,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat3x2,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeMat3x2,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec2$1,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat3,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat3,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat3,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeMat3,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec3$1,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat3x4,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat3x4,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat3x4,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeMat3x4,
                typeF32Vec3$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeF32Vec4$1,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat4x2,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat4x2,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat4x2,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec2$1, [
                typeMat4x2,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec2$1,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat4x3,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat4x3,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat4x3,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec3$1, [
                typeMat4x3,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec3$1,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat4,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat4,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat4,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeMat4,
                typeF32Vec4$1
            ]),
            ...genType('', MASK_ALL, typeF32Vec4$1, [
                typeF32Vec4$1,
                typeMat4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '*', matchResult[0].returnType);
        }
    },
    mul: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('mul');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.mul_2(result, args[i]);
            }
            return result;
        }
    },
    mod: {
        overloads: [
            ...genType('mod', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('mod', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('mod', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('mod', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            const isIntegerType = argType.isPrimitiveType() && (argType.scalarType === PBPrimitiveType.I32 || argType.scalarType === PBPrimitiveType.U32);
            if (pb.getDevice().type === 'webgl' && isIntegerType) {
                throw new PBDeviceNotSupport('integer modulus');
            }
            if (pb.getDevice().type === 'webgpu' || isIntegerType) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '%', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    radians: {
        overloads: genType('radians', MASK_ALL, 0, [
            0
        ])
    },
    degrees: {
        overloads: genType('degrees', MASK_ALL, 0, [
            0
        ])
    },
    sin: {
        overloads: genType('sin', MASK_ALL, 0, [
            0
        ])
    },
    cos: {
        overloads: genType('cos', MASK_ALL, 0, [
            0
        ])
    },
    tan: {
        overloads: genType('tan', MASK_ALL, 0, [
            0
        ])
    },
    asin: {
        overloads: genType('asin', MASK_ALL, 0, [
            0
        ])
    },
    acos: {
        overloads: genType('acos', MASK_ALL, 0, [
            0
        ])
    },
    atan: {
        overloads: genType('atan', MASK_ALL, 0, [
            0
        ])
    },
    atan2: {
        overloads: [
            ...genType('atan', MASK_WEBGL, 0, [
                0,
                0
            ]),
            ...genType('atan2', MASK_WEBGPU, 0, [
                0,
                0
            ])
        ]
    },
    sinh: {
        overloads: genType('sinh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    cosh: {
        overloads: genType('cosh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    tanh: {
        overloads: genType('tanh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    asinh: {
        overloads: genType('asinh', MASK_WEBGL2, 0, [
            0
        ])
    },
    acosh: {
        overloads: genType('acosh', MASK_WEBGL2, 0, [
            0
        ])
    },
    atanh: {
        overloads: genType('atanh', MASK_WEBGL2, 0, [
            0
        ])
    },
    pow: {
        overloads: genType('pow', MASK_ALL, 0, [
            0,
            0
        ])
    },
    exp: {
        overloads: genType('exp', MASK_ALL, 0, [
            0
        ])
    },
    exp2: {
        overloads: genType('exp2', MASK_ALL, 0, [
            0
        ])
    },
    log: {
        overloads: genType('log', MASK_ALL, 0, [
            0
        ])
    },
    log2: {
        overloads: genType('log2', MASK_ALL, 0, [
            0
        ])
    },
    sqrt: {
        overloads: genType('sqrt', MASK_ALL, 0, [
            0
        ])
    },
    inverseSqrt: {
        overloads: [
            ...genType('inversesqrt', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('inverseSqrt', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    abs: {
        overloads: [
            ...genType('abs', MASK_ALL, 0, [
                0
            ]),
            ...genType('abs', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1
            ]),
            ...genType('abs', MASK_WEBGPU, 2, [
                2
            ])
        ]
    },
    sign: {
        overloads: [
            ...genType('sign', MASK_ALL, 0, [
                0
            ]),
            ...genType('sign', MASK_WEBGL2, 1, [
                1
            ])
        ]
    },
    floor: {
        overloads: genType('floor', MASK_ALL, 0, [
            0
        ])
    },
    ceil: {
        overloads: genType('ceil', MASK_ALL, 0, [
            0
        ])
    },
    fract: {
        overloads: genType('fract', MASK_ALL, 0, [
            0
        ])
    },
    fma: {
        overloads: genType('fma', MASK_ALL, 0, [
            0,
            0,
            0
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            if (pb.getDevice().type === 'webgpu') {
                return callBuiltinChecked(pb, matchResult);
            } else {
                return pb.add(pb.mul(args[0], args[1]), args[2]);
            }
        }
    },
    round: {
        overloads: genType('round', MASK_WEBGPU, 0, [
            0
        ])
    },
    trunc: {
        overloads: genType('trunc', MASK_WEBGPU, 0, [
            0
        ])
    },
    // TODO: modf
    min: {
        overloads: [
            ...genType('min', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('min', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('min', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ]
    },
    max: {
        overloads: [
            ...genType('max', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('max', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('max', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ]
    },
    clamp: {
        overloads: [
            ...genType('clamp', MASK_ALL, 0, [
                0,
                0,
                0
            ]),
            ...genType('clamp', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1,
                1
            ]),
            ...genType('clamp', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2,
                2
            ])
        ]
    },
    mix: {
        overloads: [
            ...genType('mix', MASK_ALL, 0, [
                0,
                0,
                0
            ]),
            ...genType('mix', MASK_ALL, 0, [
                0,
                0,
                typeF32$1
            ])
        ]
    },
    step: {
        overloads: genType('step', MASK_ALL, 0, [
            0,
            0
        ])
    },
    smoothStep: {
        overloads: genType('smoothstep', MASK_ALL, 0, [
            0,
            0,
            0
        ])
    },
    isnan: {
        overloads: genType('isnan', MASK_WEBGL2, 3, [
            0
        ])
    },
    isinf: {
        overloads: genType('isinf', MASK_WEBGL2, 3, [
            0
        ])
    },
    length: {
        overloads: genType('length', MASK_ALL, typeF32$1, [
            0
        ])
    },
    distance: {
        overloads: genType('distance', MASK_ALL, typeF32$1, [
            0,
            0
        ])
    },
    dot: {
        overloads: [
            ...genType('dot', MASK_ALL, typeF32$1, [
                0,
                0
            ], true),
            ...genType('dot', MASK_WEBGPU, typeI32$1, [
                1,
                1
            ], true),
            ...genType('dot', MASK_WEBGPU, typeU32$3, [
                2,
                2
            ], true)
        ]
    },
    cross: {
        overloads: genType('cross', MASK_ALL, typeF32Vec3$1, [
            typeF32Vec3$1,
            typeF32Vec3$1
        ])
    },
    normalize: {
        overloads: genType('normalize', MASK_ALL, 0, [
            0
        ], true)
    },
    faceForward: {
        overloads: [
            ...genType('faceforward', MASK_WEBGL, 0, [
                0,
                0,
                0
            ], true),
            ...genType('faceForward', MASK_WEBGPU, 0, [
                0,
                0,
                0
            ], true)
        ]
    },
    reflect: {
        overloads: genType('reflect', MASK_ALL, 0, [
            0,
            0
        ], true)
    },
    refract: {
        overloads: genType('refract', MASK_ALL, 0, [
            0,
            0,
            typeF32$1
        ], true)
    },
    frexp: {
        overloads: [
            ...genType('frexp', MASK_WEBGPU, typeFrexpResult, [
                typeF32$1
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec2, [
                typeF32Vec2$1
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec3, [
                typeF32Vec3$1
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec4, [
                typeF32Vec4$1
            ])
        ]
    },
    outerProduct: {
        overloads: [
            ...genType('outerProduct', MASK_WEBGL2, typeMat2, [
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3, [
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4, [
                typeF32Vec4$1,
                typeF32Vec4$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat2x3, [
                typeF32Vec3$1,
                typeF32Vec2$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3x2, [
                typeF32Vec2$1,
                typeF32Vec3$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat2x4, [
                typeF32Vec4$1,
                typeF32Vec2$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4x2, [
                typeF32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3x4, [
                typeF32Vec4$1,
                typeF32Vec3$1
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4x3, [
                typeF32Vec3$1,
                typeF32Vec4$1
            ])
        ]
    },
    transpose: {
        overloads: [
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2, [
                typeMat2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3, [
                typeMat3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4, [
                typeMat4
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2x3, [
                typeMat3x2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3x2, [
                typeMat2x3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2x4, [
                typeMat4x2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4x2, [
                typeMat2x4
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3x4, [
                typeMat4x3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4x3, [
                typeMat3x4
            ])
        ]
    },
    determinant: {
        overloads: [
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32$1, [
                typeMat2
            ]),
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32$1, [
                typeMat3
            ]),
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32$1, [
                typeMat4
            ])
        ]
    },
    inverse: {
        overloads: [
            ...genType('inverse', MASK_WEBGL2, typeMat2, [
                typeMat2
            ]),
            ...genType('inverse', MASK_WEBGL2, typeMat3, [
                typeMat3
            ]),
            ...genType('inverse', MASK_WEBGL2, typeMat4, [
                typeMat4
            ])
        ]
    },
    lessThan: {
        overloads: [
            ...genType('lessThan', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('lessThan', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('lessThan', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '<', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    lessThanEqual: {
        overloads: [
            ...genType('lessThanEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('lessThanEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('lessThanEqual', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '<=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    greaterThan: {
        overloads: [
            ...genType('greaterThan', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('greaterThan', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('greaterThan', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '>', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    greaterThanEqual: {
        overloads: [
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '>=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    compEqual: {
        overloads: [
            ...genType('equal', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('equal', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('equal', MASK_ALL, 3, [
                2,
                2
            ]),
            ...genType('equal', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '==', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    compNotEqual: {
        overloads: [
            ...genType('notEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                2,
                2
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '!=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    equal: {
        overloads: [
            ...genType('equal', MASK_ALL, typeBool, [
                0,
                0
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                1,
                1
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                2,
                2
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' && argType.isPrimitiveType() && !argType.isScalarType()) {
                return pb.all(pb.compEqual(args[0], args[1]));
            } else {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '==', matchResult[0].returnType);
            }
        }
    },
    notEqual: {
        overloads: [
            ...genType('notEqual', MASK_ALL, typeBool, [
                0,
                0
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                1,
                1
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                2,
                2
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' && argType.isPrimitiveType() && !argType.isScalarType()) {
                return pb.any(pb.compNotEqual(args[0], args[1]));
            } else {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '!=', matchResult[0].returnType);
            }
        }
    },
    any: {
        overloads: genType('any', MASK_ALL, typeBool, [
            3
        ], true)
    },
    all: {
        overloads: genType('all', MASK_ALL, typeBool, [
            3
        ], true)
    },
    not: {
        overloads: genType('not', MASK_ALL, 3, [
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return unaryFunc(matchResult[1][0], '!', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    neg: {
        overloads: [
            ...genType('neg', MASK_ALL, 0, [
                0
            ]),
            ...genType('neg', MASK_ALL, 1, [
                1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return unaryFunc(matchResult[1][0], '-', matchResult[0].returnType);
        }
    },
    or_2: {
        overloads: genType('or', MASK_ALL, typeBool, [
            3,
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '||', matchResult[0].returnType);
        }
    },
    or: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('or');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.or_2(result, args[i]);
            }
            return result;
        }
    },
    compOr: {
        overloads: [
            ...genType('compOr', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compOr', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '|', matchResult[0].returnType);
        }
    },
    and_2: {
        overloads: genType('and', MASK_ALL, typeBool, [
            3,
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '&&', matchResult[0].returnType);
        }
    },
    and: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('and');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.and_2(result, args[i]);
            }
            return result;
        }
    },
    compAnd: {
        overloads: [
            ...genType('compAnd', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compAnd', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '&', matchResult[0].returnType);
        }
    },
    compXor: {
        overloads: [
            ...genType('compXor', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compXor', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '^', matchResult[0].returnType);
        }
    },
    sal: {
        overloads: [
            ...genType('sal', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                2
            ]),
            ...genType('sal', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '<<', matchResult[0].returnType);
        }
    },
    sar: {
        overloads: [
            ...genType('sar', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                2
            ]),
            ...genType('sar', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '>>', matchResult[0].returnType);
        }
    },
    arrayLength: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError('arrayLength');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('arrayLength', 'array');
            }
            const type = args[0].$ast.getType();
            const arrayType = type.isPointerType() ? type.pointerType : type;
            if (!arrayType.isArrayType() || arrayType.dimension !== 0) {
                throw new PBParamTypeError('arrayLength', 'array');
            }
            const arg = type.isArrayType() ? pb.addressOf(args[0]).$ast : args[0].$ast;
            return pb.$callFunctionNoCheck(name, [
                arg
            ], typeU32$3);
        }
    },
    select: {
        overloads: [
            ...genType('select', MASK_WEBGPU, 0, [
                0,
                0,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 1, [
                1,
                1,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 2, [
                2,
                2,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 3, [
                3,
                3,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 0, [
                0,
                0,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 1, [
                1,
                1,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 2, [
                2,
                2,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 3, [
                3,
                3,
                3
            ], true),
            ...genType('mix', MASK_WEBGL2, 0, [
                0,
                0,
                3
            ]),
            ...genType('mix', MASK_WEBGL2, 1, [
                1,
                1,
                3
            ]),
            ...genType('mix', MASK_WEBGL2, 2, [
                2,
                2,
                3
            ])
        ]
    },
    floatBitsToInt: {
        overloads: genType('floatBitsToInt', MASK_WEBGL2, 1, [
            0
        ])
    },
    floatBitsToUint: {
        overloads: genType('floatBitsToUint', MASK_WEBGL2, 2, [
            0
        ])
    },
    intBitsToFloat: {
        overloads: genType('intBitsToFloat', MASK_WEBGL2, 0, [
            1
        ])
    },
    uintBitsToFloat: {
        overloads: genType('uintBitsToFloat', MASK_WEBGL2, 0, [
            2
        ])
    },
    pack4x8snorm: {
        overloads: genType('pack4x8snorm', MASK_WEBGPU, typeU32$3, [
            typeF32Vec4$1
        ])
    },
    unpack4x8snorm: {
        overloads: genType('unpack4x8snorm', MASK_WEBGPU, typeF32Vec4$1, [
            typeU32$3
        ])
    },
    pack4x8unorm: {
        overloads: genType('pack4x8unorm', MASK_WEBGPU, typeU32$3, [
            typeF32Vec4$1
        ])
    },
    unpack4x8unorm: {
        overloads: genType('unpack4x8unorm', MASK_WEBGPU, typeF32Vec4$1, [
            typeU32$3
        ])
    },
    pack2x16snorm: {
        overloads: [
            ...genType('pack2x16snorm', MASK_WEBGPU, typeU32$3, [
                typeF32Vec2$1
            ]),
            ...genType('packSnorm2x16', MASK_WEBGL2, typeU32$3, [
                typeF32Vec2$1
            ])
        ]
    },
    unpack2x16snorm: {
        overloads: [
            ...genType('unpack2x16snorm', MASK_WEBGPU, typeF32Vec2$1, [
                typeU32$3
            ]),
            ...genType('unpackSnorm2x16', MASK_WEBGL2, typeF32Vec2$1, [
                typeU32$3
            ])
        ]
    },
    pack2x16unorm: {
        overloads: [
            ...genType('pack2x16unorm', MASK_WEBGPU, typeU32$3, [
                typeF32Vec2$1
            ]),
            ...genType('packUnorm2x16', MASK_WEBGL2, typeU32$3, [
                typeF32Vec2$1
            ])
        ]
    },
    unpack2x16unorm: {
        overloads: [
            ...genType('unpack2x16unorm', MASK_WEBGPU, typeF32Vec2$1, [
                typeU32$3
            ]),
            ...genType('unpackUnorm2x16', MASK_WEBGL2, typeF32Vec2$1, [
                typeU32$3
            ])
        ]
    },
    pack2x16float: {
        overloads: [
            ...genType('pack2x16float', MASK_WEBGPU, typeU32$3, [
                typeF32Vec2$1
            ]),
            ...genType('packHalf2x16', MASK_WEBGL2, typeU32$3, [
                typeF32Vec2$1
            ])
        ]
    },
    unpack2x16float: {
        overloads: [
            ...genType('unpack2x16float', MASK_WEBGPU, typeF32Vec2$1, [
                typeU32$3
            ]),
            ...genType('unpackHalf2x16', MASK_WEBGL2, typeF32Vec2$1, [
                typeU32$3
            ])
        ]
    },
    matrixCompMult: {
        overloads: genMatrixType('matrixCompMult', MASK_WEBGL, null, [
            null,
            null
        ])
    },
    dpdx: {
        overloads: [
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('dpdx', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    dpdy: {
        overloads: [
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('dpdy', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    fwidth: {
        overloads: genType('fwidth', MASK_ALL, 0, [
            0
        ])
    },
    dpdxCoarse: {
        overloads: [
            ...genType('dpdxCoarse', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdxFine: {
        overloads: [
            ...genType('dpdxFine', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdyCoarse: {
        overloads: [
            ...genType('dpdyCoarse', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdyFine: {
        overloads: [
            ...genType('dpdyFine', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    // textureDimensions(tex: PBShaderExp, level?: number|PBShaderExp);
    textureDimensions: {
        overloads: [
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTex1D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeITex1D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeUTex1D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTex2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITex2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTex2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTex2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITex2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTex2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTex3D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeITex3D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeUTex3D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITexCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTexCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITexCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTexCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeITexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeUTexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepth2D,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepth2DArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepthCube,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepthCubeArray,
                typeI32$1
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexDepthMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$3, [
                typeTexStorage1D_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2D_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2$1, [
                typeTexStorage2DArray_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3$1, [
                typeTexStorage3D_r32float
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTex1D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTex2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITex1D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITex2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTex1D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTex2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTex2DArray,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITex2DArray,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTex2DArray,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeITexCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeUTexCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3$1, [
                typeTex3D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3$1, [
                typeITex3D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3$1, [
                typeUTex3D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexDepth2D,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexDepthCube,
                typeI32$1
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2$1, [
                typeTexDepth2DArray,
                typeI32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 1 || args.length > 2) {
                throw new PBParamLengthError('textureDimensions');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('textureDimensions', 'tex');
            }
            const texType = args[0].$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureDimensions', 'tex');
            }
            if (pb.getDevice().type === 'webgpu') {
                if (texType.isMultisampledTexture() || texType.isStorageTexture()) {
                    if (args[1] !== undefined) {
                        throw new PBParamValueError('textureDimensions', 'level');
                    }
                }
                return callBuiltin(pb, name, ...args);
            } else if (pb.getDevice().type === 'webgl2') {
                const tex = args[0];
                const level = args[1] || 0;
                return texType.is1DTexture() ? callBuiltin(pb, name, tex, level).x : callBuiltin(pb, name, tex, level);
            }
        }
    },
    // textureGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp);
    // textureGather(component: number|PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp);
    textureGather: {
        overloads: [
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3$1
            ])
        ]
    },
    // textureArrayGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp);
    // textureArrayGather(component: number|PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp);
    textureArrayGather: {
        overloads: [
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeI32$1,
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4$1, [
                typeI32$1,
                typeITexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4$1, [
                typeI32$1,
                typeUTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ])
        ]
    },
    // textureGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp);
    textureGatherCompare: {
        overloads: [
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeF32$1
            ])
        ]
    },
    // textureArrayGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp);
    textureArrayGatherCompare: {
        overloads: [
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ])
        ]
    },
    // textureLoad(tex: PBShaderExp, coords: number|PBShaderExp, levelOrSampleIndex: number|PBShaderExp);
    textureLoad: {
        overloads: [
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex1D,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex1D,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex1D,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITexMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTexMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexExternal,
                typeI32Vec2$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32$1, [
                typeTexDepthMultisampled2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex1D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeTexExternal,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeITex1D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4$1, [
                typeITex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4$1, [
                typeITex3D,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeUTex1D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeUTex2D,
                typeI32Vec2$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeUTex3D,
                typeI32Vec3$1,
                typeI32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length === 0) {
                throw new PBParamLengthError('textureLoad');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('textureLoad', 'tex');
            }
            const texType = args[0].$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureLoad', 'tex');
            }
            if (pb.getDevice().type === 'webgl2') {
                if (args.length !== 3) {
                    throw new PBParamLengthError('textureLoad');
                }
                if (texType.is1DTexture()) {
                    if (typeof args[1] === 'number') {
                        if (!Number.isInteger(args[1])) {
                            throw new PBParamTypeError('textureLoad', 'coord');
                        }
                    } else if (args[1] instanceof PBShaderExp) {
                        const coordType = args[1].$ast.getType();
                        if (!coordType.isPrimitiveType() || !coordType.isScalarType() || coordType.scalarType !== PBPrimitiveType.I32) {
                            throw new PBParamTypeError('textureLoad', 'coord');
                        }
                    } else {
                        throw new PBParamTypeError('textureLoad', 'coord');
                    }
                    args[1] = pb.ivec2(args[1], 0);
                }
            } else if (pb.getDevice().type === 'webgpu' && texType.isExternalTexture()) {
                args = args.slice(0, 2);
            }
            return callBuiltin(pb, name, ...args);
        }
    },
    // textureArrayLoad(tex: PBShaderExp, coords: number|PBShaderExp, arrayIndex: number|PBShaderExp, level: number|PBShaderExp);
    textureArrayLoad: {
        overloads: [
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4$1, [
                typeITex2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4$1, [
                typeUTex2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeI32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4$1, [
                typeITex2DArray,
                typeI32Vec3$1,
                typeI32$1
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4$1, [
                typeUTex2DArray,
                typeI32Vec3$1,
                typeI32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (pb.getDevice().type === 'webgl2') {
                if (args.length !== 4) {
                    throw new PBParamLengthError('textureArrayLoad');
                }
                const tex = args[0];
                const coords = pb.ivec3(args[1], args[2]);
                const level = args[3];
                return callBuiltin(pb, name, tex, coords, level);
            } else {
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureStore(tex: PBShaderExp, coords: number|PBShaderExp, value: PBShaderExp);
    textureStore: {
        overloads: [
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8unorm,
                typeU32$3,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8snorm,
                typeU32$3,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8uint,
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8sint,
                typeU32$3,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16uint,
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16sint,
                typeU32$3,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16float,
                typeU32$3,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32uint,
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32sint,
                typeU32$3,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32float,
                typeU32$3,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32uint,
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32sint,
                typeU32$3,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32float,
                typeU32$3,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32uint,
                typeU32$3,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32sint,
                typeU32$3,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32float,
                typeU32$3,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8unorm,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8snorm,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32uint,
                typeU32Vec2$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32sint,
                typeU32Vec2$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32float,
                typeU32Vec2$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8unorm,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8snorm,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32uint,
                typeU32Vec3$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32sint,
                typeU32Vec3$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32float,
                typeU32Vec3$1,
                typeF32Vec4$1
            ])
        ]
    },
    // textureArrayStore(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, value: PBShaderExp);
    textureArrayStore: {
        overloads: [
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8unorm,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8snorm,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32uint,
                typeI32Vec2$1,
                typeI32$1,
                typeU32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32sint,
                typeI32Vec2$1,
                typeI32$1,
                typeI32Vec4$1
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32float,
                typeI32Vec2$1,
                typeI32$1,
                typeF32Vec4$1
            ])
        ]
    },
    // textureNumLayers(tex: PBShaderExp);
    textureNumLayers: {
        overloads: [
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeITex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeUTex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeITexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeUTexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexDepth2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexDepthCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_r32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_r32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_r32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rg32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rg32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rg32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba16float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba16sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba16uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8snorm
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32$1, [
                typeTexStorage2DArray_rgba8unorm
            ])
        ]
    },
    // textureNumLevels(tex: PBShaderExp);
    textureNumLevels: {
        overloads: [
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeITexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeUTexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepth2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepth2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepthCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32$1, [
                typeTexDepthCubeArray
            ])
        ]
    },
    // textureNumSamples(tex: PBShaderExp);
    textureNumSamples: {
        overloads: [
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeTexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeITexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeUTexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32$1, [
                typeTexDepthMultisampled2D
            ])
        ]
    },
    // textureSample(tex: texture, coords: number|PBShaderExp);
    textureSample: {
        overloads: [
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex1D,
                typeSampler,
                typeF32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3$1
            ]),
            ...genType('textureSampleBaseClampToEdge', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexExternal,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex1D,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex1D,
                typeF32Vec2$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError('textureSample');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSample', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSample', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const ret = callBuiltin(pb, name, tex, sampler, coords);
                if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                if (texType.is1DTexture()) {
                    if (args[1] instanceof PBShaderExp) {
                        const coordType = args[1].$ast.getType();
                        if (!coordType.isPrimitiveType() || !coordType.isScalarType() || coordType.scalarType !== PBPrimitiveType.F32) {
                            throw new PBParamTypeError('textureSample', 'coord');
                        }
                    } else if (typeof args[1] !== 'number') {
                        throw new PBParamTypeError('textureSample', 'coord');
                    }
                    args[1] = pb.vec2(args[1], 0);
                }
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySample(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp)
    textureArraySample: {
        overloads: [
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepth2DArray,
                typeF32Vec3$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureArraySample');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySample', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySample', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const ret = callBuiltin(pb, name, tex, sampler, coords, arrayIndex);
                if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const coordsComposit = pb.vec3(coords, pb.float(arrayIndex));
                return callBuiltin(pb, name, tex, coordsComposit);
            }
        }
    },
    // textureSampleBias(tex: PBShaderExp, coords: PBShaderExp, bias: number|PBShaderExp)
    textureSampleBias: {
        overloads: [
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleBias');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleBias', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleBias', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySampleBias(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, bias: number|PBShaderExp)
    textureArraySampleBias: {
        overloads: [
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleBias');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleBias', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySampleBias', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else if (pb.getDevice().type === 'webgl2') {
                pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const coordsComposit = pb.vec3(coords, pb.float(arrayIndex));
                return callBuiltin(pb, name, tex, coordsComposit, args[3]);
            }
        }
    },
    // textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp)
    textureSampleCompare: {
        overloads: [
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2D,
                typeF32Vec3$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepthCube,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleCompare');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleCompare', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureSampleCompare', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(args[0], true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(args[0], true);
                let coordsComposite;
                if (texType.isCubeTexture() || texType.isArrayTexture()) {
                    coordsComposite = pb.vec4(args[1], args[2]);
                } else {
                    coordsComposite = pb.vec3(args[1], args[2]);
                }
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureArraySampleCompare(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp)
    textureArraySampleCompare: {
        overloads: [
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2DArray,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleCompare');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleCompare', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureArraySampleCompare', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(args[0], true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(args[0], true);
                const coordsComposite = pb.vec4(args[1], pb.float(args[2]), args[3]);
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureSampleLevel(tex: PBShaderExp, coords: PBShaderExp, level: number|PBShaderExp)
    textureSampleLevel: {
        overloads: [
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexExternal,
                typeSampler,
                typeF32Vec2$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepth2D,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexExternal,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureCubeLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureCubeLodEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexDepthCube,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgl' && pb.shaderKind === 'vertex') {
                // WebGL1 does not support vertex texture lod
                return pb.textureSample(tex, args[1]);
            }
            if (pb.getDevice().type === 'webgpu') {
                if (texType.isExternalTexture()) {
                    return pb.textureLoad(tex, pb.ivec2(args[1]), 0);
                } else {
                    const sampler = pb.getDefaultSampler(tex, false);
                    const level = texType.isDepthTexture() && (typeof args[2] === 'number' || args[2] instanceof PBShaderExp && args[2].$ast.getType().isCompatibleType(typeF32$1)) ? pb.int(args[2]) : args[2];
                    const ret = texType.isExternalTexture() ? callBuiltin(pb, name, tex, sampler, args[1]) : callBuiltin(pb, name, tex, sampler, args[1], level);
                    if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                        return pb.vec4(ret);
                    } else {
                        return ret;
                    }
                }
            } else {
                pb.getDefaultSampler(tex, false);
                return texType.isExternalTexture() ? callBuiltin(pb, name, args[0], args[1], 0) : callBuiltin(pb, name, args[0], args[1], args[2]);
            }
        }
    },
    // textureArraySampleLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, level: number|PBShaderExp)
    textureArraySampleLevel: {
        overloads: [
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeI32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1,
                typeF32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySampleLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const level = texType.isDepthTexture() && (typeof args[3] === 'number' || args[3] instanceof PBShaderExp && args[3].$ast.getType().isCompatibleType(typeF32$1)) ? pb.int(args[3]) : args[3];
                const ret = callBuiltin(pb, name, tex, sampler, args[1], args[2], level);
                if (ret.$ast.getType().isCompatibleType(typeF32$1)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                const coordsComposite = pb.vec3(args[1], pb.float(args[2]));
                return callBuiltin(pb, name, tex, coordsComposite, args[3]);
            }
        }
    },
    // textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp)
    textureSampleCompareLevel: {
        overloads: [
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2D,
                typeF32Vec3$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepthCube,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleCompareLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleCompareLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureSampleCompareLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(args[0], true);
                let coordsComposite;
                if (texType.isCubeTexture() || texType.isArrayTexture()) {
                    coordsComposite = pb.vec4(args[1], args[2]);
                } else {
                    coordsComposite = pb.vec3(args[1], args[2]);
                }
                return texType.isCubeTexture() ? callBuiltin(pb, name, tex, coordsComposite) : callBuiltin(pb, name, tex, coordsComposite, 0);
            }
        }
    },
    // textureArraySampleCompareLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp)
    textureArraySampleCompareLevel: {
        overloads: [
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32$1, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3$1,
                typeI32$1,
                typeF32$1
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32$1, [
                typeTexDepth2DArray,
                typeF32Vec4$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleCompareLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleCompareLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureArraySampleCompareLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(args[0], true);
                const coordsComposite = pb.vec4(args[1], pb.float(args[2]), args[3]);
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureSampleGrad(tex: PBShaderExp, coords: PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp)
    textureSampleGrad: {
        overloads: [
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2D,
                typeSampler,
                typeF32Vec2$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex3D,
                typeSampler,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCube,
                typeSampler,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex3D,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('texture2DGradEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTex2D,
                typeF32Vec2$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureCubeGradEXT', MASK_WEBGL1, typeF32Vec4$1, [
                typeTexCube,
                typeF32Vec3$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureSampleGrad');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleGrad', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleGrad', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySampleGrad(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp)
    textureArraySampleGrad: {
        overloads: [
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2$1,
                typeI32$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4$1, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3$1,
                typeI32$1,
                typeF32Vec3$1,
                typeF32Vec3$1
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4$1, [
                typeTex2DArray,
                typeF32Vec3$1,
                typeF32Vec2$1,
                typeF32Vec2$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 5) {
                throw new PBParamLengthError('textureArraySampleGrad');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleGrad', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isArrayTexture()) {
                throw new PBParamTypeError('textureArraySampleGrad', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3], args[4]);
            } else {
                pb.getDefaultSampler(tex, false);
                const coordsComposite = pb.vec3(args[1], pb.float(args[2]));
                return callBuiltin(pb, name, tex, coordsComposite, args[3], args[4]);
            }
        }
    },
    storageBarrier: {
        overloads: genType('storageBarrier', MASK_WEBGPU, typeVoid, [])
    },
    workgroupBarrier: {
        overloads: genType('workgroupBarrier', MASK_WEBGPU, typeVoid, [])
    },
    atomicLoad: {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError(name);
            }
            const arg = args[0];
            if (!(arg instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg.$ast.getType().typeId === typeAtomicI32.typeId) {
                return pb.$callFunctionNoCheck(name, [
                    new ASTAddressOf(arg.$ast)
                ], typeI32$1);
            } else if (arg.$ast.getType().typeId === typeAtomicU32.typeId) {
                return pb.$callFunctionNoCheck(name, [
                    new ASTAddressOf(arg.$ast)
                ], typeU32$3);
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    },
    atomicStore: {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError(name);
            }
            const arg1 = args[0];
            const arg2 = args[1];
            if (!(arg1 instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg1.$ast.getType().typeId === typeAtomicI32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeI32$1)
                    ], typeVoid);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeI32$1.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeVoid);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else if (arg1.$ast.getType().typeId === typeAtomicU32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeU32$3)
                    ], typeVoid);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeU32$3.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeVoid);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    }
};
for (const name of [
    'atomicAdd',
    'atomicSub',
    'atomicMax',
    'atomicMin',
    'atomicAnd',
    'atomicOr',
    'atomicXor'
]){
    builtinFunctionsAll[name] = {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError(name);
            }
            const arg1 = args[0];
            const arg2 = args[1];
            if (!(arg1 instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg1.$ast.getType().typeId === typeAtomicI32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeI32$1)
                    ], typeI32$1);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeI32$1.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeI32$1);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else if (arg1.$ast.getType().typeId === typeAtomicU32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeU32$3)
                    ], typeU32$3);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeU32$3.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeU32$3);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    };
}
/** @internal */ function setBuiltinFuncs(cls) {
    for (const k of Object.keys(builtinFunctionsAll)){
        cls.prototype[k] = function(...args) {
            const normalizeFunc = builtinFunctionsAll?.[k]?.normalizeFunc || callBuiltin;
            return normalizeFunc(this, k, ...args);
        };
    }
}

const StorageTextureFormatMap = {
    rgba8unorm: 'rgba8unorm',
    rgba8snorm: 'rgba8snorm',
    rgba8uint: 'rgba8ui',
    rgba8sint: 'rgba8i',
    rgba16uint: 'rgba16ui',
    rgba16sint: 'rgba16i',
    rgba16float: 'rgba16f',
    r32float: 'r32f',
    r32uint: 'r32ui',
    r32sint: 'r32i',
    rg32float: 'rg32f',
    rg32uint: 'rg32ui',
    rg32sint: 'rg32i',
    rgba32float: 'rgba32f',
    rgba32uint: 'rgba32ui',
    rgba32sint: 'rgba32i'
};
function vec_n(vecType, ...args) {
    if (this.getDevice().type === 'webgl') {
        if (vecType.scalarType === PBPrimitiveType.U32) {
            throw new PBDeviceNotSupport('unsigned integer type');
        }
        if (vecType.isMatrixType() && vecType.cols !== vecType.rows) {
            throw new PBDeviceNotSupport('non-square matrix type');
        }
    }
    if (args.length === 1 && typeof args[0] === 'string') {
        return new PBShaderExp(args[0], vecType);
    } else {
        const exp = new PBShaderExp('', vecType);
        if (vecType.isScalarType() && args.length === 1 && (typeof args[0] === 'number' || typeof args[0] === 'boolean')) {
            exp.$ast = new ASTScalar(args[0], vecType);
        } else {
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, args.map((arg)=>{
                if (typeof arg === 'string') {
                    throw new PBParamTypeError('vec_n');
                }
                return arg instanceof PBShaderExp ? arg.$ast : arg;
            }));
        }
        return exp;
    }
}
const primitiveCtors = {
    float: typeF32$1,
    int: typeI32$1,
    uint: typeU32$3,
    bool: typeBool,
    vec2: typeF32Vec2$1,
    ivec2: typeI32Vec2$1,
    uvec2: typeU32Vec2$1,
    bvec2: typeBVec2,
    vec3: typeF32Vec3$1,
    ivec3: typeI32Vec3$1,
    uvec3: typeU32Vec3$1,
    bvec3: typeBVec3,
    vec4: typeF32Vec4$1,
    ivec4: typeI32Vec4$1,
    uvec4: typeU32Vec4$1,
    bvec4: typeBVec4,
    mat2: typeMat2,
    mat2x3: typeMat2x3,
    mat2x4: typeMat2x4,
    mat3x2: typeMat3x2,
    mat3: typeMat3,
    mat3x4: typeMat3x4,
    mat4x2: typeMat4x2,
    mat4x3: typeMat4x3,
    mat4: typeMat4
};
const simpleCtors = {
    tex1D: typeTex1D,
    tex2D: typeTex2D,
    tex3D: typeTex3D,
    texCube: typeTexCube,
    tex2DShadow: typeTexDepth2D,
    texCubeShadow: typeTexDepthCube,
    tex2DArray: typeTex2DArray,
    tex2DArrayShadow: typeTexDepth2DArray,
    texExternal: typeTexExternal,
    itex1D: typeITex1D,
    itex2D: typeITex2D,
    itex3D: typeITex3D,
    itexCube: typeITexCube,
    itex2DArray: typeITex2DArray,
    utex1D: typeUTex1D,
    utex2D: typeUTex2D,
    utex3D: typeUTex3D,
    utexCube: typeUTexCube,
    utex2DArray: typeUTex2DArray,
    sampler: typeSampler,
    samplerComparison: typeSamplerComparison
};
function makeStorageTextureCtor(type) {
    const ctor = {};
    for (const k of Object.keys(StorageTextureFormatMap)){
        ctor[k] = function(rhs) {
            return new PBShaderExp(rhs, new PBTextureTypeInfo(type, StorageTextureFormatMap[k]));
        };
    }
    return ctor;
}
const texStorageCtors = {
    texStorage1D: PBTextureType.TEX_STORAGE_1D,
    texStorage2D: PBTextureType.TEX_STORAGE_2D,
    texStorage2DArray: PBTextureType.TEX_STORAGE_2D_ARRAY,
    texStorage3D: PBTextureType.TEX_STORAGE_3D
};
/** @internal */ function setConstructors(cls) {
    Object.keys(primitiveCtors).forEach((k)=>{
        cls.prototype[k] = makeConstructor(function(...args) {
            return vec_n.call(this, primitiveCtors[k], ...args);
        }, primitiveCtors[k]);
    });
    Object.keys(simpleCtors).forEach((k)=>{
        cls.prototype[k] = function(rhs) {
            return new PBShaderExp(rhs, simpleCtors[k]);
        };
    });
    Object.keys(texStorageCtors).forEach((k)=>{
        cls.prototype[k] = makeStorageTextureCtor(texStorageCtors[k]);
    });
    cls.prototype['atomic_int'] = function(...args) {
        if (args.length > 1) {
            throw new PBParamLengthError('atomic_int');
        }
        if (args.length === 1) {
            if (typeof args[0] !== 'string') {
                throw new PBParamTypeError('atomic_int', 'name');
            }
            return new PBShaderExp(args[0], typeAtomicI32);
        } else {
            const exp = new PBShaderExp('', typeAtomicI32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, []);
            return exp;
        }
    };
    cls.prototype['atomic_uint'] = function(...args) {
        if (args.length > 1) {
            throw new PBParamLengthError('atomic_uint');
        }
        if (args.length === 1 && typeof args[0] === 'string') {
            return new PBShaderExp(args[0], typeAtomicU32);
        } else if (args.length === 0) {
            const exp = new PBShaderExp('', typeAtomicU32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, []);
            return exp;
        }
        const arg = args[0];
        if (typeof arg === 'number' && Number.isInteger(arg) || arg instanceof PBShaderExp && arg.$ast.getType().typeId === typeU32$3.typeId) {
            const exp = new PBShaderExp('', typeAtomicU32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, [
                arg instanceof PBShaderExp ? arg.$ast : arg
            ]);
            return exp;
        }
        return null;
    };
} /*
ProgramBuilder.prototype.texStorage1D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_1D);
ProgramBuilder.prototype.texStorage2D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_2D);
ProgramBuilder.prototype.texStorage2DArray = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_2D_ARRAY);
ProgramBuilder.prototype.texStorage3D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_3D);
*/

const COMPUTE_UNIFORM_NAME = 'ch_compute_uniform_block';
const COMPUTE_STORAGE_NAME = 'ch_compute_storage_block';
const VERTEX_UNIFORM_NAME = 'ch_vertex_uniform_block';
const FRAGMENT_UNIFORM_NAME = 'ch_fragment_uniform_block';
const SHARED_UNIFORM_NAME = 'ch_shared_uniform_block';
const VERTEX_STORAGE_NAME = 'ch_vertex_storage_block';
const FRAGMENT_STORAGE_NAME = 'ch_fragment_storage_block';
const SHARED_STORAGE_NAME = 'ch_shared_storage_block';
const input_prefix = 'zVSInput_';
const output_prefix_vs = 'zVSOutput_';
const output_prefix_fs = 'zFSOutput_';
/**
 * The program builder class
 * @public
 */ class ProgramBuilder {
    /** @internal */ _device;
    /** @internal */ _workgroupSize;
    /** @internal */ _scopeStack = [];
    /** @internal */ _shaderType = ShaderType.Vertex | ShaderType.Fragment | ShaderType.Compute;
    /** @internal */ _structInfo;
    /** @internal */ _uniforms;
    /** @internal */ _globalScope;
    /** @internal */ _builtinScope;
    /** @internal */ _inputScope;
    /** @internal */ _outputScope;
    /** @internal */ _inputs;
    /** @internal */ _outputs;
    /** @internal */ _vertexAttributes;
    /** @internal */ _depthRangeCorrection;
    /** @internal */ _emulateDepthClamp;
    /** @internal */ _lastError;
    /** @internal */ _reflection;
    /** @internal */ _autoStructureTypeIndex;
    /** @internal */ _nameMap;
    /**
   * Creates a program builder for given device
   * @param device - The device
   */ constructor(device){
        this._device = device;
        this._workgroupSize = null;
        this._structInfo = {};
        this._uniforms = [];
        this._scopeStack = [];
        this._globalScope = null;
        this._builtinScope = null;
        this._inputScope = null;
        this._outputScope = null;
        this._inputs = [];
        this._outputs = [];
        this._vertexAttributes = [];
        this._depthRangeCorrection = device.type === 'webgpu';
        this._emulateDepthClamp = false;
        this._lastError = null;
        this._reflection = new PBReflection(this);
        this._autoStructureTypeIndex = 0;
        this._nameMap = [];
    }
    /** Get last error */ get lastError() {
        return this._lastError;
    }
    /** @internal */ get shaderType() {
        return this._shaderType;
    }
    /** Current shader kind */ get shaderKind() {
        return this._shaderType === ShaderType.Vertex ? 'vertex' : this._shaderType === ShaderType.Fragment ? 'fragment' : this._shaderType === ShaderType.Compute ? 'compute' : null;
    }
    /** Gets the global scope */ getGlobalScope() {
        return this._globalScope;
    }
    /** @internal */ get builtinScope() {
        return this._builtinScope;
    }
    /** @internal */ get inputScope() {
        return this._inputScope;
    }
    /** @internal */ get outputScope() {
        return this._outputScope;
    }
    /** @internal */ get depthRangeCorrection() {
        return this._depthRangeCorrection;
    }
    get emulateDepthClamp() {
        return this._emulateDepthClamp;
    }
    set emulateDepthClamp(val) {
        this._emulateDepthClamp = val;
    }
    /** Get the shader code reflection interface */ getReflection() {
        return this._reflection;
    }
    /** Get the device */ getDevice() {
        return this._device;
    }
    /** @internal */ reset() {
        this._workgroupSize = null;
        this._structInfo = {};
        this._uniforms = [];
        this._scopeStack = [];
        this._globalScope = null;
        this._builtinScope = null;
        this._inputScope = null;
        this._outputScope = null;
        this._inputs = [];
        this._outputs = [];
        this._vertexAttributes = [];
        this._depthRangeCorrection = this._device.type === 'webgpu';
        this._reflection = new PBReflection(this);
        this._autoStructureTypeIndex = 0;
        this._nameMap = [];
    }
    /**
   * Query the global variable by the name
   * @param name - Name of the variable
   * @returns The variable or null if not exists
   */ queryGlobal(name) {
        return this.getReflection().tag(name);
    }
    /** @internal */ pushScope(scope) {
        this._scopeStack.unshift(scope);
    }
    /** @internal */ popScope() {
        return this._scopeStack.shift();
    }
    /** Gets the current scope */ getCurrentScope() {
        return this._scopeStack[0];
    }
    /** Gets the current function scope */ getCurrentFunctionScope() {
        let funcScope = this.getCurrentScope();
        while(funcScope && !(funcScope instanceof PBFunctionScope)){
            funcScope = funcScope.$parent;
        }
        return funcScope;
    }
    /**
   * Generates shader codes for a render program
   * @param options - The build options
   * @returns a tuple made by vertex shader source, fragment shader source, bind group layouts and vertex attributes used, or null if build faild
   */ buildRender(options) {
        setCurrentProgramBuilder(this);
        this._lastError = null;
        this.defineInternalStructs();
        const ret = this.buildRenderSource(options);
        setCurrentProgramBuilder(null);
        this.reset();
        return ret;
    }
    /**
   * Generates shader code for a compute program
   * @param options - The build programs
   * @returns a tuple made by compute shader source and bind group layouts, or null if build failed
   */ buildCompute(options) {
        setCurrentProgramBuilder(this);
        this._lastError = null;
        this._workgroupSize = options.workgroupSize;
        this.defineInternalStructs();
        const ret = this.buildComputeSource(options);
        setCurrentProgramBuilder(null);
        this.reset();
        return ret;
    }
    /**
   * Creates a shader program for render
   * @param options - The build options
   * @returns The created program or null if build failed
   */ buildRenderProgram(options) {
        const ret = this.buildRender(options);
        return ret ? this._device.createGPUProgram({
            type: 'render',
            label: options.label,
            params: {
                vs: ret[0],
                fs: ret[1],
                bindGroupLayouts: ret[2],
                vertexAttributes: ret[3]
            }
        }) : null;
    }
    /**
   * Creates a shader program for compute
   * @param options - The build options
   * @returns The created program or null if build failed
   */ buildComputeProgram(options) {
        const ret = this.buildCompute(options);
        return ret ? this._device.createGPUProgram({
            type: 'compute',
            params: {
                source: ret[0],
                bindGroupLayouts: ret[1]
            }
        }) : null;
    }
    /**
   * Creates a function
   * @param name - Name of the function
   * @param params - Parameters of the function
   * @param body - The generator function
   */ func(name, params, body) {
        this.getGlobalScope().$createFunctionIfNotExists(name, params, body);
    }
    /**
   * Create the main entry function of the shader
   * @param body - The shader generator function
   */ main(body) {
        this.getGlobalScope().$mainFunc(body);
    }
    /**
   * Create an 'AddressOf' expression for WGSL
   * @param ref - The reference variable
   * @returns the 'AddressOf' expression
   */ addressOf(ref) {
        if (this._device.type !== 'webgpu') {
            throw new PBDeviceNotSupport('pointer shader type');
        }
        if (!ref.$ast.isReference()) {
            throw new PBReferenceValueRequired(ref);
        }
        const exp = new PBShaderExp('', ref.$ast.getType());
        exp.$ast = new ASTAddressOf(ref.$ast);
        return exp;
    }
    /**
   * Creates a 'referenceOf' expression for WGSL
   * @param ptr - The pointer variable
   * @returns the 'referenceOf' expression
   */ referenceOf(ptr) {
        if (this._device.type !== 'webgpu') {
            throw new PBDeviceNotSupport('pointer shader type');
        }
        if (!ptr.$ast.getType().isPointerType()) {
            throw new PBPointerValueRequired(ptr);
        }
        const ast = new ASTReferenceOf(ptr.$ast);
        const exp = new PBShaderExp('', ast.getType());
        exp.$ast = ast;
        return exp;
    }
    /**
   * Creates a structure type variable
   * @param structName - Name of the structure type
   * @param instanceName - Name of the variable
   * @returns the created variable
   */ struct(structName, instanceName) {
        let ctor = null;
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & this._shaderType) {
                const structInfo = this._structInfo[st];
                ctor = structInfo?.structs[structName];
                if (ctor) {
                    break;
                }
            }
        }
        if (!ctor) {
            throw new PBParamValueError('struct', 'structName', `Struct type ${structName} not exists`);
        }
        return ctor.call(this, instanceName);
    }
    /** @internal */ isIdenticalStruct(a, b, checkName) {
        if (checkName && a.structName && b.structName && a.structName !== b.structName) {
            return false;
        }
        if (a.structMembers.length !== b.structMembers.length) {
            return false;
        }
        for(let index = 0; index < a.structMembers.length; index++){
            const val = a.structMembers[index];
            const other = b.structMembers[index];
            if (val.name !== other.name) {
                return false;
            }
            if (val.type.isStructType()) {
                if (!other.type.isStructType()) {
                    return false;
                }
                if (!this.isIdenticalStruct(val.type, other.type, true)) {
                    return false;
                }
            } else if (!val.type.isCompatibleType(other.type)) {
                return false;
            }
        }
        return true;
    }
    /** @internal */ generateStructureName() {
        return `zStruct${this._autoStructureTypeIndex++}`;
    }
    /** @internal */ getVertexAttributes() {
        return this._vertexAttributes;
    }
    /** @internal */ defineHiddenStruct(type) {
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structInfo = this._structInfo[shaderType];
            if (!structInfo) {
                structInfo = {
                    structs: {},
                    types: []
                };
                this._structInfo[shaderType] = structInfo;
            }
            if (structInfo.structs[type.structName]) {
                throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${type.structName}'`);
            }
            structInfo.types.push(new ASTStructDefine(type, true));
        }
    }
    // /**
    //  * Defines an uniform buffer
    //  * @param name - Name of the uniform buffer
    //  * @param args - Members of the buffer structure
    //  * @returns The structure type constructor
    //  */
    // defineUniformBuffer(name: string, ...args: PBShaderExp[]): ShaderTypeFunc {
    //   return this.defineStructOrUniformBuffer(name, 'std140', ...args);
    // }
    // /**
    //  * Defines a structure type
    //  * @param structName - Name of the type
    //  * @param layout - The structure layout
    //  * @param args - Members of the structure
    //  * @returns The structure type constructor
    //  */
    // defineStruct(structName: string, ...args: PBShaderExp[]): ShaderTypeFunc {
    //   return this.defineStructOrUniformBuffer(structName, 'default', ...args);
    // }
    /**
   * Defines a structure type
   * @param members - Members of the structure
   * @param structName - Name of the type
   * @returns The structure type constructor
   */ defineStruct(members, structName) {
        const layout = 'default';
        const structType = new PBStructTypeInfo(structName ?? '', layout, members.map((arg)=>{
            if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType() && !arg.$typeinfo.isAtomicI32() && !arg.$typeinfo.isAtomicU32()) {
                throw new Error(`invalid struct member type: '${arg.$str}'`);
            }
            return {
                name: arg.$str,
                type: arg.$typeinfo
            };
        }));
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structDef = null;
            let ctor = null;
            const structInfo = this._structInfo[shaderType];
            if (structInfo) {
                if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[structType.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);
                }
                for (const type of structInfo.types){
                    if (!type.builtin && this.isIdenticalStruct(type.getType(), structType, false)) {
                        structDef = type;
                        ctor = structInfo.structs[type.getType().structName];
                        break;
                    }
                }
            }
            if (structDef) {
                if (structDef.type.layout !== layout) {
                    throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);
                }
                if (shaderType !== getCurrentProgramBuilder().shaderType) {
                    if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {
                        this._structInfo[getCurrentProgramBuilder().shaderType] = {
                            structs: {},
                            types: []
                        };
                    }
                    if (this._structInfo[getCurrentProgramBuilder().shaderType].types.indexOf(structDef) < 0) {
                        this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);
                        this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;
                    }
                }
                return ctor;
            }
        }
        return this.internalDefineStruct(structName ?? this.generateStructureName(), layout, this._shaderType, false, ...members);
    }
    /**
   * Defines a structure type
   * @param structType - The structure type info
   * @returns The structure type constructor
   */ defineStructByType(structType) {
        const typeCopy = structType.extends(structType.structName || this.generateStructureName(), []);
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structDef = null;
            let ctor = null;
            const structInfo = this._structInfo[shaderType];
            if (structInfo) {
                if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[typeCopy.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${typeCopy.structName}'`);
                }
                for (const type of structInfo.types){
                    if (!type.builtin && this.isIdenticalStruct(type.getType(), typeCopy, false)) {
                        structDef = type;
                        ctor = structInfo.structs[type.getType().structName];
                        break;
                    }
                }
            }
            if (structDef) {
                if (structDef.type.layout !== typeCopy.layout) {
                    throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);
                }
                if (shaderType !== getCurrentProgramBuilder().shaderType) {
                    if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {
                        this._structInfo[getCurrentProgramBuilder().shaderType] = {
                            structs: {},
                            types: []
                        };
                    }
                    this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);
                    this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;
                }
                return ctor;
            }
        }
        return this.internalDefineStructByType(this._shaderType, false, typeCopy);
    }
    /** @internal */ internalDefineStruct(structName, layout, shaderTypeMask, builtin, ...args) {
        const structType = new PBStructTypeInfo(structName, layout, args.map((arg)=>{
            if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType() && !arg.$typeinfo.isAtomicI32() && !arg.$typeinfo.isAtomicU32()) {
                throw new Error(`invalid struct member type: '${arg.$str}'`);
            }
            return {
                name: arg.$str,
                type: arg.$typeinfo
            };
        }));
        return this.internalDefineStructByType(shaderTypeMask, builtin, structType);
    }
    /** @internal */ internalDefineStructByType(shaderTypeMask, builtin, structType) {
        const struct = makeConstructor(function structConstructor(...blockArgs) {
            let e;
            if (blockArgs.length === 1 && typeof blockArgs[0] === 'string') {
                e = new PBShaderExp(blockArgs[0], structType);
            } else {
                e = new PBShaderExp('', structType);
                e.$ast = new ASTShaderExpConstructor(e.$typeinfo, blockArgs.map((arg)=>arg instanceof PBShaderExp ? arg.$ast : arg));
            }
            return e;
        }, structType);
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (shaderTypeMask & shaderType) {
                let structInfo = this._structInfo[shaderType];
                if (!structInfo) {
                    structInfo = {
                        structs: {},
                        types: []
                    };
                    this._structInfo[shaderType] = structInfo;
                }
                if (structInfo.structs[structType.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);
                }
                structInfo.types.push(new ASTStructDefine(structType, builtin));
                structInfo.structs[structType.structName] = struct;
            }
        }
        // this.changeStructLayout(structType, layout);
        return struct;
    }
    /** @internal */ getFunction(name) {
        return this._globalScope ? this._globalScope.$getFunctions(name) : null;
    }
    /** @internal */ get structInfo() {
        return this._structInfo[this._shaderType];
    }
    /** @internal */ getBlockName(instanceName) {
        return `ch_block_name_${instanceName}`;
    }
    /** @internal */ defineBuiltinStruct(shaderType, inOrOut) {
        const structName = inOrOut === 'in' ? getBuiltinInputStructName(shaderType) : getBuiltinOutputStructName(shaderType);
        const instanceName = inOrOut === 'in' ? getBuiltinInputStructInstanceName(shaderType) : getBuiltinOutputStructInstanceName(shaderType);
        const stage = shaderType === ShaderType.Vertex ? 'vertex' : shaderType === ShaderType.Fragment ? 'fragment' : 'compute';
        const builtinVars = builtinVariables['webgpu'];
        const args = [];
        const prefix = [];
        for(const k in builtinVars){
            if (builtinVars[k].stage === stage && builtinVars[k].inOrOut === inOrOut) {
                args.push({
                    name: builtinVars[k].name,
                    type: builtinVars[k].type
                });
                prefix.push(`@builtin(${builtinVars[k].semantic}) `);
            }
        }
        const inoutList = inOrOut === 'in' ? this._inputs : this._outputs;
        for (const k of inoutList){
            // for debug only
            if (!(k[1] instanceof ASTDeclareVar)) {
                throw new PBInternalError('defineBuiltinStruct() failed: input/output is not declare var ast node');
            }
            const type = k[1].value.getType();
            if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {
                throw new Error(`invalid in/out variable type: '${k[1].value.name}'`);
            }
            args.push({
                name: k[1].value.name,
                type: type
            });
            prefix.push(`@location(${k[1].value.value.$location}) ${type.isPrimitiveType() && type.isInteger() ? '@interpolate(flat) ' : ''}`);
        }
        if (args.length > 0) {
            const st = this.findStructType(structName, shaderType);
            if (st) {
                st.getType().reset(structName, 'default', args);
                st.prefix = prefix;
                return null;
            } else {
                const structType = this.internalDefineStructByType(this._shaderType, false, new PBStructTypeInfo(structName, 'default', args));
                this.findStructType(structName, shaderType).prefix = prefix;
                const structInstance = this.struct(structName, instanceName);
                const structInstanceIN = inOrOut === 'in' ? this.struct(structName, getBuiltinParamName(shaderType)) : structInstance;
                return [
                    structType,
                    structInstance,
                    structName,
                    structInstanceIN
                ];
            }
        } else {
            return null;
        }
    }
    /** @internal */ defineInternalStructs() {
        this.defineHiddenStruct(typeFrexpResult);
        this.defineHiddenStruct(typeFrexpResultVec2);
        this.defineHiddenStruct(typeFrexpResultVec3);
        this.defineHiddenStruct(typeFrexpResultVec4);
    }
    /** @internal */ array(...args) {
        if (args.length === 0) {
            throw new PBParamLengthError('array');
        }
        args = args.map((arg)=>this.normalizeExpValue(arg));
        let typeok = true;
        let type = null;
        let isBool = true;
        let isFloat = true;
        let isInt = true;
        let isUint = true;
        let isComposite = false;
        for (const arg of args){
            if (arg instanceof PBShaderExp) {
                const argType = arg.$ast.getType();
                if (!argType.isConstructible()) {
                    typeok = false;
                    break;
                }
                if (!type) {
                    type = argType;
                } else if (!argType.isCompatibleType(type)) {
                    typeok = false;
                }
            }
        }
        if (typeok) {
            if (type && type.isPrimitiveType() && type.isScalarType()) {
                isBool = type.primitiveType === PBPrimitiveType.BOOL;
                isFloat = type.primitiveType === PBPrimitiveType.F32;
                isUint = type.primitiveType === PBPrimitiveType.U32;
                isInt = type.primitiveType === PBPrimitiveType.I32;
            } else if (type) {
                isBool = false;
                isFloat = false;
                isUint = false;
                isInt = false;
                isComposite = true;
            }
            for (const arg of args){
                if (!(arg instanceof PBShaderExp) && isComposite) {
                    typeok = false;
                    break;
                }
                if (typeof arg === 'number') {
                    isBool = false;
                    if ((arg | 0) === arg) {
                        if (arg < 0) {
                            isUint = false;
                            isInt = isInt && arg >= 0x80000000 >> 0;
                        } else {
                            isUint = isUint && arg <= 0xffffffff;
                            isInt = isInt && arg <= 0x7fffffff;
                        }
                    }
                } else if (typeof arg === 'boolean') {
                    isFloat = false;
                    isInt = false;
                    isUint = false;
                }
            }
        }
        if (typeok && !isComposite) {
            if (isBool) {
                type = typeBool;
            } else if (isInt) {
                type = typeI32$1;
            } else if (isUint) {
                type = typeU32$3;
            } else if (isFloat) {
                type = typeF32$1;
            }
            typeok = !!type;
        }
        if (!typeok) {
            throw new PBParamTypeError('array');
        }
        if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {
            throw new PBParamTypeError('array');
        }
        const arrayType = new PBArrayTypeInfo(type, args.length);
        const exp = new PBShaderExp('', arrayType);
        exp.$ast = new ASTShaderExpConstructor(arrayType, args.map((arg)=>{
            if (arg instanceof PBShaderExp) {
                return arg.$ast;
            }
            if (!type.isPrimitiveType() || !type.isScalarType()) {
                throw new PBTypeCastError(arg, typeof arg, type);
            }
            return new ASTScalar(arg, type);
        }));
        return exp;
    }
    /**
   * Creates a 'discard' statement
   */ discard() {
        this.getCurrentScope().$ast.statements.push(new ASTDiscard());
    }
    /** @internal */ tagShaderExp(getter, tagValue) {
        if (typeof tagValue === 'string') {
            this._reflection.tag(tagValue, getter);
        } else if (Array.isArray(tagValue)) {
            tagValue.forEach((tag)=>this.tagShaderExp(getter, tag));
        } else {
            for (const k of Object.keys(tagValue)){
                this.tagShaderExp((scope)=>{
                    const value = getter(scope);
                    return value[k];
                }, tagValue[k]);
            }
        }
    }
    /** @internal */ in(location, name, variable) {
        if (this._inputs[location]) {
            // input already exists, create an alias
            if (!this._inputScope[name]) {
                Object.defineProperty(this._inputScope, name, {
                    get: function() {
                        return variable;
                    },
                    set: function() {
                        throw new Error(`cannot assign to readonly variable: ${name}`);
                    }
                });
            }
        //throw new Error(`input location ${location} already declared`);
        } else {
            variable.$location = location;
            variable.$declareType = DeclareType.DECLARE_TYPE_IN;
            this._inputs[location] = [
                name,
                new ASTDeclareVar(new ASTPrimitive(variable))
            ];
            Object.defineProperty(this._inputScope, name, {
                get: function() {
                    return variable;
                },
                set: function() {
                    throw new Error(`cannot assign to readonly variable: ${name}`);
                }
            });
            variable.$tags.forEach((val)=>this.tagShaderExp(()=>variable, val));
        }
    }
    /** @internal */ out(location, name, variable) {
        if (this._outputs[location]) {
            throw new Error(`output location ${location} has already been used`);
        }
        variable.$location = location;
        variable.$declareType = DeclareType.DECLARE_TYPE_OUT;
        this._outputs[location] = [
            name,
            new ASTDeclareVar(new ASTPrimitive(variable))
        ];
        Object.defineProperty(this._outputScope, name, {
            get: function() {
                return variable;
            },
            set: function(v) {
                getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(variable.$ast), v instanceof PBShaderExp ? v.$ast : v));
            }
        });
    }
    /** @internal */ getDefaultSampler(t, comparison) {
        const u = this._uniforms.findIndex((val)=>val.texture?.exp === t);
        if (u < 0) {
            return;
        //throw new Error('invalid texture uniform object');
        }
        const samplerType = comparison ? 'comparison' : 'sample';
        if (this._uniforms[u].texture.autoBindSampler && this._uniforms[u].texture.autoBindSampler !== samplerType) {
            throw new Error('multiple sampler not supported');
        }
        this._uniforms[u].texture.autoBindSampler = samplerType;
        if (this._device.type === 'webgpu') {
            const samplerName = genSamplerName(t.$str, comparison);
            if (!this.getGlobalScope()[samplerName]) {
                throw new Error(`failed to find sampler name ${samplerName}`);
            }
            return this.getGlobalScope()[samplerName];
        } else {
            return null;
        }
    }
    /** @internal */ normalizeExpValue(value) {
        if (Array.isArray(value)) {
            const converted = value.map((val)=>Array.isArray(val) ? this.normalizeExpValue(val) : val);
            return this.array(...converted);
        } else {
            return value;
        }
    }
    /** @internal */ guessExpValueType(value) {
        const val = this.normalizeExpValue(value);
        if (typeof val === 'boolean') {
            return typeBool;
        } else if (typeof val === 'number') {
            if (!Number.isInteger(val)) {
                return typeF32$1;
            } else if (val >= 0x80000000 >> 1 && val <= 0x7fffffff) {
                return typeI32$1;
            } else if (val >= 0 && val <= 0xffffffff) {
                return typeU32$3;
            } else {
                throw new PBValueOutOfRange(val);
            }
        } else if (val instanceof PBShaderExp) {
            return val.$ast?.getType() || val.$typeinfo;
        }
    }
    /** @internal */ findStructType(name, shaderType) {
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & shaderType) {
                const structInfo = this._structInfo[st];
                if (structInfo) {
                    for (const t of structInfo.types){
                        if (t.type.structName === name) {
                            return t;
                        }
                    }
                }
            }
        }
        return null;
    }
    /** @internal */ findStructConstructor(name, shaderType) {
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & shaderType) {
                const structInfo = this._structInfo[st];
                if (structInfo && structInfo.structs?.[name]) {
                    return structInfo.structs[name];
                }
            }
        }
        return null;
    }
    /** @internal */ buildComputeSource(options) {
        try {
            this._lastError = null;
            this._shaderType = ShaderType.Compute;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            this.generate(options.compute);
            // this.removeUnusedSamplerBindings(this._globalScope);
            this.mergeUniformsCompute(this._globalScope);
            this.updateUniformBindings([
                this._globalScope
            ], [
                ShaderType.Compute
            ]);
            return [
                this.generateComputeSource(this._globalScope, this._builtinScope),
                this.createBindGroupLayouts(options.label)
            ];
        } catch (err) {
            if (err instanceof PBError) {
                this._lastError = err.getMessage(this._device.type);
                console.error(this._lastError);
                return null;
            } else if (err instanceof Error) {
                this._lastError = err.toString();
                console.error(this._lastError);
                return null;
            } else {
                this._lastError = Object.prototype.toString.call(err);
                console.log(`Error: ${this._lastError}`);
                return null;
            }
        }
    }
    /** @internal */ buildRenderSource(options) {
        try {
            this._lastError = null;
            this._shaderType = ShaderType.Vertex;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            this.generate(options.vertex);
            const vertexScope = this._globalScope;
            const vertexBuiltinScope = this._builtinScope;
            const vertexInputs = this._inputs;
            const vertexOutputs = this._outputs;
            if (this._device.type === 'webgpu') {
            // this.removeUnusedSamplerBindings(vertexScope);
            }
            this._shaderType = ShaderType.Fragment;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            vertexOutputs.forEach((val, index)=>{
                this.in(index, val[0], new PBShaderExp(val[1].value.name, val[1].value.getType()).tag(...val[1].value.value.$tags));
            });
            this.generate(options.fragment);
            const fragScope = this._globalScope;
            const fragBuiltinScope = this._builtinScope;
            const fragInputs = this._inputs;
            const fragOutputs = this._outputs;
            if (this._device.type === 'webgpu') {
            // this.removeUnusedSamplerBindings(fragScope);
            }
            this.mergeUniforms(vertexScope, fragScope);
            this.updateUniformBindings([
                vertexScope,
                fragScope
            ], [
                ShaderType.Vertex,
                ShaderType.Fragment
            ]);
            return [
                this.generateRenderSource(ShaderType.Vertex, vertexScope, vertexBuiltinScope, vertexInputs.map((val)=>val[1]), vertexOutputs.map((val)=>val[1])),
                this.generateRenderSource(ShaderType.Fragment, fragScope, fragBuiltinScope, fragInputs.map((val)=>val[1]), fragOutputs.map((val)=>val[1])),
                this.createBindGroupLayouts(options.label),
                this._vertexAttributes
            ];
        } catch (err) {
            if (err instanceof PBError) {
                this._lastError = err.getMessage(this._device.type);
                console.error(this._lastError);
                return null;
            } else if (err instanceof Error) {
                this._lastError = err.toString();
                console.error(this._lastError);
                return null;
            } else {
                this._lastError = Object.prototype.toString.call(err);
                console.log(`Error: ${this._lastError}`);
                return null;
            }
        }
    }
    /** @internal */ generate(body) {
        this.pushScope(this._globalScope);
        if (this._emulateDepthClamp && this._shaderType === ShaderType.Vertex) {
            this._globalScope.$outputs.clamppedDepth = this.float().tag('CLAMPPED_DEPTH');
        }
        body && body.call(this._globalScope, this);
        this.popScope();
        // Global delcarations should be at the first
        this._globalScope.$ast.statements = [
            ...this._globalScope.$ast.statements.filter((val)=>val instanceof ASTDeclareVar || val instanceof ASTAssignment),
            ...this._globalScope.$ast.statements.filter((val)=>!(val instanceof ASTDeclareVar) && !(val instanceof ASTAssignment))
        ];
    }
    /** @internal */ generateRenderSource(shaderType, scope, builtinScope, inputs, outputs) {
        const context = {
            type: shaderType,
            mrt: shaderType === ShaderType.Fragment && outputs.length > 1,
            defines: [],
            extensions: new Set(),
            builtins: [
                ...builtinScope.$_usedBuiltins
            ],
            types: this._structInfo[shaderType]?.types || [],
            typeReplacement: new Map(),
            inputs: inputs,
            outputs: outputs,
            global: scope,
            vertexAttributes: this._vertexAttributes,
            workgroupSize: null
        };
        switch(this._device.type){
            case 'webgl':
                for (const u of this._uniforms){
                    if (u.texture) {
                        const type = u.texture.exp.$ast.getType();
                        if (type.isTextureType() && type.isDepthTexture()) {
                            if (u.texture.autoBindSampler === 'comparison') {
                                throw new PBDeviceNotSupport('depth texture comparison');
                            }
                            if (u.texture.autoBindSampler === 'sample') {
                                if (type.is2DTexture()) {
                                    context.typeReplacement.set(u.texture.exp, typeTex2D);
                                } else if (type.isCubeTexture()) {
                                    context.typeReplacement.set(u.texture.exp, typeTexCube);
                                }
                            }
                        }
                    }
                }
                return scope.$ast.toWebGL('', context);
            case 'webgl2':
                for (const u of this._uniforms){
                    if (u.texture) {
                        const type = u.texture.exp.$ast.getType();
                        if (type.isTextureType() && type.isDepthTexture() && u.texture.autoBindSampler === 'sample') {
                            if (type.is2DTexture()) {
                                context.typeReplacement.set(u.texture.exp, type.isArrayTexture() ? typeTex2DArray : typeTex2D);
                            } else if (type.isCubeTexture()) {
                                context.typeReplacement.set(u.texture.exp, typeTexCube);
                            }
                        }
                    }
                }
                return scope.$ast.toWebGL2('', context);
            case 'webgpu':
                return scope.$ast.toWGSL('', context);
            default:
                return null;
        }
    }
    /** @internal */ generateComputeSource(scope, builtinScope) {
        const context = {
            type: ShaderType.Compute,
            mrt: false,
            defines: [],
            extensions: new Set(),
            builtins: [
                ...builtinScope.$_usedBuiltins
            ],
            types: this._structInfo[ShaderType.Compute]?.types || [],
            typeReplacement: null,
            inputs: [],
            outputs: [],
            global: scope,
            vertexAttributes: [],
            workgroupSize: this._workgroupSize
        };
        return scope.$ast.toWGSL('', context);
    }
    /** @internal */ mergeUniformsCompute(globalScope) {
        const uniformList = [];
        for(let i = 0; i < this._uniforms.length; i++){
            const u = this._uniforms[i];
            if (u.block && (u.block.exp.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || u.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE)) {
                if (u.block.exp.$typeinfo.isStructType() && u.block.exp.$isBuffer) {
                    continue;
                }
                if (!uniformList[u.group]) {
                    uniformList[u.group] = [];
                }
                const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                exp.$declareType = u.block.exp.$declareType;
                exp.$isBuffer = u.block.exp.$isBuffer;
                uniformList[u.group].push({
                    member: exp,
                    uniform: i
                });
            }
        }
        for(const k in uniformList){
            if (uniformList[k].length > 0) {
                const types = [
                    'std140',
                    'std430'
                ];
                const nameList = [
                    COMPUTE_UNIFORM_NAME,
                    COMPUTE_STORAGE_NAME
                ];
                const ulist = [
                    uniformList[k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_UNIFORM),
                    uniformList[k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_STORAGE)
                ];
                for(let i = 0; i < 2; i++){
                    if (ulist[i].length === 0) {
                        continue;
                    }
                    const nonBufferList = ulist[i].filter((val)=>!val.member.$isBuffer);
                    const bufferList = ulist[i].filter((val)=>val.member.$isBuffer);
                    const allLists = [
                        nonBufferList,
                        ...bufferList.map((val)=>[
                                val
                            ])
                    ];
                    for(let p = 0; p < allLists.length; p++){
                        if (allLists[p].length === 0) {
                            continue;
                        }
                        const uname = `${nameList[i]}_${k}_${p}`;
                        const structName = this.generateStructureName();
                        const t = getCurrentProgramBuilder().internalDefineStruct(structName, types[i], ShaderType.Compute, false, ...allLists[p].map((val)=>val.member));
                        const exp = t();
                        if (i === 0) {
                            exp.uniformBuffer(Number(k));
                        } else {
                            exp.storageBuffer(Number(k));
                        }
                        globalScope[uname] = exp;
                        const index = this._uniforms.findIndex((val)=>val.block?.name === uname);
                        this._uniforms[index].mask = ShaderType.Compute;
                        let nameMap = this._nameMap[Number(k)];
                        if (!nameMap) {
                            nameMap = {};
                            this._nameMap[Number(k)] = nameMap;
                        }
                        let writable = false;
                        for(let n = allLists[p].length - 1; n >= 0; n--){
                            const u = allLists[p][n];
                            const exp = this._uniforms[u.uniform].block.exp;
                            nameMap[exp.$str] = uname;
                            exp.$str = `${uname}.${exp.$str}`;
                            writable ||= exp.$ast.isWritable();
                        }
                        if (writable) {
                            globalScope[uname].$ast.markWritable();
                        }
                    }
                }
            }
        }
        this._uniforms = this._uniforms.filter((val)=>{
            return !val.block || val.block.exp.$typeinfo.isStructType() && val.block.exp.$isBuffer;
        //return !val.block || val.block.exp.$isBuffer;
        /*
      if (!val.block || (val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_UNIFORM && val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_STORAGE)) {
        return true;
      }
      const type = val.block.exp.$ast.getType();
      return (
        type.isTextureType() ||
        type.isSamplerType() ||
        (type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430'))
      );
      */ });
    }
    /** @internal */ mergeUniforms(globalScopeVertex, globalScopeFragmet) {
        const vertexUniformList = [];
        const fragUniformList = [];
        const sharedUniformList = [];
        //const vertexUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        //const fragUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        //const sharedUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        for(let i = 0; i < this._uniforms.length; i++){
            const u = this._uniforms[i];
            if (u.block && (u.block.exp.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || u.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE)) {
                if (u.block.exp.$typeinfo.isStructType() && u.block.exp.$isBuffer) {
                    continue;
                }
                const v = !!(u.mask & ShaderType.Vertex);
                const f = !!(u.mask & ShaderType.Fragment);
                if (v && f) {
                    if (!sharedUniformList[u.group]) {
                        sharedUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    sharedUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    });
                //sharedUniformList[u.group].uniforms.push(i);
                } else if (v) {
                    if (!vertexUniformList[u.group]) {
                        vertexUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    vertexUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    });
                //vertexUniformList[u.group].uniforms.push(i);
                } else if (f) {
                    if (!fragUniformList[u.group]) {
                        fragUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    fragUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    }); //members.push(exp);
                //fragUniformList[u.group].uniforms.push(i);
                }
            }
        }
        const uniformLists = [
            vertexUniformList,
            fragUniformList,
            sharedUniformList
        ];
        const nameListUniform = [
            VERTEX_UNIFORM_NAME,
            FRAGMENT_UNIFORM_NAME,
            SHARED_UNIFORM_NAME
        ];
        const nameListStorage = [
            VERTEX_STORAGE_NAME,
            FRAGMENT_STORAGE_NAME,
            SHARED_STORAGE_NAME
        ];
        const maskList = [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Vertex | ShaderType.Fragment
        ];
        for(let i = 0; i < 3; i++){
            for(const k in uniformLists[i]){
                if (uniformLists[i][k]?.length > 0) {
                    const ulist = [
                        uniformLists[i][k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_UNIFORM),
                        uniformLists[i][k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_STORAGE)
                    ];
                    const nameList = [
                        nameListUniform,
                        nameListStorage
                    ];
                    const layoutList = [
                        'std140',
                        'std430'
                    ];
                    for(let j = 0; j < 2; j++){
                        if (ulist[j].length === 0) {
                            continue;
                        }
                        const nonBufferList = ulist[j].filter((val)=>!val.member.$isBuffer);
                        const bufferList = ulist[j].filter((val)=>val.member.$isBuffer);
                        const allLists = [
                            nonBufferList,
                            ...bufferList.map((val)=>[
                                    val
                                ])
                        ];
                        for(let p = 0; p < allLists.length; p++){
                            if (allLists[p].length === 0) {
                                continue;
                            }
                            const uname = `${nameList[j][i]}_${k}_${p}`;
                            const structName = this.generateStructureName();
                            const t = getCurrentProgramBuilder().internalDefineStruct(structName, layoutList[j], maskList[i], false, ...allLists[p].map((val)=>val.member));
                            if (maskList[i] & ShaderType.Vertex) {
                                const exp = t();
                                if (j === 0) {
                                    exp.uniformBuffer(Number(k));
                                } else {
                                    exp.storageBuffer(Number(k));
                                }
                                globalScopeVertex[uname] = exp;
                            }
                            if (maskList[i] & ShaderType.Fragment) {
                                const exp = t();
                                if (j === 0) {
                                    exp.uniformBuffer(Number(k));
                                } else {
                                    exp.storageBuffer(Number(k));
                                }
                                globalScopeFragmet[uname] = exp;
                            }
                            const index = this._uniforms.findIndex((val)=>val.block?.name === uname);
                            this._uniforms[index].mask = maskList[i];
                            let nameMap = this._nameMap[Number(k)];
                            if (!nameMap) {
                                nameMap = {};
                                this._nameMap[Number(k)] = nameMap;
                            }
                            let writable = false;
                            for(let n = allLists[p].length - 1; n >= 0; n--){
                                const u = allLists[p][n];
                                const exp = this._uniforms[u.uniform].block.exp;
                                nameMap[exp.$str] = uname;
                                exp.$str = `${uname}.${exp.$str}`;
                                writable ||= exp.$ast.isWritable();
                            }
                            if (writable) {
                                if (maskList[i] & ShaderType.Vertex) {
                                    globalScopeVertex[uname].$ast.markWritable();
                                } else {
                                    globalScopeFragmet[uname].$ast.markWritable();
                                }
                            }
                        }
                    }
                }
            }
        }
        this._uniforms = this._uniforms.filter((val)=>{
            return !val.block || val.block.exp.$typeinfo.isStructType() && val.block.exp.$isBuffer;
        /*
      if (!val.block) {
        return true;
      }
      const type = val.block.exp.$ast.getType();
      return (
        type.isTextureType() ||
        type.isSamplerType() ||
        (type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430'))
      );
      */ });
    }
    /** @internal */ updateUniformBindings(scopes, shaderTypes) {
        this._uniforms = this._uniforms.filter((val)=>!!val.mask);
        const bindings = Array.from({
            length: MAX_BINDING_GROUPS
        }).fill(0);
        for (const u of this._uniforms){
            u.binding = bindings[u.group]++;
        }
        for(let i = 0; i < scopes.length; i++){
            const scope = scopes[i];
            const type = shaderTypes[i];
            for (const u of this._uniforms){
                if (u.mask & type) {
                    const uniforms = scope.$ast.uniforms;
                    const name = u.block ? u.block.name : u.texture ? u.texture.exp.$str : u.sampler.$str;
                    const index = uniforms.findIndex((val)=>val.value.name === name);
                    if (index < 0) {
                        throw new Error(`updateUniformBindings() failed: unable to find uniform ${name}`);
                    }
                    uniforms[index].binding = u.binding;
                }
            }
        }
    }
    /** @internal */ createBindGroupLayouts(label) {
        const layouts = [];
        for (const uniformInfo of this._uniforms){
            let layout = layouts[uniformInfo.group];
            if (!layout) {
                layout = {
                    label: `${label || 'unknown'}[${uniformInfo.group}]`,
                    entries: []
                };
                if (this._nameMap[uniformInfo.group]) {
                    layout.nameMap = this._nameMap[uniformInfo.group];
                }
                layouts[uniformInfo.group] = layout;
            }
            const entry = {
                binding: uniformInfo.binding,
                visibility: uniformInfo.mask,
                type: null,
                name: ''
            };
            if (uniformInfo.block) {
                entry.type = uniformInfo.block.exp.$typeinfo.clone(this.getBlockName(uniformInfo.block.name));
                const isStorage = uniformInfo.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE;
                entry.buffer = {
                    type: isStorage ? uniformInfo.block.exp.$ast.isWritable() ? 'storage' : 'read-only-storage' : 'uniform',
                    hasDynamicOffset: uniformInfo.block.dynamicOffset,
                    uniformLayout: entry.type.toBufferLayout(0, entry.type.layout)
                };
                entry.name = uniformInfo.block.name;
            } else if (uniformInfo.texture) {
                entry.type = uniformInfo.texture.exp.$typeinfo;
                if (!entry.type.isTextureType()) {
                    throw new Error('internal error');
                }
                if (entry.type.isStorageTexture()) {
                    entry.storageTexture = {
                        access: 'write-only',
                        viewDimension: entry.type.is1DTexture() ? '1d' : '2d',
                        format: entry.type.storageTexelFormat
                    };
                } else if (entry.type.isExternalTexture()) {
                    entry.externalTexture = {
                        autoBindSampler: uniformInfo.texture.autoBindSampler ? genSamplerName(uniformInfo.texture.exp.$str, false) : null
                    };
                } else {
                    const sampleType = this._device.type === 'webgpu' ? uniformInfo.texture.exp.$sampleType : uniformInfo.texture.autoBindSampler && entry.type.isDepthTexture() ? 'float' : uniformInfo.texture.exp.$sampleType;
                    let viewDimension;
                    if (entry.type.isArrayTexture()) {
                        viewDimension = entry.type.isCubeTexture() ? 'cube-array' : '2d-array';
                    } else if (entry.type.is3DTexture()) {
                        viewDimension = '3d';
                    } else if (entry.type.isCubeTexture()) {
                        viewDimension = 'cube';
                    } else if (entry.type.is1DTexture()) {
                        viewDimension = '1d';
                    } else {
                        viewDimension = '2d';
                    }
                    entry.texture = {
                        sampleType: sampleType,
                        viewDimension: viewDimension,
                        multisampled: false,
                        autoBindSampler: null,
                        autoBindSamplerComparison: null
                    };
                    if (this._device.type === 'webgpu' || uniformInfo.texture.autoBindSampler === 'sample') {
                        entry.texture.autoBindSampler = genSamplerName(uniformInfo.texture.exp.$str, false);
                    }
                    if (this._device.type === 'webgpu' && entry.type.isDepthTexture() || uniformInfo.texture.autoBindSampler === 'comparison') {
                        entry.texture.autoBindSamplerComparison = genSamplerName(uniformInfo.texture.exp.$str, true);
                    }
                }
                entry.name = uniformInfo.texture.exp.$str;
            } else if (uniformInfo.sampler) {
                entry.type = uniformInfo.sampler.$typeinfo;
                if (!entry.type.isSamplerType()) {
                    throw new Error('internal error');
                }
                entry.sampler = {
                    type: entry.type.accessMode === PBSamplerAccessMode.SAMPLE ? uniformInfo.sampler.$sampleType === 'float' ? 'filtering' : 'non-filtering' : 'comparison'
                };
                entry.name = uniformInfo.sampler.$str;
            } else {
                throw new PBInternalError('invalid uniform entry type');
            }
            layout.entries.push(entry);
        }
        for(let i = 0; i < layouts.length; i++){
            if (!layouts[i]) {
                layouts[i] = {
                    label: `${label || 'unknown'}[${i}]`,
                    entries: []
                };
            }
        }
        return layouts;
    }
    /** @internal */ _getFunctionOverload(funcName, args) {
        const thisArgs = args.filter((val)=>{
            if (val instanceof PBShaderExp) {
                const type = val.$ast.getType();
                if (type.isStructType() && this._structInfo[this._shaderType]?.types.findIndex((t)=>t.type.structName === type.structName) < 0) {
                    return false;
                }
            }
            return true;
        });
        const fn = this.getGlobalScope().$getFunctions(funcName);
        return fn ? this._matchFunctionOverloading(fn, thisArgs) : null;
    }
    /** @internal */ _matchFunctionOverloading(overloadings, args) {
        for (const overload of overloadings){
            if (args.length !== overload.funcType.argTypes.length) {
                continue;
            }
            const result = [];
            let matches = true;
            for(let i = 0; i < args.length; i++){
                const argInfo = overload.funcType.argTypes[i];
                const argType = argInfo.byRef && argInfo.type instanceof PBPointerTypeInfo ? argInfo.type.pointerType : argInfo.type;
                const arg = args[i];
                if (typeof arg === 'boolean') {
                    if (!argType.isPrimitiveType() || argType.primitiveType !== PBPrimitiveType.BOOL) {
                        matches = false;
                        break;
                    }
                    result.push(new ASTScalar(arg, typeBool));
                } else if (typeof arg === 'number') {
                    if (!argType.isPrimitiveType() || !argType.isScalarType() || argType.scalarType === PBPrimitiveType.BOOL) {
                        matches = false;
                        break;
                    }
                    if (argType.scalarType === PBPrimitiveType.I32) {
                        if (!Number.isInteger(arg) || arg < 0x80000000 >> 0 || arg > 0x7fffffff) {
                            matches = false;
                            break;
                        }
                        result.push(new ASTScalar(arg, typeI32$1));
                    } else if (argType.scalarType === PBPrimitiveType.U32) {
                        if (!Number.isInteger(arg) || arg < 0 || arg > 0xffffffff) {
                            matches = false;
                            break;
                        }
                        result.push(new ASTScalar(arg, typeU32$3));
                    } else {
                        result.push(new ASTScalar(arg, argType));
                    }
                } else {
                    if (!argType.isCompatibleType(arg.$ast.getType())) {
                        matches = false;
                        break;
                    }
                    result.push(arg.$ast);
                }
            }
            if (matches) {
                return [
                    overload,
                    result
                ];
            }
        }
        return null;
    }
    /** @internal */ $callFunction(funcName, args, func) {
        if (this.getCurrentScope() === this.getGlobalScope()) {
            throw new PBNonScopedFunctionCall(funcName);
        }
        const exp = new PBShaderExp('', func.returnType);
        exp.$ast = new ASTCallFunction(funcName, args, func, getCurrentProgramBuilder().getDevice().type);
        this.getCurrentScope().$ast.statements.push(exp.$ast);
        return exp;
    }
    /** @internal */ $callFunctionNoCheck(funcName, args, retType) {
        if (this.getCurrentScope() === this.getGlobalScope()) {
            throw new PBNonScopedFunctionCall(funcName);
        }
        const exp = new PBShaderExp('', retType);
        exp.$ast = new ASTCallFunction(funcName, args, null, getCurrentProgramBuilder().getDevice().type, retType);
        this.getCurrentScope().$ast.statements.push(exp.$ast);
        return exp;
    }
}
/**
 * Base class for scope of the shader program
 * @public
 */ class PBScope extends Proxiable {
    /** @internal */ $_variables;
    /** @internal */ $_parentScope;
    /** @internal */ $_AST;
    /** @internal */ $_localScope;
    /** @internal */ constructor(astScope, parent){
        super();
        this.$_parentScope = parent || null;
        this.$_variables = {};
        this.$_AST = astScope;
        this.$_localScope = null;
    }
    /** Get the program builder */ get $builder() {
        return getCurrentProgramBuilder();
    }
    /** Returns the scope of the builtin variables */ get $builtins() {
        return getCurrentProgramBuilder().builtinScope;
    }
    /** Returns the scope of the input variables */ get $inputs() {
        return getCurrentProgramBuilder().inputScope;
    }
    /** Returns the scope of the output variables */ get $outputs() {
        return getCurrentProgramBuilder().outputScope;
    }
    /** @internal */ get $parent() {
        return this.$_parentScope;
    }
    /** @internal */ get $ast() {
        return this.$_AST;
    }
    /** @internal */ set $ast(ast) {
        this.$_AST = ast;
    }
    /**
   * Get the input vertex attribute by specified semantic
   *
   * @remarks
   * Can only be called only in vertex shader
   *
   * @param semantic - The vertex semantic
   * @returns The input vertex attribute or null if not exists
   */ $getVertexAttrib(semantic) {
        return this.$inputs.$getVertexAttrib(semantic); // getCurrentProgramBuilder().getReflection().attribute(semantic);
    }
    /** Get the current local scope */ get $l() {
        return this.$_getLocalScope();
    }
    /** Get the global scope */ get $g() {
        return this.$_getGlobalScope();
    }
    /** @internal */ $local(variable, init) {
        const initNonArray = getCurrentProgramBuilder().normalizeExpValue(init);
        variable.$global = this instanceof PBGlobalScope;
        this.$_declare(variable, initNonArray);
    }
    /** @internal */ $touch(exp) {
        this.$ast.statements.push(new ASTTouch(exp.$ast));
    }
    /**
   * Query the global variable by the name
   * @param name - Name of the variable
   * @returns The variable or null if not exists
   */ $query(name) {
        return this.$builder.getReflection().tag(name);
    }
    /** @internal */ $_declareInternal(variable, init) {
        const key = variable.$str;
        if (this.$_variables[key]) {
            throw new Error(`cannot re-declare variable '${key}'`);
        }
        if (!(variable.$ast instanceof ASTPrimitive)) {
            throw new Error(`invalid variable declaration: '${variable.$ast.toString(getCurrentProgramBuilder().getDevice().type)}'`);
        }
        const varType = variable.$typeinfo;
        if (varType.isPointerType()) {
            if (!init) {
                throw new Error(`cannot declare pointer type variable without initialization: '${variable.$str}'`);
            }
            if (!(init instanceof PBShaderExp)) {
                throw new Error(`invalid initialization for pointer type declaration: '${variable.$str}`);
            }
            const initType = init.$ast.getType();
            if (!initType.isPointerType() || !varType.pointerType.isCompatibleType(initType.pointerType)) {
                throw new Error(`incompatible pointer type assignment: '${variable.$str}'`);
            }
            variable.$typeinfo = initType;
        }
        this.$_registerVar(variable, key);
        if (init === undefined || init === null) {
            return new ASTDeclareVar(variable.$ast);
        } else {
            if (init instanceof PBShaderExp && init.$ast instanceof ASTShaderExpConstructor && init.$ast.args.length === 0) {
                if (!init.$ast.getType().isCompatibleType(variable.$ast.getType())) {
                    throw new PBTypeCastError(init, init.$ast.getType(), variable.$ast.getType());
                }
                return new ASTDeclareVar(variable.$ast);
            } else {
                return new ASTAssignment(new ASTLValueDeclare(variable.$ast), init instanceof PBShaderExp ? init.$ast : init);
            }
        }
    }
    /** @internal */ $_findOrSetUniform(variable) {
        const name = variable.$str;
        const uniformInfo = {
            group: variable.$group,
            binding: 0,
            mask: 0
        };
        if (variable.$typeinfo.isTextureType()) {
            uniformInfo.texture = {
                autoBindSampler: null,
                exp: variable
            };
        } else if (variable.$typeinfo.isSamplerType()) {
            uniformInfo.sampler = variable;
        } else {
            uniformInfo.block = {
                name: name,
                dynamicOffset: false,
                exp: variable
            };
        // throw new Error(`unsupported uniform type: ${name}`);
        }
        let found = false;
        for (const u of getCurrentProgramBuilder()._uniforms){
            if (u.group !== uniformInfo.group) {
                continue;
            }
            if (uniformInfo.block && u.block && u.block.name === uniformInfo.block.name && u.block.exp.$typeinfo.isCompatibleType(uniformInfo.block.exp.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.block.exp;
                // u.block.exp = variable;
                found = true;
                break;
            }
            if (uniformInfo.texture && u.texture && uniformInfo.texture.exp.$str === u.texture.exp.$str && uniformInfo.texture.exp.$typeinfo.isCompatibleType(u.texture.exp.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.texture.exp;
                // u.texture.exp = variable;
                found = true;
                break;
            }
            if (uniformInfo.sampler && u.sampler && uniformInfo.sampler.$str === u.sampler.$str && uniformInfo.sampler.$typeinfo.isCompatibleType(u.sampler.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.sampler;
                // u.sampler = variable;
                found = true;
                break;
            }
        }
        if (!found) {
            uniformInfo.mask = getCurrentProgramBuilder().shaderType;
            getCurrentProgramBuilder()._uniforms.push(uniformInfo);
        }
        if (uniformInfo.texture && !uniformInfo.texture.exp.$typeinfo.isStorageTexture() && getCurrentProgramBuilder().getDevice().type === 'webgpu') {
            // webgpu requires explicit sampler bindings
            const isDepth = variable.$typeinfo.isTextureType() && variable.$typeinfo.isDepthTexture();
            const samplerName = genSamplerName(variable.$str, false);
            const samplerExp = getCurrentProgramBuilder().sampler(samplerName).uniform(uniformInfo.group).sampleType(variable.$sampleType);
            samplerExp.$sampleType = variable.$sampleType;
            this.$local(samplerExp);
            if (isDepth) {
                const samplerNameComp = genSamplerName(variable.$str, true);
                const samplerExpComp = getCurrentProgramBuilder().samplerComparison(samplerNameComp).uniform(uniformInfo.group).sampleType(variable.$sampleType);
                this.$local(samplerExpComp);
            }
        }
        return variable;
    }
    /** @internal */ $_declare(variable, init) {
        if (this.$_variables[variable.$str]) {
            throw new PBASTError(variable.$ast, 'cannot re-declare variable');
        }
        if (variable.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || variable.$declareType === DeclareType.DECLARE_TYPE_STORAGE) {
            const name = variable.$ast.name;
            if (!(this instanceof PBGlobalScope)) {
                throw new Error(`uniform or storage variables can only be declared within global scope: ${name}`);
            }
            if (variable.$declareType === DeclareType.DECLARE_TYPE_UNIFORM && !variable.$typeinfo.isTextureType() && !variable.$typeinfo.isSamplerType() && (!variable.$typeinfo.isConstructible() || !variable.$typeinfo.isHostSharable())) {
                throw new PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDevice().type)}' cannot be declared in uniform address space`);
            }
            if (variable.$declareType === DeclareType.DECLARE_TYPE_STORAGE) {
                if (getCurrentProgramBuilder().getDevice().type !== 'webgpu') {
                    throw new PBDeviceNotSupport('storage buffer binding');
                } else if (!variable.$typeinfo.isHostSharable()) {
                    throw new PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDevice().type)}' cannot be declared in storage address space`);
                }
            }
            /*
      if (
        variable.$declareType === AST.DeclareType.DECLARE_TYPE_STORAGE &&
        (variable.$typeinfo.isPrimitiveType() || variable.$typeinfo.isArrayType() || variable.$typeinfo.isAtomicI32() || variable.$typeinfo.isAtomicU32())
      ) {
        originalType = variable.$typeinfo as PBPrimitiveTypeInfo | PBArrayTypeInfo;
        const wrappedStruct = getCurrentProgramBuilder().defineStruct(null, new PBShaderExp('value', originalType));
        variable.$typeinfo = wrappedStruct().$typeinfo;
      }
      */ variable = this.$_findOrSetUniform(variable);
            const ast = this.$_declareInternal(variable);
            ast.group = variable.$group;
            ast.binding = 0;
            ast.blockName = getCurrentProgramBuilder().getBlockName(name);
            const type = variable.$typeinfo;
            if (type.isStructType() && variable.$isBuffer || type.isTextureType() || type.isSamplerType() || type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430')) {
                this.$ast.uniforms.push(ast);
            }
            variable.$tags.forEach((val)=>{
                getCurrentProgramBuilder().tagShaderExp(()=>variable, val);
            });
        } else {
            const ast = this.$_declareInternal(variable, init);
            this.$ast.statements.push(ast);
        }
    }
    /** @internal */ $_registerVar(variable, name) {
        const key = name || variable.$str;
        const options = {
            configurable: true,
            get: function() {
                return variable;
            },
            set: function(val) {
                getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(variable.$ast), val instanceof PBShaderExp ? val.$ast : val));
            }
        };
        Object.defineProperty(this, key, options);
        this.$_variables[key] = variable;
    }
    /** @internal */ $localGet(prop) {
        if (typeof prop === 'string' && (prop[0] === '$' || prop in this)) {
            return this[prop];
        }
        return undefined;
    }
    /** @internal */ $localSet(prop, value) {
        if (prop[0] === '$' || prop in this) {
            this[prop] = value;
            return true;
        }
        return false;
    }
    /** @internal */ $get(prop) {
        const ret = this.$localGet(prop);
        return ret === undefined && this.$_parentScope ? this.$_parentScope.$thisProxy.$get(prop) : ret;
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
            return true;
        } else {
            let scope = this;
            while(scope && !(prop in scope)){
                scope = scope.$_parentScope;
            }
            if (scope) {
                scope[prop] = value;
                return true;
            } else {
                if (this.$l) {
                    this.$l[prop] = value;
                    return true;
                }
            }
        }
        return false;
    }
    /** @internal */ $_getLocalScope() {
        if (!this.$_localScope) {
            this.$_localScope = new PBLocalScope(this);
        }
        return this.$_localScope;
    }
    /** @internal */ $_getGlobalScope() {
        return this.$builder.getGlobalScope();
    }
}
/**
 * The local scope of a shader
 * @public
 */ class PBLocalScope extends PBScope {
    /** @internal */ $_scope;
    constructor(scope){
        super(null, null);
        this.$_scope = scope;
    }
    /** @internal */ $get(prop) {
        return prop[0] === '$' ? this[prop] : this.$_scope.$localGet(prop);
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
            return true;
        }
        if (!(this.$_scope instanceof PBGlobalScope) && value instanceof PBShaderExp && (value.isConstructor() || value.$typeinfo.isTextureType() && value.$ast instanceof ASTPrimitive && !value.$ast.name) && value.$declareType === DeclareType.DECLARE_TYPE_UNIFORM) {
            // We are setting uniform a uniform, should invoke in the global scope
            this.$g[prop] = value;
            return true;
        }
        const val = this.$_scope.$localGet(prop);
        if (val === undefined) {
            const type = getCurrentProgramBuilder().guessExpValueType(value);
            if (type.isCompatibleType(typeVoid)) {
                throw new Error(`Cannot assign void type to '${prop}'`);
            }
            const exp = new PBShaderExp(prop, type);
            if (value instanceof PBShaderExp && !this.$_scope.$parent) {
                exp.$declareType = value.$declareType;
                exp.$isBuffer = value.$isBuffer;
                exp.$group = value.$group;
                exp.$attrib = value.$attrib;
                exp.$sampleType = value.$sampleType;
                exp.$precision = value.$precision;
                exp.tag(...value.$tags);
            }
            this.$_scope.$local(exp, value);
            return true;
        } else {
            return this.$_scope.$localSet(prop, value);
        }
    }
    /** @internal */ $_getLocalScope() {
        return this;
    }
}
/**
 * The builtin scope of a shader
 * @public
 */ class PBBuiltinScope extends PBScope {
    /** @internal */ $_usedBuiltins;
    /** @internal */ $_builtinVars;
    constructor(){
        super(null);
        this.$_usedBuiltins = new Set();
        const isWebGPU = getCurrentProgramBuilder().getDevice().type === 'webgpu';
        if (!isWebGPU) {
            this.$_builtinVars = {};
            const v = builtinVariables[getCurrentProgramBuilder().getDevice().type];
            for(const k in v){
                const info = v[k];
                this.$_builtinVars[k] = new PBShaderExp(info.name, info.type);
            }
        }
        const v = builtinVariables[getCurrentProgramBuilder().getDevice().type];
        const that = this;
        for (const k of Object.keys(v)){
            Object.defineProperty(this, k, {
                get: function() {
                    return that.$getBuiltinVar(k);
                },
                set: function(v) {
                    if (typeof v !== 'number' && !(v instanceof PBShaderExp)) {
                        throw new Error(`Invalid output value assignment`);
                    }
                    const exp = that.$getBuiltinVar(k);
                    getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(exp.$ast), v instanceof PBShaderExp ? v.$ast : v));
                }
            });
        }
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $getBuiltinVar(name) {
        const pb = getCurrentProgramBuilder();
        this.$_usedBuiltins.add(name);
        const isWebGPU = pb.getDevice().type === 'webgpu';
        if (isWebGPU) {
            const v = builtinVariables[pb.getDevice().type];
            const info = v[name];
            const inout = info.inOrOut;
            if (inout === 'in') {
                return pb.getCurrentFunctionScope()[getBuiltinParamName(pb.shaderType)][info.name];
            }
            const structName = inout === 'in' ? getBuiltinInputStructInstanceName(pb.shaderType) : getBuiltinOutputStructInstanceName(pb.shaderType);
            const scope = pb.getCurrentScope();
            if (!scope[structName] || !scope[structName][info.name]) {
                throw new Error(`invalid use of builtin variable ${name}`);
            }
            return scope[structName][info.name];
        } else {
            if (pb.getDevice().type === 'webgl2' && (name === 'vertexIndex' || name === 'instanceIndex')) {
                return pb.uint(this.$_builtinVars[name]);
            } else {
                return this.$_builtinVars[name];
            }
        }
    }
}
/**
 * The input scope of a shader
 * @public
 */ class PBInputScope extends PBScope {
    /** @internal */ $_names;
    $_aliases;
    /** @internal */ constructor(){
        super(null);
        this.$_names = {};
        this.$_aliases = {};
    }
    /** @internal */ $getVertexAttrib(attrib) {
        const name = this.$_names[attrib];
        return name ? this[name] : null;
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $get(prop) {
        if (prop[0] === '$') {
            return this[prop];
        }
        if (this.$_aliases[prop]) {
            prop = this.$_aliases[prop];
        }
        const pb = this.$builder;
        if (pb.getDevice().type === 'webgpu') {
            const param = pb.getCurrentFunctionScope()[getBuiltinParamName(pb.shaderType)];
            const prefix = pb.shaderKind === 'vertex' ? input_prefix : output_prefix_vs;
            const name = `${prefix}${prop}`;
            if (param.$typeinfo.structMembers.findIndex((val)=>val.name === name) < 0) {
                return undefined;
            }
            return param[`${prefix}${prop}`];
        }
        return super.$get(prop);
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
        } else {
            if (!(value instanceof PBShaderExp)) {
                throw new Error(`invalid vertex input value`);
            }
            const st = getCurrentProgramBuilder().shaderType;
            if (st !== ShaderType.Vertex) {
                throw new Error(`shader input variables can only be declared in vertex shader: "${prop}"`);
            }
            const attrib = getVertexAttribByName(value.$attrib);
            if (attrib === undefined) {
                throw new Error(`can not declare shader input variable: invalid vertex attribute: "${prop}"`);
            }
            if (getCurrentProgramBuilder()._vertexAttributes.indexOf(attrib) >= 0) {
                const lastName = this.$_names[value.$attrib];
                if (prop !== lastName) {
                    const p = this[lastName];
                    if (p.$typeinfo.typeId !== value.$typeinfo.typeId) {
                        throw new Error(`can not declare shader input variable: attribute already declared with different type: "${prop}"`);
                    }
                    this.$_aliases[prop] = lastName;
                }
                return true;
            }
            if (!(value instanceof PBShaderExp) || !(value.$ast instanceof ASTShaderExpConstructor)) {
                throw new Error(`invalid shader input variable declaration: "${prop}"`);
            }
            const type = value.$ast.getType();
            if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {
                throw new Error(`type cannot be used as pipeline input/output: ${prop}`);
            }
            this.$_names[value.$attrib] = prop;
            const location = getCurrentProgramBuilder()._inputs.length;
            const exp = new PBShaderExp(`${input_prefix}${prop}`, type).tag(...value.$tags);
            getCurrentProgramBuilder().in(location, prop, exp);
            getCurrentProgramBuilder()._vertexAttributes.push(attrib);
            //getCurrentProgramBuilder().getReflection().setAttrib(value.$attrib, exp);
            // modify input struct for webgpu
            if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                if (getCurrentProgramBuilder().findStructType(getBuiltinInputStructName(st), st)) {
                    getCurrentProgramBuilder().defineBuiltinStruct(st, 'in');
                }
            }
        }
        return true;
    }
}
/**
 * The output scope of a shader
 * @public
 */ class PBOutputScope extends PBScope {
    constructor(){
        super(null);
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$' /* || prop in this*/ ) {
            this[prop] = value;
        } else {
            const pb = getCurrentProgramBuilder();
            if (!(prop in this)) {
                if (pb.getCurrentScope() === pb.getGlobalScope() && (!(value instanceof PBShaderExp) || !(value.$ast instanceof ASTShaderExpConstructor))) {
                    throw new Error(`invalid shader output variable declaration: ${prop}`);
                }
                const type = value.$ast.getType();
                if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {
                    throw new Error(`type cannot be used as pipeline input/output: ${prop}`);
                }
                const location = pb._outputs.length;
                pb.out(location, prop, new PBShaderExp(`${pb.shaderKind === 'vertex' ? output_prefix_vs : output_prefix_fs}${prop}`, type).tag(...value.$tags));
                // modify output struct for webgpu
                if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                    const st = getCurrentProgramBuilder().shaderType;
                    if (getCurrentProgramBuilder().findStructType(getBuiltinInputStructName(st), st)) {
                        getCurrentProgramBuilder().defineBuiltinStruct(st, 'out');
                    }
                }
            }
            if (getCurrentProgramBuilder().getCurrentScope() !== getCurrentProgramBuilder().getGlobalScope()) {
                const ast = value.$ast;
                if (!(ast instanceof ASTShaderExpConstructor) || ast.args.length > 0) {
                    this[prop] = value;
                }
            }
        }
        return true;
    }
}
/**
 * The global scope of a shader
 * @public
 */ class PBGlobalScope extends PBScope {
    /** @internal */ $_inputStructInfo;
    /** @internal */ constructor(){
        super(new ASTGlobalScope());
        this.$_inputStructInfo = null;
    }
    /** @internal */ get $inputStructInfo() {
        if (!this.$_inputStructInfo) {
            this.$_inputStructInfo = this.$builder.defineBuiltinStruct(this.$builder.shaderType, 'in');
        }
        return this.$_inputStructInfo;
    }
    /** @internal */ get $inputStruct() {
        return this.$inputStructInfo[0];
    }
    /** @internal */ $mainFunc(body) {
        const pb = getCurrentProgramBuilder();
        if (pb.getDevice().type === 'webgpu') {
            const inputStruct = this.$inputStructInfo;
            //this.$local(inputStruct[1]);
            const isCompute = pb.shaderType === ShaderType.Compute;
            const outputStruct = isCompute ? null : pb.defineBuiltinStruct(pb.shaderType, 'out');
            if (outputStruct) {
                this.$local(outputStruct[1]);
            }
            // this.$internalCreateFunction('chMainStub', [], false, body);
            this.$internalCreateFunction('main', inputStruct ? [
                inputStruct[3]
            ] : [], true, function() {
                /*
          if (inputStruct) {
            this[inputStruct[1].$str] = this[inputStruct[3].$str];
          }
          */ if (pb.shaderType === ShaderType.Fragment && pb.emulateDepthClamp) {
                    this.$builtins.fragDepth = pb.clamp(this.$inputs.clamppedDepth, 0, 1);
                }
                body?.call(this);
                //this.chMainStub();
                if (pb.shaderType === ShaderType.Vertex) {
                    if (pb.depthRangeCorrection) {
                        this.$builtins.position.z = pb.mul(pb.add(this.$builtins.position.z, this.$builtins.position.w), 0.5);
                    }
                    if (pb.emulateDepthClamp) {
                        //z = gl_Position.z / gl_Position.w;
                        //z = (gl_DepthRange.diff * z + gl_DepthRange.near + gl_DepthRange.far) * 0.5;
                        this.$outputs.clamppedDepth = pb.div(this.$builtins.position.z, this.$builtins.position.w);
                        this.$builtins.position.z = 0;
                    }
                }
                if (!isCompute) {
                    this.$return(outputStruct[1]);
                }
            });
        } else {
            this.$internalCreateFunction('main', [], true, function() {
                if (pb.shaderType === ShaderType.Fragment && pb.emulateDepthClamp) {
                    this.$builtins.fragDepth = pb.clamp(this.$inputs.clamppedDepth, 0, 1);
                }
                body?.call(this);
                if (pb.shaderType === ShaderType.Vertex && pb.emulateDepthClamp) {
                    this.$outputs.clamppedDepth = pb.div(pb.add(pb.div(this.$builtins.position.z, this.$builtins.position.w), 1), 2);
                    this.$builtins.position.z = 0;
                }
            });
        }
    }
    /** @internal */ $createFunctionIfNotExists(name, params, body) {
        {
            this.$internalCreateFunction(name, params, false, body);
        }
    }
    /** @internal */ $getFunctions(name) {
        return this.$ast.findFunctions(name);
    }
    /** @internal */ $getCurrentFunctionScope() {
        let scope = getCurrentProgramBuilder().getCurrentScope();
        while(scope && !(scope instanceof PBFunctionScope)){
            scope = scope.$parent;
        }
        return scope;
    }
    /** @internal */ $internalCreateFunction(name, params, isMain, body) {
        const pb = getCurrentProgramBuilder();
        if (pb.getDevice().type === 'webgpu' && !isMain) {
            params.push(this.$inputStruct(getBuiltinParamName(pb.shaderType)));
        }
        params.forEach((param)=>{
            if (!(param.$ast instanceof ASTPrimitive)) {
                throw new Error(`${name}(): invalid function definition`);
            }
            let ast = param.$ast;
            if (param.$inout) {
                if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                    param.$typeinfo = new PBPointerTypeInfo(param.$typeinfo, PBAddressSpace.UNKNOWN);
                }
                ast = new ASTReferenceOf(param.$ast);
            }
            param.$ast = new ASTFunctionParameter(ast);
        });
        const overloads = this.$getFunctions(name);
        const currentFunctionScope = this.$getCurrentFunctionScope();
        const astFunc = new ASTFunction(name, params.map((val)=>val.$ast), isMain, null, false);
        if (currentFunctionScope) {
            const curIndex = this.$ast.statements.indexOf(currentFunctionScope.$ast);
            if (curIndex < 0) {
                throw new Error('Internal error');
            }
            this.$ast.statements.splice(curIndex, 0, astFunc);
        } else {
            this.$ast.statements.push(astFunc);
        }
        new PBFunctionScope(this, params, astFunc, body);
        if (!astFunc.returnType) {
            astFunc.returnType = typeVoid;
        }
        astFunc.funcType = new PBFunctionTypeInfo(astFunc.name, astFunc.returnType, params.map((param)=>{
            const ast = param.$ast;
            return ast.paramAST instanceof ASTReferenceOf ? {
                type: ast.paramAST.value.getType(),
                byRef: ast.paramAST instanceof ASTReferenceOf
            } : {
                type: ast.paramAST.getType(),
                byRef: false
            };
        }));
        for (const overload of overloads){
            if (overload.funcType.argHash === astFunc.funcType.argHash) {
                if (overload.returnType.isCompatibleType(astFunc.returnType)) {
                    // Function signature already exists
                    // console.warn(`Function '${name}' already exists`);
                    this.$ast.statements.splice(this.$ast.statements.indexOf(astFunc), 1);
                    return;
                } else {
                    throw new Error(`Invalid function overloading: ${name}`);
                }
            }
        }
        if (overloads.length === 0) {
            Object.defineProperty(this, name, {
                get: function() {
                    const func = this.$getFunctions(name);
                    if (func.length === 0) {
                        throw new Error(`function ${name} not found`);
                    }
                    return (...args)=>{
                        let inputArg = null;
                        if (pb.getDevice().type === 'webgpu') {
                            let funcScope = pb.getCurrentScope();
                            while(funcScope && !(funcScope instanceof PBFunctionScope)){
                                funcScope = funcScope.$parent;
                            }
                            const funcArgs = funcScope.$ast.args;
                            const arg = funcArgs[funcArgs.length - 1].paramAST;
                            const name = arg.name;
                            inputArg = funcScope[name];
                        }
                        const argsNonArray = (inputArg ? [
                            ...args,
                            inputArg
                        ] : args).map((val)=>pb.normalizeExpValue(val));
                        const funcType = pb._getFunctionOverload(name, argsNonArray);
                        if (!funcType) {
                            throw new Error(`ERROR: no matching overloads for function ${name}`);
                        }
                        return getCurrentProgramBuilder().$callFunction(name, funcType[1], funcType[0]);
                    };
                }
            });
        }
    }
}
/**
 * Scope that is inside a function
 * @public
 */ class PBInsideFunctionScope extends PBScope {
    /** @internal */ constructor(parent){
        super(new ASTScope(), parent);
    }
    /**
   * Creates a 'return' statement
   * @param retval - The return value
   */ $return(retval) {
        const functionScope = this.findOwnerFunction();
        const astFunc = functionScope.$ast;
        let returnType = null;
        const retValNonArray = getCurrentProgramBuilder().normalizeExpValue(retval);
        if (retValNonArray !== undefined && retValNonArray !== null) {
            if (typeof retValNonArray === 'number') {
                if (astFunc.returnType) {
                    if (astFunc.returnType.isPrimitiveType() && astFunc.returnType.isScalarType() && !astFunc.returnType.isCompatibleType(typeBool)) {
                        returnType = astFunc.returnType;
                    }
                }
                if (!returnType) {
                    if (Number.isInteger(retValNonArray)) {
                        if (retValNonArray < 0) {
                            if (retValNonArray < 0x80000000 >> 0) {
                                throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);
                            }
                            returnType = typeI32$1;
                        } else {
                            if (retValNonArray > 0xffffffff) {
                                throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);
                            }
                            returnType = retValNonArray <= 0x7fffffff ? typeI32$1 : typeU32$3;
                        }
                    } else {
                        returnType = typeF32$1;
                    }
                }
            } else if (typeof retValNonArray === 'boolean') {
                returnType = typeBool;
            } else {
                returnType = retValNonArray.$ast.getType();
            }
        } else {
            returnType = typeVoid;
        }
        if (returnType.isPointerType()) {
            throw new Error('function can not return pointer type');
        }
        if (!astFunc.returnType) {
            astFunc.returnType = returnType;
        } else if (!astFunc.returnType.isCompatibleType(returnType)) {
            throw new Error(`function ${astFunc.name}: return type must be ${astFunc.returnType?.toTypeName(getCurrentProgramBuilder().getDevice().type) || 'void'}`);
        }
        let returnValue = null;
        if (retValNonArray !== undefined && retValNonArray !== null) {
            if (retValNonArray instanceof PBShaderExp) {
                returnValue = retValNonArray.$ast;
            } else {
                if (!returnType.isPrimitiveType() || !returnType.isScalarType()) {
                    throw new PBTypeCastError(retValNonArray, typeof retValNonArray, returnType);
                }
                returnValue = new ASTScalar(retValNonArray, returnType);
            }
        }
        this.$ast.statements.push(new ASTReturn(returnValue));
    }
    /**
   * Creates a new scope
   * @param body - Generator function for the scope
   * @returns The created scope
   */ $scope(body) {
        const astScope = new ASTNakedScope();
        this.$ast.statements.push(astScope);
        return new PBNakedScope(this, astScope, body);
    }
    /**
   * Creates an 'if' statement
   * @param condition - Condition expression for the if statement
   * @param body - Generator function for the scope inside the if statement
   * @returns The scope inside the if statement
   */ $if(condition, body) {
        const astIf = new ASTIf('if', condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool));
        this.$ast.statements.push(astIf);
        return new PBIfScope(this, astIf, body);
    }
    /**
   * Creates a select statement: condition ? first : second
   * @param condition - Condition expression
   * @param first - The first value
   * @param second - The second value
   * @returns The first value if condition evaluates to true, otherwise returns the second value
   */ $choice(condition, first, second) {
        const ast = new ASTSelect(condition instanceof PBShaderExp ? condition.$ast : condition, first instanceof PBShaderExp ? first.$ast : first, second instanceof PBShaderExp ? second.$ast : second);
        const exp = new PBShaderExp('', ast.getType());
        exp.$ast = ast;
        return exp;
    }
    /** Creates a 'break' statement */ $break() {
        this.$ast.statements.push(new ASTBreak());
    }
    /** Creates a 'continue' statement */ $continue() {
        this.$ast.statements.push(new ASTContinue());
    }
    /**
   * Creates a 'for' statement
   * @param counter - The repeat counter variable declaration
   * @param init - initial value of the repeat counter variable
   * @param end - end value of the counter exclusive
   * @param body - Generator function for the scope that inside the for statement
   */ $for(counter, init, end, body) {
        const initializerType = counter.$ast.getType();
        if (!initializerType.isPrimitiveType() || !initializerType.isScalarType()) {
            throw new PBASTError(counter.$ast, 'invalid for range initializer type');
        }
        const initval = init instanceof PBShaderExp ? init.$ast : new ASTScalar(init, initializerType);
        const astFor = new ASTRange(counter.$ast, initval, end instanceof PBShaderExp ? end.$ast : new ASTScalar(end, initializerType), true);
        this.$ast.statements.push(astFor);
        new PBForScope(this, counter, end, astFor, body);
    }
    /**
   * Creates a 'do..while' statement
   * @param body - Generator function for the scope that inside the do..while statment
   * @returns The scope that inside the do..while statement
   */ $do(body) {
        if (this.$builder.getDevice().type === 'webgl') {
            throw new Error(`No do-while() loop support for WebGL1.0 device`);
        }
        const astDoWhile = new ASTDoWhile(null);
        this.$ast.statements.push(astDoWhile);
        return new PBDoWhileScope(this, astDoWhile, body);
    }
    /**
   * Creates a 'while' statement
   * @param condition - Condition expression for the while statement
   * @param body - Generator function for the scope that inside the while statement
   */ $while(condition, body) {
        const astWhile = new ASTWhile(condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool));
        this.$ast.statements.push(astWhile);
        new PBWhileScope(this, astWhile, body);
    }
    /** @internal */ findOwnerFunction() {
        for(let scope = this; scope; scope = scope.$parent){
            if (scope instanceof PBFunctionScope) {
                return scope;
            }
        }
        return null;
    }
}
/**
 * Scope that insides a function
 * @public
 */ class PBFunctionScope extends PBInsideFunctionScope {
    /** @internal */ $typeinfo;
    /** @internal */ constructor(parent, params, ast, body){
        super(parent);
        this.$ast = ast;
        for (const param of params){
            if (this.$_variables[param.$str]) {
                throw new Error('Duplicate function parameter name is not allowed');
            }
            this.$_registerVar(param);
        }
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    $isMain() {
        return this.$ast.isMainFunc;
    }
}
/**
 * Scope that insides a while statement
 * @public
 */ class PBWhileScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * Scope that insides a do..while statement
 * @public
 */ class PBDoWhileScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    $while(condition) {
        this.$ast.condition = condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool);
    }
}
/**
 * Scope that insides a for statement
 * @public
 */ class PBForScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, counter, count, ast, body){
        super(parent);
        this.$ast = ast;
        this.$_registerVar(counter);
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * A naked scope
 * @public
 */ class PBNakedScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * Scope that insides an if statement
 * @public
 */ class PBIfScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    /**
   * Creates an 'else if' branch
   * @param condition - Condition expression for the else if branch
   * @param body - Generator function for the scope that insides the else if statement
   * @returns The scope that insides the else if statement
   */ $elseif(condition, body) {
        const astElseIf = new ASTIf('else if', condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32$1 : typeBool));
        this.$ast.nextElse = astElseIf;
        return new PBIfScope(this.$_parentScope, astElseIf, body);
    }
    /**
   * Creates an 'else' branch
   * @param body - Generator function for the scope that insides the else statement
   */ $else(body) {
        const astElse = new ASTIf('else', null);
        this.$ast.nextElse = astElse;
        new PBIfScope(this.$_parentScope, astElse, body);
    }
}
setBuiltinFuncs(ProgramBuilder);
setConstructors(ProgramBuilder);

/** @internal */ class FontCanvas {
    static _canvas = null;
    static _context = null;
    static get canvas() {
        this._realize();
        return this._canvas;
    }
    static get context() {
        this._realize();
        return this._context;
    }
    static get font() {
        return this.context.font;
    }
    static set font(font) {
        this.context.font = font;
    }
    static _realize() {
        if (!this._canvas) {
            this._canvas = document.createElement('canvas');
            this._canvas.width = 512;
            this._canvas.height = 512;
            this._canvas.style.left = '-10000px';
            this._canvas.style.position = 'absolute';
            //document.body.appendChild(this._canvas);
            this._context = this._canvas.getContext('2d', {
                willReadFrequently: true
            });
            this._context.textBaseline = 'top';
            this._context.textAlign = 'left';
            this._context.fillStyle = 'transparent';
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
            this._context.fillStyle = '#ffffff';
            this._context.imageSmoothingEnabled = true;
        }
    }
}
/**
 * The font class
 * @public
 */ class Font {
    /** @internal */ static fontCache = {};
    /** @internal */ _name;
    /** @internal */ _nameScaled;
    /** @internal */ _scale;
    /** @internal */ _size;
    /** @internal */ _family;
    /** @internal */ _top;
    /** @internal */ _bottom;
    /** @internal */ _topScaled;
    /** @internal */ _bottomScaled;
    /** @internal */ _div;
    /**
   * Creates a instance of font class from font name and the scale value
   * @param name - The font name
   * @param scale - The scale value
   */ constructor(name, scale){
        this._top = 0;
        this._bottom = 0;
        this._size = 0;
        this._topScaled = 0;
        this._bottomScaled = 0;
        this._family = '';
        this._scale = scale;
        this._name = name;
        this._nameScaled = null;
        this._div = document.createElement('div');
        if (this._name) {
            this._normalizeFont();
        }
    }
    /**
   * Fetch a font from cache
   * @param name - The font name
   * @param scale - The scale value
   * @returns The font object
   */ static fetchFont(name, scale) {
        let fontlist = this.fontCache[name];
        if (!fontlist) {
            fontlist = {};
            this.fontCache[name] = fontlist;
        }
        let font = fontlist[scale];
        if (!font) {
            font = new Font(name, scale);
            fontlist[scale] = font;
        }
        return font;
    }
    /** Gets the font name */ get fontName() {
        return this._name;
    }
    set fontName(name) {
        this._name = name;
        this._normalizeFont();
    }
    /** Gets the scaled font name */ get fontNameScaled() {
        return this._nameScaled;
    }
    /** Gets the font size */ get size() {
        return this._size;
    }
    /** Gets the font family */ get family() {
        return this._family;
    }
    /** Gets top position of the font */ get top() {
        return this._top;
    }
    /** Gets the bottom position of the font */ get bottom() {
        return this._bottom;
    }
    /** Gets the scaled top position of the font */ get topScaled() {
        return this._topScaled;
    }
    /** Gets the scaled bottom position of the font */ get bottomScaled() {
        return this._bottomScaled;
    }
    /** Gets the maximum height of the font */ get maxHeight() {
        return this._bottom - this._top + 1;
    }
    /** Gets the scaled maximum height of the font */ get maxHeightScaled() {
        return this._bottomScaled - this._topScaled + 1;
    }
    /** Tests if two fonts are the same */ equalTo(other) {
        return this._size === other._size && this._family === other._family;
    }
    /** @internal */ _measureFontHeight(fontName) {
        const oldFont = FontCanvas.context.font;
        const oldTextBaseline = FontCanvas.context.textBaseline;
        const oldFillStyle = FontCanvas.context.fillStyle;
        FontCanvas.context.font = fontName;
        this._div.style.font = FontCanvas.context.font;
        const fontSize = this._div.style.fontSize;
        const size = parseInt(fontSize.substring(0, fontSize.length - 2));
        const family = this._div.style.fontFamily;
        const testString = 'bdfghijklpq|_~';
        const metric = FontCanvas.context.measureText(testString);
        let top, bottom;
        top = 0;
        bottom = size - 1;
        const extra = 10;
        const halfExtra = extra >> 1;
        const maxWidth = Math.ceil(metric.width) + extra;
        const maxHeight = size + extra;
        FontCanvas.context.clearRect(0, 0, maxWidth, maxHeight);
        FontCanvas.context.textBaseline = 'top';
        FontCanvas.context.fillStyle = '#ffffff';
        FontCanvas.context.fillText(testString, halfExtra, halfExtra);
        const bitmap = FontCanvas.context.getImageData(0, 0, maxWidth, maxHeight);
        const pixels = bitmap.data;
        for(let i = 0; i < maxWidth * maxHeight; i++){
            if (pixels[i * 4 + 3] > 0) {
                top = Math.floor(i / maxWidth);
                break;
            }
        }
        for(let i = maxWidth * maxHeight - 1; i >= 0; i--){
            if (pixels[i * 4 + 3] > 0) {
                bottom = Math.floor(i / maxWidth);
                break;
            }
        }
        top -= halfExtra;
        bottom -= halfExtra;
        FontCanvas.context.font = oldFont;
        FontCanvas.context.textBaseline = oldTextBaseline;
        FontCanvas.context.fillStyle = oldFillStyle;
        return {
            size,
            family,
            top,
            bottom
        };
    }
    /** @internal */ _normalizeFont() {
        const info = this._measureFontHeight(this._name);
        this._nameScaled = `${Math.round(info.size * this._scale)}px ${info.family}`;
        const infoScaled = this._measureFontHeight(this._nameScaled);
        this._size = info.size;
        this._family = info.family;
        this._top = info.top;
        this._bottom = info.bottom;
        this._topScaled = infoScaled.top;
        this._bottomScaled = infoScaled.bottom;
    }
}

/**
 * Texture atlas manager
 * @public
 */ class TextureAtlasManager {
    /** @internal */ static ATLAS_WIDTH = 1024;
    /** @internal */ static ATLAS_HEIGHT = 1024;
    /** @internal */ _packer;
    /** @internal */ _device;
    /** @internal */ _binWidth;
    /** @internal */ _binHeight;
    /** @internal */ _rectBorderWidth;
    /** @internal */ _linearSpace;
    /** @internal */ _atlasList;
    /** @internal */ _atlasInfoMap;
    /** @internal */ _atlasRestoreHandler;
    /**
   * Creates a new texture atlas manager instance
   * @param device - The render device
   * @param binWidth - Width of an atlas bin
   * @param binHeight - Height of an atlas bin
   * @param rectBorderWidth - Border width of an atlas
   * @param linearSpace - true if the texture space is linear
   */ constructor(device, binWidth, binHeight, rectBorderWidth, linearSpace){
        this._device = device;
        this._binWidth = binWidth;
        this._binHeight = binHeight;
        this._rectBorderWidth = rectBorderWidth;
        this._linearSpace = !!linearSpace;
        this._packer = new RectsPacker(this._binWidth, this._binHeight);
        this._atlasList = [];
        this._atlasInfoMap = {};
        this._atlasRestoreHandler = null;
    }
    /**
   * The texture restore handler callback function
   * This callback function will be called whenever the device has been restored
   */ get atlasTextureRestoreHandler() {
        return this._atlasRestoreHandler;
    }
    set atlasTextureRestoreHandler(f) {
        this._atlasRestoreHandler = f;
    }
    /**
   * Gets the atlas texture of a given index
   * @param index - Index of the atlas bin
   * @returns Atlas texture for given index
   */ getAtlasTexture(index) {
        return this._atlasList[index];
    }
    /**
   * Gets the information about specified atlas
   * @param key - Key of the atlas
   * @returns Information of the atlas
   */ getAtlasInfo(key) {
        return this._atlasInfoMap[key] || null;
    }
    /**
   * Check if no atlas has been created
   * @returns true if no atlas has been created
   */ isEmpty() {
        return this._atlasList.length === 0;
    }
    /**
   * Removes all created atlases
   */ clear() {
        this._packer.clear();
        for (const tex of this._atlasList){
            tex.dispose();
        }
        this._atlasList = [];
        this._atlasInfoMap = {};
    }
    /**
   * Inserts a rectangle of a canvas to the atlas texture
   * @param key - Key of the atlas
   * @param ctx - The canvas context
   * @param x - x offset of the rectangle
   * @param y - y offset of the rectangle
   * @param w - width of the rectangle
   * @param h - height of the rectangle
   * @returns The atals info or null if insert failed
   */ pushCanvas(key, ctx, x, y, w, h) {
        const rc = this._packer.insert(w + 2 * this._rectBorderWidth, h + 2 * this._rectBorderWidth);
        if (rc) {
            const atlasX = rc.x + this._rectBorderWidth;
            const atlasY = rc.y + this._rectBorderWidth;
            this._updateAtlasTextureCanvas(rc.binIndex, ctx, atlasX, atlasY, w, h, x, y);
            const info = {
                atlasIndex: rc.binIndex,
                uMin: atlasX / this._binWidth,
                vMin: atlasY / this._binHeight,
                uMax: (atlasX + w) / this._binWidth,
                vMax: (atlasY + h) / this._binHeight,
                width: w,
                height: h
            };
            this._atlasInfoMap[key] = info;
            return info;
        }
        return null;
    }
    /**
   * Inserts a bitmap to the atlas texture
   * @param key - Key of the atlas
   * @param bitmap - The bitmap object
   * @returns The atals info or null if insert failed
   */ pushBitmap(key, bitmap) {
        const rc = this._packer.insert(bitmap.width + 2 * this._rectBorderWidth, bitmap.height + 2 * this._rectBorderWidth);
        if (rc) {
            const atlasX = rc.x + this._rectBorderWidth;
            const atlasY = rc.y + this._rectBorderWidth;
            this._updateAtlasTexture(rc.binIndex, bitmap, atlasX, atlasY);
            const info = {
                atlasIndex: rc.binIndex,
                uMin: atlasX / this._binWidth,
                vMin: atlasY / this._binHeight,
                uMax: (atlasX + bitmap.width) / this._binWidth,
                vMax: (atlasY + bitmap.height) / this._binHeight,
                width: bitmap.width,
                height: bitmap.height
            };
            this._atlasInfoMap[key] = info;
            return info;
        }
        return null;
    }
    /** @internal */ _createAtlasTexture() {
        const tex = this._device.createTexture2D('rgba8unorm', this._binWidth, this._binHeight, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        tex.update(new Uint8Array(tex.width * tex.height * 4), 0, 0, tex.width, tex.height);
        tex.restoreHandler = async ()=>{
            tex.update(new Uint8Array(tex.width * tex.height * 4), 0, 0, tex.width, tex.height);
            this._atlasRestoreHandler && await this._atlasRestoreHandler(tex);
        };
        return tex;
    }
    /** @internal */ _updateAtlasTextureCanvas(atlasIndex, ctx, x, y, w, h, xOffset, yOffset) {
        let textureAtlas = null;
        if (atlasIndex === this._atlasList.length) {
            textureAtlas = this._createAtlasTexture();
            this._atlasList.push(textureAtlas);
        } else {
            textureAtlas = this._atlasList[atlasIndex];
        }
        textureAtlas.updateFromElement(ctx.canvas, x, y, xOffset, yOffset, w, h);
    }
    /** @internal */ _updateAtlasTexture(atlasIndex, bitmap, x, y) {
        let textureAtlas = null;
        if (atlasIndex === this._atlasList.length) {
            textureAtlas = this._createAtlasTexture();
            this._atlasList.push(textureAtlas);
        } else {
            textureAtlas = this._atlasList[atlasIndex];
        }
        if (bitmap instanceof ImageBitmap) {
            textureAtlas.updateFromElement(bitmap, x, y, 0, 0, bitmap.width, bitmap.height);
        } else {
            const originValues = new Uint8Array(bitmap.data.buffer);
            textureAtlas.update(originValues, x, y, bitmap.width, bitmap.height);
        }
    }
}

/**
 * Manager of texture glyphs
 * @public
 */ class GlyphManager extends TextureAtlasManager {
    /**
   * Creates a new glyph manager instance
   * @param device - The render device
   * @param binWidth - Width of an atlas bin
   * @param binHeight - Height of an atlas bin
   * @param border - Border width of an atlas
   */ constructor(device, binWidth, binHeight, border){
        super(device, binWidth, binHeight, border, true);
        this.atlasTextureRestoreHandler = async ()=>{
            if (!this.isEmpty()) {
                this.clear();
            }
        };
    }
    /**
   * Gets the atlas information for given character
   * @param char - The character
   * @param font - Font of the character
   * @returns Atlas information for the glyph
   */ getGlyphInfo(char, font) {
        if (!char || !font) {
            return null;
        }
        let glyphInfo = this.getAtlasInfo(this._hash(char, font));
        if (!glyphInfo) {
            glyphInfo = this._cacheGlyph(char, font);
            glyphInfo.width = Math.round(glyphInfo.width * (font.maxHeight / font.maxHeightScaled));
            glyphInfo.height = font.maxHeight;
        }
        return glyphInfo;
    }
    /**
   * Measuring the width of a string
   * @param str - The string to be measured
   * @param charMargin - margin size between characters
   * @param font - Font of the string
   * @returns Width of the string
   */ measureStringWidth(str, charMargin, font) {
        let w = 0;
        for (const ch of str){
            w += charMargin + this.getCharWidth(ch, font);
        }
        return w;
    }
    /**
   * Clips a string so that it's width is not larger than the given value
   * @param str - The string to be clipped
   * @param width - The desired maximum width
   * @param charMargin - Margin size between characters
   * @param start - Start index of the string to be clipped
   * @param font - Font of the string
   * @returns
   */ clipStringToWidth(str, width, charMargin, start, font) {
        let sum = 0;
        let i = start;
        for(; i < str.length; i++){
            sum += charMargin + this.getCharWidth(str[i], font);
            if (sum > width) {
                break;
            }
        }
        return i - start;
    }
    /** @internal */ _hash(char, font) {
        return `${font.family}@${font.size}&${char}`;
    }
    /** @internal */ _cacheGlyph(char, font) {
        const bitmap = this._getGlyphBitmap(char, font);
        return this.pushBitmap(this._hash(char, font), bitmap);
    }
    /**
   * Measuring width of a character
   * @param char - The character to be measured
   * @param font - Font of the character
   * @returns Width of the character
   */ getCharWidth(char, font) {
        if (!font) {
            return 0;
        }
        FontCanvas.font = font.fontNameScaled;
        const metric = FontCanvas.context.measureText(char);
        let w = metric.width;
        if (w === 0) {
            return 0;
        }
        if (typeof metric.actualBoundingBoxRight === 'number') {
            w = Math.floor(Math.max(w, metric.actualBoundingBoxRight) + 0.8);
        }
        w = Math.round(w * (font.maxHeight / font.maxHeightScaled));
        return w;
    }
    /** @internal */ _getGlyphBitmap(char, font) {
        if (!font) {
            return null;
        }
        FontCanvas.font = font.fontNameScaled;
        const metric = FontCanvas.context.measureText(char);
        let w = metric.width;
        if (w === 0) {
            return null;
        }
        if (typeof metric.actualBoundingBoxRight === 'number') {
            w = Math.floor(Math.max(w, metric.actualBoundingBoxRight) + 0.8);
        }
        const h = font.maxHeightScaled;
        FontCanvas.context.fillStyle = '#fff';
        FontCanvas.context.clearRect(0, 0, w + 2, h);
        FontCanvas.context.fillText(char, 0, -font.topScaled);
        return FontCanvas.context.getImageData(0, 0, w, h);
    }
}

const MAX_GLYPH_COUNT = 1024;
/**
 * Helper class to draw some text onto the screen
 * @public
 */ class DrawText {
    /** @internal */ static GLYPH_COUNT = MAX_GLYPH_COUNT;
    /** @internal */ static glyphManager = null;
    /** @internal */ static prepared = false;
    /** @internal */ static textVertexBuffer = null;
    /** @internal */ static textVertexLayout = null;
    /** @internal */ static textProgram = null;
    /** @internal */ static textBindGroup = null;
    /** @internal */ static textRenderStates = null;
    /** @internal */ static textOffset = 0;
    /** @internal */ static textMatrix = new Matrix4x4();
    /** @internal */ static font = null;
    /** @internal */ static vertexCache = null;
    /** @internal */ static colorValue = new Vector4();
    /** @internal */ static calculateTextMatrix(device, matrix) {
        const viewport = device.getViewport();
        const projectionMatrix = Matrix4x4.ortho(0, viewport.width, 0, viewport.height, 1, 100);
        const flipMatrix = Matrix4x4.translation(new Vector3(0, viewport.height, 0)).scaleRight(new Vector3(1, -1, 1));
        Matrix4x4.multiply(projectionMatrix, flipMatrix, matrix);
    }
    /**
   * Set the font that will be used to draw strings
   * @param device - The render device
   * @param name - The font name
   */ static setFont(device, name) {
        this.font = Font.fetchFont(name, device.getScale()) || Font.fetchFont('12px arial', device.getScale());
    }
    /**
   * Draw text onto the screen
   * @param device - The render device
   * @param text - The text to be drawn
   * @param color - The text color
   * @param x - X coordinate of the text
   * @param y - Y coordinate of the text
   */ static drawText(device, text, color, x, y) {
        if (text.length > 0) {
            device.pushDeviceStates();
            this.prepareDrawText(device);
            this.calculateTextMatrix(device, this.textMatrix);
            const colorValue = parseColor(color);
            this.colorValue.x = colorValue.r;
            this.colorValue.y = colorValue.g;
            this.colorValue.z = colorValue.b;
            this.colorValue.w = colorValue.a;
            this.textBindGroup.setValue('flip', device.type === 'webgpu' && device.getFramebuffer() ? 1 : 0);
            this.textBindGroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
            this.textBindGroup.setValue('textMatrix', this.textMatrix);
            this.textBindGroup.setValue('textColor', this.colorValue);
            device.setProgram(this.textProgram);
            device.setVertexLayout(this.textVertexLayout);
            device.setRenderStates(this.textRenderStates);
            device.setBindGroup(0, this.textBindGroup);
            let drawn = 0;
            const total = text.length;
            while(drawn < total){
                const count = Math.min(total - drawn, this.GLYPH_COUNT - this.textOffset);
                if (count > 0) {
                    x = this.drawTextNoOverflow(device, text, drawn, count, x, y);
                    drawn += count;
                    this.textOffset += count;
                }
                if (this.GLYPH_COUNT === this.textOffset) {
                    this.textOffset = 0;
                    device.flush();
                }
            }
            device.popDeviceStates();
        }
    }
    /** @internal */ static drawTextNoOverflow(device, text, start, count, x, y) {
        let drawn = 0;
        let atlasIndex = -1;
        let i = 0;
        for(; i < count; i++){
            const glyph = this.glyphManager.getGlyphInfo(text[i + start], this.font) || this.glyphManager.getGlyphInfo('?', this.font);
            if (atlasIndex >= 0 && glyph.atlasIndex !== atlasIndex) {
                this.textVertexBuffer.bufferSubData((this.textOffset + drawn) * 16 * 4, this.vertexCache, (this.textOffset + drawn) * 16, (i - drawn) * 16);
                this.textBindGroup.setTexture('tex', this.glyphManager.getAtlasTexture(atlasIndex));
                device.draw('triangle-list', (this.textOffset + drawn) * 6, (i - drawn) * 6);
                drawn = i;
            }
            atlasIndex = glyph.atlasIndex;
            const base = (this.textOffset + i) * 16;
            this.vertexCache[base + 0] = x;
            this.vertexCache[base + 1] = y;
            this.vertexCache[base + 2] = glyph.uMin;
            this.vertexCache[base + 3] = glyph.vMin;
            this.vertexCache[base + 4] = x + glyph.width;
            this.vertexCache[base + 5] = y;
            this.vertexCache[base + 6] = glyph.uMax;
            this.vertexCache[base + 7] = glyph.vMin;
            this.vertexCache[base + 8] = x + glyph.width;
            this.vertexCache[base + 9] = y + glyph.height;
            this.vertexCache[base + 10] = glyph.uMax;
            this.vertexCache[base + 11] = glyph.vMax;
            this.vertexCache[base + 12] = x;
            this.vertexCache[base + 13] = y + glyph.height;
            this.vertexCache[base + 14] = glyph.uMin;
            this.vertexCache[base + 15] = glyph.vMax;
            x += glyph.width;
        }
        this.textVertexBuffer.bufferSubData((this.textOffset + drawn) * 16 * 4, this.vertexCache, (this.textOffset + drawn) * 16, (i - drawn) * 16);
        this.textBindGroup.setTexture('tex', this.glyphManager.getAtlasTexture(atlasIndex));
        device.draw('triangle-list', (this.textOffset + drawn) * 6, (i - drawn) * 6);
        return x;
    }
    /** @internal */ static prepareDrawText(device) {
        if (!this.prepared) {
            this.prepared = true;
            this.font = this.font || Font.fetchFont('16px arial', device.getScale());
            this.glyphManager = new GlyphManager(device, 1024, 1024, 1);
            this.vertexCache = new Float32Array(this.GLYPH_COUNT * 16);
            this.textVertexBuffer = device.createInterleavedVertexBuffer([
                'position_f32x2',
                'tex0_f32x2'
            ], this.vertexCache, {
                dynamic: true
            });
            const indices = new Uint16Array(this.GLYPH_COUNT * 6);
            for(let i = 0; i < this.GLYPH_COUNT; i++){
                const base = i * 4;
                indices[i * 6 + 0] = base + 0;
                indices[i * 6 + 1] = base + 1;
                indices[i * 6 + 2] = base + 2;
                indices[i * 6 + 3] = base + 0;
                indices[i * 6 + 4] = base + 2;
                indices[i * 6 + 5] = base + 3;
            }
            const textIndexBuffer = device.createIndexBuffer(indices);
            this.textVertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: this.textVertexBuffer
                    }
                ],
                indexBuffer: textIndexBuffer
            });
            this.textOffset = 0;
            this.textProgram = device.buildRenderProgram({
                vertex (pb) {
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$inputs.uv = pb.vec2().attrib('texCoord0');
                    this.$outputs.uv = pb.vec2();
                    this.flip = pb.int(0).uniform(0);
                    this.textMatrix = pb.mat4().uniform(0);
                    pb.main(function() {
                        this.$builtins.position = pb.mul(this.textMatrix, pb.vec4(this.$inputs.pos, -50, 1));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                        this.$outputs.uv = this.$inputs.uv;
                    });
                },
                fragment (pb) {
                    this.$outputs.color = pb.vec4();
                    this.textColor = pb.vec4().uniform(0);
                    this.tex = pb.tex2D().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    pb.main(function() {
                        this.alpha = pb.mul(pb.textureSample(this.tex, this.$inputs.uv).a, this.textColor.a);
                        this.$if(pb.notEqual(this.srgbOut, 0), function() {
                            this.$outputs.color = pb.vec4(pb.mul(pb.pow(this.textColor.rgb, pb.vec3(1 / 2.2)), this.alpha), this.alpha);
                        }).$else(function() {
                            this.$outputs.color = pb.vec4(pb.mul(this.textColor.rgb, this.alpha), this.alpha);
                        });
                    });
                }
            });
            this.textBindGroup = device.createBindGroup(this.textProgram.bindGroupLayouts[0]);
            this.textRenderStates = device.createRenderStateSet();
            this.textRenderStates.useBlendingState().enable(true).setBlendFuncRGB('one', 'inv-src-alpha').setBlendFuncAlpha('zero', 'one');
            this.textRenderStates.useDepthState().enableTest(false).enableWrite(false);
            this.textRenderStates.useRasterizerState().setCullMode('none');
        }
    }
}

/**
 * Base class for rendering device
 * @public
 */ class BaseDevice {
    _canvas;
    _canvasClientWidth;
    _canvasClientHeight;
    _gpuObjectList;
    _gpuMemCost;
    _disposeObjectList;
    _beginFrameTime;
    _endFrameTime;
    _frameInfo;
    _cpuTimer;
    _gpuTimer;
    _runningLoop;
    _fpsCounter;
    _runLoopFunc;
    _backend;
    _beginFrameCounter;
    _programBuilder;
    _stateStack;
    constructor(cvs, backend){
        this._backend = backend;
        this._gpuObjectList = {
            textures: [],
            samplers: [],
            buffers: [],
            programs: [],
            framebuffers: [],
            vertexArrayObjects: [],
            bindGroups: []
        };
        this._canvas = cvs;
        this._canvas.setAttribute('tabindex', '1');
        this._canvasClientWidth = cvs.clientWidth;
        this._canvasClientHeight = cvs.clientHeight;
        this._gpuMemCost = 0;
        this._disposeObjectList = [];
        this._beginFrameTime = 0;
        this._endFrameTime = 0;
        this._runLoopFunc = null;
        this._frameInfo = {
            frameCounter: 0,
            frameTimestamp: 0,
            elapsedTimeCPU: 0,
            elapsedTimeGPU: 0,
            elapsedFrame: 0,
            elapsedOverall: 0,
            FPS: 0,
            drawCalls: 0,
            computeCalls: 0,
            nextFrameCall: []
        };
        this._programBuilder = new ProgramBuilder(this);
        this._cpuTimer = new CPUTimer();
        this._gpuTimer = null;
        this._runningLoop = null;
        this._fpsCounter = {
            time: 0,
            frame: 0
        };
        this._stateStack = [];
        this._beginFrameCounter = 0;
        this._registerEventHandlers();
    }
    get backend() {
        return this._backend;
    }
    get videoMemoryUsage() {
        return this._gpuMemCost;
    }
    get frameInfo() {
        return this._frameInfo;
    }
    get isRendering() {
        return this._runningLoop !== null;
    }
    get canvas() {
        return this._canvas;
    }
    get type() {
        return this._backend.typeName();
    }
    get runLoopFunction() {
        return this._runLoopFunc;
    }
    get programBuilder() {
        return this._programBuilder;
    }
    setFont(fontName) {
        DrawText.setFont(this, fontName);
    }
    drawText(text, x, y, color) {
        DrawText.drawText(this, text, color, x, y);
    }
    disposeObject(obj, remove = true) {
        if (obj) {
            if (remove) {
                this.removeGPUObject(obj);
            }
            if (!obj.disposed) {
                if (this.isContextLost()) {
                    obj.destroy();
                } else {
                    this._disposeObjectList.push(obj);
                }
            }
            obj.dispatchEvent(null, 'disposed');
        }
    }
    async restoreObject(obj) {
        if (obj && obj.disposed && !this.isContextLost()) {
            await obj.restore();
            if (obj.restoreHandler) {
                await obj.restoreHandler(obj);
            }
        }
    }
    enableGPUTimeRecording(enable) {
        if (enable && !this._gpuTimer) {
            this._gpuTimer = this.createGPUTimer();
        } else if (!enable) {
            this._gpuTimer?.end();
            this._gpuTimer = null;
        }
    }
    beginFrame() {
        if (this._beginFrameCounter === 0) {
            for (const obj of this._disposeObjectList){
                obj.destroy();
            }
            this._disposeObjectList = [];
        }
        this._beginFrameCounter++;
        this._beginFrameTime = this._cpuTimer.now();
        this.updateFrameInfo();
        return this.onBeginFrame();
    }
    endFrame() {
        if (this._beginFrameCounter > 0) {
            this._beginFrameCounter--;
            if (this._beginFrameCounter === 0) {
                this._endFrameTime = this._cpuTimer.now();
                this.onEndFrame();
            }
        }
    }
    getVertexAttribFormat(semantic, dataType, componentCount) {
        return getVertexAttribFormat(semantic, dataType, componentCount);
    }
    createInterleavedVertexBuffer(attribFormats, data, options) {
        if (options && options.usage && options.usage !== 'vertex') {
            console.error(`createVertexBuffer() failed: options.usage must be 'vertex' or not set`);
            return null;
        }
        let size = 0;
        for (const format of attribFormats){
            size += getVertexFormatSize(format);
        }
        const vertexBufferType = makeVertexBufferType(data.byteLength / size >> 0, ...attribFormats);
        const opt = Object.assign({
            usage: 'vertex',
            dynamic: false,
            managed: true,
            storage: false
        }, options || {});
        if (opt.storage) {
            opt.dynamic = false;
            opt.managed = false;
        }
        if (opt.dynamic) {
            opt.managed = false;
        }
        return this.createStructuredBuffer(vertexBufferType, opt, data);
    }
    createVertexBuffer(attribFormat, data, options) {
        if (options && options.usage && options.usage !== 'vertex') {
            console.error(`createVertexBuffer() failed: options.usage must be 'vertex' or not set`);
            return null;
        }
        const count = getVertexFormatSize(attribFormat);
        const vertexBufferType = makeVertexBufferType(data.byteLength / count >> 0, attribFormat);
        const opt = Object.assign({
            usage: 'vertex',
            dynamic: false,
            managed: true,
            storage: false
        }, options || {});
        if (opt.storage) {
            opt.dynamic = false;
            opt.managed = false;
        }
        if (opt.dynamic) {
            opt.managed = false;
        }
        return this.createStructuredBuffer(vertexBufferType, opt, data);
    }
    draw(primitiveType, first, count) {
        this._frameInfo.drawCalls++;
        this._draw(primitiveType, first, count);
    }
    drawInstanced(primitiveType, first, count, numInstances) {
        this._frameInfo.drawCalls++;
        this._drawInstanced(primitiveType, first, count, numInstances);
    }
    compute(workgroupCountX, workgroupCountY, workgroupCountZ) {
        this._frameInfo.computeCalls++;
        this._compute(workgroupCountX, workgroupCountY, workgroupCountZ);
    }
    runNextFrame(f) {
        if (f) {
            this._frameInfo.nextFrameCall.push(f);
        }
    }
    cancelNextFrameCall(f) {
        const index = this._frameInfo.nextFrameCall.indexOf(f);
        if (index >= 0) {
            this._frameInfo.nextFrameCall.splice(index, 1);
        }
    }
    exitLoop() {
        if (this._runningLoop) {
            cancelAnimationFrame(this._runningLoop);
            this._runningLoop = null;
        }
    }
    runLoop(func) {
        if (this._runningLoop !== null) {
            console.error('Device.runLoop() can not be nested');
            return;
        }
        if (!func) {
            console.error('Device.runLoop() argment error');
            return;
        }
        const that = this;
        that._runLoopFunc = func;
        (function entry() {
            that._runningLoop = requestAnimationFrame(entry);
            if (that.beginFrame()) {
                that._runLoopFunc(that);
                that.endFrame();
            }
        })();
    }
    pushDeviceStates() {
        this._stateStack.push({
            windowOrderReversed: this.isWindingOrderReversed(),
            framebuffer: this.getFramebuffer(),
            viewport: this.getViewport(),
            scissor: this.getScissor(),
            program: this.getProgram(),
            renderStateSet: this.getRenderStates(),
            vertexLayout: this.getVertexLayout(),
            bindGroups: [
                this.getBindGroup(0),
                this.getBindGroup(1),
                this.getBindGroup(2),
                this.getBindGroup(3)
            ]
        });
    }
    popDeviceStates() {
        if (this._stateStack.length === 0) {
            console.error('Device.popDeviceStates(): stack is empty');
        } else {
            const top = this._stateStack.pop();
            this.setFramebuffer(top.framebuffer);
            this.setViewport(top.viewport);
            this.setScissor(top.scissor);
            this.setProgram(top.program);
            this.setRenderStates(top.renderStateSet);
            this.setVertexLayout(top.vertexLayout);
            this.setBindGroup(0, ...top.bindGroups[0]);
            this.setBindGroup(1, ...top.bindGroups[1]);
            this.setBindGroup(2, ...top.bindGroups[2]);
            this.setBindGroup(3, ...top.bindGroups[3]);
            this.reverseVertexWindingOrder(top.windowOrderReversed);
        }
    }
    getGPUObjects() {
        return this._gpuObjectList;
    }
    getGPUObjectById(uid) {
        for (const list of [
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.buffers,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.programs,
            this._gpuObjectList.vertexArrayObjects
        ]){
            for (const obj of list){
                if (obj.uid === uid) {
                    return obj;
                }
            }
        }
        return null;
    }
    screenToDevice(val) {
        return this.getFramebuffer() ? val : Math.round(val * this.getScale());
    }
    deviceToScreen(val) {
        return this.getFramebuffer() ? val : Math.round(val / this.getScale());
    }
    buildRenderProgram(options) {
        return this._programBuilder.buildRenderProgram(options);
    }
    buildComputeProgram(options) {
        return this._programBuilder.buildComputeProgram(options);
    }
    addGPUObject(obj) {
        const list = this.getGPUObjectList(obj);
        if (list && list.indexOf(obj) < 0) {
            list.push(obj);
            this.dispatchEvent(new DeviceGPUObjectAddedEvent(obj));
        }
    }
    removeGPUObject(obj) {
        const list = this.getGPUObjectList(obj);
        if (list) {
            const index = list.indexOf(obj);
            if (index >= 0) {
                list.splice(index, 1);
                this.dispatchEvent(new DeviceGPUObjectRemovedEvent(obj));
            }
        }
    }
    updateVideoMemoryCost(delta) {
        this._gpuMemCost += delta;
    }
    _onresize() {
        if (this._canvasClientWidth !== this._canvas.clientWidth || this._canvasClientHeight !== this._canvas.clientHeight) {
            this._canvasClientWidth = this._canvas.clientWidth;
            this._canvasClientHeight = this._canvas.clientHeight;
            this.dispatchEvent(new DeviceResizeEvent(this._canvasClientWidth, this._canvasClientHeight));
        }
    }
    _registerEventHandlers() {
        const canvas = this._canvas;
        const that = this;
        if (window.ResizeObserver) {
            new window.ResizeObserver((entries)=>{
                that._onresize();
            }).observe(canvas, {});
        } else {
            if (window.MutationObserver) {
                new MutationObserver(function(mutations) {
                    if (mutations.length > 0) {
                        that._onresize();
                    }
                }).observe(canvas, {
                    attributes: true,
                    attributeFilter: [
                        'style'
                    ]
                });
            }
            window.addEventListener('resize', ()=>{
                this._onresize();
            });
        }
    }
    updateFrameInfo() {
        this._frameInfo.frameCounter++;
        this._frameInfo.drawCalls = 0;
        this._frameInfo.computeCalls = 0;
        const now = this._beginFrameTime;
        if (this._frameInfo.frameTimestamp === 0) {
            this._frameInfo.frameTimestamp = now;
            this._frameInfo.elapsedTimeCPU = 0;
            this._frameInfo.elapsedTimeGPU = 0;
            this._frameInfo.elapsedFrame = 0;
            this._frameInfo.elapsedOverall = 0;
            this._frameInfo.FPS = 0;
            this._fpsCounter.time = now;
            this._fpsCounter.frame = this._frameInfo.frameCounter;
            if (this._gpuTimer) {
                this._gpuTimer.begin();
            }
        } else {
            this._frameInfo.elapsedFrame = now - this._frameInfo.frameTimestamp;
            this._frameInfo.elapsedOverall += this._frameInfo.elapsedFrame;
            let gpuTime = 0;
            let cpuTime = 0;
            if (this._endFrameTime !== 0) {
                gpuTime = now - this._endFrameTime;
                cpuTime = this._endFrameTime - this._frameInfo.frameTimestamp;
            }
            this._frameInfo.frameTimestamp = now;
            if (now >= this._fpsCounter.time + 1000) {
                this._frameInfo.FPS = (this._frameInfo.frameCounter - this._fpsCounter.frame) * 1000 / (now - this._fpsCounter.time);
                this._fpsCounter.time = now;
                this._fpsCounter.frame = this._frameInfo.frameCounter;
                this._frameInfo.elapsedTimeGPU = gpuTime;
                this._frameInfo.elapsedTimeCPU = cpuTime;
            }
        }
        for (const f of this._frameInfo.nextFrameCall){
            f();
        }
        this._frameInfo.nextFrameCall.length = 0;
    }
    getGPUObjectList(obj) {
        let list = null;
        if (obj.isTexture()) {
            list = this._gpuObjectList.textures;
        } else if (obj.isSampler()) {
            list = this._gpuObjectList.samplers;
        } else if (obj.isBuffer()) {
            list = this._gpuObjectList.buffers;
        } else if (obj.isFramebuffer()) {
            list = this._gpuObjectList.framebuffers;
        } else if (obj.isProgram()) {
            list = this._gpuObjectList.programs;
        } else if (obj.isVertexLayout()) {
            list = this._gpuObjectList.vertexArrayObjects;
        } else if (obj.isBindGroup()) {
            list = this._gpuObjectList.bindGroups;
        }
        return list;
    }
    invalidateAll() {
        for (const list of [
            this._gpuObjectList.buffers,
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.programs,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.vertexArrayObjects,
            this._gpuObjectList.bindGroups
        ]){
            for (const obj of list){
                this.disposeObject(obj, false);
            }
        }
        if (this.isContextLost()) {
            for (const obj of this._disposeObjectList){
                obj.destroy();
            }
            this._disposeObjectList = [];
        }
    }
    async reloadAll() {
        const promises = [];
        for (const list of [
            this._gpuObjectList.buffers,
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.programs,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.vertexArrayObjects,
            this._gpuObjectList.bindGroups
        ]){
            // obj.reload() may change the list, so make a copy first
            for (const obj of list.slice()){
                promises.push(obj.reload());
            }
        }
        Promise.all(promises);
        return;
    }
    parseTextureOptions(options) {
        const noMipmapFlag = options?.samplerOptions?.mipFilter === 'none' ? GPUResourceUsageFlags.TF_NO_MIPMAP : 0;
        const writableFlag = options?.writable ? GPUResourceUsageFlags.TF_WRITABLE : 0;
        const dynamicFlag = options?.dynamic ? GPUResourceUsageFlags.DYNAMIC : 0;
        return noMipmapFlag | writableFlag | dynamicFlag;
    }
    parseBufferOptions(options, defaultUsage) {
        const usage = options?.usage || defaultUsage;
        let usageFlag;
        switch(usage){
            case 'uniform':
                usageFlag = GPUResourceUsageFlags.BF_UNIFORM;
                options.managed = false;
                options.dynamic = options.dynamic ?? true;
                break;
            case 'vertex':
                usageFlag = GPUResourceUsageFlags.BF_VERTEX;
                break;
            case 'index':
                usageFlag = GPUResourceUsageFlags.BF_INDEX;
                break;
            case 'read':
                usageFlag = GPUResourceUsageFlags.BF_READ;
                options.managed = false;
                break;
            case 'write':
                usageFlag = GPUResourceUsageFlags.BF_WRITE;
                options.managed = false;
                break;
            default:
                usageFlag = 0;
                break;
        }
        const storageFlag = options?.storage ?? false ? GPUResourceUsageFlags.BF_STORAGE : 0;
        const dynamicFlag = options?.dynamic ?? false ? GPUResourceUsageFlags.DYNAMIC : 0;
        const managedFlag = dynamicFlag === 0 && (options?.managed ?? true) ? GPUResourceUsageFlags.MANAGED : 0;
        return usageFlag | storageFlag | dynamicFlag | managedFlag;
    }
}

/**
 * Structured buffer data
 * @public
 */ class StructuredBufferData {
    /** @internal */ _cache;
    /** @internal */ _buffer;
    /** @internal */ _size;
    /** @internal */ _uniformMap;
    /** @internal */ _uniformPositions;
    /**
   * Creates a new structured buffer data
   * @param layout - Layout of the structure
   * @param buffer - Buffer that holds the data
   */ constructor(layout, buffer){
        this._size = layout.byteSize + 15 & ~15;
        if (this._size <= 0) {
            throw new Error(`UniformBuffer(): invalid uniform buffer byte size: ${this._size}`);
        }
        // this._cache = new ArrayBuffer(size);
        this._uniformMap = {};
        this._uniformPositions = {};
        this._cache = buffer instanceof ArrayBuffer ? buffer : null;
        this._buffer = buffer instanceof ArrayBuffer ? null : buffer;
        this.init(layout, 0, '');
    }
    /** The buffer size in bytes */ get byteLength() {
        return this._size;
    }
    /** Get the data cache buffer */ get buffer() {
        return this._cache;
    }
    /** Get all the uniform datas */ get uniforms() {
        return this._uniformMap;
    }
    /**
   * Sets the value of a structure member
   * @param name - Name of the member
   * @param value - Value to set
   */ set(name, value) {
        if (value !== undefined) {
            const view = this._uniformMap[name];
            if (view) {
                if (this._cache) {
                    if (typeof value === 'number') {
                        view[0] = value;
                    } else if (value?._v) {
                        view.set(value._v);
                    } else if (typeof value?.length === 'number') {
                        view.set(value);
                    } else {
                        throw new Error('invalid uniform value');
                    }
                } else {
                    const size = this._uniformPositions[name][1];
                    if (typeof value === 'number') {
                        view[0] = value;
                        this._buffer.bufferSubData(this._uniformPositions[name][0], view);
                    } else if (value['BYTES_PER_ELEMENT'] && size <= value['byteLength']) {
                        const arr = value;
                        this._buffer.bufferSubData(this._uniformPositions[name][0], arr, 0, size / arr.BYTES_PER_ELEMENT >> 0);
                    } else {
                        throw new Error('invalid uniform value');
                    }
                }
            } else {
                const proto = Object.getPrototypeOf(value);
                if (proto === Object.getPrototypeOf({})) {
                    this.setStruct(name, value);
                } else {
                    throw new Error('invalid uniform value');
                }
            }
        }
    }
    /** @internal */ setStruct(name, value) {
        for(const k in value){
            this.set(`${name}.${k}`, value[k]);
        }
    }
    /** @internal */ init(layout, offset, prefix) {
        for (const entry of layout.entries){
            if (entry.subLayout) {
                offset = this.init(entry.subLayout, offset, `${prefix}${entry.name}.`);
            } else {
                const name = `${prefix}${entry.name}`;
                if (this._uniformPositions[name]) {
                    throw new Error(`UniformBuffer(): duplicate uniform name: ${name}`);
                }
                if (entry.offset < offset || entry.byteSize < 0) {
                    throw new Error('UniformBuffer(): invalid layout');
                }
                this._uniformPositions[name] = [
                    entry.offset,
                    entry.byteSize
                ];
                let viewCtor = null;
                switch(entry.type){
                    case PBPrimitiveType.F32:
                        viewCtor = Float32Array;
                        break;
                    case PBPrimitiveType.U32:
                    case PBPrimitiveType.BOOL:
                        viewCtor = Uint32Array;
                        break;
                    case PBPrimitiveType.I32:
                        viewCtor = Int32Array;
                        break;
                    case PBPrimitiveType.U16:
                    case PBPrimitiveType.U16_NORM:
                    case PBPrimitiveType.F16:
                        viewCtor = Uint16Array;
                        break;
                    case PBPrimitiveType.I16:
                    case PBPrimitiveType.I16_NORM:
                        viewCtor = Int16Array;
                        break;
                    case PBPrimitiveType.U8:
                    case PBPrimitiveType.U8_NORM:
                        viewCtor = Uint8Array;
                        break;
                    case PBPrimitiveType.I8:
                    case PBPrimitiveType.I8_NORM:
                        viewCtor = Int8Array;
                        break;
                }
                if (!viewCtor) {
                    throw new Error(`UniformBuffer(): invalid data type for uniform: ${name}`);
                }
                if (entry.byteSize % viewCtor.BYTES_PER_ELEMENT) {
                    throw new Error(`UniformBuffer(): invalid byte size for uniform: ${name}`);
                }
                if (this._cache) {
                    this._uniformMap[name] = new viewCtor(this._cache, entry.offset, entry.byteSize / viewCtor.BYTES_PER_ELEMENT);
                } else {
                    this._uniformMap[name] = new viewCtor(1);
                }
                offset = entry.offset + entry.byteSize;
            }
        }
        return offset;
    }
}

/**
 * Decodes a float that was encoded into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param value - The rgba8unorm to be decoded
 * @returns The decoded float value
 *
 * @public
 */ function decodeNormalizedFloatFromRGBA(scope, value) {
    const pb = scope.$builder;
    if (!value || !value.$typeinfo.isPrimitiveType() || value.$typeinfo.primitiveType !== PBPrimitiveType.F32VEC4) {
        throw new Error('decodeNormalizedFloatFromRGBA() failed: parameter type must be vec4');
    }
    if (!scope || !(scope instanceof PBInsideFunctionScope)) {
        throw new Error('decodeNormalizedFloatFromRGBA() failed: decodeNormalizedFloatFromRGBA() must be called inside a function');
    }
    const funcName = 'Z_decodeNormalizedFloatFromRGBA';
    pb.func(funcName, [
        pb.vec4('value')
    ], function() {
        this.$l.bitShift = pb.vec4(1 / (256 * 256 * 256), 1 / (256 * 256), 1 / 256, 1);
        this.$return(pb.dot(this.value, this.bitShift));
    });
    return scope[funcName](value);
}
/**
 * Encodes a float into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param value - The float value to be encode
 * @returns The encoded rgba8unorm
 *
 * @public
 */ function encodeNormalizedFloatToRGBA(scope, value) {
    const pb = scope.$builder;
    const funcName = 'Z_encodeNormalizedFloatToRGBA';
    pb.func(funcName, [
        pb.float('value')
    ], function() {
        this.$l.bitShift = pb.vec4(256 * 256 * 256, 256 * 256, 256, 1);
        this.$l.bitMask = pb.vec4(0, 1 / 256, 1 / 256, 1 / 256);
        this.$l.t = pb.fract(pb.mul(this.value, this.bitShift));
        this.$return(pb.sub(this.t, pb.mul(this.t.xxyz, this.bitMask)));
    });
    return pb.getGlobalScope()[funcName](value);
}
/**
 * Encodes two half floats into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param a - The first half float to be encode
 * @param b - The second half float to be encode
 * @returns The encoded rgba8unorm
 *
 * @public
 */ function encode2HalfToRGBA(scope, a, b) {
    const pb = scope.$builder;
    const funcName = 'Z_encode2HalfToRGBA';
    pb.func(funcName, [
        pb.float('a'),
        pb.float('b')
    ], function() {
        this.$l.t = pb.vec4(this.a, pb.fract(pb.mul(this.a, 255)), this.b, pb.fract(pb.mul(this.b, 255)));
        this.$return(pb.vec4(pb.sub(this.t.x, pb.div(this.t.y, 255)), this.t.y, pb.sub(this.t.z, pb.div(this.t.w, 255)), this.t.w));
    });
    return pb.getGlobalScope()[funcName](a, b);
}
/**
 * Decodes two half floats that was encoded into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param value - The rgba8unorm to be decoded
 * @returns A vec2 that contains the two half floats
 *
 * @public
 */ function decode2HalfFromRGBA(scope, value) {
    const pb = scope.$builder;
    const funcName = 'Z_decode2HalfFromRGBA';
    pb.func(funcName, [
        pb.vec4('value')
    ], function() {
        this.$return(pb.vec2(pb.add(this.value.x, pb.div(this.value.y, 255)), pb.add(this.value.z, pb.div(this.value.w, 255))));
    });
    return pb.getGlobalScope()[funcName](value);
}
/**
 * Converts a vec3 color from linear space to gamma space
 *
 * @param scope - Current shader scope
 * @param color - The vec3 color to be converted
 * @returns The gamma space vec3 color
 *
 * @public
 */ function linearToGamma(scope, color) {
    const pb = scope.$builder;
    const funcName = 'Z_linearToGamma';
    pb.func(funcName, [
        pb.vec3('color')
    ], function() {
        // Almost perfect version from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
        // C_srgb_2 = max(1.055 * pow(C_lin, 0.416666667) - 0.055, 0);
        this.$return(pb.max(pb.sub(pb.mul(pb.pow(this.color, pb.vec3(0.416666667)), 1.055), pb.vec3(0.055)), pb.vec3(0)));
    });
    return pb.getGlobalScope()[funcName](color);
}

[
    [
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0),
        new Vector3(1, 0, 0)
    ],
    [
        new Vector3(0, 0, 1),
        new Vector3(0, -1, 0),
        new Vector3(-1, 0, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, 1)
    ],
    [
        new Vector3(-1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, -1)
    ]
];

/**
 * Primitive contains only the vertex and index data of a mesh
 * @public
 */ class Primitive {
    /** @internal */ _vertexLayout;
    /** @internal */ _vertexLayoutOptions;
    /** @internal */ _primitiveType;
    /** @internal */ _indexStart;
    /** @internal */ _indexCount;
    /** @internal */ _defaultIndexCount;
    /** @internal */ _vertexLayoutDirty;
    /** @internal */ static _nextId = 0;
    /** @internal */ _id;
    /** @internal */ _bbox;
    /** @internal */ _bboxChangeCallback;
    /**
   * Creates an instance of a primitive
   */ constructor(){
        this._vertexLayout = null;
        this._vertexLayoutOptions = {
            vertexBuffers: []
        };
        this._primitiveType = 'triangle-list';
        this._indexStart = 0;
        this._indexCount = null;
        this._defaultIndexCount = 0;
        this._vertexLayoutDirty = false;
        this._id = ++Primitive._nextId;
        this._bbox = null;
        this._bboxChangeCallback = [];
    }
    /**
   * Unique identifier of the primitive
   * @internal
   */ get id() {
        return this._id;
    }
    /**
   * Adds a callback function that will be called whenever the bounding box of the primitive changes.
   * @param cb - The callback function
   *
   * @internal
   */ addBoundingboxChangeCallback(cb) {
        cb && this._bboxChangeCallback.push(cb);
    }
    /**
   * Removes a callback function for bounding box changing
   * @param cb - The callback function to be removed
   */ removeBoundingboxChangeCallback(cb) {
        const index = this._bboxChangeCallback.indexOf(cb);
        if (index >= 0) {
            this._bboxChangeCallback.splice(index, 1);
        }
    }
    /** Primitive type */ get primitiveType() {
        return this._primitiveType;
    }
    set primitiveType(type) {
        this._primitiveType = type;
    }
    /** Start index for drawing */ get indexStart() {
        return this._indexStart;
    }
    set indexStart(val) {
        this._indexStart = val;
    }
    /** The number of the indices or vertices to be drawn */ get indexCount() {
        this._indexCount = this._indexCount ?? this.calcDefaultIndexCount();
        return this._indexCount;
    }
    set indexCount(val) {
        this._indexCount = val;
    }
    /**
   * Removes a vertex buffer from the primitive
   * @param buffer - The vertex buffer to be removed
   */ removeVertexBuffer(buffer) {
        for(let loc = 0; loc < this._vertexLayoutOptions.vertexBuffers.length; loc++){
            const info = this._vertexLayoutOptions.vertexBuffers[loc];
            if (info?.buffer === buffer) {
                info[loc] = null;
                this._vertexLayoutDirty = true;
            }
        }
    }
    /**
   * Gets the vertex buffer by a given semantic
   * @param semantic - The semantic of the vertex buffer
   * @returns The vertex buffer which semantic matches the given value
   */ getVertexBuffer(semantic) {
        this.checkVertexLayout();
        return this._vertexLayout.getVertexBuffer(semantic);
    }
    /**
   * Gets the vertex buffer information by a given semantic
   * @param semantic - The semantic of the vertex buffer
   * @returns The vertex buffer information of the given semantic
   */ getVertexBufferInfo(semantic) {
        this.checkVertexLayout();
        return this._vertexLayout.getVertexBufferInfo(semantic);
    }
    /**
   * Creates a vertex buffer from the given options and then adds it to the primitive
   * @param format - Vertex format for the vertex buffer
   * @param data - Contents of the vertex buffer
   * @param stepMode - Step mode of the vertex buffer
   * @returns The created vertex buffer
   */ createAndSetVertexBuffer(format, data, stepMode) {
        const buffer = Application.instance.device.createVertexBuffer(format, data);
        return this.setVertexBuffer(buffer, stepMode);
    }
    /**
   * Adds a vertex buffer to the primitive
   * @param buffer - The vertex buffer to be added
   * @param stepMode - Step mode of the vertex buffer
   * @returns The added vertex buffer
   */ setVertexBuffer(buffer, stepMode) {
        this._vertexLayoutOptions.vertexBuffers.push({
            buffer,
            stepMode
        });
        this._vertexLayoutDirty = true;
        return buffer;
    }
    /**
   * Creates an index buffer from the given options and then adds it to the prmitive
   * @param data - Contents of the index buffer
   * @param dynamic - true if the index buffer is dynamic
   * @returns The created index buffer
   */ createAndSetIndexBuffer(data, dynamic) {
        const buffer = Application.instance.device.createIndexBuffer(data, {
            dynamic: !!dynamic,
            managed: !dynamic
        });
        this.setIndexBuffer(buffer);
        return buffer;
    }
    /**
   * Adds an index buffer to the primitive
   * @param buffer - The index buffer to be added
   */ setIndexBuffer(buffer) {
        if (this._vertexLayoutOptions.indexBuffer !== buffer) {
            this._vertexLayoutOptions.indexBuffer = buffer;
            this._vertexLayoutDirty = true;
        }
    }
    /**
   * Gets the index buffer of the primitive
   * @returns The index buffer of the primitive
   */ getIndexBuffer() {
        return this._vertexLayoutOptions.indexBuffer;
    }
    /**
   * Draw the prmitive
   */ draw() {
        this.checkVertexLayout();
        if (this.indexCount > 0) {
            this._vertexLayout?.draw(this._primitiveType, this._indexStart, this.indexCount);
        }
    }
    /**
   * Draw multiple instances of the primitive
   * @param numInstances - How many instances of the primitive should be drawn
   */ drawInstanced(numInstances) {
        this.checkVertexLayout();
        if (this.indexCount > 0) {
            this._vertexLayout?.drawInstanced(this._primitiveType, this._indexStart, this.indexCount, numInstances);
        }
    }
    /**
   * Disposes the primitive
   *
   * @remarks
   * The vertex buffers and index buffer will also be disposed.
   * To prevent specific vertex buffer or index buffer to be disposed,
   * call removeVertexBuffer() or setIndexBuffer(null) first.
   */ dispose() {
        if (this._vertexLayout) {
            const vertexBuffers = this._vertexLayout.vertexBuffers;
            for(const k in vertexBuffers){
                vertexBuffers[k]?.buffer?.dispose();
            }
            this._vertexLayout.indexBuffer?.dispose();
            this._vertexLayout.dispose();
            this._vertexLayout = null;
        }
        this._indexCount = null;
        this._indexStart = 0;
    }
    /*
  createAABBTree(): AABBTree {
    const indices = this.getIndexBuffer() ? this.getIndexBuffer().getData() : null;
    const vertices = (this.getVertexBuffer(VERTEX_ATTRIB_POSITION)?.getData() as Float32Array) || null;
    const aabbtree = new AABBTree();
    aabbtree.buildFromPrimitives(vertices, indices, this._primitiveType);
    return aabbtree;
  }
  */ /**
   * Gets the bounding volume of the primitive
   * @returns The bounding volume of the primitive, or null if no bounding volume set
   */ getBoundingVolume() {
        return this._bbox;
    }
    /**
   * Sets the bounding volume of the primitive
   * @param bv - The bounding volume to be set
   */ setBoundingVolume(bv) {
        if (bv !== this._bbox) {
            this._bbox = bv;
            for (const cb of this._bboxChangeCallback){
                cb();
            }
        }
    }
    /**
   * Ray intersection test
   * @param ray - Ray object used to do intersection test with this object
   * @returns The distance from ray origin to the intersection point if ray intersects with this object, otherwise null
   */ raycast(ray) {
        const aabb = this.getBoundingVolume()?.toAABB();
        return aabb ? ray.bboxIntersectionTestEx(aabb) : null;
    }
    /** @internal */ checkVertexLayout() {
        if (this._vertexLayoutDirty) {
            this._vertexLayout?.dispose();
            this._vertexLayout = Application.instance.device.createVertexLayout(this._vertexLayoutOptions);
            this._vertexLayoutDirty = false;
        }
    }
    /** @internal */ calcDefaultIndexCount() {
        const indexBuffer = this.getIndexBuffer();
        if (indexBuffer) {
            return Math.max(0, indexBuffer.length - this._indexStart);
        }
        const info = this.getVertexBufferInfo('position');
        if (info) {
            return Math.max(0, Math.floor((info.buffer.byteLength - info.drawOffset) / info.stride) - this._indexStart);
        }
        return 0;
    }
}

/**
 * Base class for any kind of blitters
 * @public
 */ class Blitter {
    /** @internal */ _hash;
    /** @internal */ _renderStates;
    /** @internal */ _srgbOut;
    /** @internal */ _flip;
    /** @internal */ _viewport;
    /** @internal */ _scissor;
    /** @internal */ _destRect;
    /** @internal */ _offsetParams;
    /**
   * Creates an instance of Blitter
   */ constructor(){
        this._hash = null;
        this._renderStates = null;
        this._srgbOut = false;
        this._flip = false;
        this._viewport = null;
        this._scissor = null;
        this._destRect = null;
        this._offsetParams = new Vector4();
    }
    /** Viewport */ get viewport() {
        return this._viewport;
    }
    set viewport(val) {
        this._viewport = val ?? null;
    }
    /** Scissor rect */ get scissor() {
        return this._scissor;
    }
    set scissor(val) {
        this._scissor = val ?? null;
    }
    /** Destination rectangle */ get destRect() {
        return this._destRect;
    }
    set destRect(val) {
        if (!!this._destRect !== !!val) {
            this.invalidateHash();
        }
        this._destRect = val ?? null;
    }
    /**
   * Whether output color value in gamma color space
   */ get srgbOut() {
        return this._srgbOut;
    }
    set srgbOut(val) {
        if (this._srgbOut !== !!val) {
            this._srgbOut = !!val;
            this.invalidateHash();
        }
    }
    /**
   * Render states used to do the blitting
   */ get renderStates() {
        return this._renderStates;
    }
    set renderStates(rs) {
        this._renderStates = rs;
    }
    /**
   * Program hash code
   */ get hash() {
        if (!this._hash) {
            this._hash = `${this.constructor.name}:${this._srgbOut ? 1 : 0}:${this._flip ? 1 : 0}:${this._destRect ? 1 : 0}:${this.calcHash()}`;
        }
        return this._hash;
    }
    /**
   * Force the hash code to be regenerated
   */ invalidateHash() {
        this._hash = null;
    }
    /**
   * Reads a texel from the source texture
   * @param scope - The shader scope
   * @param type - The blit type
   * @param srcTex - The source texture
   * @param uv - The texture coordinate from where the texel will be read
   * @param srcLayer - The layer of the source texture
   * @returns The read texel
   */ readTexel(scope, type, srcTex, uv, srcLayer, sampleType) {
        const pb = scope.$builder;
        if (sampleType === 'float') {
            switch(type){
                case '2d':
                case 'cube':
                    return Application.instance.device.getDeviceCaps().shaderCaps.supportShaderTextureLod ? pb.textureSampleLevel(srcTex, uv, 0) : pb.textureSample(srcTex, uv);
                case '2d-array':
                    return pb.textureArraySampleLevel(srcTex, uv, srcLayer, 0);
                default:
                    return null;
            }
        } else {
            switch(type){
                case '2d':
                    return pb.textureLoad(srcTex, pb.ivec2(pb.mul(pb.vec2(pb.textureDimensions(srcTex, 0)), uv)), 0);
                case 'cube':
                    throw new Error('Integer format cube texture not supported');
                case '2d-array':
                    return pb.textureArrayLoad(srcTex, pb.ivec2(pb.mul(pb.vec2(pb.textureDimensions(srcTex, 0)), uv)), srcLayer, 0);
                default:
                    return null;
            }
        }
    }
    /**
   * Writes a texel to destination texture
   * @param scope - The shader scope
   * @param type - The blit type
   * @param uv - The texture coordinate to where the texel will be written
   * @param texel - The texel to be written
   * @returns The written texel
   */ writeTexel(scope, type, uv, texel) {
        return texel;
    }
    /**
   * Initialize uniforms of the blit program
   * @param scope - The shader scope
   * @param type - The blit type
   */ setup(scope, type) {}
    /**
   * Update uniforms of the bind group
   * @param bindGroup - The bind group to be updated
   */ setUniforms(bindGroup, sourceTex) {}
    /** @internal */ blit2D(source, dest, sampler) {
        const device = Application.instance.device;
        const flip = !dest && device.type === 'webgpu';
        const bilinearFiltering = sampler ? sampler.magFilter === 'linear' || sampler.minFilter === 'linear' || sampler.mipFilter === 'linear' : source.isFilterable();
        const programInfo = getBlitProgram('2d', this, bilinearFiltering, source.isIntegerFormat() ? source.isSignedFormat() ? 'int' : 'uint' : 'float', flip);
        programInfo.bindGroup.setTexture('srcTex', source, sampler);
        if (this._destRect) {
            const destWidth = this._viewport?.[2] ?? dest?.getWidth() ?? device.getBackBufferWidth();
            const destHeight = this._viewport?.[3] ?? dest?.getHeight() ?? device.getBackBufferHeight();
            this._offsetParams.setXYZW(this._destRect[2] / destWidth, this._destRect[3] / destHeight, (this._destRect[2] + 2 * this._destRect[0]) / destWidth - 1, (this._destRect[3] + 2 * this._destRect[1]) / destHeight - 1);
            programInfo.bindGroup.setValue('scaleBias', this._offsetParams);
        }
        this.setUniforms(programInfo.bindGroup, source);
        device.setFramebuffer(dest ?? null);
        device.setViewport(this._viewport);
        device.setScissor(this._scissor);
        device.setProgram(programInfo.program);
        device.setBindGroup(0, programInfo.bindGroup);
        device.setRenderStates(this._renderStates ?? getBlitRenderStateSet());
        getBlitPrimitive2D().draw();
    }
    /** @internal */ blit2DArray(source, dest, layer, sampler) {
        const device = Application.instance.device;
        const flip = !dest && device.type === 'webgpu';
        const bilinearFiltering = sampler ? sampler.magFilter === 'linear' || sampler.minFilter === 'linear' || sampler.mipFilter === 'linear' : source.isFilterable();
        const programInfo = getBlitProgram('2d-array', this, bilinearFiltering, source.isIntegerFormat() ? source.isSignedFormat() ? 'int' : 'uint' : 'float', flip);
        programInfo.bindGroup.setTexture('srcTex', source, sampler);
        programInfo.bindGroup.setValue('srcLayer', layer);
        this.setUniforms(programInfo.bindGroup, source);
        device.setFramebuffer(dest ?? null);
        device.setViewport(this._viewport);
        device.setScissor(this._scissor);
        device.setProgram(programInfo.program);
        device.setBindGroup(0, programInfo.bindGroup);
        device.setRenderStates(this._renderStates ?? getBlitRenderStateSet());
        getBlitPrimitive2D().draw();
    }
    /** @internal */ blitCubeMap(source, dest, face, sampler) {
        const device = Application.instance.device;
        const flip = !dest && device.type === 'webgpu';
        const bilinearFiltering = sampler ? sampler.magFilter === 'linear' || sampler.minFilter === 'linear' || sampler.mipFilter === 'linear' : source.isFilterable();
        const programInfo = getBlitProgram('cube', this, bilinearFiltering, source.isIntegerFormat() ? source.isSignedFormat() ? 'int' : 'uint' : 'float', flip);
        programInfo.bindGroup.setTexture('srcTex', source, sampler);
        programInfo.bindGroup.setValue('texelSize', 1 / source.width);
        programInfo.bindGroup.setValue('cubeFace', face);
        this.setUniforms(programInfo.bindGroup, source);
        device.setFramebuffer(dest ?? null);
        device.setViewport(this._viewport);
        device.setScissor(this._scissor);
        device.setProgram(programInfo.program);
        device.setBindGroup(0, programInfo.bindGroup);
        device.setRenderStates(this._renderStates ?? getBlitRenderStateSet());
        getBlitPrimitive2D().draw();
    }
    blit(source, dest, layer, sampler) {
        const device = Application.instance.device;
        device.pushDeviceStates();
        if (!dest) {
            if (source.isTexture2D()) {
                this.blit2D(source, null, sampler);
            } else if (source.isTexture2DArray()) {
                this.blit2DArray(source, null, layer || 0, sampler);
            } else if (source.isTextureCube()) {
                this.blitCubeMap(source, null, layer || 0, sampler);
            } else {
                throw new Error('Blitter.blit() failed: invalid texture type');
            }
        } else {
            const framebuffer = dest.isFramebuffer() ? dest : device.createFrameBuffer([
                dest
            ], null);
            const destTexture = dest.isFramebuffer() ? dest.getColorAttachments()?.[0] : dest;
            if (source.isTexture2D()) {
                if (!destTexture?.isTexture2D() && !destTexture?.isTexture2DArray()) {
                    throw new Error('Blitter.blit() failed: invalid destination texture type');
                }
                if (destTexture.isTexture2DArray()) {
                    framebuffer.setColorAttachmentLayer(0, layer || 0);
                }
                this.blit2D(source, framebuffer, sampler);
            } else if (source.isTexture2DArray()) {
                if (!destTexture?.isTexture2D() && !destTexture.isTexture2DArray()) {
                    throw new Error('Blitter.blit() failed: invalid destination texture type');
                }
                if (destTexture.isTexture2D()) {
                    this.blit2DArray(source, framebuffer, layer || 0, sampler);
                } else {
                    if (destTexture.depth !== source.depth) {
                        throw new Error('Blitter.blit() failed: can not blit between texture 2d arrays with different array size');
                    } else {
                        for(let i = 0; i < source.depth; i++){
                            framebuffer.setColorAttachmentLayer(0, i);
                            this.blit2DArray(source, framebuffer, i, layer);
                        }
                    }
                }
            } else if (source.isTextureCube()) {
                if (!destTexture.isTextureCube() && !destTexture.isTexture2D()) {
                    throw new Error('Blitter.blit() failed: invalid destination texture type');
                }
                if (destTexture.isTextureCube()) {
                    for(let i = 0; i < 6; i++){
                        framebuffer.setColorAttachmentCubeFace(0, i);
                        this.blitCubeMap(source, framebuffer, i, layer);
                    }
                } else {
                    this.blitCubeMap(source, framebuffer, layer || 0, sampler);
                }
            } else {
                throw new Error('Blitter.blit() failed: invalid texture type');
            }
            if (framebuffer && framebuffer !== dest) {
                framebuffer.dispose();
            }
        }
        device.popDeviceStates();
    }
}
const blitProgramCache = {};
let blitPrimitive2D = null;
let blitRenderStates = null;
function getBlitPrimitive2D() {
    if (!blitPrimitive2D) {
        blitPrimitive2D = new Primitive();
        const vb = Application.instance.device.createVertexBuffer('position_f32x2', new Float32Array([
            -1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1
        ]));
        blitPrimitive2D.setVertexBuffer(vb);
        blitPrimitive2D.indexCount = 4;
        blitPrimitive2D.indexStart = 0;
        blitPrimitive2D.primitiveType = 'triangle-strip';
    }
    return blitPrimitive2D;
}
function getBlitRenderStateSet() {
    if (!blitRenderStates) {
        blitRenderStates = Application.instance.device.createRenderStateSet();
        blitRenderStates.useDepthState().enableTest(false).enableWrite(false);
        blitRenderStates.useRasterizerState().setCullMode('none');
    }
    return blitRenderStates;
}
function getBlitProgram(type, filter, bilinearFiltering, sampleType, flip) {
    const hash = `${type}:${filter.hash}:${bilinearFiltering}:${sampleType}:${flip ? 1 : 0}`;
    let programInfo = blitProgramCache[hash];
    if (programInfo === undefined) {
        programInfo = createBlitProgram(type, filter, bilinearFiltering, sampleType, flip, !!filter.destRect) || null;
        blitProgramCache[hash] = programInfo;
    }
    return programInfo;
}
function createBlitProgram(type, filter, bilinearFiltering, st, flip, scaleBias) {
    const program = Application.instance.device.buildRenderProgram({
        vertex (pb) {
            this.$inputs.pos = pb.vec2().attrib('position');
            this.$outputs.uv = pb.vec2();
            if (scaleBias) {
                this.scaleBias = pb.vec4().uniform(0);
            }
            filter.setup(this, type);
            pb.main(function() {
                this.$builtins.position = pb.vec4(this.$inputs.pos, 1, 1);
                this.$outputs.uv = type === 'cube' ? pb.mul(pb.vec2(1, -1), this.$inputs.pos.xy) : pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                if (Application.instance.device.type === 'webgpu') {
                    this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                }
                if (scaleBias) {
                    this.$l.xy = pb.add(pb.mul(this.$builtins.position.xy, this.scaleBias.xy), this.scaleBias.zw);
                    this.$builtins.position = pb.vec4(this.xy, 1, 1);
                }
            });
        },
        fragment (pb) {
            switch(type){
                case '2d':
                    if (st === 'int') {
                        this.srcTex = pb.itex2D().sampleType('sint').uniform(0);
                    } else if (st === 'uint') {
                        this.srcTex = pb.utex2D().sampleType('uint').uniform(0);
                    } else {
                        this.srcTex = pb.tex2D().sampleType(bilinearFiltering ? 'float' : 'unfilterable-float').uniform(0);
                    }
                    break;
                case '2d-array':
                    if (st === 'int') {
                        this.srcTex = pb.itex2DArray().sampleType('sint').uniform(0);
                    } else if (st === 'uint') {
                        this.srcTex = pb.utex2DArray().sampleType('uint').uniform(0);
                    } else {
                        this.srcTex = pb.tex2DArray().sampleType(bilinearFiltering ? 'float' : 'unfilterable-float').uniform(0);
                    }
                    this.srcLayer = pb.int().uniform(0);
                    break;
                case 'cube':
                    if (st === 'int') {
                        this.srcTex = pb.itexCube().sampleType('sint').uniform(0);
                    } else if (st === 'uint') {
                        this.srcTex = pb.utexCube().sampleType('uint').uniform(0);
                    } else {
                        this.srcTex = pb.texCube().sampleType(bilinearFiltering ? 'float' : 'unfilterable-float').uniform(0);
                    }
                    this.texelSize = pb.float().uniform(0);
                    this.cubeFace = pb.int().uniform(0);
                    break;
                default:
                    throw new Error(`invalid blit type: ${type}`);
            }
            this.$outputs.outColor = pb.vec4();
            filter.setup(this, type);
            pb.main(function() {
                if (type === 'cube') {
                    this.uv = pb.vec3();
                    this.$if(pb.equal(this.cubeFace, 0), function() {
                        this.uv = pb.vec3(1, this.$inputs.uv.y, pb.neg(this.$inputs.uv.x));
                    }).$elseif(pb.equal(this.cubeFace, 1), function() {
                        this.uv = pb.vec3(-1, this.$inputs.uv.y, this.$inputs.uv.x);
                    }).$elseif(pb.equal(this.cubeFace, 2), function() {
                        this.uv = pb.vec3(this.$inputs.uv.x, 1, pb.neg(this.$inputs.uv.y));
                    }).$elseif(pb.equal(this.cubeFace, 3), function() {
                        this.uv = pb.vec3(this.$inputs.uv.x, -1, this.$inputs.uv.y);
                    }).$elseif(pb.equal(this.cubeFace, 4), function() {
                        this.uv = pb.vec3(this.$inputs.uv.x, this.$inputs.uv.y, 1);
                    }).$else(function() {
                        this.uv = pb.vec3(pb.neg(this.$inputs.uv.x), this.$inputs.uv.y, -1);
                    });
                } else {
                    this.uv = this.$inputs.uv;
                }
                if (flip) {
                    this.uv.y = pb.sub(1, this.uv.y);
                }
                this.$l.outTexel = filter.filter(this, type, this.srcTex, this.uv, type === '2d' ? null : this.srcLayer, st);
                this.$outputs.outColor = filter.writeTexel(this, type, this.$inputs.uv, this.outTexel);
                if (filter.srgbOut) {
                    this.$outputs.outColor = pb.vec4(linearToGamma(this, this.$outputs.outColor.rgb), this.$outputs.outColor.a);
                }
            });
        }
    });
    return program ? {
        program,
        bindGroup: Application.instance.device.createBindGroup(program.bindGroupLayouts[0])
    } : null;
}

/**
 * Copy blitter
 * @public
 */ class CopyBlitter extends Blitter {
    /**
   * {@inheritDoc Blitter.filter}
   * @override
   */ filter(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        return this.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
    }
    /**
   * {@inheritDoc Blitter.calcHash}
   * @override
   */ calcHash() {
        return '';
    }
}

[
    [
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0),
        new Vector3(1, 0, 0)
    ],
    [
        new Vector3(0, 0, 1),
        new Vector3(0, -1, 0),
        new Vector3(-1, 0, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, 1)
    ],
    [
        new Vector3(-1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, -1)
    ]
];

/**
 * The bounding box class
 * @public
 */ class BoundingBox extends AABB {
    constructor(arg0, arg1){
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        super(arg0, arg1);
    }
    /** {@inheritDoc BoundingVolume.behindPlane} */ behindPlane(plane) {
        return this.toAABB().behindPlane(plane);
    }
    /** {@inheritDoc BoundingVolume.clone} */ clone() {
        return new BoundingBox(this);
    }
    /** {@inheritDoc BoundingVolume.transform} */ transform(matrix) {
        return new BoundingBox(AABB.transform(this, matrix));
    }
    /** {@inheritDoc BoundingVolume.outsideFrustum} */ outsideFrustum(frustum) {
        return (frustum instanceof Frustum ? this.getClipStateWithFrustum(frustum) : this.getClipState(frustum)) === ClipState.NOT_CLIPPED;
    }
    /** {@inheritDoc BoundingVolume.toAABB} */ toAABB() {
        return this;
    }
}

/**
 * Abstract base class for any kind of shapes
 * @public
 */ class Shape extends Primitive {
    /** @internal */ _options;
    /**
   * Creates an instance of shape
   * @param options - The creation options
   */ constructor(options){
        super();
        this._options = this.createDefaultOptions();
        this.create(options);
    }
    /** @internal */ create(options) {
        if (options) {
            this._options = this.createDefaultOptions();
            Object.assign(this._options, options);
        }
        return this._create();
    }
    /** @internal */ createDefaultOptions() {
        return {
            needNormal: true,
            needTangent: false,
            needUV: true
        };
    }
}

/**
 * Box shape
 * @public
 */ class BoxShape extends Shape {
    /**
   * Creates an instance of box shape
   * @param options - The creation options
   */ constructor(options){
        super(options);
    }
    /** @internal */ createDefaultOptions() {
        const options = super.createDefaultOptions();
        options.size = 1;
        return options;
    }
    /** @internal */ _createArrays(vertices, normals, uvs, indices, minx, miny, minz, maxx, maxy, maxz) {
        const needTangent = this._options.needTangent;
        const needNormal = this._options.needNormal || needTangent;
        const needUV = this._options.needUV;
        const uv = needUV ? [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ] : null;
        const topFacePos = [
            minx,
            maxy,
            minz,
            minx,
            maxy,
            maxz,
            maxx,
            maxy,
            maxz,
            maxx,
            maxy,
            minz
        ];
        const topFacenormal = needNormal ? [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ] : null;
        const frontFacePos = [
            minx,
            maxy,
            maxz,
            minx,
            miny,
            maxz,
            maxx,
            miny,
            maxz,
            maxx,
            maxy,
            maxz
        ];
        const frontFaceNormal = needNormal ? [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ] : null;
        const rightFacePos = [
            maxx,
            maxy,
            maxz,
            maxx,
            miny,
            maxz,
            maxx,
            miny,
            minz,
            maxx,
            maxy,
            minz
        ];
        const rightFaceNormal = needNormal ? [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ] : null;
        const backFacePos = [
            maxx,
            maxy,
            minz,
            maxx,
            miny,
            minz,
            minx,
            miny,
            minz,
            minx,
            maxy,
            minz
        ];
        const backFaceNormal = needNormal ? [
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1
        ] : null;
        const leftFacePos = [
            minx,
            maxy,
            minz,
            minx,
            miny,
            minz,
            minx,
            miny,
            maxz,
            minx,
            maxy,
            maxz
        ];
        const leftFaceNormal = needNormal ? [
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0
        ] : null;
        const bottomFacePos = [
            minx,
            miny,
            maxz,
            minx,
            miny,
            minz,
            maxx,
            miny,
            minz,
            maxx,
            miny,
            maxz
        ];
        const bottomFaceNormal = needNormal ? [
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0
        ] : null;
        indices && indices.push(0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23);
        vertices && vertices.push(...topFacePos, ...frontFacePos, ...rightFacePos, ...backFacePos, ...leftFacePos, ...bottomFacePos);
        needNormal && normals && normals.push(...topFacenormal, ...frontFaceNormal, ...rightFaceNormal, ...backFaceNormal, ...leftFaceNormal, ...bottomFaceNormal);
        needUV && uvs && uvs.push(...uv, ...uv, ...uv, ...uv, ...uv, ...uv);
        this.primitiveType = 'triangle-list';
    }
    /** @internal */ _create() {
        const needNormal = this._options.needNormal;
        const needUV = this._options.needUV;
        const sizeX = this._options.sizeX ?? this._options.size ?? 1;
        const sizeY = this._options.sizeY ?? this._options.size ?? 1;
        const sizeZ = this._options.sizeZ ?? this._options.size ?? 1;
        const anchorX = this._options.anchorX ?? 0;
        const anchorY = this._options.anchorY ?? 0;
        const anchorZ = this._options.anchorZ ?? 0;
        const minx = -anchorX * sizeX;
        const maxx = minx + sizeX;
        const miny = -anchorY * sizeY;
        const maxy = miny + sizeY;
        const minz = -anchorZ * sizeZ;
        const maxz = minz + sizeZ;
        const vertices = [];
        const indices = [];
        const normals = needNormal ? [] : null;
        const uvs = needUV ? [] : null;
        this._createArrays(vertices, normals, uvs, indices, minx, miny, minz, maxx, maxy, maxz);
        this.createAndSetVertexBuffer('position_f32x3', new Float32Array(vertices));
        normals && this.createAndSetVertexBuffer('normal_f32x3', new Float32Array(normals));
        uvs && this.createAndSetVertexBuffer('tex0_f32x2', new Float32Array(uvs));
        this.createAndSetIndexBuffer(new Uint16Array(indices));
        this.setBoundingVolume(new BoundingBox(new Vector3(minx, miny, minz), new Vector3(maxx, maxy, maxz)));
        this.indexCount = indices.length;
        return true;
    }
}
/**
 * Wireframe box shape
 * @public
 */ class BoxFrameShape extends Shape {
    /**
   * Creates an instance of wireframe box shape
   * @param options - The creation options
   */ constructor(options){
        super(options);
    }
    /** @internal */ createDefaultOptions() {
        const options = super.createDefaultOptions();
        options.size = 1;
        options.needNormal = false;
        options.needTangent = false;
        options.needUV = false;
        return options;
    }
    /** @internal */ _createArrays(vertices, indices, minx, miny, minz, maxx, maxy, maxz) {
        const topFacePos = [
            minx,
            maxy,
            minz,
            minx,
            maxy,
            maxz,
            maxx,
            maxy,
            maxz,
            maxx,
            maxy,
            minz
        ];
        const bottomFacePos = [
            minx,
            miny,
            maxz,
            minx,
            miny,
            minz,
            maxx,
            miny,
            minz,
            maxx,
            miny,
            maxz
        ];
        indices && indices.push(0, 1, 1, 2, 2, 3, 3, 0, 0, 5, 1, 4, 2, 7, 3, 6, 6, 5, 5, 4, 4, 7, 7, 6);
        vertices && vertices.push(...topFacePos, ...bottomFacePos);
        this.primitiveType = 'line-list';
    }
    /** @internal */ _create() {
        const sizeX = this._options.sizeX ?? this._options.size ?? 1;
        const sizeY = this._options.sizeY ?? this._options.size ?? 1;
        const sizeZ = this._options.sizeZ ?? this._options.size ?? 1;
        const anchorX = this._options.anchorX ?? 0;
        const anchorY = this._options.anchorY ?? 0;
        const anchorZ = this._options.anchorZ ?? 0;
        const minx = -anchorX * sizeX;
        const maxx = minx + sizeX;
        const miny = -anchorY * sizeY;
        const maxy = miny + sizeY;
        const minz = -anchorZ * sizeZ;
        const maxz = minz + sizeZ;
        const vertices = [];
        const indices = [];
        this._createArrays(vertices, indices, minx, miny, minz, maxx, maxy, maxz);
        this.createAndSetVertexBuffer('position_f32x3', new Float32Array(vertices));
        this.createAndSetIndexBuffer(new Uint16Array(indices));
        this.setBoundingVolume(new BoundingBox(new Vector3(minx, miny, minz), new Vector3(maxx, maxy, maxz)));
        this.indexCount = indices.length;
        return true;
    }
}

/**
 * Presents a transformation from one space to another
 * @public
 */ class XForm {
    /** @internal */ _parent;
    /** @internal */ _children;
    /** @internal */ _position;
    /** @internal */ _scaling;
    /** @internal */ _rotation;
    /** @internal */ _localMatrix;
    /** @internal */ _worldMatrix;
    /** @internal */ _worldMatrixDet;
    /** @internal */ _invWorldMatrix;
    /** @internal */ _tmpLocalMatrix;
    /** @internal */ _tmpWorldMatrix;
    /** @internal */ _transformTag;
    /**
   * Creates an instance of XForm
   */ constructor(){
        this._parent = null;
        this._children = [];
        const cb = ()=>{
            this._onTransformChanged(true);
        };
        this._position = new ObservableVector3(0, 0, 0);
        this._position.callback = cb;
        this._scaling = new ObservableVector3(1, 1, 1);
        this._scaling.callback = cb;
        this._rotation = new ObservableQuaternion();
        this._rotation.callback = cb;
        this._worldMatrix = null;
        this._worldMatrixDet = null;
        this._invWorldMatrix = null;
        this._localMatrix = null;
        this._transformTag = 0;
        this._tmpLocalMatrix = Matrix4x4.identity();
        this._tmpWorldMatrix = Matrix4x4.identity();
    }
    /** Parent of the xform */ get parent() {
        return this._parent;
    }
    set parent(p) {
        p = p || null;
        if (p !== this._parent) {
            this._setParent(p);
        }
    }
    /** Children of this xform */ get children() {
        return this._children;
    }
    /**
   * Resets the transformation matrix
   * @returns self
   */ resetTransform() {
        this._position.setXYZ(0, 0, 0);
        this._rotation.identity();
        this._scaling.setXYZ(1, 1, 1);
        return this;
    }
    /**
   * Position of the xform relative to it's parent
   */ get position() {
        return this._position;
    }
    set position(val) {
        this._position.setXYZ(val[0], val[1], val[2]);
    }
    worldToThis(v, result) {
        if (v instanceof Vector3) {
            result = result || new Vector3();
            this.invWorldMatrix.transformPointAffine(v, result);
            return result;
        } else {
            result = result || new Vector4();
            this.invWorldMatrix.transformAffine(v, result);
            return result;
        }
    }
    otherToThis(other, v, result) {
        return this.worldToThis(other.thisToWorld(v, result), result);
    }
    thisToWorld(v, result) {
        if (v instanceof Vector3) {
            result = result || new Vector3();
            this.worldMatrix.transformPointAffine(v, result);
            return result;
        } else {
            result = result || new Vector4();
            this.worldMatrix.transformAffine(v, result);
            return result;
        }
    }
    thisToOther(other, v, result) {
        return other.worldToThis(this.thisToWorld(v, result), result);
    }
    /**
   * Gets the position of the xform in world space
   * @returns position of the xform in world space
   */ getWorldPosition() {
        return new Vector3(this.worldMatrix.m03, this.worldMatrix.m13, this.worldMatrix.m23);
    }
    /**
   * Moves the xform by an offset vector
   * @param delta - The offset vector
   * @returns self
   */ moveBy(delta) {
        this._position.addBy(delta);
        return this;
    }
    /**
   * Scales the xform by a given scale factor
   * @param factor - The scale factor
   * @returns self
   */ scaleBy(factor) {
        this._scaling.mulBy(factor);
        return this;
    }
    /**
   * Scaling of the xform
   */ get scale() {
        return this._scaling;
    }
    set scale(val) {
        this._scaling.setXYZ(val[0], val[1], val[2]);
    }
    /**
   * Rotation of the xform
   */ get rotation() {
        return this._rotation;
    }
    set rotation(val) {
        this._rotation.setXYZW(val[0], val[1], val[2], val[3]);
    }
    /**
   * Sets the local transform matrix of the xform
   * @param m - The transform matrix to set
   * @returns self
   */ setLocalTransform(m) {
        m.decompose(this._scaling, this._rotation, this._position);
        return this;
    }
    /** Local transformation matrix of the xform */ get localMatrix() {
        if (!this._localMatrix) {
            this._localMatrix = this._tmpLocalMatrix;
            this._localMatrix.scaling(this._scaling).rotateLeft(new Matrix4x4(this._rotation)).translateLeft(this._position);
        }
        return this._localMatrix;
    }
    /** World transformation matrix of the xform */ get worldMatrix() {
        if (!this._worldMatrix) {
            this._worldMatrix = this._tmpWorldMatrix;
            if (this._parent) {
                Matrix4x4.multiplyAffine(this._parent.worldMatrix, this.localMatrix, this._worldMatrix);
            } else {
                this._worldMatrix.set(this.localMatrix);
            }
        }
        return this._worldMatrix;
    }
    /** The determinant of world matrix */ get worldMatrixDet() {
        if (this._worldMatrixDet === null) {
            this._worldMatrixDet = this.worldMatrix.det();
        }
        return this._worldMatrixDet;
    }
    /** Inverse of the world transformation matrix of the xform */ get invWorldMatrix() {
        if (!this._invWorldMatrix) {
            this._invWorldMatrix = Matrix4x4.invertAffine(this.worldMatrix);
        }
        return this._invWorldMatrix;
    }
    /**
   * Sets the local tranformation matrix by a look-at matrix
   * @param eye - The eye position used to make the look-at matrix
   * @param target - The target position used to make the look-at matrix
   * @param up - The up vector used to make the look-at matrix
   * @returns self
   */ lookAt(eye, target, up) {
        Matrix4x4.lookAt(eye, target, up).decompose(this._scaling, this._rotation, this._position);
        return this;
    }
    /**
   * Removes this node from it's parent and add this node to another parent node if required
   * @param p - The new parent node that this node should be added to or null
   * @returns self
   */ reparent(p) {
        this.parent = p;
        return this;
    }
    /** @internal */ getTag() {
        return this._transformTag;
    }
    /** @internal */ _onTransformChanged(invalidateLocal) {
        if (invalidateLocal) {
            this._localMatrix = null;
        }
        if (this._worldMatrix) {
            this._worldMatrix = null;
            this._invWorldMatrix = null;
            this._transformTag++;
            for (const child of this._children){
                child._onTransformChanged(false);
            }
        }
        this._worldMatrixDet = null;
    }
    /** @internal */ _setParent(p) {
        if (this._parent !== p) {
            if (this._parent) {
                this._parent._children.splice(this._parent._children.indexOf(this), 1);
            }
            this._parent = p;
            if (this._parent) {
                this._parent._children.push(this);
            }
            this._onTransformChanged(false);
        }
    }
}

/**
 * The base class for any kind of scene objects
 *
 * @remarks
 * We use a data structure called SceneGraph to store scenes,
 * which consists of a couple of scene objects forming a
 * hierarchical structure. This is the base class for any kind
 * of the scene object, which contains the basic properties such
 * as position, rotation, and scale of the object.
 *
 * @public
 */ class SceneNode extends XForm {
    static CLIP_INHERITED = -1;
    static CLIP_DISABLED = 0;
    static CLIP_ENABLED = 1;
    static SHOW_INHERITED = -1;
    static SHOW_HIDE = 0;
    static SHOW_DEFAULT = 1;
    static PICK_INHERITED = -1;
    static PICK_DISABLED = 0;
    static PICK_ENABLED = 1;
    static BBOXDRAW_INHERITED = -1;
    static BBOXDRAW_DISABLED = 0;
    static BBOXDRAW_LOCAL = 1;
    static BBOXDRAW_WORLD = 2;
    /** @internal */ _clipMode;
    /** @internal */ _renderOrder;
    /** @internal */ _boxDrawMode;
    /** @internal */ _visible;
    /** @internal */ _pickMode;
    /** @internal */ _name;
    /** @internal */ _scene;
    /** @internal */ _bv;
    /** @internal */ _bvDirty;
    /** @internal */ _bvWorld;
    /**
   * Creates a new scene node
   * @param scene - Which scene the node belongs to
   */ constructor(scene){
        super();
        this._scene = scene;
        this._name = '';
        this._bv = null;
        this._bvWorld = null;
        this._bvDirty = true;
        this._clipMode = SceneNode.CLIP_ENABLED;
        this._boxDrawMode = SceneNode.BBOXDRAW_DISABLED;
        this._visible = SceneNode.SHOW_INHERITED;
        this._pickMode = SceneNode.PICK_DISABLED;
        if (scene && this !== scene.rootNode) {
            this.reparent(scene.rootNode);
        }
    }
    /**
   * Name of the scene node
   */ get name() {
        return this._name;
    }
    set name(val) {
        this._name = val || '';
    }
    /** The scene to which the node belongs */ get scene() {
        return this._scene;
    }
    /** true if the node is attached to the scene node, false otherwise */ get attached() {
        return !!this._scene?.rootNode?.isParentOf(this);
    }
    /**
   * Check if given node is a direct child of the node
   * @param child - The node to be checked
   * @returns true if the given node is a direct child of this node, false otherwise
   */ hasChild(child) {
        return this._children.indexOf(child) >= 0;
    }
    /**
   * Removes all children from this node
   */ removeChildren() {
        while(this._children.length){
            this._children[0].remove();
        }
    }
    /**
   * Checks if this node is the direct parent or indirect parent of a given node
   * @param child - The node to be checked
   * @returns true if this node is the direct parent or indirect parent of the given node, false otherwise
   */ isParentOf(child) {
        while(child && child !== this){
            child = child.parent;
        }
        return child === this;
    }
    /**
   * Removes this node from it's parent
   * @returns self
   */ remove() {
        this.parent = null;
        return this;
    }
    /**
   * Traverse the entire subtree of this node by a visitor
   * @param v - The visitor that will travel the subtree of this node
   * @param inverse - true if traversing from bottom to top, otherwise top to bottom
   */ traverse(v, inverse) {
        if (inverse) {
            for(let i = this._children.length - 1; i >= 0; i--){
                this._children[i].traverse(v, inverse);
            }
            v.visit(this);
        } else {
            v.visit(this);
            for (const child of this._children){
                child.traverse(v);
            }
        }
    }
    /**
   * Iterate self and all of the children
   * @param callback - callback function that will be called on each node
   */ iterate(callback) {
        callback(this);
        for (const child of this._children){
            child.iterate(callback);
        }
    }
    /** true if this is a graph node, false otherwise */ isGraphNode() {
        return false;
    }
    /** true if this is a light node, false otherwise */ isLight() {
        return false;
    }
    /** true if this is a mesh node, false otherwise */ isMesh() {
        return false;
    }
    /** true if this is a terrain node, false otherwise */ isTerrain() {
        return false;
    }
    /** true if this is a camera node, false otherwise */ isCamera() {
        return false;
    }
    /** true if this is a punctual light node, false otherwise */ isPunctualLight() {
        return false;
    }
    /** Disposes the node */ dispose() {
        this.remove();
        this.removeChildren();
    }
    /**
   * Computes the bounding volume of the node
   * @param bv - The output bounding volume
   * @returns The output bounding volume
   */ computeBoundingVolume(bv) {
        return bv;
    }
    /**
   * Gets the bounding volume of the node
   * @returns The bounding volume of the node
   */ getBoundingVolume() {
        if (this._bvDirty) {
            this._bv = this.computeBoundingVolume(this._bv) || null;
            this._bvDirty = false;
        }
        return this._bv;
    }
    /**
   * Sets the bounding volume of the node
   * @param bv - The bounding volume to set
   */ setBoundingVolume(bv) {
        if (bv !== this._bv) {
            this._bv = bv;
            this.invalidateBoundingVolume();
        }
    }
    /**
   * Gets the world space bounding volume of the node
   * @returns The world space bounding volume of the node
   */ getWorldBoundingVolume() {
        if (!this._bvWorld) {
            this._bvWorld = this.getBoundingVolume()?.transform(this.worldMatrix) ?? null;
        }
        return this._bvWorld;
    }
    /**
   * Force the bounding volume to be recalculated
   */ invalidateBoundingVolume() {
        this._bvDirty = true;
        this.invalidateWorldBoundingVolume();
    }
    /** Force the world space bounding volume to be recalculated */ invalidateWorldBoundingVolume() {
        this._bvWorld = null;
        this._scene?.invalidateNodePlacement(this);
    }
    /**
   * Computed value of clip mode
   */ get computedClipMode() {
        if (this._clipMode === SceneNode.CLIP_INHERITED) {
            let parent = this.parent;
            while(parent && !parent.isGraphNode()){
                parent = parent.parent;
            }
            return parent?.computedClipMode ?? SceneNode.CLIP_ENABLED;
        }
        return this._clipMode;
    }
    /** Clip mode */ get clipMode() {
        return this._clipMode;
    }
    set clipMode(val) {
        this._clipMode = val;
    }
    /** Computed value of show state */ get hidden() {
        let node = this;
        while(node && node._visible === SceneNode.SHOW_INHERITED){
            node = node.parent;
        }
        return node ? node._visible === SceneNode.SHOW_HIDE : false;
    }
    /** Show state */ get showState() {
        return this._visible;
    }
    set showState(val) {
        if (val !== this._visible) {
            const prevHidden = this.hidden;
            this._visible = val;
            if (prevHidden !== this.hidden) {
                this.notifyHiddenChanged();
            }
        }
    }
    /** Computed value of pick mode */ get pickable() {
        let node = this;
        while(node && node._pickMode === SceneNode.PICK_INHERITED){
            node = node.parent;
        }
        return node ? node._pickMode === SceneNode.PICK_ENABLED : false;
    }
    /** Pick mode */ get pickMode() {
        return this._pickMode;
    }
    set pickMode(val) {
        this._pickMode = val;
    }
    /** Computed value for bounding box draw mode */ get computedBoundingBoxDrawMode() {
        if (this._boxDrawMode === SceneNode.BBOXDRAW_INHERITED) {
            let parent = this.parent;
            while(parent && !parent.isGraphNode()){
                parent = parent.parent;
            }
            return parent?.computedBoundingBoxDrawMode ?? SceneNode.BBOXDRAW_DISABLED;
        }
        return this._boxDrawMode;
    }
    /** Bounding box draw mode */ get boundingBoxDrawMode() {
        return this._boxDrawMode;
    }
    set boundingBoxDrawMode(mode) {
        this._boxDrawMode = mode;
    }
    /** @internal */ _setParent(p) {
        if (p !== this._parent) {
            const sceneLast = this.attached ? this.scene : null;
            const sceneNew = p?.attached ? p.scene : null;
            const willDetach = sceneLast && sceneLast !== sceneNew;
            const willAttach = sceneNew && sceneLast !== sceneNew;
            willDetach && this._willDetach();
            willAttach && this._willAttach();
            super._setParent(p);
            willDetach && this._detached();
            willAttach && this._attached();
        }
    }
    /** @internal */ _onTransformChanged(invalidateLocal) {
        super._onTransformChanged(invalidateLocal);
        this.invalidateWorldBoundingVolume();
    }
    /** @internal */ _willAttach() {}
    /** @internal */ _attached() {}
    /** @internal */ _willDetach() {}
    /** @internal */ _detached() {}
    /** @internal */ notifyHiddenChanged() {
        this._visibleChanged();
        for (const child of this._children){
            if (child.showState === SceneNode.SHOW_INHERITED) {
                child.notifyHiddenChanged();
            }
        }
    }
    /** @internal */ _visibleChanged() {}
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
/**
 * Graph scene node
 *
 * @remarks
 * Graph node is the base class of any kind of scene node that will be placed into the octree
 *
 * @public
 */ class GraphNode extends SceneNode {
    /**
   * Creates a graph node
   * @param scene - The scene to which the node belongs
   */ constructor(scene){
        super(scene);
        this._renderOrder = 0;
    }
    /**
   * Render order of the node
   */ get renderOrder() {
        return this._renderOrder;
    }
    set renderOrder(val) {
        this._renderOrder = val;
    }
    /** Gets the name */ getName() {
        return this._name;
    }
    /**
   * {@inheritDoc SceneNode.isGraphNode}
   * @override
   */ isGraphNode() {
        return true;
    }
    /**
   * {@inheritDoc Drawable.getXForm}
   */ getXForm() {
        return this;
    }
    /**
   * {@inheritDoc Drawable.getBoneMatrices}
   */ getBoneMatrices() {
        return null;
    }
    /**
   * {@inheritDoc Drawable.getInvBindMatrix}
   */ getInvBindMatrix() {
        return null;
    }
    /**
   * {@inheritDoc Drawable.getSortDistance}
   */ getSortDistance(camera) {
        const cameraWorldMatrix = camera.worldMatrix;
        const objectWorldMatrix = this.worldMatrix;
        const dx = cameraWorldMatrix.m03 - objectWorldMatrix.m03;
        const dy = cameraWorldMatrix.m13 - objectWorldMatrix.m13;
        const dz = cameraWorldMatrix.m23 - objectWorldMatrix.m23;
        return dx * dx + dy * dy * dz * dz;
    }
    /**
   * {@inheritDoc Drawable.isBatchable}
   */ isBatchable() {
        return false;
    }
    /** @internal */ _visibleChanged() {
        this._scene?.invalidateNodePlacement(this);
    }
}

var OctreePlacement;
(function(OctreePlacement) {
    OctreePlacement[OctreePlacement["PPP"] = 0] = "PPP";
    OctreePlacement[OctreePlacement["PPN"] = 1] = "PPN";
    OctreePlacement[OctreePlacement["PNP"] = 2] = "PNP";
    OctreePlacement[OctreePlacement["PNN"] = 3] = "PNN";
    OctreePlacement[OctreePlacement["NPP"] = 4] = "NPP";
    OctreePlacement[OctreePlacement["NPN"] = 5] = "NPN";
    OctreePlacement[OctreePlacement["NNP"] = 6] = "NNP";
    OctreePlacement[OctreePlacement["NNN"] = 7] = "NNN";
})(OctreePlacement || (OctreePlacement = {}));
/**
 * Octree node
 * @public
 */ class OctreeNode {
    /** @internal */ _chunk;
    /** @internal */ _position;
    /** @internal */ _references;
    /** @internal */ _nodes;
    /** @internal */ _box;
    /** @internal */ _boxLoosed;
    /**
   * Creates an instance of octree node
   */ constructor(){
        this._chunk = null;
        this._position = 0;
        this._references = 0;
        this._nodes = [];
        this._box = null;
        this._boxLoosed = null;
    }
    /**
   * Get all the scene nodes that this octree node contains
   * @returns An array of the scene nodes
   */ getNodes() {
        return this._nodes;
    }
    /**
   * Gets the level index of the octree node
   * @returns The level index
   */ getLevel() {
        return this._chunk.getLevel();
    }
    /**
   * Adds a scene node to this node
   * @param node - The scene node to be added
   */ addNode(node) {
        if (node && this._nodes.indexOf(node) < 0) {
            this._nodes.push(node);
        }
    }
    /**
   * Removes a scene node from this node
   * @param node - The scene node to be removed
   */ removeNode(node) {
        const index = this._nodes.indexOf(node);
        if (index >= 0) {
            this._nodes.splice(index, 1);
        }
    }
    /** Removes all the scene nodes that this octree node contains */ clearNodes() {
        this._nodes = [];
    }
    /**
   * Sets the octree chunk
   * @param chunk - The octree chunk to be set
   */ setChunk(chunk) {
        console.assert(!!chunk, 'Invalid chunk');
        this._chunk = chunk;
    }
    /**
   * Gets the octree chunk
   * @returns The octree chunk
   */ getChunk() {
        return this._chunk;
    }
    /**
   * Sets the position of the node
   * @param index - Position of the node
   */ setPosition(index) {
        this._position = index;
    }
    /**
   * Gets the position of the octree node
   * @returns Position of the octree node
   */ getPosition() {
        return this._position;
    }
    /**
   * Invalidates the cached box
   */ invalidateBox() {
        this._box = null;
        this.getParent()?.invalidateBox();
    }
    /**
   * Get the bounding box of the octree node
   * @returns The bounding box of the octree node
   */ getBox() {
        if (this._box === null) {
            const box = new AABB();
            box.beginExtend();
            for(let i = 0; i < 8; i++){
                const child = this.getChild(i);
                if (child) {
                    const childBox = child.getBox();
                    if (childBox) {
                        box.extend(childBox.minPoint);
                        box.extend(childBox.maxPoint);
                    }
                }
            }
            for (const node of this._nodes){
                if (!node.isLight()) {
                    const bv = node.getWorldBoundingVolume()?.toAABB();
                    if (bv) {
                        box.extend(bv.minPoint);
                        box.extend(bv.maxPoint);
                    }
                }
            }
            if (box.isValid()) {
                this._box = box;
            }
        }
        return this._box;
    }
    /**
   * Gets the loosed bounding box of the node
   * @returns The loosed bounding box of the node
   */ getBoxLoosed() {
        if (this._boxLoosed === null) {
            console.assert(!!this._chunk, 'Invalid chunk');
            const d = this._chunk.getDimension();
            const nodeSize = this._chunk.getNodeSize();
            const halfWorldSize = this._chunk.getWorldSize() * 0.5;
            const px = this._position % d;
            const py = Math.floor(this._position / d) % d;
            const pz = Math.floor(Math.floor(this._position / d) / d);
            const minPoint = new Vector3(px - 0.5, py - 0.5, pz - 0.5).scaleBy(nodeSize).subBy(new Vector3(halfWorldSize, halfWorldSize, halfWorldSize));
            const maxPoint = new Vector3(minPoint.x + nodeSize * 2, minPoint.y + nodeSize * 2, minPoint.z + nodeSize * 2);
            this._boxLoosed = new AABB(minPoint, maxPoint);
        }
        return this._boxLoosed;
    }
    /**
   * Gets min point of the node
   * @returns Min point of the node
   */ getMinPoint() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const d = this._chunk.getDimension();
        const nodeSize = this._chunk.getNodeSize();
        const halfWorldSize = this._chunk.getWorldSize() * 0.5;
        const px = this._position % d;
        const py = Math.floor(this._position / d) % d;
        const pz = Math.floor(Math.floor(this._position / d) / d);
        return new Vector3(px, py, pz).scaleBy(nodeSize).subBy(new Vector3(halfWorldSize, halfWorldSize, halfWorldSize));
    }
    /**
   * Gets max point of the node
   * @returns Max point of the node
   */ getMaxPoint() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const d = this._chunk.getDimension();
        const nodeSize = this._chunk.getNodeSize();
        const halfWorldSize = this._chunk.getWorldSize() * 0.5;
        const px = this._position % d + 1;
        const py = Math.floor(this._position / d) % d + 1;
        const pz = Math.floor(Math.floor(this._position / d) / d) + 1;
        return new Vector3(px, py, pz).scaleBy(nodeSize).subBy(new Vector3(halfWorldSize, halfWorldSize, halfWorldSize));
    }
    /**
   * Gets the loosed min point of the node
   * @returns Loosed min point of the node
   */ getMinPointLoosed() {
        const halfNodeSize = this._chunk.getNodeSize() * 0.5;
        return this.getMinPoint().subBy(new Vector3(halfNodeSize, halfNodeSize, halfNodeSize));
    }
    /**
   * Gets the loosed max point of the node
   * @returns Loosed max point of the node
   */ getMaxPointLoosed() {
        const halfNodeSize = this._chunk.getNodeSize() * 0.5;
        return this.getMaxPoint().addBy(new Vector3(halfNodeSize, halfNodeSize, halfNodeSize));
    }
    /**
   * Get reference of the node
   * @returns Reference of the node
   */ getReference() {
        return this._references;
    }
    /**
   * Gets the child node by a given placement
   * @param placement - The placement
   * @returns Child node at the given placement
   */ getChild(placement) {
        console.assert(!!this._chunk, 'Invalid chunk');
        const next = this._chunk.getNext();
        return next ? next.getNode(this._chunk.getChildIndex(this._position, placement)) : null;
    }
    /**
   * Gets or creates a child node by a given placement
   * @param placement - The placement
   * @returns The child node fetched
   */ getOrCreateChild(placement) {
        console.assert(!!this._chunk, 'Invalid chunk');
        const next = this._chunk.getNext();
        return next ? next.getOrCreateNode(this._chunk.getChildIndex(this._position, placement)) : null;
    }
    /**
   * Gets parent of the node
   * @returns Parent of the node
   */ getParent() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const prev = this._chunk.getPrev();
        return prev ? prev.getNode(this._chunk.getParentIndex(this._position)) : null;
    }
    /**
   * Gets or creates the parent node
   * @returns The parent node
   */ getOrCreateParent() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const prev = this._chunk.getPrev();
        return prev ? prev.getOrCreateNode(this._chunk.getParentIndex(this._position)) : null;
    }
    /**
   * Creates all children of this node
   */ createChildren() {
        this.getOrCreateChild(OctreePlacement.PPP);
        this.getOrCreateChild(OctreePlacement.PPN);
        this.getOrCreateChild(OctreePlacement.PNP);
        this.getOrCreateChild(OctreePlacement.PNN);
        this.getOrCreateChild(OctreePlacement.NPP);
        this.getOrCreateChild(OctreePlacement.NPN);
        this.getOrCreateChild(OctreePlacement.NNP);
        this.getOrCreateChild(OctreePlacement.NNN);
    }
    /**
   * Free up all empty children
   * @returns true if some children were freed
   */ tidy() {
        this._references = 8;
        for(let i = 0; i < 8; i++){
            const node = this.getChild(i);
            if (!node || node.tidy()) {
                --this._references;
            }
        }
        if (this._nodes.length === 0 && this._references === 0) {
            this._chunk.freeNodeByIndex(this._position);
            return true;
        }
        return false;
    }
    /**
   * Traverse this node by a visitor
   * @param v - The visitor
   */ traverse(v) {
        if (v.visit(this)) {
            for(let i = 0; i < 8; i++){
                const child = this.getChild(i);
                if (child) {
                    child.traverse(v);
                }
            }
        }
    }
}
/**
 * Octree node chunk
 * @public
 */ class OctreeNodeChunk {
    /** @internal */ _level;
    /** @internal */ _dimension;
    /** @internal */ _nodeSize;
    /** @internal */ _prev;
    /** @internal */ _next;
    /** @internal */ _octree;
    /** @internal */ _nodeMap;
    /**
   * Creates an instance of octree chunk
   * @param octree - Octree to which the chunk belongs
   */ constructor(octree){
        this._octree = octree;
        this._level = 0;
        this._dimension = 0;
        this._nodeSize = 0;
        this._next = null;
        this._prev = null;
        this._nodeMap = new Map();
    }
    /**
   * Gets an octree node at a given index
   * @param index - Index of the node
   * @returns The octree node
   */ getNode(index) {
        return this._nodeMap.get(index) || null;
    }
    /**
   * Gets or creates an octree node at a given index
   * @param index - Index of the node
   * @returns The octree node
   */ getOrCreateNode(index) {
        let node = this.getNode(index);
        if (!node) {
            node = new OctreeNode();
            node.setChunk(this);
            node.setPosition(index);
            this._nodeMap.set(index, node);
        }
        return node;
    }
    /**
   * Gets or creates an octree node chain at a given index
   * @param index - Index of the head node
   * @returns The head node of the chain
   */ getOrCreateNodeChain(index) {
        const node = this.getOrCreateNode(index);
        if (this._prev) {
            this._prev.getOrCreateNodeChain(this.getParentIndex(index));
        }
        return node;
    }
    /**
   * Removes an octree node at given index
   * @param index - Index of the node
   */ freeNodeByIndex(index) {
        const node = this._nodeMap.get(index);
        if (node) {
            node.clearNodes();
            this._nodeMap.delete(index);
        }
    }
    /**
   * Removes an octree node
   * @param node - The octree node to be removed
   */ freeNode(node) {
        if (node) {
            console.assert(node.getChunk() === this, 'Invalid chunk');
            this.freeNodeByIndex(node.getPosition());
        }
    }
    /**
   * Removes all octree nodes of this chunk
   */ clearNodes() {
        for (const key of this._nodeMap.keys()){
            this._nodeMap.get(key).clearNodes();
            this._nodeMap.delete(key);
        }
    }
    /**
   * Gets the index of a child node at given placement
   * @param index - Index of the parent node
   * @param placement - The placement
   * @returns Index of the child
   */ getChildIndex(index, placement) {
        const dim = this._dimension;
        let px = 2 * (index % dim);
        let py = 2 * (Math.floor(index / dim) % dim);
        let pz = 2 * Math.floor(Math.floor(index / dim) / dim);
        switch(placement){
            case OctreePlacement.PPP:
                ++px;
                ++py;
                ++pz;
                break;
            case OctreePlacement.PPN:
                ++px;
                ++py;
                break;
            case OctreePlacement.PNP:
                ++px;
                ++pz;
                break;
            case OctreePlacement.PNN:
                ++px;
                break;
            case OctreePlacement.NPP:
                ++py;
                ++pz;
                break;
            case OctreePlacement.NPN:
                ++py;
                break;
            case OctreePlacement.NNP:
                ++pz;
                break;
            case OctreePlacement.NNN:
                break;
            default:
                console.assert(false, 'getChildIndex: Got invalid index');
                return 0;
        }
        const dimension2 = 2 * dim;
        return pz * dimension2 * dimension2 + py * dimension2 + px;
    }
    /**
   * Gets the index of the parent node
   * @param index - Index of the child node
   * @returns Index of the parent node
   */ getParentIndex(index) {
        const dim = this._dimension;
        const px = index % dim >> 1;
        const py = Math.floor(index / dim) % dim >> 1;
        const pz = Math.floor(Math.floor(index / dim) / dim) >> 1;
        const d = dim >> 1;
        return px + py * d + pz * d * d;
    }
    /**
   * Gets the size of the node in this chunk
   * @returns The size of the node in this chunk
   */ getNodeSize() {
        return this._nodeSize;
    }
    /**
   * Gets the root size of the octree
   * @returns The root size of the octree
   */ getWorldSize() {
        return this._octree.getRootSize();
    }
    /**
   * Gets the dimension of this chunk
   * @returns Dimension of this chunk
   */ getDimension() {
        return this._dimension;
    }
    /**
   * Gets the level index of this chunk
   * @returns Level index of this chunk
   */ getLevel() {
        return this._level;
    }
    /**
   * Check if this chunk is empty
   * @returns true if this chunk is empty, otherwise false
   */ empty() {
        return this._nodeMap.size === 0;
    }
    /**
   * Gets the chunk next to this chunk
   * @returns The next chunk
   */ getNext() {
        return this._next;
    }
    /**
   * Gets the chunk previous to this chunk
   * @returns The previous chunk
   */ getPrev() {
        return this._prev;
    }
    /**
   * Gets the octree that the chunk belongs to
   * @returns The octree
   */ getOctree() {
        return this._octree;
    }
    /**
   * Sets the level index of this chunk
   * @param level - The level index to set
   */ setLevel(level) {
        this._level = level;
    }
    /**
   * Sets the dimension of this chunk
   * @param dimension - The dimension to set
   */ setDimension(dimension) {
        this._dimension = dimension;
    }
    /**
   * Sets the size of octree node in this chunk
   * @param size - The node size to set
   */ setNodeSize(size) {
        this._nodeSize = size;
    }
    /**
   * Sets the next chunk
   * @param chunk - The chunk to set
   */ setNext(chunk) {
        this._next = chunk;
    }
    /**
   * Sets the previous chunk
   * @param chunk - The chunk to set
   */ setPrev(chunk) {
        this._prev = chunk;
    }
}
/**
 * Octree class
 * @public
 */ class Octree {
    /** @internal */ _scene;
    /** @internal */ _chunks;
    /** @internal */ _rootSize;
    /** @internal */ _leafSize;
    /** @internal */ _rootNode;
    /** @internal */ _nodeMap;
    /**
   * Creates an instance of octree
   * @param scene - The scene to which the octree belongs
   * @param rootSize - Root size of the octre
   * @param leafSize - Leaf size of the octree
   */ constructor(scene, rootSize = 4096, leafSize = 64){
        this._scene = scene;
        this._chunks = [];
        this._rootSize = 0;
        this._leafSize = 0;
        this._rootNode = null;
        this._nodeMap = new WeakMap();
        this.initialize(rootSize, leafSize);
    }
    /**
   * Initialize the octree with specified root size and leaf size
   * @param rootSize - Root size of the octree
   * @param leafSize - Leaf size of the octree
   */ initialize(rootSize, leafSize) {
        console.assert(rootSize >= leafSize && leafSize > 0, 'Invalid rootSize or leafSize for octree');
        this.finalize();
        this._rootSize = rootSize;
        this._leafSize = leafSize;
        let n = 1;
        for(; rootSize >= leafSize * 2; leafSize *= 2, ++n);
        for(let i = 0; i < n; ++i, rootSize *= 0.5){
            const chunk = new OctreeNodeChunk(this);
            chunk.setLevel(i);
            chunk.setNodeSize(rootSize);
            chunk.setDimension(1 << i);
            this._chunks.push(chunk);
            if (i > 0) {
                this._chunks[i - 1].setNext(chunk);
                chunk.setPrev(this._chunks[i - 1]);
            }
        }
    }
    /** Free up the octree */ finalize() {
        this._chunks = [];
        this._rootSize = 0;
        this._leafSize = 0;
        this._rootNode = null;
        this._nodeMap = new WeakMap();
    }
    /**
   * Gets the scene to which the octree belongs
   * @returns The scene
   */ getScene() {
        return this._scene;
    }
    /**
   * Gets the root size of the octree
   * @returns The root size of the octree
   */ getRootSize() {
        return this._rootSize;
    }
    /**
   * Gets the leaf size of the octree
   * @returns The leaf size of the octree
   */ getLeafSize() {
        return this._leafSize;
    }
    /**
   * Locates a node chain in the octree by a sphere
   * @param candidate - The candidate node
   * @param center - center of the sphere
   * @param radius - radius of the sphere
   * @returns Head node of the located node chain
   */ locateNodeChain(candidate, center, radius) {
        let level = this._chunks.length - 1;
        while(level && this._chunks[level].getNodeSize() < 4 * radius){
            --level;
        }
        const dim = this._chunks[level].getDimension();
        const inv_node_size = 1 / this._chunks[level].getNodeSize();
        let px = Math.floor((center.x + this._rootSize * 0.5) * inv_node_size);
        let py = Math.floor((center.y + this._rootSize * 0.5) * inv_node_size);
        let pz = Math.floor((center.z + this._rootSize * 0.5) * inv_node_size);
        if (px >= dim || py >= dim || pz >= dim) {
            level = 0;
            px = 0;
            py = 0;
            pz = 0;
        }
        const index = px + py * dim + pz * dim * dim;
        if (candidate && candidate.getChunk().getLevel() === level && candidate.getPosition() === index) {
            return candidate;
        }
        return this._chunks[level].getOrCreateNodeChain(index);
    }
    /**
   * Gets the root node of the octree
   * @returns Root node of the octree
   */ getRootNode() {
        if (!this._rootNode) {
            this._rootNode = this._chunks[0].getOrCreateNode(0);
        }
        return this._rootNode;
    }
    /**
   * Gets the number of chunks in the octree
   * @returns The number of chunks in the octree
   */ getNumChunks() {
        return this._chunks.length;
    }
    /**
   * Gets the chunk by a given index
   * @param level - The chunk index
   * @returns The chunk at given index
   */ getChunk(level) {
        return this._chunks[level];
    }
    /**
   * Place a scene node into the octree
   * @param node - The scene node to be placed
   */ placeNode(node) {
        const curNode = this._nodeMap.get(node) || null;
        let locatedNode = this.getRootNode();
        if (node.computedClipMode === GraphNode.CLIP_ENABLED) {
            const bbox = node.getWorldBoundingVolume()?.toAABB();
            if (bbox && bbox.isValid()) {
                const center = bbox.center;
                const extents = bbox.extents;
                const size = Math.max(Math.max(extents.x, extents.y), extents.z);
                locatedNode = this.locateNodeChain(curNode, center, size) || this.getRootNode();
            }
        }
        if (curNode !== locatedNode) {
            curNode?.removeNode(node);
            locatedNode?.addNode(node);
            this._nodeMap.set(node, locatedNode);
            curNode?.invalidateBox();
            locatedNode?.invalidateBox();
        }
    }
    /**
   * Removes a scene node from the octree
   * @param node - The scene node to be removed
   */ removeNode(node) {
        if (node.isGraphNode()) {
            const curNode = this._nodeMap.get(node) || null;
            if (curNode) {
                curNode.removeNode(node);
                curNode.invalidateBox();
                this._nodeMap.delete(node);
            }
        }
    }
}

/**
 * Forward render pass type
 * @public
 */ const RENDER_PASS_TYPE_LIGHT = 0;
/**
 * Shadow map render pass type
 * @public
 */ const RENDER_PASS_TYPE_SHADOWMAP = 1;
/**
 * Depth only render pass type
 * @public
 */ const RENDER_PASS_TYPE_DEPTH = 2;
/**
 * Builtin texture name for sheen LUT
 * @public
 */ const BUILTIN_ASSET_TEXTURE_SHEEN_LUT = 'LUT_Sheen';
/**
 * Builtin cube texture for test
 * @public
 */ const BUILTIN_ASSET_TEST_CUBEMAP = 'TEST_Cubemap';
/**
 * No light
 * @public
 */ const LIGHT_TYPE_NONE = 0;
/**
 * Directional light type
 * @public
 */ const LIGHT_TYPE_DIRECTIONAL = 1;
/**
 * Point light type
 * @public
 */ const LIGHT_TYPE_POINT = 2;
/**
 * Spot light type
 * @public
 */ const LIGHT_TYPE_SPOT = 3;
/**
 * Max light size for clustered lighting
 * @public
 */ const MAX_CLUSTERED_LIGHTS = 255;
/**
 * Opaque render queue type
 * @public
 */ const QUEUE_OPAQUE = 1;
/**
 * Transparent render queue type
 * @public
 */ const QUEUE_TRANSPARENT = 2;

/**
 * Node visitor for culling
 * @public
 */ class CullVisitor {
    /** @internal */ _primaryCamera;
    /** @internal */ _camera;
    /** @internal */ _skipClipTest;
    /** @internal */ _renderQueue;
    /** @internal */ _renderPass;
    /**
   * Creates an instance of CullVisitor
   * @param renderPass - Render pass for the culling task
   * @param camera - Camera that will be used for culling
   * @param rendeQueue - RenderQueue
   * @param viewPoint - Camera position of the primary render pass
   */ constructor(renderPass, camera, renderQueue, primaryCamera){
        this._primaryCamera = primaryCamera;
        this._camera = camera;
        this._renderQueue = renderQueue;
        this._skipClipTest = false;
        this._renderPass = renderPass;
    }
    /** The camera that will be used for culling */ get camera() {
        return this._camera;
    }
    set camera(camera) {
        this._camera = camera || null;
    }
    /** The camera position of the primary render pass */ get primaryCamera() {
        return this._primaryCamera;
    }
    /** Render pass for the culling task */ get renderPass() {
        return this._renderPass;
    }
    /** The result of culling */ get renderQueue() {
        return this._renderQueue;
    }
    /** Frustum for culling */ get frustum() {
        return this._camera?.frustum || null;
    }
    /** @internal */ push(camera, drawable, renderOrder) {
        this.renderQueue.push(camera, drawable, renderOrder);
    }
    /**
   * Visits a node
   * @param target - The node to be visit
   */ visit(target) {
        if (target instanceof OctreeNode) {
            return this.visitOctreeNode(target);
        } else if (target.isMesh()) {
            return this.visitMesh(target);
        } else if (target.isTerrain()) {
            return this.visitTerrain(target);
        } else if (target.isPunctualLight()) {
            return this.visitPunctualLight(target);
        }
    }
    /** @internal */ visitPunctualLight(node) {
        if (!node.hidden) {
            const clipState = this.getClipStateWithNode(node);
            if (clipState !== ClipState.NOT_CLIPPED) {
                this.renderQueue.pushLight(node);
                return true;
            }
        }
        return false;
    }
    /** @internal */ visitTerrain(node) {
        if (!node.hidden && (node.castShadow || this._renderPass.type !== RENDER_PASS_TYPE_SHADOWMAP)) {
            const clipState = this.getClipStateWithNode(node);
            if (clipState !== ClipState.NOT_CLIPPED) {
                return node.cull(this) > 0;
            }
        }
        return false;
    }
    /** @internal */ visitMesh(node) {
        if (!node.hidden && (node.castShadow || this._renderPass.type !== RENDER_PASS_TYPE_SHADOWMAP)) {
            const clipState = this.getClipStateWithNode(node);
            if (clipState !== ClipState.NOT_CLIPPED) {
                this.push(this._camera, node, node.renderOrder);
                return true;
            }
        }
        return false;
    }
    /** @internal */ visitOctreeNode(node) {
        const clipState = node.getLevel() > 0 ? this.getClipStateWithAABB(node.getBoxLoosed()) : ClipState.CLIPPED;
        if (clipState !== ClipState.NOT_CLIPPED) {
            const saveSkipFlag = this._skipClipTest;
            this._skipClipTest = clipState === ClipState.A_INSIDE_B;
            const nodes = node.getNodes();
            for(let i = 0; i < nodes.length; i++){
                this.visit(nodes[i]);
            }
            this._skipClipTest = saveSkipFlag;
            return true;
        }
        return false;
    }
    /** @internal */ getClipStateWithNode(node) {
        let clipState;
        if (this._skipClipTest) {
            clipState = ClipState.A_INSIDE_B;
        } else if (node.computedClipMode === GraphNode.CLIP_DISABLED) {
            clipState = ClipState.CLIPPED;
        } else {
            const bv = node.getWorldBoundingVolume();
            clipState = bv ? this.getClipStateWithAABB(bv.toAABB()) : ClipState.CLIPPED;
        }
        return clipState;
    }
    /** @internal */ getClipStateWithAABB(aabb) {
        return this.camera.clipMask ? aabb.getClipStateWithFrustumMask(this.frustum, this.camera.clipMask) : aabb.getClipStateWithFrustum(this.frustum);
    }
}

class ScatteringLut {
    static _groundAlbedo = 1.0;
    static _groundRadiusMM = 6.36;
    static _atmosphereRadiusMM = 6.46;
    static _scatteringSteps = 32;
    static _sunTransmittanceSteps = 40;
    static _rayleighScatteringBase = [
        5.802,
        13.558,
        33.1
    ];
    static _rayleighAbsorptionBase = 0;
    static _mieScatteringBase = 3.996;
    static _mieAbsorptionBase = 4.4;
    static _ozoneAbsorptionBase = [
        0.65,
        1.881,
        0.085
    ];
    static _multiScatteringSteps = 20;
    static _sqrtSamples = 8;
    static _transmittanceLutWidth = 256;
    static _transmittanceLutHeight = 64;
    static _multiScatteringLutWidth = 32;
    static _multiScatteringLutHeight = 32;
    static _skyViewLutWidth = 256;
    static _skyViewLutHeight = 256;
    static _vertexLayout = null;
    static _renderStates = null;
    static _programTransmittanceLut = null;
    static _bindgroupTransmittanceLut = null;
    static _programMultiScatteringLut = null;
    static _bindgroupMultiScatteringLut = null;
    static _programSkyViewLut = null;
    static _bindgroupSkyViewLut = null;
    static _transmittanceLut = null;
    static _multiScatteringLut = null;
    static _skyViewFramebuffer = null;
    static _programAerialPerspectiveLut = null;
    static _bindgroupAerialPerspectiveLut = null;
    static _aerialPerspectiveLut = null;
    static _currentSkyViewSunAltitude = 0;
    static _currentAerialPerspectiveAltitude = 0;
    static _currentMaxAerialPerspectiveDistance = 800;
    static _aerialPerspectiveSliceX = 32;
    static _aerialPerspectiveSliceY = 32;
    static _aerialPerspectiveSliceZ = 32;
    static _aerialPerspectiveTextureWidth = this._aerialPerspectiveSliceX * this._aerialPerspectiveSliceZ;
    static _aerialPerspectiveTextureHeight = this._aerialPerspectiveSliceY;
    static _viewPos = new Vector3(0.0, this._groundRadiusMM + 0.00005, 0.0);
    static get aerialPerspectiveSliceZ() {
        return this._aerialPerspectiveSliceZ;
    }
    static get groundRadius() {
        return this._groundRadiusMM;
    }
    static get atmosphereRadius() {
        return this._atmosphereRadiusMM;
    }
    static get viewPosition() {
        return this._viewPos;
    }
    static getMultiScatteringLut() {
        const device = Application.instance.device;
        if (!this._multiScatteringLut) {
            this.prepare(device);
            const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
            this._multiScatteringLut = device.createTexture2D(format, this._multiScatteringLutWidth, this._multiScatteringLutHeight, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            this._multiScatteringLut.name = 'MultiScatteringLUT';
            const tLut = this.getTransmittanceLut();
            const tempFramebuffer = device.createFrameBuffer([
                this._multiScatteringLut
            ], null);
            device.pushDeviceStates();
            device.setFramebuffer(tempFramebuffer);
            device.setProgram(this._programMultiScatteringLut);
            device.setBindGroup(0, this._bindgroupMultiScatteringLut);
            this._bindgroupMultiScatteringLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this._bindgroupMultiScatteringLut.setTexture('tLut', tLut);
            this.drawQuad(device);
            device.popDeviceStates();
            tempFramebuffer.dispose();
        }
        return this._multiScatteringLut;
    }
    static getAerialPerspectiveLut(sunAltitude, maxDistance) {
        const device = Application.instance.device;
        if (sunAltitude !== this._currentAerialPerspectiveAltitude || maxDistance !== this._currentMaxAerialPerspectiveDistance || !this._aerialPerspectiveLut) {
            if (!this._aerialPerspectiveLut) {
                const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
                if (!this._aerialPerspectiveLut) {
                    this._aerialPerspectiveLut = device.createTexture2D(format, this._aerialPerspectiveTextureWidth, this._aerialPerspectiveTextureHeight, {
                        samplerOptions: {
                            mipFilter: 'none'
                        }
                    });
                    this._aerialPerspectiveLut.name = 'AerialPerspectiveLUT';
                }
            }
            const fb = device.createFrameBuffer([
                this._aerialPerspectiveLut
            ], null);
            const tLut = this.getTransmittanceLut();
            const msLut = this.getMultiScatteringLut();
            this._currentAerialPerspectiveAltitude = sunAltitude;
            this._currentMaxAerialPerspectiveDistance = maxDistance;
            device.pushDeviceStates();
            device.setFramebuffer(fb);
            device.setProgram(this._programAerialPerspectiveLut);
            device.setBindGroup(0, this._bindgroupAerialPerspectiveLut);
            this._bindgroupAerialPerspectiveLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this._bindgroupAerialPerspectiveLut.setValue('sunAltitude', this._currentAerialPerspectiveAltitude);
            this._bindgroupAerialPerspectiveLut.setValue('maxDistance', this._currentMaxAerialPerspectiveDistance);
            this._bindgroupAerialPerspectiveLut.setTexture('tLut', tLut);
            this._bindgroupAerialPerspectiveLut.setTexture('msLut', msLut);
            this.drawQuad(device);
            device.popDeviceStates();
            fb.dispose();
        }
        return this._aerialPerspectiveLut;
    }
    static getSkyViewLut(sunAltitude) {
        const device = Application.instance.device;
        if (sunAltitude !== this._currentSkyViewSunAltitude || !this._skyViewFramebuffer) {
            if (!this._skyViewFramebuffer) {
                const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
                const skyViewLut = device.createTexture2D(format, this._skyViewLutWidth, this._skyViewLutHeight, {
                    samplerOptions: {
                        mipFilter: 'none'
                    }
                });
                skyViewLut.name = 'SkyViewLut';
                this._skyViewFramebuffer = device.createFrameBuffer([
                    skyViewLut
                ], null);
            }
            const tLut = this.getTransmittanceLut();
            const msLut = this.getMultiScatteringLut();
            this._currentSkyViewSunAltitude = sunAltitude;
            device.pushDeviceStates();
            device.setFramebuffer(this._skyViewFramebuffer);
            device.setProgram(this._programSkyViewLut);
            device.setBindGroup(0, this._bindgroupSkyViewLut);
            this._bindgroupSkyViewLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this._bindgroupSkyViewLut.setValue('sunAltitude', this._currentSkyViewSunAltitude);
            this._bindgroupSkyViewLut.setTexture('tLut', tLut);
            this._bindgroupSkyViewLut.setTexture('msLut', msLut);
            this.drawQuad(device);
            device.popDeviceStates();
        }
        return this._skyViewFramebuffer.getColorAttachments()[0];
    }
    static getTransmittanceLut() {
        const device = Application.instance.device;
        if (!this._transmittanceLut) {
            this.prepare(device);
            const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
            this._transmittanceLut = device.createTexture2D(format, this._transmittanceLutWidth, this._transmittanceLutHeight, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            this._transmittanceLut.name = 'TransmittanceLUT';
            const tempFramebuffer = device.createFrameBuffer([
                this._transmittanceLut
            ], null);
            device.pushDeviceStates();
            device.setFramebuffer(tempFramebuffer);
            device.setProgram(this._programTransmittanceLut);
            device.setBindGroup(0, this._bindgroupTransmittanceLut);
            this._bindgroupTransmittanceLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this.drawQuad(device);
            device.popDeviceStates();
            tempFramebuffer.dispose();
        }
        return this._transmittanceLut;
    }
    static drawQuad(device) {
        const lastRenderState = device.getRenderStates();
        device.setRenderStates(this._renderStates);
        device.setVertexLayout(this._vertexLayout);
        device.draw('triangle-strip', 0, 4);
        device.setRenderStates(lastRenderState);
    }
    static commonVertexShader() {
        const pb = this.$builder;
        this.flip = pb.int().uniform(0);
        this.$inputs.pos = pb.vec2().attrib('position');
        this.$outputs.uv = pb.vec2();
        pb.main(function() {
            this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
            this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
            this.$if(pb.notEqual(this.flip, 0), function() {
                this.$builtins.position.y = pb.neg(this.$builtins.position.y);
            });
        });
    }
    static commonFunctions() {
        const pb = this.$builder;
        this.viewPos = pb.vec3(ScatteringLut._viewPos.x, ScatteringLut._viewPos.y, ScatteringLut._viewPos.z);
        pb.func('getMiePhase', [
            pb.float('cosTheta')
        ], function() {
            this.$l.g = pb.float(0.8);
            this.$l.scale = pb.float(3 / (Math.PI * 8));
            this.$l.gg = pb.mul(this.g, this.g);
            this.$l.num = pb.mul(pb.sub(1, this.gg), pb.add(pb.mul(this.cosTheta, this.cosTheta), 1));
            this.$l.denom = pb.mul(pb.add(2, this.gg), pb.pow(pb.sub(pb.add(1, this.gg), pb.mul(this.g, this.cosTheta, 2)), 1.5));
            this.$return(pb.div(pb.mul(this.scale, this.num), this.denom));
        });
        pb.func('getRayleighPhase', [
            pb.float('cosTheta')
        ], function() {
            this.$l.k = pb.float(3 / (Math.PI * 16));
            this.$return(pb.mul(this.k, pb.add(1, pb.mul(this.cosTheta, this.cosTheta))));
        });
        pb.func('rayIntersectSphere', [
            pb.vec3('ro'),
            pb.vec3('rd'),
            pb.float('rad')
        ], function() {
            this.$l.b = pb.dot(this.ro, this.rd);
            this.$l.c = pb.sub(pb.dot(this.ro, this.ro), pb.mul(this.rad, this.rad));
            this.$if(pb.and(pb.greaterThan(this.c, 0), pb.greaterThan(this.b, 0)), function() {
                this.$return(pb.float(-1));
            });
            this.$l.bb = pb.mul(this.b, this.b);
            this.$l.discr = pb.sub(this.bb, this.c);
            this.$if(pb.lessThan(this.discr, 0), function() {
                this.$return(pb.float(-1));
            });
            this.$if(pb.greaterThan(this.discr, this.bb), function() {
                this.$return(pb.sub(pb.sqrt(this.discr), this.b));
            });
            this.$return(pb.sub(pb.neg(pb.sqrt(this.discr)), this.b));
        });
        pb.func('getScatteringValues', [
            pb.vec3('pos'),
            pb.vec3('rayleighScattering').out(),
            pb.float('mieScattering').out(),
            pb.vec3('extinction').out()
        ], function() {
            this.$l.altitudeKM = pb.mul(pb.sub(pb.length(this.pos), ScatteringLut._groundRadiusMM), 1000);
            this.$l.rayleighDensity = pb.exp(pb.div(this.altitudeKM, -8));
            this.$l.mieDensity = pb.exp(pb.div(this.altitudeKM, -1.2));
            this.rayleighScattering = pb.mul(pb.vec3(...ScatteringLut._rayleighScatteringBase), this.rayleighDensity);
            this.$l.rayleighAbsorption = pb.mul(ScatteringLut._rayleighAbsorptionBase, this.rayleighDensity);
            this.mieScattering = pb.mul(ScatteringLut._mieScatteringBase, this.mieDensity);
            this.$l.mieAbsorption = pb.mul(ScatteringLut._mieAbsorptionBase, this.mieDensity);
            this.$l.ozoneAbsorption = pb.mul(pb.vec3(...ScatteringLut._ozoneAbsorptionBase), pb.max(0, pb.sub(1, pb.div(pb.abs(pb.sub(this.altitudeKM, 25)), 15))));
            this.extinction = pb.add(this.rayleighScattering, pb.vec3(this.rayleighAbsorption), pb.vec3(this.mieScattering), pb.vec3(this.mieAbsorption), this.ozoneAbsorption);
        });
    }
    static prepare(device) {
        const that = this;
        if (!this._vertexLayout) {
            this._vertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                            -1,
                            -1,
                            1,
                            -1,
                            -1,
                            1,
                            1,
                            1
                        ]))
                    }
                ]
            });
        }
        if (!this._renderStates) {
            this._renderStates = device.createRenderStateSet();
            this._renderStates.useRasterizerState().setCullMode('none');
            this._renderStates.useDepthState().enableTest(false).enableWrite(false);
        }
        if (!this._programAerialPerspectiveLut) {
            this._programAerialPerspectiveLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.sunAltitude = pb.float().uniform(0);
                    this.tLut = pb.tex2D().uniform(0);
                    this.msLut = pb.tex2D().uniform(0);
                    this.maxDistance = pb.float().uniform(0);
                    that.commonFunctions.call(this);
                    pb.func('getValFromTLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                    });
                    pb.func('getValFromMSLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.msLut, this.uv, 0).rgb);
                    });
                    pb.func('raymarchScattering', [
                        pb.vec3('pos'),
                        pb.vec3('rayDir'),
                        pb.vec3('sunDir'),
                        pb.float('tMax')
                    ], function() {
                        this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                        this.$l.miePhaseValue = this.getMiePhase(this.cosTheta);
                        this.$l.rayleighPhaseValue = this.getRayleighPhase(pb.neg(this.cosTheta));
                        this.$l.lum = pb.vec3(0);
                        this.$l.transmittance = pb.vec3(1);
                        this.$l.t = pb.float(0);
                        this.$for(pb.int('i'), 0, that._scatteringSteps, function() {
                            this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.i), 0.3), that._scatteringSteps), this.tMax);
                            this.$l.dt = pb.sub(this.newT, this.t);
                            this.t = this.newT;
                            this.$l.newPos = pb.add(this.pos, pb.mul(this.rayDir, this.t));
                            this.$l.rayleighScattering = pb.vec3();
                            this.$l.extinction = pb.vec3();
                            this.$l.mieScattering = pb.float();
                            this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                            this.$l.sampleTransmittance = pb.exp(pb.mul(pb.neg(this.dt), this.extinction));
                            this.$l.sunTransmittance = this.getValFromTLUT(this.newPos, this.sunDir);
                            this.$l.psiMS = this.getValFromMSLUT(this.newPos, this.sunDir);
                            this.$l.rayleighInScattering = pb.mul(this.rayleighScattering, pb.add(pb.mul(this.sunTransmittance, this.rayleighPhaseValue), this.psiMS));
                            this.$l.mieInScattering = pb.mul(pb.add(pb.mul(this.sunTransmittance, this.miePhaseValue), this.psiMS), this.mieScattering);
                            this.$l.inScattering = pb.add(this.rayleighInScattering, this.mieInScattering);
                            this.$l.scatteringIntegral = pb.div(pb.sub(this.inScattering, pb.mul(this.inScattering, this.sampleTransmittance)), this.extinction);
                            this.lum = pb.add(this.lum, pb.mul(this.scatteringIntegral, this.transmittance));
                            this.transmittance = pb.mul(this.transmittance, this.sampleTransmittance);
                        });
                        this.$return(this.lum);
                    });
                    pb.main(function() {
                        this.$l.slice = pb.clamp(pb.floor(pb.div(this.$inputs.uv.x, 1 / ScatteringLut._aerialPerspectiveSliceZ)), 0, pb.sub(ScatteringLut._aerialPerspectiveSliceZ, 1));
                        this.$l.sliceU = pb.clamp(pb.div(pb.sub(this.$inputs.uv.x, pb.mul(this.slice, 1 / ScatteringLut._aerialPerspectiveSliceZ)), 1 / ScatteringLut._aerialPerspectiveSliceZ), 0, 1);
                        this.$l.horizonAngle = pb.sub(pb.mul(this.sliceU, Math.PI * 2), Math.PI);
                        this.$l.zenithAngle = pb.mul(this.$inputs.uv.y, Math.PI / 2);
                        /*
            this.$l.rayDir = pb.vec3(pb.mul(this.cosAltitude, pb.sin(this.azimuthAngle)), pb.sin(this.altitudeAngle), pb.mul(pb.neg(this.cosAltitude), pb.cos(this.azimuthAngle)));
            this.$l.sunDir = pb.vec3(0, pb.sin(this.sunAltitude), pb.neg(pb.cos(this.sunAltitude)));
            */ this.$l.rayDir = pb.vec3(pb.mul(pb.cos(this.zenithAngle), pb.sin(this.horizonAngle)), pb.sin(this.zenithAngle), pb.mul(pb.neg(pb.cos(this.zenithAngle)), pb.cos(this.horizonAngle)));
                        this.$l.atmoDist = this.rayIntersectSphere(this.viewPos, this.rayDir, ScatteringLut._atmosphereRadiusMM);
                        this.$l.groundDist = this.rayIntersectSphere(this.viewPos, this.rayDir, ScatteringLut._groundRadiusMM);
                        this.$l.tMax = pb.float();
                        this.$if(pb.lessThan(this.groundDist, 0), function() {
                            this.tMax = this.atmoDist;
                        }).$else(function() {
                            this.tMax = this.groundDist;
                        });
                        this.tMax = this.atmoDist;
                        this.$l.maxDistanceMM = pb.mul(this.maxDistance, 1e-6);
                        this.$l.sliceDist = pb.mul(this.maxDistanceMM, pb.div(this.slice, ScatteringLut._aerialPerspectiveSliceZ));
                        this.tMax = pb.min(this.tMax, this.sliceDist);
                        this.$l.sunDir = pb.vec3(0, pb.sin(this.sunAltitude), pb.neg(pb.cos(this.sunAltitude)));
                        this.$l.lum = this.raymarchScattering(this.viewPos, this.rayDir, this.sunDir, this.tMax);
                        const heightKM = (that._viewPos.y - that._groundRadiusMM) * 1000;
                        const rayleighDensity = Math.exp(-heightKM / 8);
                        const mieDensity = Math.exp(-heightKM / 1.2);
                        this.$l.extinction = pb.vec3(-((that._rayleighScatteringBase[0] + that._rayleighAbsorptionBase) * rayleighDensity + (that._mieScatteringBase + that._mieAbsorptionBase) * mieDensity), -((that._rayleighScatteringBase[1] + that._rayleighAbsorptionBase) * rayleighDensity + (that._mieScatteringBase + that._mieAbsorptionBase) * mieDensity), -((that._rayleighScatteringBase[2] + that._rayleighAbsorptionBase) * rayleighDensity + (that._mieScatteringBase + that._mieAbsorptionBase) * mieDensity));
                        this.$l.t = pb.exp(pb.mul(this.extinction, this.tMax));
                        this.$outputs.outColor = pb.vec4(this.lum, pb.dot(this.t, pb.vec3(1 / 3, 1 / 3, 1 / 3)));
                    });
                }
            });
            this._bindgroupAerialPerspectiveLut = device.createBindGroup(this._programAerialPerspectiveLut.bindGroupLayouts[0]);
        }
        if (!this._programSkyViewLut) {
            this._programSkyViewLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.sunAltitude = pb.float().uniform(0);
                    this.tLut = pb.tex2D().uniform(0);
                    this.msLut = pb.tex2D().uniform(0);
                    that.commonFunctions.call(this);
                    pb.func('getValFromTLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                    });
                    pb.func('getValFromMSLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.msLut, this.uv, 0).rgb);
                    });
                    pb.func('raymarchScattering', [
                        pb.vec3('pos'),
                        pb.vec3('rayDir'),
                        pb.vec3('sunDir'),
                        pb.float('tMax')
                    ], function() {
                        this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                        this.$l.miePhaseValue = this.getMiePhase(this.cosTheta);
                        this.$l.rayleighPhaseValue = this.getRayleighPhase(pb.neg(this.cosTheta));
                        this.$l.lum = pb.vec3(0);
                        this.$l.transmittance = pb.vec3(1);
                        this.$l.t = pb.float(0);
                        this.$for(pb.int('i'), 0, that._scatteringSteps, function() {
                            this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.i), 0.3), that._scatteringSteps), this.tMax);
                            this.$l.dt = pb.sub(this.newT, this.t);
                            this.t = this.newT;
                            this.$l.newPos = pb.add(this.pos, pb.mul(this.rayDir, this.t));
                            this.$l.rayleighScattering = pb.vec3();
                            this.$l.extinction = pb.vec3();
                            this.$l.mieScattering = pb.float();
                            this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                            this.$l.sampleTransmittance = pb.exp(pb.mul(pb.neg(this.dt), this.extinction));
                            this.$l.sunTransmittance = this.getValFromTLUT(this.newPos, this.sunDir);
                            this.$l.psiMS = this.getValFromMSLUT(this.newPos, this.sunDir);
                            this.$l.rayleighInScattering = pb.mul(this.rayleighScattering, pb.add(pb.mul(this.sunTransmittance, this.rayleighPhaseValue), this.psiMS));
                            this.$l.mieInScattering = pb.mul(pb.add(pb.mul(this.sunTransmittance, this.miePhaseValue), this.psiMS), this.mieScattering);
                            this.$l.inScattering = pb.add(this.rayleighInScattering, this.mieInScattering);
                            this.$l.scatteringIntegral = pb.div(pb.sub(this.inScattering, pb.mul(this.inScattering, this.sampleTransmittance)), this.extinction);
                            this.lum = pb.add(this.lum, pb.mul(this.scatteringIntegral, this.transmittance));
                            this.transmittance = pb.mul(this.transmittance, this.sampleTransmittance);
                        });
                        this.$return(this.lum);
                    });
                    pb.main(function() {
                        this.$l.azimuthAngle = pb.mul(pb.sub(this.$inputs.uv.x, 0.5), 2 * Math.PI);
                        this.$l.adjV = pb.float();
                        this.$if(pb.lessThan(this.$inputs.uv.y, 0.5), function() {
                            this.$l.coord = pb.sub(1, pb.mul(this.$inputs.uv.y, 2));
                            this.adjV = pb.neg(pb.mul(this.coord, this.coord));
                        }).$else(function() {
                            this.$l.coord = pb.sub(pb.mul(this.$inputs.uv.y, 2), 1);
                            this.adjV = pb.mul(this.coord, this.coord);
                        });
                        this.$l.height = pb.length(this.viewPos);
                        this.$l.up = pb.div(this.viewPos, this.height);
                        this.$l.horizonAngle = pb.sub(pb.acos(pb.clamp(pb.div(pb.sqrt(pb.sub(pb.mul(this.height, this.height), pb.mul(that._groundRadiusMM, that._groundRadiusMM))), this.height), -1, 1)), Math.PI * 0.5);
                        this.$l.altitudeAngle = pb.sub(pb.mul(this.adjV, Math.PI * 0.5), this.horizonAngle);
                        this.$l.cosAltitude = pb.cos(this.altitudeAngle);
                        this.$l.rayDir = pb.vec3(pb.mul(this.cosAltitude, pb.sin(this.azimuthAngle)), pb.sin(this.altitudeAngle), pb.mul(pb.neg(this.cosAltitude), pb.cos(this.azimuthAngle)));
                        this.$l.sunDir = pb.vec3(0, pb.sin(this.sunAltitude), pb.neg(pb.cos(this.sunAltitude)));
                        this.$l.atmoDist = this.rayIntersectSphere(this.viewPos, this.rayDir, that._atmosphereRadiusMM);
                        this.$l.groundDist = this.rayIntersectSphere(this.viewPos, this.rayDir, that._groundRadiusMM);
                        this.$l.tMax = pb.float();
                        this.$if(pb.lessThan(this.groundDist, 0), function() {
                            this.tMax = this.atmoDist;
                        }).$else(function() {
                            this.tMax = this.groundDist;
                        });
                        this.$l.lum = this.raymarchScattering(this.viewPos, this.rayDir, this.sunDir, this.tMax);
                        this.$outputs.outColor = pb.vec4(this.lum, 1);
                    });
                }
            });
            this._bindgroupSkyViewLut = device.createBindGroup(this._programSkyViewLut.bindGroupLayouts[0]);
        }
        if (!this._programMultiScatteringLut) {
            this._programMultiScatteringLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.tLut = pb.tex2D().uniform(0);
                    that.commonFunctions.call(this);
                    pb.func('getValFromTLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                    });
                    pb.func('getSphericalDir', [
                        pb.float('theta'),
                        pb.float('phi')
                    ], function() {
                        this.$l.cosPhi = pb.cos(this.phi);
                        this.$l.sinPhi = pb.sin(this.phi);
                        this.$l.cosTheta = pb.cos(this.theta);
                        this.$l.sinTheta = pb.sin(this.theta);
                        this.$return(pb.vec3(pb.mul(this.sinPhi, this.sinTheta), this.cosPhi, pb.mul(this.sinPhi, this.cosTheta)));
                    });
                    pb.func('getMultiScatteringValues', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir'),
                        pb.vec3('lumTotal').out(),
                        pb.vec3('fms').out()
                    ], function() {
                        this.lumTotal = pb.vec3(0);
                        this.fms = pb.vec3(0);
                        this.$l.invSamples = pb.div(pb.float(1), pb.mul(that._sqrtSamples, that._sqrtSamples));
                        this.$for(pb.int('i'), 0, that._sqrtSamples, function() {
                            this.$for(pb.int('j'), 0, that._sqrtSamples, function() {
                                this.$l.theta = pb.div(pb.mul(pb.add(pb.float(this.i), 0.5), Math.PI), that._sqrtSamples);
                                this.$l.c = pb.sub(1, pb.div(pb.mul(pb.add(pb.float(this.j), 0.5), 2), that._sqrtSamples));
                                this.$l.phi = pb.acos(pb.clamp(this.c, -1, 1));
                                this.$l.rayDir = this.getSphericalDir(this.theta, this.phi);
                                this.$l.atmoDist = this.rayIntersectSphere(this.pos, this.rayDir, that._atmosphereRadiusMM);
                                this.$l.groundDist = this.rayIntersectSphere(this.pos, this.rayDir, that._groundRadiusMM);
                                this.$l.tMax = this.atmoDist;
                                this.$if(pb.greaterThan(this.groundDist, 0), function() {
                                    this.tMax = this.groundDist;
                                });
                                this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                                this.$l.miePhaseValue = this.getMiePhase(this.cosTheta);
                                this.$l.rayleighPhaseValue = this.getRayleighPhase(pb.neg(this.cosTheta));
                                this.$l.lum = pb.vec3(0);
                                this.$l.lumFactor = pb.vec3(0);
                                this.$l.transmittance = pb.vec3(1);
                                this.$l.t = pb.float(0);
                                this.$for(pb.int('stepI'), 0, that._multiScatteringSteps, function() {
                                    this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.stepI), 0.3), that._multiScatteringSteps), this.tMax);
                                    this.$l.dt = pb.sub(this.newT, this.t);
                                    this.t = this.newT;
                                    this.$l.newPos = pb.add(this.pos, pb.mul(this.rayDir, this.t));
                                    this.$l.rayleighScattering = pb.vec3();
                                    this.$l.extinction = pb.vec3();
                                    this.$l.mieScattering = pb.float();
                                    this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                                    this.$l.sampleTransmittance = pb.exp(pb.mul(pb.neg(this.dt), this.extinction));
                                    this.$l.scatteringNoPhase = pb.add(this.rayleighScattering, pb.vec3(this.mieScattering));
                                    this.$l.scatteringF = pb.div(pb.sub(this.scatteringNoPhase, pb.mul(this.scatteringNoPhase, this.sampleTransmittance)), this.extinction);
                                    this.lumFactor = pb.add(this.lumFactor, pb.mul(this.transmittance, this.scatteringF));
                                    this.$l.sunTransmittance = this.getValFromTLUT(this.newPos, this.sunDir);
                                    this.$l.rayleighInscattering = pb.mul(this.rayleighScattering, this.rayleighPhaseValue);
                                    this.$l.mieInscattering = pb.mul(this.mieScattering, this.miePhaseValue);
                                    this.$l.inscattering = pb.mul(pb.add(this.rayleighInscattering, pb.vec3(this.mieInscattering)), this.sunTransmittance);
                                    this.$l.scatteringIntegral = pb.div(pb.sub(this.inscattering, pb.mul(this.inscattering, this.sampleTransmittance)), this.extinction);
                                    this.lum = pb.add(this.lum, pb.mul(this.scatteringIntegral, this.transmittance));
                                    this.transmittance = pb.mul(this.transmittance, this.sampleTransmittance);
                                });
                                this.$if(pb.greaterThan(this.groundDist, 0), function() {
                                    this.$l.hitPos = pb.add(this.pos, pb.mul(this.rayDir, this.groundDist));
                                    this.$if(pb.greaterThan(pb.dot(this.pos, this.sunDir), 0), function() {
                                        this.hitPos = pb.mul(pb.normalize(this.hitPos), that._groundRadiusMM);
                                        this.lum = pb.add(this.lum, pb.mul(this.transmittance, pb.vec3(that._groundAlbedo), this.getValFromTLUT(this.hitPos, this.sunDir)));
                                    });
                                });
                                this.fms = pb.add(this.fms, pb.mul(this.lumFactor, this.invSamples));
                                this.lumTotal = pb.add(this.lumTotal, pb.mul(this.lum, this.invSamples));
                            });
                        });
                    });
                    pb.main(function() {
                        this.$l.sunCosTheta = pb.sub(pb.mul(this.$inputs.uv.x, 2), 1);
                        this.$l.sunTheta = pb.acos(pb.clamp(this.sunCosTheta, -1, 1));
                        this.$l.height = pb.mix(that._groundRadiusMM, that._atmosphereRadiusMM, this.$inputs.uv.y);
                        this.$l.pos = pb.vec3(0, this.height, 0);
                        this.$l.sunDir = pb.normalize(pb.vec3(0, this.sunCosTheta, pb.neg(pb.sin(this.sunTheta))));
                        this.$l.lum = pb.vec3();
                        this.$l.fms = pb.vec3();
                        this.getMultiScatteringValues(this.pos, this.sunDir, this.lum, this.fms);
                        this.$l.psi = pb.div(this.lum, pb.sub(1, this.fms));
                        this.$outputs.outColor = pb.vec4(this.psi, 1);
                    });
                }
            });
        }
        this._bindgroupMultiScatteringLut = device.createBindGroup(this._programMultiScatteringLut.bindGroupLayouts[0]);
        if (!this._programTransmittanceLut) {
            this._programTransmittanceLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    that.commonFunctions.call(this);
                    pb.func('getSunTransmittance', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$if(pb.greaterThan(this.rayIntersectSphere(this.pos, this.sunDir, that._groundRadiusMM), 0), function() {
                            this.$return(pb.vec3(0));
                        });
                        this.$l.atmoDist = this.rayIntersectSphere(this.pos, this.sunDir, that._atmosphereRadiusMM);
                        this.$l.t = pb.float(0);
                        this.$l.transmittance = pb.vec3(1);
                        this.$for(pb.int('i'), 0, that._sunTransmittanceSteps, function() {
                            this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.i), 0.3), that._sunTransmittanceSteps), this.atmoDist);
                            this.$l.dt = pb.sub(this.newT, this.t);
                            this.t = this.newT;
                            this.$l.newPos = pb.add(this.pos, pb.mul(this.sunDir, this.t));
                            this.$l.rayleighScattering = pb.vec3();
                            this.$l.extinction = pb.vec3();
                            this.$l.mieScattering = pb.float();
                            this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                            this.transmittance = pb.mul(this.transmittance, pb.exp(pb.mul(this.extinction, pb.neg(this.dt))));
                        });
                        this.$return(this.transmittance);
                    });
                    pb.main(function() {
                        this.$l.sunCosTheta = pb.sub(pb.mul(this.$inputs.uv.x, 2), 1);
                        this.$l.sunTheta = pb.acos(pb.clamp(this.sunCosTheta, -1, 1));
                        this.$l.height = pb.mix(that._groundRadiusMM, that._atmosphereRadiusMM, this.$inputs.uv.y);
                        this.$l.pos = pb.vec3(0, this.height, 0);
                        this.$l.sunDir = pb.normalize(pb.vec3(0, this.sunCosTheta, pb.neg(pb.sin(this.sunTheta))));
                        this.$outputs.outColor = pb.vec4(this.getSunTransmittance(this.pos, this.sunDir), 1);
                    });
                }
            });
        }
        this._bindgroupTransmittanceLut = device.createBindGroup(this._programTransmittanceLut.bindGroupLayouts[0]);
    }
}

const UNIFORM_NAME_GLOBAL = 'Z_UniformGlobal';
const UNIFORM_NAME_LIGHT_BUFFER = 'Z_UniformLightBuffer';
const UNIFORM_NAME_LIGHT_INDEX_TEXTURE = 'Z_UniformLightIndexTex';
const UNIFORM_NAME_AERIALPERSPECTIVE_LUT = 'Z_UniformAerialPerspectiveLUT';
const UNIFORM_NAME_SHADOW_MAP = 'Z_UniformShadowMap';
const UNIFORM_NAME_INSTANCE_BUFFER_OFFSET = 'Z_UniformInstanceBufferOffset';
const UNIFORM_NAME_WORLD_MATRIX = 'Z_UniformWorldMatrix';
const UNIFORM_NAME_WORLD_MATRICES = 'Z_UniformWorldMatrices';
const UNIFORM_NAME_BONE_MATRICES = 'Z_UniformBoneMatrices';
const UNIFORM_NAME_BONE_TEXTURE_SIZE = 'Z_UniformBoneTexSize';
const UNIFORM_NAME_BONE_INV_BIND_MATRIX = 'Z_UniformBoneInvBindMatrix';
/**
 * Helper shader functions for the builtin material system
 * @public
 */ class ShaderHelper {
    static FOG_TYPE_NONE = 0;
    static FOG_TYPE_LINEAR = 1;
    static FOG_TYPE_EXP = 2;
    static FOG_TYPE_EXP2 = 3;
    static FOG_TYPE_SCATTER = 4;
    static BILLBOARD_SPHERICAL = 1;
    static BILLBOARD_SYLINDRAL = 2;
    /** @internal */ static defaultSunDir = Vector3.one().inplaceNormalize();
    /** @internal */ static SKIN_MATRIX_NAME = 'Z_SkinMatrix';
    /** @internal */ static _lightUniformShadow = {
        light: {
            sunDir: new Vector3(),
            envLightStrength: 1,
            shadowCascades: 1,
            positionAndRange: new Vector4(),
            directionAndCutoff: new Vector4(),
            diffuseAndIntensity: new Vector4(),
            cascadeDistances: new Vector4(),
            depthBiasValues: new Vector4(),
            shadowCameraParams: new Vector4(),
            depthBiasScales: new Vector4(),
            shadowMatrices: new Float32Array(16 * 4)
        }
    };
    /** @internal */ static _fogUniforms = {
        fog: {
            fogType: 0,
            fogColor: null,
            // [near, far, top, density]
            fogParams: null,
            // aerial perspective density
            apDensity: 1
        }
    };
    static getWorldMatrixUniformName() {
        return UNIFORM_NAME_WORLD_MATRIX;
    }
    static getWorldMatricesUniformName() {
        return UNIFORM_NAME_WORLD_MATRICES;
    }
    static getInstanceBufferOffsetUniformName() {
        return UNIFORM_NAME_INSTANCE_BUFFER_OFFSET;
    }
    static getBoneMatricesUniformName() {
        return UNIFORM_NAME_BONE_MATRICES;
    }
    static getBoneTextureSizeUniformName() {
        return UNIFORM_NAME_BONE_TEXTURE_SIZE;
    }
    static getBoneInvBindMatrixUniformName() {
        return UNIFORM_NAME_BONE_INV_BIND_MATRIX;
    }
    static getLightBufferUniformName() {
        return UNIFORM_NAME_LIGHT_BUFFER;
    }
    /**
   * Prepares the fragment shader which is going to be used in our material system
   *
   * @remarks
   * This function will setup all nessesary uniforms acoording to the drawing context
   *
   * @param pb - The program builder
   * @param ctx - The drawing context
   */ static prepareFragmentShader(pb, ctx) {
        this.setupGlobalUniforms(pb, ctx);
    }
    /**
   * Prepares the vertex shader which is going to be used in our material system
   *
   * @remarks
   * This function will setup all nessesary uniforms according to the drawing context
   *
   * @param pb - The program builder
   * @param ctx - The drawing context
   */ static prepareVertexShader(pb, ctx) {
        this.setupGlobalUniforms(pb, ctx);
        this.prepareVertexShaderCommon(pb, ctx);
    }
    /** @internal */ static setupGlobalUniforms(pb, ctx) {
        const scope = pb.getGlobalScope();
        const cameraStruct = pb.defineStruct([
            pb.vec4('position'),
            pb.vec4('clipPlane'),
            pb.mat4('viewProjectionMatrix'),
            pb.mat4('viewMatrix'),
            pb.mat4('rotationMatrix'),
            pb.mat4('projectionMatrix'),
            pb.vec4('params')
        ]);
        if (ctx.renderPass.type === RENDER_PASS_TYPE_SHADOWMAP) {
            const lightStruct = pb.defineStruct([
                pb.vec4('positionAndRange'),
                pb.vec4('directionCutoff'),
                pb.mat4('viewMatrix'),
                pb.vec4('depthBias'),
                pb.int('lightType')
            ]);
            const globalStruct = pb.defineStruct([
                cameraStruct('camera'),
                lightStruct('light')
            ]);
            scope[UNIFORM_NAME_GLOBAL] = globalStruct().uniform(0);
        } else if (ctx.renderPass.type === RENDER_PASS_TYPE_DEPTH) {
            const globalStruct = pb.defineStruct([
                cameraStruct('camera')
            ]);
            scope[UNIFORM_NAME_GLOBAL] = globalStruct().uniform(0);
        } else if (ctx.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
            const useClusteredLighting = !ctx.currentShadowLight;
            const fogStruct = pb.defineStruct([
                pb.int('fogType'),
                pb.vec4('fogColor'),
                pb.vec4('fogParams'),
                pb.float('apDensity')
            ]);
            const lightStruct = ctx.currentShadowLight ? pb.defineStruct([
                pb.vec3('sunDir'),
                pb.int('shadowCascades'),
                pb.vec4('positionAndRange'),
                pb.vec4('directionAndCutoff'),
                pb.vec4('diffuseAndIntensity'),
                pb.vec4('cascadeDistances'),
                pb.vec4('depthBiasValues'),
                pb.vec4('shadowCameraParams'),
                pb.vec4('depthBiasScales'),
                pb.vec4[16]('shadowMatrices'),
                pb.float('envLightStrength')
            ]) : pb.defineStruct([
                pb.vec3('sunDir'),
                pb.float('envLightStrength'),
                pb.vec4('clusterParams'),
                pb.ivec4('countParams'),
                pb.ivec2('lightIndexTexSize')
            ]);
            const globalStruct = pb.defineStruct([
                cameraStruct('camera'),
                lightStruct('light'),
                fogStruct('fog')
            ]);
            scope[UNIFORM_NAME_GLOBAL] = globalStruct().uniform(0);
            if (useClusteredLighting) {
                scope[UNIFORM_NAME_LIGHT_BUFFER] = pb.vec4[(MAX_CLUSTERED_LIGHTS + 1) * 3]().uniformBuffer(0);
                scope[UNIFORM_NAME_LIGHT_INDEX_TEXTURE] = (pb.getDevice().type === 'webgl' ? pb.tex2D() : pb.utex2D()).uniform(0);
            }
            if (ctx.applyFog && ctx.scene.env.sky.drawScatteredFog(ctx)) {
                scope[UNIFORM_NAME_AERIALPERSPECTIVE_LUT] = pb.tex2D().uniform(0);
            }
            if (ctx.currentShadowLight) {
                const scope = pb.getGlobalScope();
                const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
                const tex = shadowMapParams.shadowMap.isTextureCube() ? shadowMapParams.shadowMap.isDepth() ? scope.$builder.texCubeShadow() : scope.$builder.texCube() : shadowMapParams.shadowMap.isTexture2D() ? shadowMapParams.shadowMap.isDepth() ? scope.$builder.tex2DShadow() : scope.$builder.tex2D() : shadowMapParams.shadowMap.isDepth() ? scope.$builder.tex2DArrayShadow() : scope.$builder.tex2DArray();
                if (!shadowMapParams.shadowMap.isDepth() && !Application.instance.device.getDeviceCaps().textureCaps.getTextureFormatInfo(shadowMapParams.shadowMap.format).filterable) {
                    tex.sampleType('unfilterable-float');
                }
                scope[UNIFORM_NAME_SHADOW_MAP] = tex.uniform(0);
            }
            ctx.drawEnvLight && ctx.env.light.envLight.initShaderBindings(pb);
        }
    }
    /**
   * This function checks if the shader needs to process skeletal animation.
   *
   * @param scope - Current shader scope
   *
   * @returns true if the shader needs to process skeletal animation, otherwise false.
   */ static hasSkinning(scope) {
        return !!scope[UNIFORM_NAME_BONE_MATRICES];
    }
    /**
   * Calculate skinning matrix for current vertex
   *
   * @param scope - Current shader scope
   *
   * @returns Skinning matrix for current vertex, or null if there is not skeletal animation
   */ static calculateSkinMatrix(scope) {
        if (!this.hasSkinning(scope)) {
            return null;
        }
        const pb = scope.$builder;
        const funcNameGetBoneMatrixFromTexture = 'Z_getBoneMatrixFromTexture';
        pb.func(funcNameGetBoneMatrixFromTexture, [
            pb.int('boneIndex')
        ], function() {
            const boneTexture = this[UNIFORM_NAME_BONE_MATRICES];
            this.$l.w = pb.float(this[UNIFORM_NAME_BONE_TEXTURE_SIZE]);
            this.$l.pixelIndex = pb.float(pb.mul(this.boneIndex, 4));
            this.$l.xIndex = pb.mod(this.pixelIndex, this.w);
            this.$l.yIndex = pb.floor(pb.div(this.pixelIndex, this.w));
            this.$l.u1 = pb.div(pb.add(this.xIndex, 0.5), this.w);
            this.$l.u2 = pb.div(pb.add(this.xIndex, 1.5), this.w);
            this.$l.u3 = pb.div(pb.add(this.xIndex, 2.5), this.w);
            this.$l.u4 = pb.div(pb.add(this.xIndex, 3.5), this.w);
            this.$l.v = pb.div(pb.add(this.yIndex, 0.5), this.w);
            this.$l.row1 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u1, this.v), 0);
            this.$l.row2 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u2, this.v), 0);
            this.$l.row3 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u3, this.v), 0);
            this.$l.row4 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u4, this.v), 0);
            this.$return(pb.mat4(this.row1, this.row2, this.row3, this.row4));
        });
        const funcNameGetSkinningMatrix = 'Z_getSkinningMatrix';
        pb.func(funcNameGetSkinningMatrix, [], function() {
            const invBindMatrix = this[UNIFORM_NAME_BONE_INV_BIND_MATRIX];
            const blendIndices = scope.$getVertexAttrib('blendIndices');
            const blendWeights = scope.$getVertexAttrib('blendWeights');
            this.$l.m0 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[0]));
            this.$l.m1 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[1]));
            this.$l.m2 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[2]));
            this.$l.m3 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[3]));
            this.$l.m = pb.add(pb.mul(this.m0, blendWeights.x), pb.mul(this.m1, blendWeights.y), pb.mul(this.m2, blendWeights.z), pb.mul(this.m3, blendWeights.w));
            this.$return(pb.mul(invBindMatrix, this.m));
        });
        return scope.$g[funcNameGetSkinningMatrix]();
    }
    /**
   * Calculates the vertex position of type vec3 in object space
   *
   * @param scope - Current shader scope
   * @param pos - Vertex position input, must be type of vec3, null if no vertex position input
   * @param skinMatrix - The skinning matrix if there is skeletal animation, otherwise null
   * @returns The calculated vertex position in object space, or null if pos is null
   */ static resolveVertexPosition(scope, pos) {
        const pb = scope.$builder;
        if (pb.shaderKind !== 'vertex') {
            throw new Error(`ShaderHelper.resolveVertexPosition(): must be called at vertex stage`);
        }
        const funcScope = pb.getCurrentFunctionScope();
        if (!funcScope || !funcScope.$isMain()) {
            throw new Error(`ShaderHelper.resolveVertexPosition(): must be called at entry function`);
        }
        if (!pos) {
            if (!scope.$getVertexAttrib('position')) {
                scope.$inputs.Z_pos = pb.vec3().attrib('position');
            }
            pos = scope.$getVertexAttrib('position');
        }
        if (this.hasSkinning(scope)) {
            if (!funcScope[this.SKIN_MATRIX_NAME]) {
                funcScope[this.SKIN_MATRIX_NAME] = this.calculateSkinMatrix(funcScope);
            }
            return pb.mul(scope[this.SKIN_MATRIX_NAME], pb.vec4(pos, 1)).xyz;
        } else {
            return pos;
        }
    }
    /**
   * Calculates the normal vector of type vec3 in object space
   *
   * @param scope - Current shader scope
   * @param normal - Vertex normal input, must be type of vec3, null if no vertex normal input
   * @param skinMatrix - The skinning matrix if there is skeletal animation, otherwise null
   * @returns The calculated normal vector in object space, or null if normal is null
   */ static resolveVertexNormal(scope, normal) {
        const pb = scope.$builder;
        if (pb.shaderKind !== 'vertex') {
            throw new Error(`ShaderHelper.resolveVertexNormal(): must be called in vertex stage`);
        }
        const funcScope = pb.getCurrentFunctionScope();
        if (!funcScope || !funcScope.$isMain()) {
            throw new Error(`ShaderHelper.resolveVertexNormal(): must be called at entry function`);
        }
        if (!normal) {
            if (!scope.$getVertexAttrib('normal')) {
                scope.$inputs.Z_normal = pb.vec3().attrib('normal');
            }
            normal = scope.$getVertexAttrib('normal');
        }
        if (this.hasSkinning(scope)) {
            if (!funcScope[this.SKIN_MATRIX_NAME]) {
                funcScope[this.SKIN_MATRIX_NAME] = this.calculateSkinMatrix(funcScope);
            }
            return pb.mul(scope[this.SKIN_MATRIX_NAME], pb.vec4(normal, 0)).xyz;
        } else {
            return normal;
        }
    }
    /**
   * Calculates the tangent vector of type vec3 in object space
   *
   * @param scope - Current shader scope
   * @param tangent - Vertex tangent input, must be type of vec4, null if no vertex tangent input
   * @param skinMatrix - The skinning matrix if there is skeletal animation, otherwise null
   * @returns The calculated tangent vector of type vec4 in object space, or null if tangent is null
   */ static resolveVertexTangent(scope, tangent) {
        const pb = scope.$builder;
        if (pb.shaderKind !== 'vertex') {
            throw new Error(`ShaderHelper.resolveVertexTangent(): must be called in vertex stage`);
        }
        const funcScope = pb.getCurrentFunctionScope();
        if (!funcScope || !funcScope.$isMain()) {
            throw new Error(`ShaderHelper.resolveVertexTangent(): must be called at entry function`);
        }
        if (!tangent) {
            if (!scope.$getVertexAttrib('tangent')) {
                scope.$inputs.Z_tangent = pb.vec4().attrib('tangent');
            }
            tangent = scope.$getVertexAttrib('tangent');
        }
        if (this.hasSkinning(scope)) {
            if (!funcScope[this.SKIN_MATRIX_NAME]) {
                funcScope[this.SKIN_MATRIX_NAME] = this.calculateSkinMatrix(funcScope);
            }
            return pb.vec4(pb.mul(scope[this.SKIN_MATRIX_NAME], pb.vec4(tangent.xyz, 0)).xyz, tangent.w);
        } else {
            return tangent;
        }
    }
    /**
   * Gets the uniform variable of type mat4 which holds the world matrix of current object to be drawn
   * @param scope - Current shader scope
   * @returns The world matrix of current object to be drawn
   */ static getWorldMatrix(scope) {
        const pb = scope.$builder;
        return scope[UNIFORM_NAME_WORLD_MATRIX] ?? scope[UNIFORM_NAME_WORLD_MATRICES].at(pb.add(scope[UNIFORM_NAME_INSTANCE_BUFFER_OFFSET], pb.uint(scope.$builtins.instanceIndex)));
    }
    /**
   * Gets the uniform variable of type mat4 which holds the normal matrix of current object to be drawn
   * @param scope - Current shader scope
   * @returns The normal matrix of current object to be drawn
   */ static getNormalMatrix(scope) {
        return this.getWorldMatrix(scope);
    }
    /** @internal */ static prepareVertexShaderCommon(pb, ctx) {
        const instancing = ctx.instanceData?.worldMatrices?.length > 1;
        const skinning = !!ctx.target?.getBoneMatrices();
        const scope = pb.getGlobalScope();
        if (instancing) {
            const maxNumInstances = Application.instance.device.getDeviceCaps().shaderCaps.maxUniformBufferSize >> 6;
            scope[UNIFORM_NAME_INSTANCE_BUFFER_OFFSET] = pb.uint().uniform(1);
            scope[UNIFORM_NAME_WORLD_MATRICES] = pb.mat4[maxNumInstances]().uniformBuffer(3);
        } else {
            scope[UNIFORM_NAME_WORLD_MATRIX] = pb.mat4().uniform(1);
        }
        if (skinning) {
            scope[UNIFORM_NAME_BONE_MATRICES] = pb.tex2D().uniform(1).sampleType('unfilterable-float');
            scope[UNIFORM_NAME_BONE_INV_BIND_MATRIX] = pb.mat4().uniform(1);
            scope[UNIFORM_NAME_BONE_TEXTURE_SIZE] = pb.int().uniform(1);
        }
    }
    /** @internal */ static setCameraUniforms(bindGroup, ctx, linear) {
        const pos = ctx.camera.getWorldPosition();
        const cameraStruct = {
            position: new Vector4(pos.x, pos.y, pos.z, ctx.camera.clipPlane ? 1 : 0),
            clipPlane: ctx.camera.clipPlane ?? Vector4.zero(),
            viewProjectionMatrix: ctx.camera.viewProjectionMatrix,
            viewMatrix: ctx.camera.viewMatrix,
            rotationMatrix: ctx.camera.getRotationMatrix(),
            projectionMatrix: ctx.camera.getProjectionMatrix(),
            params: new Vector4(ctx.camera.getNearPlane(), ctx.camera.getFarPlane(), ctx.flip ? -1 : 1, linear ? 0 : 1)
        };
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, {
            camera: cameraStruct
        });
    }
    /** @internal */ static setLightUniformsShadowMap(bindGroup, ctx, light) {
        if (light) {
            const shadowMapParams = ctx.shadowMapInfo.get(light);
            bindGroup.setValue(UNIFORM_NAME_GLOBAL, {
                light: {
                    positionAndRange: light.positionAndRange,
                    directionCutoff: light.directionAndCutoff,
                    viewMatrix: light.viewMatrix,
                    depthBias: shadowMapParams.depthBiasValues[0],
                    lightType: light.lightType
                }
            });
        }
    }
    /** @internal */ static setFogUniforms(bindGroup, fogType, fogColor, fogParams, apDensity, aerialPerspectiveLUT) {
        this._fogUniforms.fog.fogColor = fogColor;
        this._fogUniforms.fog.fogParams = fogParams;
        this._fogUniforms.fog.fogType = fogType;
        this._fogUniforms.fog.apDensity = apDensity;
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, this._fogUniforms);
        if (aerialPerspectiveLUT) {
            bindGroup.setTexture(UNIFORM_NAME_AERIALPERSPECTIVE_LUT, aerialPerspectiveLUT);
        }
    }
    /** @internal */ static setLightUniforms(bindGroup, ctx, clusterParams, countParams, lightBuffer, lightIndexTexture) {
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, {
            light: {
                sunDir: ctx.sunLight ? ctx.sunLight.directionAndCutoff.xyz().scaleBy(-1) : this.defaultSunDir,
                clusterParams: clusterParams,
                countParams: countParams,
                envLightStrength: ctx.env.light.strength ?? 0,
                lightIndexTexSize: new Int32Array([
                    lightIndexTexture.width,
                    lightIndexTexture.height
                ])
            }
        });
        bindGroup.setBuffer(UNIFORM_NAME_LIGHT_BUFFER, lightBuffer);
        bindGroup.setTexture(UNIFORM_NAME_LIGHT_INDEX_TEXTURE, lightIndexTexture);
        ctx.drawEnvLight && ctx.env.light.envLight.updateBindGroup(bindGroup);
    }
    /** @internal */ static setLightUniformsShadow(bindGroup, ctx, light) {
        const shadowMapParams = ctx.shadowMapInfo.get(light);
        this._lightUniformShadow.light.sunDir = ctx.sunLight ? ctx.sunLight.directionAndCutoff.xyz().scaleBy(-1) : this.defaultSunDir, this._lightUniformShadow.light.envLightStrength = ctx.env?.light.strength ?? 0;
        this._lightUniformShadow.light.shadowCascades = shadowMapParams.numShadowCascades;
        this._lightUniformShadow.light.positionAndRange.set(light.positionAndRange);
        this._lightUniformShadow.light.directionAndCutoff.set(light.directionAndCutoff);
        this._lightUniformShadow.light.diffuseAndIntensity.set(light.diffuseAndIntensity);
        this._lightUniformShadow.light.cascadeDistances.set(shadowMapParams.cascadeDistances);
        this._lightUniformShadow.light.depthBiasValues.set(shadowMapParams.depthBiasValues[0]);
        this._lightUniformShadow.light.shadowCameraParams.set(shadowMapParams.cameraParams);
        this._lightUniformShadow.light.depthBiasScales.set(shadowMapParams.depthBiasScales);
        this._lightUniformShadow.light.shadowMatrices.set(shadowMapParams.shadowMatrices);
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, this._lightUniformShadow);
        bindGroup.setTexture(UNIFORM_NAME_SHADOW_MAP, shadowMapParams.shadowMap, shadowMapParams.shadowMapSampler);
        ctx.drawEnvLight && ctx.env.light.envLight.updateBindGroup(bindGroup);
    }
    /**
   * Gets the uniform variable of type float which holds the strength of the environment light
   *
   * @remarks
   * This function can only be used in the fragment shader
   *
   * @param scope - Current shader scope
   * @returns The uniform variable of which presents the strength of the environment light
   */ static getEnvLightStrength(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.envLightStrength;
    }
    /**
   * Gets the uniform variable of type vec3 which holds the camera position
   * @param scope - Current shader scope
   * @returns The camera position
   */ static getCameraPosition(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.position.xyz;
    }
    /**
   * Discard the fragment if it was clipped by the clip plane
   * @param scope - Current shader scope
   */ static discardIfClipped(scope, worldPos) {
        const funcName = 'Z_discardIfClippped';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcName, [
            pb.vec3('worldPos')
        ], function() {
            this.$if(pb.notEqual(that.getCameraClipPlaneFlag(this), 0), function() {
                this.$l.clipPlane = that.getCameraClipPlane(this);
                this.$if(pb.greaterThan(pb.add(pb.dot(this.worldPos.xyz, this.clipPlane.xyz), this.clipPlane.w), 0), function() {
                    pb.discard();
                });
            });
        });
        pb.getGlobalScope()[funcName](worldPos);
    }
    /**
   * Gets the clip plane flag
   * @param scope - Current shader scope
   * @returns A float value of 1 indices the clip plane presents, otherwise 0
   */ static getCameraClipPlaneFlag(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.position.w;
    }
    /**
   * Gets the clip plane
   * @param scope - Current shader scope
   * @returns A vec4 presents the clip plane
   */ static getCameraClipPlane(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.clipPlane;
    }
    /**
   * Gets the uniform variable of type vec4 which holds the camera parameters
   * @param scope - Current shader scope
   * @returns The camera parameters
   */ static getCameraParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.params;
    }
    /**
   * Gets the uniform variable of type vec4 which holds the fog color
   * @param scope - Current shader scope
   * @returns The fog color
   */ static getFogColor(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.fogColor;
    }
    /** @internal */ static getClusterParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.clusterParams;
    }
    /** @internal */ static getCountParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.countParams;
    }
    /** @internal */ static getClusteredLightIndexTexture(scope) {
        return scope[UNIFORM_NAME_LIGHT_INDEX_TEXTURE];
    }
    /**
   * Gets the uniform variable of type vec4 which holds the fog color
   * @param scope - Current shader scope
   * @returns The fog color
   */ static getFogType(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.fogType;
    }
    /**
   * Gets the aerial perspective LUT
   * @param scope - Current shader scope
   * @returns The aerial perspective LUT texture
   */ static getAerialPerspectiveLUT(scope) {
        return scope[UNIFORM_NAME_AERIALPERSPECTIVE_LUT];
    }
    /**
   * Gets the uniform variable of type vec4 which holds the fog parameters
   * @param scope - Current shader scope
   * @returns The fog parameters
   */ static getFogParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.fogParams;
    }
    /**
   * Gets the uniform variable of type float which holds the aerial perspective density
   * @param scope - Current shader scope
   * @returns aerial perspective density
   */ static getAPDensity(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.apDensity;
    }
    /**
   * Computes the fog factor for a given view vector
   * @param scope - Current shader scope
   * @param viewDir - the view vector
   * @param fogType - Type of the fog
   * @param fogParams - Fog parameters [start, end, top, density]
   * @returns The computed fog factor
   */ static computeFogFactor(scope, viewDir, fogType, fogParams) {
        const pb = scope.$builder;
        const funcName = 'Z_computeFogFactor';
        const that = this;
        pb.func(funcName, [
            pb.vec3('viewDir'),
            pb.int('fogType'),
            pb.vec4('fogParams')
        ], function() {
            this.$l.distance = pb.length(this.viewDir);
            this.$l.top = pb.max(this.viewDir.y, 0.0001);
            this.$l.distance = pb.mul(this.$l.distance, pb.min(1, pb.div(this.fogParams.z, this.top)));
            this.$if(pb.equal(this.fogType, that.FOG_TYPE_LINEAR), function() {
                this.$return(pb.clamp(pb.div(pb.sub(this.distance, this.fogParams.x), pb.sub(this.fogParams.y, this.fogParams.x)), 0, 1));
            }).$elseif(pb.equal(this.fogType, that.FOG_TYPE_EXP), function() {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(this.e))));
            }).$elseif(pb.equal(this.fogType, that.FOG_TYPE_EXP2), function() {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(pb.mul(this.e, this.e)))));
            }).$else(function() {
                this.$return(0);
            });
        });
        return pb.getGlobalScope()[funcName](viewDir, fogType, fogParams);
    }
    /**
   * Computes the fog factor with given type for a given view vector
   * @param scope - Current shader scope
   * @param viewDir - the view vector
   * @param fogParams - The fog params [start, end, top, density]
   * @param fogType - Type of the fog
   * @returns The computed fog factor
   */ static computeFogFactorForType(scope, viewDir, fogParams, fogType) {
        const pb = scope.$builder;
        const funcName = `Z_computeFogFactor${fogType[0].toUpperCase()}${fogType.slice(1)}`;
        pb.func(funcName, [
            pb.vec3('viewDir'),
            pb.vec4('fogParams')
        ], function() {
            this.$l.distance = pb.length(this.viewDir);
            this.$l.top = pb.max(this.viewDir.y, 0.0001);
            this.$l.distance = pb.mul(this.$l.distance, pb.min(1, pb.div(this.fogParams.z, this.top)));
            if (fogType === 'linear') {
                this.$return(pb.clamp(pb.div(pb.sub(this.distance, this.fogParams.x), pb.sub(this.fogParams.y, this.fogParams.x)), 0, 1));
            } else if (fogType === 'exp') {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(this.e))));
            } else if (fogType === 'exp2') {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(pb.mul(this.e, this.e)))));
            } else {
                this.$return(0);
            }
        });
        return pb.getGlobalScope()[funcName](viewDir, fogParams);
    }
    /**
   * Gets the uniform variable of type mat4 which holds the view projection matrix of current camera
   * @param scope - Current shader scope
   * @returns The view projection matrix of current camera
   */ static getViewProjectionMatrix(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.viewProjectionMatrix;
    }
    /**
   * Gets the uniform variable of type mat4 which holds the view matrix of current camera
   * @param scope - Current shader scope
   * @returns The view matrix of current camera
   */ static getViewMatrix(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.viewMatrix;
    }
    /**
   * Gets the uniform variable of type mat4 which holds the projection matrix of current camera
   * @param scope - Current shader scope
   * @returns The projection matrix of current camera
   */ static getProjectionMatrix(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.projectionMatrix;
    }
    /**
   * Gets the uniform variable of type mat4 which holds the view projection matrix of current camera
   * @param scope - Current shader scope
   * @returns The view projection matrix of current camera
   */ static getCameraRotationMatrix(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.rotationMatrix;
    }
    /** @internal */ static getCascadeDistances(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.cascadeDistances;
    }
    /** @internal */ static getDepthBiasValues(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.depthBiasValues;
    }
    /** @internal */ static getShadowCameraParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.shadowCameraParams;
    }
    /** @internal */ static getDepthBiasScales(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.depthBiasScales;
    }
    /** @internal */ static getNumLights(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.numLights;
    }
    /** @internal */ static getSunLightDir(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.sunDir;
    }
    /** @internal */ static getLightTypeForShadow(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.lightType;
    }
    /** @internal */ static getLightPositionAndRangeForShadow(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.positionAndRange;
    }
    /** @internal */ static getLightViewMatrixForShadow(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.viewMatrix;
    }
    /** @internal */ static calculateShadowSpaceVertex(scope, worldPos, cascade = 0) {
        const pb = scope.$builder;
        return pb.vec4(pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 0)), worldPos), pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 1)), worldPos), pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 2)), worldPos), pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 3)), worldPos));
    }
    /** @internal */ static getLightPositionAndRange(scope, lightIndex) {
        return scope[UNIFORM_NAME_LIGHT_BUFFER].at(scope.$builder.mul(lightIndex, 3));
    }
    /** @internal */ static getLightDirectionAndCutoff(scope, lightIndex) {
        return scope[UNIFORM_NAME_LIGHT_BUFFER].at(scope.$builder.add(scope.$builder.mul(lightIndex, 3), 1));
    }
    /** @internal */ static getLightColorAndIntensity(scope, lightIndex) {
        return scope[UNIFORM_NAME_LIGHT_BUFFER].at(scope.$builder.add(scope.$builder.mul(lightIndex, 3), 2));
    }
    /**
   * Sets the clip space position in vertex shader
   *
   * @remarks
   * Use this function instead of using
   * <pre>
   * // Do not use this
   * this.$builtins.position = some_value;
   * // Use this
   * ShaderFramework.setClipSpacePosition(some_value);
   * </pre>,
   *
   * @param scope - Current shader scope
   * @param pos - The clip space position to be set
   */ static setClipSpacePosition(scope, pos) {
        const pb = scope.$builder;
        const cameraParams = this.getCameraParams(scope);
        if (cameraParams) {
            scope.$builtins.position = pb.mul(pos, pb.vec4(1, cameraParams.z, 1, 1));
        } else {
            scope.$builtins.position = pos;
        }
    }
    /** @internal */ static getSkinMatrix(scope) {
        const pb = scope.$builder;
        const funcNameGetBoneMatrixFromTexture = 'Z_getBoneMatrixFromTexture';
        pb.func(funcNameGetBoneMatrixFromTexture, [
            pb.int('boneIndex')
        ], function() {
            const boneTexture = this[UNIFORM_NAME_BONE_MATRICES];
            this.$l.w = pb.float(this[UNIFORM_NAME_BONE_TEXTURE_SIZE]);
            this.$l.pixelIndex = pb.float(pb.mul(this.boneIndex, 4));
            this.$l.xIndex = pb.mod(this.pixelIndex, this.w);
            this.$l.yIndex = pb.floor(pb.div(this.pixelIndex, this.w));
            this.$l.u1 = pb.div(pb.add(this.xIndex, 0.5), this.w);
            this.$l.u2 = pb.div(pb.add(this.xIndex, 1.5), this.w);
            this.$l.u3 = pb.div(pb.add(this.xIndex, 2.5), this.w);
            this.$l.u4 = pb.div(pb.add(this.xIndex, 3.5), this.w);
            this.$l.v = pb.div(pb.add(this.yIndex, 0.5), this.w);
            if (Application.instance.device.type !== 'webgl') {
                this.$l.row1 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u1, this.v), 0);
                this.$l.row2 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u2, this.v), 0);
                this.$l.row3 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u3, this.v), 0);
                this.$l.row4 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u4, this.v), 0);
            } else {
                this.$l.row1 = pb.textureSample(boneTexture, pb.vec2(this.u1, this.v));
                this.$l.row2 = pb.textureSample(boneTexture, pb.vec2(this.u2, this.v));
                this.$l.row3 = pb.textureSample(boneTexture, pb.vec2(this.u3, this.v));
                this.$l.row4 = pb.textureSample(boneTexture, pb.vec2(this.u4, this.v));
            }
            this.$return(pb.mat4(this.row1, this.row2, this.row3, this.row4));
        });
        const funcNameGetSkinningMatrix = 'Z_getSkinningMatrix';
        pb.func(funcNameGetSkinningMatrix, [], function() {
            const invBindMatrix = this[UNIFORM_NAME_BONE_INV_BIND_MATRIX];
            const blendIndices = pb.getGlobalScope().$getVertexAttrib('blendIndices');
            const blendWeights = pb.getGlobalScope().$getVertexAttrib('blendWeights');
            this.$l.m0 = pb.getGlobalScope()[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[0]));
            this.$l.m1 = pb.getGlobalScope()[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[1]));
            this.$l.m2 = pb.getGlobalScope()[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[2]));
            this.$l.m3 = pb.getGlobalScope()[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[3]));
            this.$l.m = pb.add(pb.mul(this.m0, blendWeights.x), pb.mul(this.m1, blendWeights.y), pb.mul(this.m2, blendWeights.z), pb.mul(this.m3, blendWeights.w));
            this.$return(pb.mul(invBindMatrix, this.m));
        });
        return pb.getGlobalScope()[funcNameGetSkinningMatrix]();
    }
    /**
   * Get global uniforms
   *
   * @param scope - Shader scope
   */ static getGlobalUniforms(scope) {
        return scope[UNIFORM_NAME_GLOBAL];
    }
    /**
   * Get shadow map uniform value
   *
   * @param scope - Shader scope
   * @returns The shadow map texture uniform
   */ static getShadowMap(scope) {
        return scope[UNIFORM_NAME_SHADOW_MAP];
    }
    /**
   * Calculates shadow of current fragment
   *
   * @param scope - Shader scope
   * @param NoL - NdotL vector
   * @returns Shadow of current fragment, 1 means no shadow and 0 means full shadowed.
   */ static calculateShadow(scope, worldPos, NoL, ctx) {
        const pb = scope.$builder;
        const that = this;
        const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
        const funcName = 'Z_calculateShadow';
        pb.func(funcName, [
            pb.vec3('worldPos'),
            pb.float('NoL')
        ], function() {
            if (shadowMapParams.numShadowCascades > 1) {
                this.$l.shadowCascades = that.getGlobalUniforms(this).light.shadowCascades;
                this.$l.shadowBound = pb.vec4(0, 0, 1, 1);
                this.$l.linearDepth = that.nonLinearDepthToLinear(this, this.$builtins.fragCoord.z);
                this.$l.splitDistances = that.getCascadeDistances(this);
                this.$l.comparison = pb.vec4(pb.greaterThan(pb.vec4(this.linearDepth), this.splitDistances));
                this.$l.cascadeFlags = pb.vec4(pb.float(pb.greaterThan(this.shadowCascades, 0)), pb.float(pb.greaterThan(this.shadowCascades, 1)), pb.float(pb.greaterThan(this.shadowCascades, 2)), pb.float(pb.greaterThan(this.shadowCascades, 3)));
                this.$l.split = pb.int(pb.dot(this.comparison, this.cascadeFlags));
                if (Application.instance.device.type === 'webgl') {
                    this.$l.shadowVertex = pb.vec4();
                    this.$for(pb.int('cascade'), 0, 4, function() {
                        this.$if(pb.equal(this.cascade, this.split), function() {
                            this.shadowVertex = that.calculateShadowSpaceVertex(this, pb.vec4(this.worldPos, 1), this.cascade);
                            this.$break();
                        });
                    });
                } else {
                    this.$l.shadowVertex = that.calculateShadowSpaceVertex(this, pb.vec4(this.worldPos, 1), this.split);
                }
                const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
                this.$l.shadow = shadowMapParams.impl.computeShadowCSM(shadowMapParams, this, this.shadowVertex, this.NoL, this.split);
                this.$l.shadowDistance = that.getShadowCameraParams(scope).w;
                this.shadow = pb.mix(this.shadow, 1, pb.smoothStep(pb.mul(this.shadowDistance, 0.8), this.shadowDistance, pb.distance(that.getCameraPosition(this), this.worldPos)));
                this.$return(this.shadow);
            } else {
                this.$l.shadowVertex = that.calculateShadowSpaceVertex(this, pb.vec4(this.worldPos, 1));
                const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
                this.$l.shadow = shadowMapParams.impl.computeShadow(shadowMapParams, this, this.shadowVertex, this.NoL);
                this.$l.shadowDistance = that.getShadowCameraParams(scope).w;
                this.shadow = pb.mix(this.shadow, 1, pb.smoothStep(pb.mul(this.shadowDistance, 0.8), this.shadowDistance, pb.distance(that.getCameraPosition(this), this.worldPos)));
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcName](worldPos, NoL);
    }
    static applyFog(scope, worldPos, color, ctx) {
        if (ctx.applyFog) {
            const pb = scope.$builder;
            const that = this;
            if (ctx.env.sky.drawScatteredFog(ctx)) {
                const funcName = 'Z_applySkyFog';
                pb.func(funcName, [
                    pb.vec3('worldPos'),
                    pb.vec4('color').inout()
                ], function() {
                    this.$l.viewDir = pb.sub(this.worldPos, that.getCameraPosition(this));
                    this.viewDir.y = pb.max(this.viewDir.y, 0);
                    this.$l.distance = pb.mul(pb.length(this.viewDir), that.getAPDensity(this));
                    this.$l.sliceDist = pb.div(pb.mul(that.getCameraParams(this).y, that.getAPDensity(this)), ScatteringLut.aerialPerspectiveSliceZ);
                    this.$l.slice0 = pb.floor(pb.div(this.distance, this.sliceDist));
                    this.$l.slice1 = pb.add(this.slice0, 1);
                    this.$l.factor = pb.sub(pb.div(this.distance, this.sliceDist), this.slice0);
                    this.$l.viewNormal = pb.normalize(this.viewDir);
                    this.$l.horizonAngle = pb.acos(pb.clamp(pb.dot(pb.normalize(that.getSunLightDir(this).xz), pb.normalize(this.viewNormal.xz)), 0, 1));
                    this.$l.zenithAngle = pb.asin(this.viewNormal.y);
                    this.$l.sliceU = pb.max(pb.div(this.horizonAngle, Math.PI * 2), 0.5 / ScatteringLut.aerialPerspectiveSliceZ);
                    this.$l.u0 = pb.div(pb.add(this.slice0, this.sliceU), ScatteringLut.aerialPerspectiveSliceZ);
                    this.$l.u1 = pb.add(this.u0, 1 / ScatteringLut.aerialPerspectiveSliceZ);
                    this.$l.v = pb.div(this.zenithAngle, Math.PI / 2);
                    this.$l.t0 = pb.textureSampleLevel(that.getAerialPerspectiveLUT(this), pb.vec2(this.u0, this.v), 0);
                    this.$l.t1 = pb.textureSampleLevel(that.getAerialPerspectiveLUT(this), pb.vec2(this.u1, this.v), 0);
                    this.$l.t = pb.mix(this.t0, this.t1, this.factor);
                    this.color = pb.vec4(pb.add(pb.mul(this.color.rgb, this.t.a), this.t.rgb), this.color.a);
                //this.color = pb.vec4(pb.vec3(pb.mix(this.u0, this.u1, this.factor)), this.color.a);
                });
                scope[funcName](worldPos, color);
            } else {
                const funcName = 'Z_applyFog';
                pb.func(funcName, [
                    pb.vec3('worldPos'),
                    pb.vec4('color').inout()
                ], function() {
                    this.$l.viewDir = pb.sub(this.worldPos, that.getCameraPosition(this));
                    this.$l.fogFactor = that.computeFogFactor(this, this.viewDir, that.getFogType(this), that.getFogParams(this));
                    this.color = pb.vec4(pb.mix(this.color.rgb, that.getFogColor(this).rgb, this.fogFactor), this.color.a);
                });
                scope[funcName](worldPos, color);
            }
        }
    }
    /**
   * Calculates the non-linear depth from linear depth
   *
   * @param scope - Current shader scope
   * @param depth - The linear depth
   * @param nearFar - A vector that contains the near clip plane in x component and the far clip plane in y component
   * @returns The calculated non-linear depth
   */ static linearDepthToNonLinear(scope, depth, nearFar) {
        const pb = scope.$builder;
        nearFar = nearFar ?? this.getCameraParams(scope);
        return pb.div(pb.sub(nearFar.y, pb.div(pb.mul(nearFar.x, nearFar.y), depth)), pb.sub(nearFar.y, nearFar.x));
    }
    /**
   * Calculates the linear depth from non-linear depth
   *
   * @param scope - Current shader scope
   * @param depth - The non-linear depth
   * @param nearFar - A vector that contains the near clip plane in x component and the far clip plane in y component
   * @returns The calculated linear depth
   */ static nonLinearDepthToLinear(scope, depth, nearFar) {
        const pb = scope.$builder;
        nearFar = nearFar ?? this.getCameraParams(scope);
        return pb.div(pb.mul(nearFar.x, nearFar.y), pb.mix(nearFar.y, nearFar.x, depth));
    }
    /**
   * Calculates the normalized linear depth from non-linear depth
   *
   * @param scope - Current shader scope
   * @param depth - The non-linear depth
   * @param nearFar - A vector that contains the near clip plane in x component and the far clip plane in y component
   * @returns The calculated normalized linear depth
   */ static nonLinearDepthToLinearNormalized(scope, depth, nearFar) {
        const pb = scope.$builder;
        nearFar = nearFar ?? this.getCameraParams(scope);
        return pb.div(nearFar.x, pb.mix(nearFar.y, nearFar.x, depth));
    }
    /**
   * Transform color to sRGB color space if nessesary
   *
   * @param scope - Current shader scope
   * @param outputColor - The color to be transformed
   * @returns The transformed color
   */ static encodeColorOutput(scope, outputColor) {
        const pb = scope.$builder;
        const that = this;
        const funcName = 'Z_encodeColorOutput';
        pb.func(funcName, [
            pb.vec4('outputColor')
        ], function() {
            const params = that.getCameraParams(this);
            this.$if(pb.notEqual(params.w, 0), function() {
                this.$return(pb.vec4(linearToGamma(this, this.outputColor.rgb), this.outputColor.w));
            }).$else(function() {
                this.$return(this.outputColor);
            });
        });
        return pb.getGlobalScope()[funcName](outputColor);
    }
}

class InstanceBindGroupPool {
    _bindGroups;
    _frameStamp;
    constructor(){
        this._bindGroups = [];
        this._frameStamp = -1;
    }
    apply(hash, index, worldMatrices) {
        const device = Application.instance.device;
        const maxSize = device.getDeviceCaps().shaderCaps.maxUniformBufferSize;
        if (device.frameInfo.frameCounter !== this._frameStamp) {
            this._frameStamp = device.frameInfo.frameCounter;
            for (const bindGroup of this._bindGroups){
                bindGroup.freeSize = maxSize;
            }
        }
        let bindGroupIndex = -1;
        for(let i = 0; i < this._bindGroups.length; i++){
            if (this._bindGroups[i].freeSize >= worldMatrices.length * 64) {
                bindGroupIndex = i;
                break;
            }
        }
        if (bindGroupIndex < 0) {
            const program = Material.getProgramByHashIndex(hash, index);
            const bindGroup = program?.bindGroupLayouts[3] ? device.createBindGroup(program.bindGroupLayouts[3]) : null;
            this._bindGroups.push({
                bindGroup: bindGroup,
                freeSize: maxSize
            });
            bindGroupIndex = this._bindGroups.length - 1;
        }
        const bindGroup = this._bindGroups[bindGroupIndex];
        const offset = (maxSize - bindGroup.freeSize) / 64;
        for (const matrix of worldMatrices){
            bindGroup.bindGroup.setRawData(ShaderHelper.getWorldMatricesUniformName(), maxSize - bindGroup.freeSize, matrix);
            bindGroup.freeSize -= 64;
        }
        device.setBindGroup(3, bindGroup.bindGroup);
        return offset;
    }
}
/**
 * Base class for any kind of materials
 *
 * @public
 */ class Material {
    /** @internal */ static _nextId = 0;
    /** @internal */ static _programMap = {};
    /** @internal */ static _drawableTimestamps = new WeakMap();
    /** @internal */ static _drawableIterators = new WeakMap();
    /** @internal */ static _drawableLRU = new List();
    /** @internal */ static _materialTimestamps = new WeakMap();
    /** @internal */ static _materialIterators = new WeakMap();
    /** @internal */ static _materialLRU = new List();
    /** @internal */ static _gcOptions = {
        disabled: true,
        drawableCountThreshold: 500,
        materialCountThreshold: 200,
        inactiveTimeDuration: 30000
    };
    /** @internal */ static _boneMatrixTextureSampler = null;
    /** @internal */ static _instanceBindGroupPool = new InstanceBindGroupPool();
    /** @internal */ static _drawableBindGroupMap = new WeakMap();
    /** @internal */ _numPasses;
    /** @internal */ _hash;
    /** @internal */ _renderStateSet;
    /** @internal */ _bindGroupMap;
    /** @internal */ _optionTag;
    /** @internal */ _materialBindGroup;
    /** @internal */ _id;
    /**
   * Creates an instance of material
   */ constructor(){
        this._id = ++Material._nextId;
        this._numPasses = 1;
        this._hash = [
            []
        ];
        this._renderStateSet = null;
        this._bindGroupMap = {};
        this._optionTag = 0;
        this._materialBindGroup = null;
    }
    /** Unique identifier of the material */ get id() {
        return this._id;
    }
    get numPasses() {
        return this._numPasses;
    }
    set numPasses(val) {
        while(this._hash.length < val){
            this._hash.push([]);
        }
        this._numPasses = val;
    }
    /** @internal */ getHash(renderPassType, pass) {
        if (this._hash[pass][renderPassType] === void 0) {
            this._hash[pass][renderPassType] = this.createHash(renderPassType, pass);
        }
        return this._hash[pass][renderPassType];
    }
    /** Render states associated to this material */ get stateSet() {
        if (!this._renderStateSet) {
            this._renderStateSet = this.createRenderStateSet();
        }
        return this._renderStateSet;
    }
    set stateSet(stateset) {
        this._renderStateSet = stateset;
    }
    getQueueType() {
        return QUEUE_OPAQUE;
    }
    /** Returns true if this is a transparency material */ isTransparentPass(pass) {
        return false;
    }
    /** Returns true if shading of the material will be affected by lights  */ supportLighting() {
        return true;
    }
    /** Returns true if this material supports geometry instancing  */ isBatchable() {
        return true;
    }
    /**
   * Draws a primitive using this material
   *
   * @param primitive - The prmitive to be drawn
   * @param ctx - The context of current drawing task
   * @param numInstances - How many instances should be drawn. if zero, the instance count will be automatically detected.
   */ draw(primitive, ctx, numInstances = 0) {
        for(let i = 0; i < this._numPasses; i++){
            if (this.beginDraw(i, ctx)) {
                this.drawPrimitive(i, primitive, ctx, numInstances);
                this.endDraw(i);
            }
        }
    }
    /**
   * Prepares for drawing
   * @param ctx - The context of current drawing task
   * @returns true if succeeded, otherwise false
   */ beginDraw(pass, ctx) {
        const numInstances = ctx.instanceData?.worldMatrices?.length || 1;
        const device = Application.instance.device;
        const programInfo = this.getOrCreateProgram(ctx, pass);
        if (programInfo) {
            const hash = programInfo.hash;
            if (!programInfo.programs[ctx.renderPass.type]) {
                return false;
            }
            if (pass > 0) {
                this.optionChanged(false);
            }
            this._materialBindGroup = this.applyMaterialBindGroups(ctx, hash, pass);
            if (pass === 0) {
                if (numInstances > 1) {
                    this.applyInstanceBindGroups(ctx, hash);
                } else {
                    this.applyDrawableBindGroups(ctx, hash);
                }
            }
            ctx.renderPass.applyRenderStates(device, this.stateSet, ctx);
            device.setProgram(programInfo.programs[ctx.renderPass.type]);
            Material._drawableTimestamps.set(ctx.target, ctx.timestamp);
            Material.lruPutDrawable(ctx.target);
            Material._materialTimestamps.set(this, ctx.timestamp);
            Material.lruPutMaterial(this);
            return true;
        }
        return false;
    }
    /**
   * Ends drawing a primitive
   */ endDraw(pass) {
        this._materialBindGroup = null;
    }
    /**
   * Gets the bind group of this material
   * @returns The bind group of this material
   */ getMaterialBindGroup() {
        return this._materialBindGroup;
    }
    /**
   * Sets all uniform values to the bind group of the material if needed
   * @param bindGroup - The bind group of the material
   * @param ctx - The context of current drawing task
   * @param needUpdate - true if the uniform values needs to update
   */ applyUniforms(bindGroup, ctx, needUpdate, pass) {
        if (needUpdate) {
            this._applyUniforms(bindGroup, ctx, pass);
        }
    }
    /**
   * Fetch the gpu program of the material for drawing
   * @param ctx - The context for current drawing task
   * @returns Information of the gpu program
   */ getOrCreateProgram(ctx, pass) {
        const programMap = Material._programMap;
        const renderPassType = ctx.renderPass.type;
        const hash = `${this.getHash(renderPassType, pass)}:${!!ctx.target.getBoneMatrices()}:${Number(!!(ctx.instanceData?.worldMatrices.length > 1))}:${ctx.renderPassHash}`;
        let programInfo = programMap[hash];
        if (!programInfo || programInfo.programs[renderPassType] === undefined) {
            const program = this.createProgram(ctx, pass) ?? null;
            if (!programInfo) {
                programInfo = {
                    programs: [
                        null,
                        null,
                        null
                    ],
                    hash
                };
                programMap[hash] = programInfo;
            }
            programInfo.programs[renderPassType] = program;
        }
        return programInfo;
    }
    dispose() {
        this.clearBindGroupCache();
    }
    /**
   * Sets the options of garbage collection
   * @param opt - The options to set
   */ static setGCOptions(opt) {
        this._gcOptions = Object.assign({}, this._gcOptions, opt || {});
    }
    /**
   * Gets the options of garbage collection
   * @returns The options of garbage collection
   */ static getGCOptions() {
        return this._gcOptions;
    }
    /**
   * Performs a garbage collection for this material
   * @param ts - Current time stamp
   * @returns How many bind groups have been garbage collected
   */ static garbageCollect(ts) {
        let n = 0;
        ts -= this._gcOptions.inactiveTimeDuration;
        while(this._drawableLRU.length > this._gcOptions.drawableCountThreshold){
            const iter = this._drawableLRU.begin();
            if (this._drawableTimestamps.get(iter.data) < ts) {
                const bindGroups = this._drawableBindGroupMap.get(iter.data);
                if (bindGroups) {
                    for(const k in bindGroups){
                        for (const bindGroup of bindGroups[k].bindGroup){
                            if (bindGroup) {
                                this.bindGroupGarbageCollect(bindGroup);
                                n++;
                            }
                        }
                    }
                }
                this._drawableBindGroupMap.delete(iter.data);
                this._drawableIterators.delete(iter.data);
                this._drawableLRU.remove(iter);
            } else {
                break;
            }
        }
        while(this._materialLRU.length > this._gcOptions.materialCountThreshold){
            const iter = this._materialLRU.begin();
            const mat = iter.data;
            if (this._materialTimestamps.get(mat) < ts && mat._bindGroupMap) {
                n += mat.clearBindGroupCache();
                this._materialIterators.delete(mat);
                this._materialLRU.remove(iter);
            } else {
                break;
            }
        }
        if (n > 0 && this._gcOptions.verbose) {
            console.log(`INFO: ${n} bind groups have been garbage collected`);
        }
        return n;
    }
    /** @internal */ optionChanged(changeHash) {
        this._optionTag++;
        if (changeHash) {
            for(let i = 0; i < this._numPasses; i++){
                this._hash[i] = [];
            }
        }
    }
    /** @internal */ static getProgramByHashIndex(hash, index) {
        return this._programMap[hash].programs[index];
    }
    /** @internal */ applyMaterialBindGroups(ctx, hash, pass) {
        const index = ctx.renderPass.type;
        let bindGroupInfo = this._bindGroupMap[hash];
        if (!bindGroupInfo) {
            // bindGroups not created or have been garbage collected
            const materialBindGroup = [
                RENDER_PASS_TYPE_LIGHT,
                RENDER_PASS_TYPE_SHADOWMAP,
                RENDER_PASS_TYPE_DEPTH
            ].map((k)=>{
                const program = Material._programMap[hash].programs[k];
                return program?.bindGroupLayouts[2] ? Application.instance.device.createBindGroup(program.bindGroupLayouts[2]) : null;
            });
            bindGroupInfo = this._bindGroupMap[hash] = {
                materialBindGroup,
                bindGroupTag: [
                    0,
                    0,
                    0
                ],
                materialTag: [
                    -1,
                    -1,
                    -1
                ]
            };
        }
        const bindGroup = bindGroupInfo.materialBindGroup[index];
        if (bindGroup) {
            this.applyUniforms(bindGroup, ctx, bindGroupInfo.materialTag[index] < this._optionTag || bindGroupInfo.bindGroupTag[index] !== bindGroup.cid, pass);
            bindGroupInfo.materialTag[index] = this._optionTag;
            bindGroupInfo.bindGroupTag[index] = bindGroup.cid;
            Application.instance.device.setBindGroup(2, bindGroup);
        } else {
            Application.instance.device.setBindGroup(2, null);
        }
        return bindGroup;
    }
    /** @internal */ getDrawableBindGroup(ctx, hash) {
        let drawableBindGroups = Material._drawableBindGroupMap.get(ctx.target);
        if (!drawableBindGroups) {
            drawableBindGroups = {};
            Material._drawableBindGroupMap.set(ctx.target, drawableBindGroups);
        }
        let drawableBindGroup = drawableBindGroups[hash];
        if (!drawableBindGroup) {
            const bindGroup = [
                RENDER_PASS_TYPE_LIGHT,
                RENDER_PASS_TYPE_SHADOWMAP,
                RENDER_PASS_TYPE_DEPTH
            ].map((k)=>{
                const program = Material._programMap[hash].programs[k];
                return program?.bindGroupLayouts[1] ? Application.instance.device.createBindGroup(program.bindGroupLayouts[1]) : null;
            });
            drawableBindGroup = drawableBindGroups[hash] = {
                bindGroup,
                bindGroupTag: [
                    0,
                    0,
                    0
                ],
                xformTag: [
                    -1,
                    -1,
                    -1
                ]
            };
        }
        return drawableBindGroup;
    }
    /** @internal */ applyInstanceBindGroups(ctx, hash) {
        const index = ctx.renderPass.type;
        const offset = Material._instanceBindGroupPool.apply(hash, index, ctx.instanceData.worldMatrices);
        const bindGroup = this.getDrawableBindGroup(ctx, hash).bindGroup?.[index];
        if (bindGroup) {
            bindGroup.setValue(ShaderHelper.getInstanceBufferOffsetUniformName(), offset);
            Application.instance.device.setBindGroup(1, bindGroup);
        } else {
            Application.instance.device.setBindGroup(1, null);
        }
    }
    /** @internal */ applyDrawableBindGroups(ctx, hash) {
        const device = Application.instance.device;
        const index = ctx.renderPass.type;
        const drawableBindGroup = this.getDrawableBindGroup(ctx, hash);
        if (drawableBindGroup.bindGroup) {
            const bindGroup = drawableBindGroup.bindGroup[index];
            if (drawableBindGroup.xformTag[index] < ctx.target.getXForm().getTag() || drawableBindGroup.bindGroupTag[index] !== bindGroup.cid) {
                bindGroup.setValue(ShaderHelper.getWorldMatrixUniformName(), ctx.target.getXForm().worldMatrix);
                drawableBindGroup.xformTag[index] = ctx.target.getXForm().getTag();
                drawableBindGroup.bindGroupTag[index] = bindGroup.cid;
            }
            const boneMatrices = ctx.target.getBoneMatrices();
            if (boneMatrices) {
                if (!Material._boneMatrixTextureSampler) {
                    Material._boneMatrixTextureSampler = device.createSampler({
                        magFilter: 'nearest',
                        minFilter: 'nearest',
                        mipFilter: 'none'
                    });
                }
                bindGroup.setTexture(ShaderHelper.getBoneMatricesUniformName(), boneMatrices);
                bindGroup.setValue(ShaderHelper.getBoneTextureSizeUniformName(), boneMatrices.width);
                bindGroup.setValue(ShaderHelper.getBoneInvBindMatrixUniformName(), ctx.target.getInvBindMatrix());
            }
            device.setBindGroup(1, bindGroup);
        } else {
            device.setBindGroup(1, null);
        }
        device.setBindGroup(3, null);
    }
    /**
   * Convert pass to hash
   * @param pass - pass number
   * @returns String hash
   */ passToHash(pass) {
        return String(pass);
    }
    /** @internal */ createHash(renderPassType, pass) {
        return `${this.constructor.name}|${this.passToHash(pass)}|${this._createHash(renderPassType)}`;
    }
    /** @internal */ clearBindGroupCache() {
        let n = 0;
        for(const k in this._bindGroupMap){
            for (const bindGroup of this._bindGroupMap[k].materialBindGroup){
                if (bindGroup) {
                    Material.bindGroupGarbageCollect(bindGroup);
                    n++;
                }
            }
        }
        this._bindGroupMap = {};
        return n;
    }
    /** @internal */ static bindGroupGarbageCollect(bindGroup) {
        const layout = bindGroup.getLayout();
        for (const entry of layout.entries){
            if (entry.buffer) {
                const buffer = bindGroup.getBuffer(entry.name);
                if (buffer) {
                    buffer.dispose();
                    bindGroup.setBuffer(entry.name, null);
                }
            }
        }
    }
    /** @internal */ static lruPutDrawable(drawable) {
        const iter = this._drawableIterators.get(drawable);
        if (iter) {
            this._drawableLRU.remove(iter);
        }
        this._drawableIterators.set(drawable, this._drawableLRU.append(drawable));
    }
    /** @internal */ static lruPutMaterial(material) {
        const iter = this._materialIterators.get(material);
        if (iter) {
            this._materialLRU.remove(iter);
        }
        this._materialIterators.set(material, this._materialLRU.append(material));
    }
    /**
   * Draw primitve
   *
   * @param primitive - Primitive to be drawn
   * @param ctx - Draw context
   */ drawPrimitive(pass, primitive, ctx, numInstances) {
        if (numInstances > 0) {
            primitive.drawInstanced(numInstances);
        } else if (ctx.instanceData?.worldMatrices.length > 1) {
            primitive.drawInstanced(ctx.instanceData.worldMatrices.length);
        } else {
            primitive.draw();
        }
    }
    /** @internal */ createProgram(ctx, pass) {
        const pb = new ProgramBuilder(Application.instance.device);
        return this._createProgram(pb, ctx, pass);
    }
    /** @internal */ createRenderStateSet() {
        return Application.instance.device.createRenderStateSet();
    }
    /**
   * Creates the shader program
   * @param pb - The program builder
   * @param ctx - The drawing context
   * @param func - The material func
   * @returns The created shader program
   */ _createProgram(pb, ctx, pass) {
        return null;
    }
    /**
   * Applies uniform values
   * @param bindGroup - The bind group
   * @param ctx - The drawing context
   */ _applyUniforms(bindGroup, ctx, pass) {}
    /**
   * Calculates the hash code of the shader program
   * @returns The hash code
   */ _createHash(renderPassType) {
        return '';
    }
}

/**
 * Apply material mixins to specific material class
 * @param target - Material class
 * @param mixins - mixins
 * @returns Mixed mesh material class
 *
 * @public
 */ function applyMaterialMixins(target, ...mixins) {
    let r = target;
    for (const m of mixins){
        r = m(r);
    }
    return r;
}
let FEATURE_ALPHATEST = 0;
let FEATURE_ALPHABLEND = 0;
let FEATURE_ALPHATOCOVERAGE = 0;
/**
 * Base class for any kind of mesh materials
 *
 * @public
 */ class MeshMaterial extends Material {
    /** @internal */ static NEXT_FEATURE_INDEX = 3;
    /** @internal */ _featureStates;
    /** @internal */ _alphaCutoff;
    /** @internal */ _blendMode;
    /** @internal */ _cullMode;
    /** @internal */ _opacity;
    /** @internal */ _ctx;
    /** @internal */ _materialPass;
    /**
   * Creates an instance of MeshMaterial class
   * @param args - constructor arguments
   */ constructor(...args){
        super();
        this._featureStates = [];
        this._alphaCutoff = 0;
        this._blendMode = 'none';
        this._cullMode = 'back';
        this._opacity = 1;
        this._ctx = null;
        this._materialPass = -1;
    }
    /** Indicate that the uniform has changed and needs to be resubmitted. */ uniformChanged() {
        this.optionChanged(false);
    }
    /** Define feature index */ static defineFeature() {
        const val = this.NEXT_FEATURE_INDEX;
        this.NEXT_FEATURE_INDEX++;
        return val;
    }
    /** Draw context for shader creation */ get drawContext() {
        return this._ctx;
    }
    /** Current material pass */ get pass() {
        return this._materialPass;
    }
    /** A value between 0 and 1, presents the cutoff for alpha testing */ get alphaCutoff() {
        return this._alphaCutoff;
    }
    set alphaCutoff(val) {
        if (this._alphaCutoff !== val) {
            this.useFeature(FEATURE_ALPHATEST, val > 0);
            this._alphaCutoff = val;
            this.uniformChanged();
        }
    }
    get alphaToCoverage() {
        return this.featureUsed(FEATURE_ALPHATOCOVERAGE);
    }
    set alphaToCoverage(val) {
        this.useFeature(FEATURE_ALPHATOCOVERAGE, !!val);
    }
    /** Blending mode */ get blendMode() {
        return this._blendMode;
    }
    set blendMode(val) {
        if (this._blendMode !== val) {
            this._blendMode = val;
            this.useFeature(FEATURE_ALPHABLEND, this._blendMode !== 'none' || this._opacity < 1);
        }
    }
    /** Cull mode */ get cullMode() {
        return this._cullMode;
    }
    set cullMode(val) {
        this._cullMode = val;
    }
    /** A value between 0 and 1, presents the opacity */ get opacity() {
        return this._opacity;
    }
    set opacity(val) {
        val = val < 0 ? 0 : val > 1 ? 1 : val;
        if (this._opacity !== val) {
            this._opacity = val;
            this.useFeature(FEATURE_ALPHABLEND, this._blendMode !== 'none' || this._opacity < 1);
            this.uniformChanged();
        }
    }
    /** Returns true if shading of the material will be affected by lights  */ supportLighting() {
        return true;
    }
    /**
   * Update render states according to draw context and current material pass
   * @param pass - Current material pass
   * @param ctx - Draw context
   */ updateRenderStates(pass, ctx) {
        const blending = this.featureUsed(FEATURE_ALPHABLEND) || ctx.lightBlending;
        const a2c = this.featureUsed(FEATURE_ALPHATOCOVERAGE);
        if (blending || a2c) {
            const blendingState = this.stateSet.useBlendingState();
            if (blending) {
                blendingState.enable(true);
                blendingState.setBlendFuncAlpha('zero', 'one');
                blendingState.setBlendEquation('add', 'add');
                if (this._blendMode === 'additive' || ctx.lightBlending) {
                    blendingState.setBlendFuncRGB('one', 'one');
                } else {
                    blendingState.setBlendFuncRGB('one', 'inv-src-alpha');
                }
            } else {
                blendingState.enable(false);
            }
            blendingState.enableAlphaToCoverage(a2c);
            if (blendingState.enabled) {
                this.stateSet.useDepthState().enableTest(true).enableWrite(false);
            } else {
                this.stateSet.defaultDepthState();
            }
        } else if (this.stateSet.blendingState?.enabled && !blending) {
            this.stateSet.defaultBlendingState();
            this.stateSet.defaultDepthState();
        }
        if (this._cullMode !== 'back') {
            this.stateSet.useRasterizerState().cullMode = this._cullMode;
        } else {
            this.stateSet.defaultRasterizerState();
        }
    }
    /**
   * Submit Uniform values before rendering with this material.
   *
   * @param bindGroup - Bind group for this material
   * @param ctx - Draw context
   * @param pass - Current pass of the material
   */ applyUniformValues(bindGroup, ctx, pass) {
        if (this.featureUsed(FEATURE_ALPHATEST)) {
            bindGroup.setValue('zAlphaCutoff', this._alphaCutoff);
        }
        if (this.featureUsed(FEATURE_ALPHABLEND)) {
            bindGroup.setValue('zOpacity', this._opacity);
        }
    }
    /**
   * Determine which queue should be used to render this material.
   * @returns QUEUE_TRANSPARENT or QUEUE_OPAQUE
   */ getQueueType() {
        return this.isTransparentPass(0) ? QUEUE_TRANSPARENT : QUEUE_OPAQUE;
    }
    /**
   * Determine if a certain pass of this material is translucent.
   * @param pass - Pass of the material
   * @returns True if it is translucent, otherwise false.
   */ isTransparentPass(pass) {
        return this.featureUsed(FEATURE_ALPHABLEND);
    }
    /**
   * {@inheritdoc Material.beginDraw}
   */ beginDraw(pass, ctx) {
        this.updateRenderStates(pass, ctx);
        return super.beginDraw(pass, ctx);
    }
    /** @internal */ createProgram(ctx, pass) {
        const pb = new ProgramBuilder(Application.instance.device);
        if (ctx.renderPass.type === RENDER_PASS_TYPE_SHADOWMAP) {
            const shadowMapParams = ctx.shadowMapInfo.get(ctx.renderPass.light);
            pb.emulateDepthClamp = !!shadowMapParams.depthClampEnabled;
        }
        return this._createProgram(pb, ctx, pass);
    }
    /**
   * Check if a feature is in use for given render pass type.
   *
   * @param feature - The feature index
   * @returns true if the feature is in use, otherwise false.
   */ featureUsed(feature) {
        return this._featureStates[feature];
    }
    /**
   * Use or unuse a feature of the material, this will cause the shader to be rebuild.
   *
   * @param feature - Which feature will be used or unused
   * @param use - true if use the feature, otherwise false
   */ useFeature(feature, use) {
        if (this._featureStates[feature] !== use) {
            this._featureStates[feature] = use;
            this.optionChanged(true);
        }
    }
    /**
   * {@inheritDoc Material._createHash}
   * @override
   *
   * @internal
   */ _createHash(renderPassType) {
        return this._featureStates.map((val)=>val === undefined ? '' : val).join('|');
    }
    /**
   * {@inheritDoc Material._applyUniforms}
   * @override
   *
   * @internal
   */ _applyUniforms(bindGroup, ctx, pass) {
        this.applyUniformValues(bindGroup, ctx, pass);
    }
    /**
   * Check if the color should be computed in fragment shader, this is required for forward render pass or alpha test is in use or alpha to coverage is in use.
   *
   * @returns - true if the color should be computed in fragment shader, otherwise false.
   */ needFragmentColor(ctx) {
        return (ctx ?? this.drawContext).renderPass.type === RENDER_PASS_TYPE_LIGHT || this._alphaCutoff > 0 || this.alphaToCoverage;
    }
    /**
   * Vertex shader implementation of this material
   * @param scope - Shader scope
   */ vertexShader(scope) {
        const pb = scope.$builder;
        ShaderHelper.prepareVertexShader(pb, this.drawContext);
        if (this.drawContext.target.getBoneMatrices()) {
            scope.$inputs.zBlendIndices = pb.vec4().attrib('blendIndices');
            scope.$inputs.zBlendWeights = pb.vec4().attrib('blendWeights');
        }
    }
    /**
   * Fragment shader implementation of this material
   * @param scope - Shader scope
   */ fragmentShader(scope) {
        const pb = scope.$builder;
        ShaderHelper.prepareFragmentShader(pb, this.drawContext);
        if (this._alphaCutoff > 0) {
            scope.zAlphaCutoff = pb.float().uniform(2);
        }
        if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
            if (this.isTransparentPass(this.pass)) {
                scope.zOpacity = pb.float().uniform(2);
            }
        }
    }
    /**
   * {@inheritDoc Material._createProgram}
   * @override
   *
   * @internal
   */ _createProgram(pb, ctx, pass) {
        const that = this;
        this._ctx = ctx;
        this._materialPass = pass;
        const program = pb.buildRenderProgram({
            vertex (pb) {
                pb.main(function() {
                    that.vertexShader(this);
                });
            },
            fragment (pb) {
                this.$outputs.zFragmentOutput = pb.vec4();
                pb.main(function() {
                    that.fragmentShader(this);
                });
            }
        });
        /*
    if (program) {
      console.log(program.getShaderSource('vertex'));
      console.log(program.getShaderSource('fragment'));
    }
    */ return program;
    }
    /**
   * Calculate final fragment color for output.
   *
   * @param scope - Shader scope
   * @param color - Lit fragment color
   *
   * @returns The final fragment color
   */ outputFragmentColor(scope, worldPos, color) {
        const pb = scope.$builder;
        const that = this;
        const funcName = 'Z_outputFragmentColor';
        pb.func(funcName, color ? [
            pb.vec3('worldPos'),
            pb.vec4('color')
        ] : [
            pb.vec3('worldPos')
        ], function() {
            this.$l.outColor = color ? this.color : pb.vec4();
            if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                ShaderHelper.discardIfClipped(this, this.worldPos);
                if (!that.isTransparentPass(that.pass) && !this.zAlphaCutoff && !that.alphaToCoverage) {
                    this.outColor.a = 1;
                } else if (this.zOpacity) {
                    this.outColor.a = pb.mul(this.outColor.a, this.zOpacity);
                }
                if (this.zAlphaCutoff) {
                    this.$if(pb.lessThan(this.outColor.a, this.zAlphaCutoff), function() {
                        pb.discard();
                    });
                }
                if (that.isTransparentPass(that.pass)) {
                    this.outColor = pb.vec4(pb.mul(this.outColor.rgb, this.outColor.a), this.outColor.a);
                }
                ShaderHelper.applyFog(this, this.worldPos, this.outColor, that.drawContext);
                this.$outputs.zFragmentOutput = ShaderHelper.encodeColorOutput(this, this.outColor);
            } else if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_DEPTH) {
                if (color) {
                    this.$if(pb.lessThan(this.outColor.a, this.zAlphaCutoff), function() {
                        pb.discard();
                    });
                }
                ShaderHelper.discardIfClipped(this, this.worldPos);
                this.$l.depth = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.$builtins.fragCoord.z);
                if (Application.instance.device.type === 'webgl') {
                    this.$outputs.zFragmentOutput = encodeNormalizedFloatToRGBA(this, this.depth);
                } else {
                    this.$outputs.zFragmentOutput = pb.vec4(this.depth, 0, 0, 1);
                }
            } else {
                if (color) {
                    this.$if(pb.lessThan(this.outColor.a, this.zAlphaCutoff), function() {
                        pb.discard();
                    });
                }
                ShaderHelper.discardIfClipped(this, this.worldPos);
                const shadowMapParams = that.drawContext.shadowMapInfo.get(that.drawContext.renderPass.light);
                this.$outputs.zFragmentOutput = shadowMapParams.impl.computeShadowMapDepth(shadowMapParams, this, this.worldPos);
            }
        });
        color ? pb.getGlobalScope()[funcName](worldPos, color) : pb.getGlobalScope()[funcName](worldPos);
    }
}
FEATURE_ALPHATEST = MeshMaterial.defineFeature();
FEATURE_ALPHABLEND = MeshMaterial.defineFeature();
FEATURE_ALPHATOCOVERAGE = MeshMaterial.defineFeature();

/**
 * Texture property mixin
 * @param name - Texture name
 * @returns Texture mixin
 *
 * @public
 */ function mixinTextureProps(name) {
    return function(BaseCls, vertex = false) {
        const capName = `${name[0].toUpperCase()}${name.slice(1)}`;
        const id = `mixinTexture${capName}`;
        let feature = 0;
        let featureTexIndex = 0;
        let featureTexMatrix = 0;
        if (BaseCls[id]) {
            return BaseCls;
        }
        const cls = class extends BaseCls {
            constructor(...args){
                super(...args);
            }
            vertexShader(scope) {
                super.vertexShader(scope);
                if (vertex || this.needFragmentColor()) {
                    const pb = scope.$builder;
                    const that = this;
                    if (this.featureUsed(feature)) {
                        const texCoordIndex = that[`${name}TexCoordIndex`];
                        if (texCoordIndex >= 0) {
                            const semantic = `texCoord${that[`${name}TexCoordIndex`]}`;
                            if (!scope.$getVertexAttrib(semantic)) {
                                scope.$inputs[semantic] = pb.vec2().attrib(semantic);
                            }
                            if (this.featureUsed(featureTexMatrix)) {
                                scope[`z${capName}TextureMatrix`] = pb.mat4().uniform(2);
                                if (!vertex) {
                                    scope.$outputs[`z${capName}TexCoord`] = pb.mul(scope[`z${capName}TextureMatrix`], pb.vec4(scope.$inputs[semantic], 0, 1)).xy;
                                }
                            } else if (!vertex) {
                                scope.$outputs[`z${capName}TexCoord`] = scope.$inputs[semantic];
                            }
                        }
                    }
                }
            }
            fragmentShader(scope) {
                super.fragmentShader(scope);
                if (this.needFragmentColor()) {
                    const pb = scope.$builder;
                    if (this.featureUsed(feature)) {
                        scope[`z${capName}Tex`] = pb.tex2D().uniform(2);
                    }
                }
            }
            applyUniformValues(bindGroup, ctx, pass) {
                super.applyUniformValues(bindGroup, ctx, pass);
                if (this.needFragmentColor(ctx)) {
                    if (this.featureUsed(feature)) {
                        const that = this;
                        bindGroup.setTexture(`z${capName}Tex`, that[`${name}Texture`], that[`${name}TextureSampler`]);
                        if (this.featureUsed(featureTexMatrix)) {
                            bindGroup.setValue(`z${capName}TextureMatrix`, that[`${name}TexCoordMatrix`]);
                        }
                    }
                }
            }
        };
        feature = cls.defineFeature();
        featureTexIndex = cls.defineFeature();
        featureTexMatrix = cls.defineFeature();
        const proto = cls.prototype;
        const propTexture = `__${name}Texture`;
        const propSampler = `__${name}Sampler`;
        const propTexCoord = `__${name}TexCoordIndex`;
        const propMatrix = `__${name}TexMatrix`;
        proto[propTexture] = null;
        proto[propSampler] = null;
        proto[propTexCoord] = 0;
        proto[propMatrix] = null;
        proto[`sample${capName}Texture`] = function(scope, texCoord) {
            const tex = this[`get${capName}TextureUniform`](scope);
            const coord = texCoord ?? this[`get${capName}TexCoord`](scope);
            return scope.$builder.textureSample(tex, coord);
        };
        proto[`get${capName}TextureUniform`] = function(scope) {
            return scope.$builder.shaderKind === 'fragment' ? scope[`z${capName}Tex`] : null;
        };
        proto[`get${capName}TexCoord`] = function(scope) {
            if (proto[propTexCoord] < 0) {
                return null;
            }
            const pb = scope.$builder;
            if (pb.shaderKind === 'vertex' !== !!vertex) {
                throw new Error(`mixinTextureProps.get${capName}TexCoord(): must be called in ${vertex ? 'vertex' : 'fragment'} stage`);
            }
            return scope.$builder.shaderKind === 'fragment' ? scope.$inputs[`z${capName}TexCoord`] : this.featureUsed(featureTexMatrix) ? pb.mul(scope[`z${capName}TextureMatrix`], pb.vec4(scope.$inputs[`texCoord${proto[propTexCoord]}`], 0, 1)).xy : scope.$inputs[`texCoord${proto[propTexCoord]}`];
        };
        Object.defineProperty(proto, `${name}Texture`, {
            get: function() {
                return this[propTexture];
            },
            set: function(newValue) {
                if (this[propTexture] !== newValue) {
                    this[propTexture] = newValue ?? null;
                    this.useFeature(feature, !!this[propTexture]);
                    if (this[propTexture]) {
                        this.useFeature(featureTexIndex, this[propTexCoord]);
                        this.useFeature(featureTexMatrix, !!this[propMatrix]);
                        this.uniformChanged();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, `${name}TextureSampler`, {
            get: function() {
                return this[propSampler];
            },
            set: function(newValue) {
                this[propSampler] = newValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, `${name}TexCoordMatrix`, {
            get: function() {
                return this[propMatrix];
            },
            set: function(newValue) {
                if (this[propMatrix] !== newValue) {
                    this[propMatrix] = newValue;
                    this.useFeature(featureTexMatrix, !!this[propMatrix]);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, `${name}TexCoordIndex`, {
            get: function() {
                return this[propTexCoord];
            },
            set: function(newValue) {
                if (this[propTexCoord] !== newValue) {
                    this[propTexCoord] = newValue;
                    this.useFeature(featureTexIndex, this[propTexCoord]);
                }
            },
            enumerable: true,
            configurable: true
        });
        cls[id] = true;
        return cls;
    };
}

/**
 * Albedo color mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 *
 * @public
 */ function mixinAlbedoColor(BaseCls) {
    if (BaseCls.albedoColorMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinTextureProps('albedo'));
    return class extends S {
        static albedoColorMixed = true;
        _albedoColor;
        constructor(){
            super();
            this._albedoColor = Vector4.one();
        }
        /** Albedo color */ get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(val) {
            this._albedoColor.set(val);
            this.uniformChanged();
        }
        calculateAlbedoColor(scope, uv) {
            const pb = scope.$builder;
            if (!this.needFragmentColor()) {
                console.warn('mixinAlbedoColor.calculateAlbedoColor(): No need to calculate albedo color, make sure needFragmentColor() returns true');
                return pb.vec4(1);
            }
            let color = scope.zAlbedo;
            if (this.albedoTexture) {
                color = pb.mul(color, this.sampleAlbedoTexture(scope, uv));
            }
            return color;
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            if (this.needFragmentColor()) {
                const pb = scope.$builder;
                scope.zAlbedo = pb.vec4().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zAlbedo', this._albedoColor);
            }
        }
    };
}

/**
 * Light mixin
 * @param BaseCls - class to mix in
 * @returns Mixed class
 * @public
 */ function mixinLight(BaseCls) {
    if (BaseCls.lightMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinAlbedoColor, mixinTextureProps('normal'));
    let FEATURE_DOUBLE_SIDED_LIGHTING = 0;
    let FEATURE_OBJECT_SPACE_NORMALMAP = 0;
    const cls = class extends S {
        static lightMixed = true;
        _normalScale;
        constructor(){
            super();
            this._normalScale = 1;
            this.useFeature(FEATURE_DOUBLE_SIDED_LIGHTING, true);
        }
        get normalScale() {
            return this._normalScale;
        }
        set normalScale(val) {
            if (val !== this._normalScale) {
                this._normalScale = val;
                this.uniformChanged();
            }
        }
        get normalMapMode() {
            return this.featureUsed(FEATURE_OBJECT_SPACE_NORMALMAP);
        }
        set normalMapMode(val) {
            this.useFeature(FEATURE_OBJECT_SPACE_NORMALMAP, val);
        }
        /** true if double sided lighting is used */ get doubleSidedLighting() {
            return this.featureUsed(FEATURE_DOUBLE_SIDED_LIGHTING);
        }
        set doubleSidedLighting(val) {
            this.useFeature(FEATURE_DOUBLE_SIDED_LIGHTING, !!val);
        }
        /**
     * Calculates the normalized vector from world coordinates to the viewpoint.
     *
     * @param scope - Shader scope
     *
     * @returns The view vector
     */ calculateViewVector(scope, worldPos) {
            const pb = scope.$builder;
            return pb.normalize(pb.sub(ShaderHelper.getCameraPosition(scope), worldPos.xyz));
        }
        /**
     * Calculate the reflection vector of the view vector with respect to the normal.
     *
     * @param scope - Shader scope
     * @param normal - Surface normal
     * @param viewVec - The view vector
     * @returns The reflection vector
     */ calculateReflectionVector(scope, normal, viewVec) {
            const pb = scope.$builder;
            return pb.reflect(pb.neg(viewVec), normal);
        }
        /**
     * Calculate the normal vector for current fragment
     * @param scope - The shader scope
     * @returns Normal vector for current fragment
     */ calculateNormal(scope, worldPos, worldNormal, worldTangent, worldBinormal) {
            const pb = scope.$builder;
            const that = this;
            const args = [
                worldPos
            ];
            const params = [
                pb.vec3('worldPos')
            ];
            let funcName = 'Z_calculateNormal';
            if (worldNormal) {
                params.push(pb.vec3('worldNormal'));
                args.push(worldNormal);
                funcName += '_N';
                if (worldTangent && worldBinormal) {
                    params.push(pb.vec3('worldTangent'), pb.vec3('worldBinormal'));
                    args.push(worldTangent, worldBinormal);
                    funcName += '_T';
                }
            }
            pb.func(funcName, params, function() {
                this.$l.uv = that.normalTexture ? that.getNormalTexCoord(this) ?? pb.vec2(0) : that.albedoTexture ? that.getAlbedoTexCoord(this) ?? pb.vec2(0) : pb.vec2(0);
                this.$l.TBN = that.calculateTBN(this, this.worldPos, this.worldNormal, this.worldTangent, this.worldBinormal);
                if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && that.normalTexture) {
                    if (that.normalMapMode === 'object-space') {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(pb.normalize(normalTex));
                    } else {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(pb.normalize(pb.mul(this.TBN, normalTex)));
                    }
                } else {
                    this.$return(this.TBN[2]);
                }
            });
            return pb.getGlobalScope()[funcName](...args);
        }
        /**
     * Calculate the normal vector for current fragment
     *
     * @param scope - The shader scope
     * @returns Structure that contains normal vector and TBN matrix
     */ calculateNormalAndTBN(scope, worldPos, worldNormal, worldTangent, worldBinormal) {
            const pb = scope.$builder;
            const NormalStruct = pb.defineStruct([
                pb.mat3('TBN'),
                pb.vec3('normal')
            ]);
            const that = this;
            const args = [
                worldPos.xyz
            ];
            const params = [
                pb.vec3('worldPos')
            ];
            let funcName = 'Z_calculateNormalAndTBN';
            if (worldNormal) {
                params.push(pb.vec3('worldNormal'));
                args.push(worldNormal);
                funcName += '_N';
                if (worldTangent && worldBinormal) {
                    params.push(pb.vec3('worldTangent'), pb.vec3('worldBinormal'));
                    args.push(worldTangent, worldBinormal);
                    funcName += '_T';
                }
            }
            pb.func(funcName, params, function() {
                this.$l.uv = that.normalTexture ? that.getNormalTexCoord(this) ?? pb.vec2(0) : that.albedoTexture ? that.getAlbedoTexCoord(this) ?? pb.vec2(0) : pb.vec2(0);
                this.$l.TBN = that.calculateTBN(this, this.worldPos, this.worldNormal, this.worldTangent, this.worldBinormal);
                if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && that.normalTexture) {
                    if (that.normalMapMode === 'object-space') {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(NormalStruct(this.TBN, pb.normalize(normalTex)));
                    } else {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(NormalStruct(this.TBN, pb.normalize(pb.mul(this.TBN, normalTex))));
                    }
                } else {
                    this.$return(NormalStruct(this.TBN, this.TBN[2]));
                }
            });
            return pb.getGlobalScope()[funcName](...args);
        }
        /**
     * Calculate the TBN matrix
     *
     * @param scope - The shader scope
     * @returns TBN matrix
     */ calculateTBN(scope, worldPos, worldNormal, worldTangent, worldBinormal) {
            const pb = scope.$builder;
            const that = this;
            const args = [
                worldPos.xyz
            ];
            const params = [
                pb.vec3('worldPos')
            ];
            let funcName = 'Z_calculateTBN';
            if (worldNormal) {
                params.push(pb.vec3('worldNormal'));
                args.push(worldNormal);
                funcName += '_N';
                if (worldTangent && worldBinormal) {
                    params.push(pb.vec3('worldTangent'), pb.vec3('worldBinormal'));
                    args.push(worldTangent, worldBinormal);
                    funcName += '_T';
                }
            }
            pb.func(funcName, params, function() {
                const posW = this.worldPos;
                this.$l.uv = that.normalTexture ? that.getNormalTexCoord(this) ?? pb.vec2(0) : that.albedoTexture ? that.getAlbedoTexCoord(this) ?? pb.vec2(0) : pb.vec2(0);
                this.$l.TBN = pb.mat3();
                if (!worldNormal) {
                    this.$l.uv_dx = pb.dpdx(pb.vec3(this.uv, 0));
                    this.$l.uv_dy = pb.dpdy(pb.vec3(this.uv, 0));
                    this.$if(pb.lessThanEqual(pb.add(pb.length(this.uv_dx), pb.length(this.uv_dy)), 0.000001), function() {
                        this.uv_dx = pb.vec3(1, 0, 0);
                        this.uv_dy = pb.vec3(0, 1, 0);
                    });
                    this.$l.t_ = pb.div(pb.sub(pb.mul(pb.dpdx(posW), this.uv_dy.y), pb.mul(pb.dpdy(posW), this.uv_dx.y)), pb.sub(pb.mul(this.uv_dx.x, this.uv_dy.y), pb.mul(this.uv_dx.y, this.uv_dy.x)));
                    this.$l.ng = pb.normalize(pb.cross(pb.dpdx(posW), pb.dpdy(posW)));
                    this.$l.t = pb.normalize(pb.sub(this.t_, pb.mul(this.ng, pb.dot(this.ng, this.t_))));
                    this.$l.b = pb.cross(this.ng, this.t);
                    if (that.doubleSidedLighting) {
                        this.$if(pb.not(this.$builtins.frontFacing), function() {
                            this.t = pb.mul(this.t, -1);
                            this.b = pb.mul(this.b, -1);
                            this.ng = pb.mul(this.ng, -1);
                        });
                    }
                    this.TBN = pb.mat3(this.t, this.b, this.ng);
                } else if (!worldTangent) {
                    this.$l.uv_dx = pb.dpdx(pb.vec3(this.uv, 0));
                    this.$l.uv_dy = pb.dpdy(pb.vec3(this.uv, 0));
                    this.$if(pb.lessThanEqual(pb.add(pb.length(this.uv_dx), pb.length(this.uv_dy)), 0.000001), function() {
                        this.uv_dx = pb.vec3(1, 0, 0);
                        this.uv_dy = pb.vec3(0, 1, 0);
                    });
                    this.$l.t_ = pb.div(pb.sub(pb.mul(pb.dpdx(posW), this.uv_dy.y), pb.mul(pb.dpdy(posW), this.uv_dx.y)), pb.sub(pb.mul(this.uv_dx.x, this.uv_dy.y), pb.mul(this.uv_dx.y, this.uv_dy.x)));
                    this.$l.ng = pb.normalize(this.worldNormal);
                    this.$l.t = pb.normalize(pb.sub(this.t_, pb.mul(this.ng, pb.dot(this.ng, this.t_))));
                    this.$l.b = pb.cross(this.ng, this.t);
                    if (that.doubleSidedLighting) {
                        this.$if(pb.not(this.$builtins.frontFacing), function() {
                            this.t = pb.mul(this.t, -1);
                            this.b = pb.mul(this.b, -1);
                            this.ng = pb.mul(this.ng, -1);
                        });
                    }
                    this.TBN = pb.mat3(this.t, this.b, this.ng);
                } else {
                    this.$l.ng = pb.normalize(this.worldNormal);
                    this.$l.t = pb.normalize(this.worldTangent);
                    this.$l.b = pb.normalize(this.worldBinormal);
                    if (that.doubleSidedLighting) {
                        this.$if(pb.not(this.$builtins.frontFacing), function() {
                            this.t = pb.mul(this.t, -1);
                            this.b = pb.mul(this.b, -1);
                            this.ng = pb.mul(this.ng, -1);
                        });
                    }
                    this.TBN = pb.mat3(this.t, this.b, this.ng);
                }
                this.$return(this.TBN);
            });
            return pb.getGlobalScope()[funcName](...args);
        }
        /**
     * {@inheritDoc MeshMaterial.applyUniformsValues}
     * @override
     */ applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (ctx.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                if (this.normalTexture) {
                    bindGroup.setValue('zNormalScale', this._normalScale);
                }
            }
        }
        /**
     * Check if the environment lighting should be calculated.
     *
     * @returns true Environment lighting should be calculated, otherwise false
     */ needCalculateEnvLight() {
            return this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && this.drawContext.drawEnvLight;
        }
        /**
     * Get irradiance of current environment light
     *
     * @param scope - Shader scope
     * @param normal - Fragment normal vector
     *
     * @returns Irradiance of current environment light of type vec3
     */ getEnvLightIrradiance(scope, normal) {
            if (!this.needCalculateEnvLight()) {
                console.warn('getEnvLightIrradiance(): No need to calculate environment lighting');
                return scope.$builder.vec3(0);
            }
            return this.drawContext.env.light.envLight.hasIrradiance() ? scope.$builder.mul(this.drawContext.env.light.envLight.getIrradiance(scope, normal).rgb, ShaderHelper.getEnvLightStrength(scope)) : scope.$builder.vec3(0);
        }
        /**
     * Get Radiance of current environment light
     *
     * @param scope - Shader scope
     * @param reflectVec - The reflection vector
     * @param roughness - Roughness value of current fragment
     *
     * @returns Radiance of current environment light of type vec3
     */ getEnvLightRadiance(scope, reflectVec, roughness) {
            if (!this.needCalculateEnvLight()) {
                console.warn('getEnvLightRadiance(): No need to calculate environment lighting');
                return scope.$builder.vec3(0);
            }
            return this.drawContext.env.light.envLight.hasRadiance() ? scope.$builder.mul(this.drawContext.env.light.envLight.getRadiance(scope, reflectVec, roughness).rgb, ShaderHelper.getEnvLightStrength(scope)) : scope.$builder.vec3(0);
        }
        /**
     * Checks if shadow should be computed
     *
     * @returns true if shadow should be computed, other wise false
     */ needCalucateShadow() {
            return this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && !!this.drawContext.currentShadowLight;
        }
        /**
     * Calculates shadow of current fragment
     *
     * @param scope - Shader scope
     * @param NoL - NdotL vector
     * @returns Shadow of current fragment, 1 means no shadow and 0 means full shadowed.
     */ calculateShadow(scope, worldPos, NoL) {
            const pb = scope.$builder;
            if (!this.needCalucateShadow()) {
                console.warn('calculateShadow(): No need to calculate shadow');
                return pb.float(1);
            }
            return ShaderHelper.calculateShadow(scope, worldPos, NoL, this.drawContext);
        }
        getClusterIndex(scope, fragCoord) {
            const pb = scope.$builder;
            const funcName = 'lm_getClusterIndex';
            pb.func(funcName, [
                pb.vec3('fragCoord')
            ], function() {
                const clusterParams = ShaderHelper.getClusterParams(this);
                const countParams = ShaderHelper.getCountParams(this);
                this.$l.zTile = pb.int(pb.max(pb.add(pb.mul(pb.log2(ShaderHelper.nonLinearDepthToLinear(this, this.fragCoord.z)), clusterParams.z), clusterParams.w), 0));
                this.$l.f = pb.vec2(this.fragCoord.x, pb.sub(clusterParams.y, pb.add(this.fragCoord.y, 1)));
                this.$l.xyTile = pb.ivec2(pb.div(this.f, pb.div(clusterParams.xy, pb.vec2(countParams.xy))));
                this.$return(pb.ivec3(this.xyTile, this.zTile));
            });
            return pb.getGlobalScope()[funcName](fragCoord);
        }
        calculatePointLightAttenuation(scope, worldPos, posRange) {
            const pb = scope.$builder;
            const funcName = 'Z_calculatePointLightAttenuation';
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec4('posRange')
            ], function() {
                this.$l.dist = pb.distance(this.posRange.xyz, this.worldPos);
                this.$l.falloff = pb.max(0, pb.sub(1, pb.div(this.dist, this.posRange.w)));
                this.$return(pb.mul(this.falloff, this.falloff));
            });
            return pb.getGlobalScope()[funcName](worldPos, posRange);
        }
        calculateSpotLightAttenuation(scope, worldPos, posRange, dirCutoff) {
            const pb = scope.$builder;
            const funcName = 'Z_calculateSpotLightAttenuation';
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec4('posRange'),
                pb.vec4('dirCutoff')
            ], function() {
                this.$l.dist = pb.distance(this.posRange.xyz, this.worldPos);
                this.$l.falloff = pb.max(0, pb.sub(1, pb.div(this.dist, this.posRange.w)));
                this.$l.spotFactor = pb.dot(pb.normalize(pb.sub(this.worldPos, this.posRange.xyz)), this.dirCutoff.xyz);
                this.spotFactor = pb.smoothStep(this.dirCutoff.w, pb.mix(this.dirCutoff.w, 1, 0.5), this.spotFactor);
                this.$return(pb.mul(this.spotFactor, this.falloff, this.falloff));
            });
            return pb.getGlobalScope()[funcName](worldPos, posRange, dirCutoff);
        }
        calculateLightAttenuation(scope, type, worldPos, posRange, dirCutoff) {
            const pb = scope.$builder;
            return scope.$choice(pb.equal(type, LIGHT_TYPE_DIRECTIONAL), pb.float(1), scope.$choice(pb.equal(type, LIGHT_TYPE_POINT), this.calculatePointLightAttenuation(scope, worldPos.xyz, posRange), this.calculateSpotLightAttenuation(scope, worldPos.xyz, posRange, dirCutoff)));
        }
        calculateLightDirection(scope, type, worldPos, posRange, dirCutoff) {
            const pb = scope.$builder;
            return scope.$choice(pb.equal(type, LIGHT_TYPE_DIRECTIONAL), pb.neg(dirCutoff.xyz), pb.normalize(pb.sub(posRange.xyz, worldPos.xyz)));
        }
        forEachLight(scope, callback) {
            const pb = scope.$builder;
            const that = this;
            if (that.drawContext.renderPass.type !== RENDER_PASS_TYPE_LIGHT) {
                console.warn('LitMaterial.forEachLight(): must be called in forward render pass');
                return;
            }
            if (that.drawContext.currentShadowLight) {
                const posRange = ShaderHelper.getGlobalUniforms(scope).light.positionAndRange;
                const dirCutoff = ShaderHelper.getGlobalUniforms(scope).light.directionAndCutoff;
                const colorIntensity = ShaderHelper.getGlobalUniforms(scope).light.diffuseAndIntensity;
                scope.$scope(function() {
                    const lightType = scope.$choice(pb.lessThan(posRange.w, 0), pb.int(LIGHT_TYPE_DIRECTIONAL), scope.$choice(pb.lessThan(dirCutoff.w, 0), pb.int(LIGHT_TYPE_POINT), pb.int(LIGHT_TYPE_SPOT)));
                    callback.call(this, lightType, posRange, dirCutoff, colorIntensity, true);
                });
            } else {
                scope.$scope(function() {
                    const countParams = ShaderHelper.getCountParams(this);
                    this.$l.cluster = that.getClusterIndex(this, this.$builtins.fragCoord.xyz);
                    this.$l.clusterIndex = pb.add(this.cluster.x, pb.mul(this.cluster.y, countParams.x), pb.mul(this.cluster.z, countParams.x, countParams.y));
                    this.$l.texSize = ShaderHelper.getGlobalUniforms(scope).light.lightIndexTexSize;
                    if (pb.getDevice().type === 'webgl') {
                        this.$l.texCoordX = pb.div(pb.add(pb.mod(pb.float(this.clusterIndex), pb.float(this.texSize.x)), 0.5), pb.float(this.texSize.x));
                        this.$l.texCoordY = pb.div(pb.add(pb.float(pb.div(this.clusterIndex, this.texSize.x)), 0.5), pb.float(this.texSize.y));
                        this.$l.samp = pb.textureSample(ShaderHelper.getClusteredLightIndexTexture(this), pb.vec2(this.texCoordX, this.texCoordY));
                    } else {
                        this.$l.texCoordX = pb.mod(this.clusterIndex, this.texSize.x);
                        this.$l.texCoordY = pb.div(this.clusterIndex, this.texSize.x);
                        this.$l.samp = pb.textureLoad(ShaderHelper.getClusteredLightIndexTexture(this), pb.ivec2(this.texCoordX, this.texCoordY), 0);
                    }
                    if (pb.getDevice().type === 'webgl') {
                        this.$for(pb.int('i'), 0, 4, function() {
                            this.$l.k = this.samp.at(this.i);
                            this.$l.lights = pb.int[2]();
                            this.$l.lights[0] = pb.int(pb.mod(this.k, 256));
                            this.$l.lights[1] = pb.int(pb.div(this.k, 256));
                            this.$for(pb.int('k'), 0, 2, function() {
                                this.$l.li = this.lights.at(this.k);
                                this.$if(pb.greaterThan(this.li, 0), function() {
                                    this.$for(pb.int('j'), 1, 256, function() {
                                        this.$if(pb.equal(this.j, this.li), function() {
                                            this.$l.positionRange = ShaderHelper.getLightPositionAndRange(this, this.j);
                                            this.$l.directionCutoff = ShaderHelper.getLightDirectionAndCutoff(this, this.j);
                                            this.$l.diffuseIntensity = ShaderHelper.getLightColorAndIntensity(this, this.j);
                                            this.$l.lightType = this.$choice(pb.lessThan(this.positionRange.w, 0), pb.int(LIGHT_TYPE_DIRECTIONAL), this.$choice(pb.lessThan(this.directionCutoff.w, 0), pb.int(LIGHT_TYPE_POINT), pb.int(LIGHT_TYPE_SPOT)));
                                            this.$scope(function() {
                                                callback.call(this, this.lightType, this.positionRange, this.directionCutoff, this.diffuseIntensity, false);
                                            });
                                            this.$break();
                                        });
                                    });
                                });
                            });
                        });
                    } else {
                        this.$for(pb.uint('i'), 0, 4, function() {
                            this.$for(pb.uint('k'), 0, 4, function() {
                                this.$l.c = pb.compAnd(pb.sar(this.samp.at(this.i), pb.mul(this.k, 8)), 0xff);
                                this.$if(pb.greaterThan(this.c, 0), function() {
                                    this.$l.positionRange = ShaderHelper.getLightPositionAndRange(this, this.c);
                                    this.$l.directionCutoff = ShaderHelper.getLightDirectionAndCutoff(this, this.c);
                                    this.$l.diffuseIntensity = ShaderHelper.getLightColorAndIntensity(this, this.c);
                                    this.$l.lightType = this.$choice(pb.lessThan(this.positionRange.w, 0), pb.int(LIGHT_TYPE_DIRECTIONAL), this.$choice(pb.lessThan(this.directionCutoff.w, 0), pb.int(LIGHT_TYPE_POINT), pb.int(LIGHT_TYPE_SPOT)));
                                    this.$scope(function() {
                                        callback.call(this, this.lightType, this.positionRange, this.directionCutoff, this.diffuseIntensity, false);
                                    });
                                });
                            });
                        });
                    }
                });
            }
        }
        /**
     * Fragment shader implementation
     *
     * @param scope - Shader scope
     * @returns Calucated fragment color
     */ fragmentShader(scope) {
            super.fragmentShader(scope);
            const pb = scope.$builder;
            if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                if (this.normalTexture) {
                    scope.zNormalScale = pb.float().uniform(2);
                }
            }
        }
        /**
     * {@inheritDoc Material.supportLighting}
     * @override
     */ supportLighting() {
            return true;
        }
    };
    FEATURE_DOUBLE_SIDED_LIGHTING = cls.defineFeature();
    FEATURE_OBJECT_SPACE_NORMALMAP = cls.defineFeature();
    return cls;
}

/**
 * Vertex color mixin
 *
 * @param BaseCls - Base class to mix in
 * @returns Mixed class
 */ function mixinVertexColor(BaseCls) {
    if (BaseCls.vertexColorMixed) {
        return BaseCls;
    }
    let FEATURE_VERTEX_COLOR = 0;
    const cls = class extends BaseCls {
        static vertexColorMixed = true;
        constructor(...args){
            super(...args);
        }
        /** Albedo color */ get vertexColor() {
            return this.featureUsed(FEATURE_VERTEX_COLOR);
        }
        set vertexColor(val) {
            this.useFeature(FEATURE_VERTEX_COLOR, !!val);
        }
        vertexShader(scope) {
            super.vertexShader(scope);
            if (this.needFragmentColor()) {
                if (this.vertexColor) {
                    if (scope.$getVertexAttrib('diffuse')) {
                        throw new Error('mixinVertexColor.vertexShader(): diffuse vertex stream already defined');
                    }
                    scope.$inputs.zDiffuse = scope.$builder.vec4().attrib('diffuse');
                    scope.$outputs.zOutDiffuse = scope.$inputs.zDiffuse;
                }
            }
        }
        getVertexColor(scope) {
            if (!this.needFragmentColor()) {
                throw new Error('mixinVertexColor.getVertexColor(): No need to calculate albedo color, make sure needFragmentColor() returns true');
            }
            if (scope.$builder.shaderKind === 'fragment') {
                return scope.$inputs.zOutDiffuse;
            } else {
                return scope.$inputs.zDiffuse;
            }
        }
    };
    FEATURE_VERTEX_COLOR = cls.defineFeature();
    return cls;
}

/**
 * Lambert material
 * @public
 */ class LambertMaterial extends applyMaterialMixins(MeshMaterial, mixinLight, mixinVertexColor) {
    static FEATURE_VERTEX_NORMAL = this.defineFeature();
    static FEATURE_VERTEX_TANGENT = this.defineFeature();
    constructor(){
        super();
        this.useFeature(LambertMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(LambertMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(LambertMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(LambertMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(LambertMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.color = pb.vec3(0);
            scope.$l.normal = this.calculateNormal(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            if (this.needCalculateEnvLight()) {
                scope.color = pb.add(scope.color, this.getEnvLightIrradiance(scope, scope.normal));
            }
            this.forEachLight(scope, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                this.$l.lightAtten = that.calculateLightAttenuation(this, type, scope.$inputs.worldPos, posRange, dirCutoff);
                this.$l.lightDir = that.calculateLightDirection(this, type, scope.$inputs.worldPos, posRange, dirCutoff);
                this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                this.$l.lightContrib = pb.mul(colorIntensity.rgb, colorIntensity.a, this.NoL, this.lightAtten);
                if (shadow) {
                    this.$l.shadow = pb.vec3(that.calculateShadow(this, scope.$inputs.worldPos, this.NoL));
                    this.lightContrib = pb.mul(this.lightContrib, this.shadow);
                }
                this.color = pb.add(this.color, this.lightContrib);
            });
            scope.$l.litColor = pb.mul(scope.albedo, pb.vec4(scope.color, 1));
            this.outputFragmentColor(scope, scope.$inputs.worldPos, scope.litColor);
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

/**
 * Blinn-phong lighting model mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 * @public
 */ function mixinBlinnPhong(BaseCls) {
    if (BaseCls.blinnPhongMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinLight);
    return class extends S {
        static blinnPhongMixed = true;
        _shininess;
        constructor(){
            super();
            this._shininess = 32;
        }
        /** Shininess */ get shininess() {
            return this._shininess;
        }
        set shininess(val) {
            if (val !== this._shininess) {
                this._shininess = val;
                this.uniformChanged();
            }
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            const pb = scope.$builder;
            if (this.needFragmentColor()) {
                scope.zShininess = pb.float().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor()) {
                bindGroup.setValue('zShininess', this._shininess);
            }
        }
        blinnPhongLight(scope, worldPos, normal, viewVec, albedo) {
            const pb = scope.$builder;
            const funcName = 'Z_blinnPhongLight';
            const that = this;
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec3('normal'),
                pb.vec3('viewVec'),
                pb.vec4('albedo')
            ], function() {
                if (!that.needFragmentColor()) {
                    this.$return(this.albedo.rgb);
                } else {
                    if (that.needCalculateEnvLight()) {
                        this.$l.diffuseColor = that.getEnvLightIrradiance(this, this.normal);
                    } else {
                        this.$l.diffuseColor = pb.vec3(0);
                    }
                    this.$l.specularColor = pb.vec3(0);
                    that.forEachLight(this, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                        this.$l.lightAtten = that.calculateLightAttenuation(this, type, this.worldPos, posRange, dirCutoff);
                        this.$l.lightDir = that.calculateLightDirection(this, type, this.worldPos, posRange, dirCutoff);
                        this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                        this.$l.halfVec = pb.normalize(pb.add(this.viewVec, this.lightDir));
                        this.$l.NoH = pb.clamp(pb.dot(this.normal, this.halfVec), 0, 1);
                        this.$l.lightColor = pb.mul(colorIntensity.rgb, colorIntensity.a, this.lightAtten);
                        this.$l.diffuse = pb.mul(this.lightColor, this.NoL);
                        this.$l.specular = pb.mul(this.lightColor, pb.pow(this.NoH, this.zShininess));
                        if (shadow) {
                            this.$l.shadow = pb.vec3(that.calculateShadow(this, this.worldPos, this.NoL));
                            this.diffuse = pb.mul(this.diffuse, this.shadow);
                            this.specular = pb.mul(this.specular, this.shadow);
                        }
                        this.diffuseColor = pb.add(this.diffuseColor, this.diffuse);
                        this.specularColor = pb.add(this.specularColor, this.specular);
                    });
                    this.$l.litColor = pb.add(pb.mul(this.albedo.rgb, this.diffuseColor), this.specularColor);
                    this.$return(this.litColor);
                }
            });
            return pb.getGlobalScope()[funcName](worldPos, normal, viewVec, albedo);
        }
    };
}

/**
 * Blinn material
 * @public
 */ class BlinnMaterial extends applyMaterialMixins(MeshMaterial, mixinBlinnPhong, mixinVertexColor) {
    /** @internal */ static FEATURE_VERTEX_NORMAL = this.defineFeature();
    /** @internal */ static FEATURE_VERTEX_TANGENT = this.defineFeature();
    /**
   * Creates an instance of BlinnMaterial class
   */ constructor(){
        super();
        this.useFeature(BlinnMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(BlinnMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(BlinnMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(BlinnMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(BlinnMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.normal = this.calculateNormal(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.blinnPhongLight(scope, scope.$inputs.worldPos, scope.normal, scope.viewVec, scope.albedo);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

/**
 * Unlit material
 * @public
 */ class UnlitMaterial extends applyMaterialMixins(MeshMaterial, mixinVertexColor, mixinAlbedoColor) {
    static FEATURE_VERTEX_COLOR = 'um_vertexcolor';
    constructor(){
        super();
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        let color = this.calculateAlbedoColor(scope);
        if (this.vertexColor) {
            color = scope.$builder.mul(color, this.getVertexColor(scope));
        }
        this.outputFragmentColor(scope, scope.$inputs.worldPos, this.needFragmentColor() ? color : null);
    }
}

const ggxLut = new Map();
function getGGXLUT(size) {
    let lut = ggxLut.get(size);
    if (!lut) {
        lut = createGGXLUT(size);
        ggxLut.set(size, lut);
    }
    return lut;
}
function createGGXLUT(size) {
    const device = Application.instance.device;
    const program = device.buildRenderProgram({
        vertex (pb) {
            this.$inputs.pos = pb.vec2().attrib('position');
            this.$outputs.uv = pb.vec2();
            pb.main(function() {
                this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                if (device.type === 'webgpu') {
                    this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                }
            });
        },
        fragment (pb) {
            this.$outputs.color = pb.vec4();
            const SAMPLE_COUNT = 1024;
            if (device.type === 'webgl') {
                pb.func('radicalInverse_VdC', [
                    pb.int('bits')
                ], function() {
                    this.$l.rand = pb.float(0);
                    this.$l.denom = pb.float(1);
                    this.$l.invBase = pb.float(0.5);
                    this.$l.n = this.bits;
                    this.$for(pb.int('i'), 0, 32, function() {
                        this.denom = pb.mul(this.denom, 2);
                        this.rand = pb.add(this.rand, pb.div(pb.mod(pb.float(this.n), 2), this.denom));
                        this.n = pb.div(this.n, 2);
                        this.$if(pb.equal(this.n, 0), function() {
                            this.$break();
                        });
                    });
                    this.$return(this.rand);
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(this.i)));
                });
            } else {
                pb.func('radicalInverse_VdC', [
                    pb.uint('bits')
                ], function() {
                    this.$l.n = this.bits;
                    this.n = pb.compOr(pb.sal(this.n, 16), pb.sar(this.n, 16));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x55555555), 1), pb.sar(pb.compAnd(this.n, 0xaaaaaaaa), 1));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x33333333), 2), pb.sar(pb.compAnd(this.n, 0xcccccccc), 2));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x0f0f0f0f), 4), pb.sar(pb.compAnd(this.n, 0xf0f0f0f0), 4));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x00ff00ff), 8), pb.sar(pb.compAnd(this.n, 0xff00ff00), 8));
                    this.$return(pb.mul(pb.float(this.n), 2.3283064365386963e-10));
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(pb.uint(this.i))));
                });
            }
            pb.func('generateTBN', [
                pb.vec3('normal')
            ], function() {
                this.$l.bitangent = pb.vec3(0, 1, 0);
                this.$l.NoU = this.normal.y;
                this.$l.epsl = 0.0000001;
                this.$if(pb.lessThanEqual(pb.sub(1, pb.abs(this.normal.y)), this.epsl), function() {
                    this.bitangent = this.$choice(pb.greaterThan(this.normal.y, 0), pb.vec3(0, 0, 1), pb.vec3(0, 0, -1));
                });
                this.$l.tangent = pb.normalize(pb.cross(this.bitangent, this.normal));
                this.bitangent = pb.cross(this.normal, this.tangent);
                this.$return(pb.mat3(this.tangent, this.bitangent, this.normal));
            });
            pb.func('D_Charlie', [
                pb.float('sheenRoughness'),
                pb.float('NdotH')
            ], function() {
                this.$l.roughness = pb.max(this.sheenRoughness, 0.000001);
                this.$l.invR = pb.div(1, this.roughness);
                this.$l.cos2h = pb.mul(this.NdotH, this.NdotH);
                this.$l.sin2h = pb.sub(1, this.cos2h);
                this.$return(pb.div(pb.mul(pb.add(this.invR, 2), pb.pow(this.sin2h, pb.mul(this.invR, 0.5))), Math.PI * 2));
            });
            pb.func('smithGGXCorrelated', [
                pb.float('NoV'),
                pb.float('NoL'),
                pb.float('roughness')
            ], function() {
                this.$l.a2 = pb.mul(this.roughness, this.roughness, this.roughness, this.roughness);
                this.$l.GGXV = pb.mul(this.NoL, pb.sqrt(pb.add(pb.mul(this.NoV, this.NoV, pb.sub(1, this.a2)), this.a2)));
                this.$l.GGXL = pb.mul(this.NoV, pb.sqrt(pb.add(pb.mul(this.NoL, this.NoL, pb.sub(1, this.a2)), this.a2)));
                this.$return(pb.div(0.5, pb.add(this.GGXV, this.GGXL)));
            });
            pb.func('V_Ashikhmin', [
                pb.float('NdotL'),
                pb.float('NdotV')
            ], function() {
                this.$return(pb.clamp(pb.div(1, pb.mul(pb.sub(pb.add(this.NdotL, this.NdotV), pb.mul(this.NdotL, this.NdotV)), 4)), 0, 1));
            });
            pb.func('importanceSample', [
                pb.vec2('xi'),
                pb.vec3('normal'),
                pb.float('roughness'),
                pb.vec3('ggx').out(),
                pb.vec3('charlie').out()
            ], function() {
                this.$l.alphaRoughness = pb.mul(this.roughness, this.roughness);
                this.$l.cosTheta = pb.clamp(pb.sqrt(pb.div(pb.sub(1, this.xi.y), pb.add(1, pb.mul(pb.sub(pb.mul(this.alphaRoughness, this.alphaRoughness), 1), this.xi.y)))), 0, 1);
                this.$l.sinTheta = pb.sqrt(pb.sub(1, pb.mul(this.cosTheta, this.cosTheta)));
                this.$l.phi = pb.mul(this.xi.x, Math.PI * 2);
                this.$l.TBN = this.generateTBN(this.normal);
                this.$l.localSpaceDir = pb.normalize(pb.vec3(pb.mul(this.sinTheta, pb.cos(this.phi)), pb.mul(this.sinTheta, pb.sin(this.phi)), this.cosTheta));
                this.ggx = pb.mul(this.TBN, this.localSpaceDir);
                this.sinTheta = pb.pow(this.xi.y, pb.div(this.alphaRoughness, pb.add(pb.mul(this.alphaRoughness, 2), 1)));
                this.cosTheta = pb.sqrt(pb.sub(1, pb.mul(this.sinTheta, this.sinTheta)));
                this.localSpaceDir = pb.normalize(pb.vec3(pb.mul(this.sinTheta, pb.cos(this.phi)), pb.mul(this.sinTheta, pb.sin(this.phi)), this.cosTheta));
                this.charlie = pb.mul(this.TBN, this.localSpaceDir);
            });
            pb.func('integrateBRDF', [
                pb.float('NoV'),
                pb.float('roughness')
            ], function() {
                this.$l.V = pb.vec3(pb.sub(1, pb.mul(this.NoV, this.NoV)), 0, this.NoV);
                this.$l.a = pb.float(0);
                this.$l.b = pb.float(0);
                this.$l.c = pb.float(0);
                this.$l.n = pb.vec3(0, 0, 1);
                this.$for(pb.int('i'), 0, SAMPLE_COUNT, function() {
                    this.$l.xi = this.hammersley2d(this.i, SAMPLE_COUNT);
                    this.$l.ggxSample = pb.vec3();
                    this.$l.charlieSample = pb.vec3();
                    this.importanceSample(this.xi, this.n, this.roughness, this.ggxSample, this.charlieSample);
                    this.$l.ggxL = pb.normalize(pb.reflect(pb.neg(this.V), this.ggxSample.xyz));
                    this.$l.ggxNoL = pb.clamp(this.ggxL.z, 0, 1);
                    this.$l.ggxNoH = pb.clamp(this.ggxSample.z, 0, 1);
                    this.$l.ggxVoH = pb.clamp(pb.dot(this.V, this.ggxSample.xyz), 0, 1);
                    this.$l.charlieL = pb.normalize(pb.reflect(pb.neg(this.V), this.charlieSample.xyz));
                    this.$l.charlieNoL = pb.clamp(this.charlieL.z, 0, 1);
                    this.$l.charlieNoH = pb.clamp(this.charlieSample.z, 0, 1);
                    this.$l.charlieVoH = pb.clamp(pb.dot(this.V, this.charlieSample.xyz), 0, 1);
                    this.$if(pb.greaterThan(this.ggxNoL, 0), function() {
                        this.$l.pdf = pb.div(pb.mul(this.smithGGXCorrelated(this.NoV, this.ggxNoL, this.roughness), this.ggxVoH, this.ggxNoL), this.ggxNoH);
                        this.$l.Fc = pb.pow(pb.sub(1, this.ggxVoH), 5);
                        this.a = pb.add(this.a, pb.mul(pb.sub(1, this.Fc), this.pdf));
                        this.b = pb.add(this.b, pb.mul(this.Fc, this.pdf));
                    });
                    this.$if(pb.greaterThan(this.charlieNoL, 0), function() {
                        this.$l.sheenDistribution = this.D_Charlie(this.roughness, this.charlieNoH);
                        this.$l.sheenVis = this.V_Ashikhmin(this.charlieNoL, this.NoV);
                        this.c = pb.add(this.c, pb.mul(this.sheenVis, this.sheenDistribution, this.charlieNoL, this.charlieVoH));
                    });
                });
                this.$return(pb.div(pb.vec3(pb.mul(this.a, 4), pb.mul(this.b, 4), pb.mul(this.c, 8 * Math.PI)), SAMPLE_COUNT));
            });
            pb.main(function() {
                this.$outputs.color = pb.vec4(this.integrateBRDF(this.$inputs.uv.x, this.$inputs.uv.y), 1);
            });
        }
    });
    const vertexLayout = device.createVertexLayout({
        vertexBuffers: [
            {
                buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                    -1,
                    -1,
                    1,
                    -1,
                    -1,
                    1,
                    1,
                    1
                ]))
            }
        ]
    });
    const rs = device.createRenderStateSet();
    rs.useRasterizerState().setCullMode('none');
    rs.useDepthState().enableTest(false).enableWrite(false);
    const tex = device.createTexture2D('rgba8unorm', size, size, {
        samplerOptions: {
            mipFilter: 'none'
        }
    });
    tex.name = 'GGXLUT';
    const fb = device.createFrameBuffer([
        tex
    ], null);
    device.pushDeviceStates();
    device.setProgram(program);
    device.setVertexLayout(vertexLayout);
    device.setRenderStates(rs);
    device.setFramebuffer(fb);
    device.draw('triangle-strip', 0, 4);
    device.popDeviceStates();
    fb.dispose();
    vertexLayout.dispose();
    program.dispose();
    return tex;
}

/**
 * PBR common stuff mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 */ function mixinPBRCommon(BaseCls) {
    if (BaseCls.pbrCommonMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinTextureProps('occlusion'), mixinTextureProps('emissive'), mixinTextureProps('sheenColor'), mixinTextureProps('sheenRoughness'), mixinTextureProps('clearcoatIntensity'), mixinTextureProps('clearcoatRoughness'), mixinTextureProps('clearcoatNormal'));
    let FEATURE_SHEEN = 0;
    let FEATURE_CLEARCOAT = 0;
    const cls = class extends S {
        static pbrCommonMixed = true;
        _f0;
        _emissiveFactor;
        _occlusionStrength;
        _sheenFactor;
        _clearcoatFactor;
        constructor(){
            super();
            this._f0 = new Vector4(0.04, 0.04, 0.04, 1.5);
            this._occlusionStrength = 1;
            this._emissiveFactor = new Vector4(0, 0, 0, 1);
            this._sheenFactor = Vector4.zero();
            this._clearcoatFactor = new Vector4(0, 0, 1, 0);
        }
        get ior() {
            return this._f0.w;
        }
        set ior(val) {
            if (val !== this._f0.w) {
                let k = (val - 1) / (val + 1);
                k *= k;
                this._f0.setXYZW(k, k, k, val);
                this.uniformChanged();
            }
        }
        get occlusionStrength() {
            return this._occlusionStrength;
        }
        set occlusionStrength(val) {
            if (val !== this._occlusionStrength) {
                this._occlusionStrength = val;
                this.uniformChanged();
            }
        }
        get emissiveColor() {
            return this._emissiveFactor.xyz();
        }
        set emissiveColor(val) {
            if (val.x !== this._emissiveFactor.x || val.y !== this._emissiveFactor.y || val.z !== this._emissiveFactor.z) {
                this._emissiveFactor.x = val.x;
                this._emissiveFactor.y = val.y;
                this._emissiveFactor.z = val.z;
                this.uniformChanged();
            }
        }
        get emissiveStrength() {
            return this._emissiveFactor.w;
        }
        set emissiveStrength(val) {
            if (this._emissiveFactor.w !== val) {
                this._emissiveFactor.w = val;
                this.uniformChanged();
            }
        }
        get clearcoat() {
            return this.featureUsed(FEATURE_CLEARCOAT);
        }
        set clearcoat(val) {
            this.useFeature(FEATURE_CLEARCOAT, !!val);
        }
        get clearcoatIntensity() {
            return this._clearcoatFactor.x;
        }
        set clearcoatIntensity(val) {
            if (val !== this._clearcoatFactor.x) {
                this._clearcoatFactor.x = val;
                this.uniformChanged();
            }
        }
        get clearcoatRoughnessFactor() {
            return this._clearcoatFactor.y;
        }
        set clearcoatRoughnessFactor(val) {
            if (val !== this._clearcoatFactor.y) {
                this._clearcoatFactor.y = val;
                this.uniformChanged();
            }
        }
        get clearcoatNormalScale() {
            return this._clearcoatFactor.z;
        }
        set clearcoatNormalScale(val) {
            if (val !== this._clearcoatFactor.z) {
                this._clearcoatFactor.z = val;
                this.uniformChanged();
            }
        }
        get sheen() {
            return this.featureUsed(FEATURE_SHEEN);
        }
        set sheen(val) {
            this.useFeature(FEATURE_SHEEN, !!val);
        }
        get sheenColorFactor() {
            return this._sheenFactor.xyz();
        }
        set sheenColorFactor(val) {
            if (val.x !== this._sheenFactor.x || val.y !== this._sheenFactor.y || val.z !== this._sheenFactor.z) {
                this._sheenFactor.x = val.x;
                this._sheenFactor.y = val.y;
                this._sheenFactor.z = val.z;
                this.uniformChanged();
            }
        }
        get sheenRoughnessFactor() {
            return this._sheenFactor.w;
        }
        set sheenRoughnessFactor(val) {
            if (val !== this._sheenFactor.w) {
                this._sheenFactor.w = val;
                this.uniformChanged();
            }
        }
        fragmentShader(scope) {
            const pb = scope.$builder;
            super.fragmentShader(scope);
            if (this.needFragmentColor()) {
                scope.zF0 = pb.vec4().uniform(2);
                scope.zEmissiveFactor = pb.vec4().uniform(2);
                if (this.occlusionTexture) {
                    scope.zOcclusionStrength = pb.float().uniform(2);
                }
                if (this.sheen) {
                    scope.zSheenFactor = pb.vec4().uniform(2);
                }
                if (this.clearcoat) {
                    scope.zClearcoatFactor = pb.vec4().uniform(2);
                }
                if (this.drawContext.drawEnvLight) {
                    scope.zGGXLut = pb.tex2D().uniform(2);
                }
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zF0', this._f0);
                bindGroup.setValue('zEmissiveFactor', this._emissiveFactor);
                if (this.occlusionTexture) {
                    bindGroup.setValue('zOcclusionStrength', this._occlusionStrength);
                }
                if (this.sheen) {
                    bindGroup.setValue('zSheenFactor', this._sheenFactor);
                }
                if (this.clearcoat) {
                    bindGroup.setValue('zClearcoatFactor', this._clearcoatFactor);
                }
                if (ctx.drawEnvLight) {
                    bindGroup.setTexture('zGGXLut', getGGXLUT(1024));
                }
            }
        }
        getF0(scope) {
            return scope.zF0;
        }
        getCommonDatasStruct(scope) {
            const pb = scope.$builder;
            return pb.defineStruct([
                pb.vec4('f0'),
                pb.vec3('f90'),
                pb.vec4('diffuse'),
                pb.float('metallic'),
                pb.float('roughness'),
                pb.float('specularWeight'),
                ...this.sheen ? [
                    pb.float('sheenAlbedoScaling'),
                    pb.vec3('sheenColor'),
                    pb.float('sheenRoughness')
                ] : [],
                ...this.clearcoat ? [
                    pb.vec4('ccFactor'),
                    pb.vec3('ccNormal'),
                    pb.float('ccNoV'),
                    pb.float('ccFresnel')
                ] : []
            ]);
        }
        getCommonData(scope, albedo, viewVec, TBN) {
            const pb = scope.$builder;
            const that = this;
            const funcName = 'Z_getCommonData';
            pb.func(funcName, [
                pb.vec4('albedo'),
                pb.vec3('viewVec'),
                pb.mat3('TBN')
            ], function() {
                this.$l.data = that.getCommonDatasStruct(this)();
                that.calculateCommonData(this, this.albedo, this.viewVec, this.TBN, this.data);
                this.$return(this.data);
            });
            return scope.$g[funcName](albedo, viewVec, TBN);
        }
        calculateCommonData(scope, albedo, viewVec, TBN, data) {
            const pb = scope.$builder;
            if (this.sheen) {
                if (this.sheenColorTexture) {
                    data.sheenColor = pb.mul(this.sampleSheenColorTexture(scope).rgb, scope.zSheenFactor.rgb);
                } else {
                    data.sheenColor = scope.zSheenFactor.rgb;
                }
                if (this.sheenRoughnessTexture) {
                    data.sheenRoughness = pb.mul(this.sampleSheenRoughnessTexture(scope).a, scope.zSheenFactor.a);
                } else {
                    data.sheenRoughness = scope.zSheenFactor.a;
                }
                scope.$l.sheenDFG = 0.157;
                data.sheenAlbedoScaling = pb.sub(1, pb.mul(pb.max(pb.max(data.sheenColor.r, data.sheenColor.g), data.sheenColor.b), scope.sheenDFG));
            }
            if (this.clearcoat) {
                if (this.clearcoatNormalTexture) {
                    const ccNormal = pb.mul(pb.sub(pb.mul(this.sampleClearcoatNormalTexture(scope).rgb, 2), pb.vec3(1)), pb.vec3(scope.zClearcoatFactor.zz, 1));
                    data.ccNormal = pb.normalize(pb.mul(TBN, ccNormal));
                } else {
                    data.ccNormal = TBN[2];
                }
                data.ccNoV = pb.clamp(pb.dot(data.ccNormal, viewVec), 0.0001, 1);
                data.ccFactor = scope.zClearcoatFactor;
                if (this.clearcoatIntensityTexture) {
                    data.ccFactor.x = pb.mul(data.ccFactor.x, this.sampleClearcoatIntensityTexture(scope).r);
                }
                if (this.clearcoatRoughnessTexture) {
                    data.ccFactor.y = pb.clamp(pb.mul(data.ccFactor.y, this.sampleClearcoatRoughnessTexture(scope).g), 0, 1);
                }
            }
        }
        calculateEmissiveColor(scope) {
            const pb = scope.$builder;
            if (this.emissiveTexture) {
                return pb.mul(this.sampleEmissiveTexture(scope).rgb, scope.zEmissiveFactor.rgb, scope.zEmissiveFactor.a);
            } else {
                return pb.mul(scope.zEmissiveFactor.rgb, scope.zEmissiveFactor.a);
            }
        }
        D_Charlie(scope, NdotH, sheenRoughness) {
            const funcNameDCharlie = 'Z_DCharlie';
            const pb = scope.$builder;
            pb.func(funcNameDCharlie, [
                pb.float('NdotH'),
                pb.float('sheenRoughness')
            ], function() {
                this.$l.alphaG = pb.mul(this.sheenRoughness, this.sheenRoughness);
                this.$l.invR = pb.div(1, this.alphaG);
                this.$l.cos2h = pb.mul(this.NdotH, this.NdotH);
                this.$l.sin2h = pb.max(pb.sub(1, this.cos2h), 0.0078125);
                this.$return(pb.div(pb.mul(pb.add(this.invR, 2), pb.pow(this.sin2h, pb.mul(this.invR, 0.5))), 2 * Math.PI));
            });
            return scope.$g[funcNameDCharlie](NdotH, sheenRoughness);
        }
        V_Ashikhmin(scope, NdotL, NdotV) {
            const funcNameVAshikhmin = 'Z_VAshikhmin';
            const pb = scope.$builder;
            pb.func(funcNameVAshikhmin, [
                pb.float('NdotL'),
                pb.float('NdotV')
            ], function() {
                this.$return(pb.clamp(pb.div(1, pb.mul(pb.sub(pb.add(this.NdotL, this.NdotV), pb.mul(this.NdotL, this.NdotV)), 4)), 0, 1));
            });
            return scope.$g[funcNameVAshikhmin](NdotL, NdotV);
        }
        directLighting(scope, lightDir, lightColor, normal, viewVec, commonData, outColor) {
            const pb = scope.$builder;
            const that = this;
            const funcName = 'Z_PBRDirectLighting';
            pb.func(funcName, [
                pb.vec3('L'),
                pb.vec3('lightColor'),
                pb.vec3('normal'),
                pb.vec3('viewVec'),
                that.getCommonDatasStruct(scope)('data'),
                pb.vec3('outColor').inout()
            ], function() {
                this.$l.H = pb.normalize(pb.add(this.viewVec, this.L));
                this.$l.NoH = pb.clamp(pb.dot(this.normal, this.H), 0, 1);
                this.$l.NoL = pb.clamp(pb.dot(this.normal, this.L), 0, 1);
                this.$l.NoV = pb.clamp(pb.dot(this.normal, this.viewVec), 0, 1);
                this.$if(pb.greaterThan(this.NoL, 0), function() {
                    this.$l.VoH = pb.clamp(pb.dot(this.viewVec, this.H), 0, 1);
                    this.$l.F = that.fresnelSchlick(this, this.VoH, this.data.f0.rgb, this.data.f90);
                    this.$l.alphaRoughness = pb.mul(this.data.roughness, this.data.roughness);
                    this.$l.D = that.distributionGGX(this, this.NoH, this.alphaRoughness);
                    this.$l.V = that.visGGX(this, this.NoV, this.NoL, this.alphaRoughness);
                    this.$l.specular = pb.mul(this.lightColor, this.D, this.V, this.F, this.data.specularWeight);
                    if (that.sheen) {
                        this.specular = pb.mul(this.specular, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.specular);
                    this.$l.diffuse = pb.mul(this.lightColor, pb.max(pb.mul(pb.sub(pb.vec3(1), pb.mul(this.F, this.data.specularWeight)), pb.div(this.data.diffuse.rgb, Math.PI)), pb.vec3(0)));
                    if (that.sheen) {
                        this.diffuse = pb.mul(this.diffuse, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.diffuse);
                    if (that.sheen) {
                        this.$l.sheenD = that.D_Charlie(this, this.NoH, this.data.sheenRoughness);
                        this.$l.sheenV = that.V_Ashikhmin(this, this.NoL, this.NoV);
                        this.outColor = pb.add(this.outColor, pb.mul(this.lightColor, this.data.sheenColor, this.sheenD, this.sheenV));
                    }
                    if (that.clearcoat) {
                        this.alphaRoughness = pb.mul(this.data.ccFactor.y, this.data.ccFactor.y);
                        this.NoH = pb.clamp(pb.dot(this.data.ccNormal, this.H), 0, 1);
                        this.NoL = pb.clamp(pb.dot(this.data.ccNormal, this.L), 0, 1);
                        this.ccF0 = pb.vec3(pb.pow(pb.div(pb.sub(this.data.f0.a, 1), pb.add(this.data.f0.a, 1)), 2));
                        this.F = that.fresnelSchlick(this, this.VoH, this.ccF0, pb.vec3(1));
                        this.D = that.distributionGGX(this, this.NoH, this.alphaRoughness);
                        this.V = that.visGGX(this, this.data.ccNoV, this.NoL, this.alphaRoughness);
                        this.outColor = pb.add(this.outColor, pb.mul(this.D, this.V, this.F, this.data.ccFactor.x));
                    }
                });
            });
            scope.$g[funcName](lightDir, lightColor, normal, viewVec, commonData, outColor);
        }
        indirectLighting(scope, normal, viewVec, commonData, outColor) {
            const pb = scope.$builder;
            const that = this;
            const ctx = that.drawContext;
            const funcName = 'Z_PBRIndirectLighting';
            pb.func(funcName, [
                pb.vec3('normal'),
                pb.vec3('viewVec'),
                that.getCommonDatasStruct(scope)('data'),
                pb.vec3('outColor').inout()
            ], function() {
                if (!ctx.drawEnvLight || !ctx.env.light.envLight.hasRadiance() && !ctx.env.light.envLight.hasIrradiance()) {
                    return;
                }
                const envLightStrength = ShaderHelper.getEnvLightStrength(this);
                if (that.occlusionTexture) {
                    const occlusionSample = that.sampleOcclusionTexture(this).r;
                    this.$l.occlusion = pb.mul(pb.add(pb.mul(this.zOcclusionStrength, pb.sub(occlusionSample, 1)), 1), envLightStrength);
                } else {
                    this.$l.occlusion = envLightStrength;
                }
                this.$l.NoV = pb.clamp(pb.dot(this.normal, this.viewVec), 0.0001, 1);
                this.$l.ggxLutSample = pb.clamp(pb.textureSampleLevel(this.zGGXLut, pb.clamp(pb.vec2(this.NoV, this.data.roughness), pb.vec2(0), pb.vec2(1)), 0), pb.vec4(0), pb.vec4(1));
                this.$l.f_ab = this.ggxLutSample.rg;
                this.$l.Fr = pb.sub(pb.max(pb.vec3(pb.sub(1, this.data.roughness)), this.data.f0.rgb), this.data.f0.rgb);
                this.$l.k_S = pb.add(this.data.f0.rgb, pb.mul(this.Fr, pb.pow(pb.sub(1, this.NoV), 5)));
                if (ctx.env.light.envLight.hasRadiance()) {
                    this.$l.radiance = ctx.env.light.envLight.getRadiance(this, pb.reflect(pb.neg(this.viewVec), this.normal), this.data.roughness);
                    this.$l.FssEss = pb.add(pb.mul(this.k_S, this.f_ab.x), pb.vec3(this.f_ab.y));
                    this.$l.iblSpecular = pb.mul(this.radiance, this.FssEss, this.data.specularWeight, this.occlusion);
                    if (that.sheen) {
                        this.iblSpecular = pb.mul(this.iblSpecular, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.iblSpecular);
                }
                if (ctx.env.light.envLight.hasIrradiance()) {
                    this.$l.irradiance = ctx.env.light.envLight.getIrradiance(this, this.normal);
                    this.$l.FssEss = pb.add(pb.mul(this.k_S, this.f_ab.x, this.data.specularWeight), pb.vec3(this.f_ab.y));
                    this.$l.Ems = pb.sub(1, pb.add(this.f_ab.x, this.f_ab.y));
                    this.$l.F_avg = pb.mul(pb.add(this.data.f0.rgb, pb.div(pb.sub(pb.vec3(1), this.data.f0.rgb), 21)), this.data.specularWeight);
                    this.$l.FmsEms = pb.div(pb.mul(this.FssEss, this.F_avg, this.Ems), pb.sub(pb.vec3(1), pb.mul(this.F_avg, this.Ems)));
                    this.$l.k_D = pb.mul(this.data.diffuse.rgb, pb.add(pb.sub(pb.vec3(1), this.FssEss), this.FmsEms));
                    this.$l.iblDiffuse = pb.mul(pb.add(this.FmsEms, this.k_D), this.irradiance, this.occlusion);
                    if (that.sheen) {
                        this.iblDiffuse = pb.mul(this.iblDiffuse, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.iblDiffuse);
                }
                if (that.sheen && ctx.env.light.envLight.hasIrradiance()) {
                    this.$l.refl = pb.reflect(pb.neg(this.viewVec), this.normal);
                    this.$l.sheenBRDF = pb.clamp(pb.textureSampleLevel(this.zGGXLut, pb.clamp(pb.vec2(this.NoV, this.data.sheenRoughness), pb.vec2(0), pb.vec2(1)), 0), pb.vec4(0), pb.vec4(1)).b;
                    this.outColor = pb.add(this.outColor, pb.mul(this.data.sheenColor, this.irradiance.rgb, this.sheenBRDF));
                }
                if (that.clearcoat && ctx.env.light.envLight.hasRadiance()) {
                    this.$l.NoV = pb.clamp(pb.dot(this.data.ccNormal, this.viewVec), 0.0001, 1);
                    this.$l.ggxLutSample = pb.clamp(pb.textureSampleLevel(this.zGGXLut, pb.clamp(pb.vec2(this.NoV, this.data.ccFactor.y), pb.vec2(0), pb.vec2(1)), 0), pb.vec4(0), pb.vec4(1));
                    this.$l.f_ab = this.ggxLutSample.rg;
                    this.$l.Fr = pb.sub(pb.max(pb.vec3(pb.sub(1, this.data.ccFactor.y)), this.data.f0.rgb), this.data.f0.rgb);
                    this.$l.k_S = pb.add(this.data.f0.rgb, pb.mul(this.Fr, pb.pow(pb.sub(1, this.NoV), 5)));
                    this.$l.radiance = ctx.env.light.envLight.getRadiance(this, pb.reflect(pb.neg(this.viewVec), this.data.ccNormal), this.data.ccFactor.y);
                    this.$l.FssEss = pb.add(pb.mul(this.k_S, this.f_ab.x), pb.vec3(this.f_ab.y));
                    this.$l.ccSpecular = pb.mul(this.radiance, this.FssEss, this.data.specularWeight, this.occlusion);
                    this.outColor = pb.add(this.outColor, pb.mul(this.ccSpecular, this.data.ccFactor.x));
                }
            });
            scope.$g[funcName](normal, viewVec, commonData, outColor);
        }
        fresnelSchlick(scope, cosTheta, F0, F90) {
            const pb = scope.$builder;
            const funcName = 'Z_fresnelSchlick';
            pb.func(funcName, [
                pb.float('cosTheta'),
                pb.vec3('f0'),
                pb.vec3('f90')
            ], function() {
                this.$return(pb.add(this.f0, pb.mul(pb.sub(this.f90, this.f0), pb.pow(pb.clamp(pb.sub(1, this.cosTheta), 0, 1), 5))));
            });
            return scope.$g[funcName](cosTheta, F0, F90);
        }
        distributionGGX(scope, NdotH, alphaRoughness) {
            const pb = scope.$builder;
            const funcName = 'Z_distributionGGX';
            pb.func(funcName, [
                pb.float('NdotH'),
                pb.float('roughness')
            ], function() {
                this.$l.a2 = pb.mul(this.roughness, this.roughness);
                this.$l.NdotH2 = pb.mul(this.NdotH, this.NdotH);
                this.$l.num = this.a2;
                this.$l.denom = pb.add(pb.mul(this.NdotH2, pb.sub(this.a2, 1)), 1);
                this.denom = pb.mul(pb.mul(3.14159265, this.denom), this.denom);
                this.$return(pb.div(this.num, this.denom));
            });
            return scope.$g[funcName](NdotH, alphaRoughness);
        }
        visGGX(scope, NdotV, NdotL, alphaRoughness) {
            const pb = scope.$builder;
            const funcName = 'Z_visGGX';
            pb.func(funcName, [
                pb.float('NdotV'),
                pb.float('NdotL'),
                pb.float('roughness')
            ], function() {
                this.$l.a = this.roughness;
                this.$l.ggxV = pb.mul(this.NdotL, pb.sqrt(pb.add(pb.mul(this.NdotV, this.NdotV, pb.sub(1, this.a)), this.a)));
                this.$l.ggxL = pb.mul(this.NdotV, pb.sqrt(pb.add(pb.mul(this.NdotL, this.NdotL, pb.sub(1, this.a)), this.a)));
                this.$l.ggx = pb.add(this.ggxV, this.ggxL, 1e-5);
                this.$if(pb.greaterThan(this.ggx, 0), function() {
                    this.$return(pb.div(0.5, this.ggx));
                }).$else(function() {
                    this.$return(pb.float(0));
                });
            });
            return scope.$g[funcName](NdotV, NdotL, alphaRoughness);
        }
    };
    FEATURE_SHEEN = cls.defineFeature();
    FEATURE_CLEARCOAT = cls.defineFeature();
    return cls;
}

/**
 * PBRMetallicRoughness lighting model mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 * @public
 */ function mixinPBRMetallicRoughness(BaseCls) {
    if (BaseCls.pbrMetallicRoughnessMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinPBRCommon, mixinLight, mixinTextureProps('metallicRoughness'), mixinTextureProps('occlusion'), mixinTextureProps('specular'), mixinTextureProps('specularColor'));
    return class extends S {
        static pbrMetallicRoughnessMixed = true;
        _metallic;
        _roughness;
        _specularFactor;
        constructor(){
            super();
            this._metallic = 1;
            this._roughness = 1;
            this._specularFactor = Vector4.one();
        }
        get metallic() {
            return this._metallic;
        }
        set metallic(val) {
            if (val !== this._metallic) {
                this._metallic = val;
                this.uniformChanged();
            }
        }
        get roughness() {
            return this._roughness;
        }
        set roughness(val) {
            if (val !== this._roughness) {
                this._roughness = val;
                this.uniformChanged();
            }
        }
        get specularFactor() {
            return this._specularFactor;
        }
        set specularFactor(val) {
            if (!val.equalsTo(this._specularFactor)) {
                this._specularFactor.set(val);
                this.uniformChanged();
            }
        }
        PBRLight(scope, worldPos, normal, viewVec, albedo, TBN) {
            const pb = scope.$builder;
            const funcName = 'Z_PBRMetallicRoughnessLight';
            const that = this;
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec3('normal'),
                pb.mat3('TBN'),
                pb.vec3('viewVec'),
                pb.vec4('albedo')
            ], function() {
                this.$l.pbrData = that.getCommonData(this, this.albedo, this.viewVec, this.TBN);
                this.$l.lightingColor = pb.vec3(0);
                this.$l.emissiveColor = that.calculateEmissiveColor(this);
                that.indirectLighting(this, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                that.forEachLight(this, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                    this.$l.diffuse = pb.vec3();
                    this.$l.specular = pb.vec3();
                    this.$l.lightAtten = that.calculateLightAttenuation(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.lightDir = that.calculateLightDirection(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                    this.$l.lightColor = pb.mul(colorIntensity.rgb, colorIntensity.a, this.lightAtten, this.NoL);
                    if (shadow) {
                        this.lightColor = pb.mul(this.lightColor, that.calculateShadow(this, this.worldPos, this.NoL));
                    }
                    that.directLighting(this, this.lightDir, this.lightColor, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                });
                this.$return(pb.add(this.lightingColor, this.emissiveColor));
            });
            return pb.getGlobalScope()[funcName](worldPos, normal, TBN, viewVec, albedo);
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            if (this.needFragmentColor()) {
                const pb = scope.$builder;
                scope.zMetallic = pb.float().uniform(2);
                scope.zRoughness = pb.float().uniform(2);
                scope.zSpecularFactor = pb.vec4().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zMetallic', this._metallic);
                bindGroup.setValue('zRoughness', this._roughness);
                bindGroup.setValue('zSpecularFactor', this._specularFactor);
            }
        }
        calculateCommonData(scope, albedo, viewVec, TBN, data) {
            super.calculateCommonData(scope, albedo, viewVec, TBN, data);
            const pb = scope.$builder;
            if (this.metallicRoughnessTexture) {
                scope.$l.metallicRoughnessSample = this.sampleMetallicRoughnessTexture(scope);
                data.metallic = pb.mul(scope.zMetallic, scope.metallicRoughnessSample.z);
                data.roughness = pb.mul(scope.zRoughness, scope.metallicRoughnessSample.y);
            } else {
                data.metallic = scope.zMetallic;
                data.roughness = scope.zRoughness;
            }
            if (this.specularColorTexture) {
                scope.$l.specularColor = pb.mul(scope.zSpecularFactor.rgb, this.sampleSpecularColorTexture(scope).rgb);
            } else {
                scope.$l.specularColor = scope.zSpecularFactor.rgb;
            }
            if (this.specularTexture) {
                data.specularWeight = pb.mul(scope.zSpecularFactor.a, this.sampleSpecularTexture(scope).a);
            } else {
                data.specularWeight = scope.zSpecularFactor.a;
            }
            data.f0 = pb.vec4(pb.mix(pb.min(pb.mul(this.getF0(scope).rgb, scope.specularColor), pb.vec3(1)), albedo.rgb, data.metallic), this.getF0(scope).a);
            data.f90 = pb.vec3(1);
            data.diffuse = pb.vec4(pb.mix(albedo.rgb, pb.vec3(0), data.metallic), albedo.a);
        }
    };
}

/**
 * Foliage mixin
 *
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 *
 * @public
 */ function mixinFoliage(BaseCls) {
    if (BaseCls.foliageMixed) {
        return BaseCls;
    }
    return class extends BaseCls {
        static foliageMixed = true;
        constructor(...args){
            super(...args);
            this.cullMode = 'none';
        }
        calculateFoliageAlbedo(scope, albedoColor, texelCoord) {
            const pb = scope.$builder;
            const that = this;
            const funcNameCalcMipLevel = 'Z_CalcFoliageMipLevel';
            pb.func(funcNameCalcMipLevel, [
                pb.vec2('coord')
            ], function() {
                this.$l.dx = pb.dpdx(this.coord);
                this.$l.dy = pb.dpdy(this.coord);
                this.$l.deltaMaxSqr = pb.max(pb.dot(this.dx, this.dx), pb.dot(this.dy, this.dy));
                this.$return(pb.max(0, pb.mul(pb.log2(this.deltaMaxSqr), 0.5)));
            });
            const funcNameCalcFoliageAlbedo = 'Z_calcFoliageAlbedo';
            pb.func(funcNameCalcFoliageAlbedo, [
                pb.vec4('albedo'),
                pb.vec2('coord')
            ], function() {
                this.$l.a = pb.mul(this.albedo.a, pb.add(1, pb.mul(pb.max(0, scope[funcNameCalcMipLevel](this.coord)), 0.25)));
                if (that.alphaToCoverage) {
                    this.a = pb.add(pb.div(pb.sub(this.a, 0.4), pb.max(pb.fwidth(this.albedo.a), 0.0001)), 0.5);
                }
                this.$return(pb.vec4(this.albedo.rgb, this.a));
            });
            return pb.getGlobalScope()[funcNameCalcFoliageAlbedo](albedoColor, texelCoord);
        }
    };
}

/**
 * Terrain grass material
 * @public
 */ class GrassMaterial extends applyMaterialMixins(MeshMaterial, mixinPBRMetallicRoughness, mixinFoliage) {
    /** @internal */ _terrainSize;
    /** @internal */ _terrainNormalMap;
    /** @internal */ _textureSize;
    /**
   * Creates an instance of GrassMaterial class
   * @param terrainSize - terrain size
   * @param normalMap - normal map
   * @param grassTexture - grass texture
   */ constructor(terrainSize, normalMap, grassTexture){
        super();
        this.metallic = 0;
        this.roughness = 1;
        this.specularFactor = new Vector4(1, 1, 1, 0.2);
        this.doubleSidedLighting = false;
        this._terrainSize = terrainSize;
        this._terrainNormalMap = normalMap;
        this._textureSize = Vector2.one();
        if (grassTexture) {
            this.albedoTexture = grassTexture;
            this._textureSize.setXY(grassTexture.width, grassTexture.height);
        }
    }
    /**
   * {@inheritDoc MeshMaterial.isTransparentPass}
   * @override
   */ isTransparentPass(pass) {
        return false;
    }
    /**
   * {@inheritDoc Material.supportLighting}
   * @override
   */ supportLighting() {
        return true;
    }
    applyUniformValues(bindGroup, ctx, pass) {
        super.applyUniformValues(bindGroup, ctx, pass);
        bindGroup.setTexture('terrainNormalMap', this._terrainNormalMap);
        bindGroup.setValue('terrainSize', this._terrainSize);
        if (this.needFragmentColor(ctx)) {
            bindGroup.setValue('albedoTextureSize', this._textureSize);
        }
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$inputs.pos = pb.vec3().attrib('position');
        scope.$inputs.placement = pb.vec4().attrib('texCoord1');
        scope.terrainNormalMap = pb.tex2D().uniform(2);
        scope.terrainSize = pb.vec2().uniform(2);
        const normalSample = pb.textureSampleLevel(scope.terrainNormalMap, pb.div(scope.$inputs.placement.xz, scope.terrainSize), 0).rgb;
        scope.$l.normal = pb.normalize(pb.sub(pb.mul(normalSample, 2), pb.vec3(1)));
        scope.$l.axisX = pb.vec3(1, 0, 0);
        scope.$l.axisZ = pb.cross(scope.axisX, scope.normal);
        scope.$l.axisX = pb.cross(scope.normal, scope.axisZ);
        scope.$l.rotPos = pb.mul(pb.mat3(scope.axisX, scope.normal, scope.axisZ), scope.$inputs.pos);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(pb.add(scope.rotPos, scope.$inputs.placement.xyz), 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        scope.$outputs.worldNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.normal, 0)).xyz;
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            scope.albedoTextureSize = pb.vec2().uniform(2);
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            scope.albedo = that.calculateFoliageAlbedo(scope, scope.albedo, pb.mul(that.getAlbedoTexCoord(scope), scope.albedoTextureSize));
            scope.$l.litColor = pb.vec3(0);
            if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.worldNorm);
                scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
                scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            }
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

let quadVertexLayout = null;
let quadRenderStateSet = null;
function drawFullscreenQuad(renderStates) {
    const device = Application.instance.device;
    if (!quadVertexLayout) {
        quadVertexLayout = device.createVertexLayout({
            vertexBuffers: [
                {
                    buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                        -1,
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1
                    ]))
                }
            ]
        });
    }
    if (!quadRenderStateSet) {
        quadRenderStateSet = device.createRenderStateSet();
        quadRenderStateSet.useRasterizerState().setCullMode('none');
        quadRenderStateSet.useDepthState().enableTest(false).enableWrite(false);
    }
    const saveRenderStateSet = device.getRenderStates();
    device.setRenderStates(renderStates ?? quadRenderStateSet);
    device.setVertexLayout(quadVertexLayout);
    device.draw('triangle-strip', 0, 4);
    device.setRenderStates(saveRenderStateSet);
}

/**
 * Terrain material class
 * @public
 */ class TerrainMaterial extends applyMaterialMixins(MeshMaterial, mixinLight, mixinPBRMetallicRoughness) {
    static _metallicRoughnessGenerationProgram = null;
    static _metallicRoughnessGenerationBindGroup = null;
    _options;
    _uvScales;
    _numDetailMaps;
    _terrainInfo;
    constructor(options){
        super();
        this.normalMapMode = 'object-space';
        this._options = null;
        this._numDetailMaps = 0;
        this._uvScales = null;
        this._terrainInfo = null;
        if (options && options.splatMap && options.detailMaps && options.detailMaps.albedoTextures) {
            this._options = Object.assign({}, options);
            const albedoTextures = this._options.detailMaps.albedoTextures;
            this._numDetailMaps = Array.isArray(albedoTextures) ? albedoTextures.length : albedoTextures.depth;
            if (!this._numDetailMaps) {
                throw new Error(`TerrainMaterial(): Invalid detail textures`);
            }
            if (this._numDetailMaps > 4) {
                throw new Error(`TerrainMaterial(): The maximum detail levels is 4`);
            }
            if (!this._options.detailMaps.uvScale || this._options.detailMaps.uvScale.length !== this._numDetailMaps) {
                throw new Error(`TerrainMaterial(): Invalid uv scale`);
            }
            this._uvScales = new Float32Array(this._numDetailMaps * 4);
            for(let i = 0; i < this._numDetailMaps; i++){
                this._uvScales[i * 4] = this._options.detailMaps.uvScale[i];
                this._uvScales[i * 4 + 1] = 1;
                this._uvScales[i * 4 + 2] = 0.01;
                this._uvScales[i * 4 + 3] = 0.99;
            }
            if (this._options.detailMaps.metallic) {
                if (this._options.detailMaps.metallic.length !== this._numDetailMaps) {
                    throw new Error(`TerrainMaterial(): Invalid metallic values`);
                }
                for(let i = 0; i < this._numDetailMaps; i++){
                    this._uvScales[i * 4 + 2] = this._options.detailMaps.metallic[i];
                }
            }
            if (this._options.detailMaps.roughness) {
                if (this._options.detailMaps.roughness.length !== this._numDetailMaps) {
                    throw new Error(`TerrainMaterial(): Invalid roughness values`);
                }
                for(let i = 0; i < this._numDetailMaps; i++){
                    this._uvScales[i * 4 + 3] = this._options.detailMaps.roughness[i];
                }
            }
            const normalTextures = options.detailMaps.normalTextures;
            if (normalTextures) {
                const m = Array.isArray(normalTextures) ? normalTextures.length : normalTextures.depth;
                if (m !== this._numDetailMaps) {
                    throw new Error(`TerrainMaterial(): The number of normal textures not match the number of albedo textures`);
                }
                if (options.detailMaps.normalScale) {
                    if (options.detailMaps.normalScale.length !== this._numDetailMaps) {
                        throw new Error(`TerrainMaterial(): Invalid normal scale`);
                    }
                    for(let i = 0; i < this._numDetailMaps; i++){
                        this._uvScales[i * 4 + 1] = options.detailMaps.normalScale[i];
                    }
                }
            }
            this._options = Object.assign({}, options);
            if (Array.isArray(albedoTextures)) {
                for(let i = 0; i < albedoTextures.length; i++){
                    if (!albedoTextures[i]) {
                        throw new Error(`TerrainMaterial(): Invalid detail albedo texture`);
                    }
                    albedoTextures[i].samplerOptions = {
                        addressU: 'repeat',
                        addressV: 'repeat'
                    };
                }
            } else {
                albedoTextures.samplerOptions = {
                    addressU: 'repeat',
                    addressV: 'repeat'
                };
            }
            if (Array.isArray(normalTextures)) {
                for(let i = 0; i < normalTextures.length; i++){
                    if (!normalTextures[i]) {
                        throw new Error(`TerrainMaterial(): Invalid detail normal texture`);
                    }
                    normalTextures[i].samplerOptions = {
                        addressU: 'repeat',
                        addressV: 'repeat'
                    };
                }
            } else if (normalTextures) {
                normalTextures.samplerOptions = {
                    addressU: 'repeat',
                    addressV: 'repeat'
                };
            }
        }
        this.metallicRoughnessTexture = this.generateMetallicRoughnessMap();
        this.metallicRoughnessTexCoordIndex = -1;
        this.albedoTexCoordIndex = -1;
        this.normalTexCoordIndex = -1;
    }
    get terrainInfo() {
        return this._terrainInfo;
    }
    set terrainInfo(val) {
        this._terrainInfo = val;
        this.uniformChanged();
    }
    /**
   * {@inheritDoc MeshMaterial.isTransparentPass}
   * @override
   */ isTransparentPass(pass) {
        return false;
    }
    /**
   * {@inheritDoc Material.supportLighting}
   * @override
   */ supportLighting() {
        return true;
    }
    /**
   * {@inheritDoc Material.isBatchable}
   * @override
   */ isBatchable() {
        return false;
    }
    applyUniformValues(bindGroup, ctx, pass) {
        super.applyUniformValues(bindGroup, ctx, pass);
        if (this.needFragmentColor(ctx)) {
            bindGroup.setValue('terrainInfo', this._terrainInfo);
            if (this._options) {
                bindGroup.setValue('detailScales', this._uvScales);
                bindGroup.setTexture('splatMap', this._options.splatMap);
                if (Array.isArray(this._options.detailMaps.albedoTextures)) {
                    for(let i = 0; i < this._numDetailMaps; i++){
                        bindGroup.setTexture(`detailAlbedoMap${i}`, this._options.detailMaps.albedoTextures[i]);
                    }
                } else {
                    bindGroup.setTexture('detailAlbedoMap', this._options.detailMaps.albedoTextures);
                }
                if (Array.isArray(this._options.detailMaps.normalTextures)) {
                    for(let i = 0; i < this._numDetailMaps; i++){
                        bindGroup.setTexture(`detailNormalMap${i}`, this._options.detailMaps.normalTextures[i]);
                    }
                } else {
                    bindGroup.setTexture('detailNormalMap', this._options.detailMaps.normalTextures);
                }
            }
        }
    }
    /** @ts-ignore */ getMetallicRoughnessTexCoord(scope) {
        return scope.$inputs.mapUV;
    }
    /** @ts-ignore */ getNormalTexCoord(scope) {
        return scope.$inputs.mapUV;
    }
    /** @ts-ignore */ getAlbedoTexCoord(scope) {
        return scope.$inputs.mapUV;
    }
    calculateAlbedoColor(scope) {
        if (!this._options) {
            return super.calculateAlbedoColor(scope);
        }
        const that = this;
        const pb = scope.$builder;
        const funcName = 'getTerrainAlbedo';
        pb.func(funcName, [], function() {
            this.$l.mask = pb.textureSample(this.splatMap, this.$inputs.mapUV);
            this.$l.color = pb.vec3(0);
            const useTextureArray = !Array.isArray(that._options.detailMaps.albedoTextures);
            for(let i = 0; i < that._numDetailMaps; i++){
                const uv = pb.mul(this.$inputs.mapUV, this.detailScales.at(i).x);
                const sample = useTextureArray ? pb.textureArraySample(this.detailAlbedoMap, uv, i).rgb : pb.textureSample(this[`detailAlbedoMap${i}`], uv).rgb;
                this.color = pb.add(this.color, pb.mul(sample, this.mask[i]));
            }
            this.$return(pb.vec4(this.color, 1));
        });
        return pb.getGlobalScope()[funcName]();
    }
    sampleDetailNormalMap(scope, tex, texCoord, normalScale, TBN) {
        const pb = scope.$builder;
        const pixel = pb.sub(pb.mul(pb.textureSample(tex, texCoord).rgb, 2), pb.vec3(1));
        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(normalScale).xx, 1));
        return pb.normalize(pb.mul(TBN, normalTex));
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.needFragmentColor()) {
            scope.terrainInfo = pb.vec4().uniform(2);
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.worldNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            scope.$outputs.mapUV = pb.div(scope.oPos.xz, scope.terrainInfo.xy);
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            if (this._options) {
                scope.detailScales = pb.vec4[this._numDetailMaps]().uniform(2);
                scope.splatMap = pb.tex2D().uniform(2);
                const useAlbedoTextureArray = !Array.isArray(that._options.detailMaps.albedoTextures);
                if (useAlbedoTextureArray) {
                    scope.detailAlbedoMap = pb.tex2DArray().uniform(2);
                } else {
                    for(let i = 0; i < that._numDetailMaps; i++){
                        scope[`detailAlbedoMap${i}`] = pb.tex2D().uniform(2);
                    }
                }
                const useNormalTextureArray = !Array.isArray(that._options.detailMaps.normalTextures);
                if (useNormalTextureArray) {
                    scope.detailNormalMap = pb.tex2DArray().uniform(2);
                } else {
                    for(let i = 0; i < that._numDetailMaps; i++){
                        scope[`detailNormalMap${i}`] = pb.tex2D().uniform(2);
                    }
                }
            }
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.worldNorm);
            let calcNormal = false;
            if (this._options && this._options.detailMaps.normalTextures) {
                scope.$l.detailMask = pb.textureSample(scope.splatMap, scope.$inputs.mapUV);
                if (Array.isArray(this._options.detailMaps.normalTextures)) {
                    for(let i = 0; i < this._options.detailMaps.normalTextures.length; i++){
                        const tex = scope[`detailNormalMap${i}`];
                        const scale = scope.detailScales.at(i).y;
                        const texCoord = pb.mul(scope.$inputs.mapUV, scope.detailScales.at(i).x);
                        scope.normalInfo.normal = pb.add(scope.normalInfo.normal, pb.mul(this.sampleDetailNormalMap(scope, tex, texCoord, scale, scope.normalInfo.TBN), scope.detailMask[i]));
                        calcNormal = true;
                    }
                } else {
                    const tex = scope.detailNormalMap;
                    for(let i = 0; i < this._numDetailMaps; i++){
                        const scale = scope.detailScales.at(i).y;
                        const texCoord = pb.mul(scope.$inputs.mapUV, scope.detailScales.at(i).x);
                        const pixel = pb.sub(pb.mul(pb.textureArraySample(tex, texCoord, i).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(scale).xx, 1));
                        const detailNormal = pb.normalize(pb.mul(scope.normalInfo.TBN, normalTex));
                        scope.normalInfo.normal = pb.add(scope.normalInfo.normal, pb.mul(detailNormal, scope.detailMask[i]));
                        calcNormal = true;
                    }
                }
            }
            if (calcNormal) {
                scope.normalInfo.normal = pb.normalize(scope.normalInfo.normal);
            }
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
    generateMetallicRoughnessMap() {
        const device = Application.instance.device;
        if (!this._options) {
            const tex = device.createTexture2D('rgba8unorm', 1, 1, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            tex.update(new Uint8Array([
                0,
                1,
                0,
                0
            ]), 0, 0, 1, 1);
            tex.name = 'TerrainMetallicRoughnessMap';
            return tex;
        }
        if (!TerrainMaterial._metallicRoughnessGenerationProgram) {
            TerrainMaterial._metallicRoughnessGenerationProgram = device.buildRenderProgram({
                vertex (pb) {
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        if (device.type === 'webgpu') {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        }
                    });
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.roughness = pb.vec4().uniform(0);
                    this.metallic = pb.vec4().uniform(0);
                    this.splatMap = pb.tex2D().uniform(0);
                    pb.main(function() {
                        this.weights = pb.textureSample(this.splatMap, this.$inputs.uv);
                        this.roughnessValue = pb.dot(this.weights, this.roughness);
                        this.metallicValue = pb.dot(this.weights, this.metallic);
                        this.$outputs.outColor = pb.vec4(0, this.roughnessValue, this.metallicValue, 1);
                    });
                }
            });
            TerrainMaterial._metallicRoughnessGenerationBindGroup = device.createBindGroup(TerrainMaterial._metallicRoughnessGenerationProgram.bindGroupLayouts[0]);
        }
        const roughnessValues = Vector4.one();
        const metallicValues = Vector4.zero();
        for(let i = 0; i < this._numDetailMaps; i++){
            metallicValues[i] = this._uvScales[i * 4 + 2];
            roughnessValues[i] = this._uvScales[i * 4 + 3];
        }
        const tex = device.createTexture2D('rgba8unorm', this._options.splatMap.width, this._options.splatMap.height);
        tex.name = 'TerrainMetallicRoughnessMap';
        const program = TerrainMaterial._metallicRoughnessGenerationProgram;
        const bindgroup = TerrainMaterial._metallicRoughnessGenerationBindGroup;
        bindgroup.setValue('roughness', roughnessValues);
        bindgroup.setValue('metallic', metallicValues);
        bindgroup.setTexture('splatMap', this._options.splatMap);
        const fb = device.createFrameBuffer([
            tex
        ], null);
        device.pushDeviceStates();
        device.setFramebuffer(fb);
        device.setProgram(program);
        device.setBindGroup(0, bindgroup);
        drawFullscreenQuad();
        device.popDeviceStates();
        fb.dispose();
        return tex;
    }
}

/**
 * PBRMetallicRoughness material class
 * @public
 */ class PBRMetallicRoughnessMaterial extends applyMaterialMixins(MeshMaterial, mixinPBRMetallicRoughness, mixinVertexColor) {
    /** @internal */ static FEATURE_VERTEX_NORMAL = this.defineFeature();
    /** @internal */ static FEATURE_VERTEX_TANGENT = this.defineFeature();
    /**
   * Creates an instance of PBRMetallicRoughnessMaterial class
   */ constructor(){
        super();
        this.useFeature(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

function mixinPBRSpecularGlossness(BaseCls) {
    if (BaseCls.pbrSpecularGlossnessMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinPBRCommon, mixinLight, mixinTextureProps('specular'));
    return class extends S {
        static pbrSpecularGlossnessMixed = true;
        _specularFactor;
        _glossinessFactor;
        constructor(){
            super();
            this._specularFactor = Vector4.one();
            this._glossinessFactor = 1;
        }
        get specularFactor() {
            return this._specularFactor;
        }
        set specularFactor(val) {
            if (!val.equalsTo(this._specularFactor)) {
                this._specularFactor.set(val);
                this.uniformChanged();
            }
        }
        get glossinessFactor() {
            return this._glossinessFactor;
        }
        set glossinessFactor(val) {
            if (val !== this._glossinessFactor) {
                this._glossinessFactor = val;
                this.uniformChanged();
            }
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            if (this.needFragmentColor()) {
                const pb = scope.$builder;
                scope.zSpecularFactor = pb.vec4().uniform(2);
                scope.zGlossinessFactor = pb.float().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zSpecularFactor', this._specularFactor);
                bindGroup.setValue('zGlossinessFactor', this._glossinessFactor);
            }
        }
        PBRLight(scope, worldPos, normal, viewVec, albedo, TBN) {
            const pb = scope.$builder;
            const funcName = 'Z_PBRSpecularGlossinessLight';
            const that = this;
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec3('normal'),
                pb.mat3('TBN'),
                pb.vec3('viewVec'),
                pb.vec4('albedo')
            ], function() {
                this.$l.pbrData = that.getCommonData(this, this.albedo, this.viewVec, this.TBN);
                this.$l.lightingColor = pb.vec3(0);
                this.$l.emissiveColor = that.calculateEmissiveColor(this);
                that.indirectLighting(this, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                that.forEachLight(this, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                    this.$l.diffuse = pb.vec3();
                    this.$l.specular = pb.vec3();
                    this.$l.lightAtten = that.calculateLightAttenuation(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.lightDir = that.calculateLightDirection(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                    this.$l.lightColor = pb.mul(colorIntensity.rgb, colorIntensity.a, this.lightAtten, this.NoL);
                    if (shadow) {
                        this.lightColor = pb.mul(this.lightColor, that.calculateShadow(this, this.worldPos, this.NoL));
                    }
                    that.directLighting(this, this.lightDir, this.lightColor, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                });
                this.$return(pb.add(this.lightingColor, this.emissiveColor));
            });
            return pb.getGlobalScope()[funcName](worldPos, normal, TBN, viewVec, albedo);
        }
        calculateCommonData(scope, albedo, viewVec, TBN, data) {
            super.calculateCommonData(scope, albedo, viewVec, TBN, data);
            const pb = scope.$builder;
            if (this.specularTexture) {
                scope.$l.specularTextureSample = this.sampleSpecularTexture(scope);
                data.roughness = pb.sub(1, pb.mul(scope.zGlossinessFactor, scope.specularTextureSample.a));
                data.f0 = pb.vec4(pb.mul(scope.specularTextureSample.rgb, scope.zSpecularFactor.rgb), this.getF0(scope).a);
            } else {
                data.roughness = pb.sub(1, scope.zGlossinessFactor);
                data.f0 = pb.vec4(scope.zSpecularFactor.rgb, this.getF0(scope).a);
            }
            data.metallic = pb.max(pb.max(data.f0.r, data.f0.g), data.f0.b);
            data.diffuse = pb.vec4(pb.mul(albedo.rgb, pb.sub(1, data.metallic)), albedo.a);
            data.specularWeight = 1;
            data.f90 = pb.vec3(1);
        }
    };
}

class PBRSpecularGlossinessMaterial extends applyMaterialMixins(MeshMaterial, mixinPBRSpecularGlossness, mixinVertexColor) {
    static FEATURE_VERTEX_NORMAL = this.defineFeature();
    static FEATURE_VERTEX_TANGENT = this.defineFeature();
    constructor(){
        super();
        this.useFeature(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

/**
 * A queue that contains the items to be rendered
 * @public
 */ class RenderQueue {
    /** @internal */ _itemLists;
    /** @internal */ _renderPass;
    /** @internal */ _shadowedLightList;
    /** @internal */ _unshadowedLightList;
    /** @internal */ _sunLight;
    /**
   * Creates an instance of a render queue
   * @param renderPass - The render pass to which the render queue belongs
   */ constructor(renderPass){
        this._itemLists = {};
        this._renderPass = renderPass;
        this._shadowedLightList = [];
        this._unshadowedLightList = [];
        this._sunLight = null;
    }
    /** The sun light */ get sunLight() {
        return this._sunLight;
    }
    set sunLight(light) {
        this._sunLight = light;
    }
    /** The render pass to which the render queue belongs */ get renderPass() {
        return this._renderPass;
    }
    /**
   * Gets the items of the render queue
   */ get items() {
        return this._itemLists;
    }
    /**
   * Gets the shadowed lights
   */ get shadowedLights() {
        return this._shadowedLightList;
    }
    /**
   * Gets the unshadowed lights
   */ get unshadowedLights() {
        return this._unshadowedLightList;
    }
    /**
   * Gets the maximum batch size of a given device
   * @returns The maximum batch size of the device
   *
   * @internal
   */ getMaxBatchSize() {
        return Application.instance.device.getDeviceCaps().shaderCaps.maxUniformBufferSize / 64;
    }
    /**
   * Push a punctual light
   * @param light - The light to be pushed
   */ pushLight(light) {
        if (light.castShadow) {
            this._shadowedLightList.push(light);
        } else {
            this._unshadowedLightList.push(light);
        }
        if (light.isDirectionLight() && light.sunLight) {
            this.sunLight = light;
        }
    }
    /**
   * Push an item to the render queue
   * @param camera - The camera for drawing the item
   * @param drawable - The object to be drawn
   * @param renderOrder - Render order of the object
   */ push(camera, drawable, renderOrder) {
        if (drawable) {
            let itemList = this._itemLists[renderOrder];
            if (!itemList) {
                itemList = {
                    opaqueList: [],
                    opaqueInstanceList: {},
                    transList: [],
                    transInstanceList: {}
                };
                this._itemLists[renderOrder] = itemList;
            }
            const trans = drawable.getQueueType() === QUEUE_TRANSPARENT;
            const list = trans ? itemList.transList : itemList.opaqueList;
            if (drawable.isBatchable()) {
                const instanceList = trans ? itemList.transInstanceList : itemList.opaqueInstanceList;
                const hash = drawable.getInstanceId(this._renderPass);
                const index = instanceList[hash];
                if (index === undefined || list[index].instanceData.worldMatrices.length === this.getMaxBatchSize()) {
                    instanceList[hash] = list.length;
                    list.push({
                        drawable,
                        sortDistance: drawable.getSortDistance(camera),
                        instanceData: {
                            worldMatrices: [
                                drawable.getXForm().worldMatrix
                            ],
                            hash: hash
                        }
                    });
                } else {
                    list[index].instanceData.worldMatrices.push(drawable.getXForm().worldMatrix);
                }
            } else {
                list.push({
                    drawable,
                    sortDistance: drawable.getSortDistance(camera),
                    instanceData: null
                });
            }
        }
    }
    /**
   * Removes all items in the render queue
   */ clear() {
        this._itemLists = {};
        this._shadowedLightList = [];
        this._unshadowedLightList = [];
        this._sunLight = null;
    }
    /**
   * Sorts the items in the render queue for rendering
   */ sortItems() {
        for (const list of Object.values(this._itemLists)){
            list.opaqueList.sort((a, b)=>a.sortDistance - b.sortDistance);
            list.transList.sort((a, b)=>b.sortDistance - a.sortDistance);
        }
    }
    encodeInstanceColor(index, outColor) {
        outColor[0] = (index >> 24 & 255) / 255;
        outColor[1] = (index >> 16 & 255) / 255;
        outColor[2] = (index >> 8 && 255) / 255;
        outColor[3] = (index >> 0 && 255) / 255;
    }
    /*
  private decodeInstanceColor(value: Float32Array): number {
    return (value[0] << 24) + (value[1] << 16) + (value[2] << 8) + value[3];
  }
  */ setInstanceColors() {
        const nodes = [];
        let id = 0;
        for(const k in this._itemLists){
            const lists = this._itemLists[k];
            for (const item of lists.opaqueList){
                if (item.instanceColor) {
                    item.instanceData.instanceColorList = [];
                    for(let i = 0; i < item.instanceData.worldMatrices.length; i++){
                        const v = item.drawable.getInstanceColor();
                        this.encodeInstanceColor(id, v);
                        nodes[id] = item.drawable.getPickTarget();
                        item.instanceData.instanceColorList.push(v);
                        id++;
                    }
                }
            }
        }
        return nodes;
    }
}

/**
 * Base class for any kind of render passes
 * @public
 */ class RenderPass {
    /** @internal */ _type;
    /** @internal */ _globalBindGroups;
    /** @internal */ _clearColor;
    /** @internal */ _clearDepth;
    /** @internal */ _clearStencil;
    /**
   * Creates an instanceof RenderPass
   * @param type - Render pass type
   */ constructor(type){
        this._type = type;
        this._clearColor = new Vector4(0, 0, 0, 1);
        this._clearDepth = 1;
        this._clearStencil = 0;
        this._globalBindGroups = {};
    }
    /** Color value that is used to clear the frame buffer  */ get clearColor() {
        return this._clearColor;
    }
    set clearColor(color) {
        this._clearColor = color ?? null;
    }
    /** Depth value that is used to clear the frame buffer */ get clearDepth() {
        return this._clearDepth;
    }
    set clearDepth(depth) {
        this._clearDepth = depth ?? null;
    }
    /** Stencil value that is used to clear the frame buffer */ get clearStencil() {
        return this._clearStencil;
    }
    set clearStencil(stencil) {
        this._clearStencil = stencil ?? null;
    }
    /**
   * The render pass type
   */ get type() {
        return this._type;
    }
    /** @internal */ isAutoFlip() {
        return !!(Application.instance.device.getFramebuffer() && Application.instance.device.type === 'webgpu');
    }
    /**
   * Renders a scene
   * @param ctx - Drawing context
   */ render(ctx, cullCamera, renderQueue) {
        ctx.renderPass = this;
        this.drawScene(ctx, cullCamera ?? ctx.camera, renderQueue);
    }
    /** @internal */ applyRenderStates(device, stateSet, ctx) {
        device.setRenderStates(stateSet);
    }
    /** @internal */ getGlobalBindGroupInfo(ctx) {
        const hash = this.getGlobalBindGroupHash(ctx);
        let bindGroup = this._globalBindGroups[hash];
        if (!bindGroup) {
            //const programBuilder = new ProgramBuilder(Application.instance.device);
            const ret = Application.instance.device.programBuilder.buildRender({
                vertex (pb) {
                    ShaderHelper.prepareVertexShader(pb, ctx);
                    pb.main(function() {});
                },
                fragment (pb) {
                    ShaderHelper.prepareFragmentShader(pb, ctx);
                    pb.main(function() {});
                }
            });
            bindGroup = {
                bindGroup: Application.instance.device.createBindGroup(ret[2][0]),
                layout: ret[2][0]
            };
            this._globalBindGroups[hash] = bindGroup;
        }
        if (bindGroup.bindGroup.disposed) {
            bindGroup.bindGroup.reload();
        }
        return bindGroup;
    }
    /**
   * Disposes the render pass
   */ dispose() {
        for(const k in this._globalBindGroups){
            Material.bindGroupGarbageCollect(this._globalBindGroups[k].bindGroup);
        }
        this._globalBindGroups = {};
    }
    /** @internal */ getGlobalBindGroupHash(ctx) {
        return `${this.constructor.name}:${this._getGlobalBindGroupHash(ctx)}`;
    }
    /** @internal */ drawScene(ctx, cullCamera, renderQueue) {
        const device = Application.instance.device;
        this.clearFramebuffer();
        renderQueue = renderQueue ?? this.cullScene(ctx, cullCamera);
        if (renderQueue) {
            const windingReversed = device.isWindingOrderReversed();
            device.reverseVertexWindingOrder(this.isAutoFlip() ? !windingReversed : windingReversed);
            this.renderItems(ctx, renderQueue);
            device.reverseVertexWindingOrder(windingReversed);
        }
    }
    /**
   * Culls a scene by a given camera
   * @param ctx - The draw context
   * @param cullCamera - The camera that will be used to cull the scene
   * @returns The cull result
   */ cullScene(ctx, cullCamera) {
        if (cullCamera) {
            const renderQueue = new RenderQueue(this);
            const cullVisitor = new CullVisitor(this, cullCamera, renderQueue, ctx.primaryCamera);
            if (ctx.scene.octree) {
                ctx.scene.octree.getRootNode().traverse(cullVisitor);
            } else {
                ctx.scene.rootNode.traverse(cullVisitor);
            }
            return renderQueue;
        }
        return null;
    }
    /** @internal */ drawItem(device, item, ctx, reverseWinding) {
        const reverse = reverseWinding !== item.drawable.getXForm().worldMatrixDet < 0;
        if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
        }
        item.drawable.draw(ctx);
        if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
        }
    }
    /** @internal */ clearFramebuffer() {
        Application.instance.device.clearFrameBuffer(this._clearColor, this._clearDepth, this._clearStencil);
    }
}

/**
 * Forward render pass
 * @internal
 */ class LightPass extends RenderPass {
    /** @internal */ _shadowMapHash;
    /**
   * Creates an instance of ForwardRenderPass
   */ constructor(){
        super(RENDER_PASS_TYPE_LIGHT);
        this._shadowMapHash = null;
    }
    /** @internal */ _getGlobalBindGroupHash(ctx) {
        return `${this._shadowMapHash}:${ctx.env.getHash(ctx)}`;
    }
    /** @internal */ renderLightPass(ctx, items, lights) {
        const device = Application.instance.device;
        const baseLightPass = !ctx.lightBlending;
        ctx.drawEnvLight = baseLightPass && ctx.env.light.type !== 'none' && (ctx.env.light.envLight.hasRadiance() || ctx.env.light.envLight.hasIrradiance());
        ctx.renderPassHash = this.getGlobalBindGroupHash(ctx);
        const info = this.getGlobalBindGroupInfo(ctx);
        ShaderHelper.setCameraUniforms(info.bindGroup, ctx, !!device.getFramebuffer());
        if (ctx.currentShadowLight) {
            ShaderHelper.setLightUniformsShadow(info.bindGroup, ctx, lights[0]);
        } else {
            ShaderHelper.setLightUniforms(info.bindGroup, ctx, ctx.clusteredLight.clusterParam, ctx.clusteredLight.countParam, ctx.clusteredLight.lightBuffer, ctx.clusteredLight.lightIndexTexture);
        }
        if (ctx.applyFog) {
            ShaderHelper.setFogUniforms(info.bindGroup, ctx.env.sky.mappedFogType, baseLightPass ? ctx.env.sky.fogColor : Vector4.zero(), ctx.env.sky.fogParams, ctx.env.sky.aerialPerspectiveDensity * ctx.env.sky.aerialPerspectiveDensity, ctx.env.sky.getAerialPerspectiveLUT(ctx));
        }
        device.setBindGroup(0, info.bindGroup);
        const reverseWinding = ctx.camera.worldMatrixDet < 0;
        for (const item of items){
            // unlit objects should only be drawn once
            if (!ctx.lightBlending || !item.drawable.isUnlit()) {
                ctx.instanceData = item.instanceData;
                ctx.target = item.drawable;
                this.drawItem(device, item, ctx, reverseWinding);
            }
        }
    }
    /** @internal */ renderItems(ctx, renderQueue) {
        ctx.applyFog = false;
        ctx.target = null;
        ctx.renderPassHash = null;
        ctx.env = ctx.scene.env;
        ctx.drawEnvLight = false;
        ctx.flip = this.isAutoFlip();
        renderQueue.sortItems();
        const orders = Object.keys(renderQueue.items).map((val)=>Number(val)).sort((a, b)=>a - b);
        for(let i = 0; i < 2; i++){
            ctx.applyFog = i === 1 && ctx.env.sky.fogType !== 'none';
            ctx.queue = i === 0 ? QUEUE_OPAQUE : QUEUE_TRANSPARENT;
            for (const order of orders){
                const items = renderQueue.items[order];
                const lists = [
                    items.opaqueList,
                    items.transList
                ];
                const list = lists[i];
                let lightIndex = 0;
                if (ctx.shadowMapInfo) {
                    for (const k of ctx.shadowMapInfo.keys()){
                        ctx.currentShadowLight = k;
                        ctx.lightBlending = lightIndex > 0;
                        this._shadowMapHash = ctx.shadowMapInfo.get(k).shaderHash;
                        this.renderLightPass(ctx, list, [
                            k
                        ]);
                        lightIndex++;
                    }
                }
                if (lightIndex === 0 || renderQueue.unshadowedLights.length > 0) {
                    ctx.currentShadowLight = null;
                    ctx.lightBlending = lightIndex > 0;
                    this._shadowMapHash = '';
                    this.renderLightPass(ctx, list, renderQueue.unshadowedLights);
                }
            }
            if (i === 0) {
                ctx.env.sky.skyWorldMatrix = ctx.scene.rootNode.worldMatrix;
                ctx.env.sky.renderSky(ctx);
            }
            ctx.compositor?.drawPostEffects(ctx, i === 0, ctx.linearDepthTexture);
            if (i === 0) {
                ctx.env.sky.renderFog(ctx);
            }
        }
    }
}

/**
 * Shadow map render pass
 *
 * @public
 */ class ShadowMapPass extends RenderPass {
    /** @internal */ _currentLight;
    /** @internal */ _stateOverriden;
    /**
   * Creates an instance of ShadowMapPass
   */ constructor(){
        super(RENDER_PASS_TYPE_SHADOWMAP);
        this._currentLight = null;
        this._stateOverriden = null;
    }
    /** The light that will be used to render shadow map */ get light() {
        return this._currentLight;
    }
    set light(light) {
        this._currentLight = light;
    }
    /** @internal */ get stateOverriden() {
        if (!this._stateOverriden) {
            this._stateOverriden = Application.instance.device.createRenderStateSet();
            this._stateOverriden.useRasterizerState().setCullMode('none');
        }
        return this._stateOverriden;
    }
    /** @internal */ applyRenderStates(device, stateSet, ctx) {
        const stateOverriden = this.stateOverriden;
        const state = stateOverriden.rasterizerState;
        stateOverriden.copyFrom(stateSet);
        stateOverriden.useRasterizerState(state);
        device.setRenderStates(stateOverriden);
    }
    /** @internal */ _getGlobalBindGroupHash(ctx) {
        return ctx.shadowMapInfo.get(this.light).shaderHash;
    }
    /** @internal */ renderItems(ctx, renderQueue) {
        ctx.target = null;
        ctx.drawEnvLight = false;
        ctx.env = null;
        ctx.applyFog = false;
        ctx.renderPassHash = null;
        ctx.flip = this.isAutoFlip();
        const device = Application.instance.device;
        const bindGroup = this.getGlobalBindGroupInfo(ctx).bindGroup;
        device.setBindGroup(0, bindGroup);
        ShaderHelper.setLightUniformsShadowMap(bindGroup, ctx, this._currentLight);
        ShaderHelper.setCameraUniforms(bindGroup, ctx, true);
        ctx.renderPassHash = this.getGlobalBindGroupHash(ctx);
        const reverseWinding = ctx.camera.worldMatrixDet < 0;
        for (const order of Object.keys(renderQueue.items).map((val)=>Number(val)).sort((a, b)=>a - b)){
            const renderItems = renderQueue.items[order];
            for (const item of renderItems.opaqueList){
                ctx.instanceData = item.instanceData;
                ctx.target = item.drawable;
                this.drawItem(device, item, ctx, reverseWinding);
            }
        }
    }
}

/**
 * Depth render pass
 *
 * Scene depth render pass
 *
 * @public
 */ class DepthPass extends RenderPass {
    /**
   * Creates an instance of DepthRenderPass
   */ constructor(){
        super(RENDER_PASS_TYPE_DEPTH);
    }
    /** @internal */ _getGlobalBindGroupHash(ctx) {
        return '';
    }
    /** @internal */ renderItems(ctx, renderQueue) {
        ctx.target = null;
        ctx.applyFog = false;
        ctx.drawEnvLight = false;
        ctx.env = null;
        ctx.renderPassHash = null;
        ctx.flip = this.isAutoFlip();
        const device = Application.instance.device;
        const bindGroup = this.getGlobalBindGroupInfo(ctx).bindGroup;
        device.setBindGroup(0, bindGroup);
        ShaderHelper.setCameraUniforms(bindGroup, ctx, true);
        ctx.renderPassHash = this.getGlobalBindGroupHash(ctx);
        const reverseWinding = ctx.camera.worldMatrixDet < 0;
        for (const order of Object.keys(renderQueue.items).map((val)=>Number(val)).sort((a, b)=>a - b)){
            const renderItems = renderQueue.items[order];
            for (const item of renderItems.opaqueList){
                ctx.instanceData = item.instanceData;
                ctx.target = item.drawable;
                this.drawItem(device, item, ctx, reverseWinding);
            }
        }
    }
}

/**
 * Calculate 3d noise by a 3d position
 *
 * @param scope - current shader scope
 * @param p - 3d position at where to calculate noise
 * @returns noise value between 0 and 1
 *
 * @public
 */ function noise3D(scope, p) {
    const pb = scope.$builder;
    const funcName = 'Z_noise3d';
    pb.func(funcName, [
        pb.vec3('p')
    ], function() {
        this.$l.p3 = pb.fract(pb.mul(this.p, 0.1031));
        this.$l.p3 = pb.add(this.p3, pb.vec3(pb.dot(this.p3, pb.add(this.p3.yzx, pb.vec3(33.33)))));
        this.$return(pb.fract(pb.mul(pb.add(this.p3.x, this.p3.y), this.p3.z)));
    });
    return pb.getGlobalScope()[funcName](p);
}
/**
 * Calculate smooth 3d noise by a 3d position
 *
 * @param scope - current shader scope
 * @param p - 3d position at where to calculate noise
 * @returns noise value between 0 and 1
 *
 * @public
 */ function smoothNoise3D(scope, p) {
    const pb = scope.$builder;
    const funcName = 'Z_smoothNoise3D';
    pb.func(funcName, [
        pb.vec3('p')
    ], function() {
        this.$l.cell = pb.floor(this.p);
        this.$l.local = pb.fract(this.p);
        this.$l.local = pb.mul(this.local, pb.mul(this.local, pb.sub(pb.vec3(3), pb.mul(this.local, 2))));
        this.$l.ldb = noise3D(this, this.cell);
        this.$l.rdb = noise3D(this, pb.add(this.cell, pb.vec3(1, 0, 0)));
        this.$l.ldf = noise3D(this, pb.add(this.cell, pb.vec3(0, 0, 1)));
        this.$l.rdf = noise3D(this, pb.add(this.cell, pb.vec3(1, 0, 1)));
        this.$l.lub = noise3D(this, pb.add(this.cell, pb.vec3(0, 1, 0)));
        this.$l.rub = noise3D(this, pb.add(this.cell, pb.vec3(1, 1, 0)));
        this.$l.luf = noise3D(this, pb.add(this.cell, pb.vec3(0, 1, 1)));
        this.$l.ruf = noise3D(this, pb.add(this.cell, pb.vec3(1, 1, 1)));
        this.$return(pb.mix(pb.mix(pb.mix(this.ldb, this.rdb, this.local.x), pb.mix(this.ldf, this.rdf, this.local.x), this.local.z), pb.mix(pb.mix(this.lub, this.rub, this.local.x), pb.mix(this.luf, this.ruf, this.local.x), this.local.z), this.local.y));
    });
    return pb.getGlobalScope()[funcName](p);
}

new AABB();
new Vector2(0, 0);
[
    Matrix4x4.identity(),
    // rotation z 270
    Matrix4x4.rotationZ(270 * Math.PI / 180),
    //new Matrix4x4(0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
    // rotation z 90
    Matrix4x4.rotationZ(90 * Math.PI / 180),
    //new Matrix4x4(0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
    // rotation z 180
    Matrix4x4.rotationZ(180 * Math.PI / 180)
];

/** @internal */ ({
    cascades: [
        {
            size: 450.0,
            strength: 0.8,
            croppiness: -1.2,
            minWave: 0,
            maxWave: 100
        },
        {
            size: 103.0,
            strength: 0.8,
            croppiness: -1.5,
            minWave: 0,
            maxWave: 100
        },
        {
            size: 13,
            strength: 0.9,
            croppiness: -1.5,
            minWave: 0,
            maxWave: 7
        }
    ],
    resolution: 256,
    wind: new Vector2(2, 2),
    alignment: 0.01,
    foamParams: new Vector2(1, 2),
    randomSeed: 0
});

/**
 * The camera node class
 * @public
 */ class Camera extends SceneNode {
    /** @internal */ _projMatrix;
    /** @internal */ _viewMatrix;
    /** @internal */ _viewProjMatrix;
    /** @internal */ _rotationMatrix;
    /** @internal */ _invViewProjMatrix;
    /** @internal */ _clipPlane;
    /** @internal */ _controller;
    /** @internal */ _frustum;
    /** @internal */ _frustumV;
    /** @internal */ _dirty;
    /** @internal */ _sampleCount;
    /** @internal */ _framebuffer;
    /** @internal */ _viewport;
    /** @internal */ _scissor;
    /** @internal */ _clearColor;
    /** @internal */ _clipMask;
    /**
   * Creates a new camera node
   * @param scene - The scene that the camera belongs to
   * @param projectionMatrix - Projection matrix for this camera
   */ constructor(scene, projectionMatrix){
        super(scene);
        this._projMatrix = projectionMatrix || Matrix4x4.identity();
        this._viewMatrix = Matrix4x4.identity();
        this._viewProjMatrix = Matrix4x4.identity();
        this._invViewProjMatrix = Matrix4x4.identity();
        this._clipPlane = null;
        this._dirty = true;
        this._controller = null;
        this._framebuffer = null;
        this._viewport = null;
        this._scissor = null;
        this._clearColor = new Vector4(0, 0, 0, 1);
        this._clipMask = 0;
        this._sampleCount = 1;
        this._frustum = null;
        this._frustumV = null;
    }
    /** Clip plane in camera space */ get clipPlane() {
        return this._clipPlane;
    }
    set clipPlane(plane) {
        this._clipPlane = plane;
        this._invalidate(false);
    }
    /**
   * Sample count for MSAA
   *
   * @remarks
   * If greater than one, force the scene to be rendered using multisampled framebuffer
   */ get sampleCount() {
        return this._sampleCount;
    }
    set sampleCount(val) {
        if (val !== 1 && val !== 4) {
            console.error(`Invalid sample count: ${val}`);
        } else {
            this._sampleCount = val;
        }
    }
    /** Clip plane mask */ get clipMask() {
        return this._clipMask;
    }
    set clipMask(val) {
        this._clipMask = val;
    }
    /** Framebuffer object into which the scene will be rendered */ get framebuffer() {
        return this._framebuffer;
    }
    set framebuffer(fb) {
        this._framebuffer = fb ?? null;
    }
    /** Viewport used for rendering, if null, use full framebuffer size */ get viewport() {
        return this._viewport ? [
            ...this._viewport
        ] : null;
    }
    set viewport(rect) {
        this._viewport = rect?.slice() ?? null;
    }
    /** Scissor rectangle used for rendering, if null, use viewport value */ get scissor() {
        return this._scissor ? [
            ...this._scissor
        ] : null;
    }
    set scissor(rect) {
        this._scissor = rect?.slice() ?? null;
    }
    /** Color value used to clear color buffer before rendering, if null, color buffer will not be cleared */ get clearColor() {
        return this._clearColor;
    }
    set clearColor(val) {
        if (!val) {
            this._clearColor = null;
        } else {
            this._clearColor.set(val);
        }
    }
    /**
   * Handle input events
   * @param ev - input event object
   * @param type - event type, default to ev.type
   * @returns Boolean value indicates whether the event was handled.
   */ handleEvent(ev, type) {
        let handled = false;
        if (this._controller) {
            type = type ?? ev.type;
            if (type === 'pointerdown') {
                handled = this._controller.onMouseDown(ev);
            } else if (type === 'pointerup') {
                handled = this._controller.onMouseUp(ev);
            } else if (type === 'pointermove') {
                handled = this._controller.onMouseMove(ev);
            } else if (type === 'wheel') {
                handled = this._controller.onMouseWheel(ev);
            } else if (type === 'keydown') {
                handled = this._controller.onKeyDown(ev);
            } else if (type === 'keyup') {
                handled = this._controller.onKeyUp(ev);
            }
            if (handled) {
                ev.preventDefault();
            }
        }
        return handled;
    }
    /**
   * Place the camera by specifying the camera position and the target point
   * @param eye - The camera position
   * @param target - The target point to look at
   * @param up - The up vector
   * @returns self
   */ lookAt(eye, target, up) {
        return this.setLocalTransform(Matrix4x4.lookAt(eye, target, up));
    }
    /**
   * Place the camera to look at a given cube face at a given camera position
   * @param face - The cube face to look at
   * @param position - The camera position
   * @returns self
   */ lookAtCubeFace(face, position) {
        return this.setLocalTransform(Matrix4x4.lookAtCubeFace(face, position ?? this.position));
    }
    /**
   * Setup a perspective projection matrix for the camera
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio
   * @param zNear - The near clip plane
   * @param zFar - The far clip plane
   * @returns self
   */ setPerspective(fovY, aspect, zNear, zFar) {
        this._projMatrix.perspective(fovY, aspect, zNear, zFar);
        this._invalidate(true);
        return this;
    }
    /**
   * Setup a orthogonal projection matrix for the camera
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @returns self
   */ setOrtho(left, right, bottom, top, near, far) {
        this._projMatrix.ortho(left, right, bottom, top, near, far);
        this._invalidate(true);
        return this;
    }
    /**
   * Setup a projection matrix for the camera
   * @param matrix - The projection matrix
   */ setProjectionMatrix(matrix) {
        if (matrix && matrix !== this._projMatrix) {
            this._projMatrix.set(matrix);
            this._invalidate(true);
        }
    }
    /**
   * Gets the projection matrix of the camera
   * @returns The projection matrix
   */ getProjectionMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._projMatrix;
    }
    getRotationMatrix() {
        const rotationMatrix = new Matrix4x4();
        this.worldMatrix.decompose(null, rotationMatrix, null);
        const xAxis = rotationMatrix.getRow(0).xyz().scaleBy(-1);
        const yAxis = rotationMatrix.getRow(1).xyz();
        const zAxis = rotationMatrix.getRow(2).xyz().scaleBy(-1);
        rotationMatrix.setRow(0, new Vector4(xAxis.x, xAxis.y, xAxis.z, 0));
        rotationMatrix.setRow(1, new Vector4(yAxis.x, yAxis.y, yAxis.z, 0));
        rotationMatrix.setRow(2, new Vector4(zAxis.x, zAxis.y, zAxis.z, 0));
        return rotationMatrix;
    }
    /**
   * View matrix of the camera
   *
   * @remarks
   * Camera's view matrix will transform a point from the world space to the camera space
   */ get viewMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._viewMatrix;
    }
    get viewProjectionMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._viewProjMatrix;
    }
    /**
   * The inverse-view-projection matrix of the camera
   *
   * @remarks
   * The inverse-view-projection matrix transforms a point from the clip space to the camera space
   */ get invViewProjectionMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._invViewProjMatrix;
    }
    /** Gets the frustum of the camera */ get frustum() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._frustum;
    }
    get frustumViewSpace() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        if (!this._frustumV) {
            this._frustumV = new Frustum(this._projMatrix);
        }
        return this._frustumV;
    }
    /** The camera controller  */ get controller() {
        return this._controller || null;
    }
    set controller(controller) {
        this.setController(controller);
    }
    /** {@inheritDoc SceneNode.isCamera} */ isCamera() {
        return true;
    }
    /** Gets the near clip plane of the camera */ getNearPlane() {
        return this._projMatrix.getNearPlane();
    }
    /** Gets the far clip plane of the camera */ getFarPlane() {
        return this._projMatrix.getFarPlane();
    }
    /** Gets the vertical field of view of the camera */ getFOV() {
        return this._projMatrix.getFov();
    }
    /** Gets the tangent of half of the vertical field of view */ getTanHalfFovy() {
        return this._projMatrix.getTanHalfFov();
    }
    /** Gets the aspect ratio */ getAspect() {
        return this._projMatrix.getAspect();
    }
    /**
   * Renders a scene
   * @param scene - The scene to be rendered
   * @param compositor - Compositor instance that will be used to apply postprocess effects
   */ render(scene, compositor, logger) {
        const device = Application.instance.device;
        device.pushDeviceStates();
        device.reverseVertexWindingOrder(false);
        device.setFramebuffer(this._framebuffer);
        SceneRenderer.setClearColor(this._clearColor);
        SceneRenderer.renderScene(scene, this, compositor, logger);
        device.popDeviceStates();
    }
    /**
   * Updates the controller state
   */ updateController() {
        this._controller?.update();
    }
    /**
   * Reset the controller
   */ resetController() {
        this._controller?.reset();
    }
    /** @internal */ setController(controller) {
        if (this._controller !== controller) {
            if (controller && controller._getCamera() && controller._getCamera() !== this) {
                throw new Error('Camera.setController failed: one camera controller object cannot be assigned to multiple camera');
            }
            this._controller?._setCamera(null);
            this._controller = controller;
            this._controller?._setCamera(this);
        }
        return this;
    }
    /** @internal */ _invalidate(projectMatrixChanged) {
        this._dirty = true;
        if (projectMatrixChanged) {
            this._frustumV = null;
        }
    }
    /** @internal */ _compute() {
        this._computeProj();
        Matrix4x4.invertAffine(this.worldMatrix, this._viewMatrix);
        Matrix4x4.multiply(this._projMatrix, this._viewMatrix, this._viewProjMatrix);
        Matrix4x4.invert(this._viewProjMatrix, this._invViewProjMatrix);
        if (!this._frustum) {
            this._frustum = new Frustum(this._viewProjMatrix);
        } else {
            this._frustum.initWithMatrix(this._viewProjMatrix);
        }
    }
    /** @internal */ _computeProj() {}
    /** @internal */ _onTransformChanged(invalidateLocal) {
        super._onTransformChanged(invalidateLocal);
        this._invalidate(false);
    }
    /** {@inheritdoc SceneNode.dispose} */ dispose() {
        this.setController(null);
        this._projMatrix = null;
        this._viewMatrix = null;
        this._viewProjMatrix = null;
    }
}

const fogTypeMap = {
    linear: ShaderHelper.FOG_TYPE_LINEAR,
    exp: ShaderHelper.FOG_TYPE_EXP,
    exp2: ShaderHelper.FOG_TYPE_EXP2,
    scatter: ShaderHelper.FOG_TYPE_SCATTER,
    none: ShaderHelper.FOG_TYPE_NONE
};
const defaultSkyWorldMatrix = Matrix4x4.identity();
/**
 * The sky renderer
 * @public
 */ class SkyRenderer {
    _skyType;
    _skyColor;
    _skyboxTexture;
    _updateRadianceMaps;
    _radianceMapDirty;
    _scatterSkyboxFramebuffer;
    _scatterSkyboxTextureWidth;
    _aerialPerspectiveDensity;
    _radianceMap;
    _radianceMapWidth;
    _irradianceMap;
    _irradianceMapWidth;
    _fogType;
    _fogColor;
    _fogParams;
    _cloudy;
    _cloudIntensity;
    _wind;
    _nearestSampler;
    _programSky;
    _bindgroupSky;
    _programFog;
    _bindgroupFog;
    _programFogScatter;
    _bindgroupFogScatter;
    _vertexLayout;
    _primitiveSky;
    _skyWorldMatrix;
    _renderStatesSky;
    _renderStatesSkyNoDepthTest;
    _renderStatesFog;
    _renderStatesFogScatter;
    _drawGround;
    _lastSunDir;
    /**
   * Creates an instance of SkyRenderer
   */ constructor(){
        this._skyType = 'scatter';
        this._updateRadianceMaps = true;
        this._radianceMapDirty = true;
        this._skyColor = Vector4.zero();
        this._skyboxTexture = null;
        this._scatterSkyboxFramebuffer = null;
        this._scatterSkyboxTextureWidth = 256;
        this._aerialPerspectiveDensity = 1;
        this._radianceMap = null;
        this._radianceMapWidth = 128;
        this._irradianceMap = null;
        this._irradianceMapWidth = 64;
        this._fogType = 'none';
        this._fogColor = Vector4.one();
        this._fogParams = new Vector4(1, 100, 50, 0.002);
        this._cloudy = 0.6;
        this._cloudIntensity = 40;
        this._wind = Vector2.zero();
        this._drawGround = false;
        this._nearestSampler = null;
        this._programSky = {};
        this._bindgroupSky = {};
        this._programFog = null;
        this._bindgroupFog = null;
        this._programFogScatter = null;
        this._bindgroupFogScatter = null;
        this._vertexLayout = null;
        this._primitiveSky = null;
        this._renderStatesSky = null;
        this._renderStatesSkyNoDepthTest = null;
        this._renderStatesFog = null;
        this._renderStatesFogScatter = null;
        this._skyWorldMatrix = defaultSkyWorldMatrix;
        this._lastSunDir = Vector3.zero();
    }
    /** @internal */ getHash(ctx) {
        return ctx.applyFog ? this._fogType === 'none' ? '0' : this.drawScatteredFog(ctx) ? '1' : '2' : '';
    }
    /** Which type of the sky should be rendered */ get skyType() {
        return this._skyType;
    }
    set skyType(val) {
        if (val !== this._skyType) {
            this._skyType = val;
            this.invalidateIBLMaps();
        }
    }
    /** Whether ground should be rendered */ get drawGround() {
        return this._drawGround;
    }
    set drawGround(val) {
        this._drawGround = !!val;
    }
    /**
   * Wether the IBL maps should be updated automatically.
   *
   * @remarks
   * If use use the sky for image-based lighting, the value shoud be set to true. default is false
   *
   */ get autoUpdateIBLMaps() {
        return this._updateRadianceMaps;
    }
    set autoUpdateIBLMaps(val) {
        if (this._updateRadianceMaps !== !!val) {
            this._updateRadianceMaps = !!val;
            if (this._updateRadianceMaps) {
                this.invalidateIBLMaps();
            }
        }
    }
    /**
   * The solid sky color
   */ get skyColor() {
        return this._skyColor;
    }
    set skyColor(val) {
        if (!val.equalsTo(this._skyColor)) {
            this._skyColor.set(val);
            this.invalidateIBLMaps();
        }
    }
    /** Aerial perspective density */ get aerialPerspectiveDensity() {
        return this._aerialPerspectiveDensity;
    }
    set aerialPerspectiveDensity(val) {
        this._aerialPerspectiveDensity = val;
    }
    /**
   * Light density of the sky.
   *
   * @remarks
   * This value controls how much cloud should be rendered when the sky type is scatter.
   * Typically, the value should be in the range of 0 to 1.
   */ get cloudy() {
        return this._cloudy;
    }
    set cloudy(val) {
        if (val !== this._cloudy && this._skyType === 'scatter') {
            this._cloudy = val;
            this.invalidateIBLMaps();
        }
    }
    /**
   * Intensity of the sky color
   */ get cloudIntensity() {
        return this._cloudIntensity;
    }
    set cloudIntensity(val) {
        if (val !== this._cloudIntensity && this._skyType === 'scatter') {
            this._cloudIntensity = val;
            this.invalidateIBLMaps();
        }
    }
    /**
   * Wind velocity
   *
   * @remarks
   * This value affects the movement of the cloud
   */ get wind() {
        return this._wind;
    }
    set wind(val) {
        this._wind.set(val);
    }
    /**
   * Radiance map of the sky.
   */ get radianceMap() {
        if (!this._radianceMap) {
            this._radianceMap = Application.instance.device.createCubeTexture('rgba16f', this._radianceMapWidth);
            this._radianceMap.name = 'SkyRadianceMap';
        }
        return this._radianceMap;
    }
    /**
   * Irradiance map of the sky.
   */ get irradianceMap() {
        if (!this._irradianceMap) {
            this._irradianceMap = Application.instance.device.createCubeTexture('rgba16f', this._irradianceMapWidth, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            this._irradianceMap.name = 'SkyIrradianceMap';
        }
        return this._irradianceMap;
    }
    /**
   * Cube texture for skybox.
   */ get skyboxTexture() {
        return this._skyboxTexture;
    }
    set skyboxTexture(tex) {
        if (tex !== this._skyboxTexture) {
            this._skyboxTexture = tex;
            if (this._skyType === 'skybox') {
                this.invalidateIBLMaps();
            }
        }
    }
    /** @internal */ get skyWorldMatrix() {
        return this._skyWorldMatrix;
    }
    set skyWorldMatrix(val) {
        val = val ?? defaultSkyWorldMatrix;
        if (val !== this._skyWorldMatrix) {
            this._skyWorldMatrix = val;
            this.invalidateIBLMaps();
        }
    }
    /** @internal */ get mappedFogType() {
        return fogTypeMap[this._fogType];
    }
    /** Current fog type */ get fogType() {
        return this._fogType;
    }
    set fogType(val) {
        this._fogType = val;
    }
    /** Start distance of linear fog */ get fogStart() {
        return this._fogParams.x;
    }
    set fogStart(val) {
        this._fogParams.x = val;
    }
    /** End distance of linear fog */ get fogEnd() {
        return this._fogParams.y;
    }
    set fogEnd(val) {
        this._fogParams.y = val;
    }
    /** Top distance of fog if fog type is not scatter */ get fogTop() {
        return this._fogParams.z;
    }
    set fogTop(val) {
        this._fogParams.z = val;
    }
    /** Density of exp/exp2 fog */ get fogDensity() {
        return this._fogParams.w;
    }
    set fogDensity(val) {
        this._fogParams.w = val;
    }
    /** The fog color if fog type is not scatter */ get fogColor() {
        return this._fogColor;
    }
    set fogColor(val) {
        this._fogColor.set(val);
    }
    /** @internal */ get fogParams() {
        return this._fogParams;
    }
    set fogParams(val) {
        this._fogParams.set(val);
    }
    /**
   * Force the radiance map and irradiance map to be regenerated.
   */ invalidateIBLMaps() {
        this._radianceMapDirty = true;
    }
    /** @internal */ drawScatteredFog(ctx) {
        return ctx.sunLight && this._fogType === 'scatter';
    }
    /** @internal */ getAerialPerspectiveLUT(ctx) {
        if (this.drawScatteredFog(ctx)) {
            const sunDir = SkyRenderer._getSunDir(ctx.sunLight);
            const alpha = Math.PI / 2 - Math.acos(Math.max(-1, Math.min(1, sunDir.y)));
            const farPlane = ctx.camera.getFarPlane() * this._aerialPerspectiveDensity * this._aerialPerspectiveDensity;
            return ScatteringLut.getAerialPerspectiveLut(alpha, farPlane);
        } else {
            return null;
        }
    }
    /**
   * Regenerate the radiance map and irradiance map
   *
   * @param sunLight - The sun light
   */ updateIBLMaps(sunDir) {
        const device = Application.instance.device;
        let bakedSkyboxTexture = null;
        if (this._skyType === 'skybox' && this._skyboxTexture) {
            bakedSkyboxTexture = this._skyboxTexture;
        } else {
            if (!this._scatterSkyboxFramebuffer) {
                const texCaps = device.getDeviceCaps().textureCaps;
                const format = texCaps.supportHalfFloatColorBuffer && texCaps.supportLinearHalfFloatTexture ? 'rgba16f' : texCaps.supportFloatColorBuffer && texCaps.supportLinearFloatTexture ? 'rgba32f' : 'rgba8unorm';
                const tex = device.createCubeTexture(format, this._scatterSkyboxTextureWidth);
                tex.name = 'BakedSkyboxTexture';
                this._scatterSkyboxFramebuffer = device.createFrameBuffer([
                    tex
                ], null);
                this._radianceMapDirty = true;
            }
            const camera = new Camera(null);
            camera.setPerspective(Math.PI / 2, 1, 1, 20);
            const saveRenderStates = device.getRenderStates();
            device.pushDeviceStates();
            device.setFramebuffer(this._scatterSkyboxFramebuffer);
            for (const face of [
                CubeFace.PX,
                CubeFace.NX,
                CubeFace.PY,
                CubeFace.NY,
                CubeFace.PZ,
                CubeFace.NZ
            ]){
                camera.lookAtCubeFace(face);
                this._scatterSkyboxFramebuffer.setColorAttachmentCubeFace(0, face);
                this._renderSky(camera, false, sunDir, true, false);
            }
            device.popDeviceStates();
            device.setRenderStates(saveRenderStates);
            bakedSkyboxTexture = this._scatterSkyboxFramebuffer.getColorAttachments()[0];
        }
        prefilterCubemap(bakedSkyboxTexture, 'ggx', this.radianceMap);
        prefilterCubemap(bakedSkyboxTexture, 'lambertian', this.irradianceMap);
    }
    /** @internal */ renderFog(ctx) {
        const camera = ctx.camera;
        const sceneDepthTexture = ctx.linearDepthTexture;
        const device = Application.instance.device;
        const savedRenderStates = device.getRenderStates();
        this._prepareSkyBox(device);
        const sunLight = ctx.sunLight;
        if (this._fogType === 'scatter' && !sunLight) {
            console.error('Cannot render scattering fog without sun light');
            return;
        }
        const fogProgram = this._fogType === 'scatter' ? this._programFogScatter : this._programFog;
        const renderStates = this._fogType === 'scatter' ? this._renderStatesFogScatter : this._renderStatesFog;
        if (fogProgram && sceneDepthTexture) {
            const bindgroup = this._fogType === 'scatter' ? this._bindgroupFogScatter : this._bindgroupFog;
            bindgroup.setTexture('depthTex', sceneDepthTexture, this._nearestSampler);
            bindgroup.setValue('rt', device.getFramebuffer() ? 1 : 0);
            bindgroup.setValue('invProjViewMatrix', camera.invViewProjectionMatrix);
            bindgroup.setValue('cameraNearFar', new Vector2(camera.getNearPlane(), camera.getFarPlane()));
            bindgroup.setValue('cameraPosition', camera.getWorldPosition());
            bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
            if (this._fogType === 'scatter') {
                const sunDir = sunLight ? sunLight.directionAndCutoff.xyz().scaleBy(-1) : ShaderHelper.defaultSunDir;
                const alpha = Math.PI / 2 - Math.acos(Math.max(-1, Math.min(1, sunDir.y)));
                const scale = this._aerialPerspectiveDensity * this._aerialPerspectiveDensity;
                const farPlane = ctx.camera.getFarPlane() * scale;
                bindgroup.setTexture('apLut', ScatteringLut.getAerialPerspectiveLut(alpha, farPlane));
                bindgroup.setValue('sliceDist', farPlane / ScatteringLut.aerialPerspectiveSliceZ);
                bindgroup.setValue('sunDir', sunDir);
                bindgroup.setValue('worldScale', scale);
            } else {
                bindgroup.setValue('fogType', this.mappedFogType);
                bindgroup.setValue('fogColor', this._fogColor);
                bindgroup.setValue('fogParams', this._fogParams);
            }
            device.setProgram(fogProgram);
            device.setBindGroup(0, bindgroup);
            device.setVertexLayout(this._vertexLayout);
            device.setRenderStates(renderStates);
            device.draw('triangle-strip', 0, 4);
            device.setRenderStates(savedRenderStates);
        }
    }
    /** @internal */ renderSky(ctx) {
        const sunDir = SkyRenderer._getSunDir(ctx.sunLight);
        if (!sunDir.equalsTo(this._lastSunDir)) {
            this._radianceMapDirty = true;
        }
        this._renderSky(ctx.camera, true, sunDir, this._drawGround, this._skyType === 'scatter' && this._cloudy > 0);
        if (this._radianceMapDirty && ctx.env.light.type === 'ibl') {
            if (ctx.env.light.radianceMap && (ctx.env.light.radianceMap === this._radianceMap || ctx.env.light.irradianceMap === this._irradianceMap)) {
                this._radianceMapDirty = false;
                this._lastSunDir.set(sunDir);
                this.updateIBLMaps(sunDir);
            }
        }
    }
    /** @internal */ _renderSky(camera, depthTest, sunDir, drawGround, drawCloud) {
        const device = Application.instance.device;
        const savedRenderStates = device.getRenderStates();
        this._prepareSkyBox(device);
        if (this._skyType === 'scatter') {
            this._drawScattering(camera, sunDir, depthTest, drawGround, drawCloud);
        } else if (this._skyType === 'skybox' && this._skyboxTexture) {
            this._drawSkybox(camera, depthTest);
        } else {
            this._drawSkyColor(camera, depthTest);
        }
        device.setRenderStates(savedRenderStates);
    }
    /** @internal */ _drawSkyColor(camera, depthTest) {
        const device = Application.instance.device;
        const bindgroup = this._bindgroupSky.color;
        bindgroup.setValue('viewProjMatrix', camera.viewProjectionMatrix);
        bindgroup.setValue('worldMatrix', this._skyWorldMatrix);
        bindgroup.setValue('cameraPos', camera.getWorldPosition());
        bindgroup.setValue('color', this._skyColor);
        bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
        device.setProgram(this._programSky.color);
        device.setBindGroup(0, bindgroup);
        device.setRenderStates(depthTest ? this._renderStatesSky : this._renderStatesSkyNoDepthTest);
        this._primitiveSky.draw();
    }
    /** @internal */ _drawSkybox(camera, depthTest) {
        const device = Application.instance.device;
        const bindgroup = this._bindgroupSky.skybox;
        bindgroup.setTexture('skyCubeMap', this._skyboxTexture);
        bindgroup.setValue('flip', device.getFramebuffer() && device.type === 'webgpu' ? new Vector4(1, -1, 1, 1) : new Vector4(1, 1, 1, 1));
        bindgroup.setValue('viewProjMatrix', camera.viewProjectionMatrix);
        bindgroup.setValue('worldMatrix', this._skyWorldMatrix);
        bindgroup.setValue('cameraPos', camera.getWorldPosition());
        bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
        device.setProgram(this._programSky.skybox);
        device.setBindGroup(0, bindgroup);
        device.setRenderStates(depthTest ? this._renderStatesSky : this._renderStatesSkyNoDepthTest);
        this._primitiveSky.draw();
    }
    /** @internal */ _drawScattering(camera, sunDir, depthTest, drawGround, drawCloud) {
        const device = Application.instance.device;
        const alpha = Math.PI / 2 - Math.acos(Math.max(-1, Math.min(1, sunDir.y)));
        const tLut = ScatteringLut.getTransmittanceLut();
        const skyLut = ScatteringLut.getSkyViewLut(alpha);
        //const apLut = ScatteringLut.getAerialPerspectiveLut(alpha, 8000);
        const program = drawCloud ? this._programSky.scatter : this._programSky['scatter-nocloud'];
        const bindgroup = drawCloud ? this._bindgroupSky.scatter : this._bindgroupSky['scatter-nocloud'];
        bindgroup.setValue('sunDir', sunDir);
        bindgroup.setValue('flip', device.getFramebuffer() && device.type === 'webgpu' ? new Vector4(1, -1, 1, 1) : new Vector4(1, 1, 1, 1));
        bindgroup.setValue('viewProjMatrix', camera.viewProjectionMatrix);
        bindgroup.setValue('worldMatrix', this._skyWorldMatrix);
        bindgroup.setValue('cameraPos', camera.getWorldPosition());
        bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
        bindgroup.setTexture('tLut', tLut);
        bindgroup.setTexture('skyLut', skyLut);
        if (drawCloud) {
            bindgroup.setValue('cloudy', this._cloudy);
            bindgroup.setValue('cloudIntensity', this._cloudIntensity);
            bindgroup.setValue('time', device.frameInfo.elapsedOverall * 0.001);
            bindgroup.setValue('velocity', this._wind);
        }
        bindgroup.setValue('drawGround', drawGround ? 1 : 0);
        device.setProgram(program);
        device.setBindGroup(0, bindgroup);
        device.setRenderStates(depthTest ? this._renderStatesSky : this._renderStatesSkyNoDepthTest);
        this._primitiveSky.draw();
    }
    /** @internal */ _prepareSkyBox(device) {
        if (!this._programFogScatter) {
            this._programFogScatter = device.buildRenderProgram({
                label: 'FogScatter',
                vertex (pb) {
                    this.rt = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 1, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        if (device.type === 'webgpu') {
                            this.$if(pb.notEqual(this.rt, 0), function() {
                                this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                            });
                        }
                    });
                },
                fragment (pb) {
                    this.depthTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                    this.invProjViewMatrix = pb.mat4().uniform(0);
                    this.cameraNearFar = pb.vec2().uniform(0);
                    this.cameraPosition = pb.vec3().uniform(0);
                    this.apLut = pb.tex2D().uniform(0);
                    this.worldScale = pb.float().uniform(0);
                    this.sliceDist = pb.float().uniform(0);
                    this.sunDir = pb.vec3().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.depthValue = pb.textureSample(this.depthTex, this.$inputs.uv);
                        if (device.type === 'webgl') {
                            this.$l.linearDepth = decodeNormalizedFloatFromRGBA(this, this.depthValue);
                        } else {
                            this.$l.linearDepth = this.depthValue.r;
                        }
                        this.$l.nonLinearDepth = pb.div(pb.sub(pb.div(this.cameraNearFar.x, this.linearDepth), this.cameraNearFar.y), pb.sub(this.cameraNearFar.x, this.cameraNearFar.y));
                        //this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), this.nonLinearDepth, 1);
                        this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), pb.sub(pb.mul(this.nonLinearDepth, 2), 1), 1);
                        this.$l.hPos = pb.mul(this.invProjViewMatrix, this.clipSpacePos);
                        this.$l.hPos = pb.div(this.$l.hPos, this.$l.hPos.w);
                        this.$l.viewDir = pb.sub(this.hPos.xyz, this.cameraPosition);
                        // Assume object is above the sea level
                        this.viewDir.y = pb.max(0, this.viewDir.y);
                        this.$l.distance = pb.mul(pb.length(this.viewDir), this.worldScale);
                        this.$l.slice0 = pb.floor(pb.div(this.distance, this.sliceDist));
                        this.$l.slice1 = pb.add(this.slice0, 1);
                        this.$l.factor = pb.sub(pb.div(this.distance, this.sliceDist), this.slice0);
                        this.$l.viewNormal = pb.normalize(this.viewDir);
                        this.$l.horizonAngle = pb.acos(pb.clamp(pb.dot(pb.normalize(this.sunDir.xz), pb.normalize(this.viewNormal.xz)), 0, 1));
                        this.$l.zenithAngle = pb.asin(this.viewNormal.y);
                        this.$l.sliceU = pb.max(pb.div(this.horizonAngle, Math.PI * 2), 0.5 / ScatteringLut.aerialPerspectiveSliceZ);
                        this.$l.u0 = pb.div(pb.add(this.slice0, this.sliceU), ScatteringLut.aerialPerspectiveSliceZ);
                        this.$l.u1 = pb.add(this.u0, 1 / ScatteringLut.aerialPerspectiveSliceZ);
                        this.$l.v = pb.div(this.zenithAngle, Math.PI / 2);
                        this.$l.t0 = pb.textureSampleLevel(this.apLut, pb.vec2(this.u0, this.v), 0);
                        this.$l.t1 = pb.textureSampleLevel(this.apLut, pb.vec2(this.u1, this.v), 0);
                        this.$l.t = pb.mix(this.t0, this.t1, this.factor);
                        this.$outputs.outColor = pb.vec4(this.t.rgb, pb.sub(1, this.t.a));
                    });
                }
            });
            this._bindgroupFogScatter = device.createBindGroup(this._programFogScatter.bindGroupLayouts[0]);
        }
        if (!this._programFog) {
            this._programFog = device.buildRenderProgram({
                label: 'Fog',
                vertex (pb) {
                    this.rt = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 1, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        if (device.type === 'webgpu') {
                            this.$if(pb.notEqual(this.rt, 0), function() {
                                this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                            });
                        }
                    });
                },
                fragment (pb) {
                    this.depthTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                    this.invProjViewMatrix = pb.mat4().uniform(0);
                    this.cameraNearFar = pb.vec2().uniform(0);
                    this.cameraPosition = pb.vec3().uniform(0);
                    this.fogType = pb.int().uniform(0);
                    this.fogColor = pb.vec4().uniform(0);
                    this.fogParams = pb.vec4().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.depthValue = pb.textureSample(this.depthTex, this.$inputs.uv);
                        if (device.type === 'webgl') {
                            this.$l.linearDepth = decodeNormalizedFloatFromRGBA(this, this.depthValue);
                        } else {
                            this.$l.linearDepth = this.depthValue.r;
                        }
                        this.$l.nonLinearDepth = pb.div(pb.sub(pb.div(this.cameraNearFar.x, this.linearDepth), this.cameraNearFar.y), pb.sub(this.cameraNearFar.x, this.cameraNearFar.y));
                        //this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), this.nonLinearDepth, 1);
                        this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), pb.sub(pb.mul(this.nonLinearDepth, 2), 1), 1);
                        this.$l.hPos = pb.mul(this.invProjViewMatrix, this.clipSpacePos);
                        this.$l.hPos = pb.div(this.$l.hPos, this.$l.hPos.w);
                        this.$l.viewDir = pb.sub(this.hPos.xyz, this.cameraPosition);
                        this.$l.fogFactor = ShaderHelper.computeFogFactor(this, this.viewDir, this.fogType, this.fogParams);
                        this.$l.color = pb.mul(this.fogColor.rgb, this.fogFactor);
                        this.$if(pb.equal(this.srgbOut, 0), function() {
                            this.$outputs.outColor = pb.vec4(this.color, this.fogFactor);
                        }).$else(function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color), this.fogFactor);
                        });
                    });
                }
            });
            this._bindgroupFog = device.createBindGroup(this._programFog.bindGroupLayouts[0]);
        }
        if (!this._programSky.color) {
            this._programSky.color = device.buildRenderProgram({
                label: 'SolidColorSky',
                vertex (pb) {
                    this.$inputs.pos = pb.vec3().attrib('position');
                    this.worldMatrix = pb.mat4().uniform(0);
                    this.viewProjMatrix = pb.mat4().uniform(0);
                    this.cameraPos = pb.vec3().uniform(0);
                    pb.main(function() {
                        this.$l.worldDirection = pb.mul(this.worldMatrix, pb.vec4(this.$inputs.pos, 0)).xyz;
                        this.$builtins.position = pb.mul(this.viewProjMatrix, pb.vec4(pb.add(this.worldDirection, this.cameraPos), 1));
                        this.$builtins.position.z = this.$builtins.position.w;
                    });
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.color = pb.vec4().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    pb.main(function() {
                        this.$if(pb.equal(this.srgbOut, 0), function() {
                            this.$outputs.outColor = pb.vec4(this.color.rgb, 1);
                        }).$else(function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color.rgb), 1);
                        });
                    });
                }
            });
            this._bindgroupSky.color = device.createBindGroup(this._programSky.color.bindGroupLayouts[0]);
        }
        if (!this._programSky.scatter) {
            this._programSky.scatter = SkyRenderer._createScatterProgram(device, true);
            this._bindgroupSky.scatter = device.createBindGroup(this._programSky.scatter.bindGroupLayouts[0]);
        }
        if (!this._programSky['scatter-nocloud']) {
            this._programSky['scatter-nocloud'] = SkyRenderer._createScatterProgram(device, false);
            this._bindgroupSky['scatter-nocloud'] = device.createBindGroup(this._programSky['scatter-nocloud'].bindGroupLayouts[0]);
        }
        if (!this._programSky.skybox) {
            this._programSky.skybox = device.buildRenderProgram({
                label: 'SkyBoxSky',
                vertex (pb) {
                    this.$inputs.pos = pb.vec3().attrib('position');
                    this.$outputs.texCoord = pb.vec3();
                    this.worldMatrix = pb.mat4().uniform(0);
                    this.viewProjMatrix = pb.mat4().uniform(0);
                    this.cameraPos = pb.vec3().uniform(0);
                    this.flip = pb.vec4().uniform(0);
                    pb.main(function() {
                        this.$outputs.texCoord = this.$inputs.pos;
                        this.$l.worldPos = pb.add(this.cameraPos, pb.mul(this.worldMatrix, pb.vec4(this.$inputs.pos, 0)).xyz);
                        this.$builtins.position = pb.mul(this.viewProjMatrix, pb.vec4(this.worldPos, 1), this.flip);
                        this.$builtins.position.z = this.$builtins.position.w;
                    });
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.skyCubeMap = pb.texCube().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    pb.main(function() {
                        this.$l.texCoord = pb.normalize(this.$inputs.texCoord);
                        this.$l.color = pb.textureSampleLevel(this.skyCubeMap, this.texCoord, 0).rgb;
                        this.$if(pb.equal(this.srgbOut, 0), function() {
                            this.$outputs.outColor = pb.vec4(this.color, 1);
                        }).$else(function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color), 1);
                        });
                    });
                }
            });
            this._bindgroupSky.skybox = device.createBindGroup(this._programSky.skybox.bindGroupLayouts[0]);
        }
        if (!this._renderStatesSky) {
            this._renderStatesSky = device.createRenderStateSet();
            this._renderStatesSky.useDepthState().enableTest(true).enableWrite(false).setCompareFunc('le');
            this._renderStatesSky.useRasterizerState().setCullMode('none');
        }
        if (!this._renderStatesSkyNoDepthTest) {
            this._renderStatesSkyNoDepthTest = device.createRenderStateSet();
            this._renderStatesSkyNoDepthTest.useDepthState().enableTest(false).enableWrite(false);
            this._renderStatesSkyNoDepthTest.useRasterizerState().setCullMode('none');
        }
        if (!this._renderStatesFog) {
            this._renderStatesFog = device.createRenderStateSet();
            this._renderStatesFog.useRasterizerState().setCullMode('none');
            this._renderStatesFog.useBlendingState().enable(true).setBlendFunc('one', 'inv-src-alpha');
            this._renderStatesFog.useDepthState().enableTest(false).enableWrite(false);
        }
        if (!this._renderStatesFogScatter) {
            this._renderStatesFogScatter = device.createRenderStateSet();
            this._renderStatesFogScatter.useRasterizerState().setCullMode('none');
            this._renderStatesFogScatter.useBlendingState().enable(true).setBlendFunc('one', 'inv-src-alpha');
            this._renderStatesFogScatter.useDepthState().enableTest(true).enableWrite(false).setCompareFunc('gt');
        }
        if (!this._nearestSampler) {
            this._nearestSampler = device.createSampler({
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
        }
        if (!this._vertexLayout) {
            this._vertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                            -1,
                            -1,
                            1,
                            -1,
                            -1,
                            1,
                            1,
                            1
                        ]))
                    }
                ]
            });
        }
        if (!this._primitiveSky) {
            this._primitiveSky = new BoxShape({
                size: 8,
                anchorX: 0.5,
                anchorY: 0.5,
                anchorZ: 0.5
            });
        }
    }
    /** @internal */ static _getSunDir(sunLight) {
        // TODO: reduce GC
        return sunLight?.directionAndCutoff.xyz().scaleBy(-1) ?? ShaderHelper.defaultSunDir;
    }
    static _createScatterProgram(device, cloud) {
        return device.buildRenderProgram({
            vertex (pb) {
                this.$inputs.pos = pb.vec3().attrib('position');
                this.worldMatrix = pb.mat4().uniform(0);
                this.viewProjMatrix = pb.mat4().uniform(0);
                this.cameraPos = pb.vec3().uniform(0);
                this.flip = pb.vec4().uniform(0);
                pb.main(function() {
                    this.$outputs.worldDirection = pb.mul(this.worldMatrix, pb.vec4(this.$inputs.pos, 0)).xyz;
                    this.$builtins.position = pb.mul(this.viewProjMatrix, pb.vec4(pb.add(this.$outputs.worldDirection, this.cameraPos), 1), this.flip);
                    this.$builtins.position.z = this.$builtins.position.w;
                });
            },
            fragment (pb) {
                this.$outputs.outColor = pb.vec4();
                this.tLut = pb.tex2D().uniform(0);
                this.skyLut = pb.tex2D().uniform(0);
                this.sunDir = pb.vec3().uniform(0);
                if (cloud) {
                    this.cloudy = pb.float().uniform(0);
                    this.cloudIntensity = pb.float().uniform(0);
                    this.time = pb.float().uniform(0);
                    this.velocity = pb.vec2().uniform(0);
                }
                this.drawGround = pb.int().uniform(0);
                this.srgbOut = pb.int().uniform(0);
                this.viewPos = pb.vec3(ScatteringLut.viewPosition.x, ScatteringLut.viewPosition.y, ScatteringLut.viewPosition.z);
                pb.func('getMiePhase', [
                    pb.float('cosTheta')
                ], function() {
                    this.$l.g = pb.float(0.8);
                    this.$l.scale = pb.float(3 / (Math.PI * 8));
                    this.$l.gg = pb.mul(this.g, this.g);
                    this.$l.num = pb.mul(pb.sub(1, this.gg), pb.add(pb.mul(this.cosTheta, this.cosTheta), 1));
                    this.$l.denom = pb.mul(pb.add(2, this.gg), pb.pow(pb.sub(pb.add(1, this.gg), pb.mul(this.g, this.cosTheta, 2)), 1.5));
                    this.$return(pb.div(pb.mul(this.scale, this.num), this.denom));
                });
                pb.func('noise', [
                    pb.vec3('p'),
                    pb.float('t')
                ], function() {
                    this.p2 = pb.mul(this.p, 0.25);
                    this.f = pb.mul(smoothNoise3D(this, this.p2), 0.5);
                    this.p2 = pb.mul(this.p2, 3.02);
                    this.p2.y = pb.sub(this.p2.y, pb.mul(this.t, 0.02));
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.25));
                    this.p2 = pb.mul(this.p2, 3.03);
                    this.p2.y = pb.add(this.p2.y, pb.mul(this.t, 0.01));
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.125));
                    this.p2 = pb.mul(this.p2, 3.02);
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.0625));
                    this.p2 = pb.mul(this.p2, 3.01);
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.03125));
                    this.p2 = pb.mul(this.p2, 3.01);
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.015625));
                    this.$return(this.f);
                });
                pb.func('getValFromSkyLUT', [
                    pb.vec3('rayDir'),
                    pb.vec3('sunDir')
                ], function() {
                    this.$l.height = pb.length(this.viewPos);
                    this.$l.up = pb.div(this.viewPos, this.height);
                    this.$l.c = pb.div(pb.sqrt(pb.sub(pb.mul(this.height, this.height), pb.mul(ScatteringLut.groundRadius, ScatteringLut.groundRadius))), this.height);
                    this.$l.horizonAngle = pb.acos(pb.clamp(this.c, -1, 1));
                    this.$l.altitudeAngle = pb.sub(this.horizonAngle, pb.acos(pb.dot(this.rayDir, this.up)));
                    this.$l.azimuthAngle = pb.float();
                    this.$if(pb.greaterThan(pb.abs(this.altitudeAngle), Math.PI * 0.5 - 0.0001), function() {
                        this.azimuthAngle = 0;
                    }).$else(function() {
                        this.$l.right = pb.cross(this.sunDir, this.up);
                        this.$l.forward = pb.cross(this.up, this.right);
                        this.$l.projectedDir = pb.normalize(pb.sub(this.rayDir, pb.mul(this.up, pb.dot(this.rayDir, this.up))));
                        this.$l.sinTheta = pb.dot(this.projectedDir, this.right);
                        this.$l.cosTheta = pb.dot(this.projectedDir, this.forward);
                        this.azimuthAngle = pb.add(pb.atan2(this.sinTheta, this.cosTheta), Math.PI);
                    });
                    this.$l.v = pb.add(0.5, pb.mul(0.5, pb.sign(this.altitudeAngle), pb.sqrt(pb.mul(pb.abs(this.altitudeAngle), 2 / Math.PI))));
                    this.$l.uv = pb.vec2(pb.div(this.azimuthAngle, Math.PI * 2), this.v);
                    this.$return(pb.textureSampleLevel(this.skyLut, this.uv, 0).rgb);
                });
                pb.func('sunWithBloom', [
                    pb.vec3('rayDir'),
                    pb.vec3('sunDir')
                ], function() {
                    this.$l.sunSolidAngle = 0.53 * Math.PI / 180;
                    this.$l.minSunCosTheta = pb.cos(this.sunSolidAngle);
                    this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                    this.$if(pb.greaterThanEqual(this.cosTheta, this.minSunCosTheta), function() {
                        this.$return(pb.vec3(1));
                    });
                    this.$l.offset = pb.sub(this.minSunCosTheta, this.cosTheta);
                    this.$l.gaussianBloom = pb.mul(pb.exp(pb.mul(this.offset, -50000)), 0.5);
                    this.$l.invBloom = pb.mul(pb.div(1, pb.add(0.02, pb.mul(this.offset, 300))), 0.01);
                    this.$return(pb.vec3(pb.add(this.gaussianBloom, this.invBloom)));
                });
                pb.func('rayIntersectSphere', [
                    pb.vec3('ro'),
                    pb.vec3('rd'),
                    pb.float('rad')
                ], function() {
                    this.$l.b = pb.dot(this.ro, this.rd);
                    this.$l.c = pb.sub(pb.dot(this.ro, this.ro), pb.mul(this.rad, this.rad));
                    this.$if(pb.and(pb.greaterThan(this.c, 0), pb.greaterThan(this.b, 0)), function() {
                        this.$return(pb.float(-1));
                    });
                    this.$l.bb = pb.mul(this.b, this.b);
                    this.$l.discr = pb.sub(this.bb, this.c);
                    this.$if(pb.lessThan(this.discr, 0), function() {
                        this.$return(pb.float(-1));
                    });
                    this.$if(pb.greaterThan(this.discr, this.bb), function() {
                        this.$return(pb.sub(pb.sqrt(this.discr), this.b));
                    });
                    this.$return(pb.sub(pb.neg(pb.sqrt(this.discr)), this.b));
                });
                pb.func('getValFromTLUT', [
                    pb.vec3('pos'),
                    pb.vec3('sunDir')
                ], function() {
                    this.$l.height = pb.length(this.pos);
                    this.$l.up = pb.div(this.pos, this.height);
                    this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                    this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, ScatteringLut.groundRadius), pb.sub(ScatteringLut.atmosphereRadius, ScatteringLut.groundRadius)))));
                    this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                });
                pb.main(function() {
                    this.$l.rayDir = pb.normalize(this.$inputs.worldDirection);
                    // ad-hoc
                    this.$l.sunIntensity = pb.sqrt(pb.max(0, pb.mul(this.sunDir.y, this.rayDir.y)));
                    // compute cloud
                    if (cloud) {
                        this.$l.noiseValue = pb.float();
                        this.$if(pb.lessThanEqual(this.rayDir.y, 0), function() {
                            this.noiseValue = 0;
                        }).$else(function() {
                            this.$l.tMin = pb.div(3000, this.rayDir.y);
                            this.$l.cloudPoint = pb.mul(this.rayDir, this.tMin);
                            this.speed = pb.mul(pb.vec3(this.velocity.x, 0, this.velocity.y), this.time);
                            this.$l.noiseScale = pb.float(4e-4);
                            this.noiseValue = this.noise(pb.mul(pb.add(this.cloudPoint, this.speed), this.noiseScale), this.time);
                            this.noiseValue = pb.add(this.noiseValue, this.cloudy);
                            this.noiseValue = pb.smoothStep(1, pb.add(1, this.cloudy), this.noiseValue);
                        });
                        // use sun color as cloud color
                        this.$l.sunColor = pb.mul(this.getValFromSkyLUT(this.sunDir, this.sunDir), this.sunIntensity);
                        this.$l.cloudColor = pb.mul(this.sunColor.rgb, pb.mul(this.noiseValue, this.cloudIntensity));
                    }
                    // Compute sky color
                    this.$l.skyRayDir = this.$choice(pb.equal(this.drawGround, 0), pb.normalize(pb.vec3(this.rayDir.x, pb.max(0, this.rayDir.y), this.rayDir.z)), this.rayDir);
                    this.$l.lum = this.getValFromSkyLUT(this.skyRayDir, this.sunDir);
                    this.$l.sunLum = this.sunWithBloom(this.rayDir, this.sunDir);
                    this.sunLum = pb.smoothStep(pb.vec3(0.002), pb.vec3(1), this.sunLum);
                    this.$if(pb.greaterThan(pb.length(this.sunLum), 0), function() {
                        this.$if(pb.greaterThanEqual(this.rayIntersectSphere(this.viewPos, this.rayDir, ScatteringLut.groundRadius), 0), function() {
                            this.sunLum = pb.vec3(0);
                        }).$else(function() {
                            this.sunLum = pb.mul(this.sunLum, this.getValFromTLUT(this.viewPos, this.sunDir));
                        });
                    });
                    if (cloud) {
                        this.lum = pb.add(this.lum, this.sunLum);
                        // blend
                        this.$l.vfactor = pb.clamp(pb.div(pb.sub(this.rayDir.y, 0.01), pb.sub(0.03, 0.01)), 0, 1);
                        this.$l.factor = pb.clamp(pb.mul(this.noiseValue, this.vfactor), 0, 1);
                        this.$l.color = pb.mix(this.lum, this.cloudColor, this.factor);
                    } else {
                        this.$l.color = this.lum;
                    }
                    this.color = pb.mul(this.color, 8);
                    this.color = pb.pow(this.color, pb.vec3(1.3));
                    this.color = pb.div(this.color, pb.add(pb.mul(pb.smoothStep(0, 0.2, pb.clamp(this.sunDir.y, 0, 1)), 2), 0.15));
                    this.$if(pb.equal(this.srgbOut, 0), function() {
                        this.$outputs.outColor = pb.vec4(this.color, 1);
                    }).$else(function() {
                        this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color), 1);
                    });
                });
            }
        });
    }
}

/**
 * Temporal framebuffer cache
 *
 * @internal
 */ class TemporalCache {
    static _ownDepthTextures = new Set();
    static _variantWidth = 0;
    static _variantHeight = 0;
    static _releaseFuncs = new Map();
    static _cachedFrameBuffers = {};
    static getFramebufferFixedSize(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, sampleCount = 1) {
        return this.getFramebuffer(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, false, sampleCount);
    }
    static getFramebufferVariantSize(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, sampleCount = 1) {
        return this.getFramebuffer(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, true, sampleCount);
    }
    static getFramebufferFixedSizeWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, sampleCount = 1) {
        return this.getFramebufferWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, false, sampleCount);
    }
    static getFramebufferVariantSizeWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, sampleCount = 1) {
        return this.getFramebufferWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, true, sampleCount);
    }
    static getFramebuffer(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, variant, sampleCount) {
        if (variant && (width !== this._variantWidth || height !== this._variantHeight)) {
            this.purgeVariantFramebuffers();
            this._variantWidth = width;
            this._variantHeight = height;
        }
        if (colorType !== '2darray' && depthType !== '2darray') {
            numLayers = 1;
        }
        const device = Application.instance.device;
        if (device.type === 'webgl') {
            sampleCount = 1;
        }
        const sizeHash = variant ? '' : `${width}x${height}`;
        const fmtHash = `${colorFmt ?? ''}:${depthFmt ?? ''}:${colorFmt ? colorType : ''}:${numLayers}:${depthFmt ? depthType : ''}:${colorFmt && mipmapping ? 1 : 0}:${sampleCount}`;
        const sizedFrameBuffers = this._cachedFrameBuffers[sizeHash];
        const fbList = sizedFrameBuffers?.get(null)?.[fmtHash];
        let fb = null;
        if (!fbList || fbList.length === 0) {
            let colorTex = null;
            const opt = mipmapping ? {} : {
                samplerOptions: {
                    mipFilter: 'none'
                }
            };
            if (colorFmt) {
                switch(colorType){
                    case '2d':
                        colorTex = device.createTexture2D(colorFmt, width, height, opt);
                        break;
                    case '2darray':
                        colorTex = device.createTexture2DArray(colorFmt, width, height, numLayers, opt);
                        break;
                    case 'cube':
                        colorTex = device.createCubeTexture(colorFmt, width, opt);
                        break;
                }
            }
            let depthTex = null;
            if (depthFmt) {
                switch(depthType){
                    case '2d':
                        depthTex = device.createTexture2D(depthFmt, width, height);
                        break;
                    case '2darray':
                        depthTex = device.createTexture2DArray(depthFmt, width, height, numLayers);
                        break;
                    case 'cube':
                        depthTex = device.createCubeTexture(depthFmt, width);
                        break;
                }
            }
            fb = device.createFrameBuffer(colorTex ? [
                colorTex
            ] : [], depthTex, {
                sampleCount,
                ignoreDepthStencil: false
            });
            this._ownDepthTextures.add(depthTex);
        } else {
            fb = fbList.pop();
        }
        this._releaseFuncs.set(fb, variant ? this.releaseWithoutDepthTexVariantSize : this.releaseWithoutDepthTexFixedSize);
        return fb;
    }
    static getFramebufferWithDepth(depth, numLayers, colorFmt, colorType, mipmapping, variant, sampleCount) {
        if (variant && (depth.width !== this._variantWidth || depth.height !== this._variantHeight)) {
            this.purgeVariantFramebuffers();
            this._variantWidth = depth.width;
            this._variantHeight = depth.height;
        }
        if (!colorFmt || colorType !== '2darray') {
            numLayers = 1;
        }
        const device = Application.instance.device;
        if (device.type === 'webgl') {
            sampleCount = 1;
        }
        const sizeHash = variant ? '' : `${depth.width}x${depth.height}`;
        const fmtHash = `${colorFmt ?? ''}:${depth.format}:${colorFmt ? colorType : ''}:${numLayers}:${depth.target}:${colorFmt && mipmapping ? 1 : 0}:${sampleCount}`;
        const sizedFrameBuffers = this._cachedFrameBuffers[sizeHash];
        const fbList = sizedFrameBuffers?.get(depth)?.[fmtHash];
        let fb = null;
        if (!fbList || fbList.length === 0) {
            let colorTex = null;
            const opt = mipmapping ? {} : {
                samplerOptions: {
                    mipFilter: 'none'
                }
            };
            if (colorFmt) {
                switch(colorType){
                    case '2d':
                        colorTex = device.createTexture2D(colorFmt, depth.width, depth.height, opt);
                        break;
                    case '2darray':
                        colorTex = device.createTexture2DArray(colorFmt, depth.width, depth.height, numLayers, opt);
                        break;
                    case 'cube':
                        colorTex = device.createCubeTexture(colorFmt, depth.width, opt);
                        break;
                }
            }
            fb = device.createFrameBuffer([
                colorTex
            ], depth, {
                sampleCount,
                ignoreDepthStencil: false
            });
            depth.on('disposed', ()=>{
                const sizedFrameBuffers = this._cachedFrameBuffers[sizeHash];
                const entry = sizedFrameBuffers?.get(depth);
                if (entry) {
                    for(const k in entry){
                        const index = entry[k].indexOf(fb);
                        if (index >= 0) {
                            entry[k].splice(index, 1);
                            if (entry[k].length === 0) {
                                delete entry[k];
                            }
                        }
                    }
                    if (Object.getOwnPropertyNames(entry).length === 0) {
                        sizedFrameBuffers.delete(depth);
                    }
                }
                fb.getColorAttachments()[0]?.dispose();
                fb.dispose();
            });
        } else {
            fb = fbList.pop();
        }
        this._releaseFuncs.set(fb, variant ? this.releaseWithDepthTexVariantSize : this.releaseWithDepthTexFixedSize);
        return fb;
    }
    static releaseFramebuffer(fb) {
        const releaseFunc = this._releaseFuncs.get(fb);
        if (releaseFunc) {
            releaseFunc.call(this, fb);
            this._releaseFuncs.delete(fb);
        }
    }
    static releaseWithDepthTexFixedSize(fb) {
        this.releaseFrameBufferInternal(fb, fb.getDepthAttachment(), true);
    }
    static releaseWithDepthTexVariantSize(fb) {
        this.releaseFrameBufferInternal(fb, fb.getDepthAttachment(), false);
    }
    static releaseWithoutDepthTexFixedSize(fb) {
        this.releaseFrameBufferInternal(fb, null, true);
    }
    static releaseWithoutDepthTexVariantSize(fb) {
        this.releaseFrameBufferInternal(fb, null, false);
    }
    static releaseFrameBufferInternal(fb, withDepthTex, withSize) {
        const tex = fb.getDepthAttachment() ?? fb.getColorAttachments()[0];
        const sizeHash = withSize ? `${tex.width}x${tex.height}` : '';
        let variantSizeFrameBuffers = this._cachedFrameBuffers[sizeHash];
        if (!variantSizeFrameBuffers) {
            variantSizeFrameBuffers = new Map();
            this._cachedFrameBuffers[sizeHash] = variantSizeFrameBuffers;
        }
        const colorTex = fb.getColorAttachments()[0];
        const depthTex = fb.getDepthAttachment();
        const numLayers = colorTex?.isTexture2DArray() ? colorTex.depth : depthTex?.isTexture2DArray() ? depthTex.depth : 1;
        const hash = `${colorTex?.format ?? ''}:${depthTex?.format ?? ''}:${colorTex ? colorTex.target : ''}:${numLayers}:${depthTex ? depthTex.target : ''}:${colorTex?.mipLevelCount > 1 ? 1 : 0}:${fb.getSampleCount()}`;
        let entry = variantSizeFrameBuffers.get(withDepthTex);
        if (!entry) {
            entry = {};
            variantSizeFrameBuffers.set(withDepthTex, entry);
        }
        let fblist = entry[hash];
        if (!fblist) {
            fblist = [];
            entry[hash] = fblist;
        }
        fblist.push(fb);
    }
    static purgeVariantFramebuffers() {
        const variantSizeFrameBuffers = this._cachedFrameBuffers[''];
        variantSizeFrameBuffers?.forEach((val, key)=>{
            for(const k in val){
                val[k].forEach((fb)=>{
                    fb.getColorAttachments()[0].dispose();
                    fb.dispose();
                });
            }
            if (this._ownDepthTextures.has(key)) {
                this._ownDepthTextures.delete(key);
                key?.dispose();
            }
        });
        variantSizeFrameBuffers?.clear();
    }
}

/** @internal */ class ShadowImpl {
    _resourceDirty;
    constructor(){
        this._resourceDirty = true;
    }
    invalidateResource() {
        this._resourceDirty = true;
    }
    updateResources(shadowMapParams) {
        this.doUpdateResources(shadowMapParams);
    }
}

/*
  const PCF_KERNEL_3x3 = [
    [0.5, 1.0, 0.5],
    [1.0, 1.0, 1.0],
    [0.5, 1.0, 0.5]
  ];
  const PCF_KERNEL_SUM_3x3 = 7;

  const PCF_KERNEL_5x5 = [
    [0.0, 0.5, 1.0, 0.5, 0.0],
    [0.5, 1.0, 1.0, 1.0, 0.5],
    [1.0, 1.0, 1.0, 1.0, 1.0],
    [0.5, 1.0, 1.0, 1.0, 0.5],
    [0.0, 0.5, 1.0, 0.5, 0.0]
  ];
  const PCF_KERNEL_SUM_5x5 = 17;

  const PCF_KERNEL_7x7 = [
    [0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0]
  ];
  const PCF_KERNEL_SUM_7x7 = 33;

  const PCF_KERNEL_9x9 = [
    [0.0, 0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0, 0.0],
    [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0],
    [0.0, 0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0, 0.0]
  ];
  const PCF_KERNEL_SUM_9x9 = 53;
  */ const PCF_POISSON_DISC = [
    [
        0.511749,
        0.547686
    ],
    [
        0.58929,
        0.257224
    ],
    [
        0.165018,
        0.57663
    ],
    [
        0.407692,
        0.742285
    ],
    [
        0.707012,
        0.646523
    ],
    [
        0.31463,
        0.466825
    ],
    [
        0.801257,
        0.485186
    ],
    [
        0.418136,
        0.146517
    ],
    [
        0.579889,
        0.0368284
    ],
    [
        0.79801,
        0.140114
    ],
    [
        -0.0413185,
        0.371455
    ],
    [
        -0.0529108,
        0.627352
    ],
    [
        0.0821375,
        0.882071
    ],
    [
        0.17308,
        0.301207
    ],
    [
        -0.120452,
        0.867216
    ],
    [
        0.371096,
        0.916454
    ],
    [
        -0.178381,
        0.146101
    ],
    [
        -0.276489,
        0.550525
    ],
    [
        0.12542,
        0.126643
    ],
    [
        -0.296654,
        0.286879
    ],
    [
        0.261744,
        -0.00604975
    ],
    [
        -0.213417,
        0.715776
    ],
    [
        0.425684,
        -0.153211
    ],
    [
        -0.480054,
        0.321357
    ],
    [
        -0.0717878,
        -0.0250567
    ],
    [
        -0.328775,
        -0.169666
    ],
    [
        -0.394923,
        0.130802
    ],
    [
        -0.553681,
        -0.176777
    ],
    [
        -0.722615,
        0.120616
    ],
    [
        -0.693065,
        0.309017
    ],
    [
        0.603193,
        0.791471
    ],
    [
        -0.0754941,
        -0.297988
    ],
    [
        0.109303,
        -0.156472
    ],
    [
        0.260605,
        -0.280111
    ],
    [
        0.129731,
        -0.487954
    ],
    [
        -0.537315,
        0.520494
    ],
    [
        -0.42758,
        0.800607
    ],
    [
        0.77309,
        -0.0728102
    ],
    [
        0.908777,
        0.328356
    ],
    [
        0.985341,
        0.0759158
    ],
    [
        0.947536,
        -0.11837
    ],
    [
        -0.103315,
        -0.610747
    ],
    [
        0.337171,
        -0.584
    ],
    [
        0.210919,
        -0.720055
    ],
    [
        0.41894,
        -0.36769
    ],
    [
        -0.254228,
        -0.49368
    ],
    [
        -0.428562,
        -0.404037
    ],
    [
        -0.831732,
        -0.189615
    ],
    [
        -0.922642,
        0.0888026
    ],
    [
        -0.865914,
        0.427795
    ],
    [
        0.706117,
        -0.311662
    ],
    [
        0.545465,
        -0.520942
    ],
    [
        -0.695738,
        0.664492
    ],
    [
        0.389421,
        -0.899007
    ],
    [
        0.48842,
        -0.708054
    ],
    [
        0.760298,
        -0.62735
    ],
    [
        -0.390788,
        -0.707388
    ],
    [
        -0.591046,
        -0.686721
    ],
    [
        -0.769903,
        -0.413775
    ],
    [
        -0.604457,
        -0.502571
    ],
    [
        -0.557234,
        0.00451362
    ],
    [
        0.147572,
        -0.924353
    ],
    [
        -0.0662488,
        -0.892081
    ],
    [
        0.863832,
        -0.4072
    ]
];
function getShadowMapTexelSize(scope) {
    return scope.$builder.div(1, ShaderHelper.getShadowCameraParams(scope).z);
}
function getShadowMapSize(scope) {
    return ShaderHelper.getShadowCameraParams(scope).z;
}
/** @internal */ function computeShadowMapDepth(scope, worldPos, targetFormat) {
    const funcNameComputeShadowMapDepth = 'Z_computeShadowMapDepth';
    const pb = scope.$builder;
    pb.func(funcNameComputeShadowMapDepth, [
        pb.vec3('worldPos')
    ], function() {
        if (hasDepthChannel(targetFormat)) {
            // use native shadowmap
            this.$return(pb.vec4(pb.emulateDepthClamp ? pb.clamp(scope.$inputs.clamppedDepth, 0, 1) : scope.$builtins.fragCoord.z, 0, 0, 1));
        } else {
            this.$l.depth = pb.float();
            this.$l.lightType = ShaderHelper.getLightTypeForShadow(this);
            this.$if(pb.equal(this.lightType, LIGHT_TYPE_DIRECTIONAL), function() {
                this.depth = pb.emulateDepthClamp ? pb.clamp(this.$inputs.clamppedDepth, 0, 1) : this.$builtins.fragCoord.z;
            }).$elseif(pb.equal(this.lightType, LIGHT_TYPE_POINT), function() {
                this.$l.lightSpacePos = pb.mul(ShaderHelper.getLightViewMatrixForShadow(this), pb.vec4(this.worldPos, 1));
                this.depth = pb.clamp(pb.div(pb.length(this.lightSpacePos.xyz), ShaderHelper.getLightPositionAndRangeForShadow(this).w), 0, 1);
            }).$else(function() {
                this.$l.lightSpacePos = pb.mul(ShaderHelper.getLightViewMatrixForShadow(this), pb.vec4(this.worldPos, 1));
                this.depth = pb.clamp(pb.div(pb.neg(this.lightSpacePos.z), ShaderHelper.getLightPositionAndRangeForShadow(this).w), 0, 1);
            });
            this.$return(targetFormat === 'rgba8unorm' ? encodeNormalizedFloatToRGBA(this, this.depth) : pb.vec4(this.depth, 0, 0, 1));
        }
    });
    return pb.getGlobalScope()[funcNameComputeShadowMapDepth](worldPos);
}
/** @internal */ function computeReceiverPlaneDepthBias(scope, texCoord) {
    const funcNameComputeReceiverPlaneDepthBias = 'lib_computeReceiverPlaneDepthBias';
    const pb = scope.$builder;
    pb.func(funcNameComputeReceiverPlaneDepthBias, [
        pb.vec4('coords')
    ], function() {
        this.$l.dx = pb.dpdx(this.coords);
        this.$l.dy = pb.dpdy(this.coords);
        this.$l.biasMultiply = pb.float(1);
        this.$l.uv = pb.vec2(pb.sub(pb.mul(this.dy.y, this.dx.z), pb.mul(this.dx.y, this.dy.z)), pb.sub(pb.mul(this.dx.x, this.dy.z), pb.mul(this.dy.x, this.dx.z)));
        this.$l.uv = pb.mul(this.$l.uv, pb.div(this.biasMultiply, pb.sub(pb.mul(this.dx.x, this.dy.y), pb.mul(this.dx.y, this.dy.x))));
        // from unity shader
        this.$l.minFractionalError = pb.float(0.01);
        this.$l.fractionalSamplingError = pb.dot(pb.vec2(getShadowMapTexelSize(this)), pb.abs(this.$l.uv));
        this.$l.staticBias = pb.min(this.$l.fractionalSamplingError, this.$l.minFractionalError);
        // return
        this.$return(pb.vec3(this.$l.uv, this.$l.staticBias));
    });
    return pb.getGlobalScope()[funcNameComputeReceiverPlaneDepthBias](texCoord);
}
// reference: github.com/google/filament
function interleavedGradientNoise(scope, c) {
    const pb = scope.$builder;
    const x = 0.06711056;
    const y = 0.00583715;
    const z = 52.9829189;
    return pb.fract(pb.mul(z, pb.fract(pb.dot(c, pb.vec2(x, y)))));
}
// reference: github.com/google/filament
function getRandomRotationMatrix(scope, fragCoord) {
    const funcNameGetRandomRotationMatrix = 'lib_getRandomRotationMatrix';
    const pb = scope.$builder;
    pb.func(funcNameGetRandomRotationMatrix, [
        pb.vec2('fragCoord')
    ], function() {
        this.$l.randomAngle = pb.mul(interleavedGradientNoise(this, fragCoord), 2 * Math.PI);
        this.$l.randomBase = pb.vec2(pb.cos(this.randomAngle), pb.sin(this.randomAngle));
        this.$return(pb.mat2(this.randomBase.x, this.randomBase.y, pb.neg(this.randomBase.y), this.randomBase.x));
    });
    return pb.getGlobalScope()[funcNameGetRandomRotationMatrix](fragCoord);
}
function getPoissonDiscSampleRadius(scope) {
    return ShaderHelper.getDepthBiasValues(scope).z;
}
function sampleShadowMapPCF(scope, shadowMapFormat, pos, offset, depth, cascade) {
    const funcName = cascade ? 'lib_sampleShadowMapCascadePCF' : 'lib_sampleShadowMapPCF';
    const pb = scope.$builder;
    const nativeShadowMap = hasDepthChannel(shadowMapFormat);
    pb.func(funcName, [
        pb.vec2('coords'),
        pb.float('z'),
        pb.vec2('offset'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        const sampleDepth = this.z;
        const uv = pb.add(this.coords, this.offset);
        if (nativeShadowMap) {
            this.$return(cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), uv, this.cascade, sampleDepth) : pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), uv, sampleDepth));
        } else {
            this.$l.shadowTex = cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), uv, this.cascade, 0) : pb.textureSampleLevel(ShaderHelper.getShadowMap(this), uv, 0);
            if (shadowMapFormat === 'rgba8unorm') {
                this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
            }
            this.$return(pb.step(sampleDepth, this.shadowTex.x));
        }
    });
    return pb.getGlobalScope()[funcName](pos, depth, offset, ...cascade ? [
        cascade
    ] : []);
}
function sampleShadowMap(scope, lightType, shadowMapFormat, pos, depth, cascade) {
    const funcNameSampleShadowMap = 'lib_sampleShadowMap';
    const pb = scope.$builder;
    const nativeShadowMap = hasDepthChannel(shadowMapFormat);
    pb.func(funcNameSampleShadowMap, [
        lightType === LIGHT_TYPE_POINT ? pb.vec3('coords') : pb.vec2('coords'),
        pb.float('z'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        if (lightType === LIGHT_TYPE_POINT) {
            if (nativeShadowMap) {
                this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, this.z), 0, 1));
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (shadowMapFormat === 'rgba8unorm') {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.z, this.shadowTex.x));
            }
        } else {
            if (nativeShadowMap) {
                this.$return(cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, this.cascade, this.z) : pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, this.z));
            } else {
                this.$l.shadowTex = cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.coords, this.cascade, 0) : pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (shadowMapFormat === 'rgba8unorm') {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.z, this.shadowTex.x));
            }
        }
    });
    return cascade ? pb.getGlobalScope()[funcNameSampleShadowMap](pos, depth, cascade) : pb.getGlobalScope()[funcNameSampleShadowMap](pos, depth);
}
function chebyshevUpperBound(scope, distance, occluder) {
    const funcNameChebyshevUpperBound = 'lib_chebyshevUpperBound';
    const pb = scope.$builder;
    pb.func(funcNameChebyshevUpperBound, [
        pb.float('distance'),
        pb.vec2('occluder')
    ], function() {
        this.$l.shadow = pb.float(1);
        this.$l.test = pb.step(this.distance, this.occluder.x);
        this.$if(pb.notEqual(this.test, 1), function() {
            this.$l.d = pb.sub(this.distance, this.occluder.x);
            this.$l.variance = pb.max(pb.mul(this.occluder.y, this.occluder.y), 0);
            const darkness = ShaderHelper.getDepthBiasValues(this).z;
            this.shadow = pb.div(this.variance, pb.add(this.variance, pb.mul(this.d, this.d)));
            this.shadow = pb.clamp(pb.div(pb.sub(this.shadow, darkness), pb.sub(1, darkness)), 0, 1);
        });
        this.$return(this.shadow);
    });
    return pb.getGlobalScope()[funcNameChebyshevUpperBound](distance, occluder);
}
/** @internal */ function filterShadowVSM(scope, lightType, shadowMapFormat, texCoord, cascade) {
    const funcNameFilterShadowVSM = 'lib_filterShadowVSM';
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowVSM, [
        pb.vec4('texCoord'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        if (lightType === LIGHT_TYPE_POINT) {
            this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.texCoord.xyz, 0);
            this.$return(chebyshevUpperBound(this, this.texCoord.w, shadowMapFormat === 'rgba8unorm' ? decode2HalfFromRGBA(this, this.shadowTex) : this.shadowTex.rg));
        } else {
            if (Application.instance.device.type !== 'webgl' && cascade) {
                this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.texCoord.xy, this.cascade, 0);
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.texCoord.xy, 0);
            }
            this.$return(chebyshevUpperBound(this, this.texCoord.z, shadowMapFormat === 'rgba8unorm' ? decode2HalfFromRGBA(this, this.shadowTex) : this.shadowTex.rg));
        }
    });
    return pb.getGlobalScope()[funcNameFilterShadowVSM](texCoord, ...cascade ? [
        cascade
    ] : []);
}
/** @internal */ function filterShadowESM(scope, lightType, shadowMapFormat, shadowVertex, cascade) {
    const funcNameFilterShadowESM = 'lib_filterShadowESM';
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowESM, [
        lightType === LIGHT_TYPE_POINT ? pb.vec3('shadowVertex') : pb.vec4('shadowVertex'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        if (lightType === LIGHT_TYPE_POINT) {
            this.$l.depth = pb.div(pb.length(this.shadowVertex.xyz), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
            this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowVertex.xyz, 0);
            if (shadowMapFormat === 'rgba8unorm') {
                this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
            }
        } else {
            if (cascade && Application.instance.device.type !== 'webgl') {
                this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.shadowVertex.xy, this.cascade, 0);
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowVertex.xy, 0);
            }
            if (shadowMapFormat === 'rgba8unorm') {
                this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
            }
            if (lightType === LIGHT_TYPE_SPOT) {
                this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                this.$l.depth = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.shadowVertex.z, this.nearFar);
            } else {
                this.$l.depth = this.shadowVertex.z;
            }
        }
        const depthScale = ShaderHelper.getDepthBiasValues(this).z;
        this.$return(pb.clamp(pb.exp(pb.min(87, pb.mul(depthScale, pb.sub(this.shadowTex.x, this.depth)))), 0, 1));
    });
    return pb.getGlobalScope()[funcNameFilterShadowESM](shadowVertex, ...cascade ? [
        cascade
    ] : []);
}
/** @internal */ function filterShadowPCF(scope, lightType, shadowMapFormat, kernelSize, texCoord, receiverPlaneDepthBias, cascade) {
    const funcNameFilterShadowPCF = `lib_filterShadowPCF${kernelSize}x${kernelSize}`;
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowPCF, [
        pb.vec4('texCoord'),
        ...receiverPlaneDepthBias ? [
            pb.vec3('receiverPlaneDepthBias')
        ] : [],
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        this.$l.lightDepth = this.texCoord.z;
        if (receiverPlaneDepthBias) {
            this.lightDepth = pb.sub(this.lightDepth, this.receiverPlaneDepthBias.z);
        }
        const shadowMapTexelSize = getShadowMapTexelSize(this);
        this.$l.uv = pb.add(pb.mul(this.texCoord.xy, pb.vec2(getShadowMapSize(this))), pb.vec2(0));
        this.$l.st = pb.fract(this.uv);
        this.$l.baseUV = pb.sub(pb.floor(this.uv), pb.vec2(0.5));
        this.baseUV = pb.mul(this.baseUV, shadowMapTexelSize);
        this.$l.shadow = pb.float(0);
        if (kernelSize === 3) {
            this.$l.uvw0 = pb.sub(pb.vec2(3), pb.mul(2, this.st));
            this.$l.uvw1 = pb.add(pb.vec2(1), pb.mul(2, this.st));
            this.$l.u = pb.mul(pb.vec2(pb.sub(pb.div(pb.sub(2, this.st.x), this.uvw0.x), 1), pb.add(pb.div(this.st.x, this.uvw1.x), 1)), shadowMapTexelSize);
            this.$l.v = pb.mul(pb.vec2(pb.sub(pb.div(pb.sub(2, this.st.y), this.uvw0.y), 1), pb.add(pb.div(this.st.y, this.uvw1.y), 1)), shadowMapTexelSize);
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.x), this.lightDepth, this.cascade), this.uvw0.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.x), this.lightDepth, this.cascade), this.uvw1.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.y), this.lightDepth, this.cascade), this.uvw0.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.y), this.lightDepth, this.cascade), this.uvw1.x, this.uvw1.y));
            this.shadow = pb.div(this.shadow, 16);
        } else if (kernelSize === 5) {
            this.$l.uvw0 = pb.sub(pb.vec2(4), pb.mul(this.st, 3));
            this.$l.uvw1 = pb.vec2(7);
            this.$l.uvw2 = pb.add(pb.vec2(1), pb.mul(this.st, 3));
            this.$l.u = pb.mul(pb.vec3(pb.sub(pb.div(pb.sub(3, pb.mul(this.st.x, 2)), this.uvw0.x), 2), pb.div(pb.add(this.st.x, 3), this.uvw1.x), pb.add(pb.div(this.st.x, this.uvw2.x), 2)), shadowMapTexelSize);
            this.$l.v = pb.mul(pb.vec3(pb.sub(pb.div(pb.sub(3, pb.mul(this.st.y, 2)), this.uvw0.y), 2), pb.div(pb.add(this.st.y, 3), this.uvw1.y), pb.add(pb.div(this.st.y, this.uvw2.y), 2)), shadowMapTexelSize);
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.x), this.lightDepth, this.cascade), this.uvw0.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.x), this.lightDepth, this.cascade), this.uvw1.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.z, this.v.x), this.lightDepth, this.cascade), this.uvw2.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.y), this.lightDepth, this.cascade), this.uvw0.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.y), this.lightDepth, this.cascade), this.uvw1.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.z, this.v.y), this.lightDepth, this.cascade), this.uvw2.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.z), this.lightDepth, this.cascade), this.uvw0.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.z), this.lightDepth, this.cascade), this.uvw1.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.z, this.v.z), this.lightDepth, this.cascade), this.uvw2.x, this.uvw2.y));
            this.shadow = pb.div(this.shadow, 144);
        } else if (kernelSize === 7) {
            this.$l.uvw0 = pb.sub(pb.mul(this.st, 5), pb.vec2(6));
            this.$l.uvw1 = pb.sub(pb.mul(this.st, 11), pb.vec2(28));
            this.$l.uvw2 = pb.sub(pb.mul(this.st, -11), pb.vec2(17));
            this.$l.uvw3 = pb.sub(pb.mul(this.st, -5), 1);
            this.$l.u = pb.vec4(pb.sub(pb.div(pb.sub(pb.mul(this.st.x, 4), 5), this.uvw0.x), 3), pb.sub(pb.div(pb.sub(pb.mul(this.st.x, 4), 16), this.uvw1.x), 1), pb.add(pb.div(pb.sub(pb.mul(this.st.x, -7), 5), this.uvw2.x), 1), pb.add(pb.div(pb.neg(this.st.x), this.uvw3.x), 3));
            this.$l.v = pb.vec4(pb.sub(pb.div(pb.sub(pb.mul(this.st.y, 4), 5), this.uvw0.y), 3), pb.sub(pb.div(pb.sub(pb.mul(this.st.y, 4), 16), this.uvw1.y), 1), pb.add(pb.div(pb.sub(pb.mul(this.st.y, -7), 5), this.uvw2.y), 1), pb.add(pb.div(pb.neg(this.st.y), this.uvw3.y), 3));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw3.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw3.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw3.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw3.y));
            this.shadow = pb.div(this.shadow, 2704);
        }
        this.$return(this.shadow);
    });
    return pb.getGlobalScope()[funcNameFilterShadowPCF](texCoord, ...receiverPlaneDepthBias ? [
        receiverPlaneDepthBias
    ] : [], ...cascade ? [
        cascade
    ] : []);
}
/** @internal */ function filterShadowPoissonDisc(scope, lightType, shadowMapFormat, tapCount, texCoord, receiverPlaneDepthBias, cascade) {
    const funcNameFilterShadowPoissonDisc = 'lib_filterShadowPoissonDisc';
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowPoissonDisc, [
        pb.vec4('texCoord'),
        ...receiverPlaneDepthBias ? [
            pb.vec3('receiverPlaneDepthBias')
        ] : [],
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        this.$l.lightDepth = this.texCoord.z;
        if (receiverPlaneDepthBias) {
            this.lightDepth = pb.sub(this.lightDepth, this.receiverPlaneDepthBias.z);
        }
        this.$l.duv = pb.vec2();
        this.$l.filterRadius = pb.mul(getShadowMapTexelSize(this), getPoissonDiscSampleRadius(this));
        this.$l.matrix = getRandomRotationMatrix(this, this.$builtins.fragCoord.xy);
        this.$l.shadow = pb.float(0);
        for(let i = 0; i < tapCount; i++){
            this.duv = pb.mul(this.matrix, pb.mul(pb.vec2(PCF_POISSON_DISC[i][0], PCF_POISSON_DISC[i][1]), this.filterRadius));
            const sampleDepth = receiverPlaneDepthBias ? pb.add(this.lightDepth, pb.dot(this.duv, this.receiverPlaneDepthBias.xy)) : this.lightDepth;
            this.shadow = pb.add(this.shadow, sampleShadowMap(this, lightType, shadowMapFormat, pb.add(this.texCoord.xy, this.duv), sampleDepth, this.cascade));
        }
        this.shadow = pb.div(this.shadow, tapCount);
        this.$return(this.shadow);
    });
    return pb.getGlobalScope()[funcNameFilterShadowPoissonDisc](texCoord, ...receiverPlaneDepthBias ? [
        receiverPlaneDepthBias
    ] : [], ...cascade ? [
        cascade
    ] : []);
}

/** @internal */ class SSM extends ShadowImpl {
    static instance = new SSM();
    constructor(){
        super();
    }
    resourceDirty() {
        return false;
    }
    getType() {
        return 'hard';
    }
    getShadowMapBorder(shadowMapParams) {
        return 0;
    }
    getShadowMap(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? shadowMapParams.shadowMapFramebuffer.getDepthAttachment() : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(this.useNativeShadowMap(shadowMapParams)) || null;
    }
    postRenderShadowMap() {}
    releaseTemporalResources(shadowMapParams) {}
    getDepthScale() {
        return 1;
    }
    setDepthScale(val) {}
    getShaderHash() {
        return '';
    }
    getShadowMapColorFormat(shadowMapParams) {
        if (this.useNativeShadowMap(shadowMapParams)) {
            return null;
        } else {
            const device = Application.instance.device;
            if (device.type === 'webgl') {
                return device.getDeviceCaps().textureCaps.supportFloatColorBuffer ? 'rgba32f' : device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? 'rgba16f' : 'rgba8unorm';
            } else {
                return 'r32f';
            }
        }
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return Application.instance.device.type === 'webgl' ? 'd24s8' : 'd32f';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            this.$l.shadowCoord = pb.div(this.shadowVertex.xyz, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord.xyz, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    if (shadowMapParams.shadowMap.isTexture2DArray()) {
                        this.shadow = pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.split, this.shadowCoord.z);
                    } else {
                        this.shadow = pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.shadowCoord.z);
                    }
                } else {
                    if (shadowMapParams.shadowMap.isTexture2DArray()) {
                        this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.split, 0);
                    } else {
                        this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, 0);
                    }
                    if (!floatDepthTexture) {
                        this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                    }
                    this.shadow = pb.step(this.shadowCoord.z, this.shadowTex.x);
                }
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                    this.$l.maxZ = pb.max(pb.max(pb.abs(this.dir.x), pb.abs(this.dir.y)), pb.abs(this.dir.z));
                    this.$l.distance = ShaderHelper.linearDepthToNonLinear(this, this.maxZ, this.nearFar);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, pb.div(this.maxZ, ShaderHelper.getLightPositionAndRangeForShadow(this).w), this.NdotL, true);
                    this.$return(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.dir, pb.sub(this.distance, this.shadowBias)));
                } else {
                    this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                    this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.dir, 0);
                    if (!floatDepthTexture) {
                        this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                    }
                    this.distance = pb.sub(this.distance, this.shadowBias);
                    this.$return(pb.step(this.distance, this.shadowTex.x));
                }
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex.xyz, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord.xyz, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$if(this.inShadow, function() {
                    if (that.useNativeShadowMap(shadowMapParams)) {
                        this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                        this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                        this.shadow = pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.shadowCoord.z);
                    } else {
                        if (shadowMapParams.lightType === LIGHT_TYPE_SPOT) {
                            this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                            this.shadowCoord.z = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.shadowCoord.z, this.nearFar);
                            this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, true);
                        } else {
                            this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                        }
                        this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                        this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, 0);
                        if (!floatDepthTexture) {
                            this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                        }
                        this.shadow = pb.step(this.shadowCoord.z, this.shadowTex.x);
                    }
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return Application.instance.device.type !== 'webgl';
    }
}

/**
 * Gaussian blur blitter
 * @public
 */ class GaussianBlurBlitter extends Blitter {
    /** @internal */ _phase;
    /** @internal */ _kernelSize;
    /** @internal */ _sigma;
    /** @internal */ _blurSize;
    /** @internal */ _logSpace;
    /** @internal */ _logSpaceMultiplier;
    /** @internal */ _depthTex;
    /** @internal */ _depthCutoff;
    /**
   * Creates an instance of GaussianBlurBlitter
   * @param phase - Blitter phase
   * @param kernalSize - kernel size
   * @param sigma - Gaussian standard deviation
   * @param blurSize - Blur radius
   */ constructor(phase, kernalSize, sigma, blurSize){
        super();
        this._phase = phase;
        this._kernelSize = kernalSize;
        this._sigma = sigma;
        this._blurSize = blurSize;
        this._logSpace = false;
        this._logSpaceMultiplier = 1;
        this._depthTex = null;
        this._depthCutoff = 0.7;
    }
    /** Blur radius */ get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    /** Kernel size */ get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        if (this._kernelSize !== val) {
            this._kernelSize = val;
            this.invalidateHash();
        }
    }
    /** true if the box filter will be applied in logarithmic space */ get logSpace() {
        return this._logSpace;
    }
    set logSpace(val) {
        if (this._logSpace !== !!val) {
            this._logSpace = !!val;
            this.invalidateHash();
        }
    }
    /** Multiplier for logarithmic space blur */ get logSpaceMultiplier() {
        return this._logSpaceMultiplier;
    }
    set logSpaceMultiplier(val) {
        this._logSpaceMultiplier = val;
    }
    /** Linear depth texture */ get depthTexture() {
        return this._depthTex;
    }
    set depthTexture(tex) {
        if (this._depthTex !== tex) {
            if (!tex || !this._depthTex) {
                this.invalidateHash();
            }
            this._depthTex = tex;
        }
    }
    /** Depth cutoff */ get depthCutoff() {
        return this._depthCutoff;
    }
    set depthCutoff(val) {
        this._depthCutoff = val;
    }
    /**
   * {@inheritDoc Blitter.setup}
   * @override
   */ setup(scope, type) {
        const pb = scope.$builder;
        if (pb.shaderKind === 'fragment') {
            if (this._depthTex) {
                scope.depthTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                scope.depthCutoff = pb.float().uniform(0);
            }
            scope.sigma = pb.float().uniform(0);
            scope.blurSize = pb.float().uniform(0);
            if (this._logSpace && this._phase === 'horizonal') {
                scope.multiplier = pb.float().uniform(0);
            }
            if (this._phase !== 'horizonal' && this._phase !== 'vertical') {
                throw new Error(`GaussianBlurFilter.setupFilter() failed: invalid phase: ${this._phase}`);
            }
            if (!Number.isInteger(this._kernelSize) || this._kernelSize < 0 || (this._kernelSize & 1) === 0) {
                throw new Error(`GaussianBlurFilter.setupFilter() failed: invalid kernel size: ${this._kernelSize}`);
            }
            scope.blurMultiplyVec = type === 'cube' ? this._phase === 'horizonal' ? pb.vec3(1, 0, 0) : pb.vec3(0, 1, 0) : this._phase === 'horizonal' ? pb.vec2(1, 0) : pb.vec2(0, 1);
            scope.numBlurPixelsPerSide = pb.float((this._kernelSize + 1) / 2);
        }
    }
    /**
   * {@inheritDoc Blitter.setUniforms}
   * @override
   */ setUniforms(bindGroup) {
        bindGroup.setValue('sigma', this._sigma);
        bindGroup.setValue('blurSize', this._blurSize);
        if (this._logSpace && this._phase === 'horizonal') {
            bindGroup.setValue('multiplier', this._logSpaceMultiplier);
        }
        if (this._depthTex) {
            bindGroup.setTexture('depthTex', this._depthTex);
            bindGroup.setValue('depthCutoff', this._depthCutoff);
        }
    }
    /**
   * {@inheritDoc Blitter.filter}
   * @override
   */ filter(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const that = this;
        const pb = scope.$builder;
        if (that._depthTex) {
            pb.func('getLinearDepth', [
                pb.vec2('uv')
            ], function() {
                this.$l.depthValue = pb.textureSample(this.depthTex, this.uv);
                if (pb.getDevice().type === 'webgl') {
                    this.$return(decodeNormalizedFloatFromRGBA(this, this.depthValue));
                } else {
                    this.$return(this.depthValue.r);
                }
            });
        }
        scope.incrementalGaussian = pb.vec3();
        scope.incrementalGaussian.x = pb.div(1, pb.mul(scope.sigma, Math.sqrt(2 * Math.PI)));
        scope.incrementalGaussian.y = pb.exp(pb.div(-0.5, pb.mul(scope.sigma, scope.sigma)));
        scope.incrementalGaussian.z = pb.mul(scope.incrementalGaussian.y, scope.incrementalGaussian.y);
        scope.coefficientSum = pb.float(0);
        scope.minExpValue = pb.vec4(87, 87, 87, 87);
        scope.d0 = that.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        if (that._logSpace) {
            scope.avgValue = pb.vec4(scope.incrementalGaussian.x);
        } else {
            scope.avgValue = pb.mul(that.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType), scope.incrementalGaussian.x);
        }
        if (that._depthTex) {
            scope.centerDepth = scope.getLinearDepth(srcUV);
        }
        scope.coefficientSum = pb.add(scope.coefficientSum, scope.incrementalGaussian.x);
        scope.incrementalGaussian = pb.vec3(pb.mul(scope.incrementalGaussian.xy, scope.incrementalGaussian.yz), scope.incrementalGaussian.z);
        scope.$for(pb.float('i'), 1, scope.numBlurPixelsPerSide, function() {
            this.$l.uv1 = pb.sub(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i));
            this.$l.d1 = pb.vec4();
            if (that._depthTex) {
                this.$l.depth1 = this.getLinearDepth(this.uv1);
                this.$l.test1 = pb.lessThan(pb.abs(pb.sub(this.depth1, this.centerDepth)), this.depthCutoff);
            } else {
                this.$l.test1 = true;
            }
            this.$if(this.test1, function() {
                this.d1 = that.readTexel(scope, type, srcTex, this.uv1, srcLayer, sampleType);
            });
            this.$l.uv2 = pb.add(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), this.$l.d2 = pb.vec4();
            if (that._depthTex) {
                this.$l.depth2 = this.getLinearDepth(this.uv2);
                this.$l.test2 = pb.lessThan(pb.abs(pb.sub(this.depth2, this.centerDepth)), this.depthCutoff);
            } else {
                this.$l.test2 = true;
            }
            this.$if(this.test2, function() {
                this.d2 = that.readTexel(scope, type, srcTex, pb.add(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), srcLayer, sampleType);
            });
            if (that._logSpace) {
                if (that._phase === 'horizonal') {
                    this.$if(this.test1, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.mul(pb.sub(this.d1, this.d0), this.multiplier))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                    this.$if(this.test2, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.mul(pb.sub(this.d2, this.d0), this.multiplier))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                } else {
                    this.$if(this.test1, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.sub(this.d1, this.d0))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                    this.$if(this.test2, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.sub(this.d2, this.d0))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                }
            } else {
                this.$if(this.test1, function() {
                    this.avgValue = pb.add(this.avgValue, pb.mul(this.d1, this.incrementalGaussian.x));
                    this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                });
                this.$if(this.test2, function() {
                    this.avgValue = pb.add(this.avgValue, pb.mul(this.d2, this.incrementalGaussian.x));
                    this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                });
            }
            this.incrementalGaussian = pb.vec3(pb.mul(this.incrementalGaussian.xy, this.incrementalGaussian.yz), this.incrementalGaussian.z);
        });
        scope.$l.outColor = pb.div(scope.avgValue, scope.coefficientSum);
        if (that._logSpace) {
            if (that._phase === 'horizonal') {
                scope.outColor = pb.add(pb.mul(scope.multiplier, scope.d0), pb.log(scope.outColor));
            } else {
                scope.outColor = pb.add(scope.d0, pb.log(scope.outColor));
            }
        }
        return scope.outColor;
    }
    /**
   * {@inheritDoc Blitter.calcHash}
   * @override
   */ calcHash() {
        return `${this._depthTex ? 1 : 0}-${this._phase}-${this._kernelSize}-${Number(!!this._logSpace)}`;
    }
}

class BlurBlitter extends GaussianBlurBlitter {
    _packFloat;
    get packFloat() {
        return this._packFloat;
    }
    set packFloat(b) {
        if (this._packFloat !== !!b) {
            this._packFloat = !!b;
            this.invalidateHash();
        }
    }
    readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const pb = scope.$builder;
        const texel = super.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        if (this.packFloat) {
            return pb.vec4(decodeNormalizedFloatFromRGBA(scope, texel), 0, 0, 1);
        } else {
            return texel;
        }
    }
    writeTexel(scope, type, srcUV, texel) {
        const outTexel = super.writeTexel(scope, type, srcUV, texel);
        if (this.packFloat) {
            return encodeNormalizedFloatToRGBA(scope, outTexel.r);
        } else {
            return outTexel;
        }
    }
    calcHash() {
        return `${super.calcHash()}-${Number(this.packFloat)}`;
    }
}
/** @internal */ class ESM extends ShadowImpl {
    /** @internal */ _depthScale;
    /** @internal */ _blur;
    /** @internal */ _kernelSize;
    /** @internal */ _blurSize;
    /** @internal */ _logSpace;
    /** @internal */ _blitterH;
    /** @internal */ _blitterV;
    /** @internal */ _mipmap;
    constructor(kernelSize, blurSize, depthScale){
        super();
        this._blur = true;
        this._depthScale = depthScale ?? 500;
        this._kernelSize = kernelSize ?? 5;
        this._blurSize = blurSize ?? 1;
        this._logSpace = true;
        this._mipmap = true;
        this._blitterH = new BlurBlitter('horizonal', this._kernelSize, 4, 1 / 1024);
        this._blitterV = new BlurBlitter('vertical', this._kernelSize, 4, 1 / 1024);
    }
    resourceDirty() {
        return this._resourceDirty;
    }
    get blur() {
        return this._blur;
    }
    set blur(val) {
        if (this._blur !== !!val) {
            this._blur = !!val;
            this._resourceDirty = true;
        }
    }
    get mipmap() {
        return this._mipmap;
    }
    set mipmap(b) {
        if (this._mipmap !== !!b) {
            this._mipmap = !!b;
            if (this._blur) {
                this._resourceDirty = true;
            }
        }
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        this._kernelSize = val;
    }
    get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    get logSpace() {
        return this._logSpace;
    }
    set logSpace(val) {
        this._logSpace = !!val;
    }
    getType() {
        return 'esm';
    }
    getShadowMapBorder(shadowMapParams) {
        return this._blur ? Math.ceil((this._kernelSize + 1) / 2 * this._blurSize) : 0;
    }
    getShadowMap(shadowMapParams) {
        const implData = shadowMapParams.implData;
        return implData ? implData.blurFramebuffer2.getColorAttachments()[0] : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        const implData = {
            blurFramebuffer: null,
            blurFramebuffer2: null
        };
        shadowMapParams.implData = implData;
        const colorFormat = this.getShadowMapColorFormat(shadowMapParams);
        const target = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].target;
        const shadowMapWidth = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].width;
        const shadowMapHeight = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].height;
        if (this._blur) {
            shadowMapParams.implData = {
                blurFramebuffer: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, false),
                blurFramebuffer2: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, this._mipmap)
            };
        }
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(false) ?? null;
    }
    postRenderShadowMap(shadowMapParams) {
        if (shadowMapParams.implData) {
            const implData = shadowMapParams.implData;
            const colorAttachment = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
            this._blitterH.blurSize = this._blurSize / colorAttachment.width;
            this._blitterH.kernelSize = this._kernelSize;
            this._blitterH.logSpace = this._logSpace;
            this._blitterH.packFloat = colorAttachment.format === 'rgba8unorm';
            this._blitterV.blurSize = this._blurSize / colorAttachment.height;
            this._blitterV.kernelSize = this._kernelSize;
            this._blitterV.logSpace = this._logSpace;
            this._blitterV.packFloat = colorAttachment.format === 'rgba8unorm';
            this._blitterH.blit(colorAttachment, implData.blurFramebuffer);
            this._blitterV.blit(implData.blurFramebuffer.getColorAttachments()[0], implData.blurFramebuffer2);
        }
    }
    releaseTemporalResources(shadowMapParams) {
        const implData = shadowMapParams.implData;
        if (implData) {
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer);
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer2);
        }
    }
    getDepthScale() {
        return this._depthScale;
    }
    setDepthScale(val) {
        this._depthScale = val;
    }
    getShaderHash() {
        return '';
    }
    getShadowMapColorFormat(shadowMapParams) {
        const device = Application.instance.device;
        return device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? device.type === 'webgl' ? 'rgba16f' : 'r16f' : device.getDeviceCaps().textureCaps.supportFloatColorBuffer ? device.type === 'webgl' ? 'rgba32f' : 'r32f' : 'rgba8unorm';
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return 'd24s8';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$if(this.inShadow, function() {
                this.shadow = filterShadowESM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                this.$return(filterShadowESM(this, LIGHT_TYPE_POINT, shadowMapParams.shadowMap.format, this.dir));
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$if(this.inShadow, function() {
                    this.shadow = filterShadowESM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return false;
    }
}

class VSMBlitter extends Blitter {
    _phase;
    _packFloat;
    _blurSize;
    _kernelSize;
    constructor(phase, kernelSize, blurSize, packFloat){
        super();
        this._phase = phase;
        this._blurSize = blurSize;
        this._kernelSize = kernelSize;
        this._packFloat = packFloat;
    }
    get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        if (val !== this._kernelSize) {
            this._kernelSize = val;
            this.invalidateHash();
        }
    }
    get packFloat() {
        return this._packFloat;
    }
    set packFloat(b) {
        if (this._packFloat !== !!b) {
            this._packFloat = !!b;
            this.invalidateHash();
        }
    }
    setup(scope, type) {
        const pb = scope.$builder;
        if (pb.shaderKind === 'fragment') {
            scope.blurSize = pb.float().uniform(0);
            scope.blurMultiplyVec = type === 'cube' ? this._phase === 'horizonal' ? pb.vec3(1, 0, 0) : pb.vec3(0, 1, 0) : this._phase === 'horizonal' ? pb.vec2(1, 0) : pb.vec2(0, 1);
            scope.numBlurPixelsPerSide = pb.float((this._kernelSize + 1) / 2);
            scope.weight = pb.float(1 / (this._kernelSize * this._kernelSize));
        }
    }
    setUniforms(bindGroup) {
        bindGroup.setValue('blurSize', this._blurSize);
    }
    readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const pb = scope.$builder;
        const texel = super.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        if (this._packFloat) {
            if (this._phase === 'horizonal') {
                return pb.vec4(decodeNormalizedFloatFromRGBA(scope, texel));
            } else {
                return pb.vec4(decode2HalfFromRGBA(scope, texel), 0, 0);
            }
        } else {
            return texel;
        }
    }
    writeTexel(scope, type, srcUV, texel) {
        const outTexel = super.writeTexel(scope, type, srcUV, texel);
        if (this._packFloat) {
            return encode2HalfToRGBA(scope, outTexel.x, outTexel.y);
        } else {
            return outTexel;
        }
    }
    filter(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const that = this;
        const pb = scope.$builder;
        scope.d0 = that.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        scope.mean = pb.float(0);
        scope.squaredMean = pb.float(0);
        scope.$for(pb.float('i'), 1, scope.numBlurPixelsPerSide, function() {
            this.d1 = that.readTexel(this, type, srcTex, pb.sub(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), srcLayer, sampleType);
            this.d2 = that.readTexel(this, type, srcTex, pb.add(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), srcLayer, sampleType);
            this.mean = pb.add(this.mean, this.d1.x);
            this.mean = pb.add(this.mean, this.d2.x);
            if (that._phase === 'horizonal') {
                this.squaredMean = pb.add(this.squaredMean, pb.mul(this.d1.x, this.d1.x));
                this.squaredMean = pb.add(this.squaredMean, pb.mul(this.d2.x, this.d2.x));
            } else {
                this.squaredMean = pb.add(this.squaredMean, pb.dot(this.d1.xy, this.d1.xy));
                this.squaredMean = pb.add(this.squaredMean, pb.dot(this.d2.xy, this.d2.xy));
            }
        });
        scope.mean = pb.div(scope.mean, that._kernelSize);
        scope.squaredMean = pb.div(scope.squaredMean, that._kernelSize);
        scope.stdDev = pb.sqrt(pb.max(0, pb.sub(scope.squaredMean, pb.mul(scope.mean, scope.mean))));
        return pb.vec4(scope.mean, scope.stdDev, 0, 1);
    }
    calcHash() {
        return `${this._phase}-${this._kernelSize}-${Number(this._packFloat)}`;
    }
}
/** @internal */ class VSM extends ShadowImpl {
    /** @internal */ _blur;
    /** @internal */ _kernelSize;
    /** @internal */ _blurSize;
    /** @internal */ _blitterH;
    /** @internal */ _blitterV;
    /** @internal */ _mipmap;
    /** @internal */ _darkness;
    constructor(kernelSize, blurSize, darkness){
        super();
        this._blur = true;
        this._kernelSize = kernelSize ?? 5;
        this._blurSize = blurSize ?? 1;
        this._darkness = darkness ?? 0;
        this._mipmap = true;
        this._blitterH = new VSMBlitter('horizonal', this._kernelSize, 1 / 1024, false);
        this._blitterV = new VSMBlitter('vertical', this._kernelSize, 1 / 1024, false);
    }
    resourceDirty() {
        return this._resourceDirty;
    }
    get blur() {
        return this._blur;
    }
    set blur(val) {
        if (this._blur !== !!val) {
            this._blur = !!val;
            this._resourceDirty = true;
        }
    }
    get mipmap() {
        return this._mipmap;
    }
    set mipmap(b) {
        if (this._mipmap !== !!b) {
            this._mipmap = !!b;
            if (this._blur) {
                this._resourceDirty = true;
            }
        }
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        this._kernelSize = val;
    }
    get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    getDepthScale() {
        return this._darkness;
    }
    setDepthScale(val) {
        this._darkness = val;
    }
    getType() {
        return 'vsm';
    }
    getShadowMapBorder(shadowMapParams) {
        return this._blur ? Math.ceil((this._kernelSize + 1) / 2 * this._blurSize) : 0;
    }
    getShadowMap(shadowMapParams) {
        const implData = shadowMapParams.implData;
        return implData ? implData.blurFramebuffer2.getColorAttachments()[0] : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        const colorFormat = this.getShadowMapColorFormat(shadowMapParams);
        const target = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].target;
        const shadowMapWidth = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].width;
        const shadowMapHeight = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].height;
        if (this._blur) {
            shadowMapParams.implData = {
                blurFramebuffer: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, false),
                blurFramebuffer2: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, this._mipmap)
            };
        }
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(false) ?? null;
    }
    postRenderShadowMap(shadowMapParams) {
        if (this._blur) {
            const implData = shadowMapParams.implData;
            this._blitterH.blurSize = this._blurSize / shadowMapParams.shadowMap.width;
            this._blitterH.kernelSize = this._kernelSize;
            this._blitterH.packFloat = shadowMapParams.shadowMap.format === 'rgba8unorm';
            this._blitterV.blurSize = this._blurSize / shadowMapParams.shadowMap.height;
            this._blitterV.kernelSize = this._kernelSize;
            this._blitterV.packFloat = shadowMapParams.shadowMap.format === 'rgba8unorm';
            this._blitterH.blit(shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0], implData.blurFramebuffer);
            this._blitterV.blit(implData.blurFramebuffer.getColorAttachments()[0], implData.blurFramebuffer2);
        }
    }
    releaseTemporalResources(shadowMapParams) {
        const implData = shadowMapParams.implData;
        if (implData) {
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer);
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer2);
        }
    }
    getShaderHash() {
        return '';
    }
    getShadowMapColorFormat(shadowMapParams) {
        const device = Application.instance.device;
        return device.getDeviceCaps().textureCaps.supportFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearFloatTexture ? device.type === 'webgl' ? 'rgba32f' : 'rg32f' : device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? device.type === 'webgl' ? 'rgba16f' : 'rg16f' : 'rgba8unorm';
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return 'd24s8';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                this.shadow = filterShadowVSM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                this.$l.coord = pb.vec4(this.dir, pb.sub(this.distance, this.shadowBias));
                this.$return(filterShadowVSM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.coord));
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$if(this.inShadow, function() {
                    if (shadowMapParams.lightType === LIGHT_TYPE_SPOT) {
                        this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                        this.shadowCoord.z = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.shadowCoord.z, this.nearFar);
                        this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, true);
                    } else {
                        this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                    }
                    this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                    this.shadow = filterShadowVSM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return false;
    }
}

/** @internal */ class PCFPD extends ShadowImpl {
    _tapCount;
    _sampleRadius;
    _shadowSampler;
    constructor(tapCount, sampleRadius){
        super();
        this._tapCount = tapCount ?? 3;
        this._sampleRadius = sampleRadius ?? 1;
        this._shadowSampler = null;
    }
    get tapCount() {
        return this._tapCount;
    }
    set tapCount(val) {
        this._tapCount = val;
    }
    getType() {
        return 'pcf-pd';
    }
    dispose() {
        this._shadowSampler = null;
    }
    resourceDirty() {
        return false;
    }
    getShadowMapBorder(shadowMapParams) {
        return this._sampleRadius + 1;
    }
    getShadowMap(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? shadowMapParams.shadowMapFramebuffer.getDepthAttachment() : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(this.useNativeShadowMap(shadowMapParams)) || null;
    }
    postRenderShadowMap() {}
    releaseTemporalResources(shadowMapParams) {}
    getDepthScale() {
        return this._sampleRadius;
    }
    setDepthScale(val) {
        this._sampleRadius = val;
    }
    getShaderHash() {
        return `${this._tapCount}`;
    }
    getShadowMapColorFormat(shadowMapParams) {
        if (this.useNativeShadowMap(shadowMapParams)) {
            return null;
        } else {
            const device = Application.instance.device;
            return device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? device.type === 'webgl' ? 'rgba16f' : 'r16f' : device.getDeviceCaps().textureCaps.supportFloatColorBuffer ? device.type === 'webgl' ? 'rgba32f' : 'r32f' : 'rgba8unorm';
        }
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return Application.instance.device.type === 'webgl' ? 'd24s8' : 'd32f';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                this.shadow = filterShadowPoissonDisc(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._tapCount, this.shadowCoord, this.receiverPlaneDepthBias, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                    this.$l.maxZ = pb.max(pb.max(pb.abs(this.dir.x), pb.abs(this.dir.y)), pb.abs(this.dir.z));
                    this.$l.distance = ShaderHelper.linearDepthToNonLinear(this, this.maxZ, this.nearFar);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, pb.div(this.maxZ, ShaderHelper.getLightPositionAndRangeForShadow(this).w), this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                } else {
                    this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                }
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
                this.$if(this.inShadow, function() {
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                    this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                    this.shadow = filterShadowPoissonDisc(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._tapCount, this.shadowCoord, this.receiverPlaneDepthBias);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return Application.instance.device.type !== 'webgl';
    }
    /** @internal */ sampleShadowMap(shadowMapParams, scope, coords, z, bias) {
        const funcNameSampleShadowMap = 'lib_sampleShadowMap';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMap, [
            pb.vec3('coords'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            if (that.useNativeShadowMap(shadowMapParams)) {
                this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, pb.sub(this.z, this.bias)), 0, 1));
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$l.distance = pb.sub(this.z, this.bias);
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMap](coords, z, bias);
    }
    /** @internal */ sampleShadowMapCSM(shadowMapParams, scope, coords, split, z, bias) {
        const funcNameSampleShadowMapCSM = 'lib_sampleShadowMapCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMapCSM, [
            pb.vec4('coords'),
            pb.int('split'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            this.$l.distance = pb.sub(this.z, this.bias);
            if (that.useNativeShadowMap(shadowMapParams)) {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$return(pb.clamp(pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, this.distance), 0, 1));
                } else {
                    this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.distance), 0, 1));
                }
            } else {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, 0);
                } else {
                    this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, 0);
                }
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMapCSM](coords, split, z, bias);
    }
}

/** @internal */ class PCFOPT extends ShadowImpl {
    _kernelSize;
    _shadowSampler;
    constructor(kernelSize){
        super();
        this._kernelSize = kernelSize ?? 5;
        this._shadowSampler = null;
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        val = val !== 3 && val !== 5 && val !== 7 ? 5 : val;
        this._kernelSize = val;
    }
    getType() {
        return 'pcf-opt';
    }
    dispose() {
        this._shadowSampler = null;
    }
    resourceDirty() {
        return false;
    }
    getShadowMapBorder(shadowMapParams) {
        return this._kernelSize;
    }
    getShadowMap(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? shadowMapParams.shadowMapFramebuffer.getDepthAttachment() : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(this.useNativeShadowMap(shadowMapParams)) || null;
    }
    postRenderShadowMap() {}
    releaseTemporalResources(shadowMapParams) {}
    getDepthScale() {
        return 1;
    }
    setDepthScale(val) {}
    getShaderHash() {
        return `${this._kernelSize}`;
    }
    getShadowMapColorFormat(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? null : 'rgba8unorm';
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return Application.instance.device.type === 'webgl' ? 'd24s8' : 'd32f';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                this.shadow = filterShadowPCF(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._kernelSize, this.shadowCoord, this.receiverPlaneDepthBias, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                    this.$l.maxZ = pb.max(pb.max(pb.abs(this.dir.x), pb.abs(this.dir.y)), pb.abs(this.dir.z));
                    this.$l.distance = ShaderHelper.linearDepthToNonLinear(this, this.maxZ, this.nearFar);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, pb.div(this.maxZ, ShaderHelper.getLightPositionAndRangeForShadow(this).w), this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                } else {
                    this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                }
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
                this.$if(this.inShadow, function() {
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                    this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                    this.shadow = filterShadowPCF(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._kernelSize, this.shadowCoord, this.receiverPlaneDepthBias);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return Application.instance.device.type !== 'webgl';
    }
    /** @internal */ sampleShadowMap(shadowMapParams, scope, coords, z, bias) {
        const funcNameSampleShadowMap = `lib_sampleShadowMap`;
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMap, [
            pb.vec3('coords'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            if (that.useNativeShadowMap(shadowMapParams)) {
                this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, pb.sub(this.z, this.bias)), 0, 1));
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$l.distance = pb.sub(this.z, this.bias);
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMap](coords, z, bias);
    }
    /** @internal */ sampleShadowMapCSM(shadowMapParams, scope, coords, split, z, bias) {
        const funcNameSampleShadowMapCSM = 'lib_sampleShadowMapCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMapCSM, [
            pb.vec4('coords'),
            pb.int('split'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            this.$l.distance = pb.sub(this.z, this.bias);
            if (that.useNativeShadowMap(shadowMapParams)) {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$return(pb.clamp(pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, this.distance), 0, 1));
                } else {
                    this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.distance), 0, 1));
                }
            } else {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, 0);
                } else {
                    this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, 0);
                }
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMapCSM](coords, split, z, bias);
    }
}

const tmpMatrix = new Matrix4x4();
const tmpFrustum = new Frustum(Matrix4x4.identity());
// const zeroPosition = Vector3.zero();
/**
 * The shadow map generator
 * @public
 */ class ShadowMapper {
    /** @internal */ static _snapMatrix = new Matrix4x4();
    /** @internal */ static _target = new Vector3();
    /** @internal */ static _up = new Vector3();
    /** @internal */ static _frustumMin = new Vector3();
    /** @internal */ static _frustumMax = new Vector3();
    /** @internal */ static _frustumCenter = new Vector3();
    /** @internal */ static _lightCameras = new WeakMap();
    /** @internal */ static _shadowMapParams = [];
    /** @internal */ _light;
    /** @internal */ _config;
    /** @internal */ _resourceDirty;
    /** @internal */ _shadowMode;
    /** @internal */ _shadowDistance;
    /** @internal */ _impl;
    /** @internal */ _pdSampleCount;
    /** @internal */ _pdSampleRadius;
    /** @internal */ _pcfKernelSize;
    /** @internal */ _vsmBlurKernelSize;
    /** @internal */ _vsmBlurRadius;
    /** @internal */ _vsmDarkness;
    /** @internal */ _esmBlur;
    /** @internal */ _esmBlurKernelSize;
    /** @internal */ _esmBlurRadius;
    /** @internal */ _esmDepthScale;
    /**
   * Creates an instance of ShadowMapper
   * @param light - The light that is used to generate shadow map
   */ constructor(light){
        this._light = light;
        this._config = {
            shadowMapSize: 1024,
            numCascades: 1,
            splitLambda: 0.5,
            depthBias: 0.05,
            normalBias: 0.05,
            nearClip: 1
        };
        this._resourceDirty = true;
        this._shadowMode = 'hard';
        this._shadowDistance = 2000;
        this._impl = null;
        this._pdSampleCount = 12;
        this._pdSampleRadius = 4;
        this._pcfKernelSize = 5;
        this._vsmBlurKernelSize = 5;
        this._vsmBlurRadius = 4;
        this._vsmDarkness = 0.3;
        this._esmBlur = true;
        this._esmBlurKernelSize = 5;
        this._esmBlurRadius = 4;
        this._esmDepthScale = 200;
        this.applyMode(this._shadowMode);
    }
    /** The light that is used to generate shadow map */ get light() {
        return this._light;
    }
    /** Size of the shadow map */ get shadowMapSize() {
        return this._config.shadowMapSize;
    }
    set shadowMapSize(num) {
        if (!Number.isInteger(num) || num < 1) {
            console.error(`invalid shadow map size: ${num}`);
            return;
        }
        if (this._config.shadowMapSize !== num) {
            this._config.shadowMapSize = num;
            this._resourceDirty = true;
        }
    }
    /** Maximum distance from the camera, shadow will not be rendered beyond this range */ get shadowDistance() {
        return this._shadowDistance;
    }
    set shadowDistance(val) {
        this._shadowDistance = Math.max(0, val);
    }
    /** Count of the cascades, The maximum value is 4 */ get numShadowCascades() {
        return this._config.numCascades;
    }
    set numShadowCascades(num) {
        if (num !== 1 && num !== 2 && num !== 3 && num !== 4) {
            console.error(`invalid shadow cascade number: ${num}`);
            return;
        }
        if (!this._light.isDirectionLight() && num > 1) {
            console.error(`only directional light can have more than one shadow cascades`);
            return;
        }
        if (num !== this._config.numCascades) {
            this._config.numCascades = num;
            this._resourceDirty = true;
        }
    }
    /** The split lambda for cascaded shadow mapping */ get splitLambda() {
        return this._config.splitLambda;
    }
    set splitLambda(val) {
        if (this._config.splitLambda !== val) {
            this._config.splitLambda = val;
        }
    }
    /** Depth bias for the shadow map */ get depthBias() {
        return this._config.depthBias;
    }
    set depthBias(val) {
        this._config.depthBias = val;
    }
    /** Normal bias for the shadow map */ get normalBias() {
        return this._config.normalBias;
    }
    set normalBias(val) {
        this._config.normalBias = val;
    }
    /** Near clip plane */ get nearClip() {
        return this._config.nearClip;
    }
    set nearClip(val) {
        if (this._config.nearClip !== val) {
            this._config.nearClip = val;
        }
    }
    /** Shadow map mode */ get mode() {
        return this._shadowMode;
    }
    set mode(mode) {
        if (mode !== this._shadowMode) {
            this._shadowMode = mode;
            this.applyMode(this._shadowMode);
        }
    }
    /** Generated shadow map */ /*
  get shadowMap(): ShadowMapType {
    return (this._impl.getShadowMap(this) ?? this._framebuffer?.getColorAttachments()[0] ?? null) as ShadowMapType;
  }
  */ /** Sampler of the shadow map */ /*
  get shadowMapSampler(): TextureSampler {
    return this._impl.getShadowMapSampler(this);
  }
  */ /** @internal */ getShaderHash(shadowMapParams) {
        return `${shadowMapParams.impl.constructor.name}_${shadowMapParams.impl.getShaderHash()}_${shadowMapParams.lightType}_${shadowMapParams.shadowMap.target}_${Number(shadowMapParams.numShadowCascades > 1)}_${Number(Application.instance.device.getDeviceCaps().textureCaps.getTextureFormatInfo(shadowMapParams.shadowMap.format).filterable)}`;
    }
    /** Sample count for poisson disc PCF */ get pdSampleCount() {
        return this._pdSampleCount;
    }
    set pdSampleCount(val) {
        val = Math.min(Math.max(1, Number(val) >> 0), 64);
        if (val !== this._pdSampleCount) {
            this._pdSampleCount = val;
            this.asPCFPD() && (this.asPCFPD().tapCount = this._pdSampleCount);
        }
    }
    /** Radius for poisson disc PCF */ get pdSampleRadius() {
        return this._pdSampleRadius;
    }
    set pdSampleRadius(val) {
        val = Math.max(0, Number(val) >> 0);
        if (val !== this._pdSampleRadius) {
            this._pdSampleRadius = val;
            this.asPCFPD()?.setDepthScale(this._pdSampleRadius);
        }
    }
    /** Kernel size for optimized PCF */ get pcfKernelSize() {
        return this._pcfKernelSize;
    }
    set pcfKernelSize(val) {
        val = val !== 3 && val !== 5 && val !== 7 ? 5 : val;
        if (val !== this._pcfKernelSize) {
            this._pcfKernelSize = val;
            this.asPCFOPT() && (this.asPCFOPT().kernelSize = this._pcfKernelSize);
        }
    }
    /** Kernel size of VSM */ get vsmBlurKernelSize() {
        return this._vsmBlurKernelSize;
    }
    set vsmBlurKernelSize(val) {
        val = Math.max(3, Number(val) >> 0) | 1;
        if (val !== this._vsmBlurKernelSize) {
            this._vsmBlurKernelSize = val;
            this.asVSM() && (this.asVSM().kernelSize = this._vsmBlurKernelSize);
        }
    }
    /** Blur radius for VSM */ get vsmBlurRadius() {
        return this._vsmBlurRadius;
    }
    set vsmBlurRadius(val) {
        val = Math.max(0, Number(val) || 0);
        if (val !== this._vsmBlurRadius) {
            this._vsmBlurRadius = val;
            this.asVSM() && (this.asVSM().blurSize = this._vsmBlurRadius);
        }
    }
    /** Darkness for VSM */ get vsmDarkness() {
        return this._vsmDarkness;
    }
    set vsmDarkness(val) {
        val = Math.min(0.999, Math.max(0, Number(val) || 0));
        if (val !== this._vsmDarkness) {
            this._vsmDarkness = val;
            this.asVSM()?.setDepthScale(this._vsmDarkness);
        }
    }
    /** Whether to enable ESM blur */ get esmBlur() {
        return this._esmBlur;
    }
    set esmBlur(val) {
        if (!!val !== this.esmBlur) {
            this._esmBlur = !!val;
            this.asESM() && (this.asESM().blur = this._esmBlur);
        }
    }
    /** Kernel size for ESM */ get esmBlurKernelSize() {
        return this._esmBlurKernelSize;
    }
    set esmBlurKernelSize(val) {
        val = Math.max(3, Number(val) >> 0) | 1;
        if (val !== this._esmBlurKernelSize) {
            this._esmBlurKernelSize = val;
            this.asESM() && (this.asESM().kernelSize = this._esmBlurKernelSize);
        }
    }
    /** Blur radius for ESM */ get esmBlurRadius() {
        return this._esmBlurRadius;
    }
    set esmBlurRadius(val) {
        val = Math.max(0, Number(val) || 0);
        if (val !== this._esmBlurRadius) {
            this._esmBlurRadius = val;
            this.asESM() && (this.asESM().blurSize = this._esmBlurRadius);
        }
    }
    /** Depth scale for ESM */ get esmDepthScale() {
        return this._esmDepthScale;
    }
    set esmDepthScale(val) {
        val = Math.max(0, Number(val) || 0);
        if (val !== this._esmDepthScale) {
            this._esmDepthScale = val;
            this.asESM()?.setDepthScale(this._esmDepthScale);
        }
    }
    /** @internal */ computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        return this._impl.computeShadow(shadowMapParams, scope, shadowVertex, NdotL);
    }
    /** @internal */ computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        return this._impl.computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split);
    }
    /** @internal */ static releaseTemporalResources(ctx) {
        if (ctx.shadowMapInfo) {
            for (const k of ctx.shadowMapInfo.keys()){
                const shadowMapParams = ctx.shadowMapInfo.get(k);
                TemporalCache.releaseFramebuffer(shadowMapParams.shadowMapFramebuffer);
                shadowMapParams.impl.releaseTemporalResources(shadowMapParams);
                shadowMapParams.lightType = LIGHT_TYPE_NONE;
                shadowMapParams.depthClampEnabled = false;
                shadowMapParams.shaderHash = '';
                shadowMapParams.numShadowCascades = 1;
                shadowMapParams.shadowMapFramebuffer = null;
                shadowMapParams.impl = null;
                shadowMapParams.shadowMap = null;
                shadowMapParams.shadowMapSampler = null;
                shadowMapParams.implData = null;
                this._shadowMapParams.push(shadowMapParams);
            }
            ctx.shadowMapInfo = null;
        }
    }
    /** @internal */ static computeShadowBias(shadowMapParams, scope, z, NdotL, linear) {
        const pb = scope.$builder;
        const depthBiasParam = ShaderHelper.getDepthBiasValues(scope);
        if (shadowMapParams.lightType === LIGHT_TYPE_DIRECTIONAL) {
            return pb.dot(pb.mul(depthBiasParam.xy, pb.vec2(1, pb.sub(1, NdotL))), pb.vec2(1, 1));
        } else {
            const nearFar = ShaderHelper.getShadowCameraParams(scope).xy;
            const linearDepth = linear ? z : ShaderHelper.nonLinearDepthToLinearNormalized(scope, z, nearFar);
            const biasScaleFactor = pb.mix(1, depthBiasParam.w, linearDepth);
            return pb.dot(pb.mul(depthBiasParam.xy, pb.vec2(1, pb.sub(1, NdotL)), biasScaleFactor), pb.vec2(1, 1));
        }
    }
    /** @internal */ static computeShadowBiasCSM(shadowMapParams, scope, NdotL, split) {
        const pb = scope.$builder;
        const depthBiasParam = ShaderHelper.getDepthBiasValues(scope);
        const splitFlags = pb.vec4(pb.float(pb.equal(split, 0)), pb.float(pb.equal(split, 1)), pb.float(pb.equal(split, 2)), pb.float(pb.equal(split, 3)));
        const depthBiasScale = pb.dot(ShaderHelper.getDepthBiasScales(scope), splitFlags);
        return pb.dot(pb.mul(depthBiasParam.xy, pb.vec2(1, pb.sub(1, NdotL)), depthBiasScale), pb.vec2(1, 1));
    }
    /** @internal */ isTextureInvalid(texture, target, format, width, height) {
        return texture && (texture.target !== target || texture.format !== format || texture.width !== width || texture.height !== height || texture.depth !== this.numShadowCascades);
    }
    /** @internal */ createTexture(target, format, width, height, depth) {
        const device = Application.instance.device;
        const options = {
            samplerOptions: {
                mipFilter: 'none'
            }
        };
        switch(target){
            case '2d':
                return device.createTexture2D(format, width, height, options);
            case 'cube':
                return device.createCubeTexture(format, width, options);
            case '2darray':
                return device.createTexture2DArray(format, width, height, depth, options);
            default:
                return null;
        }
    }
    /** @internal */ updateResources(shadowMapParams) {
        const device = Application.instance.device;
        const colorFormat = shadowMapParams.impl.getShadowMapColorFormat(shadowMapParams);
        const depthFormat = shadowMapParams.impl.getShadowMapDepthFormat(shadowMapParams);
        const numCascades = shadowMapParams.numShadowCascades;
        const useTextureArray = numCascades > 1 && device.type !== 'webgl';
        const shadowMapWidth = numCascades > 1 && !useTextureArray ? 2 * this._config.shadowMapSize : this._config.shadowMapSize;
        const shadowMapHeight = numCascades > 2 && !useTextureArray ? 2 * this._config.shadowMapSize : this._config.shadowMapSize;
        const colorTarget = useTextureArray ? '2darray' : this._light.isPointLight() ? 'cube' : '2d';
        const depthTarget = device.type === 'webgl' ? '2d' : colorTarget;
        shadowMapParams.shadowMapFramebuffer = TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, numCascades, colorFormat, depthFormat, colorTarget, depthTarget, false, 1);
        shadowMapParams.impl = this._impl;
        this._impl.updateResources(shadowMapParams);
    }
    /** @internal */ createLightCameraPoint(lightCamera) {
        //lightCamera.reparent(this._light);
        lightCamera.reparent(lightCamera.scene.rootNode);
        lightCamera.resetTransform();
        lightCamera.setPerspective(Math.PI / 2, 1, this._config.nearClip, Math.min(this._shadowDistance, this._light.range));
        lightCamera.position.set(this._light.positionAndRange.xyz());
    }
    /** @internal */ createLightCameraSpot(lightCamera) {
        lightCamera.reparent(this._light);
        lightCamera.resetTransform();
        lightCamera.setPerspective(2 * this._light.cutoff, 1, this._config.nearClip, Math.min((this._shadowDistance, this._light).range));
    }
    /** @internal */ createLightCameraDirectional(sceneAABB, sceneCamera, lightCamera, cropMatrix, border) {
        let frustum = sceneCamera.frustumViewSpace;
        if (this._shadowDistance < sceneCamera.getFarPlane()) {
            tmpMatrix.set(sceneCamera.getProjectionMatrix());
            tmpMatrix.setNearFar(tmpMatrix.getNearPlane(), this._shadowDistance);
            //tmpMatrix.multiplyRight(sceneCamera.viewMatrix);
            tmpFrustum.initWithMatrix(tmpMatrix);
            frustum = tmpFrustum;
        }
        border = border || 0;
        const expand = (this.shadowMapSize - 2 * border) / this.shadowMapSize;
        //const frustum = sceneCamera.frustum;
        const frustumMin = ShadowMapper._frustumMin;
        const frustumMax = ShadowMapper._frustumMax;
        const frustumCenter = ShadowMapper._frustumCenter;
        const target = ShadowMapper._target;
        const up = ShadowMapper._up;
        // const frustum = new Frustum(sceneCamera.viewProjectionMatrix);
        frustumMin.setXYZ(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        frustumMax.setXYZ(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        frustum.corners.forEach((p)=>{
            frustumMin.inplaceMin(p);
            frustumMax.inplaceMax(p);
        });
        let radius = Vector3.distance(frustumMin, frustumMax) * 0.5 * expand;
        const center = sceneCamera.thisToWorld(Vector3.add(frustumMin, frustumMax, frustumCenter).scaleBy(0.5), frustumCenter);
        // Bounding sphere of the shadow camera should not be larger than bounding sphere of the scene.
        const sceneRadius = sceneAABB.diagonalLength * 0.5 * expand;
        if (sceneRadius < radius) {
            radius = sceneRadius;
            Vector3.add(sceneAABB.minPoint, sceneAABB.maxPoint, center).scaleBy(0.5);
        }
        target.setXYZ(center.x + this._light.directionAndCutoff.x, center.y + this._light.directionAndCutoff.y, center.z + this._light.directionAndCutoff.z);
        up.setXYZ(0, 1, 0);
        lightCamera.lookAt(center, target, up);
        lightCamera.position.set(center);
        lightCamera.setOrtho(-radius, radius, -radius, radius, -radius, radius);
        center.setXYZ(0, 0, 0);
        lightCamera.viewProjectionMatrix.transformPointP(center, center);
        if (cropMatrix) {
            const tx = center.x * this.shadowMapSize * 0.5;
            const ty = center.y * this.shadowMapSize * 0.5;
            const rx = Math.round(tx);
            const ry = Math.round(ty);
            center.setXYZ((rx - tx) * 2 / this.shadowMapSize, (ry - ty) * 2 / this.shadowMapSize, 0);
            cropMatrix.translation(center);
        }
    /*
    const minx = frustumMin.x;
    const maxx = frustumMax.x;
    const miny = frustumMin.y;
    const maxy = frustumMax.y;
    const minz = frustumMin.z;
    const maxz = frustumMax.z;
    const texelSizeW = (maxx - minx) / this.shadowMapSize;
    const texelSizeH = (maxy - miny) / this.shadowMapSize;
    const cx = Math.floor((minx + maxx) / 2 / texelSizeW) * texelSizeW;
    const cy = Math.floor((miny + maxy) / 2 / texelSizeH) * texelSizeH;
    const cz = (minz + maxz) / 2;
    const hx = Math.floor(((maxx - minx) * (expand + 0.5)) / texelSizeW) * texelSizeW;
    const hy = Math.floor(((maxy - miny) * (expand + 0.5)) / texelSizeH) * texelSizeH;
    lightCamera.position.setXYZ(cx, cy, cz);
    lightCamera.setOrtho(
      -hx,
      hx,
      -hy,
      hy,
      sceneMax.z - maxz,
      sceneMax.z - minz + 1
    );
    if (cropMatrix) {
      // compute crop matrix
      let clipMaxX = 0,
        clipMaxY = 0;
      let clipMinX = Number.MAX_VALUE,
        clipMinY = Number.MAX_VALUE;
      frustum.corners.forEach((p) => {
        const clipPos = lightCamera.viewProjectionMatrix.transformPoint(p);
        clipPos.x = Math.min(1, Math.max(-1, clipPos.x / clipPos.w));
        clipPos.y = Math.min(1, Math.max(-1, clipPos.y / clipPos.w));
        if (clipPos.x > clipMaxX) {
          clipMaxX = clipPos.x;
        }
        if (clipPos.x < clipMinX) {
          clipMinX = clipPos.x;
        }
        if (clipPos.y > clipMaxY) {
          clipMaxY = clipPos.y;
        }
        if (clipPos.y < clipMinY) {
          clipMinY = clipPos.y;
        }
      });
      const clipW = clipMaxX - clipMinX;
      const clipH = clipMaxY - clipMinY;
      clipMinX -= expand * clipW;
      clipMinY -= expand * clipH;
      clipMaxX += expand * clipW;
      clipMaxY += expand * clipH;
      const scaleX = 2 / (clipMaxX - clipMinX);
      const scaleY = 2 / (clipMaxY - clipMinY);
      const offsetX = -0.5 * (clipMaxX + clipMinX) * scaleX;
      const offsetY = -0.5 * (clipMaxY + clipMinY) * scaleY;
      cropMatrix.identity();
      cropMatrix.m00 = scaleX;
      cropMatrix.m11 = scaleY;
      cropMatrix.m03 = offsetX;
      cropMatrix.m13 = offsetY;
    }
    */ }
    /** @internal */ static fetchShadowMapParams() {
        if (this._shadowMapParams.length > 0) {
            return this._shadowMapParams.pop();
        } else {
            return {
                lightType: LIGHT_TYPE_NONE,
                depthClampEnabled: false,
                shaderHash: '',
                cameraParams: new Vector4(),
                cascadeDistances: new Vector4(),
                depthBiasScales: new Vector4(),
                depthBiasValues: [
                    new Vector4(),
                    new Vector4(),
                    new Vector4(),
                    new Vector4()
                ],
                numShadowCascades: 1,
                shadowMatrices: new Float32Array(16 * 4),
                shadowMap: null,
                shadowMapSampler: null,
                shadowMapFramebuffer: null,
                impl: null,
                implData: null
            };
        }
    }
    /** @internal */ static fetchCameraForScene(scene) {
        const cameras = this._lightCameras.get(scene);
        if (!cameras || cameras.length === 0) {
            return new Camera(scene);
        } else {
            const camera = cameras.pop();
            camera.parent = scene.rootNode;
            camera.resetTransform();
            camera.clipMask = 0;
            return camera;
        }
    }
    /** @internal */ static releaseCamera(camera) {
        let cameras = this._lightCameras.get(camera.scene);
        if (!cameras) {
            cameras = [];
            this._lightCameras.set(camera.scene, cameras);
        }
        camera.remove();
        cameras.push(camera);
    }
    /** @internal */ calcSplitDistances(nearPlane, farPlane, numCascades) {
        const result = [
            0,
            0,
            0,
            0,
            0
        ];
        for(let i = 0; i <= numCascades; ++i){
            const fIDM = i / numCascades;
            const fLog = nearPlane * Math.pow(farPlane / nearPlane, fIDM);
            const fUniform = nearPlane + (farPlane - nearPlane) * fIDM;
            result[i] = fLog * this._config.splitLambda + fUniform * (1 - this._config.splitLambda);
        }
        return result;
    }
    /** @internal */ calcDepthBiasParams(shadowMapCamera, shadowMapSize, depthBias, normalBias, depthScale, result) {
        const sizeNear = Math.min(shadowMapCamera.getProjectionMatrix().getNearPlaneWidth(), shadowMapCamera.getProjectionMatrix().getNearPlaneHeight());
        const sizeFar = Math.min(shadowMapCamera.getProjectionMatrix().getFarPlaneWidth(), shadowMapCamera.getProjectionMatrix().getFarPlaneHeight());
        const scaleFactor = sizeNear / shadowMapSize / 2;
        result.setXYZW(depthBias * scaleFactor, normalBias * scaleFactor, depthScale, sizeFar / sizeNear);
    }
    /** @internal */ postRenderShadowMap(shadowMapParams) {
        this._impl.postRenderShadowMap(shadowMapParams);
    }
    /** @internal */ render(ctx, renderPass) {
        if (!ctx.shadowMapInfo) {
            ctx.shadowMapInfo = new Map();
        }
        const shadowMapParams = ShadowMapper.fetchShadowMapParams();
        shadowMapParams.impl = this._impl;
        shadowMapParams.lightType = this.light.lightType;
        shadowMapParams.numShadowCascades = shadowMapParams.lightType === LIGHT_TYPE_DIRECTIONAL ? this._config.numCascades : 1;
        ctx.shadowMapInfo.set(this.light, shadowMapParams);
        const scene = ctx.scene;
        const camera = ctx.camera;
        renderPass.light = this._light;
        this.updateResources(shadowMapParams);
        shadowMapParams.shaderHash = this.getShaderHash(shadowMapParams);
        const device = Application.instance.device;
        const fb = shadowMapParams.shadowMapFramebuffer;
        shadowMapParams.depthClampEnabled = false;
        renderPass.clearColor = fb.getColorAttachments()[0] ? fb.getColorAttachments()[0].isFloatFormat() ? new Vector4(1, 1, 1, 1) : new Vector4(0, 0, 0, 1) : null;
        const depthScale = this._impl.getDepthScale();
        if (this._light.isPointLight()) {
            const shadowMapRenderCamera = ShadowMapper.fetchCameraForScene(scene);
            this.createLightCameraPoint(shadowMapRenderCamera);
            this.calcDepthBiasParams(shadowMapRenderCamera, this._config.shadowMapSize, this._config.depthBias, this._config.normalBias, depthScale, shadowMapParams.depthBiasValues[0]);
            shadowMapParams.cameraParams.setXYZW(shadowMapRenderCamera.getNearPlane(), shadowMapRenderCamera.getFarPlane(), this._config.shadowMapSize, this._shadowDistance);
            device.setFramebuffer(fb);
            shadowMapParams.shadowMatrices.set(Matrix4x4.transpose(shadowMapRenderCamera.viewMatrix));
            for (const face of [
                CubeFace.PX,
                CubeFace.NX,
                CubeFace.PY,
                CubeFace.NY,
                CubeFace.PZ,
                CubeFace.NZ
            ]){
                shadowMapRenderCamera.lookAtCubeFace(face);
                fb.setColorAttachmentCubeFace(0, face);
                fb.setDepthAttachmentCubeFace(face);
                ctx.camera = shadowMapRenderCamera;
                renderPass.render(ctx);
            }
            shadowMapParams.shadowMatrices.set(Matrix4x4.identity());
            ShadowMapper.releaseCamera(shadowMapRenderCamera);
        } else {
            if (this._config.numCascades > 1) {
                const distances = this.calcSplitDistances(camera.getNearPlane(), Math.min(this._shadowDistance, camera.getFarPlane()), this._config.numCascades);
                const cascadeCamera = ShadowMapper.fetchCameraForScene(scene);
                const shadowMapRenderCamera = ShadowMapper.fetchCameraForScene(scene);
                const shadowMapCullCamera = ShadowMapper.fetchCameraForScene(scene);
                shadowMapCullCamera.clipMask = AABB.ClipLeft | AABB.ClipRight | AABB.ClipBottom | AABB.ClipTop;
                cascadeCamera.reparent(camera);
                shadowMapParams.depthClampEnabled = Application.instance.device.getDeviceCaps().shaderCaps.supportFragmentDepth;
                for(let split = 0; split < this._config.numCascades; split++){
                    cascadeCamera.setPerspective(camera.getFOV(), camera.getAspect(), distances[split], distances[split + 1]);
                    const snapMatrix = ShadowMapper._snapMatrix;
                    const border = shadowMapParams.impl.getShadowMapBorder(shadowMapParams); //20 / this._config.shadowMapSize;
                    this.createLightCameraDirectional(ctx.scene.boundingBox, cascadeCamera, shadowMapRenderCamera, snapMatrix, border);
                    this.createLightCameraDirectional(ctx.scene.boundingBox, cascadeCamera, shadowMapCullCamera, null, border);
                    this.calcDepthBiasParams(shadowMapRenderCamera, this._config.shadowMapSize, this._config.depthBias, this._config.normalBias, depthScale, shadowMapParams.depthBiasValues[split]);
                    shadowMapParams.depthBiasScales[split] = 1;
                    // Incorrect calculation
                    // shadowMapParams.depthBiasScales[split] = shadowMapParams.depthBiasValues[0].x !== 0 ? shadowMapParams.depthBiasValues[split].x / shadowMapParams.depthBiasValues[0].x : 1;
                    shadowMapParams.cameraParams.setXYZW(shadowMapRenderCamera.getNearPlane(), shadowMapRenderCamera.getFarPlane(), this._config.shadowMapSize, this._shadowDistance);
                    let scissor = null;
                    if (fb.getColorAttachments()[0]?.isTexture2DArray() || fb.getDepthAttachment()?.isTexture2DArray()) {
                        shadowMapRenderCamera.setProjectionMatrix(Matrix4x4.multiply(snapMatrix, shadowMapRenderCamera.getProjectionMatrix()));
                        fb.setColorAttachmentLayer(0, split);
                        fb.setDepthAttachmentLayer(split);
                    } else {
                        const numRows = this._config.numCascades > 2 ? 2 : 1;
                        const numCols = this._config.numCascades > 1 ? 2 : 1;
                        const adjMatrix = new Matrix4x4();
                        const col = split % 2;
                        const row = split >> 1;
                        adjMatrix.setRowXYZW(0, 1.5 - 0.5 * numCols, 0, 0, 0);
                        adjMatrix.setRowXYZW(1, 0, 1.5 - 0.5 * numRows, 0, 0);
                        adjMatrix.setRowXYZW(2, 0, 0, 1, 0);
                        adjMatrix.setRowXYZW(3, col - 0.5 * numCols + 0.5, row - 0.5 * numRows + 0.5, 0, 1);
                        shadowMapRenderCamera.setProjectionMatrix(Matrix4x4.multiply(adjMatrix, Matrix4x4.multiply(snapMatrix, shadowMapRenderCamera.getProjectionMatrix())));
                        if (device.type === 'webgpu') {
                            scissor = [
                                col * this._config.shadowMapSize,
                                (numRows - 1 - row) * this._config.shadowMapSize,
                                this._config.shadowMapSize,
                                this._config.shadowMapSize
                            ];
                        } else {
                            scissor = [
                                col * this._config.shadowMapSize,
                                row * this._config.shadowMapSize,
                                this._config.shadowMapSize,
                                this._config.shadowMapSize
                            ];
                        }
                    }
                    device.setFramebuffer(fb);
                    device.setScissor(scissor);
                    ctx.camera = shadowMapRenderCamera;
                    renderPass.render(ctx, shadowMapCullCamera);
                    shadowMapParams.shadowMatrices.set(Matrix4x4.transpose(shadowMapRenderCamera.viewProjectionMatrix), split * 16);
                    shadowMapParams.cascadeDistances[split] = distances[split + 1];
                }
                ShadowMapper.releaseCamera(cascadeCamera);
                ShadowMapper.releaseCamera(shadowMapRenderCamera);
                ShadowMapper.releaseCamera(shadowMapCullCamera);
            } else {
                const shadowMapRenderCamera = ShadowMapper.fetchCameraForScene(scene);
                const snapMatrix = ShadowMapper._snapMatrix;
                shadowMapRenderCamera.clipMask = AABB.ClipLeft | AABB.ClipRight | AABB.ClipBottom | AABB.ClipTop;
                if (this._light.isDirectionLight()) {
                    this.createLightCameraDirectional(ctx.scene.boundingBox, camera, shadowMapRenderCamera, snapMatrix, shadowMapParams.impl.getShadowMapBorder(shadowMapParams));
                } else {
                    this.createLightCameraSpot(shadowMapRenderCamera);
                }
                this.calcDepthBiasParams(shadowMapRenderCamera, this._config.shadowMapSize, this._config.depthBias, this._config.normalBias, depthScale, shadowMapParams.depthBiasValues[0]);
                shadowMapParams.cameraParams.setXYZW(shadowMapRenderCamera.getNearPlane(), shadowMapRenderCamera.getFarPlane(), this._config.shadowMapSize, this._shadowDistance);
                device.setFramebuffer(fb);
                shadowMapRenderCamera.setProjectionMatrix(Matrix4x4.multiply(snapMatrix, shadowMapRenderCamera.getProjectionMatrix()));
                ctx.camera = shadowMapRenderCamera;
                renderPass.render(ctx);
                shadowMapParams.shadowMatrices.set(Matrix4x4.transpose(shadowMapRenderCamera.viewProjectionMatrix));
                ShadowMapper.releaseCamera(shadowMapRenderCamera);
            }
        }
        ctx.camera = camera;
        this.postRenderShadowMap(shadowMapParams);
    }
    /** @internal */ applyMode(mode) {
        if (mode !== 'hard' && mode !== 'vsm' && mode !== 'esm' && mode !== 'pcf-pd' && mode !== 'pcf-opt') {
            console.error(`ShadowMapper.setShadowMode() failed: invalid mode: ${mode}`);
            return;
        }
        this._impl = null;
        if (mode === 'hard') {
            this._impl = new SSM();
        } else if (mode === 'vsm') {
            this._impl = new VSM(this._vsmBlurKernelSize, this._vsmBlurRadius, this._vsmDarkness);
        } else if (mode === 'esm') {
            this._impl = new ESM(this._esmBlurKernelSize, this._esmBlurRadius, this._esmDepthScale);
        } else if (mode === 'pcf-pd') {
            this._impl = new PCFPD(this._pdSampleCount, this._pdSampleRadius);
        } else if (mode === 'pcf-opt') {
            this._impl = new PCFOPT(this._pcfKernelSize);
        }
    }
    /** @internal */ asVSM() {
        return this._impl?.getType() === 'vsm' ? this._impl : null;
    }
    /** @internal */ asESM() {
        return this._impl?.getType() === 'esm' ? this._impl : null;
    }
    /** @internal */ asPCFPD() {
        return this._impl?.getType() === 'pcf-pd' ? this._impl : null;
    }
    /** @internal */ asPCFOPT() {
        return this._impl?.getType() === 'pcf-opt' ? this._impl : null;
    }
}

class ClusteredLight {
    _tileCountX;
    _tileCountY;
    _tileCountZ;
    _lights;
    _lightIndexTexture;
    _lightIndexFramebuffer;
    _lightIndexProgram;
    _bindGroup;
    _lightIndexVertexLayout;
    _lightIndexRenderStates;
    _lightBuffer;
    _sizeParam;
    _countParam;
    _clusterParam;
    constructor(){
        this._tileCountX = 16;
        this._tileCountY = 16;
        this._tileCountZ = 32;
        this._lights = new Float32Array(12 * (MAX_CLUSTERED_LIGHTS + 1));
        this._lightIndexTexture = null;
        this._lightIndexFramebuffer = null;
        this._lightIndexProgram = null;
        this._lightBuffer = null;
        this._bindGroup = null;
        this._lightIndexVertexLayout = null;
        this._lightIndexRenderStates = null;
        this._sizeParam = new Vector4();
        this._countParam = new Int32Array(4);
        this._clusterParam = new Vector4();
    }
    get lightBuffer() {
        return this._lightBuffer;
    }
    get clusterParam() {
        return this._clusterParam;
    }
    get countParam() {
        return this._countParam;
    }
    get lightIndexTexture() {
        return this._lightIndexTexture;
    }
    createVertexLayout(device, textureWidth, textureHeight) {
        let vb;
        if (device.type === 'webgl') {
            const vertices = new Float32Array(this._tileCountX * this._tileCountY * this._tileCountZ * 3);
            for(let i = 0; i < vertices.length; i++){
                const ix = i % textureWidth;
                const iy = Math.floor(i / textureWidth);
                vertices[i * 3 + 0] = 2 * (ix + 0.5) / textureWidth - 1;
                vertices[i * 3 + 1] = 2 * (iy + 0.5) / textureHeight - 1;
                vertices[i * 3 + 2] = i;
            }
            vb = device.createVertexBuffer('position_f32x3', vertices);
        } else {
            const vertices = new Float32Array(this._tileCountX * this._tileCountY * this._tileCountZ * 2);
            for(let i = 0; i < vertices.length; i++){
                const ix = i % textureWidth;
                const iy = Math.floor(i / textureWidth);
                vertices[i * 2 + 0] = 2 * (ix + 0.5) / textureWidth - 1;
                vertices[i * 2 + 1] = 2 * (iy + 0.5) / textureHeight - 1;
            }
            vb = device.createVertexBuffer('position_f32x2', vertices);
        }
        this._lightIndexVertexLayout = device.createVertexLayout({
            vertexBuffers: [
                {
                    buffer: vb
                }
            ]
        });
    }
    createRenderState(device) {
        this._lightIndexRenderStates = device.createRenderStateSet();
        this._lightIndexRenderStates.useDepthState().enableTest(false).enableWrite(false);
        this._lightIndexRenderStates.useRasterizerState().setCullMode('none');
    }
    createProgram(device) {
        const webgl1 = device.type === 'webgl';
        this._lightIndexProgram = device.buildRenderProgram({
            vertex (pb) {
                this.$inputs.pos = (webgl1 ? pb.vec3() : pb.vec2()).attrib('position');
                this.$outputs.value = webgl1 ? pb.vec4() : pb.uvec4();
                this.invProjMatrix = pb.mat4().uniform(0);
                this.viewMatrix = pb.mat4().uniform(0);
                this.sizeParam = pb.vec4().uniform(0);
                this.countParam = pb.ivec4().uniform(0);
                this[ShaderHelper.getLightBufferUniformName()] = pb.vec4[(MAX_CLUSTERED_LIGHTS + 1) * 3]().uniformBuffer(0);
                pb.func('lineIntersectionToZPlane', [
                    pb.vec3('a'),
                    pb.vec3('b'),
                    pb.float('zDistance')
                ], function() {
                    this.$l.normal = pb.vec3(0, 0, 1);
                    this.$l.ab = pb.sub(this.b, this.a);
                    this.$l.t = pb.div(pb.sub(this.zDistance, pb.dot(this.normal, this.a)), pb.dot(this.normal, this.ab));
                    this.$return(pb.add(this.a, pb.mul(this.t, this.ab)));
                });
                pb.func('clipToView', [
                    pb.vec4('clip')
                ], function() {
                    this.$l.view = pb.mul(this.invProjMatrix, this.clip);
                    this.$return(pb.div(this.view, this.view.w));
                });
                pb.func('screenToView', [
                    pb.vec4('screen')
                ], function() {
                    this.$l.texCoord = pb.div(this.screen.xy, this.sizeParam.xy);
                    this.$l.clip = pb.vec4(pb.sub(pb.mul(pb.vec2(this.texCoord.x, pb.sub(1, this.texCoord.y)), 2), pb.vec2(1)), this.screen.z, this.screen.w);
                    this.$return(this.clipToView(this.clip));
                });
                pb.func('sphereIntersectsAABB', [
                    pb.vec4('sphere'),
                    pb.vec3('aabbMin'),
                    pb.vec3('aabbMax')
                ], function() {
                    this.$l.dmin = pb.float(0);
                    this.$if(pb.lessThanEqual(this.sphere.w, 0), function() {
                        this.$return(true);
                    });
                    this.$for(pb.int('i'), 0, 3, function() {
                        this.$if(pb.lessThan(this.sphere.at(this.i), this.aabbMin.at(this.i)), function() {
                            this.$l.delta = pb.sub(this.sphere.at(this.i), this.aabbMin.at(this.i));
                            this.dmin = pb.add(this.dmin, pb.mul(this.delta, this.delta));
                        }).$elseif(pb.greaterThan(this.sphere.at(this.i), this.aabbMax.at(this.i)), function() {
                            this.$l.delta = pb.sub(this.sphere.at(this.i), this.aabbMax.at(this.i));
                            this.dmin = pb.add(this.dmin, pb.mul(this.delta, this.delta));
                        });
                    });
                    this.$if(pb.lessThanEqual(this.dmin, pb.mul(this.sphere.w, this.sphere.w)), function() {
                        this.$return(true);
                    });
                    this.$return(false);
                });
                pb.main(function() {
                    if (pb.getDevice().type !== 'webgpu') {
                        this.$builtins.pointSize = 1;
                    }
                    this.$builtins.position = pb.vec4(this.$inputs.pos.xy, 0, 1);
                    if (pb.getDevice().type === 'webgpu') {
                        this.$builtins.position = pb.mul(this.$builtins.position, pb.vec4(1, -1, 1, 1));
                    }
                    this.$l.tileIndex = webgl1 ? pb.int(this.$inputs.pos.z) : pb.int(this.$builtins.vertexIndex);
                    this.$l.tileSize = pb.div(this.sizeParam.xy, pb.vec2(this.countParam.xy));
                    this.$l.zIndex = pb.div(this.tileIndex, pb.mul(this.countParam.x, this.countParam.y));
                    this.$l.yIndex = pb.div(pb.sub(this.tileIndex, pb.mul(this.zIndex, this.countParam.x, this.countParam.y)), this.countParam.x);
                    this.$l.xIndex = pb.sub(this.tileIndex, pb.add(pb.mul(this.zIndex, this.countParam.x, this.countParam.y), pb.mul(this.yIndex, this.countParam.x)));
                    this.$l.maxPoint_sS = pb.vec4(pb.mul(pb.vec2(pb.float(pb.add(this.xIndex, 1)), pb.float(pb.add(this.yIndex, 1))), this.tileSize), 0.0, 1.0);
                    this.$l.minPoint_sS = pb.vec4(pb.mul(pb.vec2(pb.float(this.xIndex), pb.float(this.yIndex)), this.tileSize), 0.0, 1.0);
                    this.$l.maxPoint_vS = this.screenToView(this.maxPoint_sS).xyz;
                    this.$l.minPoint_vS = this.screenToView(this.minPoint_sS).xyz;
                    this.$l.tileNear = pb.mul(pb.neg(this.sizeParam.z), pb.pow(pb.div(this.sizeParam.w, this.sizeParam.z), pb.div(pb.float(this.zIndex), pb.float(this.countParam.z))));
                    this.$l.tileFar = pb.mul(pb.neg(this.sizeParam.z), pb.pow(pb.div(this.sizeParam.w, this.sizeParam.z), pb.div(pb.add(pb.float(this.zIndex), 1), pb.float(this.countParam.z))));
                    this.$l.eyePos = pb.vec3(0);
                    this.$l.minPointNear = this.lineIntersectionToZPlane(this.eyePos, this.minPoint_vS, this.tileNear);
                    this.$l.minPointFar = this.lineIntersectionToZPlane(this.eyePos, this.minPoint_vS, this.tileFar);
                    this.$l.maxPointNear = this.lineIntersectionToZPlane(this.eyePos, this.maxPoint_vS, this.tileNear);
                    this.$l.maxPointFar = this.lineIntersectionToZPlane(this.eyePos, this.maxPoint_vS, this.tileFar);
                    this.$l.aabbMin = pb.min(pb.min(this.minPointNear, this.minPointFar), pb.min(this.maxPointNear, this.maxPointFar));
                    this.$l.aabbMax = pb.max(pb.max(this.minPointNear, this.minPointFar), pb.max(this.maxPointNear, this.maxPointFar));
                    this.$l.n = pb.int(0);
                    if (webgl1) {
                        this.$l.lightIndices = pb.float[8]();
                        this.$for(pb.int('i'), 0, 8, function() {
                            this.lightIndices.setAt(this.i, 0);
                        });
                        this.$for(pb.int('i'), 1, 256, function() {
                            this.$if(pb.equal(this.i, this.countParam.w), function() {
                                this.$break();
                            });
                            this.$l.light = this[ShaderHelper.getLightBufferUniformName()].at(pb.mul(this.i, 3));
                            this.$l.lightPos = pb.mul(this.viewMatrix, pb.vec4(this.light.xyz, 1));
                            this.$l.lightPos.w = this.light.w;
                            this.$if(this.sphereIntersectsAABB(this.lightPos, this.aabbMin, this.aabbMax), function() {
                                this.$for(pb.int('j'), 0, 8, function() {
                                    this.$if(pb.equal(this.j, this.n), function() {
                                        this.lightIndices.setAt(this.j, pb.float(this.i));
                                        this.n = pb.add(this.n, 1);
                                        this.$break();
                                    });
                                });
                                this.$if(pb.equal(this.n, 8), function() {
                                    this.$break();
                                });
                            });
                        });
                        this.$outputs.value.r = pb.add(pb.mul(this.lightIndices[0], 256), this.lightIndices[1]);
                        this.$outputs.value.g = pb.add(pb.mul(this.lightIndices[2], 256), this.lightIndices[3]);
                        this.$outputs.value.b = pb.add(pb.mul(this.lightIndices[4], 256), this.lightIndices[5]);
                        this.$outputs.value.a = pb.add(pb.mul(this.lightIndices[6], 256), this.lightIndices[7]);
                    } else {
                        this.$l.lightIndex = [
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0)
                        ];
                        this.$for(pb.uint('i'), 1, pb.uint(this.countParam.w), function() {
                            this.$l.light = this[ShaderHelper.getLightBufferUniformName()].at(pb.mul(this.i, 3));
                            this.$l.lightPos = pb.mul(this.viewMatrix, pb.vec4(this.light.xyz, 1));
                            this.$l.lightPos.w = this.light.w;
                            this.$if(this.sphereIntersectsAABB(this.lightPos, this.aabbMin, this.aabbMax), function() {
                                this.lightIndex.setAt(this.n, this.i);
                                this.n = pb.add(this.n, 1);
                                this.$if(pb.equal(this.n, 16), function() {
                                    this.$break();
                                });
                            });
                        });
                        this.$l.r = pb.add(pb.sal(this.lightIndex[0], 24), pb.sal(this.lightIndex[1], 16), pb.sal(this.lightIndex[2], 8), this.lightIndex[3]);
                        this.$l.g = pb.add(pb.sal(this.lightIndex[4], 24), pb.sal(this.lightIndex[5], 16), pb.sal(this.lightIndex[6], 8), this.lightIndex[7]);
                        this.$l.b = pb.add(pb.sal(this.lightIndex[8], 24), pb.sal(this.lightIndex[9], 16), pb.sal(this.lightIndex[10], 8), this.lightIndex[11]);
                        this.$l.a = pb.add(pb.sal(this.lightIndex[12], 24), pb.sal(this.lightIndex[13], 16), pb.sal(this.lightIndex[14], 8), this.lightIndex[15]);
                        this.$outputs.value = pb.uvec4(this.r, this.g, this.b, this.a);
                    }
                });
            },
            fragment (pb) {
                this.$outputs.color = webgl1 ? pb.vec4() : pb.uvec4();
                pb.main(function() {
                    this.$outputs.color = this.$inputs.value;
                });
            }
        });
        this._bindGroup = device.createBindGroup(this._lightIndexProgram.bindGroupLayouts[0]);
        this._lightBuffer?.dispose();
        const lightBufferType = this._lightIndexProgram.getBindingInfo(ShaderHelper.getLightBufferUniformName()).type;
        this._lightBuffer = device.createStructuredBuffer(lightBufferType, {
            usage: 'uniform'
        });
    }
    createLightIndexTexture(device) {
        const exp = Math.log2(this._tileCountX * this._tileCountY * this._tileCountZ);
        const a = exp + 1 >>> 1;
        const b = exp - a;
        const textureWidth = 2 << a - 1;
        const textureHeight = 2 << b - 1;
        if (textureWidth * textureHeight !== this._tileCountX * this._tileCountY * this._tileCountZ) {
            throw new Error('Internal error');
        }
        this._lightIndexTexture = device.createTexture2D(device.type === 'webgl' ? 'rgba32f' : 'rgba32ui', textureWidth, textureHeight, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        this._lightIndexTexture.name = 'ClusterLightIndex';
        this._lightIndexFramebuffer?.dispose();
        this._lightIndexFramebuffer = device.createFrameBuffer([
            this._lightIndexTexture
        ], null);
    }
    calculateLightIndex(camera, renderQueue) {
        const numLights = this.getVisibleLights(renderQueue, this._lights);
        const device = Application.instance.device;
        if (!this._lightIndexTexture) {
            this.createLightIndexTexture(device);
        }
        if (!this._lightIndexProgram) {
            this.createProgram(device);
        }
        if (!this._lightIndexVertexLayout) {
            this.createVertexLayout(device, this._lightIndexTexture.width, this._lightIndexTexture.height);
        }
        if (!this._lightIndexRenderStates) {
            this.createRenderState(device);
        }
        const viewport = device.getViewport();
        const vw = device.screenToDevice(viewport.width);
        const vh = device.screenToDevice(viewport.height);
        const scale = this._tileCountZ / Math.log2(camera.getFarPlane() / camera.getNearPlane());
        const bias = -(this._tileCountZ * Math.log2(camera.getNearPlane()) / Math.log2(camera.getFarPlane() / camera.getNearPlane()));
        this._clusterParam.setXYZW(vw, vh, scale, bias);
        device.pushDeviceStates();
        device.setFramebuffer(this._lightIndexFramebuffer);
        if (numLights > 0) {
            this._lightBuffer.bufferSubData(0, this._lights);
            this._sizeParam.setXYZW(vw, vh, camera.getNearPlane(), camera.getFarPlane());
            this._countParam[0] = this._tileCountX;
            this._countParam[1] = this._tileCountY;
            this._countParam[2] = this._tileCountZ;
            this._countParam[3] = numLights + 1;
            this._bindGroup.setValue('invProjMatrix', Matrix4x4.invert(camera.getProjectionMatrix()));
            this._bindGroup.setValue('viewMatrix', camera.viewMatrix);
            this._bindGroup.setValue('sizeParam', this._sizeParam);
            this._bindGroup.setValue('countParam', this._countParam);
            this._bindGroup.setBuffer(ShaderHelper.getLightBufferUniformName(), this._lightBuffer);
            device.setProgram(this._lightIndexProgram);
            device.setVertexLayout(this._lightIndexVertexLayout);
            device.setBindGroup(0, this._bindGroup);
            const savedRS = device.getRenderStates();
            device.setRenderStates(this._lightIndexRenderStates);
            device.draw('point-list', 0, this._tileCountX * this._tileCountY * this._tileCountZ);
            device.setRenderStates(savedRS);
        } else {
            device.clearFrameBuffer(new Vector4(0, 0, 0, 0), 1, 0);
        }
        device.popDeviceStates();
    }
    getVisibleLights(renderQueue, lights) {
        const numLights = Math.min(renderQueue.unshadowedLights.length, MAX_CLUSTERED_LIGHTS);
        for(let i = 1; i <= numLights; i++){
            const light = renderQueue.unshadowedLights[i - 1];
            lights.set(light.positionAndRange, i * 12);
            lights.set(light.directionAndCutoff, i * 12 + 4);
            lights.set(light.diffuseAndIntensity, i * 12 + 8);
        }
        return numLights;
    }
}

/**
 * Forward render scheme
 * @internal
 */ class SceneRenderer {
    /** @internal */ static _scenePass = new LightPass();
    /** @internal */ static _depthPass = new DepthPass();
    /** @internal */ static _shadowMapPass = new ShadowMapPass();
    /** @internal */ static _enableDepthPass = false;
    /** @internal */ static _clusters = [];
    /** @internal */ static setClearColor(color) {
        this._scenePass.clearColor = color;
    }
    /** @internal */ static getClusteredLight() {
        if (this._clusters.length > 0) {
            return this._clusters.pop();
        }
        return new ClusteredLight();
    }
    /** @internal */ static freeClusteredLight(clusteredLight) {
        this._clusters.push(clusteredLight);
    }
    /**
   * Renders a scene by given camera
   * @param scene - The scene to be rendered
   * @param camera - The camera that will be used to render the scene
   * @param compositor - The compositor that will be used to apply postprocess effects
   */ static renderScene(scene, camera, compositor, logger) {
        const device = Application.instance.device;
        const ctx = {
            scene,
            primaryCamera: camera,
            camera,
            compositor: compositor?.needDrawPostEffects() ? compositor : null,
            timestamp: device.frameInfo.frameTimestamp,
            logger,
            queue: 0,
            lightBlending: false,
            target: null,
            renderPass: null,
            renderPassHash: null,
            applyFog: false,
            flip: false,
            drawEnvLight: false,
            env: null
        };
        scene.frameUpdate();
        if (camera && !device.isContextLost()) {
            this._renderScene(ctx);
        }
    }
    /** @internal */ static _renderSceneDepth(ctx, renderQueue, depthFramebuffer) {
        const device = Application.instance.device;
        device.pushDeviceStates();
        device.setFramebuffer(depthFramebuffer);
        this._depthPass.clearColor = device.type === 'webgl' ? new Vector4(0, 0, 0, 1) : new Vector4(1, 1, 1, 1);
        this._depthPass.render(ctx, null, renderQueue);
        device.popDeviceStates();
    }
    /** @internal */ static _renderScene(ctx) {
        const device = Application.instance.device;
        const vp = ctx.camera.viewport;
        const scissor = ctx.camera.scissor;
        const finalFramebuffer = device.getFramebuffer();
        const drawingBufferWidth = device.getDrawingBufferWidth();
        const drawingBufferHeight = device.getDrawingBufferHeight();
        ctx.depthFormat = 'd24s8';
        ctx.viewportX = finalFramebuffer ? vp?.[0] ?? 0 : device.screenToDevice(vp?.[0] ?? 0);
        ctx.viewportY = finalFramebuffer ? vp?.[1] ?? 0 : device.screenToDevice(vp?.[1] ?? 0);
        ctx.viewportWidth = finalFramebuffer ? vp?.[2] ?? finalFramebuffer.getWidth() : vp ? device.screenToDevice(vp[2]) : device.getDrawingBufferWidth();
        ctx.viewportHeight = finalFramebuffer ? vp?.[3] ?? finalFramebuffer.getHeight() : vp ? device.screenToDevice(vp[3]) : device.getDrawingBufferHeight();
        ctx.defaultViewport = !finalFramebuffer && !vp;
        const oversizedViewport = vp && !device.getDeviceCaps().miscCaps.supportOversizedViewport && (ctx.viewportX < 0 || ctx.viewportY < 0 || ctx.viewportX + ctx.viewportWidth > drawingBufferWidth || ctx.viewportY + ctx.viewportHeight > drawingBufferHeight);
        // TODO: determin the color buffer format
        const colorFmt = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? 'rgba16f' : 'rgba8unorm';
        let tempFramebuffer = null;
        let depthFramebuffer = null;
        const renderQueue = this._scenePass.cullScene(ctx, ctx.camera);
        ctx.sunLight = renderQueue.sunLight;
        ctx.clusteredLight = this.getClusteredLight();
        ctx.clusteredLight.calculateLightIndex(ctx.camera, renderQueue);
        this.renderShadowMaps(ctx, renderQueue.shadowedLights);
        const sampleCount = ctx.compositor ? 1 : ctx.primaryCamera.sampleCount;
        if (this._enableDepthPass || oversizedViewport || ctx.scene.env.needSceneDepthTexture() || ctx.compositor?.requireLinearDepth()) {
            const format = device.type === 'webgl' ? 'rgba8unorm' : 'r32f';
            if (!finalFramebuffer && !vp) {
                depthFramebuffer = TemporalCache.getFramebufferVariantSize(drawingBufferWidth, drawingBufferHeight, 1, format, ctx.depthFormat, '2d', '2d', false);
            } else {
                const originDepth = finalFramebuffer?.getDepthAttachment();
                depthFramebuffer = originDepth?.isTexture2D() ? TemporalCache.getFramebufferFixedSizeWithDepth(originDepth, 1, format, '2d', false) : TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false);
            }
            this._renderSceneDepth(ctx, renderQueue, depthFramebuffer);
            ctx.linearDepthTexture = depthFramebuffer.getColorAttachments()[0];
            ctx.depthTexture = depthFramebuffer.getDepthAttachment();
            if (ctx.depthTexture === finalFramebuffer?.getDepthAttachment()) {
                tempFramebuffer = finalFramebuffer;
            } else {
                if (ctx.defaultViewport) {
                    tempFramebuffer = TemporalCache.getFramebufferVariantSize(ctx.depthTexture.width, ctx.depthTexture.height, 1, colorFmt, ctx.depthFormat, '2d', '2d', false, sampleCount);
                } else {
                    tempFramebuffer = TemporalCache.getFramebufferFixedSize(ctx.depthTexture.width, ctx.depthTexture.height, 1, colorFmt, ctx.depthFormat, '2d', '2d', false, sampleCount);
                }
            }
        } else {
            ctx.linearDepthTexture = null;
            ctx.depthTexture = null;
            if (!vp) {
                tempFramebuffer = finalFramebuffer;
            } else {
                tempFramebuffer = TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, colorFmt, ctx.depthFormat, '2d', '2d', false, sampleCount);
            }
        }
        if (tempFramebuffer && tempFramebuffer !== finalFramebuffer) {
            device.pushDeviceStates();
            device.setFramebuffer(tempFramebuffer);
        } else {
            device.setViewport(vp);
            device.setScissor(scissor);
        }
        this._scenePass.clearDepth = 1; //ctx.depthTexture ? null : 1;
        this._scenePass.clearStencil = 0; //ctx.depthTexture ? null : 0;
        ctx.compositor?.begin(ctx);
        this._scenePass.render(ctx, null, renderQueue);
        ctx.compositor?.end(ctx);
        if (tempFramebuffer && tempFramebuffer !== finalFramebuffer) {
            const blitter = new CopyBlitter();
            if (oversizedViewport) {
                blitter.destRect = [
                    ctx.viewportX,
                    ctx.viewportY,
                    ctx.viewportWidth,
                    ctx.viewportHeight
                ];
            } else {
                blitter.viewport = vp;
            }
            blitter.scissor = scissor;
            blitter.srgbOut = !finalFramebuffer;
            const srcTex = tempFramebuffer.getColorAttachments()[0];
            blitter.blit(srcTex, finalFramebuffer ?? null, device.createSampler({
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none'
            }));
            device.popDeviceStates();
        }
        if (depthFramebuffer) {
            TemporalCache.releaseFramebuffer(depthFramebuffer);
        }
        if (tempFramebuffer && tempFramebuffer !== finalFramebuffer) {
            TemporalCache.releaseFramebuffer(tempFramebuffer);
        }
        ShadowMapper.releaseTemporalResources(ctx);
        this.freeClusteredLight(ctx.clusteredLight);
    }
    /** @internal */ static renderShadowMaps(ctx, lights) {
        ctx.renderPass = this._shadowMapPass;
        Application.instance.device.pushDeviceStates();
        for (const light of lights){
            light.shadow.render(ctx, this._shadowMapPass);
        }
        Application.instance.device.popDeviceStates();
    }
}

/**
 * Base class for any kind of environment light
 * @public
 */ class EnvironmentLighting {
    /**
   * Whether this is an instance of EnvIBL
   * @returns true if this is an instance of EnvIBL
   */ isIBL() {
        return false;
    }
    /**
   * Whether this is an instance of EnvConstantAmbient
   * @returns true if this is an instance of EnvConstantAmbient
   */ isConstant() {
        return false;
    }
    /**
   * Whether this is an instance of EnvHemisphericAmbient
   * @returns true if this is an instance of EnvHemisphericAmbient
   */ isHemispheric() {
        return false;
    }
}
/**
 * IBL based environment lighting
 * @public
 */ class EnvIBL extends EnvironmentLighting {
    /** @internal */ static UNIFORM_NAME_IBL_RADIANCE_MAP = 'zIBLRadianceMap';
    /** @internal */ static UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD = 'zIBLRadianceMapMaxLOD';
    /** @internal */ static UNIFORM_NAME_IBL_IRRADIANCE_MAP = 'zIBLIrradianceMap';
    /** @internal */ _radianceMap;
    /** @internal */ _irradianceMap;
    /**
   * Creates an instance of EnvIBL
   * @param radianceMap - The radiance map
   * @param irradianceMap - The irradiance map
   */ constructor(radianceMap, irradianceMap){
        super();
        this._radianceMap = radianceMap || null;
        this._irradianceMap = irradianceMap || null;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getType}
   * @override
   */ getType() {
        return 'ibl';
    }
    /** The radiance map */ get radianceMap() {
        return this._radianceMap;
    }
    set radianceMap(tex) {
        this._radianceMap = tex;
    }
    /** The irradiance map */ get irradianceMap() {
        return this._irradianceMap;
    }
    set irradianceMap(tex) {
        this._irradianceMap = tex;
    }
    /**
   * {@inheritDoc EnvironmentLighting.initShaderBindings}
   * @override
   */ initShaderBindings(pb) {
        if (pb.shaderKind === 'fragment') {
            if (this._radianceMap) {
                pb.getGlobalScope()[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP] = pb.texCube().uniform(0);
                pb.getGlobalScope()[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD] = pb.float().uniform(0);
            }
            if (this._irradianceMap) {
                pb.getGlobalScope()[EnvIBL.UNIFORM_NAME_IBL_IRRADIANCE_MAP] = pb.texCube().uniform(0);
            }
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.updateBindGroup}
   * @override
   */ updateBindGroup(bg) {
        if (this._radianceMap) {
            bg.setValue(EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD, this._radianceMap.mipLevelCount - 1);
            bg.setTexture(EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP, this._radianceMap);
        }
        if (this._irradianceMap) {
            bg.setTexture(EnvIBL.UNIFORM_NAME_IBL_IRRADIANCE_MAP, this._irradianceMap);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.getRadiance}
   * @override
   */ getRadiance(scope, refl, roughness) {
        const pb = scope.$builder;
        return Application.instance.device.getDeviceCaps().shaderCaps.supportShaderTextureLod ? pb.textureSampleLevel(scope[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP], refl, pb.mul(roughness, scope[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD])).rgb : pb.textureSample(scope[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP], refl).rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getIrradiance}
   * @override
   */ getIrradiance(scope, normal) {
        const pb = scope.$builder;
        return pb.textureSampleLevel(scope[EnvIBL.UNIFORM_NAME_IBL_IRRADIANCE_MAP], normal, 0).rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasRadiance}
   * @override
   */ hasRadiance() {
        return !!this._radianceMap;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasIrradiance}
   * @override
   */ hasIrradiance() {
        return !!this._irradianceMap;
    }
    /**
   * {@inheritDoc EnvironmentLighting.isIBL}
   * @override
   */ isIBL() {
        return true;
    }
}
/**
 * Constant ambient light
 * @public
 */ class EnvConstantAmbient extends EnvironmentLighting {
    /** @internal */ static UNIFORM_NAME_CONSTANT_AMBIENT = 'zConstantAmbient';
    /** @internal */ _ambientColor;
    /**
   * Creates an instance of EnvConstantAmbient
   * @param ambientColor - The ambient color
   */ constructor(ambientColor){
        super();
        this._ambientColor = ambientColor ? new Vector4(ambientColor) : new Vector4(0, 0, 0, 1);
    }
    /** The ambient color */ get ambientColor() {
        return this._ambientColor;
    }
    set ambientColor(ambientColor) {
        if (ambientColor) {
            this._ambientColor.set(ambientColor);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.getType}
   * @override
   */ getType() {
        return 'constant';
    }
    /**
   * {@inheritDoc EnvironmentLighting.initShaderBindings}
   * @override
   */ initShaderBindings(pb) {
        if (pb.shaderKind === 'fragment') {
            pb.getGlobalScope()[EnvConstantAmbient.UNIFORM_NAME_CONSTANT_AMBIENT] = pb.vec4().uniform(0);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.updateBindGroup}
   * @override
   */ updateBindGroup(bg) {
        bg.setValue(EnvConstantAmbient.UNIFORM_NAME_CONSTANT_AMBIENT, this._ambientColor);
    }
    /**
   * {@inheritDoc EnvironmentLighting.getRadiance}
   * @override
   */ getRadiance(scope, refl, roughness) {
        return null;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getIrradiance}
   * @override
   */ getIrradiance(scope, normal) {
        return scope[EnvConstantAmbient.UNIFORM_NAME_CONSTANT_AMBIENT].rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasRadiance}
   * @override
   */ hasRadiance() {
        return false;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasIrradiance}
   * @override
   */ hasIrradiance() {
        return true;
    }
    /**
   * {@inheritDoc EnvironmentLighting.isConstant}
   * @override
   */ isConstant() {
        return true;
    }
}
/**
 * Hemispheric ambient light
 * @public
 */ class EnvHemisphericAmbient extends EnvironmentLighting {
    /** @internal */ static UNIFORM_NAME_AMBIENT_UP = 'zHemisphericAmbientUp';
    /** @internal */ static UNIFORM_NAME_AMBIENT_DOWN = 'zHemisphericAmbientDown';
    /** @internal */ _ambientUp;
    /** @internal */ _ambientDown;
    /**
   * Creates an instance of EnvConstantAmbient
   * @param ambientUp - The upside ambient color
   * @param ambientDown - The downside ambient color
   */ constructor(ambientUp, ambientDown){
        super();
        this._ambientUp = new Vector4(ambientUp);
        this._ambientDown = new Vector4(ambientDown);
    }
    /** The upside ambient color */ get ambientUp() {
        return this._ambientUp;
    }
    set ambientUp(color) {
        if (color) {
            this._ambientUp.set(color);
        }
    }
    /** The downside ambient color */ get ambientDown() {
        return this._ambientDown;
    }
    set ambientDown(color) {
        if (color) {
            this._ambientDown.set(color);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.getType}
   * @override
   */ getType() {
        return 'hemisphere';
    }
    /**
   * {@inheritDoc EnvironmentLighting.initShaderBindings}
   * @override
   */ initShaderBindings(pb) {
        if (pb.shaderKind === 'fragment') {
            pb.getGlobalScope()[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_UP] = pb.vec4().uniform(0);
            pb.getGlobalScope()[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_DOWN] = pb.vec4().uniform(0);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.updateBindGroup}
   * @override
   */ updateBindGroup(bg) {
        bg.setValue(EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_UP, this._ambientUp);
        bg.setValue(EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_DOWN, this._ambientDown);
    }
    /**
   * {@inheritDoc EnvironmentLighting.getRadiance}
   * @override
   */ getRadiance(scope, refl, roughness) {
        return null;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getIrradiance}
   * @override
   */ getIrradiance(scope, normal) {
        const pb = scope.$builder;
        const factor = pb.add(pb.mul(normal.y, 0.5), 0.5);
        return pb.mix(scope[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_DOWN], scope[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_UP], factor).rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasRadiance}
   * @override
   */ hasRadiance() {
        return false;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasIrradiance}
   * @override
   */ hasIrradiance() {
        return true;
    }
    /**
   * {@inheritDoc EnvironmentLighting.isHemispheric}
   * @override
   */ isHemispheric() {
        return true;
    }
}

/** @internal */ class OctreeUpdateVisitor {
    /** @internal */ _octree;
    constructor(octree){
        this._octree = octree;
    }
    visit(node) {
        if (node instanceof GraphNode) {
            this._octree.placeNode(node);
        }
    }
}

/** @internal */ class RaycastVisitor {
    /** @internal */ _ray;
    /** @internal */ _rayLocal;
    /** @internal */ _intersected;
    /** @internal */ _intersectedDist;
    constructor(ray, length){
        this._ray = ray;
        this._rayLocal = new Ray();
        this._intersected = null;
        this._intersectedDist = length;
    }
    get intersected() {
        return this._intersected;
    }
    get intersectedDist() {
        return this._intersectedDist;
    }
    get intersectedPoint() {
        return Vector3.add(this._ray.origin, Vector3.scale(this._ray.direction, this._intersectedDist));
    }
    visit(target) {
        if (target instanceof OctreeNode) {
            return this.visitOctreeNode(target);
        }
        if (target.isMesh()) {
            return this.visitMesh(target);
        } else if (target.isTerrain()) {
            return this.visitTerrain(target);
        }
        return false;
    }
    visitTerrain(node) {
        if (!node.hidden && node.pickable) {
            this._ray.transform(node.invWorldMatrix, this._rayLocal);
            const d = node.rayIntersect(this._rayLocal); // this._rayLocal.bboxIntersectionTestEx(node.getBoundingVolume().toAABB());
            if (d !== null && d < this._intersectedDist) {
                this._intersectedDist = d;
                this._intersected = node;
                return true;
            }
        }
        return false;
    }
    visitMesh(node) {
        if (!node.hidden && node.pickable) {
            this._ray.transform(node.invWorldMatrix, this._rayLocal);
            const d = node.primitive.raycast(this._rayLocal);
            if (d !== null && d < this._intersectedDist) {
                this._intersectedDist = d;
                this._intersected = node.getPickTarget() ?? node;
                return true;
            }
        }
        return false;
    }
    visitOctreeNode(node) {
        if (node.getLevel() === 0 || this._ray.bboxIntersectionTest(node.getBoxLoosed()) !== null) {
            const nodes = node.getNodes();
            for(let i = 0; i < nodes.length; i++){
                this.visit(nodes[i]);
            }
            return true;
        }
        return false;
    }
}

/**
 * Wrapper for environmant lighting
 * @public
 */ class EnvLightWrapper {
    _envLight;
    _ambientColor;
    _ambientDown;
    _ambientUp;
    _radianceMap;
    _irradianceMap;
    _strength;
    /** @internal */ constructor(){
        this._envLight = new EnvIBL();
        this._ambientColor = new Vector4(0.2, 0.2, 0.2, 1);
        this._ambientDown = new Vector4(0.2, 0.2, 0.2, 1);
        this._ambientUp = new Vector4(0.3, 0.5, 0.8, 1);
        this._radianceMap = null;
        this._irradianceMap = null;
        this._strength = 1;
    }
    /** @internal */ getHash(ctx) {
        return ctx.drawEnvLight ? `${this.type}:${this._envLight.hasRadiance() ? '1' : '0'}:${this._envLight.hasIrradiance() ? '1' : '0'}` : 'none';
    }
    /** @internal */ get envLight() {
        return this._envLight;
    }
    /** The strength of environment lighting */ get strength() {
        return this._strength;
    }
    set strength(val) {
        this._strength = val;
    }
    /** Ambient light color for environment light type constant */ get ambientColor() {
        return this._ambientColor.clone();
    }
    set ambientColor(val) {
        this._ambientColor.set(val);
        if (this.type === 'constant') {
            this._envLight.ambientColor = this._ambientColor;
        }
    }
    /** Up color for environment light type hemisphere */ get ambientUp() {
        return this._ambientUp.clone();
    }
    set ambientUp(val) {
        this._ambientUp.set(val);
        if (this.type === 'hemisphere') {
            this._envLight.ambientUp = this._ambientUp;
        }
    }
    /** Down color for environment light type hemisphere */ get ambientDown() {
        return this._ambientDown.clone();
    }
    set ambientDown(val) {
        this._ambientDown.set(val);
        if (this.type === 'hemisphere') {
            this._envLight.ambientDown = this._ambientDown;
        }
    }
    /** Radiance map for environment light type ibl */ get radianceMap() {
        return this._radianceMap;
    }
    set radianceMap(tex) {
        this._radianceMap = tex ?? null;
        if (this.type === 'ibl') {
            this._envLight.radianceMap = this._radianceMap;
        }
    }
    /** Irradiance map for environment light type ibl */ get irradianceMap() {
        return this._irradianceMap;
    }
    set irradianceMap(tex) {
        this._irradianceMap = tex ?? null;
        if (this.type === 'ibl') {
            this._envLight.irradianceMap = this._irradianceMap;
        }
    }
    /** The environment light type */ get type() {
        return this._envLight?.getType() ?? 'none';
    }
    set type(val) {
        switch(val){
            case 'none':
                this._envLight = null;
                break;
            case 'ibl':
                if (this._envLight?.getType() !== val) {
                    this._envLight = new EnvIBL(this._radianceMap, this._irradianceMap);
                }
                break;
            case 'constant':
                if (this._envLight?.getType() !== val) {
                    this._envLight = new EnvConstantAmbient(this._ambientColor);
                }
                break;
            case 'hemisphere':
                if (this._envLight?.getType() !== val) {
                    this._envLight = new EnvHemisphericAmbient(this._ambientUp, this._ambientDown);
                }
                break;
        }
    }
}
/**
 * Environment of scene
 * @public
 */ class Environment {
    _sky;
    _light;
    /** @internal */ constructor(){
        this._sky = new SkyRenderer();
        this._light = new EnvLightWrapper();
    }
    /** The sky renderer */ get sky() {
        return this._sky;
    }
    /** The environment lighting renderer */ get light() {
        return this._light;
    }
    /** @internal */ getHash(ctx) {
        return `${this.light?.getHash(ctx)}:${this._sky?.getHash(ctx)}`;
    }
    /** @internal */ needSceneDepthTexture() {
        return this._sky.fogType !== 'none';
    }
}

/**
 * Event that will be fired when the scene needs to be updated
 * @public
 */ class SceneUpdateEvent {
    static NAME = 'sceneupdate';
    scene;
    type = SceneUpdateEvent.NAME;
    constructor(scene){
        this.scene = scene;
    }
}
/**
 * Presents a world that manages a couple of objects that will be rendered
 * @public
 */ class Scene extends makeEventTarget(Object)() {
    /** @internal */ static _nextId = 0;
    /** @internal */ _rootNode;
    /** @internal */ _octree;
    /** @internal */ _nodePlaceList;
    /** @internal */ _env;
    /** @internal */ _updateEvent;
    /** @internal */ _updateFrame;
    /** @internal */ _animationSet;
    /** @internal */ _id;
    /**
   * Creates an instance of scene
   */ constructor(){
        super();
        this._id = ++Scene._nextId;
        this._octree = new Octree(this, 2048, 64);
        this._nodePlaceList = new Set();
        this._env = new Environment();
        this._updateEvent = new SceneUpdateEvent(this);
        this._updateFrame = -1;
        this._animationSet = [];
        this._rootNode = new SceneNode(this);
    }
    /** @internal */ get animationSet() {
        return this._animationSet;
    }
    /**
   * Gets the unique identifier of the scene
   */ get id() {
        return this._id;
    }
    /**
   * Gets the root scene node of the scene
   */ get rootNode() {
        return this._rootNode;
    }
    /**
   * Gets the octree
   */ get octree() {
        // Make sure the octree state is up to date
        this.updateNodePlacement(this._octree, this._nodePlaceList);
        return this._octree;
    }
    /**
   * Gets the bounding box of the scene
   */ get boundingBox() {
        this.updateNodePlacement(this._octree, this._nodePlaceList);
        // this._syncBVChangedList();
        return this._octree.getRootNode().getBox() || this._octree.getRootNode().getBoxLoosed();
    }
    /**
   * The environment of the scene
   */ get env() {
        return this._env;
    }
    /**
   * Disposes the scene
   */ dispose() {
        this._rootNode = null;
    }
    /**
   * Cast a ray into the scene to get the closest object hit by the ray
   * @param camera - The camera used to compute the ray
   * @param screenX - The x position on screen
   * @param screenY - The y position on screen
   * @returns The closest object hit by the ray
   */ raycast(camera, screenX, screenY) {
        const width = camera.viewport ? camera.viewport[2] : Application.instance.device.getViewport().width;
        const height = camera.viewport ? camera.viewport[3] : Application.instance.device.getViewport().height;
        const ray = this.constructRay(camera, width, height, screenX, screenY);
        const raycastVisitor = new RaycastVisitor(ray, camera.getFarPlane());
        this.octree.getRootNode().traverse(raycastVisitor);
        return raycastVisitor.intersected ? {
            node: raycastVisitor.intersected,
            dist: raycastVisitor.intersectedDist,
            point: raycastVisitor.intersectedPoint
        } : null;
    }
    /**
   * Constructs a ray by a given camera and the position on screen
   * @param camera - The camera used to compute the ray
   * @param viewportWidth - Width of the viewport
   * @param viewportHeight - Height of the viewport
   * @param screenX - The x position on screen
   * @param screenY - The y position on screen
   * @param invModelMatrix - A matrix used to transform the ray
   * @returns The constructed ray
   */ constructRay(camera, viewportWidth, viewportHeight, screenX, screenY, invModelMatrix) {
        const vClip = new Vector4(2 * screenX / viewportWidth - 1, 1 - 2 * screenY / viewportHeight, 1, 1);
        const vWorld = camera.invViewProjectionMatrix.transform(vClip);
        vWorld.scaleBy(1 / vWorld.w);
        let vEye = camera.getWorldPosition();
        let vDir = Vector3.sub(vWorld.xyz(), vEye).inplaceNormalize();
        if (invModelMatrix) {
            vEye = invModelMatrix.transformPointAffine(vEye);
            vDir = invModelMatrix.transformVectorAffine(vDir);
        }
        return new Ray(vEye, vDir);
    }
    /** @internal */ invalidateNodePlacement(node) {
        if (node.isGraphNode() || node.children.length > 0) {
            this._nodePlaceList.add(node);
        }
    }
    /** @internal */ _xformChanged(node) {
        this._nodePlaceList.add(node);
    }
    /** @internal */ frameUpdate() {
        const frameInfo = Application.instance.device.frameInfo;
        if (frameInfo.frameCounter !== this._updateFrame) {
            this._updateFrame = frameInfo.frameCounter;
            // uniform buffer garbage collect
            if (!Material.getGCOptions().disabled) {
                Material.garbageCollect(frameInfo.frameTimestamp);
            }
            for (const an of this._animationSet){
                an.update();
            }
            // check environment lighting
            if (this.env.light.type === 'ibl') {
                if (!this.env.light.radianceMap) {
                    if (this.env.sky.skyType !== 'none') {
                        this.env.light.radianceMap = this.env.sky.radianceMap;
                    }
                } else if (this.env.light.radianceMap === this.env.sky.radianceMap) {
                    if (this.env.sky.skyType === 'none') {
                        this.env.light.radianceMap = null;
                    }
                }
                if (!this.env.light.irradianceMap) {
                    if (this.env.sky.skyType !== 'none') {
                        this.env.light.irradianceMap = this.env.sky.irradianceMap;
                    }
                } else if (this.env.light.irradianceMap === this.env.sky.irradianceMap) {
                    if (this.env.sky.skyType === 'none') {
                        this.env.light.irradianceMap = null;
                    }
                }
            }
            // update scene objects first
            this.dispatchEvent(this._updateEvent);
            this.updateNodePlacement(this._octree, this._nodePlaceList);
        }
    }
    /**
   * Update node placement in the octree
   */ updateNodePlacement(octree, list) {
        function placeNode(node, attached) {
            if (node.isGraphNode()) {
                if (attached && !node.hidden) {
                    octree.placeNode(node);
                } else {
                    octree.removeNode(node);
                }
            }
            for (const child of node.children){
                if (child.isGraphNode()) {
                    placeNode(child, attached);
                }
            }
            list.delete(node);
        }
        if (list.size > 0) {
            while(list.size > 0){
                const node = list.keys().next().value;
                if (octree) {
                    placeNode(node, node.attached);
                } else {
                    list.delete(node);
                }
            }
            if (octree) {
                const worldBox = octree.getRootNode().getBox();
                if (worldBox) {
                    const radius = Math.max(Math.abs(worldBox.minPoint.x), Math.abs(worldBox.minPoint.y), Math.abs(worldBox.minPoint.z), Math.abs(worldBox.maxPoint.x), Math.abs(worldBox.maxPoint.y), Math.abs(worldBox.maxPoint.z));
                    const rootSize = nextPowerOf2(radius * 2);
                    if (rootSize > octree.getRootSize()) {
                        octree.initialize(rootSize, octree.getLeafSize());
                        const v = new OctreeUpdateVisitor(octree);
                        this._rootNode.traverse(v);
                    }
                }
            }
        }
    }
}

/**
 * Base class for any kind of light node
 * @public
 */ class BaseLight extends GraphNode {
    /** @internal */ _type;
    /** @internal */ _intensity;
    /** @internal */ _positionRange;
    /** @internal */ _directionCutoff;
    /** @internal */ _diffuseIntensity;
    /**
   * Creates a light node
   * @param scene - The scene to which the light node belongs
   * @param type - Type of the light node
   */ constructor(scene, type){
        super(scene);
        this._intensity = 1;
        this._type = type;
        this._positionRange = null;
        this._directionCutoff = null;
        this._diffuseIntensity = null;
    }
    /** Gets the light type */ get lightType() {
        return this._type;
    }
    /** Intensity of the light */ get intensity() {
        return this._intensity;
    }
    set intensity(val) {
        this.setIntensity(val);
    }
    /**
   * Position and range of the light
   *
   * @remarks
   * Gets the position in world space of the light.
   * Light range is encoded into the W component.
   */ get positionAndRange() {
        if (!this._positionRange) {
            this.computeUniforms();
        }
        return this._positionRange;
    }
    /**
   * Direction and cutoff of the light
   *
   * @remarks
   * Gets the direction in world space of the light
   * Light cutoff (for spot light only) is encoded into the W component.
   */ get directionAndCutoff() {
        if (!this._directionCutoff) {
            this.computeUniforms();
        }
        return this._directionCutoff;
    }
    /**
   * Color and intensity of the light
   *
   * @remarks
   * Gets the color of the light.
   * Light intensity is encoded into the W component.
   */ get diffuseAndIntensity() {
        if (!this._diffuseIntensity) {
            this.computeUniforms();
        }
        return this._diffuseIntensity;
    }
    /**
   * View matrix of the light
   *
   * @remarks
   * The view matrix of the light is used to transform a point
   * from the world space to the light space.
   */ get viewMatrix() {
        return this.invWorldMatrix;
    }
    /**
   * View-projection matrix of the light
   *
   * @remarks
   * The view-projection matrix of the light is used to transform
   * a point from the world space to the clip space of the light view
   */ get viewProjMatrix() {
        return null;
    }
    /**
   * Sets the intensity of the light
   * @param val - Intensity of the light
   * @returns self
   */ setIntensity(val) {
        if (this._intensity !== val) {
            this._intensity = val;
            this.invalidateUniforms();
        }
        return this;
    }
    /** @internal */ invalidateUniforms() {
        this._positionRange = null;
        this._directionCutoff = null;
        this._diffuseIntensity = null;
    }
    /** {@inheritDoc SceneNode.isLight} */ isLight() {
        return true;
    }
    /** {@inheritDoc SceneNode.isPunctualLight} */ isPunctualLight() {
        return false;
    }
    /** returns true if this is a directional light */ isDirectionLight() {
        return false;
    }
    /** returns true if this is a point light */ isPointLight() {
        return false;
    }
    /** returns true if this is a spot light */ isSpotLight() {
        return false;
    }
}
/*
export abstract class AmbientLight extends BaseLight {
  constructor(scene: Scene, type: number) {
    super(scene, type);
  }
  isAmbientLight(): this is AmbientLight {
    return true;
  }
}
*/ /*
export class HemiSphericLight extends AmbientLight {
  protected _colorUp: Vector4;
  protected _colorDown: Vector4;
  constructor(scene: Scene) {
    super(scene, LIGHT_TYPE_HEMISPHERIC);
    this._colorUp = Vector4.zero();
    this._colorDown = Vector4.zero();
  }
  get colorUp() {
    return this._colorUp;
  }
  set colorUp(val: Vector4) {
    this.setColorUp(val);
  }
  setColorUp(val: Vector4) {
    this._colorUp.set(val);
    this.invalidateUniforms();
    return this;
  }
  get colorDown() {
    return this._colorDown;
  }
  set colorDown(val: Vector4) {
    this.setColorDown(val);
  }
  setColorDown(val: Vector4) {
    this._colorDown.set(val);
    this.invalidateUniforms();
    return this;
  }
  isHemiSphericLight(): this is HemiSphericLight {
    return true;
  }
  computeUniforms() {
    this._positionRange = this.colorUp;
    this._directionCutoff = this.colorDown;
    this._diffuseIntensity = new Vector4(1, 1, 1, this.intensity);
  }
}
*/ /**
 * Base class for any kind of puncual light
 * @public
 */ class PunctualLight extends BaseLight {
    /** @internal */ _color;
    /** @internal */ _castShadow;
    /** @internal */ _lightViewProjectionMatrix;
    /** @internal */ _shadowMapper;
    /**
   * Creates an instance of punctual light
   * @param scene - The scene to which the punctual light belongs
   * @param type - The light type
   */ constructor(scene, type){
        super(scene, type);
        this._color = Vector4.one();
        this._castShadow = false;
        this._lightViewProjectionMatrix = Matrix4x4.identity();
        this._shadowMapper = new ShadowMapper(this);
    }
    /** Color of the light */ get color() {
        return this._color;
    }
    set color(clr) {
        this.setColor(clr);
    }
    /**
   * Sets color of the light
   * @param color - The color to set
   * @returns self
   */ setColor(color) {
        this._color.set(color);
        this.invalidateUniforms();
        return this;
    }
    /** Whether this light casts shadows */ get castShadow() {
        return this._castShadow;
    }
    set castShadow(b) {
        this.setCastShadow(b);
    }
    /**
   * Sets whether this light casts shadows
   * @param b - true if the light casts shadows
   * @returns self
   */ setCastShadow(b) {
        this._castShadow = b;
        return this;
    }
    /**
   * {@inheritDoc BaseLight.viewProjMatrix}
   * @override
   */ get viewProjMatrix() {
        return this._lightViewProjectionMatrix;
    }
    set viewProjMatrix(mat) {
        this.setLightViewProjectionMatrix(mat);
    }
    /** The shadow mapper for this light */ get shadow() {
        return this._shadowMapper;
    }
    /**
   * Sets the view projection matrix for this light
   * @param mat - The matrix to set
   * @returns self
   */ setLightViewProjectionMatrix(mat) {
        this._lightViewProjectionMatrix.set(mat);
        return this;
    }
    /**
   * {@inheritDoc BaseLight.isPunctualLight}
   * @override
   */ isPunctualLight() {
        return true;
    }
    /** @internal */ _onTransformChanged(invalidateLocal) {
        super._onTransformChanged(invalidateLocal);
        this.invalidateUniforms();
    // this._transformCallback(true, false);
    }
}
/**
 * Directional light
 * @public
 */ class DirectionalLight extends PunctualLight {
    static _currentSunLight = null;
    _sunLight;
    /**
   * Creates an instance of directional light
   * @param scene - The scene to which the light belongs
   */ constructor(scene){
        super(scene, LIGHT_TYPE_DIRECTIONAL);
        if (!DirectionalLight._currentSunLight) {
            DirectionalLight._currentSunLight = this;
            this._sunLight = true;
        } else {
            this._sunLight = false;
        }
    }
    /**
   * true if the light was defined as sun light
   *
   * @remarks
   * Only one directional light will be marked as sun light.
   **/ get sunLight() {
        return this._sunLight;
    }
    set sunLight(val) {
        if (!!val !== this._sunLight) {
            this._sunLight = !!val;
            if (this._sunLight) {
                DirectionalLight._currentSunLight._sunLight = false;
                DirectionalLight._currentSunLight = this;
            } else {
                DirectionalLight._currentSunLight = null;
            }
        }
        this._sunLight = !!val;
    }
    /**
   * {@inheritDoc BaseLight.isDirectionLight}
   * @override
   */ isDirectionLight() {
        return true;
    }
    /** @internal */ computeBoundingVolume(bv) {
        return null;
    }
    /** @internal */ computeUniforms() {
        const a = this.worldMatrix.getRow(3);
        const b = this.worldMatrix.getRow(2).scaleBy(-1);
        this._positionRange = new Vector4(a.x, a.y, a.z, -1);
        this._directionCutoff = new Vector4(b.x, b.y, b.z, 0);
        this._diffuseIntensity = new Vector4(this.color.x, this.color.y, this.color.z, this.intensity);
    }
}

/**
 * Mesh node
 * @public
 */ class Mesh extends GraphNode {
    /** @internal */ _primitive;
    /** @internal */ _material;
    /** @internal */ _castShadow;
    /** @internal */ _bboxChangeCallback;
    /** @internal */ _animatedBoundingBox;
    /** @internal */ _boneMatrices;
    /** @internal */ _invBindMatrix;
    /** @internal */ _instanceHash;
    /** @internal */ _batchable;
    /** @internal */ _boundingBoxNode;
    /** @internal */ _instanceColor;
    /**
   * Creates an instance of mesh node
   * @param scene - The scene to which the mesh node belongs
   */ constructor(scene, primitive, material){
        super(scene);
        this._primitive = null;
        this._material = null;
        this._castShadow = true;
        this._animatedBoundingBox = null;
        this._boneMatrices = null;
        this._invBindMatrix = null;
        this._instanceHash = null;
        this._boundingBoxNode = null;
        this._instanceColor = Vector4.zero();
        this._batchable = Application.instance.deviceType !== 'webgl';
        this._bboxChangeCallback = this._onBoundingboxChange.bind(this);
        // use setter
        this.primitive = primitive ?? null;
        this.material = material ?? Mesh._getDefaultMaterial();
    }
    /**
   * {@inheritDoc Drawable.getName}
   */ getName() {
        return this._name;
    }
    /**
   * {@inheritDoc BatchDrawable.getInstanceId}
   */ getInstanceId(renderPass) {
        return `${this._instanceHash}:${this.worldMatrixDet >= 0}`;
    }
    /**
   * {@inheritDoc Drawable.getInstanceColor}
   */ getInstanceColor() {
        return this._instanceColor;
    }
    /**
   * {@inheritDoc Drawable.getPickTarget }
   */ getPickTarget() {
        return this;
    }
    /** Wether the mesh node casts shadows */ get castShadow() {
        return this._castShadow;
    }
    set castShadow(b) {
        this._castShadow = b;
    }
    /** Primitive of the mesh */ get primitive() {
        return this._primitive;
    }
    set primitive(prim) {
        if (prim !== this._primitive) {
            if (this._primitive) {
                this._primitive.removeBoundingboxChangeCallback(this._bboxChangeCallback);
            }
            this._primitive = prim || null;
            if (this._primitive) {
                this._primitive.addBoundingboxChangeCallback(this._bboxChangeCallback);
            }
            this._instanceHash = this._primitive && this._material ? `${this.constructor.name}:${this._scene.id}:${this._primitive.id}:${this._material.id}` : null;
            this.invalidateBoundingVolume();
        }
    }
    /** Material of the mesh */ get material() {
        return this._material;
    }
    set material(m) {
        if (this._material !== m) {
            this._material = m;
            this._instanceHash = this._primitive && this._material ? `${this.constructor.name}:${this._scene.id}:${this._primitive.id}:${this._material.id}` : null;
        }
    }
    /** Wether to draw the bounding box of the mesh node */ get drawBoundingBox() {
        return !!this._boundingBoxNode;
    }
    set drawBoundingBox(val) {
        if (!!this._boundingBoxNode !== !!val) {
            if (!val) {
                this._boundingBoxNode.remove();
                this._boundingBoxNode = null;
            } else {
                if (!Mesh._defaultBoxFrame) {
                    Mesh._defaultBoxFrame = new BoxFrameShape({
                        size: 1
                    });
                }
                this._boundingBoxNode = new Mesh(this._scene, Mesh._defaultBoxFrame).reparent(this);
                this._boundingBoxNode.scale.set(this.getBoundingVolume().toAABB().size);
                this._boundingBoxNode.position.set(this.getBoundingVolume().toAABB().minPoint);
            }
        }
    }
    /**
   * {@inheritDoc SceneNode.isMesh}
   */ isMesh() {
        return true;
    }
    /**
   * Sets the bounding box for animation
   * @param bbox - The bounding box for animation
   */ setAnimatedBoundingBox(bbox) {
        this._animatedBoundingBox = bbox;
        this.invalidateBoundingVolume();
    }
    /**
   * Sets the texture that contains the bone matrices for skeletal animation
   * @param matrices - The texture that contains the bone matrices
   */ setBoneMatrices(matrices) {
        this._boneMatrices = matrices;
    }
    /**
   * Sets the inverse bind matrix for skeletal animation
   * @param matrix - The matrix to set
   */ setInvBindMatrix(matrix) {
        this._invBindMatrix = matrix;
    }
    /**
   * {@inheritDoc Drawable.isBatchable}
   */ isBatchable() {
        return this._batchable && !this._boneMatrices && this._material?.isBatchable();
    }
    /** Disposes the mesh node */ dispose() {
        this._primitive = null;
        this._material = null;
        super.dispose();
    }
    /**
   * {@inheritDoc Drawable.getQueueType}
   */ getQueueType() {
        return this.material?.getQueueType() ?? QUEUE_OPAQUE;
    }
    /**
   * {@inheritDoc Drawable.isUnlit}
   */ isUnlit() {
        return !this.material?.supportLighting();
    }
    /**
   * {@inheritDoc Drawable.draw}
   */ draw(ctx) {
        this.material.draw(this.primitive, ctx);
    }
    /**
   * {@inheritDoc Drawable.getBoneMatrices}
   */ getBoneMatrices() {
        return this._boneMatrices;
    }
    /**
   * {@inheritDoc Drawable.getInvBindMatrix}
   */ getInvBindMatrix() {
        return this._invBindMatrix;
    }
    /**
   * {@inheritDoc Drawable.getXForm}
   */ getXForm() {
        // mesh transform should be ignored when skinned
        return this;
    }
    /** @internal */ computeBoundingVolume(bv) {
        let bbox;
        if (this._animatedBoundingBox) {
            bbox = this._animatedBoundingBox;
        } else {
            const primitive = this.primitive;
            bbox = primitive ? primitive.getBoundingVolume() : null;
        }
        if (bbox && this._boundingBoxNode) {
            this._boundingBoxNode.scale.set(bbox.toAABB().size);
            this._boundingBoxNode.position.set(bbox.toAABB().minPoint);
        }
        return bbox;
    }
    /** @internal */ _onBoundingboxChange() {
        this.invalidateBoundingVolume();
    }
    /** @internal */ static _defaultMaterial = null;
    /** @internal */ static _defaultBoxFrame = null;
    /** @internal */ static _getDefaultMaterial() {
        if (!this._defaultMaterial) {
            this._defaultMaterial = new LambertMaterial();
        }
        return this._defaultMaterial;
    }
}

/**
 * Animation that contains multiple tracks
 * @public
 */ class AnimationClip {
    /** @internal */ _name;
    /** @internal */ _model;
    /** @internal */ _repeat;
    /** @internal */ _speedRatio;
    /** @internal */ _repeatCounter;
    /** @internal */ _duration;
    /** @internal */ _isPlaying;
    /** @internal */ _lastUpdateFrame;
    /** @internal */ _currentPlayTime;
    /** @internal */ _tracks;
    /** @internal */ _skeletons;
    /** @internal */ _tmpPosition;
    /** @internal */ _tmpRotation;
    /** @internal */ _tmpScale;
    /**
   * Creates an animation instance
   * @param name - Name of the animation
   * @param model - Parent node if this is a skeleton animation
   */ constructor(name, model){
        this._name = name;
        this._model = model ?? null;
        this._tracks = new Map();
        this._duration = 0;
        this._repeat = 0;
        this._repeatCounter = 0;
        this._speedRatio = 1;
        this._isPlaying = false;
        this._currentPlayTime = 0;
        this._lastUpdateFrame = 0;
        this._skeletons = new Map();
        this._tmpRotation = new Quaternion();
        this._tmpPosition = new Vector3();
        this._tmpScale = new Vector3();
    }
    /** Disposes self */ dispose() {
        this._model = null;
        this._tracks = null;
        this._skeletons?.forEach((val, key)=>key.dispose());
        this._skeletons = null;
    }
    /** Gets the name of the animation */ get name() {
        return this._name;
    }
    /** Gets all the tracks of this animation */ get tracks() {
        return this._tracks;
    }
    /** The duration of the animation */ get timeDuration() {
        return this._duration;
    }
    /**
   * Adds a skeleton to the animation
   * @param skeleton - The skeleton to be added
   * @param meshList - The meshes controlled by the skeleton
   * @param boundingBoxInfo - Bounding box information for the skeleton
   */ addSkeleton(skeleton, meshList, boundingBoxInfo) {
        let meshes = this._skeletons.get(skeleton);
        if (!meshes) {
            meshes = [];
            this._skeletons.set(skeleton, meshes);
        }
        for(let i = 0; i < meshList.length; i++){
            meshes.push({
                mesh: meshList[i],
                bounding: boundingBoxInfo[i],
                box: new BoundingBox()
            });
        }
    }
    /**
   * Adds an animation track to the animation
   * @param node - The node that will be controlled by the track
   * @param track - The track to be added
   * @returns self
   */ addTrack(node, track) {
        if (!track) {
            return;
        }
        let trackInfo = this._tracks.get(node);
        if (!trackInfo) {
            trackInfo = {
                poseTranslation: new Vector3(node.position),
                poseRotation: new Quaternion(node.rotation),
                poseScaling: new Vector3(node.scale),
                tracks: []
            };
            this._tracks.set(node, trackInfo);
        }
        trackInfo.tracks.push(track);
        this._duration = Math.max(this._duration, track.interpolator.maxTime);
        return this;
    }
    /**
   * Check if the animation is playing
   * @returns true if the animation is playing, otherwise false
   */ isPlaying() {
        return this._isPlaying;
    }
    /**
   * Updates the animation state
   */ update() {
        const device = Application.instance.device;
        if (!this._isPlaying || this._lastUpdateFrame === device.frameInfo.frameCounter) {
            return;
        }
        this._lastUpdateFrame = device.frameInfo.frameCounter;
        this._tracks.forEach((trackInfo, node)=>{
            for (const track of trackInfo.tracks){
                track.apply(node, this._currentPlayTime, this._duration);
            }
        });
        this._skeletons.forEach((meshes, skeleton)=>{
            skeleton.computeJoints();
            for (const mesh of meshes){
                skeleton.computeBoundingBox(mesh.bounding, mesh.mesh.invWorldMatrix);
                mesh.mesh.setBoneMatrices(skeleton.jointTexture);
                mesh.mesh.setInvBindMatrix(mesh.mesh.invWorldMatrix);
                mesh.mesh.setAnimatedBoundingBox(mesh.bounding.boundingBox);
            }
        });
        const timeAdvance = device.frameInfo.elapsedFrame * 0.001 * this._speedRatio;
        this._currentPlayTime += timeAdvance;
        if (this._currentPlayTime > this._duration) {
            this._repeatCounter++;
            this._currentPlayTime = 0;
        } else if (this._currentPlayTime < 0) {
            this._repeatCounter++;
            this._currentPlayTime = this._duration;
        }
        if (this._repeat !== 0 && this._repeatCounter >= this._repeat) {
            this.stop();
        }
    }
    /**
   * Starts playing the animation
   */ play(repeat, speedRatio) {
        this._isPlaying = true;
        this._repeat = repeat;
        this._speedRatio = speedRatio;
        this._currentPlayTime = speedRatio < 0 ? this._duration : 0;
        this.update();
    }
    /**
   * Stops the animation
   */ stop() {
        this._isPlaying = false;
        this._skeletons.forEach((meshes, skeleton)=>{
            skeleton.computeBindPose();
            for (const mesh of meshes){
                const invWorldMatrix = Matrix4x4.multiply(mesh.mesh.invWorldMatrix, this._model.worldMatrix);
                skeleton.computeBoundingBox(mesh.bounding, invWorldMatrix);
                mesh.mesh.setBoneMatrices(skeleton.jointTexture);
                mesh.mesh.setInvBindMatrix(invWorldMatrix);
                mesh.mesh.setAnimatedBoundingBox(mesh.bounding.boundingBox);
            }
        });
    }
    /**
   * Rewind the animation to the first frame
   */ rewind() {
        this._currentPlayTime = 0;
    }
}

/** @internal */ class TerrainPatch {
    _terrain;
    _geometry;
    _geometryLines;
    _quadtree;
    _mipLevel;
    _offsetX;
    _offsetZ;
    _step;
    _boundingBox;
    _lodDistance;
    _maxError;
    _parent;
    _offsetScale;
    constructor(terrain){
        this._terrain = terrain;
        this._geometry = null;
        this._geometryLines = null;
        this._mipLevel = 0;
        this._offsetX = 0;
        this._offsetZ = 0;
        this._boundingBox = null;
        this._parent = null;
        this._offsetScale = null;
        this._quadtree = null;
        this._step = 0;
        this._lodDistance = 0;
    }
    initialize(quadtree, parent, rowIndex, colIndex, baseVertices, normals, heightScale, elevations) {
        const patchSize = quadtree.getPatchSize();
        const rootSize = quadtree.getRootSize();
        this._mipLevel = parent ? parent.getMipLevel() + 1 : 0;
        const step = Math.floor((rootSize - 1) / (patchSize - 1)) >> this._mipLevel;
        const interval = (patchSize - 1) * step;
        const parentOffsetX = parent ? parent.getOffsetX() : 0;
        const parentOffsetZ = parent ? parent.getOffsetZ() : 0;
        this._offsetX = parentOffsetX + rowIndex * interval;
        this._offsetZ = parentOffsetZ + colIndex * interval;
        if (this._offsetX + interval >= quadtree.getRootSizeX() || this._offsetZ + interval >= quadtree.getRootSizeZ()) {
            baseVertices = null;
        }
        this._quadtree = quadtree;
        this._step = step;
        this._parent = parent;
        this._geometry = baseVertices ? new Primitive() : null;
        this._geometryLines = baseVertices ? new Primitive() : null;
        this._maxError = baseVertices ? this.computeMaxError() : 0;
        if (baseVertices) {
            const scaleX = this._quadtree.getScaleX();
            const scaleZ = this._quadtree.getScaleZ();
            if (step === 1) {
                this._boundingBox = new BoundingBox();
                this._boundingBox.minPoint.x = this._offsetX * scaleX;
                this._boundingBox.minPoint.y = Number.MAX_VALUE;
                this._boundingBox.minPoint.z = this._offsetZ * scaleZ;
                this._boundingBox.maxPoint.x = this._offsetX * scaleX + (this._quadtree.getPatchSize() - 1) * this._step * scaleX;
                this._boundingBox.maxPoint.y = -Number.MAX_VALUE;
                this._boundingBox.maxPoint.z = this._offsetZ * scaleZ + (this._quadtree.getPatchSize() - 1) * this._step * scaleZ;
            }
            this.setupVertices(this.computeSkirtLength(), baseVertices, normals, heightScale, elevations);
            this._offsetScale = new Vector4(this._step * scaleX, this._offsetX * scaleX, this._step * scaleZ, this._offsetZ * scaleZ);
        }
        return true;
    }
    getInstanceColor() {
        return this._terrain.getInstanceColor();
    }
    getPickTarget() {
        return this._terrain;
    }
    draw(ctx) {
        const isShadowMapPass = ctx.renderPass.type === RENDER_PASS_TYPE_SHADOWMAP;
        const primitive = this._quadtree.getTerrain().wireframe && !isShadowMapPass ? this.getGeometryWireframe() : this.getGeometry();
        const material = this._quadtree.getTerrain().material;
        if (isShadowMapPass) {
            material.stateSet.useRasterizerState().setCullMode('front');
        }
        this._quadtree.getTerrain().material.draw(primitive, ctx);
        if (isShadowMapPass) {
            material.stateSet.defaultRasterizerState();
        }
    }
    setupCamera(viewportH, tanHalfFovy, maxPixelError) {
        if (maxPixelError > 0 && tanHalfFovy > 0) {
            this._lodDistance = this.computeLodDistance(viewportH, tanHalfFovy, maxPixelError);
        } else {
            this._lodDistance = -1;
        }
    }
    getName() {
        return 'TerrainPatch';
    }
    getXForm() {
        return this._quadtree.getTerrain();
    }
    getBoneMatrices() {
        return null;
    }
    getInvBindMatrix() {
        return null;
    }
    getSortDistance(camera) {
        return this._quadtree.getTerrain().getSortDistance(camera);
    }
    getQueueType() {
        return QUEUE_OPAQUE;
    }
    isUnlit() {
        return false;
    }
    isBatchable() {
        return false;
    }
    setupVertices(skirtLength, baseVertices, normalVectors, heightScale, elevations) {
        const that = this;
        const sx = this._quadtree.getScaleX() * this._step;
        const sz = this._quadtree.getScaleZ() * this._step;
        const tx = this._quadtree.getScaleX() * this._offsetX;
        const tz = this._quadtree.getScaleZ() * this._offsetZ;
        function setNormalAndHeight(heights, normals, index, x, z, width, hDelta) {
            const k = x + z * width;
            const h = elevations[k] * heightScale;
            normals[index * 3 + 0] = normalVectors[k].x;
            normals[index * 3 + 1] = normalVectors[k].y;
            normals[index * 3 + 2] = normalVectors[k].z;
            heights[index * 3 + 0] = baseVertices[index * 3 + 0] * sx + tx;
            heights[index * 3 + 1] = h + hDelta;
            heights[index * 3 + 2] = baseVertices[index * 3 + 2] * sz + tz;
            if (that._boundingBox) {
                if (that._boundingBox.maxPoint.y < h) {
                    that._boundingBox.maxPoint.y = h;
                }
                if (that._boundingBox.minPoint.y > h) {
                    that._boundingBox.minPoint.y = h;
                }
            }
            return index + 1;
        }
        const patchSize = this._quadtree.getPatchSize();
        const numVerts = (patchSize + 2) * (patchSize + 2);
        const heights = new Float32Array(numVerts * 3);
        const normals = new Float32Array(numVerts * 3);
        let x = this._offsetX;
        let z = this._offsetZ;
        let t = 0;
        const hf = this._quadtree.getHeightField();
        const w = hf.getSizeX();
        t = setNormalAndHeight(heights, normals, t, x, z, w, -skirtLength);
        for(let i = 0; i < patchSize; i++, x += this._step){
            t = setNormalAndHeight(heights, normals, t, x, z, w, -skirtLength);
        }
        t = setNormalAndHeight(heights, normals, t, x - this._step, z, w, -skirtLength);
        z = this._offsetZ;
        for(let i = 0; i < patchSize; i++, z += this._step){
            x = this._offsetX;
            t = setNormalAndHeight(heights, normals, t, x, z, w, -skirtLength);
            for(let j = 0; j < patchSize; j++, x += this._step){
                t = setNormalAndHeight(heights, normals, t, x, z, w, 0);
            }
            t = setNormalAndHeight(heights, normals, t, x - this._step, z, w, -skirtLength);
        }
        x = this._offsetX;
        z -= this._step;
        t = setNormalAndHeight(heights, normals, t, x, z, w, -skirtLength);
        for(let i = 0; i < patchSize; i++, x += this._step){
            t = setNormalAndHeight(heights, normals, t, x, z, w, -skirtLength);
        }
        t = setNormalAndHeight(heights, normals, t, x - this._step, z, w, -skirtLength);
        const heightArray = Application.instance.device.createVertexBuffer('position_f32x3', heights);
        const normalArray = Application.instance.device.createVertexBuffer('normal_f32x3', normals);
        this._geometry.setVertexBuffer(heightArray);
        this._geometry.setVertexBuffer(normalArray);
        this._geometry.setIndexBuffer(this._quadtree.getIndices());
        this._geometry.indexStart = 0;
        this._geometry.indexCount = this._quadtree.getIndices().length;
        this._geometry.primitiveType = 'triangle-strip';
        this._geometryLines.setVertexBuffer(heightArray);
        this._geometryLines.setVertexBuffer(normalArray);
        this._geometryLines.setIndexBuffer(this._quadtree.getIndicesWireframe());
        this._geometryLines.indexStart = 0;
        this._geometryLines.indexCount = this._quadtree.getIndicesWireframe().length;
        this._geometryLines.primitiveType = 'line-list';
    }
    getOffsetScale() {
        if (!this._offsetScale) {
            const scaleX = this._quadtree.getScaleX();
            const scaleZ = this._quadtree.getScaleZ();
            this._offsetScale = new Vector4(this._step * scaleX, this._offsetX * scaleX, this._step * scaleZ, this._offsetZ * scaleZ);
        }
        return this._offsetScale;
    }
    getBoundingBox() {
        return this._boundingBox;
    }
    setBoundingBox(bbox) {
        this._boundingBox = bbox;
    }
    getMipLevel() {
        return this._mipLevel;
    }
    getOffsetX() {
        return this._offsetX;
    }
    getOffsetZ() {
        return this._offsetZ;
    }
    getStep() {
        return this._step;
    }
    getLODDistance() {
        return this._lodDistance;
    }
    getGeometry() {
        return this._geometry;
    }
    getGeometryWireframe() {
        return this._geometryLines;
    }
    getHeight(x, z) {
        const startX = this._offsetX + this._step * Math.floor((x - this._offsetX) / this._step);
        const startZ = this._offsetZ + this._step * Math.floor((z - this._offsetZ) / this._step);
        const endX = startX == x ? startX : startX + this._step;
        const endZ = startZ == z ? startZ : startZ + this._step;
        const hf = this._quadtree.getHeightField();
        const lt_height = hf.getHeight(startX, startZ);
        const rt_height = hf.getHeight(endX, startZ);
        const lb_height = hf.getHeight(startX, endZ);
        const rb_height = hf.getHeight(endX, endZ);
        const t1 = (x - startX) / this._step;
        const t2 = (z - startZ) / this._step;
        const h1 = lt_height + (rt_height - lt_height) * t1;
        const h2 = lb_height + (rb_height - lb_height) * t1;
        return h1 + (h2 - h1) * t2;
    }
    computeMaxError() {
        if (this._step === 1) {
            return 0;
        }
        let maxError = 0;
        const dimension = this._step * (this._quadtree.getPatchSize() - 1);
        const rootSize = this._quadtree.getRootSize();
        const hf = this._quadtree.getHeightField();
        for(let i = this._offsetZ; i <= this._offsetZ + dimension; i++){
            for(let j = this._offsetX; j <= this._offsetX + dimension; j++){
                const i00 = this._offsetZ + Math.floor((i - this._offsetZ) / this._step) * this._step;
                const j00 = this._offsetX + Math.floor((j - this._offsetX) / this._step) * this._step;
                if (i00 === rootSize - 1 || j00 === rootSize - 1) {
                    continue;
                }
                const i11 = i00 + this._step;
                const j11 = j00 + this._step;
                const h00 = hf.getHeight(j00, i00);
                const h01 = hf.getHeight(j11, i00);
                const h10 = hf.getHeight(j00, i11);
                const h11 = hf.getHeight(j11, i11);
                const factorZ = (i - i00) / this._step;
                const factorX = (j - j00) / this._step;
                const h = hf.getHeight(j, i);
                const h0 = h00 + factorX * (h01 - h00);
                const h1 = h10 + factorX * (h11 - h10);
                const h2 = h0 + factorZ * (h1 - h0);
                const err = Math.abs(h - h2);
                if (err > maxError) {
                    maxError = err;
                }
            }
        }
        return maxError;
    }
    computeSkirtLength() {
        let skirtLength = 0;
        let p = this._parent;
        while(p){
            const f = this.computeErrorMetric(p);
            if (f > skirtLength) {
                skirtLength = f;
            }
            p = p._parent;
        }
        return skirtLength;
    }
    computeErrorMetric(other) {
        let errMetric = 0;
        if (other.getMipLevel() > this._mipLevel) {
            const otherOffsetX = other.getOffsetX();
            const otherOffsetZ = other.getOffsetZ();
            const otherStep = other.getStep();
            const otherDimension = other.getStep() * this._quadtree.getPatchSize();
            for(let i = otherOffsetZ; i < otherOffsetZ + otherDimension; i += otherStep){
                for(let j = otherOffsetX; j < otherOffsetX + otherDimension; j += otherStep){
                    const err = Math.abs(this.getHeight(j, i) - other.getHeight(j, i));
                    if (err > errMetric) {
                        errMetric = err;
                    }
                }
            }
        } else if (other.getMipLevel() < this._mipLevel) {
            const dimension = this._step * (this._quadtree.getPatchSize() - 1);
            for(let i = this._offsetZ; i <= this._offsetZ + dimension; i += this._step){
                for(let j = this._offsetX; j <= this._offsetX + dimension; j += this._step){
                    const err = Math.abs(this.getHeight(j, i) - other.getHeight(j, i));
                    if (err > errMetric) {
                        errMetric = err;
                    }
                }
            }
        }
        return errMetric;
    }
    computeBoundingBox(box) {
        const [maxHeight, minHeight] = this.computeHeightBound();
        const scaleX = this._quadtree.getScaleX();
        const scaleZ = this._quadtree.getScaleZ();
        box.minPoint = new Vector3(this._offsetX * scaleX, minHeight, this._offsetZ * scaleZ);
        box.maxPoint = new Vector3(this._offsetX * scaleX + (this._quadtree.getPatchSize() - 1) * this._step * scaleX, maxHeight, this._offsetZ * scaleZ + (this._quadtree.getPatchSize() - 1) * this._step * scaleZ);
    }
    computeLodDistance(viewportH, tanHalfFovy, maxPixelError) {
        return 0.5 * this._maxError * viewportH / (maxPixelError * tanHalfFovy);
    }
    sqrDistanceToPoint(point) {
        const bbox = this.getBoundingBox();
        const radius = Math.sqrt(bbox.extents.x * bbox.extents.x + bbox.extents.z * bbox.extents.z);
        const dx = point.x - bbox.center.x;
        const dz = point.z - bbox.center.z;
        const s = Math.max(0, Math.sqrt(dx * dx + dz * dz) - radius);
        const t = point.y > bbox.maxPoint.y ? point.y - bbox.maxPoint.y : point.y < bbox.minPoint.y ? bbox.minPoint.y - point.y : 0;
        return s * s + t * t;
    }
    sqrDistancePointToTriangle(P, t0, t1, t2) {
        const B = t0;
        const E0 = Vector3.sub(t1, B);
        const E1 = Vector3.sub(t2, B);
        const D = Vector3.sub(B, P);
        const a = Vector3.dot(E0, E0);
        const b = Vector3.dot(E0, E1);
        const c = Vector3.dot(E1, E1);
        const d = Vector3.dot(E0, D);
        const e = Vector3.dot(E1, D);
        const f = Vector3.dot(D, D);
        const det = a * c - b * b;
        let s = b * e - c * d;
        let t = b * d - a * e;
        let sqrDistance;
        if (s + t <= det) {
            if (s < 0) {
                if (t < 0) {
                    if (d < 0) {
                        t = 0;
                        if (-d >= a) {
                            s = 1;
                            sqrDistance = a + 2 * d + f;
                        } else {
                            s = -d / a;
                            sqrDistance = d * s + f;
                        }
                    } else {
                        s = 0;
                        if (e >= 0) {
                            t = 0;
                            sqrDistance = f;
                        } else {
                            if (-e >= c) {
                                t = 1;
                                sqrDistance = c + 2 * e + f;
                            } else {
                                t = -e / c;
                                sqrDistance = e * t + f;
                            }
                        }
                    }
                } else {
                    s = 0;
                    if (e >= 0) {
                        t = 0;
                        sqrDistance = f;
                    } else {
                        if (-e >= c) {
                            t = 1;
                            sqrDistance = c + 2 * e + f;
                        } else {
                            t = -e / c;
                            sqrDistance = e * t + f;
                        }
                    }
                }
            } else {
                if (t < 0) {
                    t = 0;
                    if (d >= 0) {
                        s = 0;
                        sqrDistance = f;
                    } else {
                        if (-d >= a) {
                            s = 1;
                            sqrDistance = a + 2 * d + f;
                        } else {
                            s = -d / a;
                            sqrDistance = d * s + f;
                        }
                    }
                } else {
                    s /= det;
                    t /= det;
                    sqrDistance = s * (a * s + b * t + 2 * d) + t * (b * s + c * t + 2 * e) + f;
                }
            }
        } else {
            if (s < 0) {
                const tmp0 = b + d;
                const tmp1 = c + e;
                if (tmp1 > tmp0) {
                    const numer = tmp1 - tmp0;
                    const denom = a - 2 * b + c;
                    if (numer >= denom) {
                        s = 1;
                        t = 0;
                        sqrDistance = a + 2 * d + f;
                    } else {
                        s = numer / denom;
                        t = 1 - s;
                        sqrDistance = s * (a * s + b * t + 2 * d) + t * (b * s + c * t + 2 * e) + f;
                    }
                } else {
                    s = 0;
                    if (tmp1 <= 0) {
                        t = 1;
                        sqrDistance = c + 2 * e + f;
                    } else {
                        if (e >= 0) {
                            t = 0;
                            sqrDistance = f;
                        } else {
                            t = -e / c;
                            sqrDistance = e * t + f;
                        }
                    }
                }
            } else {
                if (t < 0) {
                    const tmp0 = b + e;
                    const tmp1 = a + d;
                    if (tmp1 > tmp0) {
                        const numer = tmp1 - tmp0;
                        const denom = a - 2 * b + c;
                        if (numer >= denom) {
                            t = 1;
                            s = 0;
                            sqrDistance = c + 2 * e + f;
                        } else {
                            t = numer / denom;
                            s = 1 - t;
                            sqrDistance = s * (a * s + b * t + 2 * d) + t * (b * s + c * t + 2 * e) + f;
                        }
                    } else {
                        t = 0;
                        if (tmp1 <= 0) {
                            s = 1;
                            sqrDistance = a + 2 * d + f;
                        } else {
                            if (d >= 0) {
                                s = 0;
                                sqrDistance = f;
                            } else {
                                s = -d / a;
                                sqrDistance = d * s + f;
                            }
                        }
                    }
                } else {
                    const numer = c + e - b - d;
                    if (numer <= 0) {
                        s = 0;
                        t = 1;
                        sqrDistance = c + 2 * e + f;
                    } else {
                        const denom = a - 2 * b + c;
                        if (numer >= denom) {
                            s = 1;
                            t = 0;
                            sqrDistance = a + 2 * d + f;
                        } else {
                            s = numer / denom;
                            t = 1 - s;
                            sqrDistance = s * (a * s + b * t + 2 * d) + t * (b * s + c * t + 2 * e) + f;
                        }
                    }
                }
            }
        }
        if (sqrDistance < 0) {
            sqrDistance = 0;
        }
        return sqrDistance;
    }
    computeHeightBound() {
        let maxHeight = -Number.MAX_VALUE;
        let minHeight = Number.MAX_VALUE;
        const dimension = this._step * (this._quadtree.getPatchSize() - 1);
        const hf = this._quadtree.getHeightField();
        const z = Math.min(hf.getSizeZ() - 1, this._offsetZ + dimension);
        const x = Math.min(hf.getSizeX() - 1, this._offsetX + dimension);
        for(let i = this._offsetZ; i <= z; i++){
            for(let j = this._offsetX; j <= x; j++){
                const h = hf.getHeight(j, i);
                if (h > maxHeight) {
                    maxHeight = h;
                }
                if (h < minHeight) {
                    minHeight = h;
                }
            }
        }
        return [
            maxHeight,
            minHeight
        ];
    }
    isDummy() {
        return !this._geometry && !!this._quadtree;
    }
}

/** @internal */ class HeightfieldBBoxTree {
    _resX;
    _resY;
    _spacingX;
    _spacingZ;
    _heights;
    _rootNode;
    constructor(res_x, res_y, spacing_x, spacing_z, vertices){
        this._rootNode = null;
        this._heights = null;
        this._spacingX = spacing_x;
        this._spacingZ = spacing_z;
        this.create(res_x, res_y, vertices);
    }
    create(res_x, res_y, vertices) {
        this._resX = res_x;
        this._resY = res_y;
        this._rootNode = this.allocNode();
        this._heights = new Float32Array(res_x * res_y);
        for(let i = 0; i < this._heights.length; i++){
            this._heights[i] = vertices[i].y;
        }
        this.createChildNode(this._rootNode, 0, 0, res_x, res_y, vertices);
        return true;
    }
    getHeight(x, y) {
        return this._heights[(this._resY - 1 - y) * this._resX + x];
    }
    getNormal(x, y, normal) {
        normal = normal ?? new Vector3();
        x = Math.max(0, Math.min(x, this._resX - 2));
        y = Math.max(0, Math.min(y, this._resY - 2));
        const h00 = this._heights[x + y * this._resX];
        const h01 = this._heights[x + (y + 1) * this._resX];
        const h11 = this._heights[x + 1 + (y + 1) * this._resX];
        const h10 = this._heights[x + 1 + y * this._resX];
        const sx = (h00 + h01 - h11 - h10) * 0.5;
        const sy = (h00 + h10 - h01 - h11) * 0.5;
        const tileSizeX = (this._rootNode.bbox.maxPoint.x - this._rootNode.bbox.minPoint.x) / (this._resX - 1);
        const tileSizeY = (this._rootNode.bbox.maxPoint.z - this._rootNode.bbox.minPoint.z) / (this._resY - 1);
        normal.setXYZ(sx * tileSizeY, 2 * tileSizeX * tileSizeY, -sy * tileSizeX).inplaceNormalize();
        return normal;
    }
    getRealNormal(x, y, normal) {
        normal = normal ?? new Vector3();
        x -= this._rootNode.bbox.minPoint.x;
        y -= this._rootNode.bbox.minPoint.z;
        const tileSizeX = (this._rootNode.bbox.maxPoint.x - this._rootNode.bbox.minPoint.x) / (this._resX - 1);
        const tileSizeY = (this._rootNode.bbox.maxPoint.z - this._rootNode.bbox.minPoint.z) / (this._resY - 1);
        const x_unscale = x / tileSizeX;
        const y_unscale = y / tileSizeY;
        let l = Math.floor(x_unscale);
        let t = Math.floor(y_unscale);
        let r = l + 1;
        let b = t + 1;
        if (l < 0) {
            l = 0;
        }
        if (t < 0) {
            t = 0;
        }
        if (r >= this._resX) {
            r = this._resX - 1;
        }
        if (b >= this._resY) {
            b = this._resY - 1;
        }
        const ltNormal = this.getNormal(l, t);
        const lbNormal = this.getNormal(l, b);
        const rtNormal = this.getNormal(r, t);
        const rbNormal = this.getNormal(r, b);
        ltNormal.addBy(lbNormal).addBy(rtNormal).addBy(rbNormal).scaleBy(0.25).inplaceNormalize();
        normal.set(ltNormal);
        return normal;
    }
    getRealHeight(x, y) {
        x -= this._rootNode.bbox.minPoint.x;
        y -= this._rootNode.bbox.minPoint.z;
        const tileSizeX = (this._rootNode.bbox.maxPoint.x - this._rootNode.bbox.minPoint.x) / (this._resX - 1);
        const tileSizeY = (this._rootNode.bbox.maxPoint.z - this._rootNode.bbox.minPoint.z) / (this._resY - 1);
        const x_unscale = x / tileSizeX;
        const y_unscale = y / tileSizeY;
        const l = Math.floor(x_unscale);
        const t = Math.floor(y_unscale);
        const r = l + 1;
        const b = t + 1;
        if (l < 0 || t < 0 || r >= this._resX || b >= this._resY) {
            return 0;
        }
        if (l === r) {
            if (t === b) {
                return this.getHeight(l, t);
            } else {
                const ht = this.getHeight(l, t);
                const hb = this.getHeight(l, b);
                return ht + (hb - ht) * (y_unscale - t);
            }
        } else {
            const hlt = this.getHeight(l, t);
            const hrt = this.getHeight(r, t);
            const ht = hlt + (hrt - hlt) * (x_unscale - l);
            if (t === b) {
                return ht;
            } else {
                const hlb = this.getHeight(l, b);
                const hrb = this.getHeight(r, b);
                const hb = hlb + (hrb - hlb) * (x_unscale - l);
                return ht + (hb - ht) * (y_unscale - t);
            }
        }
    }
    getRootNode() {
        return this._rootNode;
    }
    getHeights() {
        return this._heights;
    }
    allocNode() {
        return {
            bbox: new BoundingBox(),
            h: [
                0,
                0,
                0,
                0
            ],
            rc: {
                x: 0,
                y: 0,
                w: 0,
                h: 0
            },
            left: null,
            right: null
        };
    }
    computeNodeBoundingBox(node, bbox, vertices) {
        bbox.beginExtend();
        for(let i = 0; i < node.rc.w; i++){
            for(let j = 0; j < node.rc.h; j++){
                const index = node.rc.x + i + (node.rc.y + j) * this._resX;
                const vert = vertices[index];
                bbox.extend3(vert.x, vert.y, vert.z);
            }
        }
    }
    createChildNode(node, x, y, w, h, vertices) {
        node.rc.x = x;
        node.rc.y = y;
        node.rc.w = w;
        node.rc.h = h;
        if (w <= 2 && h <= 2) {
            node.left = null;
            node.right = null;
            node.h[0] = this.getHeight(x, y);
            node.h[1] = this.getHeight(x + 1, y);
            node.h[2] = this.getHeight(x + 1, y + 1);
            node.h[3] = this.getHeight(x, y + 1);
            const hMin = Math.min(...node.h);
            const hMax = Math.max(...node.h);
            node.bbox = new BoundingBox(new Vector3(x * this._spacingX, hMin, y * this._spacingZ), new Vector3((x + 1) * this._spacingX, hMax, (y + 1) * this._spacingZ));
        } else {
            if (w >= h) {
                const w1 = w + 1 >> 1;
                const w2 = w - w1 + 1;
                node.left = this.allocNode();
                this.createChildNode(node.left, x, y, w1, h, vertices);
                node.right = this.allocNode();
                this.createChildNode(node.right, x + w1 - 1, y, w2, h, vertices);
            } else {
                const h1 = h + 1 >> 1;
                const h2 = h - h1 + 1;
                node.left = this.allocNode();
                this.createChildNode(node.left, x, y, w, h1, vertices);
                node.right = this.allocNode();
                this.createChildNode(node.right, x, y + h1 - 1, w, h2, vertices);
            }
            node.bbox.beginExtend();
            node.bbox.extend(node.left.bbox.minPoint);
            node.bbox.extend(node.left.bbox.maxPoint);
            node.bbox.extend(node.right.bbox.minPoint);
            node.bbox.extend(node.right.bbox.maxPoint);
        }
        return true;
    }
    rayIntersect(ray) {
        return this.rayIntersectR(ray, this._rootNode);
    }
    rayIntersectR(ray, node) {
        const d = ray.bboxIntersectionTestEx(node.bbox);
        if (d === null) {
            return null;
        }
        if (node.left && node.right) {
            const l = this.rayIntersectR(ray, node.left);
            const r = this.rayIntersectR(ray, node.right);
            if (l !== null && r !== null) {
                return l < r ? l : r;
            } else {
                return l === null ? r : l;
            }
        } else {
            const v00 = new Vector3(node.bbox.minPoint.x, node.h[0], node.bbox.minPoint.z);
            const v01 = new Vector3(node.bbox.maxPoint.x, node.h[1], node.bbox.minPoint.z);
            const v11 = new Vector3(node.bbox.maxPoint.x, node.h[2], node.bbox.maxPoint.z);
            const v10 = new Vector3(node.bbox.minPoint.x, node.h[3], node.bbox.maxPoint.z);
            let intersected = false;
            let dist1 = ray.intersectionTestTriangle(v00, v01, v10, false);
            if (dist1 !== null && dist1 > 0) {
                intersected = true;
            } else {
                dist1 = Number.MAX_VALUE;
            }
            let dist2 = ray.intersectionTestTriangle(v10, v01, v11, false);
            if (dist2 !== null && dist2 > 0) {
                intersected = true;
            } else {
                dist2 = Number.MAX_VALUE;
            }
            if (!intersected) {
                return null;
            } else {
                return dist1 < dist2 ? dist1 : dist2;
            }
        }
    }
}
/** @internal */ class HeightField {
    m_v4Range;
    m_scale;
    m_sizeX;
    m_sizeZ;
    m_bboxTree;
    m_normals;
    constructor(){
        this.m_v4Range = Vector4.zero();
        this.m_bboxTree = null;
        this.m_scale = Vector3.one();
        this.m_sizeX = 0;
        this.m_sizeZ = 0;
        this.m_normals = null;
    }
    init(sizeX, sizeZ, offsetX, offsetZ, scaleX, scaleY, scaleZ, heights) {
        const v = [];
        for(let i = 0; i < sizeZ; ++i){
            const srcOffset = i * sizeX;
            const dstOffset = (sizeZ - i - 1) * sizeX;
            for(let j = 0; j < sizeX; ++j){
                v[dstOffset + j] = new Vector4(offsetX + j * scaleX, heights[srcOffset + j] * scaleY, offsetZ + i * scaleZ, 1);
            }
        }
        this.m_bboxTree = new HeightfieldBBoxTree(sizeX, sizeZ, scaleX, scaleZ, v);
        this.m_v4Range.setXYZW(this.m_bboxTree.getRootNode().bbox.minPoint.x, this.m_bboxTree.getRootNode().bbox.minPoint.z, this.m_bboxTree.getRootNode().bbox.extents.x * 2, this.m_bboxTree.getRootNode().bbox.extents.z * 2);
        this.m_scale.setXYZ(scaleX, scaleY, scaleZ);
        this.m_sizeX = sizeX;
        this.m_sizeZ = sizeZ;
        this.m_normals = this.computeNormalVectors();
        return true;
    }
    get normals() {
        return this.m_normals;
    }
    clear() {
        this.m_bboxTree = null;
        this.m_v4Range.setXYZW(0, 0, 0, 0);
        this.m_scale.setXYZ(1, 1, 1);
        this.m_sizeX = 0;
        this.m_sizeZ = 0;
    }
    rayIntersect(ray) {
        return this.m_bboxTree.rayIntersect(ray);
    }
    computeNormals() {
        const scaleX = this.m_scale.x;
        const scaleZ = this.m_scale.z;
        const heights = this.getHeights();
        const v = new Vector3();
        const normals = new Uint8Array((this.m_sizeZ - 1) * (this.m_sizeX - 1) * 4);
        for(let y = 0; y < this.m_sizeZ - 1; ++y){
            for(let x = 0; x < this.m_sizeX - 1; ++x){
                const h00 = heights[x + y * this.m_sizeX];
                const h01 = heights[x + (y + 1) * this.m_sizeX];
                const h11 = heights[x + 1 + (y + 1) * this.m_sizeX];
                const h10 = heights[x + 1 + y * this.m_sizeX];
                const sx = (h00 + h01 - h11 - h10) * 0.5;
                const sy = (h00 + h10 - h01 - h11) * 0.5;
                const index = x + (this.m_sizeZ - 2 - y) * (this.m_sizeX - 1);
                v.setXYZ(sx * scaleZ, 2 * scaleX * scaleZ, -sy * scaleX).inplaceNormalize();
                normals[index * 4 + 0] = Math.floor((v.x * 0.5 + 0.5) * 255);
                normals[index * 4 + 1] = Math.floor((v.y * 0.5 + 0.5) * 255);
                normals[index * 4 + 2] = Math.floor((v.z * 0.5 + 0.5) * 255);
                normals[index * 4 + 3] = 255;
            }
        }
        return normals;
    }
    computeNormalVectors() {
        const scaleX = this.m_scale.x;
        const scaleZ = this.m_scale.z;
        const heights = this.getHeights();
        const normals = [];
        for(let y = 0; y < this.m_sizeZ; ++y){
            for(let x = 0; x < this.m_sizeX; ++x){
                const h = heights[x + y * this.m_sizeX];
                const h00 = x > 0 && y > 0 ? heights[x - 1 + (y - 1) * this.m_sizeX] : h;
                const h01 = y > 0 && y < this.m_sizeZ - 1 ? heights[x - 1 + (y + 1) * this.m_sizeX] : h;
                const h11 = x < this.m_sizeX - 1 && y < this.m_sizeZ - 1 ? heights[x + 1 + (y + 1) * this.m_sizeX] : h;
                const h10 = x < this.m_sizeX - 1 && y > 0 ? heights[x + 1 + (y - 1) * this.m_sizeX] : h;
                const sx = (h00 + h01 - h11 - h10) * 0.5;
                const sy = (h00 + h10 - h01 - h11) * 0.5;
                const index = x + (this.m_sizeZ - 1 - y) * this.m_sizeX;
                normals[index] = new Vector3(sx * scaleZ, 2 * scaleX * scaleZ, -sy * scaleX).inplaceNormalize();
            }
        }
        return normals;
    }
    getBBoxTree() {
        return this.m_bboxTree;
    }
    getSpacingX() {
        return this.m_scale.x;
    }
    getSpacingZ() {
        return this.m_scale.z;
    }
    getVerticalScale() {
        return this.m_scale.y;
    }
    getSizeX() {
        return this.m_sizeX;
    }
    getSizeZ() {
        return this.m_sizeZ;
    }
    getOffsetX() {
        return this.m_v4Range.x;
    }
    getOffsetZ() {
        return this.m_v4Range.y;
    }
    getBoundingbox() {
        return this.m_bboxTree?.getRootNode()?.bbox || null;
    }
    getHeights() {
        return this.m_bboxTree?.getHeights() || null;
    }
    getHeight(x, z) {
        return this.m_bboxTree ? this.m_bboxTree.getHeight(x, z) : 0;
    }
    getRealHeight(x, z) {
        return this.m_bboxTree ? this.m_bboxTree.getRealHeight(x, z) : 0;
    }
    getRealNormal(x, z, normal) {
        normal = normal ?? new Vector3();
        const bboxRootNode = this.m_bboxTree.getRootNode();
        x -= bboxRootNode.bbox.minPoint.x;
        z -= bboxRootNode.bbox.minPoint.z;
        const tileSizeX = (bboxRootNode.bbox.maxPoint.x - bboxRootNode.bbox.minPoint.x) / (this.m_sizeX - 1);
        const tileSizeY = (bboxRootNode.bbox.maxPoint.z - bboxRootNode.bbox.minPoint.z) / (this.m_sizeZ - 1);
        const x_unscale = x / tileSizeX;
        const y_unscale = z / tileSizeY;
        let l = Math.floor(x_unscale);
        let t = Math.floor(y_unscale);
        let r = l + 1;
        let b = t + 1;
        if (l < 0) {
            l = 0;
        }
        if (t < 0) {
            t = 0;
        }
        if (r >= this.m_sizeX) {
            r = this.m_sizeX - 1;
        }
        if (b >= this.m_sizeZ) {
            b = this.m_sizeZ - 1;
        }
        normal.set(this.m_normals[l + t * this.m_sizeX]);
        normal.addBy(this.m_normals[r + t * this.m_sizeX]);
        normal.addBy(this.m_normals[r + b * this.m_sizeX]);
        normal.addBy(this.m_normals[l + b * this.m_sizeX]);
        normal.scaleBy(0.4).inplaceNormalize();
        return normal;
    }
}

/** @internal */ class QuadtreeNode {
    _patch;
    _grassClusters;
    _parent;
    _children;
    constructor(){
        this._patch = null;
        this._grassClusters = [];
        this._parent = null;
        this._children = null;
    }
    get grassClusters() {
        return this._grassClusters;
    }
    addGrassCluster(grassCluster) {
        this._grassClusters.push(grassCluster);
    }
    initialize(quadtree, parent, rowIndex, colIndex, baseVertices, normals, heightScale, elevations) {
        this._parent = parent;
        this._children = [];
        this._patch = new TerrainPatch(quadtree.terrain);
        //const rowIndex = position === PatchPosition.LeftBottom || position === PatchPosition.LeftTop ? 0 : 1;
        //const colIndex = position === PatchPosition.LeftTop || position === PatchPosition.RightTop ? 0 : 1;
        if (!this._patch.initialize(quadtree, this._parent?._patch || null, rowIndex, colIndex, baseVertices, normals, heightScale, elevations)) {
            return false;
        }
        if (this._patch.getStep() > 1) {
            let bbox = null;
            const size = (quadtree.getPatchSize() - 1) * (this._patch.getStep() >> 1);
            const offsetX = this._patch.getOffsetX();
            const offsetZ = this._patch.getOffsetZ();
            const offsets = [
                [
                    offsetX,
                    offsetZ
                ],
                [
                    offsetX + size,
                    offsetZ
                ],
                [
                    offsetX,
                    offsetZ + size
                ],
                [
                    offsetX + size,
                    offsetZ + size
                ]
            ];
            const rootSizeX = quadtree.getRootSizeX() - 1;
            const rootSizeZ = quadtree.getRootSizeZ() - 1;
            for(let i = 0; i < 4; ++i){
                if (offsets[i][0] >= rootSizeX || offsets[i][1] >= rootSizeZ) {
                    this._children[i] = null;
                } else {
                    this._children[i] = new QuadtreeNode();
                    if (!this._children[i].initialize(quadtree, this, i & 1, i >> 1, baseVertices, normals, heightScale, elevations)) {
                        return false;
                    }
                    const childBBox = this._children[i]._patch.getBoundingBox();
                    if (childBBox) {
                        if (!bbox) {
                            bbox = new BoundingBox();
                            bbox.beginExtend();
                        }
                        bbox.extend(childBBox.minPoint);
                        bbox.extend(childBBox.maxPoint);
                    }
                }
            }
            this._patch.setBoundingBox(bbox);
        }
        return true;
    }
    setupCamera(viewportH, tanHalfFovy, maxPixelError) {
        if (this._patch && !this._patch.isDummy()) {
            this._patch.setupCamera(viewportH, tanHalfFovy, maxPixelError);
        }
        for(let i = 0; i < 4; ++i){
            if (this._children[i]) {
                this._children[i].setupCamera(viewportH, tanHalfFovy, maxPixelError);
            }
        }
    }
    getBoundingbox() {
        return this._patch.getBoundingBox();
    }
    getPatch() {
        return this._patch;
    }
    getParent() {
        return this._parent;
    }
    getChild(index) {
        return this._children[index];
    }
}
/** @internal */ class Quadtree {
    _baseVertices;
    _indices;
    _indicesWireframe;
    _normalMap;
    _scaleX;
    _scaleZ;
    _patchSize;
    _rootSizeX;
    _rootSizeZ;
    _rootSize;
    _primitiveCount;
    _primitiveType;
    _rootNode;
    _terrain;
    _heightField;
    constructor(terrain){
        this._terrain = terrain;
        this._baseVertices = null;
        this._indices = null;
        this._indicesWireframe = null;
        this._normalMap = null;
        this._scaleX = 1;
        this._scaleZ = 1;
        this._patchSize = 0;
        this._rootSizeX = 0;
        this._rootSizeZ = 0;
        this._rootSize = 0;
        this._heightField = null;
        this._rootNode = null;
        this._primitiveCount = 0;
        this._primitiveType = 'triangle-strip';
    }
    get normalMap() {
        return this._normalMap;
    }
    get rootNode() {
        return this._rootNode;
    }
    get terrain() {
        return this._terrain;
    }
    build(patchSize, rootSizeX, rootSizeZ, elevations, scaleX, scaleY, scaleZ, vertexCacheSize) {
        if (!isPowerOf2(patchSize - 1) || !!((rootSizeX - 1) % (patchSize - 1)) || !!((rootSizeZ - 1) % (patchSize - 1)) || !elevations) {
            return false;
        }
        this._heightField = new HeightField();
        if (!this._heightField.init(rootSizeX, rootSizeZ, 0, 0, scaleX, scaleY, scaleZ, elevations)) {
            this._heightField = null;
            return false;
        }
        const device = Application.instance.device;
        this._patchSize = patchSize;
        this._rootSizeX = rootSizeX;
        this._rootSizeZ = rootSizeZ;
        this._rootSize = nextPowerOf2(Math.max(rootSizeX - 1, rootSizeZ - 1)) + 1;
        this._scaleX = scaleX;
        this._scaleZ = scaleZ;
        // Create base vertex buffer
        const dimension = patchSize + 2; // with "skirts"
        const vertices = new Float32Array(dimension * dimension * 3);
        let offset = 0;
        // top skirt
        vertices[0] = 0;
        vertices[1] = 0;
        vertices[2] = 0;
        for(let i = 1; i < dimension - 1; ++i){
            vertices[3 * i + 0] = i - 1;
            vertices[3 * i + 1] = 0;
            vertices[3 * i + 2] = 0;
        }
        vertices[3 * (dimension - 1) + 0] = dimension - 3;
        vertices[3 * (dimension - 1) + 1] = 0;
        vertices[3 * (dimension - 1) + 2] = 0;
        offset += dimension * 3;
        for(let i = 1; i < dimension - 1; ++i, offset += dimension * 3){
            // left skirt
            vertices[offset + 0] = 0;
            vertices[offset + 1] = 0;
            vertices[offset + 2] = i - 1;
            // height
            for(let j = 1; j < dimension - 1; ++j){
                vertices[offset + 3 * j + 0] = j - 1;
                vertices[offset + 3 * j + 1] = 0;
                vertices[offset + 3 * j + 2] = i - 1;
            }
            // right skirt
            vertices[offset + (dimension - 1) * 3 + 0] = dimension - 3;
            vertices[offset + (dimension - 1) * 3 + 1] = 0;
            vertices[offset + (dimension - 1) * 3 + 2] = i - 1;
        }
        // bottom skirt
        vertices[offset + 0] = 0;
        vertices[offset + 1] = 0;
        vertices[offset + 2] = dimension - 3;
        for(let i = 1; i < dimension - 1; ++i){
            vertices[offset + 3 * i + 0] = i - 1;
            vertices[offset + 3 * i + 1] = 0;
            vertices[offset + 3 * i + 2] = dimension - 3;
        }
        vertices[offset + (dimension - 1) * 3 + 0] = dimension - 3;
        vertices[offset + (dimension - 1) * 3 + 1] = 0;
        vertices[offset + (dimension - 1) * 3 + 2] = dimension - 3;
        this._baseVertices = vertices;
        // Create base index buffer
        const indices = this.strip(vertexCacheSize);
        this._indices = device.createIndexBuffer(indices, {
            managed: true
        });
        const lineIndices = this.line(indices);
        this._indicesWireframe = device.createIndexBuffer(lineIndices, {
            managed: true
        });
        this._primitiveCount = indices.length - 2;
        this._primitiveType = 'triangle-strip';
        this._rootNode = new QuadtreeNode();
        const normals = this._heightField.normals;
        const normalMapBytes = new Uint8Array(normals.length * 4);
        for(let i = 0; i < normals.length; i++){
            const normal = normals[i];
            normalMapBytes[i * 4 + 0] = Math.floor((normal.x * 0.5 + 0.5) * 255);
            normalMapBytes[i * 4 + 1] = Math.floor((normal.y * 0.5 + 0.5) * 255);
            normalMapBytes[i * 4 + 2] = Math.floor((normal.z * 0.5 + 0.5) * 255);
            normalMapBytes[i * 4 + 3] = 255;
        }
        this._normalMap = device.createTexture2D('rgba8unorm', rootSizeX, rootSizeZ, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        this._normalMap.name = `TerrainNormalMap-${this._normalMap.uid}`;
        this._normalMap.update(normalMapBytes, 0, 0, this._normalMap.width, this._normalMap.height);
        return this._rootNode.initialize(this, null, 0, 0, this._baseVertices, normals, scaleY, elevations);
    }
    strip(vertexCacheSize) {
        const dimension = this._patchSize + 2;
        const step = (vertexCacheSize >> 1) - 1;
        const indices = [];
        for(let i = 0; i < dimension - 1; i += step){
            const start = i;
            const end = i + step > dimension - 1 ? dimension - 1 : i + step;
            for(let j = 0; j < dimension - 1; ++j){
                for(let k = start; k <= end; ++k){
                    indices.push((dimension - 1 - k) * dimension + j);
                    indices.push((dimension - 1 - k) * dimension + j + 1);
                }
                indices.push((dimension - 1 - end) * dimension + j + 1);
                indices.push(j == dimension - 2 ? (dimension - 1 - end) * dimension : (dimension - 1 - start) * dimension + j + 1);
            }
        }
        indices.length = indices.length - 2;
        return new Uint16Array(indices);
    }
    line(strip) {
        const numTris = strip.length - 2;
        const lineIndices = [];
        let lastSkipped = true;
        let a, b, c;
        for(let i = 0; i < numTris; i++){
            if (i % 2 === 0) {
                a = strip[i];
                b = strip[i + 1];
                c = strip[i + 2];
            } else {
                a = strip[i + 1];
                b = strip[i];
                c = strip[i + 2];
            }
            const thisSkipped = a === b || a === c || b === c;
            if (!thisSkipped) {
                if (lastSkipped) {
                    lineIndices.push(a, b);
                }
                lineIndices.push(b, c, c, a);
            }
            lastSkipped = thisSkipped;
        }
        return new Uint16Array(lineIndices);
    }
    setupCamera(viewportH, tanHalfFovy, maxPixelError) {
        this._rootNode?.setupCamera(viewportH, tanHalfFovy, maxPixelError);
    }
    getBoundingBox(bbox) {
        if (this._heightField) {
            bbox.minPoint = this._heightField.getBoundingbox().minPoint;
            bbox.maxPoint = this._heightField.getBoundingbox().maxPoint;
        } else {
            bbox.minPoint = Vector3.zero();
            bbox.maxPoint = Vector3.zero();
        }
    }
    getPatchSize() {
        return this._patchSize;
    }
    getRootSize() {
        return this._rootSize;
    }
    getRootSizeX() {
        return this._rootSizeX;
    }
    getRootSizeZ() {
        return this._rootSizeZ;
    }
    getTerrain() {
        return this._terrain;
    }
    getElevations() {
        return this._heightField?.getHeights() || null;
    }
    getScaleX() {
        return this._scaleX;
    }
    getScaleZ() {
        return this._scaleZ;
    }
    getIndices() {
        return this._indices;
    }
    getIndicesWireframe() {
        return this._indicesWireframe;
    }
    getPrimitiveCount() {
        return this._primitiveCount;
    }
    getPrimitiveType() {
        return this._primitiveType;
    }
    getHeightField() {
        return this._heightField;
    }
    /** @internal */ cull(visitor, viewPoint, worldMatrix) {
        if (this._rootNode && this._terrain) {
            const frustum = new Frustum(Matrix4x4.multiply(visitor.camera.viewProjectionMatrix, worldMatrix));
            return this.cull_r(visitor, this._rootNode, viewPoint, worldMatrix, frustum, true, false);
        }
        return 0;
    }
    /** @internal */ cull_r(visitor, node, viewPoint, worldMatrix, frustum, cliptest, ignorePatch) {
        const camera = visitor.camera;
        const bbox = node.getBoundingbox();
        let ret = 0;
        let clipState;
        if (cliptest) {
            clipState = camera.clipMask ? bbox.getClipStateWithFrustumMask(frustum, camera.clipMask) : bbox.getClipStateWithFrustum(frustum);
            if (clipState === ClipState.NOT_CLIPPED) {
                return ret;
            } else if (clipState === ClipState.A_INSIDE_B) {
                cliptest = false;
            }
        } else {
            clipState = ClipState.A_INSIDE_B;
        }
        if (!ignorePatch) {
            const ld = node.getPatch().isDummy() ? -1 : node.getPatch().getLODDistance();
            const lodDistance = ld >= 0 ? ld * ld : Number.MAX_VALUE;
            const eyeDistSq = ld >= 0 ? node.getPatch().sqrDistanceToPoint(viewPoint) : 0;
            if (eyeDistSq >= lodDistance || !node.getChild(0)) {
                if (!node.getPatch().isDummy()) {
                    visitor.push(camera, node.getPatch(), this._terrain.renderOrder);
                    ignorePatch = true;
                    ret = 1;
                }
            }
        }
        if (node.grassClusters.length > 0 && visitor.renderPass.type !== RENDER_PASS_TYPE_SHADOWMAP) {
            for (const grass of node.grassClusters){
                visitor.push(camera, grass, this._terrain.renderOrder);
            }
        }
        for(let i = 0; i < 4; i++){
            const child = node.getChild(i);
            if (child) {
                ret += this.cull_r(visitor, child, viewPoint, worldMatrix, frustum, cliptest, ignorePatch);
            }
        }
        /*
    if (eyeDistSq < lodDistance && node.getChild(0)) {
      for (let i = 0; i < 4; i++) {
        const child = node.getChild(i);
        if (child) {
          ret += this.cull_r(visitor, child, viewPoint, worldMatrix, frustum, cliptest, ignorePatch);
        }
      }
    } else if (!node.getPatch().isDummy()) {
      visitor.push(camera, node.getPatch(), this._terrain.renderOrder, this._terrain.castShadow, clipState, bbox);
      return 1;
    }
    */ /*
    if ((!node.getChild(0) || eyeDistSq >= lodDistance) && !node.getPatch().isDummy()) {
      visitor.push(camera, node.getPatch(), this._terrain.renderOrder, this._terrain.castShadow, clipState, bbox);
      ret = 1;
      ignorePatch = true;
    }
    if (node.grassCluster) {
      visitor.push(camera, node.grassCluster, this._terrain.renderOrder, this._terrain.castShadow, clipState, bbox);
    } else if (!ignorePatch) {
      for (let i = 0; i < 4; i++) {
        const child = node.getChild(i);
        if (child) {
          ret += this.cull_r(visitor, child, viewPoint, worldMatrix, frustum, cliptest, ignorePatch);
        }
      }
    }
    */ /*
    const drawPatch = !(eyeDistSq < lodDistance && node.getChild(0))
    if (
      eyeDistSq < lodDistance
      && node.getChild(0)
      && (lodLevel === 0 || node.getPatch().getMipLevel() < lodLevel)
    ) {
      for (let i = 0; i < 4; i++) {
        const child = node.getChild(i);
        if (child) {
          ret += this.cull_r(visitor, child, viewPoint, worldMatrix, frustum, cliptest);
        }
      }
    } else if (!node.getPatch().isDummy()) {
      visitor.push(camera, node.getPatch(), this._terrain.renderOrder, this._terrain.castShadow, clipState, bbox);
      return 1;
    }
    */ return ret;
    }
}

class GrassCluster {
    _primitive;
    _terrain;
    _numInstances;
    _material;
    constructor(device, terrain, baseVertexBuffer, indexBuffer, material, grassData){
        this._primitive = new Primitive();
        const instanceVertexBuffer = device.createVertexBuffer('tex1_f32x4', grassData);
        this._primitive.setVertexBuffer(baseVertexBuffer, 'vertex');
        this._primitive.setVertexBuffer(instanceVertexBuffer, 'instance');
        this._primitive.setIndexBuffer(indexBuffer);
        this._primitive.primitiveType = 'triangle-list';
        this._terrain = terrain;
        this._numInstances = grassData.length >> 2;
        this._material = material;
        this._material.stateSet.useRasterizerState().setCullMode('none');
    }
    getName() {
        return 'GrassCluster';
    }
    getXForm() {
        return this._terrain;
    }
    getInstanceColor() {
        return this._terrain.getInstanceColor();
    }
    getPickTarget() {
        return this._terrain;
    }
    getBoneMatrices() {
        return null;
    }
    getInvBindMatrix() {
        return null;
    }
    getSortDistance(camera) {
        return this._terrain.getSortDistance(camera);
    }
    getQueueType() {
        return this._terrain.grassMaterial.getQueueType();
    }
    isUnlit() {
        return !this._terrain.grassMaterial.supportLighting();
    }
    isBatchable() {
        return false;
    }
    draw(ctx) {
        this._material.alphaToCoverage = Application.instance.device.getFrameBufferSampleCount() > 1;
        this._material.alphaCutoff = this._material.alphaToCoverage ? 1 : 0.8;
        this._material.draw(this._primitive, ctx, this._numInstances);
    }
}
class GrassManager {
    _clusterSize;
    _baseVertexBuffer;
    _indexBuffer;
    _layers;
    constructor(clusterSize, density){
        this._clusterSize = clusterSize;
        this._baseVertexBuffer = new Map();
        this._indexBuffer = null;
        this._layers = [];
    }
    getBaseVertexBuffer(device, bladeWidth, bladeHeight) {
        const hash = `${bladeWidth}-${bladeHeight}`;
        let baseVertexBuffer = this._baseVertexBuffer.get(hash);
        if (baseVertexBuffer) {
            return baseVertexBuffer;
        }
        const r = bladeWidth * 0.5;
        const t = bladeHeight;
        const c = r * Math.cos(Math.PI / 3);
        const s = r * Math.sin(Math.PI / 3);
        const vertices = new Float32Array([
            r,
            0,
            0,
            0,
            1,
            r,
            t,
            0,
            0,
            0,
            -r,
            t,
            0,
            1,
            0,
            -r,
            0,
            0,
            1,
            1,
            c,
            0,
            s,
            0,
            1,
            -c,
            0,
            -s,
            1,
            1,
            -c,
            t,
            -s,
            1,
            0,
            c,
            t,
            s,
            0,
            0,
            -c,
            0,
            s,
            0,
            1,
            c,
            0,
            -s,
            1,
            1,
            c,
            t,
            -s,
            1,
            0,
            -c,
            t,
            s,
            0,
            0
        ]);
        baseVertexBuffer = device.createInterleavedVertexBuffer([
            'position_f32x3',
            'tex0_f32x2'
        ], vertices);
        this._baseVertexBuffer.set(hash, baseVertexBuffer);
        return baseVertexBuffer;
    }
    getIndexBuffer(device) {
        if (!this._indexBuffer) {
            this._indexBuffer = device.createIndexBuffer(new Uint16Array([
                0,
                1,
                2,
                0,
                2,
                3,
                4,
                5,
                6,
                4,
                6,
                7,
                8,
                9,
                10,
                8,
                10,
                11
            ]));
        }
        return this._indexBuffer;
    }
    addGrassLayer(device, terrain, density, bladeWidth, bladeHeigh, offset, grassTexture) {
        const densityHeight = density.length;
        const densityWidth = density[0].length;
        const hfScale = terrain.heightFieldScale;
        this._clusterSize = Math.min(nextPowerOf2(this._clusterSize), terrain.width - 1, terrain.height - 1);
        let layer = null;
        terrain.traverseQuadtree((node)=>{
            const size = node.getPatch().getStep() * (terrain.patchSize - 1);
            if (size === this._clusterSize) {
                const bbox = node.getPatch().getBoundingBox();
                const grassData = [];
                const minX = bbox.minPoint.x;
                const minZ = bbox.minPoint.z;
                let index = 0;
                for(let i = 0; i < this._clusterSize; i++){
                    for(let j = 0; j < this._clusterSize; j++){
                        const x0 = minX + j * hfScale.x;
                        const z0 = minZ + i * hfScale.z;
                        const x1 = x0 + hfScale.x;
                        const z1 = z0 + hfScale.z;
                        const u = x0 / terrain.scaledWidth;
                        const v = z0 / terrain.scaledHeight;
                        const du = densityWidth * u >> 0;
                        const dv = densityHeight * v >> 0;
                        const val = density[dv][du] * hfScale.x * hfScale.z;
                        let grassCount = 0;
                        if (val > 0) {
                            if (val < 1) {
                                grassCount = Math.random() <= val ? 1 : 0;
                            } else {
                                grassCount = val >> 0;
                            }
                        }
                        //const grassCount = (this._density[dv][du] * hfScale.x * hfScale.z) >> 0;
                        for(let k = 0; k < grassCount; k++){
                            const x = Math.random() * (x1 - x0) + x0;
                            const z = Math.random() * (z1 - z0) + z0;
                            const y = terrain.getElevation(x, z);
                            const rot = Math.random() * Math.PI * 2;
                            grassData[index++] = x;
                            grassData[index++] = y + offset;
                            grassData[index++] = z;
                            grassData[index++] = rot;
                        }
                    }
                }
                if (grassData.length > 0) {
                    if (!layer) {
                        layer = {
                            material: new GrassMaterial(new Vector2(terrain.scaledWidth, terrain.scaledHeight), terrain.quadtree.normalMap, grassTexture),
                            clusters: new Map()
                        };
                        this._layers.push(layer);
                    }
                    const cluster = new GrassCluster(device, terrain, this.getBaseVertexBuffer(device, bladeWidth, bladeHeigh), this.getIndexBuffer(device), layer.material, new Float32Array(grassData));
                    layer.clusters.set(node, cluster);
                    //const cluster = new GrassCluster(device, terrain, this.getBaseVertexBuffer(device, bladeWidth, bladeHeigh), this.getIndexBuffer(device), grassTexture, new Float32Array(grassData));
                    node.grassClusters.push(cluster);
                }
            }
        });
        return layer;
    }
} /*
function interpolate(val: number, oldMin: number, oldMax: number, newMin: number, newMax: number) {
  return ((val - oldMin) * (newMax - newMin)) / (oldMax - oldMin) + newMin
}

function createGrassBladePrimitive(device: AbstractDevice) {
  const p = new Primitive();
  const positions: number[] = [];
  const uvs: number[] = [];
  const indices: number[] = [];
}

function getPrimitive(device: AbstractDevice): Primitive {
  if (!primitive) {
    primitive = new Primitive();
    const vertices: number[] = [-0.1, 0, 0, 0.1, 0, 0, 0.1, 0.8, 0, -0.1, 0.8, 0];
    const indices: number[] = [0, 1, 2, 0, 2, 3, 0, 2, 1, 0, 3, 2];
    const vb = device.createInterleavedVertexBuffer(['position_f32x3', 'normal_f32x3', 'tex0_f32x2'], new Float32Array(vertices));
    const ib = device.createIndexBuffer(new Uint16Array(indices));
    primitive.setVertexBuffer(vb);
    primitive.setIndexBuffer(ib)
    primitive.indexStart = 0;
    primitive.indexCount = indices.length;
    primitive.primitiveType = 'triangle-list';
  }
  return primitive;
}
*/

/**
 * Terrain node
 * @public
 */ class Terrain extends GraphNode {
    /** @internal */ _quadtree;
    /** @internal */ _grassManager;
    /** @internal */ _maxPixelError;
    /** @internal */ _maxPixelErrorDirty;
    /** @internal */ _lodCamera;
    /** @internal */ _heightFieldScale;
    /** @internal */ _patchSize;
    /** @internal */ _lastTanHalfFOVY;
    /** @internal */ _width;
    /** @internal */ _height;
    /** @internal */ _material;
    /** @internal */ _grassMaterial;
    /** @internal */ _wireframe;
    /** @internal */ _viewPoint;
    /** @internal */ _castShadow;
    /** @internal */ _instanceColor;
    /** @internal */ _overridenStateSet;
    /**
   * Creates an instance of Terrain
   * @param scene - The scene to which the terrain belongs
   */ constructor(scene){
        super(scene);
        this._quadtree = null;
        this._grassManager = null;
        this._maxPixelError = 10;
        this._maxPixelErrorDirty = true;
        this._lodCamera = null;
        this._heightFieldScale = Vector3.one();
        this._patchSize = 33;
        this._lastTanHalfFOVY = 0;
        this._width = 0;
        this._height = 0;
        this._material = null;
        this._grassMaterial = null;
        this._wireframe = false;
        this._viewPoint = null;
        this._castShadow = true;
        this._instanceColor = Vector4.zero();
        this._overridenStateSet = null;
    }
    /** @internal */ get quadtree() {
        return this._quadtree;
    }
    /**
   * {@inheritDoc Drawable.getName}
   */ getName() {
        return this._name;
    }
    /**
   * {@inheritDoc Drawable.getInstanceColor}
   */ getInstanceColor() {
        return this._instanceColor;
    }
    /** Wether the mesh node casts shadows */ get castShadow() {
        return this._castShadow;
    }
    set castShadow(val) {
        this._castShadow = !!val;
    }
    /** The maximum pixel error for terrain LOD */ get maxPixelError() {
        return this._maxPixelError;
    }
    set maxPixelError(val) {
        if (val !== this._maxPixelError) {
            this._maxPixelError = val;
            this._maxPixelErrorDirty = true;
        }
    }
    /** Camera that will be used to compute LOD level of terrain patches */ get LODCamera() {
        return this._lodCamera;
    }
    set LODCamera(camera) {
        this._lodCamera = camera;
    }
    /** Scaled terrain width */ get scaledWidth() {
        return this._width * this._heightFieldScale.x;
    }
    /** Scaled terrain height */ get scaledHeight() {
        return this._height * this._heightFieldScale.z;
    }
    /** Scale value of the height field */ get heightFieldScale() {
        return this._heightFieldScale;
    }
    /** @internal */ get patchSize() {
        return this._patchSize;
    }
    /** Width of the terrain */ get width() {
        return this._width;
    }
    /** Height of the terrain */ get height() {
        return this._height;
    }
    /** Material of the terrain */ get material() {
        return this._material;
    }
    /** Grass material */ get grassMaterial() {
        return this._grassMaterial;
    }
    /** Whether the terrain should be rendered in wireframe mode */ get wireframe() {
        return this._wireframe;
    }
    set wireframe(b) {
        this._wireframe = !!b;
    }
    /** Normal map of the terrain */ get normalMap() {
        return this._quadtree.normalMap;
    }
    /** @internal */ get overridenStateSet() {
        return this._overridenStateSet;
    }
    /**
   * Creates the terrain
   *
   * @param sizeX - Terrain size in X axis
   * @param sizeZ - Terrain size in Z axis
   * @param elevations - Elevation data of the terrain
   * @param scale - Scale of the terrain
   * @param patchSize - Patch size of the terrain
   * @returns true if succeeded
   */ create(sizeX, sizeZ, elevations, scale, patchSize, options) {
        this._quadtree = new Quadtree(this);
        if (options?.splatMap && options.splatMap.format !== 'rgba8unorm') {
            throw new Error('SplatMap must be rgba8unorm format');
        }
        this._material = new TerrainMaterial(options);
        if (!this._quadtree.build(patchSize, sizeX, sizeZ, elevations, scale.x, scale.y, scale.z, 24)) {
            this._quadtree = null;
            return false;
        }
        this._patchSize = patchSize;
        this._heightFieldScale.set(scale);
        this._width = sizeX;
        this._height = sizeZ;
        this._material.normalTexture = this._quadtree.normalMap;
        this._material.normalTexCoordIndex = -1;
        this._material.terrainInfo = new Vector4(this.scaledWidth, this.scaledHeight, 0, 0);
        this._overridenStateSet = Application.instance.device.createRenderStateSet();
        this._overridenStateSet.useRasterizerState().setCullMode('front');
        this.invalidateBoundingVolume();
        // create grass layers
        if (options?.splatMap && options?.detailMaps?.grass) {
            if (options.detailMaps.grass.findIndex((a)=>a && a.findIndex((b)=>!!b) >= 0) >= 0) {
                const splatMap = options.splatMap;
                const data = new Uint8Array(splatMap.width * splatMap.height * 4);
                splatMap.readPixels(0, 0, splatMap.width, splatMap.height, 0, 0, data).then(()=>{
                    for(let detail = 0; detail < 4; detail++){
                        if (options.detailMaps.grass[detail]) {
                            for (const grass of options.detailMaps.grass[detail]){
                                if (grass) {
                                    const d = grass.density ?? 1;
                                    const bladeWidth = grass.bladeWidth ?? 4;
                                    const bladeHeight = grass.bladeHeigh ?? 2;
                                    const offset = grass.offset ?? 0;
                                    const grassTexture = grass.texture ?? null;
                                    const density = [];
                                    for(let i = 0; i < splatMap.height; i++){
                                        const row = [];
                                        for(let j = 0; j < splatMap.width; j++){
                                            const val = data[i * 4 * splatMap.width + j * 4 + detail] / 255;
                                            row.push(val * d);
                                        }
                                        density.push(row);
                                    }
                                    this.createGrass(density, bladeWidth, bladeHeight, offset, grassTexture);
                                }
                            }
                        }
                    }
                });
            }
        }
        return true;
    }
    /**
   * Create grass fields
   * @param maxGrassPerCell - Maximum number of grasses in a cell (world space 1x1)
   * @param density - The density map
   */ createGrass(density, bladeWidth, bladeHeight, offset, grassTexture) {
        if (!this._grassManager) {
            this._grassManager = new GrassManager(64, density);
        }
        if (!this._grassMaterial) {
            this._grassMaterial = new GrassMaterial(new Vector2(this.scaledWidth, this.scaledHeight), this._quadtree.normalMap, grassTexture);
        }
        this._grassMaterial.stateSet.useRasterizerState().setCullMode('none');
        this._grassManager.addGrassLayer(Application.instance.device, this, density, bladeWidth, bladeHeight, offset, grassTexture);
    }
    /** Get elevation at specified position in terrain coordinate space */ getElevation(x, z) {
        return this._quadtree.getHeightField().getRealHeight(x, z);
    }
    /** Get normal at specified position in terrain coordinate space */ getNormal(x, z, normal) {
        return this._quadtree.getHeightField().getRealNormal(x, z, normal);
    }
    /** Get intersection distance by a ray in terrain coordinate space */ rayIntersect(ray) {
        return this._quadtree.getHeightField().rayIntersect(ray);
    }
    /**
   * {@inheritDoc SceneNode.computeBoundingVolume}
   * @override
   */ computeBoundingVolume(bv) {
        return this._quadtree ? this._quadtree.getHeightField().getBBoxTree().getRootNode().bbox : null;
    }
    /**
   * Traverse quadtree node top down
   * @param callback - the callback function
   */ traverseQuadtree(callback) {
        function visitQuadtreeNode_r(node) {
            callback(node);
            for(let i = 0; i < 4; i++){
                const child = node.getChild(i);
                if (child) {
                    visitQuadtreeNode_r(child);
                }
            }
        }
        const rootNode = this._quadtree.rootNode;
        if (rootNode) {
            visitQuadtreeNode_r(this._quadtree.rootNode);
        }
    }
    /** @internal */ cull(cullVisitor) {
        const tanHalfFovy = cullVisitor.primaryCamera.getTanHalfFovy();
        if (tanHalfFovy !== this._lastTanHalfFOVY || this._maxPixelErrorDirty) {
            this._maxPixelErrorDirty = false;
            this._lastTanHalfFOVY = tanHalfFovy;
            this._quadtree.setupCamera(1024, tanHalfFovy, this._maxPixelError);
        }
        const worldEyePos = cullVisitor.primaryCamera.getWorldPosition();
        this._viewPoint = this.invWorldMatrix.transformPointAffine(worldEyePos);
        return this._quadtree.cull(cullVisitor, this._viewPoint, this.worldMatrix);
    }
    /**
   * {@inheritDoc SceneNode.isTerrain}
   * @override
   */ isTerrain() {
        return true;
    }
}

/**
 * Animation set
 * @public
 */ class AnimationSet {
    /** @internal */ _animations;
    /** @internal */ _scene;
    /**
   * Creates an instance of AnimationSet
   * @param scene - The scene to which the animation set belongs
   */ constructor(scene){
        this._scene = scene;
        this._scene.animationSet.push(this);
        this._animations = {};
    }
    /**
   * How many animations in this set
   */ get numAnimations() {
        return Object.getOwnPropertyNames(this._animations).length;
    }
    /**
   * Gets an animation clip by name
   * @param name - name of the animation to get
   */ get(name) {
        return this._animations[name] ?? null;
    }
    /**
   * Adds an animation
   */ add(animation) {
        this._animations[animation.name] = animation;
    }
    /**
   * Gets names of all the animations of the model
   * @returns An array of string that contains the animation names
   */ getAnimationNames() {
        return Object.keys(this._animations);
    }
    /**
   * Updates all animations of the model
   */ update() {
        for(const k in this._animations){
            this._animations[k].update();
        }
    }
    /**
   * Checks whether an animation is playing
   * @param name - Name of the animation to be checked
   * @returns true if the animation is playing, otherwise false
   */ isPlayingAnimation(name) {
        if (name) {
            return this._animations[name]?.isPlaying();
        } else {
            for(const k in this._animations){
                if (this._animations[k].isPlaying()) {
                    return true;
                }
            }
            return false;
        }
    }
    /**
   * Starts playing an animation of the model
   * @param name - Name of the animation to play
   * @param repeat - The repeat times, 0 for always repeating, default is 1
   * @param ratio - The speed ratio, default is 1. Use negative value to play backwards
   */ playAnimation(name, repeat = 0, speedRatio = 1) {
        const ani = this._animations[name];
        if (ani && !ani.isPlaying()) {
            for (const name of this.getAnimationNames()){
                if (this.isPlayingAnimation(name)) {
                    this.stopAnimation(name);
                }
            }
            ani.play(repeat, speedRatio);
        }
    }
    /**
   * Stops playing an animation of the model
   * @param name - Name of the animation to stop playing
   */ stopAnimation(name) {
        this._animations[name]?.stop();
    }
    dispose() {
        const index = this._scene.animationSet.indexOf(this);
        if (index >= 0) {
            this._scene.animationSet.splice(index, 1);
        }
        for(const k in this._animations){
            this._animations[k].dispose();
        }
        this._animations = {};
    }
}

/**
 * Base class for any kind of animation track
 * @public
 */ class AnimationTrack {
    /** @internal */ _interpolator;
    /** @internal */ _currentPlayTime;
    /** @internal */ _playing;
    /**
   * Creates a new animation track
   * @param interpolator - Interpolator for the track
   */ constructor(interpolator){
        this._currentPlayTime = 0;
        this._playing = false;
        this._interpolator = interpolator;
    }
    /** Gets the interpolator of the track */ get interpolator() {
        return this._interpolator;
    }
    /** Return true if the track is playing, otherwise false */ get playing() {
        return this._playing;
    }
    /** Starts playing the track */ start() {
        this._playing = true;
    }
    /** Stops playing the track */ stop() {
        this._playing = false;
    }
    /** Rewinds the track to the first frame */ rewind() {
        this._currentPlayTime = 0;
    }
    /** Stops playing the track and rewind to the first frame */ reset() {
        this.stop();
        this._currentPlayTime = 0;
    }
}

// Reduce gc
const tmpVec3$1 = new Vector3();
/**
 * Translate animation track
 * @public
 */ class TranslationTrack extends AnimationTrack {
    constructor(modeOrInterpolator, keyFrames){
        if (modeOrInterpolator instanceof Interpolator) {
            if (modeOrInterpolator.target !== 'vec3') {
                throw new Error(`TranslationTrack(): interpolator target must be 'vec3'`);
            }
            super(modeOrInterpolator);
        } else {
            const inputs = new Float32Array(keyFrames.map((val)=>val.time));
            const outputs = new Float32Array(keyFrames.length * 3);
            for(let i = 0; i < keyFrames.length; i++){
                outputs[i * 3 + 0] = keyFrames[i].value.x;
                outputs[i * 3 + 1] = keyFrames[i].value.y;
                outputs[i * 3 + 2] = keyFrames[i].value.z;
            }
            const interpolator = new Interpolator(modeOrInterpolator, 'vec3', inputs, outputs);
            super(interpolator);
        }
    }
    /** {@inheritDoc AnimationTrack.apply} */ apply(node, currentTime, duration) {
        this._interpolator.interpolate(currentTime, duration, tmpVec3$1);
        node.position.set(tmpVec3$1);
        return true;
    }
}

// Reduce gc
const tmpQuat = new Quaternion();
/**
 * Rotation animation track
 * @public
 */ class RotationTrack extends AnimationTrack {
    constructor(modeOrInterpolator, keyFrames){
        if (modeOrInterpolator instanceof Interpolator) {
            if (modeOrInterpolator.target !== 'quat') {
                throw new Error(`RotationTrack(): interpolator target must be 'quat'`);
            }
            super(modeOrInterpolator);
        } else {
            const inputs = new Float32Array(keyFrames.map((val)=>val.time));
            const outputs = new Float32Array(keyFrames.length * 4);
            for(let i = 0; i < keyFrames.length; i++){
                outputs[i * 4 + 0] = keyFrames[i].value.x;
                outputs[i * 4 + 1] = keyFrames[i].value.y;
                outputs[i * 4 + 2] = keyFrames[i].value.z;
                outputs[i * 4 + 3] = keyFrames[i].value.w;
            }
            const interpolator = new Interpolator(modeOrInterpolator, 'quat', inputs, outputs);
            super(interpolator);
        }
    }
    /** {@inheritDoc AnimationTrack.apply} */ apply(node, currentTime, duration) {
        this._interpolator.interpolate(currentTime, duration, tmpQuat);
        node.rotation.set(tmpQuat);
        return true;
    }
}

new Vector3();
new Quaternion();

// Reduce gc
const tmpVec3 = new Vector3();
/**
 * Scale animation track
 * @public
 */ class ScaleTrack extends AnimationTrack {
    constructor(modeOrInterpolator, keyFrames){
        if (modeOrInterpolator instanceof Interpolator) {
            if (modeOrInterpolator.target !== 'vec3') {
                throw new Error(`ScaleTrack(): interpolator target must be 'vec3'`);
            }
            super(modeOrInterpolator);
        } else {
            const inputs = new Float32Array(keyFrames.map((val)=>val.time));
            const outputs = new Float32Array(keyFrames.length * 3);
            for(let i = 0; i < keyFrames.length; i++){
                outputs[i * 3 + 0] = keyFrames[i].value.x;
                outputs[i * 3 + 1] = keyFrames[i].value.y;
                outputs[i * 3 + 2] = keyFrames[i].value.z;
            }
            const interpolator = new Interpolator(modeOrInterpolator, 'vec3', inputs, outputs);
            super(interpolator);
        }
    }
    /** {@inheritDoc AnimationTrack.apply} */ apply(node, currentTime, duration) {
        this._interpolator.interpolate(currentTime, duration, tmpVec3);
        node.scale.set(tmpVec3);
        return true;
    }
}

const tmpV0 = new Vector3();
const tmpV1 = new Vector3();
const tmpV2 = new Vector3();
const tmpV3 = new Vector3();
/**
 * Skeleton for skinned animation
 * @public
 */ class Skeleton {
    /** @internal */ _joints;
    /** @internal */ _inverseBindMatrices;
    /** @internal */ _bindPoseMatrices;
    /** @internal */ _jointMatrices;
    /** @internal */ _jointMatrixArray;
    /** @internal */ _jointTexture;
    /**
   * Creates an instance of skeleton
   * @param joints - The joint nodes
   * @param inverseBindMatrices - The inverse binding matrices of the joints
   * @param bindPoseMatrices - The binding pose matrices of the joints
   */ constructor(joints, inverseBindMatrices, bindPoseMatrices){
        this._joints = joints;
        this._inverseBindMatrices = inverseBindMatrices;
        this._bindPoseMatrices = bindPoseMatrices;
        this._jointMatrixArray = null;
        this._jointMatrices = null;
        this._jointTexture = null;
    }
    /**
   * Disposes self
   */ dispose() {
        this._jointTexture?.dispose();
        this._jointTexture = null;
        this._joints = null;
        this._inverseBindMatrices = null;
        this._bindPoseMatrices = null;
        this._jointMatrices = null;
        this._jointMatrixArray = null;
    }
    /**
   * The joint transform matrices
   */ get jointMatrices() {
        return this._jointMatrices;
    }
    /**
   * The texture that contains the transform matrices of all the joints
   */ get jointTexture() {
        return this._jointTexture;
    }
    /** @internal */ updateJointMatrices(jointTransforms) {
        if (!this._jointTexture) {
            this._createJointTexture();
        }
        for(let i = 0; i < this._joints.length; i++){
            const mat = this._jointMatrices[i];
            Matrix4x4.multiply(jointTransforms ? jointTransforms[i] : this._joints[i].worldMatrix, this._inverseBindMatrices[i], mat);
        }
    }
    /** @internal */ computeBindPose() {
        this.updateJointMatrices(this._bindPoseMatrices);
        this._jointTexture.update(this._jointMatrixArray, 0, 0, this._jointTexture.width, this._jointTexture.height);
    }
    /** @internal */ computeJoints() {
        this.updateJointMatrices();
        this._jointTexture.update(this._jointMatrixArray, 0, 0, this._jointTexture.width, this._jointTexture.height);
    }
    /** @internal */ computeBoundingBox(info, invWorldMatrix) {
        info.boundingBox.beginExtend();
        for(let i = 0; i < info.boundingVertices.length; i++){
            this._jointMatrices[info.boundingVertexBlendIndices[i * 4 + 0]].transformPointAffine(info.boundingVertices[i], tmpV0).scaleBy(info.boundingVertexJointWeights[i * 4 + 0]);
            this._jointMatrices[info.boundingVertexBlendIndices[i * 4 + 1]].transformPointAffine(info.boundingVertices[i], tmpV1).scaleBy(info.boundingVertexJointWeights[i * 4 + 1]);
            this._jointMatrices[info.boundingVertexBlendIndices[i * 4 + 2]].transformPointAffine(info.boundingVertices[i], tmpV2).scaleBy(info.boundingVertexJointWeights[i * 4 + 2]);
            this._jointMatrices[info.boundingVertexBlendIndices[i * 4 + 3]].transformPointAffine(info.boundingVertices[i], tmpV3).scaleBy(info.boundingVertexJointWeights[i * 4 + 3]);
            tmpV0.addBy(tmpV1).addBy(tmpV2).addBy(tmpV3);
            invWorldMatrix.transformPointAffine(tmpV0, tmpV0);
            info.boundingBox.extend(tmpV0);
        }
    }
    /** @internal */ _createJointTexture() {
        const textureWidth = nextPowerOf2(Math.max(4, Math.ceil(Math.sqrt(this._joints.length * 4))));
        this._jointTexture = Application.instance.device.createTexture2D('rgba32f', textureWidth, textureWidth, {
            samplerOptions: {
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none'
            }
        });
        this._jointMatrixArray = new Float32Array(textureWidth * textureWidth * 4);
        const buffer = this._jointMatrixArray.buffer;
        this._jointMatrices = this._joints.map((val, index)=>new Matrix4x4(buffer, index * 16 * Float32Array.BYTES_PER_ELEMENT));
    }
}

/**
 * Perspective camera class
 * @public
 */ class PerspectiveCamera extends Camera {
    /** @internal */ _near;
    _far;
    _fovY;
    _aspect;
    _window;
    /**
   * Creates an instance of PerspectiveCamera
   * @param scene - The scene that the camera belongs to.
   * @param fovY - A radian value indicates the field of view in Y axis
   * @param aspect - Aspect ratio of the perspective transform
   * @param near - The near clip plane
   * @param far - The far clip plane
   */ constructor(scene, fovY, aspect, near, far){
        super(scene);
        this._fovY = fovY;
        this._aspect = aspect;
        this._near = near;
        this._far = far;
        this._window = null;
        this._invalidate(true);
    }
    /** Sub-window of the frustum */ get window() {
        return this._window;
    }
    set window(val) {
        this._window = val ?? null;
        this._invalidate(true);
    }
    /** The near clip plane */ get near() {
        return this._near;
    }
    set near(val) {
        if (val !== this._near) {
            this._near = val;
            this._invalidate(true);
        }
    }
    /** The far clip plane */ get far() {
        return this._far;
    }
    set far(val) {
        if (val !== this._far) {
            this._far = val;
            this._invalidate(true);
        }
    }
    /** Radian value indicates the field of view in Y axis */ get fovY() {
        return this._fovY;
    }
    set fovY(val) {
        if (val === 0) {
            debugger;
        }
        if (val !== this._fovY) {
            this._fovY = val;
            this._invalidate(true);
        }
    }
    /** Aspect ratio of the perspective transform */ get aspect() {
        return this._aspect;
    }
    set aspect(val) {
        if (val !== this._aspect) {
            this._aspect = val;
            this._invalidate(true);
        }
    }
    /**
   * {@inheritDoc Camera.setPerspective}
   */ setPerspective(fovY, aspect, zNear, zFar) {
        if (fovY === 0) {
            debugger;
        }
        this._aspect = aspect;
        this._fovY = fovY;
        this._near = zNear;
        this._far = zFar;
        this._invalidate(true);
        return this;
    }
    /**
   * Not valid for PerspectiveCamera
   *
   * @remarks
   * This method is only valid for {@link Camera} class or {@link OrthoCamera} class.
   */ setOrtho(left, right, bottom, top, near, far) {
        throw new Error(`setOrtho() not allowed on PerspectiveCamera`);
    }
    /**
   * Setup a projection matrix for the camera
   * @param matrix - The projection matrix
   */ setProjectionMatrix(matrix) {
        if (matrix && matrix !== this._projMatrix && matrix.isPerspective()) {
            if (matrix.getFov() === 0) {
                debugger;
            }
            this._aspect = matrix.getAspect();
            this._fovY = matrix.getFov();
            this._near = matrix.getNearPlane();
            this._far = matrix.getFarPlane();
            this._invalidate(true);
        } else {
            throw new Error(`PerspectiveCamera.setProjectionMatrix(): param is not a perspective projection matrix`);
        }
    }
    /** @internal */ _computeProj() {
        const h = this._near * Math.tan(this._fovY * 0.5);
        const w = h * this._aspect;
        let left = -w;
        let right = w;
        let top = h;
        let bottom = -h;
        if (this._window) {
            const width = right - left;
            const height = top - bottom;
            left += width * this._window[0];
            bottom += height * this._window[1];
            right = left + width * this._window[2];
            top = bottom + height * this._window[3];
        }
        this._projMatrix.frustum(left, right, bottom, top, this._near, this._far);
    //this._projMatrix.perspective(this._fovY, this._aspect, this._near, this._far);
    }
}

/**
 * Base class for any kind of camera controllers
 * @public
 */ class BaseCameraController {
    /** @internal */ _camera;
    /**
   * Creates an instance of BaseCameraController
   */ constructor(){
        this._camera = null;
        this.reset();
    }
    /** @internal */ _getCamera() {
        return this._camera;
    }
    /** @internal */ _setCamera(camera) {
        if (this._camera !== camera) {
            this._camera = camera;
            this.reset();
        }
    }
    /**
   * Resets state
   */ reset() {}
    /** @internal */ onMouseDown(evt) {
        return this._onMouseDown(evt);
    }
    /** @internal */ onMouseUp(evt) {
        return this._onMouseUp(evt);
    }
    /** @internal */ onMouseWheel(evt) {
        return this._onMouseWheel(evt);
    }
    /** @internal */ onMouseMove(evt) {
        return this._onMouseMove(evt);
    }
    /** @internal */ onKeyDown(evt) {
        return this._onKeyDown(evt);
    }
    /** @internal */ onKeyUp(evt) {
        return this._onKeyUp(evt);
    }
    /**
   * Updates state
   */ update() {}
    /**
   * Mouse down event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseDown(evt) {
        return false;
    }
    /**
   * Mouse up event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseUp(evt) {
        return false;
    }
    /**
   * Mouse wheel event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseWheel(evt) {
        return false;
    }
    /**
   * Mouse move event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseMove(evt) {
        return false;
    }
    /**
   * Key down event handler
   * @param evt - Keyboard event
   * @returns Boolean value indices whether this event was handled
   */ _onKeyDown(evt) {
        return false;
    }
    /**
   * Key up event handler
   * @param evt - Keyboard event
   * @returns Boolean value indices whether this event was handled
   */ _onKeyUp(evt) {
        return false;
    }
}

/**
 * Orbit camera controller
 * @public
 */ class OrbitCameraController extends BaseCameraController {
    /** @internal */ options;
    /** @internal */ mouseDown;
    /** @internal */ lastMouseX;
    /** @internal */ lastMouseY;
    /** @internal */ rotateX;
    /** @internal */ rotateY;
    /** @internal */ eyePos;
    /** @internal */ upVector;
    /** @internal */ xVector;
    /** @internal */ target;
    /** @internal */ direction;
    /** @internal */ quat;
    /** @internal */ scale;
    /**
   * Creates an instance of OrbitCameraController
   * @param options - The creation options
   */ constructor(options){
        super();
        this.options = Object.assign({
            center: Vector3.zero(),
            distance: 1,
            damping: 0.1,
            moveSpeed: 0.2,
            rotateSpeed: 0.01,
            zoomSpeed: 1
        }, options || {});
        this.rotateX = 0;
        this.rotateY = 0;
        this.eyePos = new Vector3();
        this.upVector = Vector3.axisPY();
        this.xVector = new Vector3();
        this.target = new Vector3();
        this.direction = new Vector3();
        this.quat = new Quaternion();
        this.scale = 1;
    }
    /** Rotation center */ get center() {
        return this.options.center;
    }
    set center(val) {
        this.options.center.set(val);
    }
    /**
   * {@inheritDoc BaseCameraController.reset}
   * @override
   */ reset() {
        this.mouseDown = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.rotateX = 0;
        this.rotateY = 0;
        this.upVector = Vector3.axisPY();
        this.scale = 1;
        this._loadCameraParams();
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseDown}
   * @override
   */ _onMouseDown(evt) {
        if (evt.button === 0) {
            this.mouseDown = true;
            this.lastMouseX = evt.offsetX;
            this.lastMouseY = evt.offsetY;
            this.rotateX = 0;
            this.rotateY = 0;
            return true;
        }
        return false;
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseUp}
   * @override
   */ _onMouseUp(evt) {
        if (evt.button === 0 && this.mouseDown) {
            this.mouseDown = false;
            return true;
        }
        return false;
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseWheel}
   * @override
   */ _onMouseWheel(evt) {
        const factor = Math.pow(0.9, Math.abs(this.options.zoomSpeed));
        if (evt.deltaY > 0) {
            this.scale /= factor;
        } else {
            this.scale *= factor;
        }
        return true;
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseMove}
   * @override
   */ _onMouseMove(evt) {
        if (this.mouseDown) {
            const dx = evt.offsetX - this.lastMouseX;
            const dy = evt.offsetY - this.lastMouseY;
            this.lastMouseX = evt.offsetX;
            this.lastMouseY = evt.offsetY;
            this.rotateX -= dy * this.options.rotateSpeed;
            this.rotateY -= dx * this.options.rotateSpeed;
            return true;
        }
        return false;
    }
    /** @internal */ _loadCameraParams() {
        const camera = this._getCamera();
        if (camera) {
            this.eyePos = this._getCamera().position;
            this.target.set(this.options.center);
            camera.lookAt(this.eyePos, this.target, this.upVector);
            Vector3.sub(this.eyePos, this.target, this.direction);
            this.options.distance = this.direction.magnitude;
            this.direction.inplaceNormalize();
            const mat = this._getCamera().localMatrix;
            this.xVector.setXYZ(mat[0], mat[1], mat[2]);
        }
    }
    /**
   * Set options
   * @param opt - options
   */ setOptions(opt) {
        opt && Object.assign(this.options, opt);
        this.reset();
    }
    /**
   * {@inheritDoc BaseCameraController.update}
   * @override
   */ update() {
        if (this._getCamera()) {
            const dx = this.options.center.x - this.target.x;
            const dy = this.options.center.y - this.target.y;
            const dz = this.options.center.z - this.target.z;
            this.eyePos.x += dx;
            this.eyePos.y += dy;
            this.eyePos.z += dz;
            this.target.set(this.options.center);
            Quaternion.fromAxisAngle(this.xVector, this.rotateX, this.quat);
            this.quat.transform(this.eyePos.subBy(this.target), this.eyePos);
            Quaternion.fromEulerAngle(0, this.rotateY, 0, 'XYZ', this.quat);
            this.quat.transform(this.eyePos, this.eyePos);
            this.quat.transform(this.xVector, this.xVector).inplaceNormalize();
            Vector3.normalize(this.eyePos, this.direction).inplaceNormalize();
            Vector3.cross(this.direction, this.xVector, this.upVector).inplaceNormalize();
            Vector3.add(this.target, Vector3.scale(this.direction, this.options.distance * this.scale), this.eyePos);
            this._getCamera().lookAt(this.eyePos, this.target, this.upVector);
            // this._loadCameraParams();
            if (this.mouseDown) {
                this.rotateX = 0;
                this.rotateY = 0;
            } else {
                this.rotateX *= 1 - this.options.damping;
                this.rotateY *= 1 - this.options.damping;
                if (Math.abs(this.rotateX) < 0.0001) {
                    this.rotateX = 0;
                }
                if (Math.abs(this.rotateY) < 0.0001) {
                    this.rotateY = 0;
                }
            }
        }
    }
}

/**
 * Named object interface for model loading
 * @public
 */ class NamedObject {
    name;
    /**
   * Creates an instance of NamedObject
   * @param name - Name of the object
   */ constructor(name){
        this.name = name;
    }
}
/**
 * Heirarchical node interface for model loading
 * @public
 */ class AssetHierarchyNode extends NamedObject {
    _parent;
    _position;
    _rotation;
    _scaling;
    _mesh;
    _skeleton;
    _attachToSkeleton;
    _attachIndex;
    _meshAttached;
    _matrix;
    _worldMatrix;
    _children;
    /**
   * Creates an instance of AssetHierarchyNode
   * @param name - Name of the node
   * @param parent - Parent of the node
   */ constructor(name, parent){
        super(name);
        this._parent = null;
        this._position = Vector3.zero();
        this._rotation = Quaternion.identity();
        this._scaling = Vector3.one();
        this._children = [];
        this._mesh = null;
        this._skeleton = null;
        this._attachToSkeleton = null;
        this._meshAttached = false;
        this._attachIndex = -1;
        this._matrix = null;
        this._worldMatrix = null;
        parent?.addChild(this);
    }
    /** Parent of the node */ get parent() {
        return this._parent;
    }
    /** Local transformation matrix of the node */ get matrix() {
        return this._matrix;
    }
    /** World transformation matrix of the node */ get worldMatrix() {
        return this._worldMatrix;
    }
    /** Mesh data of the node, or null if this is not a mesh node */ get mesh() {
        return this._mesh;
    }
    set mesh(data) {
        this._mesh = data;
        this.setMeshAttached();
    }
    /** The skeleton used to control the node */ get skeleton() {
        return this._skeleton;
    }
    set skeleton(skeleton) {
        this._skeleton = skeleton;
    }
    /** The translation of the node */ get position() {
        return this._position;
    }
    set position(val) {
        this._position = val;
    }
    /** The rotation of the node */ get rotation() {
        return this._rotation;
    }
    set rotation(val) {
        this._rotation = val;
    }
    /** The scale of the node */ get scaling() {
        return this._scaling;
    }
    set scaling(val) {
        this._scaling = val;
    }
    /** true if the node is parent of a mesh node */ get meshAttached() {
        return this._meshAttached;
    }
    /** Children of the node */ get children() {
        return this._children;
    }
    /** The skeleton to which the node belongs if this is a joint node */ get skeletonAttached() {
        return this._attachToSkeleton;
    }
    /** The joint index if this is a joint node */ get attachIndex() {
        return this._attachIndex;
    }
    /** @internal */ computeTransforms(parentTransform) {
        this._matrix = Matrix4x4.scaling(this._scaling).rotateLeft(this._rotation).translateLeft(this._position);
        this._worldMatrix = parentTransform ? Matrix4x4.multiply(parentTransform, this._matrix) : new Matrix4x4(this._matrix);
        for (const child of this._children){
            child.computeTransforms(this._worldMatrix);
        }
    }
    /**
   * Adds a child to this node
   * @param child - The child node to be added
   */ addChild(child) {
        if (!child || child.parent) {
            throw new Error('AssetHierarchyNode.addChild(): invalid child node');
        }
        this._children.push(child);
        child._parent = this;
        if (child.meshAttached) {
            this.setMeshAttached();
        }
    }
    /**
   * Removes a child of this node
   * @param child - The child node to be removed
   */ removeChild(child) {
        const index = this._children.indexOf(child);
        if (index < 0) {
            throw new Error('AssetHierarchyNode.removeChild(): invalid child node');
        }
        this._children[index]._parent = null;
        this._children.splice(index, 1);
    }
    /**
   * Attach this node to a skeleton
   * @param skeleton - The skeleton to which to node will attach
   * @param index - The joint index
   */ attachToSkeleton(skeleton, index) {
        if (this._attachToSkeleton && skeleton !== this._attachToSkeleton) {
            throw new Error(`joint can not attached to multiple skeletons`);
        }
        this._attachToSkeleton = skeleton;
        this._attachIndex = index;
    }
    /** @internal */ setMeshAttached() {
        this._meshAttached = true;
        this._parent?.setMeshAttached();
    }
}
/**
 * Skeleton information for model loading
 * @public
 */ class AssetSkeleton extends NamedObject {
    /** The pivot node */ pivot;
    /** Joints of the skeleton */ joints;
    /** Inverse of the binding matrices of the joints */ inverseBindMatrices;
    /** Binding pose matrices of the joints */ bindPoseMatrices;
    /**
   * Creates an instance of AssetSkeleton
   * @param name - Name of the skeleton
   */ constructor(name){
        super(name);
        this.name = name;
        this.pivot = null;
        this.joints = [];
        this.inverseBindMatrices = [];
        this.bindPoseMatrices = [];
    }
    /**
   * Adds a joint to the skeleton
   * @param joint - The joint node
   * @param inverseBindMatrix - Inverse binding matrix of the joint
   */ addJoint(joint, inverseBindMatrix) {
        joint.attachToSkeleton(this, this.joints.length);
        this.joints.push(joint);
        this.inverseBindMatrices.push(inverseBindMatrix);
        this.bindPoseMatrices.push(joint.worldMatrix);
    }
}
/**
 * Scene for model loading
 * @public
 */ class AssetScene extends NamedObject {
    /** Root nodes of the scene */ rootNodes;
    /**
   * Creates an instance of AssetScene
   * @param name - Name of the scene
   */ constructor(name){
        super(name);
        this.rootNodes = [];
    }
}
/**
 * Model information that can be shared by multiple model nodes
 * @public
 */ class SharedModel {
    /** @internal */ _name;
    /** @internal */ _skeletons;
    /** @internal */ _nodes;
    /** @internal */ _animations;
    /** @internal */ _scenes;
    /** @internal */ _activeScene;
    /**
   * Creates an instance of SharedModel
   * @param name - Name of the model
   */ constructor(name){
        this._name = name || '';
        this._skeletons = [];
        this._nodes = [];
        this._scenes = [];
        this._animations = [];
        this._activeScene = -1;
    }
    /** Name of the model */ get name() {
        return this._name;
    }
    set name(val) {
        this._name = val;
    }
    /** All scenes that the model contains */ get scenes() {
        return this._scenes;
    }
    /** All animations that the model contains */ get animations() {
        return this._animations;
    }
    /** All skeletons that the model contains */ get skeletons() {
        return this._skeletons;
    }
    /** All nodes that the model contains */ get nodes() {
        return this._nodes;
    }
    /** The active scene of the model */ get activeScene() {
        return this._activeScene;
    }
    set activeScene(val) {
        this._activeScene = val;
    }
    /**
   * Adds a node to the scene
   * @param parent - Under which node the node should be added
   * @param index - Index of the node
   * @param name - Name of the node
   * @returns The added node
   */ addNode(parent, index, name) {
        const childNode = new AssetHierarchyNode(name, parent);
        this._nodes[index] = childNode;
        return childNode;
    }
    /**
   * Adds a skeleton to the scene
   * @param skeleton - The skeleton to be added
   */ addSkeleton(skeleton) {
        this._skeletons.push(skeleton);
    }
    /**
   * Adds an animation to the scene
   * @param animation - The animation to be added
   */ addAnimation(animation) {
        this._animations.push(animation);
    }
}

var ComponentType;
(function(ComponentType) {
    ComponentType[ComponentType["UNKNOWN"] = 0] = "UNKNOWN";
    ComponentType[ComponentType["BYTE"] = 5120] = "BYTE";
    ComponentType[ComponentType["UBYTE"] = 5121] = "UBYTE";
    ComponentType[ComponentType["SHORT"] = 5122] = "SHORT";
    ComponentType[ComponentType["USHORT"] = 5123] = "USHORT";
    ComponentType[ComponentType["INT"] = 5124] = "INT";
    ComponentType[ComponentType["UINT"] = 5125] = "UINT";
    ComponentType[ComponentType["FLOAT"] = 5126 // GL.FLOAT
    ] = "FLOAT";
})(ComponentType || (ComponentType = {}));
/** @internal */ class GLTFAccessor {
    bufferView;
    byteOffset;
    componentType;
    normalized;
    count;
    type;
    max;
    min;
    sparse;
    name;
    _typedView;
    _filteredView;
    _normalizedFilteredView;
    _normalizedTypedView;
    constructor(accessorInfo){
        this.bufferView = accessorInfo.bufferView;
        this.byteOffset = accessorInfo.byteOffset ?? 0;
        this.componentType = accessorInfo.componentType;
        this.normalized = !!accessorInfo.normalized;
        this.count = accessorInfo.count;
        this.type = accessorInfo.type;
        this.max = accessorInfo.max;
        this.min = accessorInfo.min;
        this.sparse = accessorInfo.sparse;
        this.name = accessorInfo.name;
        this._typedView = null;
        this._filteredView = null;
        this._normalizedFilteredView = null;
        this._normalizedTypedView = null;
    }
    getTypedView(gltf) {
        if (this._typedView) {
            return this._typedView;
        }
        if (this.bufferView !== undefined) {
            const bufferView = gltf.bufferViews[this.bufferView];
            const buffer = gltf._loadedBuffers[bufferView.buffer];
            const byteOffset = this.byteOffset + (bufferView.byteOffset ?? 0);
            const componentSize = this.getComponentSize(this.componentType);
            const componentCount = this.getComponentCount(this.type);
            let arrayLength = 0;
            if (bufferView.byteStride !== undefined && bufferView.byteStride !== 0) {
                if (componentSize !== 0) {
                    arrayLength = bufferView.byteStride / componentSize * (this.count - 1) + componentCount;
                } else {
                    console.warn("Invalid component type in accessor '" + (this.name ? this.name : '') + "'");
                }
            } else {
                arrayLength = this.count * componentCount;
            }
            if (arrayLength * componentSize > buffer.byteLength - byteOffset) {
                arrayLength = (buffer.byteLength - byteOffset) / componentSize;
                console.warn("Count in accessor '" + (this.name ? this.name : '') + "' is too large.");
            }
            switch(this.componentType){
                case 5120:
                    this._typedView = new Int8Array(buffer, byteOffset, arrayLength);
                    break;
                case 5121:
                    this._typedView = new Uint8Array(buffer, byteOffset, arrayLength);
                    break;
                case 5122:
                    this._typedView = new Int16Array(buffer, byteOffset, arrayLength);
                    break;
                case 5123:
                    this._typedView = new Uint16Array(buffer, byteOffset, arrayLength);
                    break;
                case 5124:
                    this._typedView = new Int32Array(buffer, byteOffset, arrayLength);
                    break;
                case 5125:
                    this._typedView = new Uint32Array(buffer, byteOffset, arrayLength);
                    break;
                case 5126:
                    this._typedView = new Float32Array(buffer, byteOffset, arrayLength);
                    break;
            }
        } else if (this.sparse !== undefined) {
            this._typedView = this.createView();
        }
        if (!this._typedView) {
            console.warn('Failed to convert buffer view to typed view!: ' + this.bufferView);
        } else if (this.sparse !== undefined) {
            this.applySparse(gltf, this._typedView);
        }
        return this._typedView;
    }
    // getNormalizedTypedView provides an alternative view to the accessors data,
    // where quantized data is already normalized. This is useful if the data is not passed
    // to vertexAttribPointer but used immediately (like e.g. animations)
    getNormalizedTypedView(gltf) {
        if (this._normalizedTypedView) {
            return this._normalizedTypedView;
        }
        const typedView = this.getTypedView(gltf);
        this._normalizedTypedView = this.normalized ? GLTFAccessor.dequantize(typedView, this.componentType) : typedView;
        return this._normalizedTypedView;
    }
    // getDeinterlacedView provides a view to the accessors data in form of
    // a TypedArray. In contrast to getTypedView, getDeinterlacedView deinterlaces
    // data, i.e. stripping padding and unrelated components from the array. It then
    // only contains the data of the accessor
    getDeinterlacedView(gltf) {
        if (this._filteredView) {
            return this._filteredView;
        }
        const componentSize = this.getComponentSize(this.componentType);
        const componentCount = this.getComponentCount(this.type);
        const arrayLength = this.count * componentCount;
        let func = 'getFloat32';
        switch(this.componentType){
            case 5120:
                this._filteredView = new Int8Array(arrayLength);
                func = 'getInt8';
                break;
            case 5121:
                this._filteredView = new Uint8Array(arrayLength);
                func = 'getUint8';
                break;
            case 5122:
                this._filteredView = new Int16Array(arrayLength);
                func = 'getInt16';
                break;
            case 5123:
                this._filteredView = new Uint16Array(arrayLength);
                func = 'getUint16';
                break;
            case 5124:
                this._filteredView = new Int32Array(arrayLength);
                func = 'getInt32';
                break;
            case 5125:
                this._filteredView = new Uint32Array(arrayLength);
                func = 'getUint32';
                break;
            case 5126:
                this._filteredView = new Float32Array(arrayLength);
                func = 'getFloat32';
                break;
            default:
                return;
        }
        if (this.bufferView !== undefined) {
            const bufferView = gltf.bufferViews[this.bufferView];
            const buffer = gltf._loadedBuffers[bufferView.buffer];
            const byteOffset = this.byteOffset + (bufferView.byteOffset ?? 0);
            const stride = bufferView.byteStride !== undefined && bufferView.byteStride !== 0 ? bufferView.byteStride : componentCount * componentSize;
            const dataView = new DataView(buffer, byteOffset, this.count * stride);
            for(let i = 0; i < arrayLength; ++i){
                const offset = Math.floor(i / componentCount) * stride + i % componentCount * componentSize;
                this._filteredView[i] = dataView[func](offset, true);
            }
        } else if (this.sparse !== undefined) {
            this._filteredView = this.createView();
        }
        if (this.sparse !== undefined) {
            this.applySparse(gltf, this._filteredView);
        }
        return this._filteredView;
    }
    createView() {
        const size = this.count * this.getComponentCount(this.type);
        if (this.componentType == 5120) return new Int8Array(size);
        if (this.componentType == 5121) return new Uint8Array(size);
        if (this.componentType == 5122) return new Int16Array(size);
        if (this.componentType == 5123) return new Uint16Array(size);
        if (this.componentType == 5124) return new Int32Array(size);
        if (this.componentType == 5125) return new Uint32Array(size);
        if (this.componentType == 5126) return new Float32Array(size);
        return undefined;
    }
    // getNormalizedDeinterlacedView provides an alternative view to the accessors data,
    // where quantized data is already normalized. This is useful if the data is not passed
    // to vertexAttribPointer but used immediately (like e.g. animations)
    getNormalizedDeinterlacedView(gltf) {
        if (this._normalizedFilteredView) {
            return this._normalizedFilteredView;
        }
        const filteredView = this.getDeinterlacedView(gltf);
        this._normalizedFilteredView = this.normalized ? GLTFAccessor.dequantize(filteredView, this.componentType) : filteredView;
        return this._normalizedFilteredView;
    }
    applySparse(gltf, view) {
        // Gather indices.
        const indicesBufferView = gltf.bufferViews[this.sparse.indices.bufferView];
        const indicesBuffer = gltf._loadedBuffers[indicesBufferView.buffer];
        const indicesByteOffset = this.sparse.indices.byteOffset + (indicesBufferView.byteOffset ?? 0);
        const indicesComponentSize = this.getComponentSize(this.sparse.indices.componentType);
        let indicesComponentCount = 1;
        if (indicesBufferView.byteStride !== undefined && indicesBufferView.byteStride !== 0) {
            indicesComponentCount = indicesBufferView.byteStride / indicesComponentSize;
        }
        const indicesArrayLength = this.sparse.count * indicesComponentCount;
        let indicesTypedView;
        switch(this.sparse.indices.componentType){
            case 5121:
                indicesTypedView = new Uint8Array(indicesBuffer, indicesByteOffset, indicesArrayLength);
                break;
            case 5123:
                indicesTypedView = new Uint16Array(indicesBuffer, indicesByteOffset, indicesArrayLength);
                break;
            case 5125:
                indicesTypedView = new Uint32Array(indicesBuffer, indicesByteOffset, indicesArrayLength);
                break;
        }
        // Gather values.
        const valuesBufferView = gltf.bufferViews[this.sparse.values.bufferView];
        const valuesBuffer = gltf._loadedBuffers[valuesBufferView.buffer];
        const valuesByteOffset = this.sparse.values.byteOffset + (valuesBufferView.byteOffset ?? 0);
        const valuesComponentSize = this.getComponentSize(this.componentType);
        let valuesComponentCount = this.getComponentCount(this.type);
        if (valuesBufferView.byteStride !== undefined && valuesBufferView.byteStride !== 0) {
            valuesComponentCount = valuesBufferView.byteStride / valuesComponentSize;
        }
        const valuesArrayLength = this.sparse.count * valuesComponentCount;
        let valuesTypedView;
        switch(this.componentType){
            case 5120:
                valuesTypedView = new Int8Array(valuesBuffer, valuesByteOffset, valuesArrayLength);
                break;
            case 5121:
                valuesTypedView = new Uint8Array(valuesBuffer, valuesByteOffset, valuesArrayLength);
                break;
            case 5122:
                valuesTypedView = new Int16Array(valuesBuffer, valuesByteOffset, valuesArrayLength);
                break;
            case 5123:
                valuesTypedView = new Uint16Array(valuesBuffer, valuesByteOffset, valuesArrayLength);
                break;
            case 5124:
                valuesTypedView = new Int32Array(valuesBuffer, valuesByteOffset, valuesArrayLength);
                break;
            case 5125:
                valuesTypedView = new Uint32Array(valuesBuffer, valuesByteOffset, valuesArrayLength);
                break;
            case 5126:
                valuesTypedView = new Float32Array(valuesBuffer, valuesByteOffset, valuesArrayLength);
                break;
        }
        // Overwrite values.
        for(let i = 0; i < this.sparse.count; ++i){
            for(let k = 0; k < valuesComponentCount; ++k){
                view[indicesTypedView[i] * valuesComponentCount + k] = valuesTypedView[i * valuesComponentCount + k];
            }
        }
    }
    // dequantize can be used to perform the normalization from WebGL2 vertexAttribPointer explicitly
    static dequantize(typedArray, componentType) {
        switch(componentType){
            case 5120:
                return new Float32Array(typedArray).map((c)=>Math.max(c / 127.0, -1.0));
            case 5121:
                return new Float32Array(typedArray).map((c)=>c / 255.0);
            case 5122:
                return new Float32Array(typedArray).map((c)=>Math.max(c / 32767.0, -1.0));
            case 5123:
                return new Float32Array(typedArray).map((c)=>c / 65535.0);
            default:
                return typedArray;
        }
    }
    getComponentCount(type) {
        switch(type){
            case 'SCALAR':
                return 1;
            case 'VEC2':
                return 2;
            case 'VEC3':
                return 3;
            case 'VEC4':
                return 4;
            case 'MAT2':
                return 4;
            case 'MAT3':
                return 9;
            case 'MAT4':
                return 16;
            default:
                return 0;
        }
    }
    getComponentSize(componentType) {
        switch(componentType){
            case 5120:
            case 5121:
                return 1;
            case 5122:
            case 5123:
                return 2;
            case 5124:
            case 5125:
            case 5126:
                return 4;
            default:
                return 0;
        }
    }
}

/**
 * Base interface for any kind loaders
 * @public
 */ class LoaderBase {
    /** @internal */ _urlResolver;
    /**
   * Creates an instance of LoaderBase
   */ constructor(){
        this._urlResolver = null;
    }
    /**
   * URL resolver for the loader
   */ get urlResolver() {
        return this._urlResolver;
    }
    set urlResolver(resolver) {
        this._urlResolver = resolver;
    }
    /**
   * Sends a GET request
   * @param url - The URL to get
   * @param headers - The headers for the request
   * @param crossOrigin - crossOrigin property for the request
   * @returns Response of the request
   */ async request(url, headers = {}, crossOrigin = 'anonymous') {
        url = this._urlResolver ? this._urlResolver(url) : null;
        return url ? fetch(url, {
            credentials: crossOrigin === 'anonymous' ? 'same-origin' : 'include',
            headers: headers
        }) : null;
    }
}
/**
 * Base class for any kind of texture loaders
 * @public
 */ class AbstractTextureLoader extends LoaderBase {
}
/**
 * Base class for any kind of model loaders
 * @public
 */ class AbstractModelLoader extends LoaderBase {
}

/**
 * The GLTF/GLB model loader
 * @internal
 */ class GLTFLoader extends AbstractModelLoader {
    supportExtension(ext) {
        return ext === '.gltf' || ext === '.glb';
    }
    supportMIMEType(mimeType) {
        return mimeType === 'model/gltf+json' || mimeType === 'model/gltf-binary';
    }
    async load(assetManager, url, mimeType, data) {
        const buffer = await data.arrayBuffer();
        if (this.isGLB(buffer)) {
            return this.loadBinary(assetManager, url, buffer);
        }
        const gltf = await new Response(data).json();
        gltf._manager = assetManager;
        gltf._loadedBuffers = null;
        return this.loadJson(url, gltf);
    }
    async loadBinary(assetManager, url, buffer) {
        const jsonChunkType = 0x4e4f534a;
        const binaryChunkType = 0x004e4942;
        let gltf = null;
        const buffers = [];
        const chunkInfos = this.getGLBChunkInfos(buffer);
        for (const info of chunkInfos){
            if (info.type === jsonChunkType && !gltf) {
                const jsonSlice = new Uint8Array(buffer, 20, info.length);
                const stringBuffer = new TextDecoder('utf-8').decode(jsonSlice);
                gltf = JSON.parse(stringBuffer);
            } else if (info.type === binaryChunkType) {
                buffers.push(buffer.slice(info.start, info.start + info.length));
            }
        }
        if (gltf) {
            gltf._manager = assetManager;
            gltf._loadedBuffers = buffers;
            return this.loadJson(url, gltf);
        }
        return null;
    }
    async loadJson(url, gltf) {
        console.log(`GLTF extensions used: ${gltf.extensionsUsed || []}`);
        gltf._accessors = [];
        gltf._bufferCache = {};
        gltf._textureCache = {};
        gltf._primitiveCache = {};
        gltf._materialCache = {};
        gltf._nodes = [];
        gltf._meshes = [];
        // check asset property
        const asset = gltf.asset;
        if (asset) {
            const gltfVersion = asset.version;
            if (gltfVersion !== '2.0') {
                console.error(`Invalid GLTF version: ${gltfVersion}`);
                return null;
            }
        }
        gltf._baseURI = url.substring(0, url.lastIndexOf('/') + 1);
        if (!gltf._loadedBuffers) {
            gltf._loadedBuffers = [];
            const buffers = gltf.buffers;
            if (buffers) {
                for (const buffer of buffers){
                    const uri = this._normalizeURI(gltf._baseURI, buffer.uri);
                    const buf = await gltf._manager.fetchBinaryData(uri);
                    // const buf = (await new FileLoader(null, 'arraybuffer').load(uri)) as ArrayBuffer;
                    if (buffer.byteLength !== buf.byteLength) {
                        console.error(`Invalid GLTF: buffer byte length error.`);
                        return null;
                    }
                    gltf._loadedBuffers.push(buf);
                }
            }
        }
        const accessors = gltf.accessors;
        if (accessors) {
            for (const accessor of gltf.accessors){
                gltf._accessors.push(new GLTFAccessor(accessor));
            }
        }
        const scenes = gltf.scenes;
        if (scenes) {
            const sharedModel = new SharedModel();
            await this._loadMeshes(gltf, sharedModel);
            this._loadNodes(gltf, sharedModel);
            this._loadSkins(gltf, sharedModel);
            for(let i = 0; i < gltf.nodes?.length; i++){
                if (typeof gltf.nodes[i].skin === 'number' && gltf.nodes[i].skin >= 0) {
                    gltf._nodes[i].skeleton = sharedModel.skeletons[gltf.nodes[i].skin];
                }
            }
            this._loadAnimations(gltf, sharedModel);
            for (const scene of scenes){
                const assetScene = new AssetScene(scene.name);
                for (const node of scene.nodes){
                    assetScene.rootNodes.push(gltf._nodes[node]);
                }
                sharedModel.scenes.push(assetScene);
            }
            if (typeof gltf.scene === 'number') {
                sharedModel.activeScene = gltf.scene;
            }
            return sharedModel;
        }
        return null;
    }
    /** @internal */ _normalizeURI(baseURI, uri) {
        const s = uri.toLowerCase();
        if (s.startsWith('http://') || s.startsWith('https://') || s.startsWith('blob:') || s.startsWith('data:')) {
            // absolute path
            return encodeURI(uri);
        }
        uri = uri.replace(/\.\//g, '');
        uri = decodeURIComponent(uri);
        if (uri[0] === '/') {
            uri = uri.slice(1);
        }
        uri = uri.split('/').map((val)=>encodeURIComponent(val)).join('/');
        return baseURI + uri;
    }
    /** @internal */ _loadNodes(gltf, model) {
        if (gltf.nodes) {
            for(let i = 0; i < gltf.nodes.length; i++){
                this._loadNode(gltf, i, null, model);
            }
            for (const node of gltf._nodes){
                if (!node.parent) {
                    node.computeTransforms(null);
                }
            }
        }
    }
    /** @internal */ _loadSkins(gltf, model) {
        if (gltf.skins) {
            for(let i = 0; i < gltf.skins.length; i++){
                const skinInfo = gltf.skins[i];
                const skeleton = new AssetSkeleton(skinInfo.name);
                if (typeof skinInfo.skeleton === 'number') {
                    skeleton.pivot = gltf._nodes[skinInfo.skeleton];
                }
                const accessor = gltf._accessors[skinInfo.inverseBindMatrices];
                if (!accessor || accessor.type !== 'MAT4' || accessor.componentType !== ComponentType.FLOAT) {
                    throw new Error('Invalid GLTF inverse bind matricies accessor');
                }
                const matrices = typeof skinInfo.inverseBindMatrices === 'number' ? accessor.getDeinterlacedView(gltf) : null;
                skinInfo.joints.forEach((joint, index)=>{
                    const m = index * 16;
                    skeleton.addJoint(gltf._nodes[joint], matrices ? new Matrix4x4(matrices.subarray(m, m + 16)) : Matrix4x4.identity());
                });
                model.addSkeleton(skeleton);
            }
        }
    }
    /** @internal */ _loadAnimations(gltf, model) {
        if (gltf.animations) {
            for(let i = 0; i < gltf.animations.length; i++){
                const animation = this._loadAnimation(gltf, i, model);
                model.addAnimation(animation);
            }
        }
    }
    /** @internal */ collectNodes(gltf) {
        const collect = new Map();
        for (const node of gltf._nodes){
            collect.set(node, {
                translate: node.position || Vector3.zero(),
                rotation: node.rotation || Quaternion.identity(),
                scale: node.scaling || Vector3.one(),
                worldTransform: null
            });
        }
        return collect;
    }
    /** @internal */ updateNodeTransform(nodeTransforms, node) {
        const transform = nodeTransforms.get(node);
        if (!transform.worldTransform) {
            transform.worldTransform = Matrix4x4.scaling(transform.scale).rotateLeft(transform.rotation).translateLeft(transform.translate);
            if (node.parent) {
                this.updateNodeTransform(nodeTransforms, node.parent);
                transform.worldTransform.multiplyLeft(nodeTransforms.get(node.parent).worldTransform);
            }
        }
    }
    /** @internal */ getAnimationInfo(gltf, index) {
        const animationInfo = gltf.animations[index];
        const name = animationInfo.name || null;
        const channels = animationInfo.channels;
        const samplers = animationInfo.samplers;
        const interpolators = [];
        const interpolatorTypes = [];
        const nodes = this.collectNodes(gltf);
        let maxTime = 0;
        for(let i = 0; i < channels.length; i++){
            const channel = channels[i];
            const sampler = samplers[channel.sampler];
            const input = gltf._accessors[sampler.input].getNormalizedDeinterlacedView(gltf);
            const output = gltf._accessors[sampler.output].getNormalizedDeinterlacedView(gltf);
            const mode = sampler.interpolation === 'STEP' ? 'step' : sampler.interpolation === 'CUBICSPLINE' ? 'cubicspline' : 'linear';
            if (channel.target.path === 'rotation') {
                interpolators.push(new Interpolator(mode, 'quat', input, output));
                interpolatorTypes.push('rotation');
            } else if (channel.target.path === 'translation') {
                interpolators.push(new Interpolator(mode, 'vec3', input, output));
                interpolatorTypes.push('translation');
            } else if (channel.target.path === 'scale') {
                interpolators.push(new Interpolator(mode, 'vec3', input, output));
                interpolatorTypes.push('scale');
            } else {
                continue;
            }
            const max = input[input.length - 1];
            if (max > maxTime) {
                maxTime = max;
            }
        }
        return {
            name,
            channels,
            samplers,
            interpolators,
            interpolatorTypes,
            maxTime,
            nodes
        };
    }
    /** @internal */ _loadAnimation(gltf, index, model) {
        const animationInfo = this.getAnimationInfo(gltf, index);
        const animationData = {
            name: animationInfo.name,
            tracks: [],
            skeletons: [],
            nodes: []
        };
        for(let i = 0; i < animationInfo.channels.length; i++){
            const targetNode = gltf._nodes[animationInfo.channels[i].target.node];
            animationData.tracks.push({
                node: targetNode,
                type: animationInfo.interpolatorTypes[i],
                interpolator: animationInfo.interpolators[i]
            });
            if (animationData.nodes.indexOf(targetNode) < 0) {
                animationData.nodes.push(targetNode);
            }
            if (targetNode.skeletonAttached && animationData.skeletons.indexOf(targetNode.skeletonAttached) < 0) {
                animationData.skeletons.push(targetNode.skeletonAttached);
            }
        }
        return animationData;
    }
    /** @internal */ _loadNode(gltf, nodeIndex, parent, model) {
        let node = gltf._nodes[nodeIndex];
        if (node) {
            if (parent) {
                if (node.parent) {
                    throw new Error('invalid node hierarchy');
                }
                parent.addChild(node);
            }
            return node;
        }
        const nodeInfo = gltf.nodes?.[nodeIndex];
        if (nodeInfo) {
            node = model.addNode(parent, nodeIndex, nodeInfo.name);
            if (typeof nodeInfo.mesh === 'number') {
                node.mesh = gltf._meshes[nodeInfo.mesh];
            }
            if (!(typeof nodeInfo.skin === 'number') || nodeInfo.skin < 0) {
                // GLTF spec: Only the joint transforms are applied to the skinned mesh; the transform of the skinned mesh node MUST be ignored.
                if (nodeInfo.matrix) {
                    const matrix = new Matrix4x4(nodeInfo.matrix);
                    matrix.decompose(node.scaling, node.rotation, node.position);
                } else {
                    if (nodeInfo.rotation) {
                        node.rotation.set(nodeInfo.rotation);
                    }
                    if (nodeInfo.scale) {
                        node.scaling.set(nodeInfo.scale);
                    }
                    if (nodeInfo.translation) {
                        node.position.set(nodeInfo.translation);
                    }
                }
            }
            gltf._nodes[nodeIndex] = node;
            if (nodeInfo.children) {
                for (const childIndex of nodeInfo.children){
                    this._loadNode(gltf, childIndex, node, model);
                }
            }
        } else {
            throw new Error(`invalid GLTF node: ${nodeIndex}`);
        }
        return node;
    }
    /** @internal */ async _loadMeshes(gltf, model) {
        if (gltf.meshes) {
            for(let i = 0; i < gltf.meshes.length; i++){
                gltf._meshes[i] = await this._loadMesh(gltf, i);
            }
        }
    }
    /** @internal */ async _loadMesh(gltf, meshIndex) {
        const meshInfo = gltf.meshes && gltf.meshes[meshIndex];
        let mesh = null;
        if (meshInfo) {
            mesh = {
                subMeshes: []
            };
            const primitives = meshInfo.primitives;
            const meshName = meshInfo.name || null;
            if (primitives) {
                for(let i = 0; i < primitives.length; i++){
                    const p = primitives[i];
                    const subMeshData = {
                        name: `${meshName}-${i}`,
                        primitive: null,
                        material: null,
                        rawPositions: null,
                        rawBlendIndices: null,
                        rawJointWeights: null
                    };
                    const hash = `(${Object.getOwnPropertyNames(p.attributes).sort().map((k)=>`${k}:${p.attributes[k]}`).join(',')})-(${p.indices})-(${p.mode})`;
                    let primitive = p.targets ? null : gltf._primitiveCache[hash];
                    if (!primitive) {
                        primitive = new Primitive();
                        const attributes = p.attributes;
                        for(const attrib in attributes){
                            this._loadVertexBuffer(gltf, attrib, attributes[attrib], primitive, subMeshData);
                        }
                        const indices = p.indices;
                        if (typeof indices === 'number') {
                            this._loadIndexBuffer(gltf, indices, primitive, subMeshData);
                        }
                        let primitiveType = p.mode;
                        if (typeof primitiveType !== 'number') {
                            primitiveType = 4;
                        }
                        primitive.primitiveType = this._primitiveType(primitiveType);
                        gltf._primitiveCache[hash] = primitive;
                    }
                    const hasVertexNormal = !!primitive.getVertexBuffer('normal');
                    const hasVertexColor = !!primitive.getVertexBuffer('diffuse');
                    const hasVertexTangent = !!primitive.getVertexBuffer('tangent');
                    const materialHash = `${p.material}.${Number(hasVertexNormal)}.${Number(hasVertexColor)}.${Number(hasVertexTangent)}`;
                    let material = gltf._materialCache[materialHash];
                    if (!material) {
                        const materialInfo = p.material !== undefined ? gltf.materials[p.material] : null;
                        material = await this._loadMaterial(gltf, materialInfo, hasVertexColor, hasVertexNormal, hasVertexTangent);
                        gltf._materialCache[materialHash] = material;
                    }
                    subMeshData.primitive = primitive;
                    subMeshData.material = material;
                    mesh.subMeshes.push(subMeshData);
                }
            }
        }
        return mesh;
    }
    async _createMaterial(assetManager, assetMaterial) {
        if (assetMaterial.type === 'unlit') {
            const unlitAssetMaterial = assetMaterial;
            const unlitMaterial = new UnlitMaterial(); //new NewLambertMaterial();// new TestLitMaterial();// new UnlitMaterial();
            unlitMaterial.albedoColor = unlitAssetMaterial.diffuse ?? Vector4.one();
            if (unlitAssetMaterial.diffuseMap) {
                unlitMaterial.albedoTexture = unlitAssetMaterial.diffuseMap.texture;
                unlitMaterial.albedoTextureSampler = unlitAssetMaterial.diffuseMap.sampler;
                unlitMaterial.albedoTexCoordIndex = unlitAssetMaterial.diffuseMap.texCoord;
                unlitMaterial.albedoTexCoordMatrix = unlitAssetMaterial.diffuseMap.transform;
            }
            unlitMaterial.vertexColor = unlitAssetMaterial.common.vertexColor;
            if (assetMaterial.common.alphaMode === 'blend') {
                unlitMaterial.blendMode = 'blend';
            } else if (assetMaterial.common.alphaMode === 'mask') {
                unlitMaterial.alphaCutoff = assetMaterial.common.alphaCutoff;
            }
            if (assetMaterial.common.doubleSided) {
                const rasterizerState = unlitMaterial.stateSet.useRasterizerState();
                rasterizerState.setCullMode('none');
            }
            return unlitMaterial;
        } else if (assetMaterial.type === 'pbrSpecularGlossiness') {
            const assetPBRMaterial = assetMaterial;
            const pbrMaterial = new PBRSpecularGlossinessMaterial();
            pbrMaterial.ior = assetPBRMaterial.ior;
            pbrMaterial.albedoColor = assetPBRMaterial.diffuse;
            pbrMaterial.specularFactor = new Vector4(assetPBRMaterial.specular.x, assetPBRMaterial.specular.y, assetPBRMaterial.specular.z, 1);
            pbrMaterial.glossinessFactor = assetPBRMaterial.glossness;
            if (assetPBRMaterial.diffuseMap) {
                pbrMaterial.albedoTexture = assetPBRMaterial.diffuseMap.texture;
                pbrMaterial.albedoTextureSampler = assetPBRMaterial.diffuseMap.sampler;
                pbrMaterial.albedoTexCoordIndex = assetPBRMaterial.diffuseMap.texCoord;
                pbrMaterial.albedoTexCoordMatrix = assetPBRMaterial.diffuseMap.transform;
            }
            if (assetPBRMaterial.common.normalMap) {
                pbrMaterial.normalTexture = assetPBRMaterial.common.normalMap.texture;
                pbrMaterial.normalTextureSampler = assetPBRMaterial.common.normalMap.sampler;
                pbrMaterial.normalTexCoordIndex = assetPBRMaterial.common.normalMap.texCoord;
                pbrMaterial.normalTexCoordMatrix = assetPBRMaterial.common.normalMap.transform;
            }
            pbrMaterial.normalScale = assetPBRMaterial.common.bumpScale;
            if (assetPBRMaterial.common.emissiveMap) {
                pbrMaterial.emissiveTexture = assetPBRMaterial.common.emissiveMap.texture;
                pbrMaterial.emissiveTextureSampler = assetPBRMaterial.common.emissiveMap.sampler;
                pbrMaterial.emissiveTexCoordIndex = assetPBRMaterial.common.emissiveMap.texCoord;
                pbrMaterial.emissiveTexCoordMatrix = assetPBRMaterial.common.emissiveMap.transform;
            }
            pbrMaterial.emissiveColor = assetPBRMaterial.common.emissiveColor;
            pbrMaterial.emissiveStrength = assetPBRMaterial.common.emissiveStrength;
            if (assetPBRMaterial.common.occlusionMap) {
                pbrMaterial.occlusionTexture = assetPBRMaterial.common.occlusionMap.texture;
                pbrMaterial.occlusionTextureSampler = assetPBRMaterial.common.occlusionMap.sampler;
                pbrMaterial.occlusionTexCoordIndex = assetPBRMaterial.common.occlusionMap.texCoord;
                pbrMaterial.occlusionTexCoordMatrix = assetPBRMaterial.common.occlusionMap.transform;
            }
            pbrMaterial.occlusionStrength = assetPBRMaterial.common.occlusionStrength;
            if (assetPBRMaterial.specularGlossnessMap) {
                pbrMaterial.specularTexture = assetPBRMaterial.specularGlossnessMap.texture;
                pbrMaterial.specularTextureSampler = assetPBRMaterial.specularGlossnessMap.sampler;
                pbrMaterial.specularTexCoordIndex = assetPBRMaterial.specularGlossnessMap.texCoord;
                pbrMaterial.specularTexCoordMatrix = assetPBRMaterial.specularGlossnessMap.transform;
            }
            pbrMaterial.vertexTangent = assetPBRMaterial.common.useTangent;
            pbrMaterial.vertexColor = assetPBRMaterial.common.vertexColor;
            if (assetPBRMaterial.common.alphaMode === 'blend') {
                pbrMaterial.blendMode = 'blend';
            } else if (assetPBRMaterial.common.alphaMode === 'mask') {
                pbrMaterial.alphaCutoff = assetPBRMaterial.common.alphaCutoff;
            }
            if (assetPBRMaterial.common.doubleSided) {
                const rasterizerState = pbrMaterial.stateSet.useRasterizerState();
                rasterizerState.setCullMode('none');
            }
            pbrMaterial.vertexNormal = !!assetMaterial.common.vertexNormal;
            return pbrMaterial;
        } else if (assetMaterial.type === 'pbrMetallicRoughness') {
            const assetPBRMaterial = assetMaterial;
            const pbrMaterial = new PBRMetallicRoughnessMaterial();
            pbrMaterial.ior = assetPBRMaterial.ior;
            pbrMaterial.albedoColor = assetPBRMaterial.diffuse;
            pbrMaterial.metallic = assetPBRMaterial.metallic;
            pbrMaterial.roughness = assetPBRMaterial.roughness;
            if (assetPBRMaterial.diffuseMap) {
                pbrMaterial.albedoTexture = assetPBRMaterial.diffuseMap.texture;
                pbrMaterial.albedoTextureSampler = assetPBRMaterial.diffuseMap.sampler;
                pbrMaterial.albedoTexCoordIndex = assetPBRMaterial.diffuseMap.texCoord;
                pbrMaterial.albedoTexCoordMatrix = assetPBRMaterial.diffuseMap.transform;
            }
            if (assetPBRMaterial.common.normalMap) {
                pbrMaterial.normalTexture = assetPBRMaterial.common.normalMap.texture;
                pbrMaterial.normalTextureSampler = assetPBRMaterial.common.normalMap.sampler;
                pbrMaterial.normalTexCoordIndex = assetPBRMaterial.common.normalMap.texCoord;
                pbrMaterial.normalTexCoordMatrix = assetPBRMaterial.common.normalMap.transform;
            }
            pbrMaterial.normalScale = assetPBRMaterial.common.bumpScale;
            if (assetPBRMaterial.common.emissiveMap) {
                pbrMaterial.emissiveTexture = assetPBRMaterial.common.emissiveMap.texture;
                pbrMaterial.emissiveTextureSampler = assetPBRMaterial.common.emissiveMap.sampler;
                pbrMaterial.emissiveTexCoordIndex = assetPBRMaterial.common.emissiveMap.texCoord;
                pbrMaterial.emissiveTexCoordMatrix = assetPBRMaterial.common.emissiveMap.transform;
            }
            pbrMaterial.emissiveColor = assetPBRMaterial.common.emissiveColor;
            pbrMaterial.emissiveStrength = assetPBRMaterial.common.emissiveStrength;
            if (assetPBRMaterial.common.occlusionMap) {
                pbrMaterial.occlusionTexture = assetPBRMaterial.common.occlusionMap.texture;
                pbrMaterial.occlusionTextureSampler = assetPBRMaterial.common.occlusionMap.sampler;
                pbrMaterial.occlusionTexCoordIndex = assetPBRMaterial.common.occlusionMap.texCoord;
                pbrMaterial.occlusionTexCoordMatrix = assetPBRMaterial.common.occlusionMap.transform;
                pbrMaterial.occlusionStrength = assetPBRMaterial.common.occlusionStrength;
            }
            if (assetPBRMaterial.metallicMap) {
                pbrMaterial.metallicRoughnessTexture = assetPBRMaterial.metallicMap.texture;
                pbrMaterial.metallicRoughnessTextureSampler = assetPBRMaterial.metallicMap.sampler;
                pbrMaterial.metallicRoughnessTexCoordIndex = assetPBRMaterial.metallicMap.texCoord;
                pbrMaterial.metallicRoughnessTexCoordMatrix = assetPBRMaterial.metallicMap.transform;
            }
            pbrMaterial.specularFactor = assetPBRMaterial.specularFactor;
            if (assetPBRMaterial.specularMap) {
                pbrMaterial.specularTexture = assetPBRMaterial.specularMap.texture;
                pbrMaterial.specularTextureSampler = assetPBRMaterial.specularMap.sampler;
                pbrMaterial.specularTexCoordIndex = assetPBRMaterial.specularMap.texCoord;
                pbrMaterial.specularTexCoordMatrix = assetPBRMaterial.specularMap.transform;
            }
            if (assetPBRMaterial.specularColorMap) {
                pbrMaterial.specularColorTexture = assetPBRMaterial.specularColorMap.texture;
                pbrMaterial.specularColorTextureSampler = assetPBRMaterial.specularColorMap.sampler;
                pbrMaterial.specularColorTexCoordIndex = assetPBRMaterial.specularColorMap.texCoord;
                pbrMaterial.specularColorTexCoordMatrix = assetPBRMaterial.specularColorMap.transform;
            }
            if (assetPBRMaterial.sheen) {
                const sheen = assetPBRMaterial.sheen;
                pbrMaterial.sheen = true;
                pbrMaterial.sheenColorFactor = sheen.sheenColorFactor;
                pbrMaterial.sheenRoughnessFactor = sheen.sheenRoughnessFactor;
                if (sheen.sheenColorMap) {
                    pbrMaterial.sheenColorTexture = sheen.sheenColorMap.texture;
                    pbrMaterial.sheenColorTextureSampler = sheen.sheenColorMap.sampler;
                    pbrMaterial.sheenColorTexCoordIndex = sheen.sheenColorMap.texCoord;
                    pbrMaterial.sheenColorTexCoordMatrix = sheen.sheenColorMap.transform;
                }
                if (sheen.sheenRoughnessMap) {
                    pbrMaterial.sheenRoughnessTexture = sheen.sheenRoughnessMap.texture;
                    pbrMaterial.sheenRoughnessTextureSampler = sheen.sheenRoughnessMap.sampler;
                    pbrMaterial.sheenRoughnessTexCoordIndex = sheen.sheenRoughnessMap.texCoord;
                    pbrMaterial.sheenRoughnessTexCoordMatrix = sheen.sheenRoughnessMap.transform;
                }
            }
            if (assetPBRMaterial.clearcoat) {
                const cc = assetPBRMaterial.clearcoat;
                pbrMaterial.clearcoat = true;
                pbrMaterial.clearcoatIntensity = cc.clearCoatFactor;
                pbrMaterial.clearcoatRoughnessFactor = cc.clearCoatRoughnessFactor;
                if (cc.clearCoatIntensityMap) {
                    pbrMaterial.clearcoatIntensityTexture = cc.clearCoatIntensityMap.texture;
                    pbrMaterial.clearcoatIntensityTextureSampler = cc.clearCoatIntensityMap.sampler;
                    pbrMaterial.clearcoatIntensityTexCoordIndex = cc.clearCoatIntensityMap.texCoord;
                    pbrMaterial.clearcoatIntensityTexCoordMatrix = cc.clearCoatIntensityMap.transform;
                }
                if (cc.clearCoatRoughnessMap) {
                    pbrMaterial.clearcoatRoughnessTexture = cc.clearCoatRoughnessMap.texture;
                    pbrMaterial.clearcoatRoughnessTextureSampler = cc.clearCoatRoughnessMap.sampler;
                    pbrMaterial.clearcoatRoughnessTexCoordIndex = cc.clearCoatRoughnessMap.texCoord;
                    pbrMaterial.clearcoatRoughnessTexCoordMatrix = cc.clearCoatRoughnessMap.transform;
                }
                if (cc.clearCoatNormalMap) {
                    pbrMaterial.clearcoatNormalTexture = cc.clearCoatNormalMap.texture;
                    pbrMaterial.clearcoatNormalTextureSampler = cc.clearCoatNormalMap.sampler;
                    pbrMaterial.clearcoatNormalTexCoordIndex = cc.clearCoatNormalMap.texCoord;
                    pbrMaterial.clearcoatNormalTexCoordMatrix = cc.clearCoatNormalMap.transform;
                }
            }
            pbrMaterial.vertexTangent = assetPBRMaterial.common.useTangent;
            pbrMaterial.vertexColor = assetPBRMaterial.common.vertexColor;
            if (assetPBRMaterial.common.alphaMode === 'blend') {
                pbrMaterial.blendMode = 'blend';
            } else if (assetPBRMaterial.common.alphaMode === 'mask') {
                pbrMaterial.alphaCutoff = assetPBRMaterial.common.alphaCutoff;
            }
            if (assetPBRMaterial.common.doubleSided) {
                const rasterizerState = pbrMaterial.stateSet.useRasterizerState();
                rasterizerState.setCullMode('none');
            }
            pbrMaterial.vertexNormal = !!assetMaterial.common.vertexNormal;
            return pbrMaterial;
        }
    }
    /** @internal */ async _loadMaterial(gltf, materialInfo, vertexColor, vertexNormal, useTangent) {
        let assetMaterial = null;
        let pbrMetallicRoughness = null;
        let pbrSpecularGlossness = null;
        const pbrCommon = {
            useTangent,
            vertexColor,
            vertexNormal,
            bumpScale: 1,
            emissiveColor: Vector3.zero(),
            emissiveStrength: 1,
            occlusionStrength: 1
        };
        switch(materialInfo?.alphaMode){
            case 'BLEND':
                {
                    pbrCommon.alphaMode = 'blend';
                    break;
                }
            case 'MASK':
                {
                    pbrCommon.alphaMode = 'mask';
                    pbrCommon.alphaCutoff = materialInfo.alphaCutoff ?? 0.5;
                    break;
                }
        }
        if (materialInfo?.doubleSided) {
            pbrCommon.doubleSided = true;
        }
        if (materialInfo?.pbrMetallicRoughness || materialInfo?.extensions?.KHR_materials_pbrSpecularGlossiness) {
            pbrCommon.normalMap = materialInfo.normalTexture ? await this._loadTexture(gltf, materialInfo.normalTexture, false) : null;
            pbrCommon.bumpScale = materialInfo.normalTexture?.scale ?? 1;
            pbrCommon.occlusionMap = materialInfo.occlusionTexture ? await this._loadTexture(gltf, materialInfo.occlusionTexture, false) : null;
            pbrCommon.occlusionStrength = materialInfo.occlusionTexture?.strength ?? 1;
            pbrCommon.emissiveMap = materialInfo.emissiveTexture ? await this._loadTexture(gltf, materialInfo.emissiveTexture, false) : null;
            pbrCommon.emissiveStrength = materialInfo?.extensions?.KHR_materials_emissive_strength?.emissiveStrength ?? 1;
            pbrCommon.emissiveColor = materialInfo.emissiveFactor ? new Vector3(materialInfo.emissiveFactor) : Vector3.zero();
        }
        if (materialInfo?.pbrMetallicRoughness) {
            pbrMetallicRoughness = {
                type: 'pbrMetallicRoughness',
                ior: 1.5,
                common: pbrCommon
            };
            pbrMetallicRoughness.diffuse = new Vector4(materialInfo.pbrMetallicRoughness.baseColorFactor ?? [
                1,
                1,
                1,
                1
            ]);
            pbrMetallicRoughness.metallic = materialInfo.pbrMetallicRoughness.metallicFactor ?? 1;
            pbrMetallicRoughness.roughness = materialInfo.pbrMetallicRoughness.roughnessFactor ?? 1;
            pbrMetallicRoughness.diffuseMap = materialInfo.pbrMetallicRoughness.baseColorTexture ? await this._loadTexture(gltf, materialInfo.pbrMetallicRoughness.baseColorTexture, true) : null;
            pbrMetallicRoughness.metallicMap = materialInfo.pbrMetallicRoughness.metallicRoughnessTexture ? await this._loadTexture(gltf, materialInfo.pbrMetallicRoughness.metallicRoughnessTexture, false) : null;
            pbrMetallicRoughness.metallicIndex = 2;
            pbrMetallicRoughness.roughnessIndex = 1;
        }
        if (materialInfo?.extensions?.KHR_materials_pbrSpecularGlossiness) {
            const sg = materialInfo.extensions?.KHR_materials_pbrSpecularGlossiness;
            pbrSpecularGlossness = {
                type: 'pbrSpecularGlossiness',
                ior: 1.5,
                common: pbrCommon
            };
            pbrSpecularGlossness.diffuse = new Vector4(sg.diffuseFactor ?? [
                1,
                1,
                1,
                1
            ]);
            pbrSpecularGlossness.specular = new Vector3(sg.specularFactor ?? [
                1,
                1,
                1
            ]);
            pbrSpecularGlossness.glossness = sg.glossnessFactor ?? 1;
            pbrSpecularGlossness.diffuseMap = sg.diffuseTexture ? await this._loadTexture(gltf, sg.diffuseTexture, true) : null;
            pbrSpecularGlossness.specularGlossnessMap = sg.specularGlossinessTexture ? await this._loadTexture(gltf, sg.specularGlossinessTexture, true) : null;
        }
        assetMaterial = pbrSpecularGlossness || pbrMetallicRoughness;
        if (!assetMaterial || materialInfo?.extensions?.KHR_materials_unlit) {
            if (materialInfo?.extensions?.KHR_materials_unlit) {
                assetMaterial = {
                    type: 'unlit',
                    common: pbrCommon,
                    diffuse: pbrMetallicRoughness?.diffuse ?? Vector4.one(),
                    diffuseMap: pbrMetallicRoughness?.diffuseMap ?? null
                };
            } else {
                assetMaterial = {
                    type: 'pbrMetallicRoughness',
                    common: pbrCommon,
                    diffuse: Vector4.one(),
                    metallic: 1,
                    roughness: 1,
                    diffuseMap: null,
                    metallicMap: null,
                    metallicIndex: 2,
                    roughnessIndex: 1
                };
            }
        }
        if (assetMaterial.type !== 'unlit' && materialInfo?.extensions?.KHR_materials_ior) {
            assetMaterial.ior = materialInfo.extensions.KHR_materials_ior.ior ?? 1.5;
        }
        if (assetMaterial.type === 'pbrMetallicRoughness') {
            pbrMetallicRoughness = assetMaterial;
            // KHR_materials_specular extension
            const specularColorFactor = materialInfo?.extensions?.KHR_materials_specular?.specularColorFactor ?? [
                1,
                1,
                1
            ];
            pbrMetallicRoughness.specularFactor = new Vector4(...specularColorFactor, materialInfo?.extensions?.KHR_materials_specular?.specularFactor ?? 1);
            pbrMetallicRoughness.specularMap = materialInfo?.extensions?.KHR_materials_specular?.specularTexture ? await this._loadTexture(gltf, materialInfo.extensions.KHR_materials_specular.specularTexture, false) : null;
            pbrMetallicRoughness.specularColorMap = materialInfo?.extensions?.KHR_materials_specular?.specularColorTexture ? await this._loadTexture(gltf, materialInfo.extensions.KHR_materials_specular.specularColorTexture, true) : null;
            // KHR_materials_sheen
            const sheen = materialInfo?.extensions?.KHR_materials_sheen;
            if (sheen) {
                pbrMetallicRoughness.sheen = {
                    sheenColorFactor: new Vector3(sheen.sheenColorFactor ?? [
                        0,
                        0,
                        0
                    ]),
                    sheenColorMap: sheen.sheenColorTexture ? await this._loadTexture(gltf, sheen.sheenColorTexture, true) : null,
                    sheenRoughnessFactor: sheen.sheenRoughnessFactor ?? 0,
                    sheenRoughnessMap: sheen.sheenRoughnessTexture ? await this._loadTexture(gltf, sheen.sheenRoughnessTexture, true) : null
                };
            }
            // KHR_materials_clearcoat
            const cc = materialInfo?.extensions?.KHR_materials_clearcoat;
            if (cc) {
                pbrMetallicRoughness.clearcoat = {
                    clearCoatFactor: cc.clearcoatFactor ?? 0,
                    clearCoatIntensityMap: cc.clearcoatTexture ? await this._loadTexture(gltf, cc.clearcoatTexture, false) : null,
                    clearCoatRoughnessFactor: cc.clearcoatRoughnessFactor ?? 0,
                    clearCoatRoughnessMap: cc.clearcoatRoughnessTexture ? await this._loadTexture(gltf, cc.clearcoatRoughnessTexture, false) : null,
                    clearCoatNormalMap: cc.clearcoatNormalTexture ? await this._loadTexture(gltf, cc.clearcoatNormalTexture, false) : null
                };
            }
        }
        return await this._createMaterial(gltf._manager, assetMaterial);
    }
    /** @internal */ async _loadTexture(gltf, info, sRGB) {
        const mt = {
            texture: null,
            sampler: null,
            texCoord: info.texCoord ?? 0,
            transform: null
        };
        const textureInfo = gltf.textures[info.index];
        if (textureInfo) {
            if (info.extensions?.KHR_texture_transform) {
                const uvTransform = info.extensions.KHR_texture_transform;
                if (uvTransform.texCoord !== undefined) {
                    mt.texCoord = uvTransform.texCoord;
                }
                const rotation = uvTransform.rotation !== undefined ? Matrix4x4.rotationZ(-uvTransform.rotation) : Matrix4x4.identity();
                const scale = uvTransform.scale !== undefined ? new Vector3(uvTransform.scale[0], uvTransform.scale[1], 1) : Vector3.one();
                const translation = uvTransform.offset !== undefined ? new Vector3(uvTransform.offset[0], uvTransform.offset[1], 0) : Vector3.zero();
                mt.transform = Matrix4x4.scaling(scale).multiplyLeft(rotation).translateLeft(translation);
            }
            let wrapS = 'repeat';
            let wrapT = 'repeat';
            let magFilter = 'linear';
            let minFilter = 'linear';
            let mipFilter = 'linear';
            const samplerIndex = textureInfo.sampler;
            const sampler = gltf.samplers && gltf.samplers[samplerIndex];
            if (sampler) {
                switch(sampler.wrapS){
                    case 0x2901:
                        wrapS = 'repeat';
                        break;
                    case 0x8370:
                        wrapS = 'mirrored-repeat';
                        break;
                    case 0x812f:
                        wrapS = 'clamp';
                        break;
                }
                switch(sampler.wrapT){
                    case 0x2901:
                        wrapT = 'repeat';
                        break;
                    case 0x8370:
                        wrapT = 'mirrored-repeat';
                        break;
                    case 0x812f:
                        wrapT = 'clamp';
                        break;
                }
                switch(sampler.magFilter){
                    case 0x2600:
                        magFilter = 'nearest';
                        break;
                    case 0x2601:
                        magFilter = 'linear';
                        break;
                }
                switch(sampler.minFilter){
                    case 0x2600:
                        minFilter = 'nearest';
                        mipFilter = 'none';
                        break;
                    case 0x2601:
                        minFilter = 'linear';
                        mipFilter = 'none';
                        break;
                    case 0x2700:
                        minFilter = 'nearest';
                        mipFilter = 'nearest';
                        break;
                    case 0x2701:
                        minFilter = 'linear';
                        mipFilter = 'nearest';
                        break;
                    case 0x2702:
                        minFilter = 'nearest';
                        mipFilter = 'linear';
                        break;
                    case 0x2703:
                        minFilter = 'linear';
                        mipFilter = 'linear';
                        break;
                }
            }
            const imageIndex = textureInfo.source;
            const hash = `${imageIndex}:${!!sRGB}:${wrapS}:${wrapT}:${minFilter}:${magFilter}:${mipFilter}`;
            mt.texture = gltf._textureCache[hash];
            if (!mt.texture) {
                const image = gltf.images[imageIndex];
                if (image) {
                    if (image.uri) {
                        const imageUrl = this._normalizeURI(gltf._baseURI, image.uri);
                        mt.texture = await gltf._manager.fetchTexture(imageUrl, {
                            linearColorSpace: !sRGB
                        });
                        mt.texture.name = imageUrl;
                    } else if (typeof image.bufferView === 'number' && image.mimeType) {
                        const bufferView = gltf.bufferViews && gltf.bufferViews[image.bufferView];
                        if (bufferView) {
                            const arrayBuffer = gltf._loadedBuffers && gltf._loadedBuffers[bufferView.buffer];
                            if (arrayBuffer) {
                                const view = new Uint8Array(arrayBuffer, bufferView.byteOffset || 0, bufferView.byteLength);
                                const mimeType = image.mimeType;
                                const blob = new Blob([
                                    view
                                ], {
                                    type: mimeType
                                });
                                const sourceURI = URL.createObjectURL(blob);
                                mt.texture = await gltf._manager.fetchTexture(sourceURI, {
                                    mimeType,
                                    linearColorSpace: !sRGB
                                });
                                URL.revokeObjectURL(sourceURI);
                            }
                        }
                    }
                }
                if (mt.texture) {
                    gltf._textureCache[hash] = mt.texture;
                }
            }
            if (mt.texture) {
                mt.sampler = Application.instance.device.createSampler({
                    addressU: wrapS,
                    addressV: wrapT,
                    magFilter: magFilter,
                    minFilter: minFilter,
                    mipFilter: mipFilter
                });
            }
        }
        return mt;
    }
    /** @internal */ _primitiveType(type) {
        switch(type){
            case 0:
                return 'point-list';
            case 1:
                return 'line-list';
            /* FIXME:
      case 2: // GL_LINE_LOOP
        return PrimitiveType.LineLoop;
      */ case 3:
                return 'line-strip';
            case 4:
                return 'triangle-list';
            case 5:
                return 'triangle-strip';
            case 6:
                return 'triangle-fan';
            default:
                return null;
        }
    }
    /** @internal */ _loadIndexBuffer(gltf, accessorIndex, primitive, meshData) {
        this._setBuffer(gltf, accessorIndex, primitive, null, meshData);
    }
    /** @internal */ _loadVertexBuffer(gltf, attribName, accessorIndex, primitive, subMeshData) {
        let semantic = null;
        switch(attribName){
            case 'POSITION':
                semantic = 'position';
                break;
            case 'NORMAL':
                semantic = 'normal';
                break;
            case 'TANGENT':
                semantic = 'tangent';
                break;
            case 'TEXCOORD_0':
                semantic = 'texCoord0';
                break;
            case 'TEXCOORD_1':
                semantic = 'texCoord1';
                break;
            case 'TEXCOORD_2':
                semantic = 'texCoord2';
                break;
            case 'TEXCOORD_3':
                semantic = 'texCoord3';
                break;
            case 'TEXCOORD_4':
                semantic = 'texCoord4';
                break;
            case 'TEXCOORD_5':
                semantic = 'texCoord5';
                break;
            case 'TEXCOORD_6':
                semantic = 'texCoord6';
                break;
            case 'TEXCOORD_7':
                semantic = 'texCoord7';
                break;
            case 'COLOR_0':
                semantic = 'diffuse';
                break;
            case 'JOINTS_0':
                semantic = 'blendIndices';
                break;
            case 'WEIGHTS_0':
                semantic = 'blendWeights';
                break;
            default:
                return;
        }
        this._setBuffer(gltf, accessorIndex, primitive, semantic, subMeshData);
    }
    /** @internal */ _setBuffer(gltf, accessorIndex, primitive, semantic, subMeshData) {
        const device = Application.instance.device;
        const accessor = gltf._accessors[accessorIndex];
        const componentCount = accessor.getComponentCount(accessor.type);
        const normalized = !!accessor.normalized;
        const hash = `${accessorIndex}:${semantic || ''}:${Number(normalized)}`;
        let buffer = gltf._bufferCache[hash];
        if (!buffer) {
            let data = accessor.getNormalizedDeinterlacedView(gltf);
            if (semantic && !(data instanceof Float32Array)) {
                const floatData = new Float32Array(data.length);
                floatData.set(data);
                data = floatData;
            }
            if (!semantic) {
                if (!(data instanceof Uint8Array) && !(data instanceof Uint16Array) && !(data instanceof Uint32Array)) {
                    console.error('Invalid index buffer component type');
                    return;
                }
                if (data instanceof Uint32Array && !device.getDeviceCaps().miscCaps.support32BitIndex) {
                    console.error('Device does not support 32bit vertex index');
                    return;
                }
                if (data instanceof Uint8Array) {
                    const uint16Data = new Uint16Array(data.length);
                    uint16Data.set(data);
                    data = uint16Data;
                }
            }
            if (!semantic) {
                buffer = device.createIndexBuffer(data, {
                    managed: true
                });
            } else {
                const attribFormat = device.getVertexAttribFormat(semantic, 'f32', componentCount);
                buffer = device.createVertexBuffer(attribFormat, data);
            }
            gltf._bufferCache[hash] = buffer;
        }
        if (buffer) {
            if (!semantic) {
                primitive.setIndexBuffer(buffer);
                primitive.indexCount = buffer.length;
            } else {
                primitive.setVertexBuffer(buffer);
                if (semantic === 'position') {
                    if (!primitive.getIndexBuffer()) {
                        primitive.indexCount = Math.floor(buffer.byteLength / 12);
                    }
                    const data = accessor.getNormalizedDeinterlacedView(gltf);
                    subMeshData.rawPositions = data;
                    const min = accessor.min;
                    const max = accessor.max;
                    if (min && max) {
                        primitive.setBoundingVolume(new BoundingBox(new Vector3(min), new Vector3(max)));
                    } else {
                        const bbox = new BoundingBox();
                        bbox.beginExtend();
                        for(let i = 0; i < data.length; i++){
                            const v = new Vector3(data[i * componentCount], data[i * componentCount + 1], data[i * componentCount + 2]);
                            bbox.extend(v);
                        }
                        if (bbox.isValid()) {
                            primitive.setBoundingVolume(bbox);
                        }
                    }
                } else if (semantic === 'blendIndices') {
                    subMeshData.rawBlendIndices = accessor.getNormalizedDeinterlacedView(gltf);
                } else if (semantic === 'blendWeights') {
                    subMeshData.rawJointWeights = accessor.getNormalizedDeinterlacedView(gltf);
                }
            }
        }
        return buffer;
    }
    /** @internal */ isGLB(data) {
        if (data.byteLength > 12) {
            const p = new Uint32Array(data, 0, 3);
            if (p[0] === 0x46546c67 && p[1] === 2 && p[2] === data.byteLength) {
                return true;
            }
        }
        return false;
    }
    /** @internal */ getGLBChunkInfo(data, offset) {
        const header = new Uint32Array(data, offset, 2);
        const start = offset + 8;
        const length = header[0];
        const type = header[1];
        return {
            start,
            length,
            type
        };
    }
    /** @internal */ getGLBChunkInfos(data) {
        const infos = [];
        let offset = 12;
        while(offset < data.byteLength){
            const info = this.getGLBChunkInfo(data, offset);
            infos.push(info);
            offset += info.length + 8;
        }
        return infos;
    }
}

/**
 * Web image loader
 * @internal
 */ class WebImageLoader extends AbstractTextureLoader {
    supportExtension(ext) {
        return ext === '.jpg' || ext === '.jpeg' || ext === '.png';
    }
    supportMIMEType(mimeType) {
        return mimeType === 'image/jpg' || mimeType === 'image/jpeg' || mimeType === 'image/png';
    }
    async load(assetManager, filename, mimeType, data, srgb, samplerOptions, texture) {
        return new Promise((resolve, reject)=>{
            if (!mimeType) {
                reject('unknown image file type');
            }
            const src = URL.createObjectURL(new Blob([
                data
            ], {
                type: mimeType
            }));
            const img = document.createElement('img');
            img.src = src;
            img.onload = function() {
                createImageBitmap(img, {
                    premultiplyAlpha: 'none'
                }).then((bm)=>{
                    const options = {
                        texture: texture,
                        samplerOptions
                    };
                    const tex = Application.instance.device.createTexture2DFromImage(bm, srgb, options);
                    if (tex) {
                        resolve(tex);
                    } else {
                        reject('create texture from image element failed');
                    }
                });
            };
            img.onerror = (err)=>{
                reject(err);
            };
        });
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */ const DDSHeaderSize = 31; // in DWORD
const DDSHeaderSizeExtended = 31 + 5; // in DWORD
const DDS_MAGIC = 0x20534444; // magic
const DDPF_ALPHAPIXELS = 0x1;
const DDPF_ALPHA = 0x2;
const DDPF_FOURCC = 0x4;
const DDPF_RGB = 0x40;
const DDPF_LUMINANCE = 0x20000;
const DDSCAPS2_CUBEMAP = 0x200;
const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;
const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;
const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;
const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;
const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;
const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;
const DDS_CUBEMAP_ALLFACES = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX | DDSCAPS2_CUBEMAP_NEGATIVEX | DDSCAPS2_CUBEMAP_POSITIVEY | DDSCAPS2_CUBEMAP_NEGATIVEY | DDSCAPS2_CUBEMAP_POSITIVEZ | DDSCAPS2_CUBEMAP_NEGATIVEZ;
const DDSCAPS2_VOLUME = 0x200000;
var DX10ResourceDimension;
(function(DX10ResourceDimension) {
    DX10ResourceDimension[DX10ResourceDimension["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
    DX10ResourceDimension[DX10ResourceDimension["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
    DX10ResourceDimension[DX10ResourceDimension["DDS_DIMENSION_TEXTURE3D"] = 4] = "DDS_DIMENSION_TEXTURE3D";
})(DX10ResourceDimension || (DX10ResourceDimension = {}));
var DXGIFormat;
(function(DXGIFormat) {
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA32F"] = 2] = "DXGI_FORMAT_RGBA32F";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA32UI"] = 3] = "DXGI_FORMAT_RGBA32UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA32I"] = 4] = "DXGI_FORMAT_RGBA32I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGB32F"] = 6] = "DXGI_FORMAT_RGB32F";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGB32UI"] = 7] = "DXGI_FORMAT_RGB32UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGB32I"] = 8] = "DXGI_FORMAT_RGB32I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA16F"] = 10] = "DXGI_FORMAT_RGBA16F";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA16UI"] = 12] = "DXGI_FORMAT_RGBA16UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA16I"] = 14] = "DXGI_FORMAT_RGBA16I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RG32F"] = 16] = "DXGI_FORMAT_RG32F";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RG32UI"] = 17] = "DXGI_FORMAT_RG32UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RG32I"] = 18] = "DXGI_FORMAT_RG32I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA8"] = 28] = "DXGI_FORMAT_RGBA8";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA8_SRGB"] = 29] = "DXGI_FORMAT_RGBA8_SRGB";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA8UI"] = 30] = "DXGI_FORMAT_RGBA8UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RGBA8I"] = 32] = "DXGI_FORMAT_RGBA8I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RG16F"] = 34] = "DXGI_FORMAT_RG16F";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RG16UI"] = 36] = "DXGI_FORMAT_RG16UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_RG16I"] = 38] = "DXGI_FORMAT_RG16I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_R32F"] = 41] = "DXGI_FORMAT_R32F";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_R32UI"] = 42] = "DXGI_FORMAT_R32UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_R32I"] = 43] = "DXGI_FORMAT_R32I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_R16F"] = 54] = "DXGI_FORMAT_R16F";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_R16UI"] = 57] = "DXGI_FORMAT_R16UI";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_R16I"] = 59] = "DXGI_FORMAT_R16I";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_BGR565"] = 85] = "DXGI_FORMAT_BGR565";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_BGRA5551"] = 86] = "DXGI_FORMAT_BGRA5551";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_BGRA8"] = 87] = "DXGI_FORMAT_BGRA8";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_BGRX8"] = 88] = "DXGI_FORMAT_BGRX8";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_BGRA8_SRGB"] = 91] = "DXGI_FORMAT_BGRA8_SRGB";
    DXGIFormat[DXGIFormat["DXGI_FORMAT_BGRX8_SRGB"] = 93] = "DXGI_FORMAT_BGRX8_SRGB";
})(DXGIFormat || (DXGIFormat = {}));
var D3DFormat;
(function(D3DFormat) {
    D3DFormat[D3DFormat["D3DFMT_RGB8"] = 20] = "D3DFMT_RGB8";
    D3DFormat[D3DFormat["D3DFMT_ARGB8"] = 21] = "D3DFMT_ARGB8";
    D3DFormat[D3DFormat["D3DFMT_XRGB8"] = 22] = "D3DFMT_XRGB8";
    D3DFormat[D3DFormat["D3DFMT_RGB565"] = 23] = "D3DFMT_RGB565";
    D3DFormat[D3DFormat["D3DFMT_XRGB1555"] = 24] = "D3DFMT_XRGB1555";
    D3DFormat[D3DFormat["D3DFMT_ARGB1555"] = 25] = "D3DFMT_ARGB1555";
    D3DFormat[D3DFormat["D3DFMT_ARGB4"] = 26] = "D3DFMT_ARGB4";
    D3DFormat[D3DFormat["D3DFMT_A8"] = 28] = "D3DFMT_A8";
    D3DFormat[D3DFormat["D3DFMT_XRGB4"] = 30] = "D3DFMT_XRGB4";
    D3DFormat[D3DFormat["D3DFMT_ABGR8"] = 32] = "D3DFMT_ABGR8";
    D3DFormat[D3DFormat["D3DFMT_XBGR8"] = 33] = "D3DFMT_XBGR8";
    D3DFormat[D3DFormat["D3DFMT_A8P8"] = 40] = "D3DFMT_A8P8";
    D3DFormat[D3DFormat["D3DFMT_P8"] = 41] = "D3DFMT_P8";
    D3DFormat[D3DFormat["D3DFMT_L8"] = 50] = "D3DFMT_L8";
    D3DFormat[D3DFormat["D3DFMT_A8L8"] = 51] = "D3DFMT_A8L8";
    D3DFormat[D3DFormat["D3DFMT_DXT1"] = FourCCToInt32('DXT1')] = "D3DFMT_DXT1";
    D3DFormat[D3DFormat["D3DFMT_DXT2"] = FourCCToInt32('DXT2')] = "D3DFMT_DXT2";
    D3DFormat[D3DFormat["D3DFMT_DXT3"] = FourCCToInt32('DXT3')] = "D3DFMT_DXT3";
    D3DFormat[D3DFormat["D3DFMT_DXT4"] = FourCCToInt32('DXT4')] = "D3DFMT_DXT4";
    D3DFormat[D3DFormat["D3DFMT_DXT5"] = FourCCToInt32('DXT5')] = "D3DFMT_DXT5";
    D3DFormat[D3DFormat["D3DFMT_R16F"] = 111] = "D3DFMT_R16F";
    D3DFormat[D3DFormat["D3DFMT_RG16F"] = 112] = "D3DFMT_RG16F";
    D3DFormat[D3DFormat["D3DFMT_RGBA16F"] = 113] = "D3DFMT_RGBA16F";
    D3DFormat[D3DFormat["D3DFMT_R32F"] = 114] = "D3DFMT_R32F";
    D3DFormat[D3DFormat["D3DFMT_RG32F"] = 115] = "D3DFMT_RG32F";
    D3DFormat[D3DFormat["D3DFMT_RGBA32F"] = 116] = "D3DFMT_RGBA32F";
})(D3DFormat || (D3DFormat = {}));
function FourCCToInt32(value) {
    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
    return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);
}
function loadDDSHeader(dds) {
    const ddsHeader = {};
    const header = new Uint32Array(dds, 0, DDSHeaderSize + 1);
    const magic = header[0];
    if (magic !== DDS_MAGIC) {
        console.log('Invalid DDS magic');
        return null;
    }
    ddsHeader.dwSize = header[1];
    if (ddsHeader.dwSize !== 124) {
        console.log('Invalid DDS header size');
        return null;
    }
    ddsHeader.dataOffset = ddsHeader.dwSize + 4;
    ddsHeader.dwFlags = header[2];
    ddsHeader.dwHeight = header[3];
    ddsHeader.dwWidth = header[4];
    ddsHeader.dwPitchOrLinearSize = header[5];
    ddsHeader.dwDepth = header[6];
    ddsHeader.dwMipmapCount = header[7];
    ddsHeader.ddsPixelFormat = {};
    ddsHeader.ddsPixelFormat.dwFlags = header[20];
    ddsHeader.ddsPixelFormat.dwFourCC = header[21];
    ddsHeader.ddsPixelFormat.dwRGBBitCount = header[22];
    ddsHeader.ddsPixelFormat.dwRBitMask = header[23];
    ddsHeader.ddsPixelFormat.dwGBitMask = header[24];
    ddsHeader.ddsPixelFormat.dwBBitMask = header[25];
    ddsHeader.ddsPixelFormat.dwABitMask = header[26];
    ddsHeader.dwCaps = header[27];
    ddsHeader.dwCaps2 = header[28];
    ddsHeader.dwCaps3 = header[29];
    ddsHeader.dwCaps4 = header[30];
    if (Int32ToFourCC(ddsHeader.ddsPixelFormat.dwFourCC) === 'DX10') {
        const headerEx = new Uint32Array(dds, 0, DDSHeaderSizeExtended + 1);
        ddsHeader.ddsHeaderDX10 = {};
        ddsHeader.ddsHeaderDX10.dxgiFormat = headerEx[32];
        ddsHeader.ddsPixelFormat.dwFourCC = ddsHeader.ddsHeaderDX10.dxgiFormat;
        ddsHeader.ddsHeaderDX10.dimension = headerEx[33];
        ddsHeader.ddsHeaderDX10.miscFlag = headerEx[34];
        ddsHeader.ddsHeaderDX10.arraySize = headerEx[35];
        ddsHeader.dataOffset += 5 * 4;
    }
    return ddsHeader;
}
var DDSConvert;
(function(DDSConvert) {
    DDSConvert[DDSConvert["RGB_SWIZZLE"] = 1] = "RGB_SWIZZLE";
    DDSConvert[DDSConvert["ALPHA_ONE"] = 22] = "ALPHA_ONE";
})(DDSConvert || (DDSConvert = {}));
const dxgiFormatMap = {
    [2]: 'rgba32f',
    [3]: 'rgba32ui',
    [4]: 'rgba32i',
    [10]: 'rgba16f',
    [12]: 'rgba16ui',
    [14]: 'rgba16i',
    [16]: 'rg32f',
    [17]: 'rg32ui',
    [18]: 'rg32i',
    [28]: 'rgba8unorm',
    [29]: 'rgba8unorm-srgb',
    [30]: 'rgba8ui',
    [31]: 'rgba8snorm',
    [32]: 'rgba8i',
    [34]: 'rg16f',
    [36]: 'rg16ui',
    [38]: 'rg16i',
    [41]: 'r32f',
    [42]: 'r32ui',
    [43]: 'r32i',
    [49]: 'rg8unorm',
    [50]: 'rg8ui',
    [51]: 'rg8snorm',
    [52]: 'rg8i',
    [54]: 'r16f',
    [57]: 'r16ui',
    [59]: 'r16i',
    [61]: 'r8unorm',
    [62]: 'r8ui',
    [63]: 'r8snorm',
    [64]: 'r8i',
    [71]: 'dxt1',
    [72]: 'dxt1-srgb',
    [74]: 'dxt3',
    [75]: 'dxt3-srgb',
    [77]: 'dxt5',
    [78]: 'dxt5-srgb'
};
const legacyDDSMap = [
    {
        format: 'dxt1',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: FourCCToInt32('DXT1')
        }
    },
    {
        format: 'dxt3',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: FourCCToInt32('DXT3')
        }
    },
    {
        format: 'dxt5',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: FourCCToInt32('DXT5')
        }
    },
    {
        format: 'bgra8unorm',
        convertFlags: 1,
        pf: {
            dwFlags: DDPF_RGB | DDPF_ALPHAPIXELS,
            dwRGBBitCount: 32,
            dwRBitMask: 0x00ff0000,
            dwGBitMask: 0x0000ff00,
            dwBBitMask: 0x000000ff,
            dwABitMask: 0xff000000
        }
    },
    {
        format: 'bgra8unorm',
        convertFlags: 1 | 22,
        pf: {
            dwFlags: DDPF_RGB,
            dwRGBBitCount: 32,
            dwRBitMask: 0x00ff0000,
            dwGBitMask: 0x0000ff00,
            dwBBitMask: 0x000000ff
        }
    },
    {
        format: 'rgba8unorm',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_RGB | DDPF_ALPHAPIXELS,
            dwRGBBitCount: 32,
            dwRBitMask: 0x000000ff,
            dwGBitMask: 0x0000ff00,
            dwBBitMask: 0x00ff0000,
            dwABitMask: 0xff000000
        }
    },
    {
        format: 'rgba8unorm',
        convertFlags: 22,
        pf: {
            dwFlags: DDPF_RGB,
            dwRGBBitCount: 32,
            dwRBitMask: 0x000000ff,
            dwGBitMask: 0x0000ff00,
            dwBBitMask: 0x00ff0000
        }
    },
    {
        format: 'r16f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: 111
        }
    },
    {
        format: 'r16f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: DXGIFormat.DXGI_FORMAT_R16F
        }
    },
    {
        format: 'rg16f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: 112
        }
    },
    {
        format: 'rg16f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: DXGIFormat.DXGI_FORMAT_RG16F
        }
    },
    {
        format: 'rgba16f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: 113
        }
    },
    {
        format: 'rgba16f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: DXGIFormat.DXGI_FORMAT_RGBA16F
        }
    },
    {
        format: 'r32f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: 114
        }
    },
    {
        format: 'r32f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: DXGIFormat.DXGI_FORMAT_R32F
        }
    },
    {
        format: 'rg32f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: 115
        }
    },
    {
        format: 'rg32f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: DXGIFormat.DXGI_FORMAT_RG32F
        }
    },
    {
        format: 'rgba32f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: 116
        }
    },
    {
        format: 'rgba32f',
        convertFlags: 0,
        pf: {
            dwFlags: DDPF_FOURCC,
            dwFourCC: DXGIFormat.DXGI_FORMAT_RGBA32F
        }
    }
];
function getTextureFormat(header) {
    if (header.ddsHeaderDX10) {
        const format = header.ddsHeaderDX10 ? dxgiFormatMap[header.ddsHeaderDX10.dxgiFormat] : null;
        if (format) {
            return format;
        }
    }
    const pf = header.ddsPixelFormat;
    const flags = pf.dwFlags;
    let index;
    for(index = 0; index < legacyDDSMap.length; index++){
        const entry = legacyDDSMap[index];
        if (flags & DDPF_FOURCC && entry.pf.dwFlags & DDPF_FOURCC) {
            if (pf.dwFourCC === entry.pf.dwFourCC) {
                break;
            }
        } else if (flags === entry.pf.dwFlags) {
            if (flags & DDPF_ALPHA) {
                if (pf.dwRGBBitCount === entry.pf.dwRGBBitCount && pf.dwABitMask === entry.pf.dwABitMask) {
                    break;
                }
            } else if (flags & DDPF_LUMINANCE) {
                if (pf.dwRGBBitCount === entry.pf.dwRGBBitCount && pf.dwRBitMask === entry.pf.dwRBitMask) {
                    if (pf.dwABitMask === entry.pf.dwABitMask || !(flags & DDPF_ALPHAPIXELS)) {
                        break;
                    }
                }
            } else if (pf.dwRGBBitCount === entry.pf.dwRGBBitCount) {
                if (pf.dwRBitMask === entry.pf.dwRBitMask && pf.dwGBitMask === entry.pf.dwGBitMask && pf.dwBBitMask === entry.pf.dwBBitMask) {
                    if (pf.dwABitMask === entry.pf.dwABitMask || !(flags & DDPF_ALPHAPIXELS)) {
                        break;
                    }
                }
            }
        }
    }
    if (index === legacyDDSMap.length) {
        return null;
    }
    return legacyDDSMap[index].format;
}
function getMetaDataFromHeader(header, metaData) {
    metaData = metaData || {};
    metaData.format = getTextureFormat(header);
    if (metaData.format === null) {
        return null;
    }
    metaData.isCompressed = metaData.format === 'dxt1' || metaData.format === 'dxt3' || metaData.format === 'dxt5';
    metaData.dataOffset = header.ddsHeaderDX10 ? 37 * 4 : 32 * 4;
    metaData.width = header.dwWidth;
    metaData.height = header.dwHeight;
    metaData.depth = 1;
    metaData.mipLevels = header.dwMipmapCount || 1;
    metaData.arraySize = header.ddsHeaderDX10 ? header.ddsHeaderDX10.arraySize : 1;
    metaData.isCubemap = metaData.isVolume = false;
    if (header.dwCaps2 & DDS_CUBEMAP_ALLFACES) {
        metaData.isCubemap = true;
        metaData.arraySize *= 6;
    } else if (header.dwCaps2 & DDSCAPS2_VOLUME) {
        metaData.isVolume = true;
        metaData.depth = header.dwDepth;
    } else if (header.ddsHeaderDX10) {
        metaData.isArray = true;
        metaData.depth = header.ddsHeaderDX10.arraySize;
    }
    return metaData;
}
function getMipmapData(dds, width, height, format, dataOffset) {
    switch(format){
        case 'r16f':
            return new Uint16Array(dds, dataOffset, width * height);
        case 'rg16f':
            return new Uint16Array(dds, dataOffset, width * height * 2);
        case 'r32f':
            return new Float32Array(dds, dataOffset, width * height);
        case 'rgba8unorm':
        case 'bgra8unorm':
            return new Uint8Array(dds, dataOffset, width * height * 4);
        case 'rgba16f':
            return new Uint16Array(dds, dataOffset, width * height * 4);
        case 'rg32f':
            return new Float32Array(dds, dataOffset, width * height * 2);
        case 'rgba32f':
            return new Float32Array(dds, dataOffset, width * height * 4);
        case 'dxt1':
            return new Uint8Array(dds, dataOffset, Math.max(4, width) / 4 * Math.max(4, height) / 4 * 8);
        case 'dxt3':
        case 'dxt5':
            return new Uint8Array(dds, dataOffset, Math.max(4, width) / 4 * Math.max(4, height) / 4 * 16);
        default:
            return null;
    }
}
/** @internal */ function getDDSMipLevelsInfo(dds) {
    const ddsHeader = loadDDSHeader(dds);
    if (!ddsHeader) {
        return null;
    }
    const ddsLevelsInfo = {};
    getMetaDataFromHeader(ddsHeader, ddsLevelsInfo);
    ddsLevelsInfo.mipDatas = [];
    let dataOffset = ddsLevelsInfo.dataOffset;
    for(let i = 0; i < ddsLevelsInfo.arraySize; i++){
        const mipDatas = [];
        let width = ddsLevelsInfo.width;
        let height = ddsLevelsInfo.height;
        for(let mip = 0; mip < ddsLevelsInfo.mipLevels; mip++){
            const mipData = getMipmapData(dds, width, height, ddsLevelsInfo.format, dataOffset);
            mipDatas.push({
                data: mipData,
                width: width,
                height: height
            });
            dataOffset += mipData.byteLength;
            width = Math.max(1, width >> 1);
            height = Math.max(1, height >> 1);
        }
        ddsLevelsInfo.mipDatas.push(mipDatas);
    }
    return ddsLevelsInfo;
}

/**
 * The DDS texture loader
 * @internal
 */ class DDSLoader extends AbstractTextureLoader {
    supportExtension(ext) {
        return ext === '.dds';
    }
    supportMIMEType(mimeType) {
        return mimeType === 'image/dds';
    }
    async load(assetManager, url, mimeType, data, srgb, samplerOptions, texture) {
        const arrayBuffer = data;
        const mipmapLevelData = getDDSMipLevelsInfo(arrayBuffer);
        if (!mipmapLevelData) {
            throw new Error(`read DDS file failed: ${url}`);
        }
        const options = {
            texture: texture,
            samplerOptions
        };
        return Application.instance.device.createTextureFromMipmapData(mipmapLevelData, srgb, options);
    /*
    if (mipmapLevelData.isCubemap) {
      return Application.instance.device.createCubeTextureFromMipmapData(mipmapLevelData, options);
    } else if (mipmapLevelData.isVolume) {
      throw new Error(`load DDS volume texture is not supported`);
    } else {
      return Application.instance.device.createTexture2DFromMipmapData(mipmapLevelData, options);
    }
    */ }
}

const _f16one = floatToHalf(1);
/**
 * The HDR texture loader
 * @internal
 */ class HDRLoader extends AbstractTextureLoader {
    supportExtension(ext) {
        return ext === '.hdr';
    }
    supportMIMEType(mimeType) {
        return mimeType === 'image/hdr';
    }
    async load(assetManager, url, mimeType, data, srgb, samplerOptions, texture) {
        let format;
        for (const fmt of [
            'rg11b10uf',
            'rgba16f',
            'rgba32f',
            'rgba8unorm'
        ]){
            const info = Application.instance.device.getDeviceCaps().textureCaps.getTextureFormatInfo(fmt);
            if (info && info.filterable && info.renderable) {
                format = fmt;
                break;
            }
        }
        const textureData = await this.loadHDR(new Uint8Array(data), format);
        const options = {
            texture: texture,
            samplerOptions
        };
        const tex = Application.instance.device.createTexture2D(format, textureData.width, textureData.height, options);
        tex.update(textureData.dataFloat, 0, 0, textureData.width, textureData.height);
        return tex;
    }
    _rgbeToFloat32(buffer) {
        const length = buffer.byteLength >> 2;
        const result = new Float32Array(length * 4);
        for(let i = 0; i < length; i++){
            const s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
            result[i * 4] = buffer[i * 4] * s;
            result[i * 4 + 1] = buffer[i * 4 + 1] * s;
            result[i * 4 + 2] = buffer[i * 4 + 2] * s;
            result[i * 4 + 3] = 1;
        }
        return result;
    }
    _rgbeToFloat16(buffer) {
        const length = buffer.byteLength >> 2;
        const result = new Uint16Array(length * 4);
        for(let i = 0; i < length; i++){
            const s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
            result[i * 4 + 0] = floatToHalf(Math.max(-65504, Math.min(buffer[i * 4] * s, 65504)));
            result[i * 4 + 1] = floatToHalf(Math.max(-65504, Math.min(buffer[i * 4 + 1] * s, 65504)));
            result[i * 4 + 2] = floatToHalf(Math.max(-65504, Math.min(buffer[i * 4 + 2] * s, 65504)));
            result[i * 4 + 3] = _f16one;
        }
        return result;
    }
    _rgbeToR11G11B10(buffer) {
        const length = buffer.byteLength >> 2;
        const result = new Uint32Array(length);
        for(let i = 0; i < length; i++){
            const s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
            const r = buffer[i * 4] * s;
            const g = buffer[i * 4 + 1] * s;
            const b = buffer[i * 4 + 2] * s;
            result[i] = packFloat3(r, g, b);
        }
        return result;
    }
    /*
    Decode: rgb = pow(6 * rgbm.rgb * rgbm.a, 2.2);
   */ _rgbeToRGBM(buffer) {
        const length = buffer.byteLength >> 2;
        const result = new Uint8Array(length * 4);
        for(let i = 0; i < length; i++){
            const s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
            const r = Math.pow(buffer[i * 4] * s, 1 / 2.2);
            const g = Math.pow(buffer[i * 4 + 1] * s, 1 / 2.2);
            const b = Math.pow(buffer[i * 4 + 2] * s, 1 / 2.2);
            const rgbMax = Math.max(r, g, b);
            const M = Math.ceil(255 * rgbMax / 6) / 255;
            const t = M * 6;
            result[i * 4] = Math.ceil(255 * r / t);
            result[i * 4 + 1] = Math.ceil(255 * g / t);
            result[i * 4 + 2] = Math.ceil(255 * b / t);
            result[i * 4 + 3] = Math.ceil(255 * Math.min(M, 1));
        }
        return result;
    }
    async loadHDR(buffer, dstFormat) {
        let header = '';
        let pos = 0;
        const d8 = buffer;
        let format = undefined;
        // read header.
        while(!header.match(/\n\n[^\n]+\n/g))header += String.fromCharCode(d8[pos++]);
        // check format.
        format = header.match(/FORMAT=(.*)$/m);
        if (format.length < 2) {
            return undefined;
        }
        format = format[1];
        if (format != '32-bit_rle_rgbe') {
            console.warn('unknown format : ' + format);
            return null;
        }
        // parse resolution
        let rez = header.split(/\n/).reverse();
        if (rez.length < 2) {
            return undefined;
        }
        rez = rez[1].split(' ');
        if (rez.length < 4) {
            return undefined;
        }
        const width = Number(rez[3]) * 1, height = Number(rez[1]) * 1;
        // Create image.
        const img = new Uint8Array(width * height * 4);
        let ipos = 0;
        // Read all scanlines
        for(let j = 0; j < height; j++){
            const scanline = [];
            let rgbe = d8.slice(pos, pos += 4);
            const isNewRLE = rgbe[0] == 2 && rgbe[1] == 2 && rgbe[2] == (width >> 8 & 0xff) && rgbe[3] == (width & 0xff);
            if (isNewRLE && width >= 8 && width < 32768) {
                for(let i = 0; i < 4; i++){
                    let ptr = i * width;
                    const ptr_end = (i + 1) * width;
                    let buf = undefined;
                    let count = undefined;
                    while(ptr < ptr_end){
                        buf = d8.slice(pos, pos += 2);
                        if (buf[0] > 128) {
                            count = buf[0] - 128;
                            while(count-- > 0)scanline[ptr++] = buf[1];
                        } else {
                            count = buf[0] - 1;
                            scanline[ptr++] = buf[1];
                            while(count-- > 0)scanline[ptr++] = d8[pos++];
                        }
                    }
                }
                for(let i = 0; i < width; i++){
                    img[ipos++] = scanline[i + 0 * width];
                    img[ipos++] = scanline[i + 1 * width];
                    img[ipos++] = scanline[i + 2 * width];
                    img[ipos++] = scanline[i + 3 * width];
                }
            } else {
                pos -= 4;
                for(let i = 0; i < width; i++){
                    rgbe = d8.slice(pos, pos += 4);
                    img[ipos++] = rgbe[0];
                    img[ipos++] = rgbe[1];
                    img[ipos++] = rgbe[2];
                    img[ipos++] = rgbe[3];
                }
            }
        }
        const imageFloatBuffer = dstFormat === 'rgba32f' ? this._rgbeToFloat32(img) : dstFormat === 'rgba16f' ? this._rgbeToFloat16(img) : dstFormat === 'rg11b10uf' ? this._rgbeToR11G11B10(img) : this._rgbeToRGBM(img);
        return {
            dataFloat: imageFloatBuffer,
            width: width,
            height: height
        };
    }
}

/*
interface MicrofacetDistributionSample {
  pdf?: number;
  cosTheta?: number;
  sinTheta?: number;
  phi?: number;
}
*/ /** @internal */ function getTestCubemapLoader() {
    return async function(assetManager) {
        const tex = Application.instance.device.createCubeTexture('rgba8unorm', 32, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        const fb = Application.instance.device.createFrameBuffer([
            tex
        ], null);
        Application.instance.device.pushDeviceStates();
        Application.instance.device.setFramebuffer(fb);
        const colors = [
            new Vector4(1, 0, 0, 1),
            new Vector4(0.2, 0, 0, 1),
            new Vector4(0, 1, 0, 1),
            new Vector4(0, 0.2, 0, 1),
            new Vector4(0, 0, 1, 1),
            new Vector4(0, 0, 0.2, 1)
        ];
        for(let i = 0; i < 6; i++){
            fb.setColorAttachmentCubeFace(0, i);
            Application.instance.device.clearFrameBuffer(colors[i], null, null);
        }
        Application.instance.device.popDeviceStates();
        fb.dispose();
        return tex;
    };
}
/** @internal */ function getSheenLutLoader(textureSize) {
    const bits = new Uint32Array(1);
    //Van der Corput radical inverse
    function radicalInverse_VdC(i) {
        bits[0] = i;
        bits[0] = (bits[0] << 16 | bits[0] >> 16) >>> 0;
        bits[0] = (bits[0] & 0x55555555) << 1 | (bits[0] & 0xaaaaaaaa) >>> 1 >>> 0;
        bits[0] = (bits[0] & 0x33333333) << 2 | (bits[0] & 0xcccccccc) >>> 2 >>> 0;
        bits[0] = (bits[0] & 0x0f0f0f0f) << 4 | (bits[0] & 0xf0f0f0f0) >>> 4 >>> 0;
        bits[0] = (bits[0] & 0x00ff00ff) << 8 | (bits[0] & 0xff00ff00) >>> 8 >>> 0;
        return bits[0] * 2.3283064365386963e-10; // / 0x100000000 or / 4294967296
    }
    function hammersley(i, iN, out) {
        out.setXY(i * iN, radicalInverse_VdC(i));
    }
    /*
  function hammersley(i: number, iN: number, out: Vector2) {
    const tof = 0.5 / 0x80000000;
    let bits = i;
    bits = (bits << 16) | (bits >>> 16);
    bits = ((bits & 0x55555555) << 1) | ((bits & 0xAAAAAAAA) >>> 1);
    bits = ((bits & 0x33333333) << 2) | ((bits & 0xCCCCCCCC) >>> 2);
    bits = ((bits & 0x0F0F0F0F) << 4) | ((bits & 0xF0F0F0F0) >>> 4);
    bits = ((bits & 0x00FF00FF) << 8) | ((bits & 0xFF00FF00) >>> 8);
    out.setXY(i * iN, (bits >>> 0) * tof);
  }
  */ /*
  function generateTBN(normal: Vector3, out: Matrix3x3) {
    bitangent.setXYZ(0.0, 1.0, 0.0);
    const NdotUp = Vector3.dot(normal, up);
    const epsilon = 0.0000001;
    if (1.0 - Math.abs(NdotUp) <= epsilon) {
      // Sampling +Y or -Y, so we need a more robust bitangent.
      if (NdotUp > 0.0) {
        bitangent.setXYZ(0.0, 0.0, 1.0);
      } else {
        bitangent.setXYZ(0.0, 0.0, -1.0);
      }
    }
    Vector3.cross(bitangent, normal, tangent).inplaceNormalize();
    Vector3.cross(normal, tangent, bitangent);
    out.setCol(0, tangent);
    out.setCol(1, bitangent);
    out.setCol(2, normal);
  }
  function mix(x: number, y: number, a: number): number {
    return x * (1 - a) + y * a;
  }
  function l(x: number, alphaG: number): number {
    const oneMinusAlphaSq = (1 - alphaG) * (1 - alphaG);
    const a = mix(21.5473, 25.3245, oneMinusAlphaSq);
    const b = mix(3.82987, 3.32435, oneMinusAlphaSq);
    const c = mix(0.19823, 0.16801, oneMinusAlphaSq);
    const d = mix(-1.9776, -1.27393, oneMinusAlphaSq);
    const e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
    return a / (1 + b * Math.pow(x, c)) + d * x + e;
  }
  function lambdaSheen(cosTheta: number, alphaG: number): number {
    return Math.abs(cosTheta) < 0.5
      ? Math.exp(l(Math.abs(cosTheta), alphaG))
      : Math.exp(2 * l(0.5, alphaG) - l(1 - Math.abs(cosTheta), alphaG));
  }
  function visibilityCharlie(NdotV: number, NdotL: number, a: number): number {
    const alphaG = a;
    return 1 / ((1 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4 * NdotV * NdotL));
  }
  */ function distributionCharlie(NdotH, roughness) {
        // roughness = Math.max(roughness, 0.000001);
        const invAlpha = 1 / roughness;
        const cos2h = NdotH * NdotH;
        const sin2h = 1 - cos2h;
        return (2 + invAlpha) * Math.pow(sin2h, invAlpha * 0.5) / (2 * Math.PI);
    }
    /*
  function charlie(xi: Vector2, roughness: number, sample: MicrofacetDistributionSample) {
    const alpha = roughness * roughness;
    sample.sinTheta = Math.pow(xi.y, alpha / (2 * alpha + 1));
    sample.cosTheta = Math.sqrt(1 - sample.sinTheta * sample.sinTheta);
    sample.phi = 2 * Math.PI * xi.x;
    sample.pdf = distributionCharlie(sample.cosTheta, Math.max(alpha, 0.000001)) / 4;
  }
  function getImportanceSample(
    sampleIndex: number,
    sampleCount: number,
    N: Vector3,
    roughness: number,
    out: Vector4
  ) {
    // generate a quasi monte carlo point in the unit square [0.1)^2
    hammersley(sampleIndex, 1 / sampleCount, xi);
    // generate the points on the hemisphere with a fitting mapping for
    // the distribution (e.g. lambertian uses a cosine importance)
    charlie(xi, roughness, importanceSample);

    // transform the hemisphere sample to the normal coordinate frame
    // i.e. rotate the hemisphere to the normal direction
    localSpaceDirection
      .setXYZ(
        importanceSample.sinTheta * Math.cos(importanceSample.phi),
        importanceSample.sinTheta * Math.sin(importanceSample.phi),
        importanceSample.cosTheta
      )
      .inplaceNormalize();
    generateTBN(N, TBN);
    TBN.transform(localSpaceDirection, direction);
    out.setXYZW(direction.x, direction.y, direction.z, importanceSample.pdf);
  }
  function lut(NdotV: number, roughness: number, numSamples: number, out: Vector4) {
    V.setXYZ(Math.sqrt(1 - NdotV * NdotV), 0, NdotV);
    N.setXYZ(0, 0, 1);
    const A = 0;
    const B = 0;
    let C = 0;
    const importanceSample = new Vector4();
    for (let i = 0; i < numSamples; i++) {
      getImportanceSample(i, numSamples, N, roughness, importanceSample);
      H.setXYZ(importanceSample.x, importanceSample.y, importanceSample.z);
      // do reflect L = normalize(reflect(-V, H)) = normalize(-V - 2.0 * dot(H, -V) * H) = normalize(2 * dot(H, V) * H - V)
      Vector3.scale(H, Vector3.dot(V, H) * 2, L)
        .subBy(V)
        .inplaceNormalize();
      const NdotL = Math.min(Math.max(L.z, 0), 1);
      const NdotH = Math.min(Math.max(H.z, 0), 1);
      const VdotH = Math.min(Math.max(Vector3.dot(V, H), 0), 1);
      if (NdotL > 0) {
        const sheenDistribution = distributionCharlie(NdotH, roughness);
        // const sheenVisibility = visibilityAshikhmin(NdotV, NdotL);
        const sheenVisibility = visibilityCharlie(NdotV, NdotL, roughness);
        C += sheenVisibility * sheenDistribution * NdotL * VdotH;
      }
    }
    out.setXYZW(4 * A, 4 * B, 4 * 2 * Math.PI * C, 0).scaleBy(1 / numSamples);
  }

  async function createSheenLUT(): Promise<Texture2D> {
    const tex = Application.instance.device.createTexture2D('rgba8unorm', textureSize, textureSize);
    const image = new Uint8Array(textureSize * textureSize * 4);
    let p = 0;
    const c = new Vector4();
    for (let y = 0; y < textureSize; y++) {
      const coord = Math.min(Math.max((y + 0.5) / textureSize, 0), 1);
      const roughness = coord;
      for (let x = 0; x < textureSize; x++) {
        const NdotV = Math.min(Math.max((x + 0.5) / textureSize, 0), 1);
        // const c = dfvCharlieUniform(NdotV, roughness, 1024);
        // const c = Math.min(Math.max(Math.round(t * 255), 0), 255);
        lut(NdotV, roughness, 1024, c);
        image[p++] = Math.min(Math.max(Math.round(c.x * 255), 0), 255);
        image[p++] = Math.min(Math.max(Math.round(c.y * 255), 0), 255);
        image[p++] = Math.min(Math.max(Math.round(c.z * 255), 0), 255);
        image[p++] = 255;
      }
    }
    tex.update(image, 0, 0, textureSize, textureSize);
    tex.name = `builtin:${BUILTIN_ASSET_TEXTURE_SHEEN_LUT}`;
    return tex;
  }
  */ //////////////////////////////////////////////////////////////////////////////////////////////////////
    function visibilityAshikhmin(NdotV, NdotL) {
        return Math.min(Math.max(1 / (4 * (NdotL + NdotV - NdotL * NdotV)), 0), 1);
    }
    function hemisphereUniformSample(u, out) {
        const phi = 2 * Math.PI * u.x;
        const cosTheta = 1 - u.y;
        const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
        out.setXYZ(sinTheta * Math.cos(phi), sinTheta * Math.sin(phi), cosTheta);
    }
    function dfvCharlieUniform(NdotV, roughness, numSamples) {
        let r = 0;
        const V = new Vector3(Math.sqrt(1 - NdotV * NdotV), 0, NdotV);
        const u = new Vector2();
        const H = new Vector3();
        const L = new Vector3();
        for(let i = 0; i < numSamples; i++){
            hammersley(i, 1 / numSamples, u);
            hemisphereUniformSample(u, H);
            Vector3.scale(H, Vector3.dot(V, H) * 2, L).subBy(V);
            const VdotH = Math.min(Math.max(Vector3.dot(V, H), 0), 1);
            const NdotL = Math.min(Math.max(L.z, 0), 1);
            const NdotH = Math.min(Math.max(H.z, 0), 1);
            if (NdotL > 0) {
                const v = visibilityAshikhmin(NdotV, NdotL);
                // const v = visibilityCharlie(NdotV, NdotL, roughness);
                const d = distributionCharlie(NdotH, roughness);
                r += v * d * NdotL * VdotH;
            }
        }
        return r * (4 * 2 * Math.PI / numSamples);
    }
    const _tables = function _generateTables() {
        // float32 to float16 helpers
        const buffer = new ArrayBuffer(4);
        const floatView = new Float32Array(buffer);
        const uint32View = new Uint32Array(buffer);
        const baseTable = new Uint32Array(512);
        const shiftTable = new Uint32Array(512);
        for(let i = 0; i < 256; ++i){
            const e = i - 127;
            // very small number (0, -0)
            if (e < -27) {
                baseTable[i] = 0x0000;
                baseTable[i | 0x100] = 0x8000;
                shiftTable[i] = 24;
                shiftTable[i | 0x100] = 24;
            // small number (denorm)
            } else if (e < -14) {
                baseTable[i] = 0x0400 >> -e - 14;
                baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
                shiftTable[i] = -e - 1;
                shiftTable[i | 0x100] = -e - 1;
            // normal number
            } else if (e <= 15) {
                baseTable[i] = e + 15 << 10;
                baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
                shiftTable[i] = 13;
                shiftTable[i | 0x100] = 13;
            // large number (Infinity, -Infinity)
            } else if (e < 128) {
                baseTable[i] = 0x7c00;
                baseTable[i | 0x100] = 0xfc00;
                shiftTable[i] = 24;
                shiftTable[i | 0x100] = 24;
            // stay (NaN, Infinity, -Infinity)
            } else {
                baseTable[i] = 0x7c00;
                baseTable[i | 0x100] = 0xfc00;
                shiftTable[i] = 13;
                shiftTable[i | 0x100] = 13;
            }
        }
        // float16 to float32 helpers
        const mantissaTable = new Uint32Array(2048);
        const exponentTable = new Uint32Array(64);
        const offsetTable = new Uint32Array(64);
        for(let i = 1; i < 1024; ++i){
            let m = i << 13; // zero pad mantissa bits
            let e = 0; // zero exponent
            // normalized
            while((m & 0x00800000) === 0){
                m <<= 1;
                e -= 0x00800000; // decrement exponent
            }
            m &= ~0x00800000; // clear leading 1 bit
            e += 0x38800000; // adjust bias
            mantissaTable[i] = m | e;
        }
        for(let i = 1024; i < 2048; ++i){
            mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
        }
        for(let i = 1; i < 31; ++i){
            exponentTable[i] = i << 23;
        }
        exponentTable[31] = 0x47800000;
        exponentTable[32] = 0x80000000;
        for(let i = 33; i < 63; ++i){
            exponentTable[i] = 0x80000000 + (i - 32 << 23);
        }
        exponentTable[63] = 0xc7800000;
        for(let i = 1; i < 64; ++i){
            if (i !== 32) {
                offsetTable[i] = 1024;
            }
        }
        return {
            floatView: floatView,
            uint32View: uint32View,
            baseTable: baseTable,
            shiftTable: shiftTable,
            mantissaTable: mantissaTable,
            exponentTable: exponentTable,
            offsetTable: offsetTable
        };
    }();
    function encodeF16(val) {
        val = Math.min(Math.max(val, -65504), 65504);
        _tables.floatView[0] = val;
        const f = _tables.uint32View[0];
        const e = f >> 23 & 0x1ff;
        return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
    }
    /*
  function decodeF16(val: number) {
    const exponent = (val & 0x7c00) >> 10;
    const fraction = val & 0x03ff;
    return (
      (val >> 15 ? -1 : 1) *
      (exponent
        ? exponent === 0x1f
          ? fraction
            ? NaN
            : Infinity
          : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)
        : 6.103515625e-5 * (fraction / 0x400))
    );
  }
  */ async function createSheenLUTFilament(assetManager, texture) {
        if (texture) {
            if (!texture.isTexture2D()) {
                throw new Error('can not reload sheen lut texture: invalid texture type');
            }
            if (texture.format !== 'rgba16f') {
                throw new Error('can not reload sheen lut texture: invalid texture format');
            }
            if (texture.width !== textureSize || texture.height !== textureSize) {
                throw new Error('can not reload sheen lut texture: invalid texture size');
            }
        }
        const tex = texture || Application.instance.device.createTexture2D('rgba16f', textureSize, textureSize);
        const image = new Uint16Array(textureSize * textureSize * 4);
        let p = 0;
        const one = encodeF16(1);
        for(let y = textureSize - 1; y >= 0; y--){
            const coord = Math.min(Math.max((y + 0.5) / textureSize, 0), 1);
            const roughness = coord * coord;
            for(let x = 0; x < textureSize; x++){
                const NdotV = Math.min(Math.max((x + 0.5) / textureSize, 0), 1);
                const c = dfvCharlieUniform(NdotV, roughness, 512);
                const f16 = encodeF16(c);
                image[p++] = 0;
                image[p++] = 0;
                image[p++] = f16;
                image[p++] = one;
            }
        }
        tex.update(image, 0, 0, textureSize, textureSize);
        tex.name = `builtin:${BUILTIN_ASSET_TEXTURE_SHEEN_LUT}`;
        return tex;
    }
    return createSheenLUTFilament;
}

/**
 * TGA image loader
 * @internal
 */ class TGALoader extends AbstractTextureLoader {
    supportExtension(ext) {
        return ext === '.tga';
    }
    supportMIMEType(mimeType) {
        return mimeType === 'image/tga';
    }
    parseTGA(content, sRGB, noMipmap, texture) {
        const dataView = new DataView(content);
        const p = [
            0,
            0,
            0,
            0
        ];
        do {
            let skip = 0;
            const idLength = dataView.getUint8(0);
            skip += idLength;
            const colorMapType = dataView.getUint8(1);
            if (colorMapType !== 0 && colorMapType !== 1) {
                break;
            }
            const dataTypeCode = dataView.getUint8(2);
            if (dataTypeCode !== 2 && dataTypeCode !== 10) {
                break;
            }
            const colorMapLength = dataView.getUint16(5, true);
            skip += colorMapLength * colorMapType;
            const width = dataView.getUint16(12, true);
            const height = dataView.getUint16(14, true);
            const bpp = dataView.getUint8(16);
            if (bpp !== 16 && bpp !== 24 && bpp !== 32) {
                break;
            }
            let dataOffset = 18 + skip;
            const bytesPerPixel = bpp / 8;
            const pixels = new Uint8Array(width * height * 4);
            let n = 0;
            while(n < width * height){
                if (dataTypeCode === 2) {
                    for(let i = 0; i < bytesPerPixel; i++){
                        p[i] = dataView.getUint8(dataOffset++);
                    }
                    this.mergeBytes(pixels, n * 4, p, bytesPerPixel);
                    n++;
                } else {
                    const t = dataView.getUint8(dataOffset++);
                    for(let i = 0; i < bytesPerPixel; i++){
                        p[i] = dataView.getUint8(dataOffset++);
                    }
                    const j = t & 0x7f;
                    this.mergeBytes(pixels, n * 4, p, bytesPerPixel);
                    n++;
                    if (t & 0x80) {
                        for(let i = 0; i < j; i++){
                            this.mergeBytes(pixels, n * 4, p, bytesPerPixel);
                            n++;
                        }
                    } else {
                        for(let i = 0; i < j; i++){
                            for(let k = 0; k < bytesPerPixel; k++){
                                p[i] = dataView.getUint8(dataOffset++);
                            }
                            this.mergeBytes(pixels, n * 4, p, bytesPerPixel);
                            n++;
                        }
                    }
                }
            }
            const opt = {
                texture
            };
            if (noMipmap) {
                opt.samplerOptions = {
                    mipFilter: 'none'
                };
            }
            const tex = Application.instance.device.createTexture2D(sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm', width, height, opt);
            tex.update(pixels, 0, 0, width, height);
            return tex;
        }while (false)
        throw new Error(`Unsupported TGA file format`);
    }
    mergeBytes(dest, offset, pixel, numBytes) {
        if (numBytes === 4) {
            dest[offset + 0] = pixel[2];
            dest[offset + 1] = pixel[1];
            dest[offset + 2] = pixel[0];
            dest[offset + 3] = pixel[3];
        } else if (numBytes === 3) {
            dest[offset + 0] = pixel[2];
            dest[offset + 1] = pixel[1];
            dest[offset + 2] = pixel[0];
            dest[offset + 3] = 255;
        } else if (numBytes === 2) {
            dest[offset + 0] = (pixel[1] & 0x7c) << 1;
            dest[offset + 1] = (pixel[1] & 0x03) << 6 | (pixel[0] & 0xe0) >> 2;
            dest[offset + 2] = (pixel[0] & 0x1f) << 3;
            dest[offset + 3] = pixel[1] & 0x80;
        }
    }
    async load(assetManager, filename, mimeType, data, srgb, samplerOptions, texture) {
        return new Promise((resolve, reject)=>{
            resolve(this.parseTGA(data, srgb, samplerOptions?.mipFilter === 'none', texture));
        });
    }
}

/**
 * The asset manager
 * @public
 */ class AssetManager {
    /** @internal */ static _builtinTextures = {};
    /** @internal */ static _builtinTextureLoaders = {
        [BUILTIN_ASSET_TEXTURE_SHEEN_LUT]: getSheenLutLoader(64),
        [BUILTIN_ASSET_TEST_CUBEMAP]: getTestCubemapLoader()
    };
    /** @internal */ _httpRequest;
    /** @internal */ _textureLoaders;
    /** @internal */ _modelLoaders;
    /** @internal */ _textures;
    /** @internal */ _models;
    /** @internal */ _binaryDatas;
    /** @internal */ _textDatas;
    /**
   * Creates an instance of AssetManager
   */ constructor(){
        this._httpRequest = new HttpRequest();
        this._textureLoaders = [
            new WebImageLoader(),
            new DDSLoader(),
            new HDRLoader(),
            new TGALoader()
        ];
        this._modelLoaders = [
            new GLTFLoader()
        ];
        this._textures = {};
        this._models = {};
        this._binaryDatas = {};
        this._textDatas = {};
    }
    /**
   * HttpRequest instance of the asset manager
   */ get httpRequest() {
        return this._httpRequest;
    }
    /**
   * Removes all cached assets
   */ clearCache() {
        this._textures = {};
        this._models = {};
        this._binaryDatas = {};
        this._textDatas = {};
    }
    /**
   * Remove and dispose all cached assets
   */ purgeCache() {
        for(const k in this._textures){
            this._textures[k].then((tex)=>tex?.dispose()).catch((err)=>{});
            delete this._textures[k];
        }
        this._models = {};
        this._binaryDatas = {};
        this._textDatas = {};
    }
    /**
   * Adds a texture loader to the asset manager
   *
   * @remarks
   * TODO: this should be a static method
   *
   * @param loader - The texture loader to be added
   */ addTextureLoader(loader) {
        if (loader) {
            this._textureLoaders.unshift(loader);
        }
    }
    /**
   * Adds a model loader to the asset manager
   *
   * @remarks
   * TODO: this should be a static method
   *
   * @param loader - The model loader to be added
   */ addModelLoader(loader) {
        if (loader) {
            this._modelLoaders.unshift(loader);
        }
    }
    /**
   * Fetches a text resource from a given URL
   * @param url - The URL from where to fetch the resource
   * @param postProcess - A function that will be involved when the text data was loaded.
   *
   * @remarks
   * If a text data has already been loaded, the function will ignore the
   * postProcess parameter and directly return the text loaded previously.
   * To load the same text with different postProcess parameters,
   * use different AssetManager instances separately.
   *
   * @returns The fetched text
   */ async fetchTextData(url, postProcess) {
        let P = this._textDatas[url];
        if (!P) {
            P = this.loadTextData(url, postProcess);
            this._textDatas[url] = P;
        }
        return P;
    }
    /**
   * Fetches a binary resource from a given URL
   * @param url - The URL from where to fetch the resource
   * @param postProcess - A function that will be involved when the binary data was loaded.
   *
   * @remarks
   * If a binary data has already been loaded, the function will ignore the
   * postProcess parameter and directly return the data loaded previously.
   * To load the same data with different postProcess parameters,
   * use different AssetManager instances separately.
   *
   * @returns Binary data as ArrayBuffer
   */ async fetchBinaryData(url, postProcess) {
        let P = this._binaryDatas[url];
        if (!P) {
            P = this.loadBinaryData(url, postProcess);
            this._binaryDatas[url] = P;
        }
        return P;
    }
    /**
   * Fetches a texture resource from a given URL
   * @param url - The URL from where to fetch the resource
   * @param options - Options for texture fetching
   * @returns The fetched texture
   */ async fetchTexture(url, options) {
        if (options?.texture) {
            return this.loadTexture(url, options.mimeType ?? null, !options.linearColorSpace, options.samplerOptions, options.texture);
        } else {
            const hash = this.getHash('2d', url, options);
            let P = this._textures[hash];
            if (!P) {
                P = this.loadTexture(url, options?.mimeType ?? null, !options?.linearColorSpace, options?.samplerOptions);
                this._textures[hash] = P;
            } else {
                const tex = await P;
                if (tex.disposed) {
                    await tex.reload();
                    return tex;
                }
            }
            return P;
        }
    }
    /** @internal */ async fetchModelData(scene, url, mimeType, postProcess) {
        let P = this._models[url];
        if (!P) {
            P = this.loadModel(url, mimeType, postProcess);
            this._models[url] = P;
        }
        return P;
    }
    /**
   * Fetches a model resource from a given URL and adds it to a scene
   * @param scene - The scene to which the model node belongs
   * @param url - The URL from where to fetch the resource
   * @param mimeType - The MIME type of the model resource, if not provided, model type will be determined by file extension
   * @param postProcess - A function that will be involved when the model was loaded.
   *
   * @remarks
   * If a model has already been loaded, the function will ignore the
   * postProcess parameter and directly return the model loaded previously.
   * To load the same model with different postProcess parameters,
   * use different AssetManager instances separately.
   *
   * @returns The created model node
   */ async fetchModel(scene, url, mimeType, postProcess) {
        const sharedModel = await this.fetchModelData(scene, url, mimeType, postProcess);
        return this.createSceneNode(scene, sharedModel);
    }
    /** @internal */ async loadTextData(url, postProcess) {
        let text = await this._httpRequest.requestText(url);
        if (postProcess) {
            try {
                text = postProcess(text);
            } catch (err) {
                throw new Error(`Load text data post process failed: ${err}`);
            }
        }
        return text;
    }
    /** @internal */ async loadBinaryData(url, postProcess) {
        let data = await this._httpRequest.requestArrayBuffer(url);
        if (postProcess) {
            try {
                data = postProcess(data);
            } catch (err) {
                throw new Error(`Load binary data post process failed: ${err}`);
            }
        }
        return data;
    }
    /** @internal */ async loadTexture(url, mimeType, srgb, samplerOptions, texture) {
        const data = await this._httpRequest.requestArrayBuffer(url);
        let ext = '';
        let filename = '';
        const dataUriMatchResult = url.match(/^data:([^;]+)/);
        if (dataUriMatchResult) {
            mimeType = mimeType || dataUriMatchResult[1];
        } else {
            filename = new URL(url, new URL(location.href).origin).pathname.split('/').filter((val)=>!!val).slice(-1)[0];
            const p = filename ? filename.lastIndexOf('.') : -1;
            ext = p >= 0 ? filename.substring(p).toLowerCase() : null;
            if (!mimeType) {
                if (ext === '.jpg' || ext === '.jpeg') {
                    mimeType = 'image/jpg';
                } else if (ext === '.png') {
                    mimeType = 'image/png';
                }
            }
        }
        for (const loader of this._textureLoaders){
            if ((!ext || !loader.supportExtension(ext)) && (!mimeType || !loader.supportMIMEType(mimeType))) {
                continue;
            }
            const tex = await this.doLoadTexture(loader, filename, mimeType, data, !!srgb, samplerOptions, texture);
            tex.name = filename;
            if (url.match(/^blob:/)) {
                tex.restoreHandler = async (tex)=>{
                    await this.doLoadTexture(loader, filename, mimeType, data, !!srgb, samplerOptions, tex);
                };
            } else {
                const so = samplerOptions ? null : {
                    ...samplerOptions
                };
                tex.restoreHandler = async (tex)=>{
                    await this.loadTexture(url, mimeType, srgb, so, tex);
                };
            }
            return tex;
        }
        throw new Error(`Can not find loader for asset ${url}`);
    }
    /** @internal */ async doLoadTexture(loader, url, mimeType, data, srgb, samplerOptions, texture) {
        const device = Application.instance.device;
        if (device.type !== 'webgl') {
            return await loader.load(this, url, mimeType, data, srgb, samplerOptions, texture);
        } else {
            let tex = await loader.load(this, url, mimeType, data, srgb, samplerOptions);
            if (texture) {
                const magFilter = tex.width !== texture.width || tex.height !== texture.height ? 'linear' : 'nearest';
                const minFilter = magFilter;
                const mipFilter = 'none';
                const sampler = device.createSampler({
                    addressU: 'clamp',
                    addressV: 'clamp',
                    magFilter,
                    minFilter,
                    mipFilter
                });
                const blitter = new CopyBlitter();
                blitter.blit(tex, texture, sampler);
                tex = texture;
            } else {
                const po2_w = isPowerOf2(tex.width);
                const po2_h = isPowerOf2(tex.height);
                const srgb = tex.isSRGBFormat();
                if (srgb || !po2_w || !po2_h) {
                    const newWidth = po2_w ? tex.width : nextPowerOf2(tex.width);
                    const newHeight = po2_h ? tex.height : nextPowerOf2(tex.height);
                    const magFilter = newWidth !== tex.width || newHeight !== tex.height ? 'linear' : 'nearest';
                    const minFilter = magFilter;
                    const mipFilter = 'none';
                    const sampler = device.createSampler({
                        addressU: 'clamp',
                        addressV: 'clamp',
                        magFilter,
                        minFilter,
                        mipFilter
                    });
                    const destFormat = srgb ? 'rgba8unorm' : tex.format;
                    const blitter = new CopyBlitter();
                    const newTexture = tex.isTexture2D() ? device.createTexture2D(destFormat, newWidth, newHeight) : device.createCubeTexture(destFormat, newWidth);
                    blitter.blit(tex, newTexture, sampler);
                    tex.dispose();
                    tex = newTexture;
                }
            }
            return tex;
        }
    }
    /** @internal */ async loadModel(url, mimeType, postProcess) {
        const data = await this.httpRequest.requestBlob(url);
        const filename = new URL(url, new URL(location.href).origin).pathname.split('/').filter((val)=>!!val).slice(-1)[0];
        const p = filename ? filename.lastIndexOf('.') : -1;
        const ext = p >= 0 ? filename.substring(p) : null;
        for (const loader of this._modelLoaders){
            if (!loader.supportExtension(ext) && !loader.supportMIMEType(mimeType || data.type)) {
                continue;
            }
            let model = await loader.load(this, url, mimeType || data.type, data);
            if (!model) {
                throw new Error(`Load asset failed: ${url}`);
            }
            if (postProcess) {
                try {
                    model = postProcess(model);
                } catch (err) {
                    throw new Error(`Model loader post process failed: ${err}`);
                }
            }
            model.name = filename;
            return model;
        }
        throw new Error(`Can not find loader for asset ${url}`);
    }
    /**
   * Fetches a built-in texture
   * @param name - Name of the built-in texture
   * @returns The built-in texture
   */ async fetchBuiltinTexture(name, texture) {
        const loader = AssetManager._builtinTextureLoaders[name];
        if (!loader) {
            throw new Error(`Unknown builtin texture name: ${name}`);
        }
        if (texture) {
            return loader(this, texture);
        } else {
            let P = AssetManager._builtinTextures[name];
            if (!P) {
                P = loader(this);
                AssetManager._builtinTextures[name] = P;
            }
            const tex = await P;
            tex.restoreHandler = async (tex)=>{
                await loader(this, tex);
            };
            return tex;
        }
    }
    /** @internal */ createSceneNode(scene, model, sceneIndex) {
        const group = new SceneNode(scene);
        group.name = model.name;
        let animationSet = new AnimationSet(scene);
        for(let i = 0; i < model.scenes.length; i++){
            if (typeof sceneIndex === 'number' && sceneIndex >= 0 && i !== sceneIndex) {
                continue;
            } else if ((sceneIndex === undefined || sceneIndex === null) && model.activeScene >= 0 && i !== model.activeScene) {
                continue;
            }
            const assetScene = model.scenes[i];
            const skeletonMeshMap = new Map();
            const nodeMap = new Map();
            for(let k = 0; k < assetScene.rootNodes.length; k++){
                this.setAssetNodeToSceneNode(scene, group, model, assetScene.rootNodes[k], skeletonMeshMap, nodeMap);
            }
            for (const animationData of model.animations){
                const animation = new AnimationClip(animationData.name, group);
                animationSet.add(animation);
                for (const track of animationData.tracks){
                    if (track.type === 'translation') {
                        animation.addTrack(nodeMap.get(track.node), new TranslationTrack(track.interpolator));
                    } else if (track.type === 'scale') {
                        animation.addTrack(nodeMap.get(track.node), new ScaleTrack(track.interpolator));
                    } else if (track.type === 'rotation') {
                        animation.addTrack(nodeMap.get(track.node), new RotationTrack(track.interpolator));
                    } else {
                        console.error(`Invalid animation track type: ${track.type}`);
                    }
                }
                for (const sk of animationData.skeletons){
                    const nodes = skeletonMeshMap.get(sk);
                    if (nodes) {
                        const skeleton = new Skeleton(sk.joints.map((val)=>nodeMap.get(val)), sk.inverseBindMatrices, sk.bindPoseMatrices);
                        skeleton.updateJointMatrices();
                        animation.addSkeleton(skeleton, nodes.mesh, nodes.bounding.map((val)=>this.getBoundingInfo(skeleton, val)));
                    }
                }
                animation.stop();
            }
        }
        if (animationSet.numAnimations === 0) {
            animationSet.dispose();
            animationSet = null;
        }
        return {
            group,
            animationSet
        };
    }
    /**
   * Sets the loader for a given builtin-texture
   * @param name - Name of the builtin texture
   * @param loader - Loader for the builtin texture
   */ static setBuiltinTextureLoader(name, loader) {
        if (loader) {
            this._builtinTextureLoaders[name] = loader;
        } else {
            delete this._builtinTextureLoaders[name];
        }
    }
    /** @internal */ getBoundingInfo(skeleton, meshData) {
        const indices = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        let minx = Number.MAX_VALUE;
        let maxx = -Number.MAX_VALUE;
        let miny = Number.MAX_VALUE;
        let maxy = -Number.MAX_VALUE;
        let minz = Number.MAX_VALUE;
        let maxz = -Number.MAX_VALUE;
        const v = meshData.rawPositions;
        const vert = new Vector3();
        const tmpV0 = new Vector3();
        const tmpV1 = new Vector3();
        const tmpV2 = new Vector3();
        const tmpV3 = new Vector3();
        const numVertices = Math.floor(v.length / 3);
        for(let i = 0; i < numVertices; i++){
            vert.setXYZ(v[i * 3], v[i * 3 + 1], v[i * 3 + 2]);
            skeleton.jointMatrices[meshData.rawBlendIndices[i * 4 + 0]].transformPointAffine(vert, tmpV0).scaleBy(meshData.rawJointWeights[i * 4 + 0]);
            skeleton.jointMatrices[meshData.rawBlendIndices[i * 4 + 1]].transformPointAffine(vert, tmpV1).scaleBy(meshData.rawJointWeights[i * 4 + 1]);
            skeleton.jointMatrices[meshData.rawBlendIndices[i * 4 + 2]].transformPointAffine(vert, tmpV2).scaleBy(meshData.rawJointWeights[i * 4 + 2]);
            skeleton.jointMatrices[meshData.rawBlendIndices[i * 4 + 3]].transformPointAffine(vert, tmpV3).scaleBy(meshData.rawJointWeights[i * 4 + 3]);
            tmpV0.addBy(tmpV1).addBy(tmpV2).addBy(tmpV3);
            if (tmpV0.x < minx) {
                minx = tmpV0.x;
                indices[0] = i;
            }
            if (tmpV0.x > maxx) {
                maxx = tmpV0.x;
                indices[1] = i;
            }
            if (tmpV0.y < miny) {
                miny = tmpV0.y;
                indices[2] = i;
            }
            if (tmpV0.y > maxy) {
                maxy = tmpV0.y;
                indices[3] = i;
            }
            if (tmpV0.z < minz) {
                minz = tmpV0.z;
                indices[4] = i;
            }
            if (tmpV0.z > maxz) {
                maxz = tmpV0.z;
                indices[5] = i;
            }
        }
        const info = {
            boundingVertexBlendIndices: new Float32Array(Array.from({
                length: 6 * 4
            }).map((val, index)=>meshData.rawBlendIndices[indices[index >> 2] * 4 + index % 4])),
            boundingVertexJointWeights: new Float32Array(Array.from({
                length: 6 * 4
            }).map((val, index)=>meshData.rawJointWeights[indices[index >> 2] * 4 + index % 4])),
            boundingVertices: Array.from({
                length: 6
            }).map((val, index)=>new Vector3(meshData.rawPositions[indices[index] * 3], meshData.rawPositions[indices[index] * 3 + 1], meshData.rawPositions[indices[index] * 3 + 2])),
            boundingBox: new BoundingBox()
        };
        return info;
    }
    /** @internal */ setAssetNodeToSceneNode(scene, parent, model, assetNode, skeletonMeshMap, nodeMap) {
        const node = new SceneNode(scene);
        nodeMap.set(assetNode, node);
        node.name = `${assetNode.name}`;
        node.position.set(assetNode.position);
        node.rotation.set(assetNode.rotation);
        node.scale.set(assetNode.scaling);
        if (assetNode.mesh) {
            const meshData = assetNode.mesh;
            const skeleton = assetNode.skeleton;
            for (const subMesh of meshData.subMeshes){
                const meshNode = new Mesh(scene);
                meshNode.name = subMesh.name;
                meshNode.clipMode = GraphNode.CLIP_INHERITED;
                meshNode.showState = GraphNode.SHOW_INHERITED;
                meshNode.pickMode = GraphNode.PICK_INHERITED;
                meshNode.primitive = subMesh.primitive;
                meshNode.material = subMesh.material;
                // meshNode.drawBoundingBox = true;
                meshNode.reparent(node);
                if (skeleton) {
                    if (!skeletonMeshMap.has(skeleton)) {
                        skeletonMeshMap.set(skeleton, {
                            mesh: [
                                meshNode
                            ],
                            bounding: [
                                subMesh
                            ]
                        });
                    } else {
                        skeletonMeshMap.get(skeleton).mesh.push(meshNode);
                        skeletonMeshMap.get(skeleton).bounding.push(subMesh);
                    }
                }
            }
        }
        node.reparent(parent);
        for (const child of assetNode.children){
            this.setAssetNodeToSceneNode(scene, node, model, child, skeletonMeshMap, nodeMap);
        }
    }
    getHash(type, url, options) {
        return `${type}:${url}:${!options?.linearColorSpace}`;
    }
}

/**
 * Base class for any type of post effect
 * @public
 */ class AbstractPostEffect {
    _outputTexture;
    _quadVertexLayout;
    _quadRenderStateSet;
    _enabled;
    _opaque;
    _intermediateFramebuffers;
    /**
   * Creates an instance of a post effect
   * @param name - Name of the post effect
   */ constructor(){
        this._outputTexture = null;
        this._quadVertexLayout = null;
        this._quadRenderStateSet = null;
        this._enabled = true;
        this._opaque = false;
        this._intermediateFramebuffers = {};
    }
    /** Whether this post effect is enabled */ get enabled() {
        return this._enabled;
    }
    set enabled(val) {
        this._enabled = !!val;
    }
    /** Whether this post effect will be rendered at opaque phase */ get opaque() {
        return this._opaque;
    }
    /**
   * Check if the post effect should be rendered upside down.
   * @param device - The device object
   * @returns true if the post effect should be rendered upside down
   */ needFlip(device) {
        return device.type === 'webgpu' && !!device.getFramebuffer();
    }
    /**
   * Adds an intermediate frame buffer
   * @param name - Name of the frame buffer
   * @param format - Render target texture format
   * @param useDepth - Whether the scene depth buffer should be attached to the frame buffer
   */ addIntermediateFramebuffer(name, depth) {
        if (this._intermediateFramebuffers[name]) {
            throw new Error(`Intermediate framebuffer already exists: ${name}`);
        }
        this._intermediateFramebuffers[name] = {
            depth,
            framebuffer: null
        };
    }
    /**
   * Gets the intermediate frame buffer by name
   * @param name - Name of the intermediate frame buffer
   * @param width - Width of the frame buffer
   * @param height - Height of the frame buffer
   * @returns The intermediate frame buffer or null if not exists
   *
   * @remarks
   * The intemediate buffer will be resized to fit the given size if needed
   */ getIntermediateFramebuffer(name, format, width, height) {
        const fb = this._intermediateFramebuffers[name];
        if (!fb) {
            return null;
        }
        const device = Application.instance.device;
        const currentDepthBuffer = device.getFramebuffer().getDepthAttachment();
        if (fb.framebuffer) {
            const colorTex = fb.framebuffer.getColorAttachments()[0];
            const depthTex = fb.framebuffer.getDepthAttachment();
            if (colorTex.width !== width || colorTex.height !== height || colorTex.format !== format) {
                fb.framebuffer.dispose();
                colorTex.dispose();
                if (depthTex && depthTex !== currentDepthBuffer) {
                    depthTex.dispose();
                }
                fb.framebuffer = null;
            }
        }
        if (!fb.framebuffer) {
            const colorTex = device.createTexture2D(format, width, height, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            colorTex.name = `Intermediate-<${name}>`;
            let depthTex = null;
            if (fb.depth === 'current') {
                depthTex = currentDepthBuffer;
            } else if (fb.depth === 'temporal') {
                depthTex = device.createTexture2D('d24s8', width, height);
                depthTex.name = `Intermediate-<${name}>-depth`;
            }
            fb.framebuffer = device.createFrameBuffer([
                colorTex
            ], depthTex);
        }
        return fb.framebuffer;
    }
    /**
   * Disposes the post effect.
   */ dispose() {
        this._quadVertexLayout?.dispose();
        this._quadVertexLayout = null;
        this._quadRenderStateSet = null;
        for(const k in this._intermediateFramebuffers){
            const fb = this._intermediateFramebuffers[k];
            if (fb) {
                const colorAttachment = fb.framebuffer.getColorAttachments()[0];
                fb.framebuffer.dispose();
                colorAttachment.dispose();
            }
        }
        this._intermediateFramebuffers = {};
    }
    /**
   * Draws a fullscreen quad
   * @param renderStateSet - Render states that will be used when drawing the fullscreen quad.
   */ drawFullscreenQuad(renderStateSet) {
        drawFullscreenQuad(renderStateSet);
    /*
    const device = Application.instance.device;
    if (!this._quadVertexLayout) {
      this._quadVertexLayout = this.createVertexLayout(device);
    }
    if (!this._quadRenderStateSet) {
      this._quadRenderStateSet = this.createRenderStates(device);
    }
    const lastRenderState = device.getRenderStates();
    device.setVertexLayout(this._quadVertexLayout);
    device.setRenderStates(renderStateSet ?? this._quadRenderStateSet);
    device.draw('triangle-strip', 0, 4);
    device.setRenderStates(lastRenderState);
    */ }
    /** @internal */ createVertexLayout(device) {
        return device.createVertexLayout({
            vertexBuffers: [
                {
                    buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                        -1,
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1
                    ]))
                }
            ]
        });
    }
    /** @internal */ createRenderStates(device) {
        const renderStates = device.createRenderStateSet();
        renderStates.useRasterizerState().setCullMode('none');
        renderStates.useDepthState().enableTest(false).enableWrite(false);
        return renderStates;
    }
}

/**
 * The tonemap post effect
 * @public
 */ class Tonemap extends AbstractPostEffect {
    static _nearestSampler = null;
    static _programTonemap = null;
    _bindgroupTonemap;
    _exposure;
    /**
   * Creates an instance of tonemap post effect
   */ constructor(){
        super();
        this._bindgroupTonemap = null;
        this._opaque = false;
        this._exposure = 1;
    }
    /** Exposure value */ get exposure() {
        return this._exposure;
    }
    set exposure(val) {
        this._exposure = val;
    }
    /** {@inheritDoc AbstractPostEffect.requireLinearDepthTexture} */ requireLinearDepthTexture() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.requireDepthAttachment} */ requireDepthAttachment() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.apply} */ apply(ctx, inputColorTexture, sceneDepthTexture, srgbOutput) {
        const device = Application.instance.device;
        this._prepare(device, inputColorTexture);
        this._tonemap(device, inputColorTexture, srgbOutput);
    }
    /** @internal */ _tonemap(device, inputColorTexture, sRGBOutput) {
        this._bindgroupTonemap.setValue('srgbOut', sRGBOutput ? 1 : 0);
        this._bindgroupTonemap.setValue('exposure', this._exposure);
        this._bindgroupTonemap.setValue('flip', this.needFlip(device) ? 1 : 0);
        this._bindgroupTonemap.setTexture('tex', inputColorTexture, Tonemap._nearestSampler);
        device.setProgram(Tonemap._programTonemap);
        device.setBindGroup(0, this._bindgroupTonemap);
        this.drawFullscreenQuad();
    }
    /** @internal */ _prepare(device, srcTexture) {
        if (!Tonemap._programTonemap) {
            Tonemap._programTonemap = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.srgbOut = pb.int().uniform(0);
                    this.exposure = pb.float().uniform(0);
                    this.tex = pb.tex2D().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.func('RRTAndODTFit', [
                        pb.vec3('v')
                    ], function() {
                        this.$l.a = pb.sub(pb.mul(this.v, pb.add(this.v, pb.vec3(0.0245786))), pb.vec3(0.000090537));
                        this.$l.b = pb.add(pb.mul(this.v, pb.add(pb.mul(this.v, 0.983729), pb.vec3(0.432951))), pb.vec3(0.238081));
                        this.$return(pb.div(this.a, this.b));
                    });
                    pb.main(function() {
                        this.$l.vSample = pb.textureSample(this.tex, this.$inputs.uv);
                        this.$l.ACESInputMat = pb.mat3(0.59719, 0.076, 0.0284, 0.35458, 0.90834, 0.13383, 0.04823, 0.01566, 0.83777);
                        this.$l.ACESOutputMat = pb.mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276, -0.07367, -0.00605, 1.07602);
                        this.$l.color = pb.mul(this.vSample.rgb, pb.div(this.exposure, 0.6));
                        this.color = pb.mul(this.ACESInputMat, this.color);
                        this.color = this.RRTAndODTFit(this.color);
                        this.color = pb.mul(this.ACESOutputMat, this.color);
                        this.color = pb.clamp(this.color, pb.vec3(0), pb.vec3(1));
                        this.$if(pb.notEqual(this.srgbOut, 0), function() {
                            this.$l.color = linearToGamma(this, this.color);
                        });
                        this.$outputs.outColor = pb.vec4(this.color, 1);
                    });
                }
            });
        }
        if (!this._bindgroupTonemap) {
            this._bindgroupTonemap = device.createBindGroup(Tonemap._programTonemap.bindGroupLayouts[0]);
        }
        if (!Tonemap._nearestSampler) {
            Tonemap._nearestSampler = device.createSampler({
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
        }
    }
    /** {@inheritDoc AbstractPostEffect.dispose} */ dispose() {
        super.dispose();
        this._bindgroupTonemap?.dispose();
        this._bindgroupTonemap = null;
    }
}

/**
 * The bloom post effect
 * @public
 */ class Bloom extends AbstractPostEffect {
    static _nearestSampler = null;
    static _programDownsampleH = null;
    static _programDownsampleV = null;
    static _programUpsample = null;
    static _programFinalCompose = null;
    static _programPrefilter = null;
    static _renderStateAdditive = null;
    _bindgroupDownsampleH;
    _bindgroupDownsampleV;
    _bindgroupUpsample;
    _bindgroupFinalCompose;
    _bindgroupPrefilter;
    _thresholdValue;
    _invTexSize;
    _maxDownsampleLevels;
    _downsampleLimit;
    _threshold;
    _thresholdKnee;
    _intensity;
    /**
   * Creates an instance of tonemap post effect
   */ constructor(){
        super();
        this._bindgroupDownsampleH = null;
        this._bindgroupDownsampleV = null;
        this._bindgroupUpsample = null;
        this._bindgroupFinalCompose = null;
        this._bindgroupPrefilter = null;
        this._opaque = false;
        this._thresholdValue = new Vector4();
        this._invTexSize = new Vector2();
        this._maxDownsampleLevels = 4;
        this._downsampleLimit = 32;
        this._threshold = 0.8;
        this._thresholdKnee = 0;
        this._intensity = 1;
    }
    /** The maximum downsample levels */ get maxDownsampleLevel() {
        return this._maxDownsampleLevels;
    }
    set maxDownsampleLevel(val) {
        this._maxDownsampleLevels = val;
    }
    /** Downsample resolution limitation */ get downsampleLimit() {
        return this._downsampleLimit;
    }
    set downsampleLimit(val) {
        this._downsampleLimit = val;
    }
    /** Bloom threshold */ get threshold() {
        return this._threshold;
    }
    set threshold(val) {
        this._threshold = val;
    }
    /** Bloom threshold knee */ get thresholdKnee() {
        return this._thresholdKnee;
    }
    set thresholdKnee(val) {
        this._thresholdKnee = val;
    }
    /** Bloom intensity */ get intensity() {
        return this._intensity;
    }
    set intensity(val) {
        this._intensity = val;
    }
    /** {@inheritDoc AbstractPostEffect.requireLinearDepthTexture} */ requireLinearDepthTexture() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.requireDepthAttachment} */ requireDepthAttachment() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.apply} */ apply(ctx, inputColorTexture, sceneDepthTexture, srgbOutput) {
        const device = Application.instance.device;
        const downsampleFramebuffers = [];
        this._prepare(device, inputColorTexture);
        device.pushDeviceStates();
        const w = Math.max(inputColorTexture.width >> 1, 1);
        const h = Math.max(inputColorTexture.height >> 1, 1);
        const prefilterFramebuffer = TemporalCache.getFramebufferFixedSize(w, h, 1, inputColorTexture.format, null, '2d', null, false);
        this.prefilter(device, inputColorTexture, prefilterFramebuffer);
        this.downsample(device, prefilterFramebuffer.getColorAttachments()[0], downsampleFramebuffers);
        this.upsample(device, downsampleFramebuffers);
        device.popDeviceStates();
        this.finalCompose(device, inputColorTexture, downsampleFramebuffers[0].getColorAttachments()[0]);
        for (const fb of downsampleFramebuffers){
            TemporalCache.releaseFramebuffer(fb);
        }
        TemporalCache.releaseFramebuffer(prefilterFramebuffer);
    }
    /** @internal */ prefilter(device, srcTexture, fb) {
        this._thresholdValue.x = this._threshold * this._threshold;
        this._thresholdValue.y = this._thresholdValue.x * this._thresholdKnee;
        this._thresholdValue.z = 2 * this._thresholdValue.y;
        this._thresholdValue.w = 0.25 / (this._thresholdValue.y + 0.00001);
        this._thresholdValue.y -= this._thresholdValue.x;
        device.setFramebuffer(fb);
        device.setProgram(Bloom._programPrefilter);
        device.setBindGroup(0, this._bindgroupPrefilter);
        this._bindgroupPrefilter.setTexture('tex', srcTexture);
        this._bindgroupPrefilter.setValue('flip', device.type === 'webgpu' ? 1 : 0);
        this._bindgroupPrefilter.setValue('threshold', this._thresholdValue);
        this.drawFullscreenQuad();
    }
    /** @internal */ finalCompose(device, srcTexture, bloomTexture) {
        device.setProgram(Bloom._programFinalCompose);
        device.setBindGroup(0, this._bindgroupFinalCompose);
        this._bindgroupFinalCompose.setTexture('srcTex', srcTexture);
        this._bindgroupFinalCompose.setTexture('bloomTex', bloomTexture);
        this._bindgroupFinalCompose.setValue('intensity', this._intensity);
        this._bindgroupFinalCompose.setValue('flip', device.type === 'webgpu' && device.getFramebuffer() ? 1 : 0);
        this.drawFullscreenQuad();
    }
    /** @internal */ upsample(device, framebuffers) {
        device.setProgram(Bloom._programUpsample);
        device.setBindGroup(0, this._bindgroupUpsample);
        this._bindgroupUpsample.setValue('flip', device.type === 'webgpu' ? 1 : 0);
        for(let i = framebuffers.length - 2; i >= 0; i--){
            this._bindgroupUpsample.setTexture('tex', framebuffers[i + 1].getColorAttachments()[0]);
            device.setFramebuffer(framebuffers[i]);
            this.drawFullscreenQuad(Bloom._renderStateAdditive);
        }
    }
    /** @internal */ downsample(device, inputColorTexture, framebuffers) {
        const t = Math.max(2, this._downsampleLimit);
        let w = Math.max(t, inputColorTexture.width >> 1);
        let h = Math.max(t, inputColorTexture.height >> 1);
        let maxLevels = Math.max(this._maxDownsampleLevels, 1);
        let sourceTex = inputColorTexture;
        this._bindgroupDownsampleH.setValue('flip', device.type === 'webgpu' ? 1 : 0);
        this._bindgroupDownsampleV.setValue('flip', device.type === 'webgpu' ? 1 : 0);
        while((w >= t || h >= t) && maxLevels > 0){
            const fb = TemporalCache.getFramebufferFixedSize(w, h, 1, inputColorTexture.format, null, '2d', '2d', false);
            const fbMiddle = TemporalCache.getFramebufferFixedSize(w, h, 1, inputColorTexture.format, null, '2d', '2d', false);
            framebuffers.push(fb);
            // horizonal blur
            this._invTexSize.setXY(1 / sourceTex.width, 1 / sourceTex.height);
            device.setFramebuffer(fbMiddle);
            device.setProgram(Bloom._programDownsampleH);
            device.setBindGroup(0, this._bindgroupDownsampleH);
            this._bindgroupDownsampleH.setTexture('tex', sourceTex);
            this._bindgroupDownsampleH.setValue('invTexSize', this._invTexSize);
            this.drawFullscreenQuad();
            // vertical blur
            const midTex = fbMiddle.getColorAttachments()[0];
            this._invTexSize.setXY(1 / midTex.width, 1 / midTex.height);
            device.setFramebuffer(fb);
            device.setProgram(Bloom._programDownsampleV);
            device.setBindGroup(0, this._bindgroupDownsampleV);
            this._bindgroupDownsampleV.setTexture('tex', midTex);
            this._bindgroupDownsampleV.setValue('invTexSize', this._invTexSize);
            this.drawFullscreenQuad();
            maxLevels--;
            w = Math.max(1, w >> 1);
            h = Math.max(1, h >> 1);
            sourceTex = fb.getColorAttachments()[0];
            TemporalCache.releaseFramebuffer(fbMiddle);
        }
    }
    /** @internal */ _prepare(device, srcTexture) {
        if (!Bloom._programFinalCompose) {
            Bloom._programFinalCompose = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.srcTex = pb.tex2D().uniform(0);
                    this.bloomTex = pb.tex2D().uniform(0);
                    this.intensity = pb.float().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.srcSample = pb.textureSampleLevel(this.srcTex, this.$inputs.uv, 0);
                        this.$l.bloomSample = pb.textureSampleLevel(this.bloomTex, this.$inputs.uv, 0);
                        this.$outputs.outColor = pb.vec4(pb.add(this.srcSample.rgb, pb.mul(this.bloomSample.rgb, this.intensity)), 1);
                    });
                }
            });
        }
        if (!this._bindgroupFinalCompose) {
            this._bindgroupFinalCompose = device.createBindGroup(Bloom._programFinalCompose.bindGroupLayouts[0]);
        }
        if (!Bloom._programPrefilter) {
            Bloom._programPrefilter = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.tex = pb.tex2D().uniform(0);
                    this.threshold = pb.vec4().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.p = pb.textureSampleLevel(this.tex, this.$inputs.uv, 0);
                        this.$l.brightness = pb.max(pb.max(this.p.r, this.p.g), this.p.b);
                        this.$l.soft = pb.clamp(pb.add(this.brightness, this.threshold.y), 0, this.threshold.z);
                        this.soft = pb.mul(this.soft, this.soft, this.threshold.w);
                        this.$l.contrib = pb.div(pb.max(this.soft, pb.sub(this.brightness, this.threshold.x)), pb.max(this.brightness, 0.00001));
                        this.$outputs.outColor = pb.vec4(pb.mul(this.p.rgb, this.contrib), 1);
                    });
                }
            });
        }
        if (!this._bindgroupPrefilter) {
            this._bindgroupPrefilter = device.createBindGroup(Bloom._programPrefilter.bindGroupLayouts[0]);
        }
        if (!Bloom._programUpsample) {
            Bloom._programUpsample = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.tex = pb.tex2D().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$outputs.outColor = pb.textureSampleLevel(this.tex, this.$inputs.uv, 0);
                    });
                }
            });
        }
        if (!this._bindgroupUpsample) {
            this._bindgroupUpsample = device.createBindGroup(Bloom._programUpsample.bindGroupLayouts[0]);
        }
        if (!Bloom._programDownsampleH) {
            const offsets = [
                -4,
                -3,
                -2,
                -1,
                0,
                1,
                2,
                3,
                4
            ];
            const weights = [
                0.01621622,
                0.05405405,
                0.12162162,
                0.19459459,
                0.22702703,
                0.19459459,
                0.12162162,
                0.05405405,
                0.01621622
            ];
            Bloom._programDownsampleH = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.invTexSize = pb.vec2().uniform(0);
                    this.tex = pb.tex2D().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.sum = pb.vec3(0);
                        this.$l.offset = pb.float();
                        for(let i = 0; i < 9; i++){
                            this.offset = pb.mul(this.invTexSize.x, offsets[i] * 2);
                            this.sum = pb.add(this.sum, pb.mul(pb.textureSampleLevel(this.tex, pb.add(this.$inputs.uv, pb.vec2(this.offset, 0)), 0).rgb, weights[i]));
                        }
                        this.$outputs.outColor = pb.vec4(this.sum, 1);
                    });
                }
            });
        }
        if (!this._bindgroupDownsampleH) {
            this._bindgroupDownsampleH = device.createBindGroup(Bloom._programDownsampleH.bindGroupLayouts[0]);
        }
        if (!Bloom._programDownsampleV) {
            const offsets = [
                -3.23076923,
                -1.38461538,
                0.0,
                1.38461538,
                3.23076923
            ];
            const weights = [
                0.07027027,
                0.31621622,
                0.22702703,
                0.31621622,
                0.07027027
            ];
            Bloom._programDownsampleV = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.invTexSize = pb.vec2().uniform(0);
                    this.tex = pb.tex2D().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.sum = pb.vec3(0);
                        this.$l.offset = pb.float();
                        for(let i = 0; i < 5; i++){
                            this.offset = pb.mul(this.invTexSize.y, offsets[i]);
                            this.sum = pb.add(this.sum, pb.mul(pb.textureSampleLevel(this.tex, pb.add(this.$inputs.uv, pb.vec2(0, this.offset)), 0).rgb, weights[i]));
                        }
                        this.$outputs.outColor = pb.vec4(this.sum, 1);
                    });
                }
            });
        }
        if (!this._bindgroupDownsampleV) {
            this._bindgroupDownsampleV = device.createBindGroup(Bloom._programDownsampleV.bindGroupLayouts[0]);
        }
        if (!Bloom._nearestSampler) {
            Bloom._nearestSampler = device.createSampler({
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
        }
        if (!Bloom._renderStateAdditive) {
            Bloom._renderStateAdditive = device.createRenderStateSet();
            Bloom._renderStateAdditive.useRasterizerState().setCullMode('none');
            Bloom._renderStateAdditive.useDepthState().enableTest(false).enableWrite(false);
            Bloom._renderStateAdditive.useBlendingState().enable(true).setBlendFuncRGB('one', 'one').setBlendFuncAlpha('one', 'zero');
        }
    }
    /** {@inheritDoc AbstractPostEffect.dispose} */ dispose() {
        super.dispose();
        this._bindgroupDownsampleH?.dispose();
        this._bindgroupDownsampleH = null;
    }
}

/**
 * FXAA post effect
 * @public
 */ class FXAA extends AbstractPostEffect {
    static _program = null;
    static _sampler = null;
    _bindgroup;
    _invTexSize;
    /**
   * Creates an instance of grayscale post effect
   */ constructor(){
        super();
        this._opaque = false;
        this._bindgroup = null;
        this._invTexSize = new Vector2();
    }
    /** {@inheritDoc AbstractPostEffect.dispose} */ dispose() {
        super.dispose();
        this._bindgroup?.dispose();
        this._bindgroup = null;
    }
    /** {@inheritDoc AbstractPostEffect.requireLinearDepthTexture} */ requireLinearDepthTexture() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.requireDepthAttachment} */ requireDepthAttachment() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.apply} */ apply(ctx, inputColorTexture, sceneDepthTexture, srgbOutput) {
        const device = Application.instance.device;
        this._prepare(device);
        this._invTexSize.setXY(1 / inputColorTexture.width, 1 / inputColorTexture.height);
        this._bindgroup.setTexture('srcTex', inputColorTexture, FXAA._sampler);
        this._bindgroup.setValue('flip', this.needFlip(device) ? 1 : 0);
        this._bindgroup.setValue('srgbOut', srgbOutput ? 1 : 0);
        this._bindgroup.setValue('invTexSize', this._invTexSize);
        device.setProgram(FXAA._program);
        device.setBindGroup(0, this._bindgroup);
        this.drawFullscreenQuad();
    }
    /** @internal */ _prepare(device) {
        if (!FXAA._program) {
            FXAA._program = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.srcTex = pb.tex2D().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    this.invTexSize = pb.vec2().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.func('getLuma', [
                        pb.vec3('vSample')
                    ], function() {
                        this.$return(pb.dot(this.vSample, pb.vec3(0.299, 0.587, 0.114)));
                    });
                    pb.func('FXAA', [
                        pb.vec2('uv')
                    ], function() {
                        this.$l.posM = this.uv;
                        this.$l.rgbyM = pb.textureSampleLevel(this.srcTex, this.uv, 0);
                        this.$l.lumaM = this.getLuma(this.rgbyM.rgb);
                        this.$l.lumaN = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(0, -1), this.invTexSize)), 0).rgb);
                        this.$l.lumaW = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(-1, 0), this.invTexSize)), 0).rgb);
                        this.$l.lumaE = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(1, 0), this.invTexSize)), 0).rgb);
                        this.$l.lumaS = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(0, 1), this.invTexSize)), 0).rgb);
                        this.$l.rangeMin = pb.min(this.lumaM, pb.min(pb.min(this.lumaN, this.lumaW), pb.min(this.lumaS, this.lumaE)));
                        this.$l.rangeMax = pb.max(this.lumaM, pb.max(pb.max(this.lumaN, this.lumaW), pb.max(this.lumaS, this.lumaE)));
                        this.$l.range = pb.sub(this.rangeMax, this.rangeMin);
                        this.$if(pb.lessThan(this.range, pb.max(1 / 16, pb.div(this.rangeMax, 8))), function() {
                            this.$return(this.rgbyM);
                        });
                        this.$l.lumaNW = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(-1, -1), this.invTexSize)), 0).rgb);
                        this.$l.lumaNE = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(1, -1), this.invTexSize)), 0).rgb);
                        this.$l.lumaSW = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(-1, 1), this.invTexSize)), 0).rgb);
                        this.$l.lumaSE = this.getLuma(pb.textureSampleLevel(this.srcTex, pb.add(this.uv, pb.mul(pb.vec2(1, 1), this.invTexSize)), 0).rgb);
                        this.$l.lumaNS = pb.add(this.lumaN, this.lumaS);
                        this.$l.lumaWE = pb.add(this.lumaW, this.lumaE);
                        this.$l.subpixRcpRange = pb.div(1, this.range);
                        this.$l.subpixNSWE = pb.add(this.lumaNS, this.lumaWE);
                        this.$l.edgeHorz1 = pb.add(pb.mul(-2, this.lumaM), this.lumaNS);
                        this.$l.edgeVert1 = pb.add(pb.mul(-2, this.lumaM), this.lumaWE);
                        this.$l.lumaNESE = pb.add(this.lumaNE, this.lumaSE);
                        this.$l.lumaNWNE = pb.add(this.lumaNW, this.lumaNE);
                        this.$l.edgeHorz2 = pb.add(pb.mul(-2, this.lumaE), this.lumaNESE);
                        this.$l.edgeVert2 = pb.add(pb.mul(-2, this.lumaN), this.lumaNWNE);
                        this.$l.lumaNWSW = pb.add(this.lumaNW, this.lumaSW);
                        this.$l.lumaSWSE = pb.add(this.lumaSW, this.lumaSE);
                        this.$l.edgeHorz4 = pb.add(pb.mul(pb.abs(this.edgeHorz1), 2), pb.abs(this.edgeHorz2));
                        this.$l.edgeVert4 = pb.add(pb.mul(pb.abs(this.edgeVert1), 2), pb.abs(this.edgeVert2));
                        this.$l.edgeHorz3 = pb.add(pb.mul(-2, this.lumaW), this.lumaNWSW);
                        this.$l.edgeVert3 = pb.add(pb.mul(-2, this.lumaS), this.lumaSWSE);
                        this.$l.edgeHorz = pb.add(pb.abs(this.edgeHorz3), this.edgeHorz4);
                        this.$l.edgeVert = pb.add(pb.abs(this.edgeVert3), this.edgeVert4);
                        this.$l.subpixNWSWNESE = pb.add(this.lumaNWSW, this.lumaNESE);
                        this.$l.lengthSign = this.invTexSize.x;
                        this.$l.horzSpan = pb.greaterThanEqual(this.edgeHorz, this.edgeVert);
                        this.$l.subpixA = pb.add(pb.mul(this.subpixNSWE, 2), this.subpixNWSWNESE);
                        this.$if(pb.not(this.horzSpan), function() {
                            this.lumaN = this.lumaW;
                            this.lumaS = this.lumaE;
                        }).$else(function() {
                            this.lengthSign = this.invTexSize.y;
                        });
                        this.$l.subpixB = pb.sub(pb.div(this.subpixA, 12), this.lumaM);
                        this.$l.gradientN = pb.sub(this.lumaN, this.lumaM);
                        this.$l.gradientS = pb.sub(this.lumaS, this.lumaM);
                        this.$l.lumaNN = pb.add(this.lumaN, this.lumaM);
                        this.$l.lumaSS = pb.add(this.lumaS, this.lumaM);
                        this.$l.pairN = pb.greaterThanEqual(pb.abs(this.gradientN), pb.abs(this.gradientS));
                        this.$l.gradient = pb.max(pb.abs(this.gradientN), pb.abs(this.gradientS));
                        this.$if(this.pairN, function() {
                            this.lengthSign = pb.neg(this.lengthSign);
                        });
                        this.$l.subpixC = pb.clamp(pb.mul(pb.abs(this.subpixB), this.subpixRcpRange), 0, 1);
                        this.$l.posB = this.posM;
                        this.$l.offNP = pb.vec2();
                        this.$if(pb.not(this.horzSpan), function() {
                            this.offNP.x = 0;
                            this.offNP.y = this.invTexSize.y;
                            this.posB.x = pb.add(this.posB.x, pb.mul(this.lengthSign, 0.5));
                        }).$else(function() {
                            this.offNP.x = this.invTexSize.x;
                            this.offNP.y = 0;
                            this.posB.y = pb.add(this.posB.y, pb.mul(this.lengthSign, 0.5));
                        });
                        this.$l.posN = pb.sub(this.posB, this.offNP);
                        this.$l.posP = pb.add(this.posB, this.offNP);
                        this.$l.subpixD = pb.add(pb.mul(-2, this.subpixC), 3);
                        this.$l.lumaEndN = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posN, 0).rgb);
                        this.$l.subpixE = pb.mul(this.subpixC, this.subpixC);
                        this.$l.lumaEndP = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posP, 0).rgb);
                        this.$if(pb.not(this.pairN), function() {
                            this.lumaNN = this.lumaSS;
                        });
                        this.$l.gradientScaled = pb.div(this.gradient, 4);
                        this.$l.lumaMM = pb.sub(this.lumaM, pb.mul(this.lumaNN, 0.5));
                        this.$l.subpixF = pb.mul(this.subpixD, this.subpixE);
                        this.$l.lumaMLTZero = pb.lessThan(this.lumaMM, 0);
                        this.lumaEndN = pb.sub(this.lumaEndN, pb.mul(this.lumaNN, 0.5));
                        this.lumaEndP = pb.sub(this.lumaEndP, pb.mul(this.lumaNN, 0.5));
                        this.$l.doneN = pb.greaterThanEqual(pb.abs(this.lumaEndN), this.gradientScaled);
                        this.$l.doneP = pb.greaterThanEqual(pb.abs(this.lumaEndP), this.gradientScaled);
                        this.$if(pb.not(this.doneN), function() {
                            this.posN = pb.sub(this.posN, pb.mul(this.offNP, 1.5));
                        });
                        this.$l.doneNP = pb.or(pb.not(this.doneN), pb.not(this.doneP));
                        this.$if(pb.not(this.doneP), function() {
                            this.posP = pb.add(this.posP, pb.mul(this.offNP, 1.5));
                        });
                        this.$if(this.doneNP, function() {
                            this.$if(pb.not(this.doneN), function() {
                                this.lumaEndN = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posN.xy, 0).rgb);
                                this.lumaEndN = pb.sub(this.lumaEndN, pb.mul(this.lumaNN, 0.5));
                            });
                            this.$if(pb.not(this.doneP), function() {
                                this.lumaEndP = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posP.xy, 0).rgb);
                                this.lumaEndP = pb.sub(this.lumaEndP, pb.mul(this.lumaNN, 0.5));
                            });
                            this.doneN = pb.greaterThanEqual(pb.abs(this.lumaEndN), this.gradientScaled);
                            this.doneP = pb.greaterThanEqual(pb.abs(this.lumaEndP), this.gradientScaled);
                            this.$if(pb.not(this.doneN), function() {
                                this.posN = pb.sub(this.posN, pb.mul(this.offNP, 2.0));
                            });
                            this.doneNP = pb.or(pb.not(this.doneN), pb.not(this.doneP));
                            this.$if(pb.not(this.doneP), function() {
                                this.posP = pb.add(this.posP, pb.mul(this.offNP, 2.0));
                            });
                            this.$if(this.doneNP, function() {
                                this.$if(pb.not(this.doneN), function() {
                                    this.lumaEndN = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posN.xy, 0).rgb);
                                    this.lumaEndN = pb.sub(this.lumaEndN, pb.mul(this.lumaNN, 0.5));
                                });
                                this.$if(pb.not(this.doneP), function() {
                                    this.lumaEndP = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posP.xy, 0).rgb);
                                    this.lumaEndP = pb.sub(this.lumaEndP, pb.mul(this.lumaNN, 0.5));
                                });
                                this.doneN = pb.greaterThanEqual(pb.abs(this.lumaEndN), this.gradientScaled);
                                this.doneP = pb.greaterThanEqual(pb.abs(this.lumaEndP), this.gradientScaled);
                                this.$if(pb.not(this.doneN), function() {
                                    this.posN = pb.sub(this.posN, pb.mul(this.offNP, 2.0));
                                });
                                this.doneNP = pb.or(pb.not(this.doneN), pb.not(this.doneP));
                                this.$if(pb.not(this.doneP), function() {
                                    this.posP = pb.add(this.posP, pb.mul(this.offNP, 2.0));
                                });
                                this.$if(this.doneNP, function() {
                                    this.$if(pb.not(this.doneN), function() {
                                        this.lumaEndN = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posN.xy, 0).rgb);
                                        this.lumaEndN = pb.sub(this.lumaEndN, pb.mul(this.lumaNN, 0.5));
                                    });
                                    this.$if(pb.not(this.doneP), function() {
                                        this.lumaEndP = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posP.xy, 0).rgb);
                                        this.lumaEndP = pb.sub(this.lumaEndP, pb.mul(this.lumaNN, 0.5));
                                    });
                                    this.doneN = pb.greaterThanEqual(pb.abs(this.lumaEndN), this.gradientScaled);
                                    this.doneP = pb.greaterThanEqual(pb.abs(this.lumaEndP), this.gradientScaled);
                                    this.$if(pb.not(this.doneN), function() {
                                        this.posN = pb.sub(this.posN, pb.mul(this.offNP, 4.0));
                                    });
                                    this.doneNP = pb.or(pb.not(this.doneN), pb.not(this.doneP));
                                    this.$if(pb.not(this.doneP), function() {
                                        this.posP = pb.add(this.posP, pb.mul(this.offNP, 4.0));
                                    });
                                    this.$if(this.doneNP, function() {
                                        this.$if(pb.not(this.doneN), function() {
                                            this.lumaEndN = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posN.xy, 0).rgb);
                                            this.lumaEndN = pb.sub(this.lumaEndN, pb.mul(this.lumaNN, 0.5));
                                        });
                                        this.$if(pb.not(this.doneP), function() {
                                            this.lumaEndP = this.getLuma(pb.textureSampleLevel(this.srcTex, this.posP.xy, 0).rgb);
                                            this.lumaEndP = pb.sub(this.lumaEndP, pb.mul(this.lumaNN, 0.5));
                                        });
                                        this.doneN = pb.greaterThanEqual(pb.abs(this.lumaEndN), this.gradientScaled);
                                        this.doneP = pb.greaterThanEqual(pb.abs(this.lumaEndP), this.gradientScaled);
                                        this.$if(pb.not(this.doneN), function() {
                                            this.posN = pb.sub(this.posN, pb.mul(this.offNP, 2.0));
                                        });
                                        this.$if(pb.not(this.doneP), function() {
                                            this.posP = pb.add(this.posP, pb.mul(this.offNP, 2.0));
                                        });
                                    });
                                });
                            });
                        });
                        this.$l.dstN = pb.sub(this.posM.x, this.posN.x);
                        this.$l.dstP = pb.sub(this.posP.x, this.posM.x);
                        this.$if(pb.not(this.horzSpan), function() {
                            this.dstN = pb.sub(this.posM.y, this.posN.y);
                            this.dstP = pb.sub(this.posP.y, this.posM.y);
                        });
                        this.$l.goodSpanN = pb.notEqual(pb.lessThan(this.lumaEndN, 0), this.lumaMLTZero);
                        this.$l.spanLength = pb.add(this.dstP, this.dstN);
                        this.$l.goodSpanP = pb.notEqual(pb.lessThan(this.lumaEndP, 0), this.lumaMLTZero);
                        this.$l.spanLengthRcp = pb.div(1, this.spanLength);
                        this.$l.directionN = pb.lessThan(this.dstN, this.dstP);
                        this.$l.dst = pb.min(this.dstN, this.dstP);
                        this.$l.goodSpan = this.$choice(this.directionN, this.goodSpanN, this.goodSpanP);
                        this.$l.subpixG = pb.mul(this.subpixF, this.subpixF);
                        this.$l.pixelOffset = pb.add(pb.mul(this.dst, pb.neg(this.spanLengthRcp)), 0.5);
                        this.$l.subpixH = pb.mul(this.subpixG, 0.75);
                        this.$l.pixelOffsetGood = this.$choice(this.goodSpan, this.pixelOffset, 0);
                        this.$l.pixelOffsetSubpix = pb.max(this.pixelOffsetGood, this.subpixH);
                        this.$if(pb.not(this.horzSpan), function() {
                            this.posM.x = pb.add(this.posM.x, pb.mul(this.pixelOffsetSubpix, this.lengthSign));
                        }).$else(function() {
                            this.posM.y = pb.add(this.posM.y, pb.mul(this.pixelOffsetSubpix, this.lengthSign));
                        });
                        this.$return(pb.textureSampleLevel(this.srcTex, this.posM, 0).xyzw);
                    });
                    pb.main(function() {
                        this.$l.color = this.FXAA(this.$inputs.uv);
                        this.$if(pb.equal(this.srgbOut, 0), function() {
                            this.$outputs.outColor = this.color;
                        }).$else(function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color.rgb), this.color.a);
                        });
                    });
                }
            });
        }
        if (!FXAA._sampler) {
            FXAA._sampler = device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
        }
        if (!this._bindgroup) {
            this._bindgroup = device.createBindGroup(FXAA._program.bindGroupLayouts[0]);
        }
    }
}

/**
 * Post processing compositor
 * @public
 */ class Compositor {
    /** @internal */ _postEffectsOpaque;
    /** @internal */ _postEffectsTransparency;
    /** @internal */ static _blitSampler = null;
    /** @internal */ static _blitProgram = null;
    /** @internal */ static _blitBindgroup = null;
    /** @internal */ static _blitRenderStates = null;
    /** @internal */ static _blitVertexLayout = null;
    /**
   * Creates an instance of Compositor
   */ constructor(){
        this._postEffectsOpaque = [];
        this._postEffectsTransparency = [];
    }
    /** @internal */ requireLinearDepth() {
        for (const postEffect of this._postEffectsOpaque){
            if (postEffect.requireLinearDepthTexture()) {
                return true;
            }
        }
        for (const postEffect of this._postEffectsTransparency){
            if (postEffect.requireLinearDepthTexture()) {
                return true;
            }
        }
        return false;
    }
    /**
   * Adds a posteffect
   *
   * @param postEffect - The post effect to add
   * @param opaque - true if the post effect should be applied after the opaque pass and before the transparent pass, otherwise the post effect should be applied after the transparent pass
   */ appendPostEffect(postEffect) {
        if (postEffect) {
            if (this._postEffectsOpaque.indexOf(postEffect) >= 0 || this._postEffectsTransparency.indexOf(postEffect) >= 0) {
                console.error(`Posteffect cannot be added to same compositor multiple times`);
                return;
            }
            const postEffects = postEffect.opaque ? this._postEffectsOpaque : this._postEffectsTransparency;
            postEffects.push(postEffect);
        }
    }
    /**
   * Removes a posteffect that was previously added
   *
   * @param postEffect - The posteffect to be remove.
   */ removePostEffect(postEffect) {
        for (const list of [
            this._postEffectsOpaque,
            this._postEffectsTransparency
        ]){
            const index = list.indexOf(postEffect);
            if (index >= 0) {
                list.splice(index, 1);
                return;
            }
        }
    }
    /**
   * Removes all post effects
   */ clear() {
        this._postEffectsOpaque = [];
        this._postEffectsTransparency = [];
    }
    /**
   * Gets all post effects
   */ getPostEffects() {
        return [
            ...this._postEffectsOpaque,
            ...this._postEffectsTransparency
        ];
    }
    /** @internal */ begin(ctx) {
        const device = Application.instance.device;
        const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? 'rgba16f' : 'rgba8unorm';
        const finalFramebuffer = device.getFramebuffer();
        const depth = finalFramebuffer?.getDepthAttachment();
        let pingpongFramebuffers;
        let msFramebuffer = null;
        if (ctx.primaryCamera.sampleCount > 1) {
            msFramebuffer = depth ? TemporalCache.getFramebufferVariantSizeWithDepth(depth, 1, format, '2d', false, ctx.primaryCamera.sampleCount) : TemporalCache.getFramebufferVariantSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, ctx.primaryCamera.sampleCount);
        }
        if (ctx.defaultViewport) {
            pingpongFramebuffers = [
                depth ? TemporalCache.getFramebufferVariantSizeWithDepth(depth, 1, format, '2d', false, 1) : TemporalCache.getFramebufferVariantSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 1),
                depth ? TemporalCache.getFramebufferVariantSizeWithDepth(depth, 1, format, '2d', false, 1) : TemporalCache.getFramebufferVariantSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 1)
            ];
        } else {
            pingpongFramebuffers = [
                depth ? TemporalCache.getFramebufferFixedSizeWithDepth(depth, 1, format, '2d', false, 4) : TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 4),
                depth ? TemporalCache.getFramebufferFixedSizeWithDepth(depth, 1, format, '2d', false, 4) : TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 4)
            ];
        }
        let writeIndex;
        if (msFramebuffer) {
            writeIndex = 3;
            device.setFramebuffer(msFramebuffer);
        } else {
            writeIndex = 0;
            device.setFramebuffer(pingpongFramebuffers[writeIndex]);
        }
        device.setViewport(null);
        device.setScissor(null);
        ctx.compositorContex = {
            finalFramebuffer,
            pingpongFramebuffers,
            msFramebuffer,
            writeIndex
        };
    }
    /** @internal */ drawPostEffects(ctx, opaque, sceneDepthTexture) {
        const postEffects = opaque ? this._postEffectsOpaque : this._postEffectsTransparency;
        if (postEffects.length > 0) {
            const device = Application.instance.device;
            for(let i = 0; i < postEffects.length; i++){
                const postEffect = postEffects[i];
                if (!postEffect.enabled) {
                    continue;
                }
                const inputTexture = device.getFramebuffer().getColorAttachments()[0];
                const isLast = this.isLastPostEffect(opaque, i);
                const finalEffect = isLast && (!postEffect.requireDepthAttachment() || !!ctx.compositorContex.finalFramebuffer);
                if (finalEffect) {
                    device.setFramebuffer(ctx.compositorContex.finalFramebuffer);
                    device.setViewport(null);
                    device.setScissor(null);
                } else {
                    ctx.compositorContex.writeIndex = (1 + ctx.compositorContex.writeIndex) % 2;
                    device.setFramebuffer(ctx.compositorContex.pingpongFramebuffers[ctx.compositorContex.writeIndex]);
                    device.setViewport(null);
                    device.setScissor(null);
                }
                postEffect.apply(ctx, inputTexture, sceneDepthTexture, !device.getFramebuffer());
            }
        }
    }
    /** @internal */ end(ctx) {
        const device = Application.instance.device;
        if (device.getFramebuffer() !== ctx.compositorContex.finalFramebuffer) {
            const srcTex = device.getFramebuffer().getColorAttachments()[0];
            device.setFramebuffer(ctx.compositorContex.finalFramebuffer);
            device.setViewport(null);
            device.setScissor(null);
            Compositor._blit(device, srcTex, !ctx.compositorContex.finalFramebuffer);
        }
        TemporalCache.releaseFramebuffer(ctx.compositorContex.pingpongFramebuffers[0]);
        TemporalCache.releaseFramebuffer(ctx.compositorContex.pingpongFramebuffers[1]);
        if (ctx.compositorContex.msFramebuffer) {
            TemporalCache.releaseFramebuffer(ctx.compositorContex.msFramebuffer);
        }
        ctx.compositorContex = null;
    }
    /** @internal */ isLastPostEffect(opaque, index) {
        const list = opaque ? this._postEffectsOpaque : this._postEffectsTransparency;
        for(let i = index; i < list.length; i++){
            if (list[i].enabled) {
                return false;
            }
        }
        if (opaque) {
            for(let i = 0; i < this._postEffectsTransparency.length; i++){
                if (this._postEffectsTransparency[i].enabled) {
                    return false;
                }
            }
        }
        return true;
    }
    /** @internal */ needDrawPostEffects() {
        for(let i = 0; i < this._postEffectsOpaque.length; i++){
            if (this._postEffectsOpaque[i].enabled) {
                return true;
            }
        }
        for(let i = 0; i < this._postEffectsTransparency.length; i++){
            if (this._postEffectsTransparency[i].enabled) {
                return true;
            }
        }
        return false;
    }
    /** @internal */ static _blit(device, srcTex, srgbOutput) {
        if (!this._blitProgram) {
            this._blitProgram = device.buildRenderProgram({
                vertex (pb) {
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    this.flip = pb.int().uniform(0);
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.srcTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                    this.srgbOutput = pb.int().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$outputs.outColor = pb.textureSample(this.srcTex, this.$inputs.uv);
                        this.$if(pb.notEqual(this.srgbOutput, 0), function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.$outputs.outColor.rgb), 1);
                        });
                    });
                }
            });
            this._blitBindgroup = device.createBindGroup(this._blitProgram.bindGroupLayouts[0]);
            this._blitVertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                            -1,
                            -1,
                            1,
                            -1,
                            -1,
                            1,
                            1,
                            1
                        ]))
                    }
                ]
            });
            this._blitSampler = device.createSampler({
                minFilter: 'nearest',
                magFilter: 'nearest',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
            this._blitRenderStates = device.createRenderStateSet();
            this._blitRenderStates.useRasterizerState().setCullMode('none');
            this._blitRenderStates.useDepthState().enableTest(false).enableWrite(false);
        }
        this._blitBindgroup.setTexture('srcTex', srcTex, this._blitSampler);
        this._blitBindgroup.setValue('srgbOutput', srgbOutput ? 1 : 0);
        this._blitBindgroup.setValue('flip', device.type === 'webgpu' && !!device.getFramebuffer() ? 1 : 0);
        device.setRenderStates(this._blitRenderStates);
        device.setProgram(this._blitProgram);
        device.setBindGroup(0, this._blitBindgroup);
        device.setVertexLayout(this._blitVertexLayout);
        device.draw('triangle-strip', 0, 4);
    }
}

let _uniqueId$1 = 0;
class WebGPUObject extends makeEventTarget(Object)() {
    _device;
    _object;
    _uid;
    _cid;
    _name;
    _queueState;
    _restoreHandler;
    constructor(device){
        super();
        this._device = device;
        this._object = null;
        this._uid = ++_uniqueId$1;
        this._cid = 1;
        this._name = `${genDefaultName(this)}#${this._uid}`;
        this._queueState = 0;
        this._restoreHandler = null;
        this._device.addGPUObject(this);
    }
    get device() {
        return this._device;
    }
    get object() {
        return this._object;
    }
    get uid() {
        return this._uid;
    }
    get cid() {
        return this._cid;
    }
    get disposed() {
        return !this._object;
    }
    get restoreHandler() {
        return this._restoreHandler;
    }
    set restoreHandler(handler) {
        this._restoreHandler = handler;
    }
    get name() {
        return this._name;
    }
    set name(val) {
        if (val !== this._name) {
            const evt = new DeviceGPUObjectRenameEvent(this, this._name);
            this._name = val;
            this._device.dispatchEvent(evt);
        }
    }
    get queueState() {
        return this._queueState;
    }
    set queueState(val) {
        this._queueState = val;
    }
    isVertexLayout() {
        return false;
    }
    isFramebuffer() {
        return false;
    }
    isSampler() {
        return false;
    }
    isTexture() {
        return false;
    }
    isTexture2D() {
        return false;
    }
    isTexture2DArray() {
        return false;
    }
    isTexture3D() {
        return false;
    }
    isTextureCube() {
        return false;
    }
    isTextureVideo() {
        return false;
    }
    isProgram() {
        return false;
    }
    isBuffer() {
        return false;
    }
    isBindGroup() {
        return false;
    }
    dispose() {
        if (!this.disposed) {
            this._device.disposeObject(this, true);
        }
    }
    async reload() {
        if (this.disposed) {
            const p = this._device.restoreObject(this);
            this._cid++;
            return p;
        }
    }
    destroy() {
        throw new Error('Abstract function call: dispose()');
    }
    async restore() {
        throw new Error('Abstract function call: restore()');
    }
}

class WebGPUProgram extends WebGPUObject {
    static _hashCounter = 0;
    _type;
    _vs;
    _fs;
    _cs;
    _label;
    _hash;
    _error;
    _bindGroupLayouts;
    _vertexAttributes;
    _csModule;
    _vsModule;
    _fsModule;
    _pipelineLayout;
    constructor(device, params){
        super(device);
        this._type = params.type;
        this._label = params.label;
        this._bindGroupLayouts = [
            ...params.params.bindGroupLayouts
        ];
        this._error = '';
        if (params.type === 'render') {
            const renderParams = params.params;
            this._vs = renderParams.vs;
            this._fs = renderParams.fs;
            this._vertexAttributes = renderParams.vertexAttributes ? renderParams.vertexAttributes.join(':') : '';
        } else {
            const computeParams = params.params;
            this._cs = computeParams.source;
        }
        this._load();
        this._hash = String(++WebGPUProgram._hashCounter);
    }
    get type() {
        return this._type;
    }
    get label() {
        return this._label;
    }
    getCompileError() {
        return this._error;
    }
    getShaderSource(kin) {
        switch(kin){
            case 'vertex':
                return this._vs;
            case 'fragment':
                return this._fs;
            case 'compute':
                return this._cs;
        }
    }
    getBindingInfo(name) {
        for(let group = 0; group < this._bindGroupLayouts.length; group++){
            const layout = this._bindGroupLayouts[group];
            const bindName = layout.nameMap?.[name] ?? name;
            for(let binding = 0; binding < layout.entries.length; binding++){
                const bindingPoint = layout.entries[binding];
                if (bindingPoint.name === bindName) {
                    return {
                        group: group,
                        binding: binding,
                        type: bindingPoint.type
                    };
                }
            }
        }
        return null;
    }
    get bindGroupLayouts() {
        return this._bindGroupLayouts;
    }
    get vertexAttributes() {
        return this._vertexAttributes;
    }
    get hash() {
        return this._hash;
    }
    getPipelineLayout() {
        return this._pipelineLayout;
    }
    getShaderModule() {
        return {
            vsModule: this._vsModule,
            fsModule: this._fsModule,
            csModule: this._csModule,
            pipelineLayout: this._pipelineLayout
        };
    }
    get fsModule() {
        return this._fsModule;
    }
    destroy() {
        this._vsModule = null;
        this._fsModule = null;
        this._pipelineLayout = null;
        this._object = null;
    }
    async restore() {
        if (!this._object) {
            this._load();
        }
    }
    isProgram() {
        return true;
    }
    createUniformBuffer(uniform) {
        const type = this.getBindingInfo(uniform)?.type;
        return type ? this.device.createStructuredBuffer(type, {
            usage: 'uniform'
        }) : null;
    }
    _load() {
        if (this._type === 'render') {
            this._vsModule = this.createShaderModule(this._vs);
            this._fsModule = this.createShaderModule(this._fs);
        } else {
            this._csModule = this.createShaderModule(this._cs);
        }
        this._pipelineLayout = this.createPipelineLayout(this._bindGroupLayouts);
        this._object = {};
    }
    createPipelineLayout(bindGroupLayouts) {
        const layouts = [];
        bindGroupLayouts.forEach((val)=>{
            layouts.push(this._device.fetchBindGroupLayout(val));
        });
        return this._device.device.createPipelineLayout({
            bindGroupLayouts: layouts
        });
    }
    createShaderModule(code) {
        let sm = this._device.device.createShaderModule({
            code
        });
        if (sm) {
            const func = sm.compilationInfo || sm.getCompilationInfo;
            if (!func) {
                return sm;
            }
            func.call(sm).then((compilationInfo)=>{
                let err = false;
                if (compilationInfo?.messages?.length > 0) {
                    let msg = '';
                    for (const message of compilationInfo.messages){
                        if (message.type === 'error') {
                            err = true;
                        }
                        msg += `Line ${message.lineNum}:${message.linePos} - ${code.slice(message.offset, message.offset + message.length)}\n`;
                        msg += `${message.message}\n`;
                        if (message.type === 'error') {
                            err = true;
                            console.error(msg);
                        } else if (message.type === 'warning') {
                            console.warn(msg);
                        } else {
                            console.log(msg);
                        }
                        this._error += msg;
                    }
                }
                if (err) {
                    sm = null;
                }
            });
        }
        return sm;
    }
    use() {
        this._device.setProgram(this);
    }
}

class UploadRingBuffer {
    _device;
    _bufferList;
    _defaultSize;
    _unmappedBufferList;
    constructor(device, defaultSize = 64 * 1024){
        this._device = device;
        this._bufferList = [];
        this._defaultSize = defaultSize;
        this._unmappedBufferList = [];
    }
    uploadBuffer(src, dst, srcOffset, dstOffset, uploadSize, allowOverlap) {
        const size = uploadSize + 3 & ~3;
        const mappedBuffer = this.fetchBufferMapped(size, !!allowOverlap);
        if (src) {
            const mappedRange = mappedBuffer.mappedRange; //mappedBuffer.buffer.getMappedRange(mappedBuffer.offset, size);
            new Uint8Array(mappedRange, mappedBuffer.offset, size).set(new Uint8Array(src, srcOffset, uploadSize));
        }
        const upload = {
            mappedBuffer: {
                ...mappedBuffer
            },
            uploadSize: size,
            uploadBuffer: dst,
            uploadOffset: dstOffset
        };
        mappedBuffer.offset += size;
        mappedBuffer.offset = mappedBuffer.offset + 7 & ~7;
        return upload;
    }
    beginUploads() {
        for(let i = this._bufferList.length - 1; i >= 0; i--){
            const buffer = this._bufferList[i];
            if (buffer.used) {
                buffer.buffer.unmap();
                this._unmappedBufferList.push(buffer);
                this._bufferList.splice(i, 1);
                buffer.mappedRange = null;
            }
        }
        return this._unmappedBufferList.length;
    }
    endUploads() {
        for (const buffer of this._unmappedBufferList){
            buffer.buffer.mapAsync(GPUMapMode.WRITE).then(()=>{
                buffer.offset = 0;
                buffer.used = false;
                buffer.mappedRange = buffer.buffer.getMappedRange();
                this._bufferList.push(buffer);
            });
        }
        this._unmappedBufferList = [];
    }
    purge() {
        for(let i = this._bufferList.length - 1; i >= 0; i--){
            const buffer = this._bufferList[i];
            if (buffer.mappedRange) {
                buffer.buffer.unmap();
                buffer.buffer.destroy();
            }
        }
        this._bufferList = [];
        for (const buffer of this._unmappedBufferList){
            buffer.buffer.destroy();
        }
        this._unmappedBufferList = [];
    }
    fetchBufferMapped(size, allowOverlap) {
        for (const buffer of this._bufferList){
            if (allowOverlap || buffer.size - buffer.offset >= size) {
                buffer.used = true;
                return buffer;
            }
        }
        const bufferSize = Math.max(size, this._defaultSize) + 3 & ~3;
        const buf = this._device.device.createBuffer({
            label: `StagingRingBuffer${this._bufferList.length}:${bufferSize}`,
            size: bufferSize,
            usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
            mappedAtCreation: true
        });
        this._bufferList.push({
            buffer: buf,
            size: bufferSize,
            offset: 0,
            used: true,
            mappedRange: buf.getMappedRange()
        });
        return this._bufferList[this._bufferList.length - 1];
    }
}

class WebGPUBuffer extends WebGPUObject {
    _size;
    _usage;
    _gpuUsage;
    _memCost;
    _ringBuffer;
    _pendingUploads;
    constructor(device, usage, data){
        super(device);
        this._object = null;
        this._memCost = 0;
        this._usage = usage;
        this._gpuUsage = 0;
        this._size = typeof data === 'number' ? data : data.byteLength;
        if (this._size <= 0) {
            throw new Error('can not create buffer with zero size');
        }
        this._ringBuffer = new UploadRingBuffer(device, this._size + 15 & ~15);
        this._pendingUploads = [];
        this.load(typeof data === 'number' ? null : data);
    }
    get hash() {
        return this._object ? this._device.gpuGetObjectHash(this._object) : 0;
    }
    get byteLength() {
        return this._size;
    }
    get usage() {
        return this._usage;
    }
    get gpuUsage() {
        return this._gpuUsage;
    }
    getPendingUploads() {
        return this._pendingUploads;
    }
    clearPendingUploads() {
        if (this._pendingUploads.length > 0) {
            this._pendingUploads = [];
            this.beginSyncChanges(null);
            this.endSyncChanges();
        }
    }
    bufferSubData(dstByteOffset, data, srcOffset, srcLength) {
        srcOffset = Number(srcOffset) || 0;
        dstByteOffset = Number(dstByteOffset) || 0;
        srcLength = Number(srcLength) || data.length - srcOffset;
        if (srcOffset + srcLength > data.length) {
            throw new Error('bufferSubData() failed: source buffer is too small');
        }
        if (dstByteOffset + srcLength * data.BYTES_PER_ELEMENT > this.byteLength) {
            throw new Error('bufferSubData() failed: dest buffer is too small');
        }
        let uploadSize = srcLength * data.BYTES_PER_ELEMENT;
        if ((dstByteOffset & 3) !== 0 || (uploadSize & 3) !== 0) {
            throw new Error('bufferSubData() failed: destination byte offset or upload size must be 4 bytes aligned');
        }
        const uploadOffset = data.byteOffset + srcOffset * data.BYTES_PER_ELEMENT;
        const writeOffset = dstByteOffset;
        const writeSize = uploadSize;
        if (this._pendingUploads.length === 0) {
            this.pushUpload(this._pendingUploads, data.buffer, uploadOffset, dstByteOffset, uploadSize);
        } else {
            let newPendings = [];
            let added = false;
            for(let i = 0; i < this._pendingUploads.length; i++){
                const upload = this._pendingUploads[i];
                if (upload.uploadOffset + upload.uploadSize < dstByteOffset) {
                    // current upload in front of new upload
                    newPendings.push(upload);
                } else if (upload.uploadOffset > dstByteOffset + uploadSize) {
                    // current upload behind of new upload
                    if (!added) {
                        added = true;
                        this.pushUpload(newPendings, null, 0, dstByteOffset, uploadSize);
                    }
                    newPendings.push(upload);
                } else {
                    const start = Math.min(dstByteOffset, upload.uploadOffset);
                    const end = Math.max(dstByteOffset + uploadSize, upload.uploadOffset + upload.uploadSize);
                    if (end - start < uploadSize + upload.uploadSize && this._device.currentPass?.isBufferUploading(this)) {
                        // data overlaps and previous data is in use, refresh data by restarting current render pass or compute pass
                        this._device.currentPass.end();
                        // now, the pending uploads should be cleared
                        newPendings = [];
                        break;
                    }
                    dstByteOffset = start;
                    uploadSize = end - start;
                }
            }
            if (!added) {
                this.pushUpload(newPendings, null, 0, dstByteOffset, uploadSize);
            }
            this._pendingUploads = newPendings;
            new Uint8Array(this._pendingUploads[0].mappedBuffer.mappedRange, writeOffset, writeSize).set(new Uint8Array(data.buffer, uploadOffset, writeSize));
        }
    }
    async getBufferSubData(dstBuffer, offsetInBytes, sizeInBytes) {
        if (!(this._usage & GPUResourceUsageFlags.BF_READ)) {
            throw new Error('getBufferSubData() failed: buffer does not have BF_READ flag set');
        }
        this.sync();
        offsetInBytes = Number(offsetInBytes) || 0;
        sizeInBytes = Number(sizeInBytes) || this.byteLength - offsetInBytes;
        if (offsetInBytes < 0 || offsetInBytes + sizeInBytes > this.byteLength) {
            throw new Error('data query range out of bounds');
        }
        if (dstBuffer && dstBuffer.byteLength < sizeInBytes) {
            throw new Error('no enough space for querying buffer data');
        }
        dstBuffer = dstBuffer || new Uint8Array(sizeInBytes);
        await this._object.mapAsync(GPUMapMode.READ);
        const range = this._object.getMappedRange();
        dstBuffer.set(new Uint8Array(range, offsetInBytes, sizeInBytes));
        this._object.unmap();
        return dstBuffer;
    }
    async restore() {
        if (!this._device.isContextLost()) {
            this.load();
        }
    }
    destroy() {
        if (this._object) {
            this._object.destroy();
            this._object = null;
            this._gpuUsage = 0;
            this._memCost = 0;
        }
    }
    isBuffer() {
        return true;
    }
    beginSyncChanges(encoder) {
        if (this._pendingUploads.length > 0) {
            const cmdEncoder = encoder || this._device.device.createCommandEncoder();
            for (const upload of this._pendingUploads){
                cmdEncoder.copyBufferToBuffer(upload.mappedBuffer.buffer, upload.mappedBuffer.offset, this._object, upload.uploadOffset, upload.uploadSize);
            }
            if (!encoder) {
                this._device.device.queue.submit([
                    cmdEncoder.finish()
                ]);
            }
            this._pendingUploads.length = 0;
            this._ringBuffer.beginUploads();
        }
    }
    endSyncChanges() {
        if (this._usage & GPUResourceUsageFlags.DYNAMIC) {
            this._ringBuffer.endUploads();
        } else {
            this._ringBuffer.purge();
        }
    }
    load(data) {
        if (this._device.isContextLost()) {
            return;
        }
        this._memCost = 0;
        if (!this._device.isContextLost()) {
            if (!this._object) {
                this._gpuUsage = 0;
                let label = '';
                if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                    this._gpuUsage |= GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST;
                    label += '[vertex]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                    this._gpuUsage |= GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
                    label += '[index]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                    this._gpuUsage |= GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
                    label += '[uniform]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_STORAGE) {
                    this._gpuUsage |= GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
                    label += '[storage]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_READ) {
                    this._gpuUsage |= GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;
                    label += '[mapRead]';
                }
                if (this._usage & GPUResourceUsageFlags.BF_WRITE) {
                    this._gpuUsage |= GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;
                    label += '[mapWrite]';
                }
                if (data) {
                    this._object = this._device.gpuCreateBuffer({
                        label: label,
                        size: data.byteLength + 15 & ~15,
                        usage: this._gpuUsage,
                        mappedAtCreation: true
                    });
                    const range = this._object.getMappedRange();
                    new data.constructor(range).set(data);
                    this._object.unmap();
                } else {
                    this._object = this._device.gpuCreateBuffer({
                        label: label,
                        size: this.byteLength + 15 & ~15,
                        usage: this._gpuUsage
                    });
                }
                const memCost = this.byteLength;
                this._device.updateVideoMemoryCost(memCost - this._memCost);
                this._memCost = memCost;
            }
        }
    }
    sync() {
        if (this._pendingUploads) {
            if (this._device.isBufferUploading(this)) {
                this._device.currentPass.end();
            } else {
                this.beginSyncChanges(null);
                this.endSyncChanges();
            }
        }
    }
    pushUpload(pending, data, srcByteOffset, dstByteOffset, byteSize) {
        const bufferMapped = this._ringBuffer.fetchBufferMapped(byteSize, true);
        if (data) {
            new Uint8Array(bufferMapped.mappedRange, dstByteOffset, byteSize).set(new Uint8Array(data, srcByteOffset, byteSize));
        }
        pending.push({
            mappedBuffer: {
                buffer: bufferMapped.buffer,
                size: bufferMapped.size,
                offset: dstByteOffset,
                used: bufferMapped.used,
                mappedRange: bufferMapped.mappedRange
            },
            uploadSize: byteSize,
            uploadOffset: dstByteOffset,
            uploadBuffer: this._object
        });
    }
}

const typeU8Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2_NORM);
const typeU8Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4_NORM);
const typeI8Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2_NORM);
const typeI8Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4_NORM);
const typeU16Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2);
const typeU16Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4);
const typeI16Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2);
const typeI16Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4);
const typeU16Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2_NORM);
const typeU16Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4_NORM);
const typeI16Vec2_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2_NORM);
const typeI16Vec4_Norm = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4_NORM);
const typeF16Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC2);
const typeF16Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC4);
const typeF32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32);
const typeF32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC2);
const typeF32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC3);
const typeF32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC4);
const typeU32$2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
const typeU32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2);
const typeU32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3);
const typeU32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4);
const typeI32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
const typeI32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2);
const typeI32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3);
const typeI32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4);
const vertexFormatTable = {
    [typeU8Vec2_Norm.typeId]: 'unorm8x2',
    [typeU8Vec4_Norm.typeId]: 'unorm8x4',
    [typeI8Vec2_Norm.typeId]: 'snorm8x2',
    [typeI8Vec4_Norm.typeId]: 'snorm8x4',
    [typeU16Vec2.typeId]: 'uint16x2',
    [typeU16Vec4.typeId]: 'uint16x4',
    [typeI16Vec2.typeId]: 'sint16x2',
    [typeI16Vec4.typeId]: 'sint16x4',
    [typeU16Vec2_Norm.typeId]: 'unorm16x2',
    [typeU16Vec4_Norm.typeId]: 'unorm16x4',
    [typeI16Vec2_Norm.typeId]: 'snorm16x2',
    [typeI16Vec4_Norm.typeId]: 'snorm16x4',
    [typeF16Vec2.typeId]: 'float16x2',
    [typeF16Vec4.typeId]: 'float16x4',
    [typeF32.typeId]: 'float32',
    [typeF32Vec2.typeId]: 'float32x2',
    [typeF32Vec3.typeId]: 'float32x3',
    [typeF32Vec4.typeId]: 'float32x4',
    [typeU32$2.typeId]: 'uint32',
    [typeU32Vec2.typeId]: 'uint32x2',
    [typeU32Vec3.typeId]: 'uint32x3',
    [typeU32Vec4.typeId]: 'uint32x4',
    [typeI32.typeId]: 'sint32',
    [typeI32Vec2.typeId]: 'sint32x2',
    [typeI32Vec3.typeId]: 'sint32x3',
    [typeI32Vec4.typeId]: 'sint32x4'
};
class WebGPUStructuredBuffer extends WebGPUBuffer {
    _structure;
    _data;
    constructor(device, structure, usage, source){
        if (!structure?.isStructType()) {
            throw new Error('invalid structure type');
        }
        if (usage & GPUResourceUsageFlags.BF_INDEX) {
            throw new Error('structured buffer must not have Index usage flag');
        }
        if (usage & GPUResourceUsageFlags.BF_READ || usage & GPUResourceUsageFlags.BF_WRITE) {
            throw new Error('structured buffer must not have Read or Write usage flags');
        }
        if (usage & GPUResourceUsageFlags.BF_VERTEX) {
            if (structure.structMembers.length !== 1 || !structure.structMembers[0].type.isArrayType()) {
                throw new Error('structured buffer for vertex usage must have only one array member');
            }
        }
        if (usage & GPUResourceUsageFlags.BF_UNIFORM || usage & GPUResourceUsageFlags.BF_STORAGE) {
            usage |= GPUResourceUsageFlags.DYNAMIC;
        }
        const layout = structure.toBufferLayout(0, structure.layout);
        if (source && layout.byteSize !== source.byteLength) {
            throw new Error(`create structured buffer failed: invalid source size: ${source.byteLength}, should be ${layout.byteSize}`);
        }
        super(device, usage, source || layout.byteSize);
        this._data = new StructuredBufferData(layout, this);
        this._structure = structure;
    }
    set(name, value) {
        this._data.set(name, value);
    }
    get structure() {
        return this._structure;
    }
    set structure(st) {
        if (st && !st.isCompatibleType(this._structure)) {
            const layout = st.toBufferLayout(0, st.layout);
            if (layout.byteSize > this.byteLength) {
                throw new Error(`set structure type failed: new structure type is too large: ${layout.byteSize}`);
            }
            this._data = new StructuredBufferData(layout, this);
            this._structure = st;
        }
    }
    static getGPUVertexFormat(type) {
        return vertexFormatTable[type.typeId];
    }
}

class WebGPUBindGroup extends WebGPUObject {
    _layout;
    _bindGroup;
    _buffers;
    _textures;
    _videoTextures;
    _resources;
    constructor(device, layout){
        super(device);
        this._device = device;
        this._layout = layout;
        this._bindGroup = null;
        this._resources = {};
        this._buffers = [];
        this._textures = [];
        this._videoTextures = null;
    }
    get bindGroup() {
        if (!this._bindGroup) {
            this._bindGroup = this._create();
        }
        return this._bindGroup;
    }
    get bufferList() {
        return this._buffers;
    }
    get textureList() {
        return this._textures;
    }
    getLayout() {
        return this._layout;
    }
    getBuffer(name) {
        return this._getBuffer(name, GPUResourceUsageFlags.BF_UNIFORM | GPUResourceUsageFlags.BF_STORAGE, true);
    }
    setBuffer(name, buffer) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.name === bindName) {
                if (!entry.buffer) {
                    console.log(`setBuffer() failed: resource '${name}' is not buffer`);
                } else {
                    const bufferUsage = entry.buffer.type === 'uniform' ? GPUResourceUsageFlags.BF_UNIFORM : GPUResourceUsageFlags.BF_STORAGE;
                    if (buffer && !(buffer.usage & bufferUsage)) {
                        console.log(`setBuffer() failed: buffer resource '${name}' must be type '${entry.buffer.type}'`);
                    } else if (buffer !== this._resources[entry.name]) {
                        this._resources[entry.name] = buffer;
                        this._bindGroup = null;
                    }
                }
                return;
            }
        }
        console.log(`setBuffer() failed: no buffer resource named '${name}'`);
    }
    setValue(name, value) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setValue(mappedName, {
                [name]: value
            });
        } else {
            const buffer = this._getBuffer(name, GPUResourceUsageFlags.BF_UNIFORM | GPUResourceUsageFlags.BF_STORAGE, false);
            if (buffer) {
                if (!(buffer instanceof WebGPUStructuredBuffer)) {
                    throw new Error(`BindGroup.setValue() failed: '${name}' is not structured buffer`);
                }
                if (value?.BYTES_PER_ELEMENT) {
                    buffer.bufferSubData(0, value);
                } else {
                    for(const k in value){
                        buffer.set(k, value[k]);
                    }
                }
            } else {
                console.log(`setValue() failed: no uniform buffer named '${name}'`);
            }
        }
    }
    setRawData(name, byteOffset, data, srcPos, srcLength) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setRawData(mappedName, byteOffset, data, srcPos, srcLength);
        } else {
            const buffer = this._getBuffer(name, GPUResourceUsageFlags.BF_UNIFORM | GPUResourceUsageFlags.BF_STORAGE, false);
            if (buffer) {
                buffer.bufferSubData(byteOffset, data, srcPos, srcLength);
            } else {
                console.log(`set(): no uniform buffer named '${name}'`);
            }
        }
    }
    getTexture(name) {
        const entry = this._findTextureLayout(name);
        if (entry) {
            const t = this._resources[name];
            return t ? t[0] : null;
        } else {
            throw new Error(`getTexture() failed:${name} is not a texture`);
        }
    }
    setTextureView(name, value, level, face, mipCount, sampler) {
        if (!value) {
            throw new Error(`WebGPUBindGroup.setTextureView() failed: invalid texture uniform value: ${value}`);
        } else {
            const entry = this._findTextureLayout(name);
            if (entry) {
                if (entry.externalTexture) {
                    throw new Error(`WebGPUBindGroup.setTextureView() failed: video texture does not have view`);
                } else if (value.isTextureVideo()) {
                    throw new Error(`WebGPUBindGroup.setTextureView() failed: invalid texture type`);
                }
                const t = this._resources[name];
                const view = value.getView(level, face, mipCount);
                if (!t || t[1] !== view) {
                    this._resources[name] = [
                        value,
                        view
                    ];
                    this._bindGroup = null;
                }
                if (entry.texture?.autoBindSampler) {
                    const samplerEntry = this._findSamplerLayout(entry.texture.autoBindSampler);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTextureView() failed: sampler entry not found: ${entry.texture.autoBindSampler}`);
                    }
                    const s = !sampler || sampler.compare ? value.getDefaultSampler(false) : sampler;
                    if (s.object !== this._resources[entry.texture.autoBindSampler]) {
                        this._resources[entry.texture.autoBindSampler] = s.object;
                        this._bindGroup = null;
                    }
                }
                if (entry.texture?.autoBindSamplerComparison) {
                    const samplerEntry = this._findSamplerLayout(entry.texture.autoBindSamplerComparison);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTextureView() failed: sampler entry not found: ${entry.texture.autoBindSamplerComparison}`);
                    }
                    const s = !sampler || !sampler.compare ? value.getDefaultSampler(true) : sampler;
                    if (s.object !== this._resources[entry.texture.autoBindSamplerComparison]) {
                        this._resources[entry.texture.autoBindSamplerComparison] = s.object;
                        this._bindGroup = null;
                    }
                }
            } else {
                throw new Error(`WebGPUBindGroup.setView() failed: no texture uniform named '${name}'`);
            }
        }
    }
    setTexture(name, value, sampler) {
        if (!value) {
            throw new Error(`WebGPUBindGroup.setTexture() failed: invalid texture uniform value: ${value}`);
        } else {
            const entry = this._findTextureLayout(name);
            if (entry) {
                const t = this._resources[name];
                if (entry.externalTexture) {
                    if (!value.isTextureVideo()) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: invalid texture type of resource '${name}'`);
                    }
                    if (!t || t !== value) {
                        this._resources[name] = value;
                        this._bindGroup = null;
                        this._videoTextures = [];
                        for (const entry of this._layout.entries){
                            if (entry.externalTexture) {
                                const tex = this._resources[entry.name];
                                if (tex && this._videoTextures.indexOf(tex) < 0) {
                                    this._videoTextures.push(tex);
                                }
                            }
                        }
                    }
                } else {
                    if (value.isTextureVideo()) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: invalid texture type of resource '${name}'`);
                    }
                    const view = value.getDefaultView();
                    if (!entry.externalTexture && !view) {
                        throw new Error('WebGPUBindGroup.setTexture() failed: create texture view failed');
                    }
                    if (!t || t[0] !== value) {
                        this._resources[name] = [
                            value,
                            view
                        ];
                        this._bindGroup = null;
                    }
                }
                const autoBindSampler = entry.texture?.autoBindSampler || entry.externalTexture?.autoBindSampler;
                if (autoBindSampler) {
                    const samplerEntry = this._findSamplerLayout(autoBindSampler);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: sampler entry not found: ${autoBindSampler}`);
                    }
                    const s = !sampler || sampler.compare ? value.getDefaultSampler(false) : sampler;
                    if (s.object !== this._resources[autoBindSampler]) {
                        this._resources[autoBindSampler] = s.object;
                        this._bindGroup = null;
                    }
                }
                const autoBindSamplerComparison = entry.texture?.autoBindSamplerComparison;
                if (autoBindSamplerComparison) {
                    const samplerEntry = this._findSamplerLayout(autoBindSamplerComparison);
                    if (!samplerEntry || !samplerEntry.sampler) {
                        throw new Error(`WebGPUBindGroup.setTexture() failed: sampler entry not found: ${autoBindSamplerComparison}`);
                    }
                    const s = !sampler || !sampler.compare ? value.getDefaultSampler(true) : sampler;
                    if (s.object !== this._resources[autoBindSamplerComparison]) {
                        this._resources[autoBindSamplerComparison] = s.object;
                        this._bindGroup = null;
                    }
                }
            } else {
                throw new Error(`WebGPUBindGroup.setTexture() failed: no texture uniform named '${name}'`);
            }
        }
    }
    setSampler(name, value) {
        const sampler = value?.object;
        if (!sampler) {
            console.log(`WebGPUBindGroup.setSampler() failed: invalid sampler uniform value: ${value}`);
        } else if (this._resources[name] !== sampler) {
            if (!this._findSamplerLayout(name)) {
                console.log(`WebGPUBindGroup.setSampler() failed: no sampler uniform named '${name}'`);
            } else {
                this._resources[name] = sampler;
                this._bindGroup = null;
            }
        }
    }
    destroy() {
        this._bindGroup = null;
        this._resources = {};
        this._buffers = [];
        this._textures = [];
        this._videoTextures = null;
        this._object = null;
    }
    async restore() {
        this._bindGroup = null;
        this._object = {};
    }
    isBindGroup() {
        return true;
    }
    /** @internal */ updateVideoTextures() {
        this._videoTextures?.forEach((t)=>{
            if (t.updateVideoFrame()) {
                this._bindGroup = null;
            }
        });
    }
    /** @internal */ _findTextureLayout(name) {
        for (const entry of this._layout.entries){
            if ((entry.texture || entry.storageTexture || entry.externalTexture) && entry.name === name) {
                return entry;
            }
        }
        return null;
    }
    /** @internal */ _findSamplerLayout(name) {
        for (const entry of this._layout.entries){
            if (entry.sampler && entry.name === name) {
                return entry;
            }
        }
        return null;
    }
    /** @internal */ _getBuffer(name, usage, nocreate = false) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.buffer && entry.name === bindName) {
                const bufferUsage = entry.buffer.type === 'uniform' ? GPUResourceUsageFlags.BF_UNIFORM : GPUResourceUsageFlags.BF_STORAGE;
                if (!(usage & bufferUsage)) {
                    return null;
                }
                let buffer = this._resources[entry.name];
                if (!buffer && !nocreate) {
                    const options = {
                        usage: bufferUsage === GPUResourceUsageFlags.BF_UNIFORM ? 'uniform' : null,
                        storage: bufferUsage === GPUResourceUsageFlags.BF_STORAGE,
                        dynamic: true
                    };
                    buffer = this._device.createStructuredBuffer(entry.type, options);
                    this._resources[entry.name] = buffer;
                }
                return buffer;
            }
        }
        return null;
    }
    /** @internal */ _create() {
        let bindGroup = null;
        this._textures = [];
        this._buffers = [];
        const entries = [];
        let resourceOk = true;
        for (const entry of this._layout.entries){
            const ge = {
                binding: entry.binding
            };
            if (entry.buffer) {
                const buffer = this._getBuffer(entry.name, entry.buffer.type === 'uniform' ? GPUResourceUsageFlags.BF_UNIFORM : GPUResourceUsageFlags.BF_STORAGE, true);
                if (!buffer) {
                    throw new Error(`Uniform buffer '${entry.name}' not exists, maybe you forgot settings some uniform values`);
                }
                if (this._buffers.indexOf(buffer) < 0) {
                    this._buffers.push(buffer);
                }
                ge.resource = {
                    buffer: buffer.object,
                    offset: 0,
                    size: buffer.byteLength
                };
                resourceOk = resourceOk && !!buffer.object;
            } else if (entry.texture || entry.storageTexture) {
                const t = this._resources[entry.name];
                if (!t) {
                    console.error(`Missing texture in bind group: ${entry.name}`);
                    resourceOk = false;
                } else {
                    if (this._textures.indexOf(t[0]) < 0) {
                        this._textures.push(t[0]);
                    }
                    ge.resource = t[1];
                    resourceOk = resourceOk && !!t[1];
                }
            } else if (entry.externalTexture) {
                const t = this._resources[entry.name];
                ge.resource = t.object;
                resourceOk = resourceOk && !!t.object;
            } else if (entry.sampler) {
                const sampler = this._resources[entry.name];
                ge.resource = sampler;
                resourceOk = resourceOk && !!sampler;
            }
            entries.push(ge);
        }
        if (!resourceOk) {
            return null;
        }
        const layout = this._device.fetchBindGroupLayout(this._layout);
        const descriptor = {
            layout,
            entries
        };
        if (layout.label) {
            descriptor.label = `${layout.label}.bindgroup`;
        }
        bindGroup = this._device.gpuCreateBindGroup(descriptor);
        if (!bindGroup) {
            console.log('Create bindgroup failed');
        }
        return bindGroup;
    }
}

const textureWrappingMap$1 = {
    repeat: 'repeat',
    'mirrored-repeat': 'mirror-repeat',
    clamp: 'clamp-to-edge'
};
const textureFilterMap = {
    nearest: 'nearest',
    linear: 'linear',
    none: undefined
};
const compareFuncMap$1 = {
    always: 'always',
    le: 'less-equal',
    ge: 'greater-equal',
    lt: 'less',
    gt: 'greater',
    eq: 'equal',
    ne: 'not-equal',
    never: 'never'
};
const stencilOpMap$1 = {
    keep: 'keep',
    replace: 'replace',
    zero: 'zero',
    invert: 'invert',
    incr: 'increment-clamp',
    decr: 'decrement-clamp',
    'incr-wrap': 'increment-wrap',
    'decr-wrap': 'decrement-wrap'
};
const primitiveTypeMap$1 = {
    'triangle-list': 'triangle-list',
    'triangle-strip': 'triangle-strip',
    'triangle-fan': null,
    'line-list': 'line-list',
    'line-strip': 'line-strip',
    'point-list': 'point-list'
};
const faceModeMap$1 = {
    back: 'back',
    front: 'front',
    none: 'none'
};
const blendEquationMap$1 = {
    add: 'add',
    subtract: 'subtract',
    'reverse-subtract': 'reverse-subtract',
    min: 'min',
    max: 'max'
};
const blendFuncMap$1 = {
    'const-color': 'constant',
    'const-alpha': 'constant',
    'dst-color': 'dst',
    'dst-alpha': 'dst-alpha',
    'inv-const-color': 'one-minus-constant',
    'inv-const-alpha': 'one-minus-constant',
    'inv-dst-color': 'one-minus-dst',
    'inv-dst-alpha': 'one-minus-dst-alpha',
    'src-color': 'src',
    'src-alpha': 'src-alpha',
    'inv-src-color': 'one-minus-src',
    'inv-src-alpha': 'one-minus-src-alpha',
    'src-alpha-saturate': 'src-alpha-saturated',
    one: 'one',
    zero: 'zero'
};
const vertexFormatToHash = {
    float32: '0',
    float32x2: '1',
    float32x3: '2',
    float32x4: '3',
    uint32: '4',
    uint32x2: '5',
    uint32x3: '6',
    uint32x4: '7',
    sint32: '8',
    sint32x2: '9',
    sint32x3: 'a',
    sint32x4: 'b',
    uint16x2: 'c',
    uint16x4: 'd',
    unorm16x2: 'e',
    unorm16x4: 'f',
    sint16x2: 'g',
    sint16x4: 'h',
    snorm16x2: 'i',
    snorm16x4: 'j',
    uint8x2: 'k',
    uint8x4: 'l',
    unorm8x2: 'm',
    unorm8x4: 'n',
    sint8x2: 'o',
    sint8x4: 'p',
    snorm8x2: 'q',
    snorm8x4: 'r'
};
const textureFormatMap = {
    ['unknown']: null,
    ['rgba8unorm']: 'rgba8unorm',
    ['rgba8snorm']: 'rgba8snorm',
    ['bgra8unorm']: 'bgra8unorm',
    ['dxt1']: 'bc1-rgba-unorm',
    ['dxt3']: 'bc2-rgba-unorm',
    ['dxt5']: 'bc3-rgba-unorm',
    ['dxt1-srgb']: 'bc1-rgba-unorm-srgb',
    ['dxt3-srgb']: 'bc2-rgba-unorm-srgb',
    ['dxt5-srgb']: 'bc3-rgba-unorm-srgb',
    ['r8unorm']: 'r8unorm',
    ['r8snorm']: 'r8snorm',
    ['r16f']: 'r16float',
    ['r32f']: 'r32float',
    ['r8ui']: 'r8uint',
    ['r8i']: 'r8sint',
    ['r16ui']: 'r16uint',
    ['r16i']: 'r16sint',
    ['r32ui']: 'r32uint',
    ['r32i']: 'r32sint',
    ['rg8unorm']: 'rg8unorm',
    ['rg8snorm']: 'rg8snorm',
    ['rg16f']: 'rg16float',
    ['rg32f']: 'rg32float',
    ['rg8ui']: 'rg8uint',
    ['rg8i']: 'rg8sint',
    ['rg16ui']: 'rg16uint',
    ['rg16i']: 'rg16sint',
    ['rg32ui']: 'rg32uint',
    ['rg32i']: 'rg32sint',
    ['rgba8unorm-srgb']: 'rgba8unorm-srgb',
    ['bgra8unorm-srgb']: 'bgra8unorm-srgb',
    ['rgba16f']: 'rgba16float',
    ['rgba32f']: 'rgba32float',
    ['rgba8ui']: 'rgba8uint',
    ['rgba8i']: 'rgba8sint',
    ['rgba16ui']: 'rgba16uint',
    ['rgba16i']: 'rgba16sint',
    ['rgba32ui']: 'rgba32uint',
    ['rgba32i']: 'rgba32sint',
    ['rg11b10uf']: 'rg11b10ufloat',
    ['d16']: 'depth16unorm',
    ['d24']: 'depth24plus',
    ['d32f']: 'depth32float',
    ['d32fs8']: 'depth32float-stencil8',
    ['d24s8']: 'depth24plus-stencil8'
};
function zip(keys, values) {
    const ret = {};
    const len = keys.length;
    for(let i = 0; i < len; i++){
        ret[keys[i]] = values[i];
    }
    return ret;
}
const textureFormatInvMap = zip(Object.values(textureFormatMap), Object.keys(textureFormatMap));
const hashToVertexFormat = zip(Object.values(vertexFormatToHash), Object.keys(vertexFormatToHash));

class WebGPUBaseTexture extends WebGPUObject {
    _target;
    _hash;
    _memCost;
    _views;
    _defaultView;
    _mipmapDirty;
    _flags;
    _width;
    _height;
    _depth;
    _format;
    _renderable;
    _fb;
    _gpuFormat;
    _mipLevelCount;
    _samplerOptions;
    _ringBuffer;
    _pendingUploads;
    constructor(device, target){
        super(device);
        this._target = target;
        this._flags = 0;
        this._width = 0;
        this._height = 0;
        this._depth = 0;
        this._renderable = false;
        this._fb = false;
        this._format = 'unknown';
        this._gpuFormat = null;
        this._mipLevelCount = 0;
        this._samplerOptions = null;
        this._memCost = 0;
        this._mipmapDirty = false;
        this._views = [];
        this._defaultView = null;
        this._ringBuffer = new UploadRingBuffer(device);
        this._pendingUploads = [];
    }
    get hash() {
        return this._object ? this._device.gpuGetObjectHash(this._object) : 0;
    }
    get target() {
        return this._target;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get depth() {
        return this._depth;
    }
    get format() {
        return this._format;
    }
    get mipLevelCount() {
        return this._mipLevelCount;
    }
    get gpuFormat() {
        return this._gpuFormat;
    }
    get samplerOptions() {
        return this._samplerOptions;
    }
    set samplerOptions(options) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._samplerOptions = options ? Object.assign({}, this._getSamplerOptions(params, !!options.compare), options) : null;
    }
    isTexture() {
        return true;
    }
    isFilterable() {
        if (!this.getTextureCaps().getTextureFormatInfo(this._format)?.filterable) {
            return false;
        }
        return true;
    }
    /** @internal */ getPendingUploads() {
        return this._pendingUploads;
    }
    /** @internal */ clearPendingUploads() {
        if (this._pendingUploads.length > 0) {
            this._pendingUploads = [];
            this.beginSyncChanges(null);
            this.endSyncChanges();
        }
    }
    isMipmapDirty() {
        return this._mipmapDirty;
    }
    setMipmapDirty(b) {
        this._mipmapDirty = b;
    }
    destroy() {
        if (this._object) {
            if (!this.isTextureVideo()) {
                this._object.destroy();
            }
            this._object = null;
            this._device.updateVideoMemoryCost(-this._memCost);
            this._memCost = 0;
        }
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.init();
        }
    }
    getTextureCaps() {
        return this._device.getDeviceCaps().textureCaps;
    }
    isSRGBFormat() {
        return isSRGBTextureFormat(this._format);
    }
    isFloatFormat() {
        return isFloatTextureFormat(this._format);
    }
    isIntegerFormat() {
        return isIntegerTextureFormat(this._format);
    }
    isSignedFormat() {
        return isSignedTextureFormat(this._format);
    }
    isCompressedFormat() {
        return isCompressedTextureFormat(this._format);
    }
    isDepth() {
        return hasDepthChannel(this._format);
    }
    isRenderable() {
        return this._renderable;
    }
    getView(level, face, mipCount) {
        level = Number(level) || 0;
        face = Number(face) || 0;
        mipCount = Number(mipCount) || 0;
        if (!this._views[face]) {
            this._views[face] = [];
        }
        if (!this._views[face][level]) {
            this._views[face][level] = [];
        }
        if (!this._views[face][level][mipCount]) {
            this._views[face][level][mipCount] = this.createView(level, face, mipCount);
        }
        return this._views[face][level][mipCount];
    }
    getDefaultView() {
        if (!this._defaultView && this._object && !this.isTextureVideo()) {
            this._defaultView = this._device.gpuCreateTextureView(this._object, {
                dimension: this.isTextureCube() ? 'cube' : this.isTexture3D() ? '3d' : this.isTexture2DArray() ? '2d-array' : '2d',
                arrayLayerCount: this.isTextureCube() ? 6 : this.isTexture2DArray() ? this._depth : 1,
                aspect: hasDepthChannel(this.format) ? 'depth-only' : 'all'
            });
        }
        return this._defaultView;
    }
    copyPixelDataToBuffer(x, y, w, h, layer, level, buffer) {
        if (this.isTextureVideo()) {
            throw new Error('copyPixelDataToBuffer() failed: can not copy pixel data of video texture');
        }
        this.sync();
        WebGPUBaseTexture.copyTexturePixelsToBuffer(this._device.device, this.object, this.width, this.height, this.format, x, y, w, h, layer, level, buffer);
    }
    generateMipmaps() {
        this._mipmapDirty = true;
    }
    beginSyncChanges(encoder) {
        if (!this.isTextureVideo() && this._pendingUploads.length > 0 && this._object) {
            const cmdEncoder = encoder || this._device.device.createCommandEncoder();
            for (const u of this._pendingUploads){
                if (u.mappedBuffer) {
                    const upload = u;
                    cmdEncoder.copyBufferToTexture({
                        buffer: upload.mappedBuffer.buffer,
                        offset: upload.mappedBuffer.offset,
                        bytesPerRow: upload.bufferStride,
                        rowsPerImage: upload.uploadHeight
                    }, {
                        texture: this._object,
                        origin: {
                            x: upload.uploadOffsetX,
                            y: upload.uploadOffsetY,
                            z: upload.uploadOffsetZ
                        },
                        mipLevel: upload.mipLevel
                    }, {
                        width: upload.uploadWidth,
                        height: upload.uploadHeight,
                        depthOrArrayLayers: upload.uploadDepth
                    });
                } else if (u.image) {
                    const upload = u;
                    // FIXME: copy image cannot be queued into the command buffer
                    const copyView = {
                        texture: this._object,
                        origin: {
                            x: upload.offsetX,
                            y: upload.offsetY,
                            z: upload.offsetZ
                        },
                        mipLevel: upload.mipLevel,
                        premultipliedAlpha: false
                    };
                    this._device.device.queue.copyExternalImageToTexture({
                        source: upload.image,
                        origin: {
                            x: upload.srcX,
                            y: upload.srcY
                        }
                    }, copyView, {
                        width: upload.width,
                        height: upload.height,
                        depthOrArrayLayers: upload.depth
                    });
                }
            }
            this._pendingUploads.length = 0;
            if (!encoder) {
                this._device.device.queue.submit([
                    cmdEncoder.finish()
                ]);
            }
            this._ringBuffer.beginUploads();
        }
    }
    endSyncChanges() {
        if (this._flags & GPUResourceUsageFlags.DYNAMIC) {
            this._ringBuffer.endUploads();
        } else {
            this._ringBuffer.purge();
        }
    }
    getDefaultSampler(shadow) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        return this._device.createSampler(!this._samplerOptions || !this._samplerOptions.compare !== !shadow ? this._getSamplerOptions(params, shadow) : this._samplerOptions);
    }
    /** @internal */ sync() {
        if (this._pendingUploads) {
            if (this._device.isTextureUploading(this)) {
                this._device.currentPass.end();
            } else {
                this.beginSyncChanges(null);
                this.endSyncChanges();
            }
        }
    }
    /** @internal */ _calcMipLevelCount(format, width, height, depth) {
        if (hasDepthChannel(format) || this.isTexture3D() || this.isTextureVideo()) {
            return 1;
        }
        if (this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) {
            return 1;
        }
        const params = this.getTextureCaps().getTextureFormatInfo(format);
        if (!params || !params.renderable) {
            return 1;
        }
        return Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    /** @internal */ allocInternal(format, width, height, depth, numMipLevels) {
        if (this.isTextureVideo()) {
            return;
        }
        if (numMipLevels === 0) {
            numMipLevels = this._calcMipLevelCount(format, width, height, depth);
        } else if (numMipLevels !== 1) {
            let size = Math.max(width, height);
            if (this.isTexture3D()) {
                size = Math.max(size, depth);
            }
            const autoMipLevelCount = Math.floor(Math.log2(size)) + 1; //this._calcMipLevelCount(format, width, height, depth);
            //const autoMipLevelCount = this._calcMipLevelCount(format, width, height, depth);
            if (!Number.isInteger(numMipLevels) || numMipLevels < 0 || numMipLevels > autoMipLevelCount) {
                numMipLevels = autoMipLevelCount;
            }
        }
        if (this._object && (this._format !== format || this._width !== width || this._height !== height || this._depth !== depth, this._mipLevelCount !== numMipLevels)) {
            const obj = this._object;
            this._device.runNextFrame(()=>{
                obj.destroy();
            });
            this._object = null;
        }
        if (!this._object) {
            this._format = format;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._mipLevelCount = numMipLevels;
            if (!this._device.isContextLost()) {
                this._gpuFormat = textureFormatMap[this._format];
                const params = this.getTextureCaps().getTextureFormatInfo(this._format);
                this._renderable = params.renderable && !(this._flags & GPUResourceUsageFlags.TF_WRITABLE);
                this._object = this._device.gpuCreateTexture({
                    size: {
                        width: this._width,
                        height: this._height,
                        depthOrArrayLayers: this.isTextureCube() ? 6 : this._depth
                    },
                    format: this._gpuFormat,
                    mipLevelCount: this._mipLevelCount,
                    sampleCount: 1,
                    dimension: this.isTexture3D() ? '3d' : '2d',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | (this._renderable && !this.isTexture3D() ? GPUTextureUsage.RENDER_ATTACHMENT : 0) | (this._flags & GPUResourceUsageFlags.TF_WRITABLE ? GPUTextureUsage.STORAGE_BINDING : 0)
                });
                const memCost = this.getTextureCaps().calcMemoryUsage(this._format, this._width * this._height * (this.isTextureCube() ? 6 : this._depth));
                this._device.updateVideoMemoryCost(memCost - this._memCost);
                this._memCost = memCost;
            }
        }
    }
    /** @internal */ static copyTexturePixelsToBuffer(device, texture, texWidth, texHeight, format, x, y, w, h, layer, level, buffer) {
        if (!(buffer.gpuUsage & GPUBufferUsage.COPY_DST)) {
            throw new Error('copyTexturePixelsToBuffer() failed: destination buffer does not have COPY_DST usage set');
        }
        const blockWidth = getTextureFormatBlockWidth(format);
        const blockHeight = getTextureFormatBlockHeight(format);
        const blockSize = getTextureFormatBlockSize(format);
        const blocksPerRow = texWidth / blockWidth;
        const blocksPerCol = texHeight / blockHeight;
        const rowStride = blocksPerRow * blockSize;
        const bufferStride = rowStride + 255 & ~255;
        const bufferSize = blocksPerCol * rowStride;
        const bufferSizeAligned = blocksPerCol * bufferStride;
        if (buffer.byteLength < bufferSize) {
            throw new Error(`copyTexturePixelsToBuffer() failed: destination buffer size is ${buffer.byteLength}, should be at least ${bufferSize}`);
        }
        const tmpBuffer = device.createBuffer({
            size: bufferSizeAligned,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        const encoder = device.createCommandEncoder();
        encoder.copyTextureToBuffer({
            texture: texture,
            mipLevel: level ?? 0,
            origin: {
                x: x,
                y: y,
                z: layer ?? 0
            }
        }, {
            buffer: tmpBuffer,
            offset: 0,
            bytesPerRow: bufferStride
        }, {
            width: w,
            height: h,
            depthOrArrayLayers: 1
        });
        if (bufferSize !== bufferSizeAligned) {
            for(let i = 0; i < blocksPerCol; i++){
                encoder.copyBufferToBuffer(tmpBuffer, i * bufferStride, buffer.object, i * rowStride, rowStride);
            }
        } else {
            encoder.copyBufferToBuffer(tmpBuffer, 0, buffer.object, 0, bufferSize);
        }
        device.queue.submit([
            encoder.finish()
        ]);
        tmpBuffer.destroy();
    }
    /** @internal */ uploadRaw(pixels, width, height, depth, offsetX, offsetY, offsetZ, miplevel) {
        const data = new Uint8Array(pixels.buffer, pixels.byteOffset, pixels.byteLength);
        const info = this.getTextureCaps().getTextureFormatInfo(this._format);
        const blockWidth = info.blockWidth || 1;
        const blockHeight = info.blockHeight || 1;
        const blocksPerRow = Math.ceil(width / blockWidth);
        const blocksPerCol = Math.ceil(height / blockHeight);
        const rowStride = blocksPerRow * info.size;
        if (rowStride * blocksPerCol * depth !== data.byteLength) {
            throw new Error(`WebGPUTexture.update() invalid data size: ${data.byteLength}`);
        }
        if (!this._device.isTextureUploading(this)) {
            this.clearPendingUploads();
            const destination = {
                texture: this._object,
                mipLevel: miplevel,
                origin: {
                    x: offsetX,
                    y: offsetY,
                    z: offsetZ
                }
            };
            const dataLayout = {
                bytesPerRow: rowStride,
                rowsPerImage: blockHeight * blocksPerCol
            };
            const size = {
                width: blockWidth * blocksPerRow,
                height: blockHeight * blocksPerCol,
                depthOrArrayLayers: depth
            };
            this._device.device.queue.writeTexture(destination, data, dataLayout, size);
        } else {
            const bufferStride = rowStride + 255 & ~255; // align to 256 bytes
            const uploadSize = bufferStride * blocksPerCol * depth;
            const upload = this._ringBuffer.uploadBuffer(null, null, 0, 0, uploadSize);
            const mappedRange = upload.mappedBuffer.mappedRange;
            const src = new Uint8Array(data);
            const dst = new Uint8Array(mappedRange, upload.mappedBuffer.offset, uploadSize);
            if (uploadSize === data.byteLength) {
                dst.set(new Uint8Array(data));
            } else {
                for(let d = 0; d < depth; d++){
                    const srcLayerOffset = d * rowStride * blocksPerRow;
                    const dstLayerOffset = d * bufferStride * blocksPerCol;
                    for(let i = 0; i < blocksPerCol; i++){
                        dst.set(src.subarray(srcLayerOffset + i * rowStride, srcLayerOffset + (i + 1) * rowStride), dstLayerOffset + i * bufferStride);
                    }
                }
            }
            this._pendingUploads.push({
                mappedBuffer: upload.mappedBuffer,
                uploadOffsetX: offsetX,
                uploadOffsetY: offsetY,
                uploadOffsetZ: offsetZ,
                uploadWidth: blockWidth * blocksPerRow,
                uploadHeight: blockHeight * blocksPerCol,
                uploadDepth: depth,
                bufferStride: bufferStride,
                mipLevel: miplevel
            });
        }
    }
    /** @internal */ uploadImageData(data, srcX, srcY, width, height, destX, destY, miplevel, layer) {
        {
            /*
      // can not use getImageData() because it is not accurate
      const tmpCanvas = document.createElement('canvas');
      let gl = tmpCanvas.getContext("webgl2");
      gl.activeTexture(gl.TEXTURE0);
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
      let pixels = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      this.uploadRaw(pixels, width, height, 1, offsetX, offsetY, faceIndex, miplevel);
      tmpCanvas.width = 0;
      tmpCanvas.height = 0;
      */ this._pendingUploads.push({
                image: data,
                offsetX: destX,
                offsetY: destY,
                offsetZ: layer ?? 0,
                srcX: srcX ?? 0,
                srcY: srcY ?? 0,
                srcZ: 0,
                width: width,
                height: height,
                depth: 1,
                mipLevel: miplevel ?? 0
            });
        }
    }
    /** @internal */ _getSamplerOptions(params, shadow) {
        const comparison = this.isDepth() && shadow;
        const filterable = params.filterable || comparison;
        const magFilter = filterable ? 'linear' : 'nearest';
        const minFilter = params.filterable ? 'linear' : 'nearest';
        const mipFilter = this._mipLevelCount > 1 ? filterable ? 'linear' : 'nearest' : 'none';
        return {
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter,
            minFilter,
            mipFilter,
            compare: comparison ? 'lt' : null
        };
    }
    /** @internal */ _markAsCurrentFB(b) {
        this._fb = b;
    }
    /** @internal */ _isMarkedAsCurrentFB() {
        return this._fb;
    }
}

class WebGPUTexture2D extends WebGPUBaseTexture {
    constructor(device){
        super(device, '2d');
    }
    isTexture2D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, 1, xOffset, yOffset, 0, 0);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, destX, destY, srcX, srcY, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        if (data instanceof HTMLCanvasElement || this._device.isTextureUploading(this)) {
            // Copy the pixel values out in case the canvas content may be changed later
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, srcX, srcY, width, height, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            this.update(imageData.data, destX, destY, width, height);
            cvs.width = 0;
            cvs.height = 0;
        } else {
            this.uploadImageData(data, srcX, srcY, width, height, destX, destY, 0, 0);
        }
    }
    async readPixels(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        if (faceOrLayer !== 0) {
            throw new Error(`Texture2D.readPixels(): parameter faceOrLayer must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = Math.ceil(w / blockWidth);
        const blocksPerCol = Math.ceil(h / blockHeight);
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, 0, mipLevel, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        if (faceOrLayer !== 0) {
            throw new Error(`Texture2D.readPixels(): parameter faceOrLayer must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, 0, mipLevel, buffer);
    }
    loadFromElement(element, sRGB, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        const format = sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm';
        this.loadImage(element, format);
    }
    createEmpty(format, width, height, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        this.loadEmpty(format, width, height, 0);
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            dimension: '2d',
            baseMipLevel: level ?? 0,
            mipLevelCount: mipCount || this._mipLevelCount - (level ?? 0),
            baseArrayLayer: 0,
            arrayLayerCount: 1
        }) : null;
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (data.isCubemap || data.isVolume) {
            console.error('loading 2d texture with mipmap data failed: data is not 2d texture');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error(new Error('webgl device does not support storage texture'));
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, width, height, numMipLevels) {
        this.allocInternal(format, width, height, 1, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    /** @internal */ loadLevels(levels, sRGB) {
        let format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        let swizzle = false;
        if (format === 'bgra8unorm') {
            format = 'rgba8unorm';
            swizzle = true;
        } else if (this._format === 'bgra8unorm-srgb') {
            format = 'rgba8unorm-srgb';
            swizzle = true;
        }
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let i = 0; i < levels.mipDatas[0].length; i++){
                if (swizzle) {
                    // convert bgra to rgba
                    for(let j = 0; j < levels.mipDatas[0][i].width * levels.mipDatas[0][i].height; j++){
                        const t = levels.mipDatas[0][i].data[j * 4];
                        levels.mipDatas[0][i].data[j * 4] = levels.mipDatas[0][i].data[j * 4 + 2];
                        levels.mipDatas[0][i].data[j * 4 + 2] = t;
                    }
                }
                this.uploadRaw(levels.mipDatas[0][i].data, levels.mipDatas[0][i].width, levels.mipDatas[0][i].height, 1, 0, 0, 0, i);
            }
        }
    }
    /** @internal */ loadImage(element, format) {
        this.allocInternal(format, Number(element.width), Number(element.height), 1, 0);
        if (!this._device.isContextLost()) {
            this.updateFromElement(element, 0, 0, 0, 0, this._width, this._height);
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
}

class WebGPUTexture2DArray extends WebGPUBaseTexture {
    constructor(device){
        super(device, '2darray');
    }
    isTexture2DArray() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, depth, xOffset, yOffset, zOffset, 0);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, destX, destY, destZ, srcX, srcY, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        if (data instanceof HTMLCanvasElement || this._device.isTextureUploading(this)) {
            // Copy the pixel values out in case the canvas content may be changed later
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, srcX, srcY, width, height, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            this.update(imageData.data, destX, destY, destZ, width, height, 1);
            cvs.width = 0;
            cvs.height = 0;
        } else {
            this.uploadImageData(data, srcX, srcY, width, height, destX, destY, 0, destZ);
        }
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        this.loadEmpty(format, width, height, depth, 0);
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            dimension: '2d',
            baseMipLevel: level ?? 0,
            mipLevelCount: mipCount || this._mipLevelCount - (level ?? 0),
            baseArrayLayer: face ?? 0,
            arrayLayerCount: 1
        }) : null;
    }
    async readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixels(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = Math.ceil(w / blockWidth);
        const blocksPerCol = Math.ceil(h / blockHeight);
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, layer, mipLevel, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, layer, mipLevel, buffer);
    }
    loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const depth = levels.arraySize;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, depth) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture2DArray.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, levels.arraySize, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let layer = 0; layer < levels.arraySize; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture2DArray.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    this.uploadRaw(levels.mipDatas[layer][i].data, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, 0, 0, layer, i);
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
}

class WebGPUTexture3D extends WebGPUBaseTexture {
    constructor(device){
        super(device, '3d');
    }
    isTexture3D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, depth, xOffset, yOffset, zOffset, 0);
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        this.loadEmpty(format, width, height, depth, 0);
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            dimension: '2d',
            baseMipLevel: 0,
            mipLevelCount: 1,
            baseArrayLayer: face,
            arrayLayerCount: 1
        }) : null;
    }
    async readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixels(): parameter mipLevel must be 0`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = this.width / blockWidth;
        const blocksPerCol = this.height / blockHeight;
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, layer, 0, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixelsToBuffer(): parameter mipLevel must be 0`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, layer, 0, buffer);
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const depth = levels.depth;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, depth) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture3D.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, depth, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let layer = 0; layer < depth; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture3D.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    this.uploadRaw(levels.mipDatas[layer][i].data, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, 0, 0, layer, i);
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
    loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
}

class WebGPUTextureCube extends WebGPUBaseTexture {
    constructor(device){
        super(device, 'cube');
    }
    init() {
        this.loadEmpty(this._format, this._width, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height, face) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        this.uploadRaw(data, width, height, 1, xOffset, yOffset, face, 0);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, destX, destY, face, srcX, srcY, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        if (data instanceof HTMLCanvasElement || this._device.isTextureUploading(this)) {
            // Copy the pixel values out in case the canvas content may be changed later
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, srcX, srcY, width, height, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            this.update(imageData.data, destX, destY, width, height, face);
            cvs.width = 0;
            cvs.height = 0;
        } else {
            this.uploadImageData(data, srcX, srcY, width, height, destX, destY, 0, face);
        }
    }
    createEmpty(format, size, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('storage texture can not be cube texture'));
        } else {
            this.loadEmpty(format, size, 0);
        }
    }
    isTextureCube() {
        return true;
    }
    createView(level, face, mipCount) {
        return this._object ? this._device.gpuCreateTextureView(this._object, {
            format: this._gpuFormat,
            dimension: '2d',
            baseMipLevel: level ?? 0,
            mipLevelCount: mipCount || this._mipLevelCount - (level ?? 0),
            baseArrayLayer: face ?? 0,
            arrayLayerCount: 1,
            aspect: 'all'
        }) : null;
    }
    async readPixels(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const blockWidth = getTextureFormatBlockWidth(this.format);
        const blockHeight = getTextureFormatBlockHeight(this.format);
        const blockSize = getTextureFormatBlockSize(this.format);
        const blocksPerRow = Math.ceil(w / blockWidth);
        const blocksPerCol = Math.ceil(h / blockHeight);
        const imageSize = blocksPerRow * blocksPerCol * blockSize;
        if (buffer.byteLength < imageSize) {
            throw new Error(`Texture2D.readPixels() failed: destination buffer size is ${buffer.byteLength}, should be at least ${imageSize}`);
        }
        const tmpBuffer = this._device.createBuffer(imageSize, {
            usage: 'read'
        });
        await this.copyPixelDataToBuffer(x, y, w, h, face, mipLevel, tmpBuffer);
        await tmpBuffer.getBufferSubData(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), 0, imageSize);
        tmpBuffer.dispose();
    }
    readPixelsToBuffer(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        this.copyPixelDataToBuffer(x, y, w, h, face, mipLevel, buffer);
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (!data.isCubemap) {
            console.error('loading cubmap with mipmap data failed: data is not cubemap');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('webgl device does not support storage texture');
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, size, mipLevelCount) {
        this.allocInternal(format, size, size, 1, mipLevelCount);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    /** @internal */ loadImages(images, format) {
        const width = images[0].width;
        const height = images[0].height;
        if (images.length !== 6) {
            console.error(new Error('cubemap face list must have 6 images'));
            return;
        }
        for(let i = 1; i < 6; i++){
            if (images[i].width !== width || images[i].height !== height) {
                console.error(new Error('cubemap face images must have identical sizes'));
                return;
            }
        }
        if (width === 0 || height === 0) {
            return;
        }
        this.allocInternal(format, width, height, 1, 0);
        if (!this._device.isContextLost()) {
            const w = this._width;
            const h = this._height;
            for(let face = 0; face < 6; face++){
                createImageBitmap(images[face], {
                    premultiplyAlpha: 'none'
                }).then((bmData)=>{
                    this.updateFromElement(bmData, 0, 0, face, 0, 0, w, h);
                });
            }
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
    /** @internal */ loadLevels(levels, sRGB) {
        const format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        const width = levels.width;
        const height = levels.height;
        //const mipLevelCount = levels.mipLevels;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, 1) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('TextureCube.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            for(let face = 0; face < 6; face++){
                if (levels.mipDatas[face].length !== levels.mipLevels) {
                    console.log(`TextureCube.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    this.uploadRaw(levels.mipDatas[face][i].data, levels.mipDatas[face][i].width, levels.mipDatas[face][i].height, 1, 0, 0, face, i);
                }
            }
        }
        if (levels.mipLevels !== this.mipLevelCount) {
            this.generateMipmaps();
        }
    }
}

class WebGPUTextureVideo extends WebGPUBaseTexture {
    _source;
    constructor(device, element){
        super(device, '2d');
        this._source = element;
        this._width = 0;
        this._height = 0;
        this.loadFromElement();
    }
    isTextureVideo() {
        return true;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get source() {
        return this._source;
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.loadElement(this._source);
        }
    }
    updateVideoFrame() {
        if (this._source.readyState > 2) {
            const videoFrame = new window.VideoFrame(this._source);
            videoFrame.close();
            this._object = this._device.gpuImportExternalTexture(this._source);
            return true;
        }
        return false;
    }
    createView(level, face, mipCount) {
        return null;
    }
    init() {
        this.loadFromElement();
    }
    readPixels(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixels()`);
    }
    readPixelsToBuffer(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixelsToBuffer()`);
    }
    /** @internal */ loadFromElement() {
        this.loadElement(this._source);
    }
    /** @internal */ loadElement(element) {
        this._format = 'rgba8unorm';
        this._width = element.videoWidth;
        this._height = element.videoHeight;
        this._depth = 1;
        this._mipLevelCount = 1;
        if (!this._device.isContextLost()) {
            if (element.readyState > 2) {
                this._object = this._device.gpuImportExternalTexture(element);
            }
        }
        return !!this._object;
    }
}

class WebGPUFramebufferCaps {
    maxDrawBuffers;
    maxColorAttachmentBytesPerSample;
    supportMultisampledFramebuffer;
    supportFloatBlending;
    supportDepth32float;
    supportDepth32floatStencil8;
    constructor(device){
        this.maxDrawBuffers = device.device.limits.maxColorAttachments;
        this.maxColorAttachmentBytesPerSample = device.device.limits.maxColorAttachmentBytesPerSample;
        this.supportMultisampledFramebuffer = true;
        this.supportFloatBlending = true;
        this.supportDepth32float = true;
        this.supportDepth32floatStencil8 = device.device.features.has('depth32float-stencil8');
    }
}
class WebGPUMiscCaps {
    supportOversizedViewport;
    supportBlendMinMax;
    support32BitIndex;
    supportDepthClamp;
    maxBindGroups;
    maxTexCoordIndex;
    constructor(device){
        this.supportOversizedViewport = false;
        this.supportBlendMinMax = true;
        this.support32BitIndex = true;
        this.supportDepthClamp = device.device.features.has('depth-clip-control');
        this.maxBindGroups = 4;
        this.maxTexCoordIndex = 8;
    }
}
class WebGPUShaderCaps {
    supportFragmentDepth;
    supportStandardDerivatives;
    supportShaderTextureLod;
    supportHighPrecisionFloat;
    supportHighPrecisionInt;
    maxUniformBufferSize;
    uniformBufferOffsetAlignment;
    constructor(device){
        this.supportFragmentDepth = true;
        this.supportStandardDerivatives = true;
        this.supportShaderTextureLod = true;
        this.supportHighPrecisionFloat = true;
        this.maxUniformBufferSize = device.device.limits.maxUniformBufferBindingSize || 65536;
        this.uniformBufferOffsetAlignment = device.device.limits.minUniformBufferOffsetAlignment || 256;
    }
}
class WebGPUTextureCaps {
    _textureFormatInfos;
    maxTextureSize;
    maxCubeTextureSize;
    npo2Mipmapping;
    npo2Repeating;
    supportS3TC;
    supportS3TCSRGB;
    supportDepthTexture;
    support3DTexture;
    supportSRGBTexture;
    supportFloatTexture;
    supportLinearFloatTexture;
    supportHalfFloatTexture;
    supportLinearHalfFloatTexture;
    supportAnisotropicFiltering;
    supportFloatColorBuffer;
    supportHalfFloatColorBuffer;
    supportFloatBlending;
    constructor(device){
        this.supportAnisotropicFiltering = true;
        this.supportDepthTexture = true;
        this.support3DTexture = true;
        this.supportSRGBTexture = true;
        this.supportFloatTexture = true;
        this.supportFloatColorBuffer = true;
        this.supportHalfFloatColorBuffer = true;
        this.supportFloatBlending = true;
        this.supportS3TC = device.device.features.has('texture-compression-bc');
        this.supportS3TCSRGB = this.supportS3TC;
        this.supportHalfFloatTexture = true;
        this.maxTextureSize = device.device.limits.maxTextureDimension2D;
        this.maxCubeTextureSize = device.device.limits.maxTextureDimension2D;
        this.npo2Mipmapping = true;
        this.npo2Repeating = true;
        this._textureFormatInfos = {
            ['rgba8unorm']: {
                gpuSampleType: 'float',
                filterable: true,
                renderable: true,
                compressed: false,
                writable: true,
                size: 4
            },
            ['rgba8snorm']: {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: false,
                writable: true,
                size: 4
            },
            ['bgra8unorm']: {
                gpuSampleType: 'float',
                filterable: true,
                renderable: true,
                compressed: false,
                writable: false,
                size: 4
            }
        };
        if (this.supportS3TC) {
            this._textureFormatInfos['dxt1'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 8,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt3'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt5'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
        }
        if (this.supportS3TCSRGB) {
            this._textureFormatInfos['dxt1-srgb'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 8,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt3-srgb'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
            this._textureFormatInfos['dxt5-srgb'] = {
                gpuSampleType: 'float',
                filterable: true,
                renderable: false,
                compressed: true,
                size: 16,
                writable: false,
                blockWidth: 4,
                blockHeight: 4
            };
        }
        this._textureFormatInfos['r8unorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 1
        };
        this._textureFormatInfos['r8snorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: false,
            compressed: false,
            writable: false,
            size: 1
        }, this._textureFormatInfos['r16f'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['r32f'] = {
            gpuSampleType: 'unfilterable-float',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['r8ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 1
        };
        this._textureFormatInfos['r8i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 1
        };
        this._textureFormatInfos['r16ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['r16i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['r32ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['r32i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['rg8unorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg8snorm'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: false,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg16f'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rg32f'] = {
            gpuSampleType: 'unfilterable-float',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rg8ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg8i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['rg16ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rg16i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rg32ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rg32i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba8unorm-srgb'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['bgra8unorm-srgb'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['rgba16f'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba32f'] = {
            gpuSampleType: 'unfilterable-float',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 16
        };
        this._textureFormatInfos['rgba8ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['rgba8i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 4
        };
        this._textureFormatInfos['rgba16ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba16i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 8
        };
        this._textureFormatInfos['rgba32ui'] = {
            gpuSampleType: 'uint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 16
        };
        this._textureFormatInfos['rgba32i'] = {
            gpuSampleType: 'sint',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: true,
            size: 16
        };
        this._textureFormatInfos['rg11b10uf'] = {
            gpuSampleType: 'float',
            filterable: true,
            renderable: device.device.features.has('rg11b10ufloat-renderable'),
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['d16'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 2
        };
        this._textureFormatInfos['d24'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['d32f'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this._textureFormatInfos['d32fs8'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 8
        };
        this._textureFormatInfos['d24s8'] = {
            gpuSampleType: 'depth',
            filterable: false,
            renderable: true,
            compressed: false,
            writable: false,
            size: 4
        };
        this.supportLinearFloatTexture = this._textureFormatInfos['r32f'].filterable && this._textureFormatInfos['rg32f'].filterable && this._textureFormatInfos['rgba32f'].filterable;
        this.supportLinearHalfFloatTexture = this._textureFormatInfos['r16f'].filterable && this._textureFormatInfos['rg16f'].filterable && this._textureFormatInfos['rgba16f'].filterable;
    }
    calcMemoryUsage(format, numPixels) {
        return this._textureFormatInfos[format] ? this._textureFormatInfos[format].size * numPixels : 0;
    }
    getTextureFormatInfo(format) {
        return this._textureFormatInfos[format];
    }
}

class WebGPUVertexLayout extends WebGPUObject {
    static _hashCounter = 0;
    _vertexData;
    _hash;
    _layouts;
    constructor(device, options){
        super(device);
        this._vertexData = new VertexData();
        for (const vb of options.vertexBuffers){
            this._vertexData.setVertexBuffer(vb.buffer, vb.stepMode);
        }
        if (options.indexBuffer) {
            this._vertexData.setIndexBuffer(options.indexBuffer);
        }
        this._hash = String(++WebGPUVertexLayout._hashCounter);
        this._layouts = {};
    }
    destroy() {
        this._object = null;
    }
    async restore() {
        this._object = {};
    }
    setDrawOffset(buffer, byteOffset) {
        for (const info of this._vertexData.vertexBuffers){
            if (info?.buffer === buffer) {
                info.drawOffset = byteOffset;
            }
        }
    }
    get hash() {
        return this._hash;
    }
    get vertexBuffers() {
        return this._vertexData.vertexBuffers;
    }
    get indexBuffer() {
        return this._vertexData.indexBuffer;
    }
    getDrawOffset() {
        return this._vertexData.getDrawOffset();
    }
    getVertexBuffer(semantic) {
        return this._vertexData.getVertexBuffer(semantic);
    }
    getVertexBufferInfo(semantic) {
        return this._vertexData.getVertexBufferInfo(semantic);
    }
    getIndexBuffer() {
        return this._vertexData.getIndexBuffer();
    }
    getLayouts(attributes) {
        if (!attributes) {
            return null;
        }
        let layout = this._layouts[attributes];
        if (!layout) {
            layout = this.calcHash(attributes);
            this._layouts[attributes] = layout;
        }
        return layout;
    }
    calcHash(attribHash) {
        const layouts = [];
        const layoutVertexBuffers = [];
        const vertexBuffers = this._vertexData.vertexBuffers;
        const attributes = attribHash.split(':').map((val)=>Number(val));
        for(let idx = 0; idx < attributes.length; idx++){
            const attrib = attributes[idx];
            const bufferInfo = vertexBuffers[attrib];
            const buffer = bufferInfo?.buffer;
            if (!buffer) {
                console.log(`ERROR: No vertex buffer set for location ${idx}`);
                continue;
            }
            const gpuFormat = WebGPUStructuredBuffer.getGPUVertexFormat(bufferInfo.type);
            if (!gpuFormat) {
                throw new Error('Invalid vertex buffer format');
            }
            const index = layoutVertexBuffers.findIndex((val)=>val.buffer === buffer);
            const stride = bufferInfo.stride;
            let layout = index >= 0 ? layouts[index] : `${stride}-${Number(bufferInfo.stepMode === 'instance')}`;
            layout += `-${vertexFormatToHash[gpuFormat]}-${bufferInfo.offset}-${idx}`;
            if (index >= 0) {
                layouts[index] = layout;
            } else {
                layouts.push(layout);
                layoutVertexBuffers.push(bufferInfo);
            }
        }
        return {
            layoutHash: layouts.join(':'),
            buffers: layoutVertexBuffers
        };
    }
    bind() {
        this._device.setVertexLayout(this);
    }
    draw(primitiveType, first, count) {
        this.bind();
        this._device.draw(primitiveType, first, count);
    }
    drawInstanced(primitiveType, first, count, numInstances) {
        this.bind();
        this._device.drawInstanced(primitiveType, first, count, numInstances);
    }
}

class WebGPURenderState {
    static _defaultState;
    _hash;
    static get defaultState() {
        return this._defaultState;
    }
    constructor(){
        this._hash = null;
    }
    get hash() {
        return this._getHash(this.constructor);
    }
    invalidateHash() {
        this._hash = null;
    }
    _getHash(ctor) {
        if (this === ctor.defaultState) {
            return '';
        } else {
            if (this._hash === null) {
                this._hash = this.computeHash();
            }
            return this._hash;
        }
    }
}
class WebGPUColorState extends WebGPURenderState {
    static _defaultState = new WebGPUColorState();
    _redMask;
    _greenMask;
    _blueMask;
    _alphaMask;
    constructor(){
        super();
        this._redMask = this._greenMask = this._blueMask = this._alphaMask = true;
    }
    clone() {
        return new WebGPUColorState().setColorMask(this._redMask, this._greenMask, this._blueMask, this._alphaMask);
    }
    get redMask() {
        return this._redMask;
    }
    set redMask(val) {
        if (this._redMask !== !!val) {
            this._redMask = !!val;
            this.invalidateHash();
        }
    }
    get greenMask() {
        return this._greenMask;
    }
    set greenMask(val) {
        if (this._greenMask !== !!val) {
            this._greenMask = !!val;
            this.invalidateHash();
        }
    }
    get blueMask() {
        return this._blueMask;
    }
    set blueMask(val) {
        if (this._blueMask !== !!val) {
            this._blueMask = !!val;
            this.invalidateHash();
        }
    }
    get alphaMask() {
        return this._alphaMask;
    }
    set alphaMask(val) {
        if (this._alphaMask !== !!val) {
            this._alphaMask = !!val;
            this.invalidateHash();
        }
    }
    setColorMask(r, g, b, a) {
        this.redMask = r;
        this.greenMask = g;
        this.blueMask = b;
        this.alphaMask = a;
        return this;
    }
    computeHash() {
        let val = 0;
        if (this.redMask) {
            val += 1 << 0;
        }
        if (this.greenMask) {
            val += 1 << 1;
        }
        if (this.blueMask) {
            val += 1 << 2;
        }
        if (this.alphaMask) {
            val += 1 << 3;
        }
        return String(val);
    }
}
class WebGPUBlendingState extends WebGPURenderState {
    static _defaultState = new WebGPUBlendingState();
    _enabled;
    _alphaToCoverageEnabled;
    _srcBlendRGB;
    _dstBlendRGB;
    _srcBlendAlpha;
    _dstBlendAlpha;
    _rgbEquation;
    _alphaEquation;
    constructor(){
        super();
        this._enabled = false;
        this._alphaToCoverageEnabled = false;
        this._srcBlendRGB = 'one';
        this._dstBlendRGB = 'zero';
        this._srcBlendAlpha = 'one';
        this._dstBlendAlpha = 'zero';
        this._rgbEquation = 'add';
        this._alphaEquation = 'add';
    }
    clone() {
        const other = new WebGPUBlendingState();
        other.enable(this._enabled);
        other.enableAlphaToCoverage(this._alphaToCoverageEnabled);
        other.setBlendFuncRGB(this._srcBlendRGB, this._dstBlendRGB);
        other.setBlendFuncAlpha(this._srcBlendAlpha, this._dstBlendAlpha);
        other.setBlendEquation(this._rgbEquation, this._alphaEquation);
        return other;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(val) {
        if (this._enabled !== !!val) {
            this._enabled = !!val;
            this.invalidateHash();
        }
    }
    get alphaToCoverageEnabled() {
        return this._alphaToCoverageEnabled;
    }
    set alphaToCoverageEnabled(val) {
        if (this._alphaToCoverageEnabled !== !!val) {
            this._alphaToCoverageEnabled = !!val;
            this.invalidateHash();
        }
    }
    get srcBlendRGB() {
        return this._srcBlendRGB;
    }
    set srcBlendRGB(val) {
        if (this._srcBlendRGB !== val) {
            this._srcBlendRGB = val;
            this.invalidateHash();
        }
    }
    get srcBlendAlpha() {
        return this._srcBlendAlpha;
    }
    set srcBlendAlpha(val) {
        if (this._srcBlendAlpha !== val) {
            this._srcBlendAlpha = val;
            this.invalidateHash();
        }
    }
    get dstBlendRGB() {
        return this._dstBlendRGB;
    }
    set dstBlendRGB(val) {
        if (this._dstBlendRGB !== val) {
            this._dstBlendRGB = val;
            this.invalidateHash();
        }
    }
    get dstBlendAlpha() {
        return this._dstBlendAlpha;
    }
    set dstBlendAlpha(val) {
        if (this._dstBlendAlpha !== val) {
            this._dstBlendAlpha = val;
            this.invalidateHash();
        }
    }
    get rgbEquation() {
        return this._rgbEquation;
    }
    set rgbEquation(val) {
        if (this._rgbEquation !== val) {
            this._rgbEquation = val;
            this.invalidateHash();
        }
    }
    get alphaEquation() {
        return this._alphaEquation;
    }
    set alphaEquation(val) {
        if (this._alphaEquation !== val) {
            this._alphaEquation = val;
            this.invalidateHash();
        }
    }
    enable(b) {
        this.enabled = b;
        return this;
    }
    enableAlphaToCoverage(b) {
        this.alphaToCoverageEnabled = b;
        return this;
    }
    setBlendFunc(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendFuncRGB(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        return this;
    }
    setBlendFuncAlpha(src, dest) {
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendEquation(rgb, alpha) {
        this.rgbEquation = rgb;
        this.alphaEquation = alpha;
        return this;
    }
    computeHash() {
        return this._enabled ? `${this._srcBlendRGB}-${this._srcBlendAlpha}-${this._dstBlendRGB}-${this._dstBlendAlpha}-${this._rgbEquation}-${this._alphaEquation}-${Number(!!this._alphaToCoverageEnabled)}` : `${Number(!!this._alphaToCoverageEnabled)}`;
    }
}
class WebGPURasterizerState extends WebGPURenderState {
    static _defaultState = new WebGPURasterizerState();
    _cullMode;
    _depthClampEnabled;
    constructor(){
        super();
        this._cullMode = 'back';
        this._depthClampEnabled = false;
    }
    clone() {
        return new WebGPURasterizerState().setCullMode(this._cullMode).enableDepthClamp(this._depthClampEnabled);
    }
    get cullMode() {
        return this._cullMode;
    }
    set cullMode(val) {
        if (this._cullMode !== val) {
            this._cullMode = val;
            this.invalidateHash();
        }
    }
    setCullMode(mode) {
        this.cullMode = mode;
        return this;
    }
    get depthClampEnabled() {
        return this._depthClampEnabled;
    }
    set depthClampEnabled(val) {
        this.enableDepthClamp(val);
    }
    enableDepthClamp(enable) {
        if (this._depthClampEnabled !== !!enable) {
            this._depthClampEnabled = !!enable;
            this.invalidateHash();
        }
        return this;
    }
    computeHash() {
        return `${this._cullMode}-${this._depthClampEnabled ? 1 : 0}`;
    }
}
class WebGPUDepthState extends WebGPURenderState {
    static _defaultState = new WebGPUDepthState();
    _testEnabled;
    _writeEnabled;
    _compareFunc;
    constructor(){
        super();
        this._testEnabled = true;
        this._writeEnabled = true;
        this._compareFunc = 'le';
    }
    clone() {
        const other = new WebGPUDepthState();
        other.enableTest(this._testEnabled);
        other.enableWrite(this._writeEnabled);
        other.setCompareFunc(this._compareFunc);
        return other;
    }
    get testEnabled() {
        return this._testEnabled;
    }
    set testEnabled(val) {
        if (this._testEnabled !== !!val) {
            this._testEnabled = val;
            this.invalidateHash();
        }
    }
    get writeEnabled() {
        return this._writeEnabled;
    }
    set writeEnabled(val) {
        if (this._writeEnabled !== !!val) {
            this._writeEnabled = val;
            this.invalidateHash();
        }
    }
    get compareFunc() {
        return this._compareFunc;
    }
    set compareFunc(val) {
        if (this._compareFunc !== val) {
            this._compareFunc = val;
            this.invalidateHash();
        }
    }
    enableTest(b) {
        this.testEnabled = b;
        return this;
    }
    enableWrite(b) {
        this.writeEnabled = b;
        return this;
    }
    setCompareFunc(func) {
        this.compareFunc = func;
        return this;
    }
    computeHash() {
        return `${Number(this._testEnabled)}-${Number(this._writeEnabled)}-${this.compareFunc}}`;
    }
}
class WebGPUStencilState extends WebGPURenderState {
    static _defaultState = new WebGPUStencilState();
    _enabled;
    _writeMask;
    _failOp;
    _failOpBack;
    _zFailOp;
    _zFailOpBack;
    _passOp;
    _passOpBack;
    _func;
    _funcBack;
    _ref;
    _readMask;
    constructor(){
        super();
        this._enabled = false;
        this._failOp = this.failOpBack = 'keep';
        this._zFailOp = this.zFailOpBack = 'keep';
        this._passOp = this.passOpBack = 'keep';
        this._func = this.funcBack = 'always';
        this._ref = 0;
        this._writeMask = 0xffffffff;
        this._readMask = 0xffffffff;
    }
    clone() {
        const other = new WebGPUStencilState();
        other.enable(this._enabled);
        other.setWriteMask(this._writeMask);
        other.setFrontOp(this._failOp, this._zFailOp, this._passOp);
        other.setBackOp(this._failOpBack, this._zFailOpBack, this._passOpBack);
        other.setFrontCompareFunc(this._func);
        other.setBackCompareFunc(this._funcBack);
        other.setReference(this._ref);
        other.setReadMask(this._readMask);
        return other;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(val) {
        if (this._enabled !== !!val) {
            this._enabled = !!val;
            this.invalidateHash();
        }
    }
    get writeMask() {
        return this._writeMask;
    }
    set writeMask(val) {
        if (this._writeMask !== val) {
            this._writeMask = val;
            this.invalidateHash();
        }
    }
    get failOp() {
        return this._failOp;
    }
    set failOp(val) {
        if (this._failOp !== val) {
            this._failOp = val;
            this.invalidateHash();
        }
    }
    get failOpBack() {
        return this._failOpBack;
    }
    set failOpBack(val) {
        if (this._failOpBack !== val) {
            this._failOpBack = val;
            this.invalidateHash();
        }
    }
    get zFailOp() {
        return this._zFailOp;
    }
    set zFailOp(val) {
        if (this._zFailOp !== val) {
            this._zFailOp = val;
            this.invalidateHash();
        }
    }
    get zFailOpBack() {
        return this._zFailOpBack;
    }
    set zFailOpBack(val) {
        if (this._zFailOpBack !== val) {
            this._zFailOpBack = val;
            this.invalidateHash();
        }
    }
    get passOp() {
        return this._passOp;
    }
    set passOp(val) {
        if (this._passOp !== val) {
            this._passOp = val;
            this.invalidateHash();
        }
    }
    get passOpBack() {
        return this._passOpBack;
    }
    set passOpBack(val) {
        if (this._passOpBack !== val) {
            this._passOpBack = val;
            this.invalidateHash();
        }
    }
    get func() {
        return this._func;
    }
    set func(val) {
        if (this._func !== val) {
            this._func = val;
            this.invalidateHash();
        }
    }
    get funcBack() {
        return this._funcBack;
    }
    set funcBack(val) {
        if (this._funcBack !== val) {
            this._funcBack = val;
            this.invalidateHash();
        }
    }
    get ref() {
        return this._ref;
    }
    set ref(val) {
        if (this._ref !== val) {
            this._ref = val;
            this.invalidateHash();
        }
    }
    get readMask() {
        return this._readMask;
    }
    set readMask(val) {
        if (this._readMask !== val) {
            this._readMask = val;
            this.invalidateHash();
        }
    }
    enable(b) {
        this.enabled = b;
        return this;
    }
    setWriteMask(mask) {
        this.writeMask = mask;
        return this;
    }
    setFrontOp(fail, zfail, pass) {
        this.failOp = fail;
        this.zFailOp = zfail;
        this.passOp = pass;
        return this;
    }
    setBackOp(fail, zfail, pass) {
        this.failOpBack = fail;
        this.zFailOpBack = zfail;
        this.passOpBack = pass;
        return this;
    }
    setFrontCompareFunc(func) {
        this.func = func;
        return this;
    }
    setBackCompareFunc(func) {
        this.funcBack = func;
        return this;
    }
    setReference(ref) {
        this.ref = ref;
        return this;
    }
    setReadMask(mask) {
        this.readMask = mask;
        return this;
    }
    computeHash() {
        return this._enabled ? `${this.sideHash(false)}-${this.sideHash(true)}-${this.readMask.toString(16)}-${this.writeMask.toString(16)}-${this.ref.toString(16)}` : '';
    }
    sideHash(back) {
        return back ? `${this._failOpBack}-${this._zFailOpBack}-${this._passOpBack}-${this._funcBack}` : `${this._failOp}-${this._zFailOp}-${this._passOp}-${this._func}`;
    }
}
class WebGPURenderStateSet {
    _device;
    colorState;
    blendingState;
    rasterizerState;
    depthState;
    stencilState;
    constructor(device){
        this._device = device;
        this.colorState = null;
        this.blendingState = null;
        this.rasterizerState = null;
        this.depthState = null;
        this.stencilState = null;
    }
    copyFrom(stateSet) {
        this.colorState = stateSet.colorState;
        this.blendingState = stateSet.blendingState;
        this.rasterizerState = stateSet.rasterizerState;
        this.depthState = stateSet.depthState;
        this.stencilState = stateSet.stencilState;
    }
    get hash() {
        return `${this.colorState?.hash || ''}:${this.blendingState?.hash || ''}:${this.rasterizerState?.hash || ''}:${this.depthState?.hash || ''}:${this.stencilState?.hash || ''}`;
    }
    useColorState(state) {
        return this.colorState = state ?? this.colorState ?? new WebGPUColorState();
    }
    defaultColorState() {
        this.colorState = null;
    }
    useBlendingState(state) {
        return this.blendingState = state ?? this.blendingState ?? new WebGPUBlendingState();
    }
    defaultBlendingState() {
        this.blendingState = null;
    }
    useRasterizerState(state) {
        return this.rasterizerState = state ?? this.rasterizerState ?? new WebGPURasterizerState();
    }
    defaultRasterizerState() {
        this.rasterizerState = null;
    }
    useDepthState(state) {
        return this.depthState = state ?? this.depthState ?? new WebGPUDepthState();
    }
    defaultDepthState() {
        this.depthState = null;
    }
    useStencilState(state) {
        return this.stencilState = state ?? this.stencilState ?? new WebGPUStencilState();
    }
    defaultStencilState() {
        this.stencilState = null;
    }
    apply(force) {
        this._device.setRenderStates(this);
    }
}

const typeU16$4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const stencilFormats = [
    'stencil8',
    'depth24plus-stencil8',
    'depth24unorm-stencil8',
    'depth32float-stencil8'
];
const depthFormats = [
    'depth16unorm',
    'depth24plus',
    'depth24plus-stencil8',
    'depth32float',
    'depth24unorm-stencil8',
    'depth32float-stencil8'
];
class PipelineCache {
    _device;
    _renderPipelines;
    _computePipelines;
    constructor(device){
        this._device = device;
        this._renderPipelines = {};
        this._computePipelines = {};
    }
    wipeCache() {
        this._renderPipelines = {};
        this._computePipelines = {};
    }
    fetchComputePipeline(program) {
        const hash = this.getComputePipelineHash(program);
        let pipeline = this._computePipelines[hash];
        if (pipeline === undefined) {
            const shaderModule = program.getShaderModule();
            const desc = {
                layout: shaderModule.pipelineLayout,
                compute: {
                    module: shaderModule.csModule,
                    entryPoint: 'main'
                }
            };
            pipeline = this._device.gpuCreateComputePipeline(desc);
            this._computePipelines[hash] = pipeline;
        }
        return pipeline;
    }
    fetchRenderPipeline(program, vertexData, stateSet, primitiveType, frameBufferInfo) {
        if (!frameBufferInfo.hash) {
            return null;
        }
        if (!program.vertexAttributes) {
            // no vertex data needed for this pipeline
            vertexData = null;
        }
        const hash = this.getRenderPipelineHash(frameBufferInfo.hash, program, vertexData, stateSet, primitiveType);
        let pipeline = this._renderPipelines[hash];
        if (pipeline === undefined) {
            const bufferLayouts = vertexData ? this._device.fetchVertexLayout(vertexData.getLayouts(program.vertexAttributes).layoutHash) : null;
            const shaderModule = program.getShaderModule();
            const vertex = {
                module: shaderModule.vsModule,
                entryPoint: 'main'
            };
            if (bufferLayouts) {
                vertex.buffers = bufferLayouts;
            }
            const primitiveState = this.createPrimitiveState(vertexData, stateSet, primitiveType);
            const depthStencilState = this.createDepthStencilState(frameBufferInfo.depthFormat, stateSet);
            const colorTargetStates = frameBufferInfo.colorFormats.map((val)=>this.createColorTargetState(stateSet, val));
            const desc = {
                label: hash,
                layout: shaderModule.pipelineLayout,
                vertex,
                primitive: primitiveState,
                depthStencil: depthStencilState,
                multisample: this.createMultisampleState(frameBufferInfo.sampleCount, stateSet),
                fragment: {
                    module: shaderModule.fsModule,
                    entryPoint: 'main',
                    targets: colorTargetStates
                }
            };
            pipeline = this._device.gpuCreateRenderPipeline(desc);
            this._renderPipelines[hash] = pipeline;
        }
        return pipeline;
    }
    createPrimitiveState(vertexData, stateSet, primitiveType) {
        const topology = primitiveTypeMap$1[primitiveType];
        if (!topology) {
            throw new Error(`createPrimitiveState() failed: invalid primitive type: ${primitiveType}`);
        }
        const rasterizerState = stateSet?.rasterizerState || WebGPURasterizerState.defaultState;
        const cullMode = faceModeMap$1[rasterizerState.cullMode];
        if (!cullMode) {
            throw new Error(`createPrimitiveState() failed: invalid cull mode: ${rasterizerState.cullMode}`);
        }
        const frontFace = this._device.isWindingOrderReversed() ? 'cw' : 'ccw';
        const state = {
            topology,
            frontFace,
            cullMode
        };
        if (this._device.device.features.has('depth-clip-control')) {
            state.unclippedDepth = rasterizerState.depthClampEnabled;
        }
        if (topology === 'triangle-strip' || topology === 'line-strip') {
            state.stripIndexFormat = vertexData?.getIndexBuffer()?.indexType === typeU16$4 ? 'uint16' : 'uint32';
        }
        return state;
    }
    createMultisampleState(sampleCount, stateSet) {
        return {
            count: sampleCount,
            alphaToCoverageEnabled: sampleCount > 1 && (stateSet?.blendingState ?? WebGPUBlendingState.defaultState).alphaToCoverageEnabled
        };
    }
    createDepthStencilState(depthFormat, stateSet) {
        if (!depthFormat) {
            return undefined;
        }
        const depthState = stateSet?.depthState || WebGPUDepthState.defaultState;
        const stencilState = stateSet?.stencilState || WebGPUStencilState.defaultState;
        const hasStencil = stencilFormats.indexOf(depthFormat) >= 0;
        const hasDepth = depthFormats.indexOf(depthFormat) >= 0;
        const depthWriteEnabled = hasDepth ? depthState.writeEnabled : false;
        const depthCompare = hasDepth && depthState.testEnabled ? compareFuncMap$1[depthState.compareFunc] : 'always';
        const state = {
            format: depthFormat,
            depthWriteEnabled,
            depthCompare
        };
        if (hasStencil) {
            const stencilFront = stencilState.enabled ? this.createStencilFaceState(stencilState.func, stencilState.failOp, stencilState.zFailOp, stencilState.passOp) : undefined;
            const stencilBack = stencilState.enabled ? this.createStencilFaceState(stencilState.funcBack, stencilState.failOpBack, stencilState.zFailOpBack, stencilState.passOpBack) : undefined;
            const stencilReadMask = stencilState.enabled ? stencilState.readMask : undefined;
            const stencilWriteMask = stencilState.enabled ? stencilState.writeMask : undefined;
            state.stencilFront = stencilFront;
            state.stencilBack = stencilBack;
            state.stencilReadMask = stencilReadMask;
            state.stencilWriteMask = stencilWriteMask;
        }
        return state;
    }
    createStencilFaceState(func, failOp, zFailOp, passOp) {
        return {
            compare: compareFuncMap$1[func],
            failOp: stencilOpMap$1[failOp],
            depthFailOp: stencilOpMap$1[zFailOp],
            passOp: stencilOpMap$1[passOp]
        };
    }
    createColorTargetState(stateSet, format) {
        const blendingState = stateSet?.blendingState || WebGPUBlendingState.defaultState;
        const colorState = stateSet?.colorState || WebGPUColorState.defaultState;
        const r = colorState.redMask ? GPUColorWrite.RED : 0;
        const g = colorState.greenMask ? GPUColorWrite.GREEN : 0;
        const b = colorState.blueMask ? GPUColorWrite.BLUE : 0;
        const a = colorState.alphaMask ? GPUColorWrite.ALPHA : 0;
        const state = {
            format: format,
            writeMask: r | g | b | a
        };
        if (blendingState.enabled) {
            state.blend = this.createBlendState(blendingState);
        }
        return state;
    }
    createBlendState(blendingState) {
        return {
            color: this.createBlendComponent(blendingState.rgbEquation, blendingState.srcBlendRGB, blendingState.dstBlendRGB),
            alpha: this.createBlendComponent(blendingState.alphaEquation, blendingState.srcBlendAlpha, blendingState.dstBlendAlpha)
        };
    }
    createBlendComponent(op, srcFunc, dstFunc) {
        const operation = blendEquationMap$1[op];
        if (!operation) {
            throw new Error(`createBlendComponent() failed: invalid blend op: ${op}`);
        }
        const srcFactor = blendFuncMap$1[srcFunc];
        if (!srcFactor) {
            throw new Error(`createBlendComponent() failed: invalid source blend func ${srcFunc}`);
        }
        const dstFactor = blendFuncMap$1[dstFunc];
        if (!dstFactor) {
            throw new Error(`createBlendComponent() failed: invalid dest blend func ${dstFunc}`);
        }
        return {
            operation,
            srcFactor,
            dstFactor
        };
    }
    getRenderPipelineHash(fbHash, program, vertexData, stateSet, primitiveType) {
        const programHash = program.hash;
        const vertexHash = vertexData?.getLayouts(program.vertexAttributes).layoutHash || '';
        const stateHash = stateSet?.hash || '';
        return `${programHash}:${vertexHash}:${fbHash}:${primitiveType}:${stateHash}:${Number(this._device.isWindingOrderReversed())}`;
    }
    getComputePipelineHash(program) {
        return program.hash;
    }
}

class WebGPUFrameBuffer extends WebGPUObject {
    _options;
    _width;
    _height;
    _bindFlag;
    _msaaColorTextures;
    _msaaDepthTexture;
    constructor(device, colorAttachments, depthAttachment, opt){
        super(device);
        if (colorAttachments.length > 0 && colorAttachments.findIndex((val)=>!val) >= 0) {
            throw new Error('WebGPUFramebuffer(): invalid color attachments');
        }
        this._object = null;
        this._options = {
            colorAttachments: colorAttachments?.length > 0 ? colorAttachments.map((value)=>({
                    texture: value,
                    face: 0,
                    layer: 0,
                    level: 0,
                    generateMipmaps: true
                })) : null,
            depthAttachment: depthAttachment ? {
                texture: depthAttachment,
                face: 0,
                layer: 0,
                level: 0,
                generateMipmaps: false
            } : null,
            sampleCount: opt?.sampleCount ?? 1,
            ignoreDepthStencil: opt?.ignoreDepthStencil ?? false
        };
        if (!this._options.colorAttachments && !this._options.depthAttachment) {
            throw new Error('WebGPUFramebuffer(): colorAttachments or depthAttachment must be specified');
        }
        this._width = this._options.colorAttachments ? this._options.colorAttachments[0].texture.width : this._options.depthAttachment.texture.width;
        this._height = this._options.colorAttachments ? this._options.colorAttachments[0].texture.height : this._options.depthAttachment.texture.height;
        if (this._options.colorAttachments && this._options.colorAttachments.findIndex((val)=>val.texture.width !== this._width || val.texture.height !== this._height) >= 0 || this._options.depthAttachment && (this._options.depthAttachment.texture.width !== this._width || this._options.depthAttachment.texture.height !== this._height)) {
            throw new Error('WebGPUFramebuffer(): attachment textures must have same width and height');
        }
        this._bindFlag = 0;
        this._msaaColorTextures = null;
        this._msaaDepthTexture = null;
        this._init();
    }
    getOptions() {
        return this._options;
    }
    get bindFlag() {
        return this._bindFlag;
    }
    getWidth() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return attachment ? Math.max(attachment.texture.width >> attachment.level, 1) : 0;
    }
    getHeight() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return attachment ? Math.max(attachment.texture.height >> attachment.level, 1) : 0;
    }
    async restore() {
        if (this._options?.depthAttachment?.texture?.disposed) {
            await this._options.depthAttachment.texture.reload();
        }
        if (this._options?.colorAttachments) {
            for (const k of this._options.colorAttachments){
                if (k?.texture?.disposed) {
                    await k.texture.reload();
                }
            }
        }
        if (!this._device.isContextLost()) {
            this._init();
        }
    }
    destroy() {
        this._object = null;
        if (this._msaaColorTextures) {
            for (const tex of this._msaaColorTextures){
                tex.destroy();
            }
            this._msaaColorTextures = null;
        }
        if (this._msaaDepthTexture) {
            this._msaaDepthTexture.destroy();
            this._msaaDepthTexture = null;
        }
    }
    setColorAttachmentGenerateMipmaps(index, generateMipmaps) {
        const k = this._options.colorAttachments?.[index];
        if (k) {
            k.generateMipmaps = !!generateMipmaps;
        }
    }
    setColorAttachmentCubeFace(index, face) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.face !== face) {
            k.face = face;
            this._bindFlag++;
        }
    }
    setColorAttachmentMipLevel(index, level) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.level !== level) {
            k.level = level;
            this._bindFlag++;
        }
    }
    setColorAttachmentLayer(index, layer) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.layer !== layer) {
            k.layer = layer;
            this._bindFlag++;
        }
    }
    setDepthAttachmentCubeFace(face) {
        const k = this._options.depthAttachment;
        if (k && k.face !== face) {
            k.face = face;
            this._bindFlag++;
        }
    }
    setDepthAttachmentLayer(layer) {
        const k = this._options.depthAttachment;
        if (k && k.layer !== layer) {
            k.layer = layer;
            this._bindFlag++;
        }
    }
    getDepthAttachment() {
        return this._options?.depthAttachment?.texture || null;
    }
    getColorAttachments() {
        return this._options?.colorAttachments?.map((val)=>val?.texture || null) || [];
    }
    getMSAADepthAttachment() {
        return this._msaaDepthTexture;
    }
    getMSAAColorAttacments() {
        return this._msaaColorTextures;
    }
    getColorFormats() {
        return this._options?.colorAttachments?.map((val)=>(val?.texture)?.gpuFormat || null);
    }
    getDepthFormat() {
        return (this._options.depthAttachment?.texture)?.gpuFormat || null;
    }
    bind() {
        throw new Error('no bind operatation for WebGPU');
    }
    unbind() {
        throw new Error('no unbind operatation for WebGPU');
    }
    _init() {
        if (this._options.sampleCount > 1) {
            this._msaaColorTextures = [];
            for (const colorAttachment of this._options.colorAttachments){
                const msaaTexture = this.device.gpuCreateTexture({
                    size: {
                        width: this._width,
                        height: this._height,
                        depthOrArrayLayers: 1
                    },
                    format: colorAttachment.texture.gpuFormat,
                    mipLevelCount: 1,
                    sampleCount: this._options.sampleCount,
                    dimension: '2d',
                    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
                });
                this._msaaColorTextures.push(msaaTexture);
            }
            if (this._options.depthAttachment) {
                const msaaDepthTexture = this.device.gpuCreateTexture({
                    size: {
                        width: this._width,
                        height: this._height,
                        depthOrArrayLayers: 1
                    },
                    format: this._options.depthAttachment.texture.gpuFormat,
                    mipLevelCount: 1,
                    sampleCount: this._options.sampleCount,
                    dimension: '2d',
                    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
                });
                this._msaaDepthTexture = msaaDepthTexture;
            }
        }
        this._object = {};
    }
    isFramebuffer() {
        return true;
    }
    getSampleCount() {
        return this._options.sampleCount;
    }
}

const typeU16$3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const typeU32$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
class WebGPUIndexBuffer extends WebGPUBuffer {
    indexType;
    length;
    constructor(device, data, usage){
        if (!(data instanceof Uint16Array) && !(data instanceof Uint32Array)) {
            throw new Error('invalid index data');
        }
        super(device, GPUResourceUsageFlags.BF_INDEX | usage, data);
        this.indexType = data instanceof Uint16Array ? typeU16$3 : typeU32$1;
        this.length = data.length;
    }
}

class BindGroupCache {
    _device;
    _bindGroupLayoutCache;
    constructor(device){
        this._device = device;
        this._bindGroupLayoutCache = {};
    }
    fetchBindGroupLayout(desc) {
        const hash = desc ? this.getLayoutHash(desc) : '';
        let bgl = this._bindGroupLayoutCache[hash];
        if (!bgl) {
            bgl = this.createBindGroupLayout(desc);
            if (bgl) {
                this._bindGroupLayoutCache[hash] = bgl;
            } else {
                throw new Error(`fetchBindGroupLayout() failed: hash: ${hash}`);
            }
        }
        return bgl;
    }
    getLayoutHash(desc) {
        let hash = '';
        for (const entry of desc.entries){
            let s = `${entry.binding}:${entry.visibility}:`;
            if (entry.buffer) {
                s += `b:${entry.buffer.type}:${entry.buffer.hasDynamicOffset}:${entry.buffer.minBindingSize}`;
            } else if (entry.sampler) {
                s += `s${entry.sampler.type}:`;
            } else if (entry.texture) {
                s += `t${entry.texture.sampleType}-${entry.texture.viewDimension}-${Number(!!entry.texture.multisampled)}:`;
            } else if (entry.storageTexture) {
                s += `k${entry.storageTexture.access}-${entry.storageTexture.format}-${entry.storageTexture.viewDimension}:`;
            } else if (entry.externalTexture) {
                s += `v:`;
            }
            hash = `${hash} ${s}`;
        }
        return hash;
    }
    createBindGroupLayout(desc) {
        const layoutDescriptor = {
            entries: desc?.entries.map((entry)=>{
                const binding = entry.binding;
                const visibility = (entry.visibility & ShaderType.Vertex ? GPUShaderStage.VERTEX : 0) | (entry.visibility & ShaderType.Fragment ? GPUShaderStage.FRAGMENT : 0) | (entry.visibility & ShaderType.Compute ? GPUShaderStage.COMPUTE : 0);
                const buffer = entry.buffer ? {
                    type: entry.buffer.type,
                    hasDynamicOffset: entry.buffer.hasDynamicOffset,
                    // minBindingSize: entry.buffer.uniformLayout.byteSize
                    minBindingSize: Number(entry.buffer.minBindingSize) || 0
                } : undefined;
                const sampler = entry.sampler ? {
                    type: entry.sampler.type
                } : undefined;
                const texture = entry.texture ? {
                    sampleType: entry.texture.sampleType,
                    viewDimension: entry.texture.viewDimension
                } : undefined;
                const storageTexture = entry.storageTexture ? {
                    access: 'write-only',
                    viewDimension: '2d',
                    format: textureFormatMap[entry.storageTexture.format]
                } : undefined;
                const externalTexture = entry.externalTexture ? {} : undefined;
                const t = {
                    binding,
                    visibility
                };
                if (buffer) {
                    t.buffer = buffer;
                } else if (sampler) {
                    t.sampler = sampler;
                } else if (texture) {
                    t.texture = texture;
                } else if (storageTexture) {
                    t.storageTexture = storageTexture;
                } else if (externalTexture) {
                    t.externalTexture = externalTexture;
                }
                return t;
            }) || []
        };
        if (desc?.label) {
            layoutDescriptor.label = desc.label;
        }
        return this._device.device.createBindGroupLayout(layoutDescriptor);
    }
}

class VertexLayoutCache {
    _layouts;
    constructor(){
        this._layouts = {};
    }
    fetchVertexLayout(hash) {
        let layouts = this._layouts[hash];
        if (!layouts) {
            layouts = [];
            hash.split(':').forEach((l)=>{
                const parts = l.split('-');
                const layout = {
                    arrayStride: Number(parts[0]),
                    stepMode: Number(parts[1]) ? 'instance' : 'vertex',
                    attributes: []
                };
                for(let i = 2; i < parts.length; i += 3){
                    layout.attributes.push({
                        format: hashToVertexFormat[parts[i]],
                        offset: Number(parts[i + 1]),
                        shaderLocation: Number(parts[i + 2])
                    });
                }
                layouts.push(layout);
            });
            this._layouts[hash] = layouts;
        }
        return layouts;
    }
}

class WebGPUTextureSampler extends WebGPUObject {
    _options;
    constructor(device, options){
        super(device);
        this._options = Object.assign({
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter: 'nearest',
            minFilter: 'nearest',
            mipFilter: 'none',
            lodMin: 0,
            lodMax: 32,
            compare: null,
            maxAnisotropy: 1
        }, options || {});
        this._load();
    }
    get hash() {
        return this._object ? this._device.gpuGetObjectHash(this._object) : 0;
    }
    get addressModeU() {
        return this._options.addressU;
    }
    get addressModeV() {
        return this._options.addressV;
    }
    get addressModeW() {
        return this._options.addressW;
    }
    get magFilter() {
        return this._options.magFilter;
    }
    get minFilter() {
        return this._options.minFilter;
    }
    get mipFilter() {
        return this._options.mipFilter;
    }
    get lodMin() {
        return this._options.lodMin;
    }
    get lodMax() {
        return this._options.lodMax;
    }
    get compare() {
        return this._options.compare;
    }
    get maxAnisotropy() {
        return this._options.maxAnisotropy;
    }
    destroy() {
        this._object = null;
    }
    async restore() {
        if (!this._device.isContextLost()) {
            this._load();
        }
    }
    _load() {
        this._object = this._device.gpuCreateSampler({
            addressModeU: textureWrappingMap$1[this._options.addressU],
            addressModeV: textureWrappingMap$1[this._options.addressV],
            addressModeW: textureWrappingMap$1[this._options.addressW],
            magFilter: textureFilterMap[this._options.magFilter],
            minFilter: textureFilterMap[this._options.minFilter],
            mipmapFilter: textureFilterMap[this._options.mipFilter],
            lodMinClamp: this._options.lodMin,
            lodMaxClamp: this._options.lodMax,
            compare: compareFuncMap$1[this._options.compare] || undefined,
            maxAnisotropy: this._options.maxAnisotropy
        });
        return !!this._object;
    }
    isSampler() {
        return true;
    }
}

let SamplerCache$1 = class SamplerCache {
    _device;
    _samplers;
    constructor(device){
        this._device = device;
        this._samplers = {};
    }
    fetchSampler(options) {
        const hash = this.hash(options);
        let sampler = this._samplers[hash];
        if (!sampler) {
            sampler = this.createSampler(options);
            this._samplers[hash] = sampler;
        }
        return sampler;
    }
    hash(options) {
        const addressU = options.addressU ? String(options.addressU) : '';
        const addressV = options.addressV ? String(options.addressV) : '';
        const addressW = options.addressW ? String(options.addressW) : '';
        const magFilter = options.magFilter ? String(options.magFilter) : '';
        const minFilter = options.minFilter ? String(options.minFilter) : '';
        const mipFilter = options.mipFilter ? String(options.mipFilter) : '';
        const lodMin = options.lodMin ? String(options.lodMin) : '';
        const lodMax = options.lodMax ? String(options.lodMax) : '';
        const compare = options.compare ? String(options.compare) : '';
        const maxAnisotropy = options.maxAnisotropy ? String(options.maxAnisotropy) : '';
        return `${addressU}:${addressV}:${addressW}:${magFilter}:${minFilter}:${mipFilter}:${lodMin}:${lodMax}:${compare}:${maxAnisotropy}`;
    }
    createSampler(options) {
        return new WebGPUTextureSampler(this._device, options);
    }
};

class WebGPUClearQuad {
    static _clearPrograms = {};
    static _clearBindGroup = null;
    static _clearStateSet = null;
    static _defaultClearColor = new Vector4(0, 0, 0, 1);
    static drawClearQuad(renderPass, clearColor, clearDepth, clearStencil) {
        if (!this._clearBindGroup) {
            this.initClearQuad(renderPass);
        }
        const hash = renderPass.getFrameBufferInfo().clearHash;
        const program = this.getClearProgram(renderPass.getDevice(), hash);
        const bClearColor = !!clearColor;
        const bClearDepth = !(clearDepth === null || clearDepth === undefined);
        const bClearStencil = !(clearStencil === null || clearStencil === undefined);
        program.bindGroup.setValue('clearDepth', clearDepth ?? 1);
        program.bindGroup.setValue('clearColor', clearColor ?? this._defaultClearColor);
        this._clearStateSet.useDepthState().enableWrite(bClearDepth);
        this._clearStateSet.useColorState().setColorMask(bClearColor, bClearColor, bClearColor, bClearColor);
        this._clearStateSet.useStencilState().enable(bClearStencil).setReference(bClearStencil ? clearStencil : 0);
        renderPass.draw(program.program, null, this._clearStateSet, [
            program.bindGroup
        ], null, 'triangle-strip', 0, 4, 1);
    }
    static getClearProgram(device, hash) {
        let programInfo = this._clearPrograms[hash];
        if (!programInfo) {
            const colorAttachments = hash.split('');
            const program = device.buildRenderProgram({
                label: `ClearQuad-${hash}`,
                vertex (pb) {
                    this.clearDepth = pb.float().uniform(0);
                    this.coords = [
                        pb.vec2(-1, 1),
                        pb.vec2(1, 1),
                        pb.vec2(-1, -1),
                        pb.vec2(1, -1)
                    ];
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.coords.at(this.$builtins.vertexIndex), this.clearDepth, 1);
                    });
                },
                fragment (pb) {
                    this.clearColor = pb.vec4().uniform(0);
                    if (colorAttachments.length === 0) {
                        this.$outputs.outColor = pb.vec4();
                        pb.main(function() {
                            this.$outputs.outColor = this.clearColor;
                        });
                    } else {
                        for(let i = 0; i < colorAttachments.length; i++){
                            this.$outputs[`outColor${i}`] = colorAttachments[i] === 'f' ? pb.vec4() : colorAttachments[i] === 'i' ? pb.ivec4() : pb.uvec4();
                        }
                        pb.main(function() {
                            for(let i = 0; i < colorAttachments.length; i++){
                                this.$outputs[`outColor${i}`] = colorAttachments[i] === 'f' ? this.clearColor : colorAttachments[i] === 'i' ? pb.ivec4(this.clearColor) : pb.uvec4(this.clearColor);
                            }
                        });
                    }
                }
            });
            const bindGroup = device.createBindGroup(program.bindGroupLayouts[0]);
            programInfo = {
                program,
                bindGroup
            };
            this._clearPrograms[hash] = programInfo;
        }
        return programInfo;
    }
    static initClearQuad(renderPass) {
        this._clearStateSet = renderPass.getDevice().createRenderStateSet();
        this._clearStateSet.useDepthState().enableTest(false);
        this._clearStateSet.useRasterizerState().setCullMode('none');
        this._clearStateSet.useStencilState().enable(true).setFrontOp('replace', 'replace', 'replace').setBackOp('replace', 'replace', 'replace').setFrontCompareFunc('always').setBackCompareFunc('always');
    }
}
class WebGPUMipmapGenerator {
    static _frameBufferInfo = null;
    static _mipmapGenerationProgram = null;
    static _mipmapGenerationBindGroup = new WeakMap();
    static _mipmapGenerationStateSet = null;
    static generateMipmap(device, tex) {
        if (!this._mipmapGenerationProgram) {
            this.initMipmapGeneration(device);
        }
        const cmdEncoder = device.device.createCommandEncoder();
        const miplevels = tex.mipLevelCount;
        const numLayers = tex.isTextureCube() ? 6 : tex.isTexture2DArray() ? tex.depth : 1;
        let tmpTex = tex.object;
        if (!tex.isRenderable()) {
            tmpTex = device.gpuCreateTexture({
                size: {
                    width: tex.width,
                    height: tex.height,
                    depthOrArrayLayers: numLayers
                },
                format: tex.gpuFormat,
                mipLevelCount: tex.mipLevelCount,
                sampleCount: 1,
                dimension: '2d',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
            });
        }
        tex.setMipmapDirty(false);
        for(let face = 0; face < numLayers; face++){
            for(let level = 1; level < miplevels; level++){
                this.generateMiplevel(device, cmdEncoder, tex, tmpTex, tex.gpuFormat, tmpTex === tex.object ? level : level - 1, level, face);
            }
        }
        if (tmpTex !== tex.object) {
            let width = tex.width;
            let height = tex.height;
            for(let level = 1; level < miplevels; level++){
                cmdEncoder.copyTextureToTexture({
                    texture: tmpTex,
                    mipLevel: level - 1
                }, {
                    texture: tex.object,
                    mipLevel: level
                }, {
                    width: width,
                    height: height,
                    depthOrArrayLayers: numLayers
                });
                width = Math.ceil(width / 2);
                height = Math.ceil(height / 2);
            }
        }
        device.device.queue.submit([
            cmdEncoder.finish()
        ]);
        if (tmpTex !== tex.object) {
            tmpTex.destroy();
        }
    }
    static generateMipmapsForBindGroups(device, bindGroups) {
        for (const bindGroup of bindGroups){
            if (bindGroup) {
                for (const tex of bindGroup.textureList){
                    if (!tex.disposed && tex.isMipmapDirty()) {
                        WebGPUMipmapGenerator.generateMipmap(device, tex);
                    }
                }
            }
        }
    }
    static generateMiplevel(device, commandEncoder, srcTex, dstTex, format, dstLevel, srcLevel, face) {
        const renderPassEncoder = this.beginMipmapGenerationPass(commandEncoder, dstTex, format, dstLevel, face);
        renderPassEncoder.setBindGroup(0, this.getMipmapGenerationBindGroup(device, srcTex, srcLevel, face).bindGroup);
        const pipeline = device.pipelineCache.fetchRenderPipeline(this._mipmapGenerationProgram, null, this._mipmapGenerationStateSet, 'triangle-strip', this._frameBufferInfo);
        if (pipeline) {
            renderPassEncoder.setPipeline(pipeline);
            renderPassEncoder.draw(4, 1, 0);
        }
        renderPassEncoder.end();
    }
    static beginMipmapGenerationPass(encoder, texture, format, level, face) {
        const passDesc = {
            colorAttachments: [
                {
                    view: texture.createView({
                        dimension: '2d',
                        baseMipLevel: level || 0,
                        mipLevelCount: 1,
                        baseArrayLayer: face || 0,
                        arrayLayerCount: 1
                    }),
                    loadOp: 'clear',
                    clearValue: [
                        0,
                        0,
                        0,
                        0
                    ],
                    storeOp: 'store'
                }
            ]
        };
        this._frameBufferInfo = {
            colorFormats: [
                format
            ],
            depthFormat: null,
            sampleCount: 1,
            hash: null,
            clearHash: null
        };
        this._frameBufferInfo.hash = `${this._frameBufferInfo.colorFormats.join('-')}:${this._frameBufferInfo.depthFormat}:${this._frameBufferInfo.sampleCount}`;
        const renderPassEncoder = encoder.beginRenderPass(passDesc);
        renderPassEncoder.insertDebugMarker('MipmapGeneration');
        return renderPassEncoder;
    }
    static getMipmapGenerationBindGroup(device, texture, level, face) {
        let faceGroups = this._mipmapGenerationBindGroup.get(texture);
        if (!faceGroups) {
            faceGroups = [];
            this._mipmapGenerationBindGroup.set(texture, faceGroups);
        }
        let levelGroups = faceGroups[face];
        if (!levelGroups) {
            levelGroups = [];
            faceGroups[face] = levelGroups;
        }
        let levelGroup = levelGroups[level];
        if (!levelGroup) {
            levelGroup = device.createBindGroup(this._mipmapGenerationProgram.bindGroupLayouts[0]);
            levelGroup.setTextureView('tex', texture, level - 1, face, 1);
            levelGroups[level] = levelGroup;
        }
        return levelGroup;
    }
    static initMipmapGeneration(device) {
        this._mipmapGenerationProgram = device.buildRenderProgram({
            label: 'MipmapGeneration',
            vertex (pb) {
                this.$outputs.outUV = pb.vec2();
                this.coords = [
                    pb.vec2(-1, 1),
                    pb.vec2(1, 1),
                    pb.vec2(-1, -1),
                    pb.vec2(1, -1)
                ];
                this.uv = [
                    pb.vec2(0, 0),
                    pb.vec2(1, 0),
                    pb.vec2(0, 1),
                    pb.vec2(1, 1)
                ];
                pb.main(function() {
                    this.$builtins.position = pb.vec4(this.coords.at(this.$builtins.vertexIndex), 0, 1);
                    this.$outputs.outUV = this.uv.at(this.$builtins.vertexIndex);
                });
            },
            fragment (pb) {
                this.$outputs.color = pb.vec4();
                this.tex = pb.tex2D().uniform(0);
                pb.main(function() {
                    this.$outputs.color = pb.textureSampleLevel(this.tex, this.$inputs.outUV, 0);
                });
            }
        });
        this._mipmapGenerationStateSet = device.createRenderStateSet();
        this._mipmapGenerationStateSet.useDepthState().enableTest(false).enableWrite(false);
        this._mipmapGenerationStateSet.useRasterizerState().setCullMode('none');
    }
}

const VALIDATION_NEED_NEW_PASS$1 = 1 << 0;
const VALIDATION_NEED_GENERATE_MIPMAP$1 = 1 << 1;
const VALIDATION_FAILED$1 = 1 << 2;
const typeU16$2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
class WebGPURenderPass {
    _device;
    _frameBuffer;
    _bufferUploads;
    _textureUploads;
    _bufferUploadsNext;
    _textureUploadsNext;
    _renderCommandEncoder;
    _renderPassEncoder;
    _fbBindFlag;
    _currentViewport;
    _currentScissor;
    _frameBufferInfo;
    constructor(device){
        this._device = device;
        this._bufferUploads = new Set();
        this._textureUploads = new Set();
        this._bufferUploadsNext = new Set();
        this._textureUploadsNext = new Set();
        this._renderCommandEncoder = this._device.device.createCommandEncoder();
        this._renderPassEncoder = null;
        this._frameBuffer = null;
        this._fbBindFlag = null;
        this._currentViewport = null;
        this._currentScissor = null;
        this._frameBufferInfo = null;
    }
    get active() {
        return !!this._renderPassEncoder;
    }
    isBufferUploading(buffer) {
        return !!this._bufferUploads.has(buffer);
    }
    isTextureUploading(tex) {
        return !!this._textureUploads.has(tex);
    }
    setFramebuffer(fb) {
        if (this._frameBuffer !== fb) {
            this.end();
            this._frameBuffer = fb;
            this.setViewport(null);
            this.setScissor(null);
        }
    }
    getFramebuffer() {
        return this._frameBuffer;
    }
    setViewport(vp) {
        if (!vp || !Array.isArray(vp) && vp.default) {
            this._currentViewport = {
                x: 0,
                y: 0,
                width: this._device.deviceToScreen(this._device.drawingBufferWidth),
                height: this._device.deviceToScreen(this._device.drawingBufferHeight),
                default: true
            };
        } else {
            if (Array.isArray(vp)) {
                this._currentViewport = {
                    x: vp[0],
                    y: vp[1],
                    width: vp[2],
                    height: vp[3],
                    default: false
                };
            } else {
                this._currentViewport = Object.assign({
                    default: false
                }, vp);
            }
        }
        const vx = this._device.screenToDevice(this._currentViewport.x);
        const vy = this._device.screenToDevice(this._currentViewport.y);
        const vw = this._device.screenToDevice(this._currentViewport.width);
        const vh = this._device.screenToDevice(this._currentViewport.height);
        if (vx < 0 || vy < 0 || vw > this._device.drawingBufferWidth || vh > this._device.drawingBufferHeight) {
            console.log(`** VIEWPORT ERROR **: (${vx}, ${vy}, ${vw}, ${vh}) => (0, 0, ${this._device.drawingBufferWidth}, ${this._device.drawingBufferHeight})`);
        }
        if (this._renderPassEncoder) {
            this._renderPassEncoder.setViewport(vx, this._device.drawingBufferHeight - vy - vh, vw, vh, 0, 1);
        }
    }
    getViewport() {
        return Object.assign({}, this._currentViewport);
    }
    setScissor(scissor) {
        const backBufferWidth = this._device.deviceToScreen(this._device.drawingBufferWidth);
        const backBufferHeight = this._device.deviceToScreen(this._device.drawingBufferHeight);
        if (scissor === null || scissor === undefined || !Array.isArray(scissor) && scissor.default) {
            this._currentScissor = {
                x: 0,
                y: 0,
                width: backBufferWidth,
                height: backBufferHeight,
                default: true
            };
        } else {
            if (Array.isArray(scissor)) {
                this._currentScissor = {
                    x: scissor[0],
                    y: scissor[1],
                    width: scissor[2],
                    height: scissor[3],
                    default: false
                };
            } else {
                this._currentScissor = Object.assign({
                    default: false
                }, scissor);
            }
        }
        let vx = this._device.screenToDevice(this._currentScissor.x);
        let vy = this._device.screenToDevice(this._currentScissor.y);
        let vw = this._device.screenToDevice(this._currentScissor.width);
        let vh = this._device.screenToDevice(this._currentScissor.height);
        // Clip scissor region to screen
        if (vx < 0) {
            vw += vx;
            vx = 0;
        }
        if (vy < 0) {
            vh += vy;
            vy = 0;
        }
        vw = Math.min(this._device.screenToDevice(backBufferWidth) - vx, vw);
        vh = Math.min(this._device.screenToDevice(backBufferHeight) - vy, vh);
        if (vw < 0 || vh < 0) {
            vx = 0;
            vy = 0;
            vw = 0;
            vh = 0;
        }
        if (this._renderPassEncoder) {
            this._renderPassEncoder.setScissorRect(vx, this._device.drawingBufferHeight - vy - vh, vw, vh);
        }
    }
    getScissor() {
        return Object.assign({}, this._currentScissor);
    }
    draw(program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances) {
        const validation = this.validateDraw(program, vertexData, bindGroups);
        if (validation & VALIDATION_FAILED$1) {
            return;
        }
        if (validation & VALIDATION_NEED_NEW_PASS$1 || validation & VALIDATION_NEED_GENERATE_MIPMAP$1) {
            this.end();
        }
        if (validation & VALIDATION_NEED_GENERATE_MIPMAP$1) {
            WebGPUMipmapGenerator.generateMipmapsForBindGroups(this._device, bindGroups);
        }
        if (!this.active) {
            this.begin();
        }
        this.drawInternal(this._renderPassEncoder, program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances);
    }
    clear(color, depth, stencil) {
        if (!this._currentScissor) {
            this.end();
            this.begin(color, depth, stencil);
        } else {
            if (!this._renderPassEncoder) {
                this.begin();
            }
            this._renderPassEncoder.insertDebugMarker('clear');
            WebGPUClearQuad.drawClearQuad(this, color, depth, stencil);
            this._renderPassEncoder.insertDebugMarker('end clear');
        }
    }
    getDevice() {
        return this._device;
    }
    getFrameBufferInfo() {
        return this._frameBufferInfo;
    }
    begin(color, depth, stencil) {
        if (this.active) {
            console.error('WebGPURenderPass.begin() failed: begin() has already been called');
            return;
        }
        this._renderCommandEncoder = this._device.device.createCommandEncoder();
        if (!this._frameBuffer) {
            const fmt = textureFormatInvMap[this._device.backbufferFormat];
            this._frameBufferInfo = {
                colorFormats: [
                    this._device.backbufferFormat
                ],
                depthFormat: this._device.backbufferDepthFormat,
                sampleCount: this._device.sampleCount,
                hash: `${this._device.backbufferFormat}:${this._device.backbufferDepthFormat}:${this._device.sampleCount}`,
                clearHash: isIntegerTextureFormat(fmt) ? isSignedTextureFormat(fmt) ? 'i' : 'u' : 'f'
            };
            const mainPassDesc = this._device.defaultRenderPassDesc;
            const colorAttachmentDesc = this._device.defaultRenderPassDesc.colorAttachments[0];
            if (this._frameBufferInfo.sampleCount > 1) {
                colorAttachmentDesc.resolveTarget = this._device.context.getCurrentTexture().createView();
            } else {
                colorAttachmentDesc.view = this._device.context.getCurrentTexture().createView();
            }
            colorAttachmentDesc.loadOp = color ? 'clear' : 'load';
            colorAttachmentDesc.clearValue = color;
            const depthAttachmentDesc = this._device.defaultRenderPassDesc.depthStencilAttachment;
            depthAttachmentDesc.depthLoadOp = typeof depth === 'number' ? 'clear' : 'load';
            depthAttachmentDesc.depthClearValue = depth;
            depthAttachmentDesc.stencilLoadOp = typeof stencil === 'number' ? 'clear' : 'load';
            depthAttachmentDesc.stencilClearValue = stencil;
            this._renderPassEncoder = this._renderCommandEncoder.beginRenderPass(mainPassDesc);
        } else {
            const colorAttachmentTextures = this._frameBuffer.getColorAttachments();
            const depthAttachmentTexture = this._frameBuffer.getDepthAttachment();
            let depthTextureView;
            if (depthAttachmentTexture) {
                depthAttachmentTexture._markAsCurrentFB(true);
                const attachment = this._frameBuffer.getOptions().depthAttachment;
                const layer = depthAttachmentTexture.isTexture2DArray() || depthAttachmentTexture.isTexture3D() ? attachment.layer : depthAttachmentTexture.isTextureCube() ? attachment.face : 0;
                depthTextureView = depthAttachmentTexture.getView(0, layer ?? 0, 1);
            }
            this._frameBufferInfo = {
                colorFormats: colorAttachmentTextures.map((val)=>val.gpuFormat),
                depthFormat: depthAttachmentTexture?.gpuFormat,
                sampleCount: this._frameBuffer.getOptions().sampleCount,
                hash: null,
                clearHash: colorAttachmentTextures.map((val)=>{
                    const fmt = textureFormatInvMap[val.gpuFormat];
                    return isIntegerTextureFormat(fmt) ? isSignedTextureFormat(fmt) ? 'i' : 'u' : 'f';
                }).join('')
            };
            this._frameBufferInfo.hash = `${this._frameBufferInfo.colorFormats.join('-')}:${this._frameBufferInfo.depthFormat}:${this._frameBufferInfo.sampleCount}`;
            this._fbBindFlag = this._frameBuffer.bindFlag;
            const passDesc = {
                label: `customRenderPass:${this._frameBufferInfo.hash}`,
                colorAttachments: this._frameBuffer.getOptions().colorAttachments?.map((attachment, index)=>{
                    const tex = attachment.texture;
                    if (tex) {
                        tex._markAsCurrentFB(true);
                        const layer = tex.isTexture2DArray() || tex.isTexture3D() ? attachment.layer : tex.isTextureCube() ? attachment.face : 0;
                        if (this._frameBuffer.getOptions().sampleCount === 1) {
                            return {
                                view: tex.getView(attachment.level ?? 0, layer ?? 0, 1),
                                loadOp: color ? 'clear' : 'load',
                                clearValue: color,
                                storeOp: 'store'
                            };
                        } else {
                            const msaaTexture = this._frameBuffer.getMSAAColorAttacments()[index];
                            const msaaView = this._device.gpuCreateTextureView(msaaTexture, {
                                dimension: '2d',
                                baseMipLevel: attachment.level ?? 0,
                                mipLevelCount: 1,
                                baseArrayLayer: 0,
                                arrayLayerCount: 1
                            });
                            return {
                                view: msaaView,
                                resolveTarget: tex.getView(attachment.level ?? 0, layer ?? 0, 1),
                                loadOp: color ? 'clear' : 'load',
                                clearValue: color,
                                storeOp: 'store'
                            };
                        }
                    } else {
                        return null;
                    }
                }) ?? [],
                depthStencilAttachment: depthAttachmentTexture ? this._frameBuffer.getOptions().sampleCount === 1 ? {
                    view: depthTextureView,
                    depthLoadOp: typeof depth === 'number' ? 'clear' : 'load',
                    depthClearValue: depth,
                    depthStoreOp: 'store',
                    stencilLoadOp: hasStencilChannel(depthAttachmentTexture.format) ? typeof stencil === 'number' ? 'clear' : 'load' : undefined,
                    stencilClearValue: stencil,
                    stencilStoreOp: hasStencilChannel(depthAttachmentTexture.format) ? 'store' : undefined
                } : {
                    view: this._frameBuffer.getMSAADepthAttachment().createView(),
                    depthLoadOp: typeof depth === 'number' ? 'clear' : 'load',
                    depthClearValue: depth,
                    depthStoreOp: 'store',
                    stencilLoadOp: hasStencilChannel(depthAttachmentTexture.format) ? typeof stencil === 'number' ? 'clear' : 'load' : undefined,
                    stencilClearValue: stencil,
                    stencilStoreOp: hasStencilChannel(depthAttachmentTexture.format) ? 'store' : undefined
                } : undefined
            };
            this._renderPassEncoder = this._renderCommandEncoder.beginRenderPass(passDesc);
        }
        this.setViewport(this._currentViewport);
        this.setScissor(this._currentScissor);
    }
    end() {
        const commands = [];
        // upload the resources needed for this rendering pass
        if (this._bufferUploads.size > 0 || this._textureUploads.size > 0) {
            const uploadCommandEncoder = this._device.device.createCommandEncoder();
            this._bufferUploads.forEach((buffer)=>buffer.beginSyncChanges(uploadCommandEncoder));
            this._textureUploads.forEach((tex)=>tex.beginSyncChanges(uploadCommandEncoder));
            commands.push(uploadCommandEncoder.finish());
        }
        // finish current render pass command
        if (this._renderPassEncoder) {
            this._renderPassEncoder.end();
            this._renderPassEncoder = null;
        }
        // render commands
        if (this._renderCommandEncoder) {
            commands.push(this._renderCommandEncoder.finish());
            this._renderCommandEncoder = null;
        }
        // submit to GPU
        if (commands.length > 0) {
            this._device.device.queue.submit(commands);
        }
        // free up resource upload buffers
        this._bufferUploads.forEach((buffer)=>buffer.endSyncChanges());
        this._textureUploads.forEach((tex)=>tex.endSyncChanges());
        this._bufferUploads.clear();
        this._textureUploads.clear();
        // next pass uploading becomes current pass uploading
        [this._bufferUploads, this._bufferUploadsNext] = [
            this._bufferUploadsNext,
            this._bufferUploads
        ];
        [this._textureUploads, this._textureUploadsNext] = [
            this._textureUploadsNext,
            this._textureUploads
        ];
        // unmark render target flags and generate render target mipmaps if needed
        if (this._frameBuffer) {
            const options = this._frameBuffer.getOptions();
            if (options.colorAttachments) {
                for (const attachment of options.colorAttachments){
                    attachment.texture._markAsCurrentFB(false);
                    if (attachment.generateMipmaps && attachment.texture.mipLevelCount > 1) {
                        attachment.texture.generateMipmaps();
                    }
                }
            }
            (options.depthAttachment?.texture)?._markAsCurrentFB(false);
        }
    }
    drawInternal(renderPassEncoder, program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances) {
        if (this.setBindGroupsForRender(renderPassEncoder, program, vertexData, bindGroups, bindGroupOffsets)) {
            const pipeline = this._device.pipelineCache.fetchRenderPipeline(program, vertexData, stateSet, primitiveType, this._frameBufferInfo);
            if (pipeline) {
                renderPassEncoder.setPipeline(pipeline);
                const stencilState = stateSet?.stencilState;
                if (stencilState) {
                    renderPassEncoder.setStencilReference(stencilState.ref);
                }
                if (vertexData) {
                    const vertexBuffers = vertexData.getLayouts(program.vertexAttributes)?.buffers;
                    vertexBuffers?.forEach((val, index)=>{
                        renderPassEncoder.setVertexBuffer(index, val.buffer.object, val.drawOffset);
                    });
                    const indexBuffer = vertexData.getIndexBuffer();
                    if (indexBuffer) {
                        renderPassEncoder.setIndexBuffer(indexBuffer.object, indexBuffer.indexType === typeU16$2 ? 'uint16' : 'uint32');
                        renderPassEncoder.drawIndexed(count, numInstances, first);
                    } else {
                        renderPassEncoder.draw(count, numInstances, first);
                    }
                } else {
                    renderPassEncoder.draw(count, numInstances, first);
                }
            }
        }
    }
    validateDraw(program, vertexData, bindGroups) {
        let validation = 0;
        const bufferUploads = [];
        const textureUploads = [];
        if (bindGroups) {
            for(let i = 0; i < program.bindGroupLayouts.length; i++){
                const bindGroup = bindGroups[i];
                if (bindGroup) {
                    if (bindGroup.bindGroup) {
                        for (const ubo of bindGroup.bufferList){
                            if (ubo.disposed) {
                                validation |= VALIDATION_FAILED$1;
                            }
                            if (ubo.getPendingUploads().length > 0) {
                                bufferUploads.push(ubo);
                            }
                        }
                        for (const tex of bindGroup.textureList){
                            if (tex.disposed) {
                                validation |= VALIDATION_FAILED$1;
                            }
                            if (tex._isMarkedAsCurrentFB()) {
                                console.error('bind resource texture can not be current render target');
                                validation |= VALIDATION_FAILED$1;
                            }
                            if (tex.isMipmapDirty()) {
                                validation |= VALIDATION_NEED_GENERATE_MIPMAP$1;
                            }
                            if (tex.getPendingUploads().length > 0) {
                                if (tex.isMipmapDirty()) {
                                    this._textureUploads.add(tex);
                                } else {
                                    textureUploads.push(tex);
                                }
                            }
                        }
                    }
                } else {
                    console.error(`Missing bind group (${i}) when drawing with program '${program.name}'`);
                    return VALIDATION_FAILED$1;
                }
            }
        }
        const vertexBuffers = vertexData?.getLayouts(program.vertexAttributes)?.buffers;
        if (vertexBuffers) {
            for (const buffer of vertexBuffers){
                if (buffer.buffer.getPendingUploads().length > 0) {
                    bufferUploads.push(buffer.buffer);
                }
            }
        }
        const indexBuffer = vertexData?.getIndexBuffer();
        if (indexBuffer?.getPendingUploads().length > 0) {
            bufferUploads.push(indexBuffer);
        }
        if (this._frameBuffer && this._frameBuffer.bindFlag !== this._fbBindFlag) {
            validation |= VALIDATION_NEED_NEW_PASS$1;
        }
        const needNewPass = validation & VALIDATION_NEED_NEW_PASS$1 || validation & VALIDATION_NEED_GENERATE_MIPMAP$1;
        if (bufferUploads.length > 0) {
            const bu = needNewPass ? this._bufferUploadsNext : this._bufferUploads;
            for (const buffer of bufferUploads){
                bu.add(buffer);
            }
        }
        if (textureUploads.length > 0) {
            const tu = needNewPass ? this._textureUploadsNext : this._textureUploads;
            for (const tex of textureUploads){
                tu.add(tex);
            }
        }
        return validation;
    }
    setBindGroupsForRender(renderPassEncoder, program, vertexData, bindGroups, bindGroupOffsets) {
        if (bindGroups) {
            for(let i = 0; i < 4; i++){
                if (i < program.bindGroupLayouts.length) {
                    bindGroups[i].updateVideoTextures();
                    const bindGroup = bindGroups[i].bindGroup;
                    if (!bindGroup) {
                        return false;
                    }
                    renderPassEncoder.setBindGroup(i, bindGroup, bindGroupOffsets?.[i] || undefined);
                } else {
                    renderPassEncoder.setBindGroup(i, this._device.emptyBindGroup);
                }
            }
        }
        return true;
    }
}

const VALIDATION_NEED_NEW_PASS = 1 << 0;
const VALIDATION_NEED_GENERATE_MIPMAP = 1 << 1;
const VALIDATION_FAILED = 1 << 2;
class WebGPUComputePass {
    _device;
    _bufferUploads;
    _textureUploads;
    _uploadCommandEncoder;
    _computeCommandEncoder;
    _computePassEncoder;
    constructor(device, frameBuffer){
        this._device = device;
        this._bufferUploads = new Set();
        this._textureUploads = new Set();
        this._uploadCommandEncoder = this._device.device.createCommandEncoder();
        this._computeCommandEncoder = this._device.device.createCommandEncoder();
        this._computePassEncoder = null;
    }
    get active() {
        return !!this._computePassEncoder;
    }
    isBufferUploading(buffer) {
        return !!this._bufferUploads.has(buffer);
    }
    isTextureUploading(tex) {
        return !!this._textureUploads.has(tex);
    }
    compute(program, bindGroups, bindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ) {
        const validation = this.validateCompute(program, bindGroups);
        if (validation & VALIDATION_FAILED) {
            return;
        }
        if (validation & VALIDATION_NEED_NEW_PASS || validation & VALIDATION_NEED_GENERATE_MIPMAP) {
            if (this._computePassEncoder) {
                this.end();
            }
        }
        if (validation & VALIDATION_NEED_GENERATE_MIPMAP) {
            WebGPUMipmapGenerator.generateMipmapsForBindGroups(this._device, bindGroups);
        }
        if (!this._computePassEncoder) {
            this.begin();
        }
        this.setBindGroupsForCompute(this._computePassEncoder, program, bindGroups, bindGroupOffsets);
        const pipeline = this._device.pipelineCache.fetchComputePipeline(program);
        if (pipeline) {
            this._computePassEncoder.setPipeline(pipeline);
            this._computePassEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
        }
    }
    setBindGroupsForCompute(computePassEncoder, program, bindGroups, bindGroupOffsets) {
        if (bindGroups) {
            for(let i = 0; i < 4; i++){
                if (i < program.bindGroupLayouts.length) {
                    const bindGroup = bindGroups[i].bindGroup;
                    if (!bindGroup) {
                        return false;
                    }
                    computePassEncoder.setBindGroup(i, bindGroup, bindGroupOffsets?.[i] || undefined);
                } else {
                    computePassEncoder.setBindGroup(i, this._device.emptyBindGroup);
                }
            }
        }
        return true;
    }
    begin() {
        if (this.active) {
            console.error('WebGPUComputePass.begin() failed: WebGPUComputePass.begin() has already been called');
            return;
        }
        this._uploadCommandEncoder = this._device.device.createCommandEncoder();
        this._computeCommandEncoder = this._device.device.createCommandEncoder();
        this._computePassEncoder = this._computeCommandEncoder.beginComputePass();
    }
    end() {
        if (this.active) {
            this._computePassEncoder.end();
            this._computePassEncoder = null;
            this._bufferUploads.forEach((buffer)=>buffer.beginSyncChanges(this._uploadCommandEncoder));
            this._textureUploads.forEach((tex)=>tex.beginSyncChanges(this._uploadCommandEncoder));
            this._device.device.queue.submit([
                this._uploadCommandEncoder.finish(),
                this._computeCommandEncoder.finish()
            ]);
            this._bufferUploads.forEach((buffer)=>buffer.endSyncChanges());
            this._textureUploads.forEach((tex)=>tex.endSyncChanges());
            this._bufferUploads.clear();
            this._textureUploads.clear();
            this._uploadCommandEncoder = null;
            this._computeCommandEncoder = null;
        }
    }
    validateCompute(program, bindGroups) {
        let validation = 0;
        if (bindGroups) {
            for(let i = 0; i < program.bindGroupLayouts.length; i++){
                const bindGroup = bindGroups[i];
                if (bindGroup) {
                    if (bindGroup.bindGroup) {
                        for (const ubo of bindGroup.bufferList){
                            if (ubo.disposed) {
                                validation |= VALIDATION_FAILED;
                            }
                            if (ubo.getPendingUploads().length > 0) {
                                this._bufferUploads.add(ubo);
                            }
                        }
                        for (const tex of bindGroup.textureList){
                            if (tex.disposed) {
                                validation |= VALIDATION_FAILED;
                            }
                            if (tex.isMipmapDirty()) {
                                validation |= VALIDATION_NEED_GENERATE_MIPMAP;
                            }
                            if (tex.getPendingUploads().length > 0) {
                                this._textureUploads.add(tex);
                            }
                        }
                    }
                } else {
                    console.error(`Missing bind group (${i}) when compute with program '${program.name}'`);
                    return VALIDATION_FAILED;
                }
            }
        }
        return validation;
    }
}

class CommandQueueImmediate {
    _renderPass;
    _computePass;
    constructor(device){
        this._renderPass = new WebGPURenderPass(device);
        this._computePass = new WebGPUComputePass(device);
    }
    get currentPass() {
        return this._renderPass.active ? this._renderPass : this._computePass.active ? this._computePass : null;
    }
    beginFrame() {}
    endFrame() {
        this._renderPass.end();
        this._computePass.end();
    }
    flush() {
        this._renderPass.end();
        this._computePass.end();
    }
    setFramebuffer(fb) {
        this._renderPass.setFramebuffer(fb);
    }
    getFramebuffer() {
        return this._renderPass.getFramebuffer();
    }
    getFramebufferInfo() {
        return this._renderPass.getFrameBufferInfo();
    }
    compute(program, bindGroups, bindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ) {
        this._renderPass.end();
        this._computePass.compute(program, bindGroups, bindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ);
    }
    draw(program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances) {
        this._computePass.end();
        this._renderPass.draw(program, vertexData, stateSet, bindGroups, bindGroupOffsets, primitiveType, first, count, numInstances);
    }
    setViewport(vp) {
        this._renderPass.setViewport(vp);
    }
    getViewport() {
        return this._renderPass.getViewport();
    }
    setScissor(scissor) {
        this._renderPass.setScissor(scissor);
    }
    getScissor() {
        return this._renderPass.getScissor();
    }
    clear(color, depth, stencil) {
        this._renderPass.clear(color, depth, stencil);
    }
    isBufferUploading(buffer) {
        return this._renderPass.isBufferUploading(buffer) || this._computePass.isBufferUploading(buffer);
    }
    isTextureUploading(tex) {
        return this._renderPass.isTextureUploading(tex) || this._computePass.isTextureUploading(tex);
    }
}

class WebGPUDevice extends BaseDevice {
    _context;
    _dpr;
    _device;
    _adapter;
    _deviceCaps;
    _reverseWindingOrder;
    _canRender;
    _backBufferFormat;
    _depthFormat;
    _defaultMSAAColorTexture;
    _defaultMSAAColorTextureView;
    _defaultDepthTexture;
    _defaultDepthTextureView;
    _pipelineCache;
    _bindGroupCache;
    _vertexLayoutCache;
    _samplerCache;
    _currentProgram;
    _currentVertexData;
    _currentStateSet;
    _currentBindGroups;
    _currentBindGroupOffsets;
    _commandQueue;
    _gpuObjectHashCounter;
    _gpuObjectHasher;
    _defaultRenderPassDesc;
    _sampleCount;
    _emptyBindGroup;
    constructor(backend, cvs, options){
        super(cvs, backend);
        this._dpr = Math.max(1, Math.floor(options?.dpr ?? window.devicePixelRatio));
        this._device = null;
        this._adapter = null;
        this._context = null;
        this._reverseWindingOrder = false;
        this._defaultMSAAColorTexture = null;
        this._defaultMSAAColorTextureView = null;
        this._defaultDepthTexture = null;
        this._defaultDepthTextureView = null;
        this._pipelineCache = null;
        this._bindGroupCache = null;
        this._vertexLayoutCache = null;
        this._currentProgram = null;
        this._currentVertexData = null;
        this._currentStateSet = null;
        this._currentBindGroups = [];
        this._currentBindGroupOffsets = [];
        this._defaultRenderPassDesc = null;
        this._sampleCount = options?.msaa ? 4 : 1;
        this._deviceCaps = null;
        this._gpuObjectHasher = new WeakMap();
        this._gpuObjectHashCounter = 1;
        this._emptyBindGroup = null;
        this._samplerCache = new SamplerCache$1(this);
    }
    get context() {
        return this._context;
    }
    getFrameBufferSampleCount() {
        return this.getFramebuffer()?.getSampleCount() ?? this._sampleCount;
    }
    get device() {
        return this._device;
    }
    get adapter() {
        return this._adapter;
    }
    get drawingBufferWidth() {
        return this.getDrawingBufferWidth();
    }
    get drawingBufferHeight() {
        return this.getDrawingBufferHeight();
    }
    get clientWidth() {
        return this.canvas.clientWidth;
    }
    get clientHeight() {
        return this.canvas.clientHeight;
    }
    get pipelineCache() {
        return this._pipelineCache;
    }
    get backbufferFormat() {
        return this._backBufferFormat;
    }
    get backbufferDepthFormat() {
        return this._depthFormat;
    }
    get defaultDepthTexture() {
        return this._defaultDepthTexture;
    }
    get defaultDepthTextureView() {
        return this._defaultDepthTextureView;
    }
    get defaultMSAAColorTextureView() {
        return this._defaultMSAAColorTextureView;
    }
    get defaultRenderPassDesc() {
        return this._defaultRenderPassDesc;
    }
    get sampleCount() {
        return this._sampleCount;
    }
    get currentPass() {
        return this._commandQueue.currentPass;
    }
    get emptyBindGroup() {
        return this._emptyBindGroup;
    }
    getScale() {
        return this._dpr;
    }
    isContextLost() {
        return false;
    }
    getDeviceCaps() {
        return this._deviceCaps;
    }
    getDrawingBufferWidth() {
        return this.getFramebuffer()?.getWidth() || this.canvas.width;
    }
    getDrawingBufferHeight() {
        return this.getFramebuffer()?.getHeight() || this.canvas.height;
    }
    getBackBufferWidth() {
        return this.canvas.width;
    }
    getBackBufferHeight() {
        return this.canvas.height;
    }
    async initContext() {
        if (!navigator.gpu) {
            throw new Error('No browser support for WebGPU');
        }
        this._adapter = await navigator.gpu.requestAdapter();
        if (!this._adapter) {
            throw new Error('WebGPU: requestAdapter() failed');
        }
        if (this._adapter.isFallbackAdapter) {
            console.warn('using a fallback adapter');
        }
        this._device = await this._adapter.requestDevice({
            requiredFeatures: [
                ...this._adapter.features
            ]
        });
        console.log('WebGPU device features:');
        for (const feature of this._device.features){
            console.log(` - ${feature}`);
        }
        this.device.lost.then((info)=>{
            console.error(`WebGPU device was lost: ${info.message}`);
            this._canRender = false;
        });
        this._emptyBindGroup = this.device.createBindGroup({
            layout: this.device.createBindGroupLayout({
                entries: []
            }),
            entries: []
        });
        this._context = this.canvas.getContext('webgpu') || null;
        if (!this._context) {
            this._canRender = false;
            throw new Error('WebGPU: getContext() failed');
        }
        this.canvas.width = this.canvas.clientWidth;
        this.canvas.height = this.canvas.clientHeight;
        this._deviceCaps = {
            textureCaps: new WebGPUTextureCaps(this),
            framebufferCaps: new WebGPUFramebufferCaps(this),
            miscCaps: new WebGPUMiscCaps(this),
            shaderCaps: new WebGPUShaderCaps(this)
        };
        this.configure();
        this._pipelineCache = new PipelineCache(this);
        this._bindGroupCache = new BindGroupCache(this);
        this._vertexLayoutCache = new VertexLayoutCache();
        this._commandQueue = new CommandQueueImmediate(this);
        this._canRender = true;
        this.setViewport(null);
        this.setScissor(null);
        this.on('resize', (evt)=>{
            const width = Math.max(1, Math.round(this.canvas.clientWidth * this._dpr));
            const height = Math.max(1, Math.round(this.canvas.clientHeight * this._dpr));
            if (width !== this.canvas.width || height !== this.canvas.height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this.createDefaultRenderAttachments();
                this.setViewport(null);
                this.setScissor(null);
            }
        });
        this.dispatchEvent(new DeviceResizeEvent(this.canvas.clientWidth, this.canvas.clientHeight));
    }
    clearFrameBuffer(clearColor, clearDepth, clearStencil) {
        this._commandQueue.clear(clearColor, clearDepth, clearStencil);
    }
    // factory
    createGPUTimer() {
        // throw new Error('not implemented');
        return null;
    }
    createRenderStateSet() {
        return new WebGPURenderStateSet(this);
    }
    createSampler(options) {
        return this.fetchSampler(options);
    }
    createTextureFromMipmapData(data, sRGB, options) {
        if (!data) {
            console.error(`Device.createTextureFromMipmapData() failed: invalid data`);
            return null;
        }
        if (data.isCubemap) {
            const tex = new WebGPUTextureCube(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        } else if (data.isVolume) {
            const tex = new WebGPUTexture3D(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else if (data.isArray) {
            const tex = new WebGPUTexture2DArray(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else {
            const tex = new WebGPUTexture2D(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        }
    }
    createTexture2D(format, width, height, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2D() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createEmpty(format, width, height, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromMipmapData() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromImage(element, sRGB, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromImage() failed: options.texture must be 2d texture');
            return null;
        }
        tex.loadFromElement(element, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArray(format, width, height, depth, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArray() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromMipmapData(data, options) {
        const tex = (options?.texture) ?? new WebGPUTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArrayFromMipmapData() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createWithMipmapData(data, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromImages(elements, sRGB, options) {
        if (!elements || elements.length === 0) {
            console.error('createTexture2DArrayFromImages() failed: Invalid image elements');
            return null;
        }
        let width = 0;
        let height = 0;
        for (const element of elements){
            if (width === 0 || height === 0) {
                width = element.width;
                height = element.height;
            } else if (width !== element.width || height !== element.height) {
                console.error('createTexture2DArrayFromImages() failed: Image elements must have the same size');
                return null;
            }
        }
        if (options?.texture && !options.texture.isTexture2DArray()) {
            console.error('createTexture2DArrayFromImages() failed: options.texture must be 2d array texture');
            return null;
        }
        let tex = options?.texture;
        if (tex) {
            if (tex.depth !== elements.length) {
                console.error('createTexture2DArrayFromImages() failed: Layer count of options.texture not match the given image elements');
                return null;
            }
            if (tex.width !== width || tex.height !== height) {
                console.error('createTexture2DArrayFromImages() failed: Size of options.texture not match the given image elements');
                return null;
            }
        } else {
            tex = this.createTexture2DArray(sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm', width, height, elements.length, options);
            for(let i = 0; i < elements.length; i++){
                tex.updateFromElement(elements[i], 0, 0, i, 0, 0, width, height);
            }
        }
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture3D(format, width, height, depth, options) {
        const tex = (options?.texture) ?? new WebGPUTexture3D(this);
        if (!tex.isTexture3D()) {
            console.error('createTexture3D() failed: options.texture must be 3d texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTexture(format, size, options) {
        const tex = (options?.texture) ?? new WebGPUTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTexture() failed: options.texture must be cube texture');
            return null;
        }
        tex.createEmpty(format, size, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTextureFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGPUTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTextureFromMipmapData() failed: options.texture must be cube texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTextureVideo(el, samplerOptions) {
        const tex = new WebGPUTextureVideo(this, el);
        tex.samplerOptions = samplerOptions ?? null;
        return tex;
    }
    createGPUProgram(params) {
        return new WebGPUProgram(this, params);
    }
    createBindGroup(layout) {
        return new WebGPUBindGroup(this, layout);
    }
    createBuffer(sizeInBytes, options) {
        return new WebGPUBuffer(this, this.parseBufferOptions(options), sizeInBytes);
    }
    createIndexBuffer(data, options) {
        return new WebGPUIndexBuffer(this, data, this.parseBufferOptions(options, 'index'));
    }
    createStructuredBuffer(structureType, options, data) {
        return new WebGPUStructuredBuffer(this, structureType, this.parseBufferOptions(options), data);
    }
    createVertexLayout(options) {
        return new WebGPUVertexLayout(this, options);
    }
    createFrameBuffer(colorAttachments, depthAttachement, options) {
        return new WebGPUFrameBuffer(this, colorAttachments, depthAttachement, options);
    }
    setBindGroup(index, bindGroup, dynamicOffsets) {
        this._currentBindGroups[index] = bindGroup;
        this._currentBindGroupOffsets[index] = dynamicOffsets || null;
    }
    getBindGroup(index) {
        return [
            this._currentBindGroups[index],
            this._currentBindGroupOffsets[index]
        ];
    }
    // render related
    setViewport(vp) {
        this._commandQueue.setViewport(vp);
    }
    getViewport() {
        return this._commandQueue.getViewport();
    }
    setScissor(scissor) {
        this._commandQueue.setScissor(scissor);
    }
    getScissor() {
        return this._commandQueue.getScissor();
    }
    setProgram(program) {
        this._currentProgram = program;
    }
    getProgram() {
        return this._currentProgram;
    }
    setVertexLayout(vertexData) {
        this._currentVertexData = vertexData;
    }
    getVertexLayout() {
        return this._currentVertexData;
    }
    setRenderStates(stateSet) {
        this._currentStateSet = stateSet;
    }
    getRenderStates() {
        return this._currentStateSet;
    }
    setFramebuffer(rt) {
        this._commandQueue.setFramebuffer(rt);
    }
    getFramebuffer() {
        return this._commandQueue.getFramebuffer() ?? null;
    }
    reverseVertexWindingOrder(reverse) {
        this._reverseWindingOrder = !!reverse;
    }
    isWindingOrderReversed() {
        return this._reverseWindingOrder;
    }
    /** @internal */ isBufferUploading(buffer) {
        return this._commandQueue.isBufferUploading(buffer);
    }
    /** @internal */ isTextureUploading(tex) {
        return this._commandQueue.isTextureUploading(tex);
    }
    /** @internal */ getFramebufferInfo() {
        return this._commandQueue.getFramebufferInfo();
    }
    /** @internal */ gpuGetObjectHash(obj) {
        return this._gpuObjectHasher.get(obj);
    }
    /** @internal */ gpuCreateTexture(desc) {
        const tex = this._device.createTexture(desc);
        if (tex) {
            this._gpuObjectHasher.set(tex, ++this._gpuObjectHashCounter);
        }
        return tex;
    }
    /** @internal */ gpuImportExternalTexture(el) {
        const tex = this._device.importExternalTexture({
            source: el
        });
        if (tex) {
            this._gpuObjectHasher.set(tex, ++this._gpuObjectHashCounter);
        }
        return tex;
    }
    /** @internal */ gpuCreateSampler(desc) {
        const sampler = this._device.createSampler(desc);
        if (sampler) {
            this._gpuObjectHasher.set(sampler, ++this._gpuObjectHashCounter);
        }
        return sampler;
    }
    /** @internal */ gpuCreateBindGroup(desc) {
        const bindGroup = this._device.createBindGroup(desc);
        if (bindGroup) {
            this._gpuObjectHasher.set(bindGroup, ++this._gpuObjectHashCounter);
        }
        return bindGroup;
    }
    /** @internal */ gpuCreateBuffer(desc) {
        const buffer = this._device.createBuffer(desc);
        if (buffer) {
            this._gpuObjectHasher.set(buffer, ++this._gpuObjectHashCounter);
        }
        return buffer;
    }
    /** @internal */ gpuCreateTextureView(texture, desc) {
        const view = texture?.createView(desc);
        if (view) {
            this._gpuObjectHasher.set(view, ++this._gpuObjectHashCounter);
        }
        return view;
    }
    /** @internal */ gpuCreateRenderPipeline(desc) {
        const pipeline = this._device.createRenderPipeline(desc);
        if (pipeline) {
            this._gpuObjectHasher.set(pipeline, ++this._gpuObjectHashCounter);
        }
        return pipeline;
    }
    /** @internal */ gpuCreateComputePipeline(desc) {
        const pipeline = this._device.createComputePipeline(desc);
        if (pipeline) {
            this._gpuObjectHasher.set(pipeline, ++this._gpuObjectHashCounter);
        }
        return pipeline;
    }
    /** @internal */ fetchVertexLayout(hash) {
        return this._vertexLayoutCache.fetchVertexLayout(hash);
    }
    /** @internal */ fetchSampler(options) {
        return this._samplerCache.fetchSampler(options);
    }
    /** @internal */ fetchBindGroupLayout(desc) {
        return this._bindGroupCache.fetchBindGroupLayout(desc);
    }
    flush() {
        this._commandQueue.flush();
    }
    async readPixels(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? (fb.getColorAttachments()[index]?.object) : this.context.getCurrentTexture();
        const texFormat = fb ? fb.getColorAttachments()[index]?.format : textureFormatInvMap[this._backBufferFormat];
        if (colorAttachment && texFormat) {
            const pixelSize = getTextureFormatBlockSize(texFormat);
            const bufferSize = w * h * pixelSize;
            const stagingBuffer = this.createBuffer(bufferSize, {
                usage: 'read'
            });
            this.readPixelsToBuffer(0, x, y, w, h, stagingBuffer);
            const data = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            await stagingBuffer.getBufferSubData(data);
            stagingBuffer.dispose();
        } else {
            console.error('readPixels() failed: no color attachment0 or unrecoganized color attachment format');
        }
    }
    readPixelsToBuffer(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? (fb.getColorAttachments()[index]?.object) : this.context.getCurrentTexture();
        const texFormat = fb ? fb.getColorAttachments()[index]?.format : textureFormatInvMap[this._backBufferFormat];
        const texWidth = fb ? fb.getColorAttachments()[index]?.width : this.getDrawingBufferWidth();
        const texHeight = fb ? fb.getColorAttachments()[index]?.height : this.getDrawingBufferHeight();
        if (colorAttachment && texFormat) {
            this.flush();
            WebGPUBaseTexture.copyTexturePixelsToBuffer(this._device, colorAttachment, texWidth, texHeight, texFormat, x, y, w, h, 0, 0, buffer);
        } else {
            console.error('readPixelsToBuffer() failed: no color attachment0 or unrecoganized color attachment format');
        }
    }
    looseContext() {
    // not implemented
    }
    restoreContext() {
    // not implemented
    }
    /** @internal */ onBeginFrame() {
        if (this._canRender) {
            this._commandQueue.beginFrame();
            return true;
        } else {
            return false;
        }
    }
    /** @internal */ onEndFrame() {
        this._commandQueue.endFrame();
    }
    /** @internal */ _draw(primitiveType, first, count) {
        this._commandQueue.draw(this._currentProgram, this._currentVertexData, this._currentStateSet, this._currentBindGroups, this._currentBindGroupOffsets, primitiveType, first, count, 1);
    }
    /** @internal */ _drawInstanced(primitiveType, first, count, numInstances) {
        this._commandQueue.draw(this._currentProgram, this._currentVertexData, this._currentStateSet, this._currentBindGroups, this._currentBindGroupOffsets, primitiveType, first, count, numInstances);
    }
    /** @internal */ _compute(workgroupCountX, workgroupCountY, workgroupCountZ) {
        this._commandQueue.compute(this._currentProgram, this._currentBindGroups, this._currentBindGroupOffsets, workgroupCountX, workgroupCountY, workgroupCountZ);
    }
    configure() {
        this._backBufferFormat = navigator.gpu.getPreferredCanvasFormat();
        this._depthFormat = this._deviceCaps.framebufferCaps.supportDepth32floatStencil8 ? 'depth32float-stencil8' : 'depth24plus-stencil8';
        this._context.configure({
            device: this._device,
            format: this._backBufferFormat,
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            alphaMode: 'opaque',
            colorSpace: 'srgb'
        });
        this.createDefaultRenderAttachments();
    }
    createDefaultRenderAttachments() {
        const width = Math.max(1, this.canvas.width);
        const height = Math.max(1, this.canvas.height);
        this._defaultMSAAColorTexture?.destroy();
        this._defaultMSAAColorTexture = null;
        this._defaultMSAAColorTextureView = null;
        this._defaultDepthTexture?.destroy();
        this._defaultDepthTexture = null;
        this._defaultDepthTextureView = null;
        if (this._sampleCount > 1) {
            this._defaultMSAAColorTexture = this.gpuCreateTexture({
                size: {
                    width,
                    height,
                    depthOrArrayLayers: 1
                },
                format: this._backBufferFormat,
                dimension: '2d',
                mipLevelCount: 1,
                sampleCount: this._sampleCount,
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            this._defaultMSAAColorTextureView = this._defaultMSAAColorTexture.createView();
        }
        this._defaultDepthTexture = this.gpuCreateTexture({
            size: {
                width,
                height,
                depthOrArrayLayers: 1
            },
            format: this._depthFormat,
            dimension: '2d',
            mipLevelCount: 1,
            sampleCount: this._sampleCount,
            usage: GPUTextureUsage.RENDER_ATTACHMENT
        });
        this._defaultDepthTextureView = this._defaultDepthTexture.createView();
        this._defaultRenderPassDesc = {
            label: `mainRenderPass:${this._sampleCount}`,
            colorAttachments: [
                {
                    view: this._sampleCount > 1 ? this._defaultMSAAColorTextureView : null,
                    resolveTarget: undefined,
                    loadOp: 'clear',
                    clearValue: [
                        0,
                        0,
                        0,
                        0
                    ],
                    storeOp: 'store'
                }
            ],
            depthStencilAttachment: {
                view: this._defaultDepthTextureView,
                depthLoadOp: 'clear',
                depthClearValue: 1,
                depthStoreOp: 'store',
                stencilLoadOp: 'clear',
                stencilClearValue: 0,
                stencilStoreOp: 'store'
            }
        };
    }
}

/**
 * The WebGPU backend
 * @public
 */ const backendWebGPU = {
    typeName () {
        return 'webgpu';
    },
    supported () {
        return !!window.GPU && navigator.gpu instanceof window.GPU;
    },
    async createDevice (cvs, options) {
        try {
            const factory = makeEventTarget(WebGPUDevice)();
            const device = new factory(this, cvs, options);
            await device.initContext();
            device.setViewport();
            device.setScissor();
            return device;
        } catch (err) {
            console.error(err);
            return null;
        }
    }
};

/**
 * WebGL constant value definitions
 */ var WebGLEnum;
(function(WebGLEnum) {
    WebGLEnum[WebGLEnum["READ_BUFFER"] = 0xc02] = "READ_BUFFER";
    WebGLEnum[WebGLEnum["UNPACK_ROW_LENGTH"] = 0xcf2] = "UNPACK_ROW_LENGTH";
    WebGLEnum[WebGLEnum["UNPACK_SKIP_ROWS"] = 0xcf3] = "UNPACK_SKIP_ROWS";
    WebGLEnum[WebGLEnum["UNPACK_SKIP_PIXELS"] = 0xcf4] = "UNPACK_SKIP_PIXELS";
    WebGLEnum[WebGLEnum["PACK_ROW_LENGTH"] = 0xd02] = "PACK_ROW_LENGTH";
    WebGLEnum[WebGLEnum["PACK_SKIP_ROWS"] = 0xd03] = "PACK_SKIP_ROWS";
    WebGLEnum[WebGLEnum["PACK_SKIP_PIXELS"] = 0xd04] = "PACK_SKIP_PIXELS";
    WebGLEnum[WebGLEnum["COLOR"] = 0x1800] = "COLOR";
    WebGLEnum[WebGLEnum["DEPTH"] = 0x1801] = "DEPTH";
    WebGLEnum[WebGLEnum["STENCIL"] = 0x1802] = "STENCIL";
    WebGLEnum[WebGLEnum["RED"] = 0x1903] = "RED";
    WebGLEnum[WebGLEnum["RGB8"] = 0x8051] = "RGB8";
    WebGLEnum[WebGLEnum["RGBA8"] = 0x8058] = "RGBA8";
    WebGLEnum[WebGLEnum["RGB10_A2"] = 0x8059] = "RGB10_A2";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_3D"] = 0x806a] = "TEXTURE_BINDING_3D";
    WebGLEnum[WebGLEnum["UNPACK_SKIP_IMAGES"] = 0x806d] = "UNPACK_SKIP_IMAGES";
    WebGLEnum[WebGLEnum["UNPACK_IMAGE_HEIGHT"] = 0x806e] = "UNPACK_IMAGE_HEIGHT";
    WebGLEnum[WebGLEnum["TEXTURE_3D"] = 0x806f] = "TEXTURE_3D";
    WebGLEnum[WebGLEnum["TEXTURE_WRAP_R"] = 0x8072] = "TEXTURE_WRAP_R";
    WebGLEnum[WebGLEnum["MAX_3D_TEXTURE_SIZE"] = 0x8073] = "MAX_3D_TEXTURE_SIZE";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_2_10_10_10_REV"] = 0x8368] = "UNSIGNED_INT_2_10_10_10_REV";
    WebGLEnum[WebGLEnum["MAX_ELEMENTS_VERTICES"] = 0x80e8] = "MAX_ELEMENTS_VERTICES";
    WebGLEnum[WebGLEnum["MAX_ELEMENTS_INDICES"] = 0x80e9] = "MAX_ELEMENTS_INDICES";
    WebGLEnum[WebGLEnum["TEXTURE_MIN_LOD"] = 0x813a] = "TEXTURE_MIN_LOD";
    WebGLEnum[WebGLEnum["TEXTURE_MAX_LOD"] = 0x813b] = "TEXTURE_MAX_LOD";
    WebGLEnum[WebGLEnum["TEXTURE_BASE_LEVEL"] = 0x813c] = "TEXTURE_BASE_LEVEL";
    WebGLEnum[WebGLEnum["TEXTURE_MAX_LEVEL"] = 0x813d] = "TEXTURE_MAX_LEVEL";
    WebGLEnum[WebGLEnum["MIN"] = 0x8007] = "MIN";
    WebGLEnum[WebGLEnum["MAX"] = 0x8008] = "MAX";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT24"] = 0x81a6] = "DEPTH_COMPONENT24";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_LOD_BIAS"] = 0x84fd] = "MAX_TEXTURE_LOD_BIAS";
    WebGLEnum[WebGLEnum["TEXTURE_COMPARE_MODE"] = 0x884c] = "TEXTURE_COMPARE_MODE";
    WebGLEnum[WebGLEnum["TEXTURE_COMPARE_FUNC"] = 0x884d] = "TEXTURE_COMPARE_FUNC";
    WebGLEnum[WebGLEnum["CURRENT_QUERY"] = 0x8865] = "CURRENT_QUERY";
    WebGLEnum[WebGLEnum["QUERY_RESULT"] = 0x8866] = "QUERY_RESULT";
    WebGLEnum[WebGLEnum["QUERY_RESULT_AVAILABLE"] = 0x8867] = "QUERY_RESULT_AVAILABLE";
    WebGLEnum[WebGLEnum["STREAM_READ"] = 0x88e1] = "STREAM_READ";
    WebGLEnum[WebGLEnum["STREAM_COPY"] = 0x88e2] = "STREAM_COPY";
    WebGLEnum[WebGLEnum["STATIC_READ"] = 0x88e5] = "STATIC_READ";
    WebGLEnum[WebGLEnum["STATIC_COPY"] = 0x88e6] = "STATIC_COPY";
    WebGLEnum[WebGLEnum["DYNAMIC_READ"] = 0x88e9] = "DYNAMIC_READ";
    WebGLEnum[WebGLEnum["DYNAMIC_COPY"] = 0x88ea] = "DYNAMIC_COPY";
    WebGLEnum[WebGLEnum["MAX_DRAW_BUFFERS"] = 0x8824] = "MAX_DRAW_BUFFERS";
    WebGLEnum[WebGLEnum["DRAW_BUFFER0"] = 0x8825] = "DRAW_BUFFER0";
    WebGLEnum[WebGLEnum["DRAW_BUFFER1"] = 0x8826] = "DRAW_BUFFER1";
    WebGLEnum[WebGLEnum["DRAW_BUFFER2"] = 0x8827] = "DRAW_BUFFER2";
    WebGLEnum[WebGLEnum["DRAW_BUFFER3"] = 0x8828] = "DRAW_BUFFER3";
    WebGLEnum[WebGLEnum["DRAW_BUFFER4"] = 0x8829] = "DRAW_BUFFER4";
    WebGLEnum[WebGLEnum["DRAW_BUFFER5"] = 0x882a] = "DRAW_BUFFER5";
    WebGLEnum[WebGLEnum["DRAW_BUFFER6"] = 0x882b] = "DRAW_BUFFER6";
    WebGLEnum[WebGLEnum["DRAW_BUFFER7"] = 0x882c] = "DRAW_BUFFER7";
    WebGLEnum[WebGLEnum["DRAW_BUFFER8"] = 0x882d] = "DRAW_BUFFER8";
    WebGLEnum[WebGLEnum["DRAW_BUFFER9"] = 0x882e] = "DRAW_BUFFER9";
    WebGLEnum[WebGLEnum["DRAW_BUFFER10"] = 0x882f] = "DRAW_BUFFER10";
    WebGLEnum[WebGLEnum["DRAW_BUFFER11"] = 0x8830] = "DRAW_BUFFER11";
    WebGLEnum[WebGLEnum["DRAW_BUFFER12"] = 0x8831] = "DRAW_BUFFER12";
    WebGLEnum[WebGLEnum["DRAW_BUFFER13"] = 0x8832] = "DRAW_BUFFER13";
    WebGLEnum[WebGLEnum["DRAW_BUFFER14"] = 0x8833] = "DRAW_BUFFER14";
    WebGLEnum[WebGLEnum["DRAW_BUFFER15"] = 0x8834] = "DRAW_BUFFER15";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 0x8b49] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_VERTEX_UNIFORM_COMPONENTS"] = 0x8b4a] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["SAMPLER_3D"] = 0x8b5f] = "SAMPLER_3D";
    WebGLEnum[WebGLEnum["SAMPLER_2D_SHADOW"] = 0x8b62] = "SAMPLER_2D_SHADOW";
    WebGLEnum[WebGLEnum["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 0x8b8b] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    WebGLEnum[WebGLEnum["PIXEL_PACK_BUFFER"] = 0x88eb] = "PIXEL_PACK_BUFFER";
    WebGLEnum[WebGLEnum["PIXEL_UNPACK_BUFFER"] = 0x88ec] = "PIXEL_UNPACK_BUFFER";
    WebGLEnum[WebGLEnum["PIXEL_PACK_BUFFER_BINDING"] = 0x88ed] = "PIXEL_PACK_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["PIXEL_UNPACK_BUFFER_BINDING"] = 0x88ef] = "PIXEL_UNPACK_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["FLOAT_MAT2x3"] = 0x8b65] = "FLOAT_MAT2x3";
    WebGLEnum[WebGLEnum["FLOAT_MAT2x4"] = 0x8b66] = "FLOAT_MAT2x4";
    WebGLEnum[WebGLEnum["FLOAT_MAT3x2"] = 0x8b67] = "FLOAT_MAT3x2";
    WebGLEnum[WebGLEnum["FLOAT_MAT3x4"] = 0x8b68] = "FLOAT_MAT3x4";
    WebGLEnum[WebGLEnum["FLOAT_MAT4x2"] = 0x8b69] = "FLOAT_MAT4x2";
    WebGLEnum[WebGLEnum["FLOAT_MAT4x3"] = 0x8b6a] = "FLOAT_MAT4x3";
    WebGLEnum[WebGLEnum["SRGB"] = 0x8c40] = "SRGB";
    WebGLEnum[WebGLEnum["SRGB8"] = 0x8c41] = "SRGB8";
    WebGLEnum[WebGLEnum["SRGB_ALPHA"] = 0x8c42] = "SRGB_ALPHA";
    WebGLEnum[WebGLEnum["SRGB8_ALPHA8"] = 0x8c43] = "SRGB8_ALPHA8";
    WebGLEnum[WebGLEnum["COMPARE_REF_TO_TEXTURE"] = 0x884e] = "COMPARE_REF_TO_TEXTURE";
    WebGLEnum[WebGLEnum["RGBA32F"] = 0x8814] = "RGBA32F";
    WebGLEnum[WebGLEnum["RGB32F"] = 0x8815] = "RGB32F";
    WebGLEnum[WebGLEnum["RGBA16F"] = 0x881a] = "RGBA16F";
    WebGLEnum[WebGLEnum["RGB16F"] = 0x881b] = "RGB16F";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_INTEGER"] = 0x88fd] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    WebGLEnum[WebGLEnum["MAX_ARRAY_TEXTURE_LAYERS"] = 0x88ff] = "MAX_ARRAY_TEXTURE_LAYERS";
    WebGLEnum[WebGLEnum["MIN_PROGRAM_TEXEL_OFFSET"] = 0x8904] = "MIN_PROGRAM_TEXEL_OFFSET";
    WebGLEnum[WebGLEnum["MAX_PROGRAM_TEXEL_OFFSET"] = 0x8905] = "MAX_PROGRAM_TEXEL_OFFSET";
    WebGLEnum[WebGLEnum["MAX_VARYING_COMPONENTS"] = 0x8b4b] = "MAX_VARYING_COMPONENTS";
    WebGLEnum[WebGLEnum["TEXTURE_2D_ARRAY"] = 0x8c1a] = "TEXTURE_2D_ARRAY";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_2D_ARRAY"] = 0x8c1d] = "TEXTURE_BINDING_2D_ARRAY";
    WebGLEnum[WebGLEnum["R11F_G11F_B10F"] = 0x8c3a] = "R11F_G11F_B10F";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_10F_11F_11F_REV"] = 0x8c3b] = "UNSIGNED_INT_10F_11F_11F_REV";
    WebGLEnum[WebGLEnum["RGB9_E5"] = 0x8c3d] = "RGB9_E5";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_5_9_9_9_REV"] = 0x8c3e] = "UNSIGNED_INT_5_9_9_9_REV";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 0x8c7f] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    WebGLEnum[WebGLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 0x8c80] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_VARYINGS"] = 0x8c83] = "TRANSFORM_FEEDBACK_VARYINGS";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_START"] = 0x8c84] = "TRANSFORM_FEEDBACK_BUFFER_START";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 0x8c85] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 0x8c88] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    WebGLEnum[WebGLEnum["RASTERIZER_DISCARD"] = 0x8c89] = "RASTERIZER_DISCARD";
    WebGLEnum[WebGLEnum["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 0x8c8a] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 0x8c8b] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    WebGLEnum[WebGLEnum["INTERLEAVED_ATTRIBS"] = 0x8c8c] = "INTERLEAVED_ATTRIBS";
    WebGLEnum[WebGLEnum["SEPARATE_ATTRIBS"] = 0x8c8d] = "SEPARATE_ATTRIBS";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER"] = 0x8c8e] = "TRANSFORM_FEEDBACK_BUFFER";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 0x8c8f] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["RGBA32UI"] = 0x8d70] = "RGBA32UI";
    WebGLEnum[WebGLEnum["RGB32UI"] = 0x8d71] = "RGB32UI";
    WebGLEnum[WebGLEnum["RGBA16UI"] = 0x8d76] = "RGBA16UI";
    WebGLEnum[WebGLEnum["RGB16UI"] = 0x8d77] = "RGB16UI";
    WebGLEnum[WebGLEnum["RGBA8UI"] = 0x8d7c] = "RGBA8UI";
    WebGLEnum[WebGLEnum["RGB8UI"] = 0x8d7d] = "RGB8UI";
    WebGLEnum[WebGLEnum["RGBA32I"] = 0x8d82] = "RGBA32I";
    WebGLEnum[WebGLEnum["RGB32I"] = 0x8d83] = "RGB32I";
    WebGLEnum[WebGLEnum["RGBA16I"] = 0x8d88] = "RGBA16I";
    WebGLEnum[WebGLEnum["RGB16I"] = 0x8d89] = "RGB16I";
    WebGLEnum[WebGLEnum["RGBA8I"] = 0x8d8e] = "RGBA8I";
    WebGLEnum[WebGLEnum["RGB8I"] = 0x8d8f] = "RGB8I";
    WebGLEnum[WebGLEnum["RED_INTEGER"] = 0x8d94] = "RED_INTEGER";
    WebGLEnum[WebGLEnum["RGB_INTEGER"] = 0x8d98] = "RGB_INTEGER";
    WebGLEnum[WebGLEnum["RGBA_INTEGER"] = 0x8d99] = "RGBA_INTEGER";
    WebGLEnum[WebGLEnum["SAMPLER_2D_ARRAY"] = 0x8dc1] = "SAMPLER_2D_ARRAY";
    WebGLEnum[WebGLEnum["SAMPLER_2D_ARRAY_SHADOW"] = 0x8dc4] = "SAMPLER_2D_ARRAY_SHADOW";
    WebGLEnum[WebGLEnum["SAMPLER_CUBE_SHADOW"] = 0x8dc5] = "SAMPLER_CUBE_SHADOW";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_VEC2"] = 0x8dc6] = "UNSIGNED_INT_VEC2";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_VEC3"] = 0x8dc7] = "UNSIGNED_INT_VEC3";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_VEC4"] = 0x8dc8] = "UNSIGNED_INT_VEC4";
    WebGLEnum[WebGLEnum["INT_SAMPLER_2D"] = 0x8dca] = "INT_SAMPLER_2D";
    WebGLEnum[WebGLEnum["INT_SAMPLER_3D"] = 0x8dcb] = "INT_SAMPLER_3D";
    WebGLEnum[WebGLEnum["INT_SAMPLER_CUBE"] = 0x8dcc] = "INT_SAMPLER_CUBE";
    WebGLEnum[WebGLEnum["INT_SAMPLER_2D_ARRAY"] = 0x8dcf] = "INT_SAMPLER_2D_ARRAY";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_2D"] = 0x8dd2] = "UNSIGNED_INT_SAMPLER_2D";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_3D"] = 0x8dd3] = "UNSIGNED_INT_SAMPLER_3D";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_CUBE"] = 0x8dd4] = "UNSIGNED_INT_SAMPLER_CUBE";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 0x8dd7] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT32F"] = 0x8cac] = "DEPTH_COMPONENT32F";
    WebGLEnum[WebGLEnum["DEPTH32F_STENCIL8"] = 0x8cad] = "DEPTH32F_STENCIL8";
    WebGLEnum[WebGLEnum["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 0x8dad] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 0x8210] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 0x8211] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 0x8212] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 0x8213] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 0x8214] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 0x8215] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 0x8216] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 0x8217] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_DEFAULT"] = 0x8218] = "FRAMEBUFFER_DEFAULT";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_24_8"] = 0x84fa] = "UNSIGNED_INT_24_8";
    WebGLEnum[WebGLEnum["DEPTH24_STENCIL8"] = 0x88f0] = "DEPTH24_STENCIL8";
    WebGLEnum[WebGLEnum["UNSIGNED_NORMALIZED"] = 0x8c17] = "UNSIGNED_NORMALIZED";
    WebGLEnum[WebGLEnum["DRAW_FRAMEBUFFER_BINDING"] = 0x8ca6] = "DRAW_FRAMEBUFFER_BINDING";
    WebGLEnum[WebGLEnum["READ_FRAMEBUFFER"] = 0x8ca8] = "READ_FRAMEBUFFER";
    WebGLEnum[WebGLEnum["DRAW_FRAMEBUFFER"] = 0x8ca9] = "DRAW_FRAMEBUFFER";
    WebGLEnum[WebGLEnum["READ_FRAMEBUFFER_BINDING"] = 0x8caa] = "READ_FRAMEBUFFER_BINDING";
    WebGLEnum[WebGLEnum["RENDERBUFFER_SAMPLES"] = 0x8cab] = "RENDERBUFFER_SAMPLES";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 0x8cd4] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    WebGLEnum[WebGLEnum["MAX_COLOR_ATTACHMENTS"] = 0x8cdf] = "MAX_COLOR_ATTACHMENTS";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT1"] = 0x8ce1] = "COLOR_ATTACHMENT1";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT2"] = 0x8ce2] = "COLOR_ATTACHMENT2";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT3"] = 0x8ce3] = "COLOR_ATTACHMENT3";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT4"] = 0x8ce4] = "COLOR_ATTACHMENT4";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT5"] = 0x8ce5] = "COLOR_ATTACHMENT5";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT6"] = 0x8ce6] = "COLOR_ATTACHMENT6";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT7"] = 0x8ce7] = "COLOR_ATTACHMENT7";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT8"] = 0x8ce8] = "COLOR_ATTACHMENT8";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT9"] = 0x8ce9] = "COLOR_ATTACHMENT9";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT10"] = 0x8cea] = "COLOR_ATTACHMENT10";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT11"] = 0x8ceb] = "COLOR_ATTACHMENT11";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT12"] = 0x8cec] = "COLOR_ATTACHMENT12";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT13"] = 0x8ced] = "COLOR_ATTACHMENT13";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT14"] = 0x8cee] = "COLOR_ATTACHMENT14";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT15"] = 0x8cef] = "COLOR_ATTACHMENT15";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 0x8d56] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    WebGLEnum[WebGLEnum["MAX_SAMPLES"] = 0x8d57] = "MAX_SAMPLES";
    WebGLEnum[WebGLEnum["HALF_FLOAT"] = 0x140b] = "HALF_FLOAT";
    WebGLEnum[WebGLEnum["RG"] = 0x8227] = "RG";
    WebGLEnum[WebGLEnum["RG_INTEGER"] = 0x8228] = "RG_INTEGER";
    WebGLEnum[WebGLEnum["R8"] = 0x8229] = "R8";
    WebGLEnum[WebGLEnum["RG8"] = 0x822b] = "RG8";
    WebGLEnum[WebGLEnum["R16F"] = 0x822d] = "R16F";
    WebGLEnum[WebGLEnum["R32F"] = 0x822e] = "R32F";
    WebGLEnum[WebGLEnum["RG16F"] = 0x822f] = "RG16F";
    WebGLEnum[WebGLEnum["RG32F"] = 0x8230] = "RG32F";
    WebGLEnum[WebGLEnum["R8I"] = 0x8231] = "R8I";
    WebGLEnum[WebGLEnum["R8UI"] = 0x8232] = "R8UI";
    WebGLEnum[WebGLEnum["R16I"] = 0x8233] = "R16I";
    WebGLEnum[WebGLEnum["R16UI"] = 0x8234] = "R16UI";
    WebGLEnum[WebGLEnum["R32I"] = 0x8235] = "R32I";
    WebGLEnum[WebGLEnum["R32UI"] = 0x8236] = "R32UI";
    WebGLEnum[WebGLEnum["RG8I"] = 0x8237] = "RG8I";
    WebGLEnum[WebGLEnum["RG8UI"] = 0x8238] = "RG8UI";
    WebGLEnum[WebGLEnum["RG16I"] = 0x8239] = "RG16I";
    WebGLEnum[WebGLEnum["RG16UI"] = 0x823a] = "RG16UI";
    WebGLEnum[WebGLEnum["RG32I"] = 0x823b] = "RG32I";
    WebGLEnum[WebGLEnum["RG32UI"] = 0x823c] = "RG32UI";
    WebGLEnum[WebGLEnum["VERTEX_ARRAY_BINDING"] = 0x85b5] = "VERTEX_ARRAY_BINDING";
    WebGLEnum[WebGLEnum["R8_SNORM"] = 0x8f94] = "R8_SNORM";
    WebGLEnum[WebGLEnum["RG8_SNORM"] = 0x8f95] = "RG8_SNORM";
    WebGLEnum[WebGLEnum["RGB8_SNORM"] = 0x8f96] = "RGB8_SNORM";
    WebGLEnum[WebGLEnum["RGBA8_SNORM"] = 0x8f97] = "RGBA8_SNORM";
    WebGLEnum[WebGLEnum["SIGNED_NORMALIZED"] = 0x8f9c] = "SIGNED_NORMALIZED";
    WebGLEnum[WebGLEnum["COPY_READ_BUFFER"] = 0x8f36] = "COPY_READ_BUFFER";
    WebGLEnum[WebGLEnum["COPY_WRITE_BUFFER"] = 0x8f37] = "COPY_WRITE_BUFFER";
    WebGLEnum[WebGLEnum["COPY_READ_BUFFER_BINDING"] = 0x8f36] = "COPY_READ_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["COPY_WRITE_BUFFER_BINDING"] = 0x8f37] = "COPY_WRITE_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER"] = 0x8a11] = "UNIFORM_BUFFER";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_BINDING"] = 0x8a28] = "UNIFORM_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_START"] = 0x8a29] = "UNIFORM_BUFFER_START";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_SIZE"] = 0x8a2a] = "UNIFORM_BUFFER_SIZE";
    WebGLEnum[WebGLEnum["MAX_VERTEX_UNIFORM_BLOCKS"] = 0x8a2b] = "MAX_VERTEX_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 0x8a2d] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["MAX_COMBINED_UNIFORM_BLOCKS"] = 0x8a2e] = "MAX_COMBINED_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["MAX_UNIFORM_BUFFER_BINDINGS"] = 0x8a2f] = "MAX_UNIFORM_BUFFER_BINDINGS";
    WebGLEnum[WebGLEnum["MAX_UNIFORM_BLOCK_SIZE"] = 0x8a30] = "MAX_UNIFORM_BLOCK_SIZE";
    WebGLEnum[WebGLEnum["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 0x8a31] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 0x8a33] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 0x8a34] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    WebGLEnum[WebGLEnum["ACTIVE_UNIFORM_BLOCKS"] = 0x8a36] = "ACTIVE_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["UNIFORM_TYPE"] = 0x8a37] = "UNIFORM_TYPE";
    WebGLEnum[WebGLEnum["UNIFORM_SIZE"] = 0x8a38] = "UNIFORM_SIZE";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_INDEX"] = 0x8a3a] = "UNIFORM_BLOCK_INDEX";
    WebGLEnum[WebGLEnum["UNIFORM_OFFSET"] = 0x8a3b] = "UNIFORM_OFFSET";
    WebGLEnum[WebGLEnum["UNIFORM_ARRAY_STRIDE"] = 0x8a3c] = "UNIFORM_ARRAY_STRIDE";
    WebGLEnum[WebGLEnum["UNIFORM_MATRIX_STRIDE"] = 0x8a3d] = "UNIFORM_MATRIX_STRIDE";
    WebGLEnum[WebGLEnum["UNIFORM_IS_ROW_MAJOR"] = 0x8a3e] = "UNIFORM_IS_ROW_MAJOR";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_BINDING"] = 0x8a3f] = "UNIFORM_BLOCK_BINDING";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_DATA_SIZE"] = 0x8a40] = "UNIFORM_BLOCK_DATA_SIZE";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 0x8a42] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 0x8a43] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 0x8a44] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 0x8a46] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    WebGLEnum[WebGLEnum["INVALID_INDEX"] = 0xffffffff] = "INVALID_INDEX";
    WebGLEnum[WebGLEnum["MAX_VERTEX_OUTPUT_COMPONENTS"] = 0x9122] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_INPUT_COMPONENTS"] = 0x9125] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_SERVER_WAIT_TIMEOUT"] = 0x9111] = "MAX_SERVER_WAIT_TIMEOUT";
    WebGLEnum[WebGLEnum["OBJECT_TYPE"] = 0x9112] = "OBJECT_TYPE";
    WebGLEnum[WebGLEnum["SYNC_CONDITION"] = 0x9113] = "SYNC_CONDITION";
    WebGLEnum[WebGLEnum["SYNC_STATUS"] = 0x9114] = "SYNC_STATUS";
    WebGLEnum[WebGLEnum["SYNC_FLAGS"] = 0x9115] = "SYNC_FLAGS";
    WebGLEnum[WebGLEnum["SYNC_FENCE"] = 0x9116] = "SYNC_FENCE";
    WebGLEnum[WebGLEnum["SYNC_GPU_COMMANDS_COMPLETE"] = 0x9117] = "SYNC_GPU_COMMANDS_COMPLETE";
    WebGLEnum[WebGLEnum["UNSIGNALED"] = 0x9118] = "UNSIGNALED";
    WebGLEnum[WebGLEnum["SIGNALED"] = 0x9119] = "SIGNALED";
    WebGLEnum[WebGLEnum["ALREADY_SIGNALED"] = 0x911a] = "ALREADY_SIGNALED";
    WebGLEnum[WebGLEnum["TIMEOUT_EXPIRED"] = 0x911b] = "TIMEOUT_EXPIRED";
    WebGLEnum[WebGLEnum["CONDITION_SATISFIED"] = 0x911c] = "CONDITION_SATISFIED";
    WebGLEnum[WebGLEnum["WAIT_FAILED"] = 0x911d] = "WAIT_FAILED";
    WebGLEnum[WebGLEnum["SYNC_FLUSH_COMMANDS_BIT"] = 0x1] = "SYNC_FLUSH_COMMANDS_BIT";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 0x88fe] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    WebGLEnum[WebGLEnum["ANY_SAMPLES_PASSED"] = 0x8c2f] = "ANY_SAMPLES_PASSED";
    WebGLEnum[WebGLEnum["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 0x8d6a] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    WebGLEnum[WebGLEnum["SAMPLER_BINDING"] = 0x8919] = "SAMPLER_BINDING";
    WebGLEnum[WebGLEnum["RGB10_A2UI"] = 0x906f] = "RGB10_A2UI";
    WebGLEnum[WebGLEnum["INT_2_10_10_10_REV"] = 0x8d9f] = "INT_2_10_10_10_REV";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK"] = 0x8e22] = "TRANSFORM_FEEDBACK";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_PAUSED"] = 0x8e23] = "TRANSFORM_FEEDBACK_PAUSED";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_ACTIVE"] = 0x8e24] = "TRANSFORM_FEEDBACK_ACTIVE";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BINDING"] = 0x8e25] = "TRANSFORM_FEEDBACK_BINDING";
    WebGLEnum[WebGLEnum["TEXTURE_IMMUTABLE_FORMAT"] = 0x912f] = "TEXTURE_IMMUTABLE_FORMAT";
    WebGLEnum[WebGLEnum["MAX_ELEMENT_INDEX"] = 0x8d6b] = "MAX_ELEMENT_INDEX";
    WebGLEnum[WebGLEnum["TEXTURE_IMMUTABLE_LEVELS"] = 0x82df] = "TEXTURE_IMMUTABLE_LEVELS";
    WebGLEnum[WebGLEnum["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 0x9247] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    WebGLEnum[WebGLEnum["DEPTH_BUFFER_BIT"] = 0x100] = "DEPTH_BUFFER_BIT";
    WebGLEnum[WebGLEnum["STENCIL_BUFFER_BIT"] = 0x400] = "STENCIL_BUFFER_BIT";
    WebGLEnum[WebGLEnum["COLOR_BUFFER_BIT"] = 0x4000] = "COLOR_BUFFER_BIT";
    WebGLEnum[WebGLEnum["POINTS"] = 0x0] = "POINTS";
    WebGLEnum[WebGLEnum["LINES"] = 0x1] = "LINES";
    WebGLEnum[WebGLEnum["LINE_LOOP"] = 0x2] = "LINE_LOOP";
    WebGLEnum[WebGLEnum["LINE_STRIP"] = 0x3] = "LINE_STRIP";
    WebGLEnum[WebGLEnum["TRIANGLES"] = 0x4] = "TRIANGLES";
    WebGLEnum[WebGLEnum["TRIANGLE_STRIP"] = 0x5] = "TRIANGLE_STRIP";
    WebGLEnum[WebGLEnum["TRIANGLE_FAN"] = 0x6] = "TRIANGLE_FAN";
    WebGLEnum[WebGLEnum["ZERO"] = 0x0] = "ZERO";
    WebGLEnum[WebGLEnum["ONE"] = 0x1] = "ONE";
    WebGLEnum[WebGLEnum["SRC_COLOR"] = 0x300] = "SRC_COLOR";
    WebGLEnum[WebGLEnum["ONE_MINUS_SRC_COLOR"] = 0x301] = "ONE_MINUS_SRC_COLOR";
    WebGLEnum[WebGLEnum["SRC_ALPHA"] = 0x302] = "SRC_ALPHA";
    WebGLEnum[WebGLEnum["ONE_MINUS_SRC_ALPHA"] = 0x303] = "ONE_MINUS_SRC_ALPHA";
    WebGLEnum[WebGLEnum["DST_ALPHA"] = 0x304] = "DST_ALPHA";
    WebGLEnum[WebGLEnum["ONE_MINUS_DST_ALPHA"] = 0x305] = "ONE_MINUS_DST_ALPHA";
    WebGLEnum[WebGLEnum["DST_COLOR"] = 0x306] = "DST_COLOR";
    WebGLEnum[WebGLEnum["ONE_MINUS_DST_COLOR"] = 0x307] = "ONE_MINUS_DST_COLOR";
    WebGLEnum[WebGLEnum["SRC_ALPHA_SATURATE"] = 0x308] = "SRC_ALPHA_SATURATE";
    WebGLEnum[WebGLEnum["FUNC_ADD"] = 0x8006] = "FUNC_ADD";
    WebGLEnum[WebGLEnum["FUNC_MIN"] = 0x8007] = "FUNC_MIN";
    WebGLEnum[WebGLEnum["FUNC_MAX"] = 0x8008] = "FUNC_MAX";
    WebGLEnum[WebGLEnum["BLEND_EQUATION"] = 0x8009] = "BLEND_EQUATION";
    WebGLEnum[WebGLEnum["BLEND_EQUATION_RGB"] = 0x8009] = "BLEND_EQUATION_RGB";
    WebGLEnum[WebGLEnum["BLEND_EQUATION_ALPHA"] = 0x883d] = "BLEND_EQUATION_ALPHA";
    WebGLEnum[WebGLEnum["FUNC_SUBTRACT"] = 0x800a] = "FUNC_SUBTRACT";
    WebGLEnum[WebGLEnum["FUNC_REVERSE_SUBTRACT"] = 0x800b] = "FUNC_REVERSE_SUBTRACT";
    WebGLEnum[WebGLEnum["BLEND_DST_RGB"] = 0x80c8] = "BLEND_DST_RGB";
    WebGLEnum[WebGLEnum["BLEND_SRC_RGB"] = 0x80c9] = "BLEND_SRC_RGB";
    WebGLEnum[WebGLEnum["BLEND_DST_ALPHA"] = 0x80ca] = "BLEND_DST_ALPHA";
    WebGLEnum[WebGLEnum["BLEND_SRC_ALPHA"] = 0x80cb] = "BLEND_SRC_ALPHA";
    WebGLEnum[WebGLEnum["CONSTANT_COLOR"] = 0x8001] = "CONSTANT_COLOR";
    WebGLEnum[WebGLEnum["ONE_MINUS_CONSTANT_COLOR"] = 0x8002] = "ONE_MINUS_CONSTANT_COLOR";
    WebGLEnum[WebGLEnum["CONSTANT_ALPHA"] = 0x8003] = "CONSTANT_ALPHA";
    WebGLEnum[WebGLEnum["ONE_MINUS_CONSTANT_ALPHA"] = 0x8004] = "ONE_MINUS_CONSTANT_ALPHA";
    WebGLEnum[WebGLEnum["BLEND_COLOR"] = 0x8005] = "BLEND_COLOR";
    WebGLEnum[WebGLEnum["ARRAY_BUFFER"] = 0x8892] = "ARRAY_BUFFER";
    WebGLEnum[WebGLEnum["ELEMENT_ARRAY_BUFFER"] = 0x8893] = "ELEMENT_ARRAY_BUFFER";
    WebGLEnum[WebGLEnum["ARRAY_BUFFER_BINDING"] = 0x8894] = "ARRAY_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["ELEMENT_ARRAY_BUFFER_BINDING"] = 0x8895] = "ELEMENT_ARRAY_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["STREAM_DRAW"] = 0x88e0] = "STREAM_DRAW";
    WebGLEnum[WebGLEnum["STATIC_DRAW"] = 0x88e4] = "STATIC_DRAW";
    WebGLEnum[WebGLEnum["DYNAMIC_DRAW"] = 0x88e8] = "DYNAMIC_DRAW";
    WebGLEnum[WebGLEnum["BUFFER_SIZE"] = 0x8764] = "BUFFER_SIZE";
    WebGLEnum[WebGLEnum["BUFFER_USAGE"] = 0x8765] = "BUFFER_USAGE";
    WebGLEnum[WebGLEnum["CURRENT_VERTEX_ATTRIB"] = 0x8626] = "CURRENT_VERTEX_ATTRIB";
    WebGLEnum[WebGLEnum["FRONT"] = 0x404] = "FRONT";
    WebGLEnum[WebGLEnum["BACK"] = 0x405] = "BACK";
    WebGLEnum[WebGLEnum["FRONT_AND_BACK"] = 0x408] = "FRONT_AND_BACK";
    WebGLEnum[WebGLEnum["TEXTURE_2D"] = 0xde1] = "TEXTURE_2D";
    WebGLEnum[WebGLEnum["CULL_FACE"] = 0xb44] = "CULL_FACE";
    WebGLEnum[WebGLEnum["BLEND"] = 0xbe2] = "BLEND";
    WebGLEnum[WebGLEnum["DITHER"] = 0xbd0] = "DITHER";
    WebGLEnum[WebGLEnum["STENCIL_TEST"] = 0xb90] = "STENCIL_TEST";
    WebGLEnum[WebGLEnum["DEPTH_TEST"] = 0xb71] = "DEPTH_TEST";
    WebGLEnum[WebGLEnum["SCISSOR_TEST"] = 0xc11] = "SCISSOR_TEST";
    WebGLEnum[WebGLEnum["POLYGON_OFFSET_FILL"] = 0x8037] = "POLYGON_OFFSET_FILL";
    WebGLEnum[WebGLEnum["SAMPLE_ALPHA_TO_COVERAGE"] = 0x809e] = "SAMPLE_ALPHA_TO_COVERAGE";
    WebGLEnum[WebGLEnum["SAMPLE_COVERAGE"] = 0x80a0] = "SAMPLE_COVERAGE";
    WebGLEnum[WebGLEnum["NO_ERROR"] = 0x0] = "NO_ERROR";
    WebGLEnum[WebGLEnum["INVALID_ENUM"] = 0x500] = "INVALID_ENUM";
    WebGLEnum[WebGLEnum["INVALID_VALUE"] = 0x501] = "INVALID_VALUE";
    WebGLEnum[WebGLEnum["INVALID_OPERATION"] = 0x502] = "INVALID_OPERATION";
    WebGLEnum[WebGLEnum["OUT_OF_MEMORY"] = 0x505] = "OUT_OF_MEMORY";
    WebGLEnum[WebGLEnum["CW"] = 0x900] = "CW";
    WebGLEnum[WebGLEnum["CCW"] = 0x901] = "CCW";
    WebGLEnum[WebGLEnum["LINE_WIDTH"] = 0xb21] = "LINE_WIDTH";
    WebGLEnum[WebGLEnum["ALIASED_POINT_SIZE_RANGE"] = 0x846d] = "ALIASED_POINT_SIZE_RANGE";
    WebGLEnum[WebGLEnum["ALIASED_LINE_WIDTH_RANGE"] = 0x846e] = "ALIASED_LINE_WIDTH_RANGE";
    WebGLEnum[WebGLEnum["CULL_FACE_MODE"] = 0xb45] = "CULL_FACE_MODE";
    WebGLEnum[WebGLEnum["FRONT_FACE"] = 0xb46] = "FRONT_FACE";
    WebGLEnum[WebGLEnum["DEPTH_RANGE"] = 0xb70] = "DEPTH_RANGE";
    WebGLEnum[WebGLEnum["DEPTH_WRITEMASK"] = 0xb72] = "DEPTH_WRITEMASK";
    WebGLEnum[WebGLEnum["DEPTH_CLEAR_VALUE"] = 0xb73] = "DEPTH_CLEAR_VALUE";
    WebGLEnum[WebGLEnum["DEPTH_FUNC"] = 0xb74] = "DEPTH_FUNC";
    WebGLEnum[WebGLEnum["STENCIL_CLEAR_VALUE"] = 0xb91] = "STENCIL_CLEAR_VALUE";
    WebGLEnum[WebGLEnum["STENCIL_FUNC"] = 0xb92] = "STENCIL_FUNC";
    WebGLEnum[WebGLEnum["STENCIL_FAIL"] = 0xb94] = "STENCIL_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_PASS_DEPTH_FAIL"] = 0xb95] = "STENCIL_PASS_DEPTH_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_PASS_DEPTH_PASS"] = 0xb96] = "STENCIL_PASS_DEPTH_PASS";
    WebGLEnum[WebGLEnum["STENCIL_REF"] = 0xb97] = "STENCIL_REF";
    WebGLEnum[WebGLEnum["STENCIL_VALUE_MASK"] = 0xb93] = "STENCIL_VALUE_MASK";
    WebGLEnum[WebGLEnum["STENCIL_WRITEMASK"] = 0xb98] = "STENCIL_WRITEMASK";
    WebGLEnum[WebGLEnum["STENCIL_BACK_FUNC"] = 0x8800] = "STENCIL_BACK_FUNC";
    WebGLEnum[WebGLEnum["STENCIL_BACK_FAIL"] = 0x8801] = "STENCIL_BACK_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_BACK_PASS_DEPTH_FAIL"] = 0x8802] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_BACK_PASS_DEPTH_PASS"] = 0x8803] = "STENCIL_BACK_PASS_DEPTH_PASS";
    WebGLEnum[WebGLEnum["STENCIL_BACK_REF"] = 0x8ca3] = "STENCIL_BACK_REF";
    WebGLEnum[WebGLEnum["STENCIL_BACK_VALUE_MASK"] = 0x8ca4] = "STENCIL_BACK_VALUE_MASK";
    WebGLEnum[WebGLEnum["STENCIL_BACK_WRITEMASK"] = 0x8ca5] = "STENCIL_BACK_WRITEMASK";
    WebGLEnum[WebGLEnum["VIEWPORT"] = 0xba2] = "VIEWPORT";
    WebGLEnum[WebGLEnum["SCISSOR_BOX"] = 0xc10] = "SCISSOR_BOX";
    WebGLEnum[WebGLEnum["COLOR_CLEAR_VALUE"] = 0xc22] = "COLOR_CLEAR_VALUE";
    WebGLEnum[WebGLEnum["COLOR_WRITEMASK"] = 0xc23] = "COLOR_WRITEMASK";
    WebGLEnum[WebGLEnum["UNPACK_ALIGNMENT"] = 0xcf5] = "UNPACK_ALIGNMENT";
    WebGLEnum[WebGLEnum["PACK_ALIGNMENT"] = 0xd05] = "PACK_ALIGNMENT";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_SIZE"] = 0xd33] = "MAX_TEXTURE_SIZE";
    WebGLEnum[WebGLEnum["MAX_VIEWPORT_DIMS"] = 0xd3a] = "MAX_VIEWPORT_DIMS";
    WebGLEnum[WebGLEnum["SUBPIXEL_BITS"] = 0xd50] = "SUBPIXEL_BITS";
    WebGLEnum[WebGLEnum["RED_BITS"] = 0xd52] = "RED_BITS";
    WebGLEnum[WebGLEnum["GREEN_BITS"] = 0xd53] = "GREEN_BITS";
    WebGLEnum[WebGLEnum["BLUE_BITS"] = 0xd54] = "BLUE_BITS";
    WebGLEnum[WebGLEnum["ALPHA_BITS"] = 0xd55] = "ALPHA_BITS";
    WebGLEnum[WebGLEnum["DEPTH_BITS"] = 0xd56] = "DEPTH_BITS";
    WebGLEnum[WebGLEnum["STENCIL_BITS"] = 0xd57] = "STENCIL_BITS";
    WebGLEnum[WebGLEnum["POLYGON_OFFSET_UNITS"] = 0x2a00] = "POLYGON_OFFSET_UNITS";
    WebGLEnum[WebGLEnum["POLYGON_OFFSET_FACTOR"] = 0x8038] = "POLYGON_OFFSET_FACTOR";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_2D"] = 0x8069] = "TEXTURE_BINDING_2D";
    WebGLEnum[WebGLEnum["SAMPLE_BUFFERS"] = 0x80a8] = "SAMPLE_BUFFERS";
    WebGLEnum[WebGLEnum["SAMPLES"] = 0x80a9] = "SAMPLES";
    WebGLEnum[WebGLEnum["SAMPLE_COVERAGE_VALUE"] = 0x80aa] = "SAMPLE_COVERAGE_VALUE";
    WebGLEnum[WebGLEnum["SAMPLE_COVERAGE_INVERT"] = 0x80ab] = "SAMPLE_COVERAGE_INVERT";
    WebGLEnum[WebGLEnum["COMPRESSED_TEXTURE_FORMATS"] = 0x86a3] = "COMPRESSED_TEXTURE_FORMATS";
    WebGLEnum[WebGLEnum["DONT_CARE"] = 0x1100] = "DONT_CARE";
    WebGLEnum[WebGLEnum["FASTEST"] = 0x1101] = "FASTEST";
    WebGLEnum[WebGLEnum["NICEST"] = 0x1102] = "NICEST";
    WebGLEnum[WebGLEnum["GENERATE_MIPMAP_HINT"] = 0x8192] = "GENERATE_MIPMAP_HINT";
    WebGLEnum[WebGLEnum["BYTE"] = 0x1400] = "BYTE";
    WebGLEnum[WebGLEnum["UNSIGNED_BYTE"] = 0x1401] = "UNSIGNED_BYTE";
    WebGLEnum[WebGLEnum["SHORT"] = 0x1402] = "SHORT";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT"] = 0x1403] = "UNSIGNED_SHORT";
    WebGLEnum[WebGLEnum["INT"] = 0x1404] = "INT";
    WebGLEnum[WebGLEnum["UNSIGNED_INT"] = 0x1405] = "UNSIGNED_INT";
    WebGLEnum[WebGLEnum["FLOAT"] = 0x1406] = "FLOAT";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT"] = 0x1902] = "DEPTH_COMPONENT";
    WebGLEnum[WebGLEnum["ALPHA"] = 0x1906] = "ALPHA";
    WebGLEnum[WebGLEnum["RGB"] = 0x1907] = "RGB";
    WebGLEnum[WebGLEnum["RGBA"] = 0x1908] = "RGBA";
    WebGLEnum[WebGLEnum["LUMINANCE"] = 0x1909] = "LUMINANCE";
    WebGLEnum[WebGLEnum["LUMINANCE_ALPHA"] = 0x190a] = "LUMINANCE_ALPHA";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT_4_4_4_4"] = 0x8033] = "UNSIGNED_SHORT_4_4_4_4";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT_5_5_5_1"] = 0x8034] = "UNSIGNED_SHORT_5_5_5_1";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT_5_6_5"] = 0x8363] = "UNSIGNED_SHORT_5_6_5";
    WebGLEnum[WebGLEnum["FRAGMENT_SHADER"] = 0x8b30] = "FRAGMENT_SHADER";
    WebGLEnum[WebGLEnum["VERTEX_SHADER"] = 0x8b31] = "VERTEX_SHADER";
    WebGLEnum[WebGLEnum["MAX_VERTEX_ATTRIBS"] = 0x8869] = "MAX_VERTEX_ATTRIBS";
    WebGLEnum[WebGLEnum["MAX_VERTEX_UNIFORM_VECTORS"] = 0x8dfb] = "MAX_VERTEX_UNIFORM_VECTORS";
    WebGLEnum[WebGLEnum["MAX_VARYING_VECTORS"] = 0x8dfc] = "MAX_VARYING_VECTORS";
    WebGLEnum[WebGLEnum["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 0x8b4d] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    WebGLEnum[WebGLEnum["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 0x8b4c] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_IMAGE_UNITS"] = 0x8872] = "MAX_TEXTURE_IMAGE_UNITS";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_UNIFORM_VECTORS"] = 0x8dfd] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    WebGLEnum[WebGLEnum["SHADER_TYPE"] = 0x8b4f] = "SHADER_TYPE";
    WebGLEnum[WebGLEnum["DELETE_STATUS"] = 0x8b80] = "DELETE_STATUS";
    WebGLEnum[WebGLEnum["LINK_STATUS"] = 0x8b82] = "LINK_STATUS";
    WebGLEnum[WebGLEnum["VALIDATE_STATUS"] = 0x8b83] = "VALIDATE_STATUS";
    WebGLEnum[WebGLEnum["ATTACHED_SHADERS"] = 0x8b85] = "ATTACHED_SHADERS";
    WebGLEnum[WebGLEnum["ACTIVE_UNIFORMS"] = 0x8b86] = "ACTIVE_UNIFORMS";
    WebGLEnum[WebGLEnum["ACTIVE_ATTRIBUTES"] = 0x8b89] = "ACTIVE_ATTRIBUTES";
    WebGLEnum[WebGLEnum["SHADING_LANGUAGE_VERSION"] = 0x8b8c] = "SHADING_LANGUAGE_VERSION";
    WebGLEnum[WebGLEnum["CURRENT_PROGRAM"] = 0x8b8d] = "CURRENT_PROGRAM";
    WebGLEnum[WebGLEnum["NEVER"] = 0x200] = "NEVER";
    WebGLEnum[WebGLEnum["LESS"] = 0x201] = "LESS";
    WebGLEnum[WebGLEnum["EQUAL"] = 0x202] = "EQUAL";
    WebGLEnum[WebGLEnum["LEQUAL"] = 0x203] = "LEQUAL";
    WebGLEnum[WebGLEnum["GREATER"] = 0x204] = "GREATER";
    WebGLEnum[WebGLEnum["NOTEQUAL"] = 0x205] = "NOTEQUAL";
    WebGLEnum[WebGLEnum["GEQUAL"] = 0x206] = "GEQUAL";
    WebGLEnum[WebGLEnum["ALWAYS"] = 0x207] = "ALWAYS";
    WebGLEnum[WebGLEnum["KEEP"] = 0x1e00] = "KEEP";
    WebGLEnum[WebGLEnum["REPLACE"] = 0x1e01] = "REPLACE";
    WebGLEnum[WebGLEnum["INCR"] = 0x1e02] = "INCR";
    WebGLEnum[WebGLEnum["DECR"] = 0x1e03] = "DECR";
    WebGLEnum[WebGLEnum["INVERT"] = 0x150a] = "INVERT";
    WebGLEnum[WebGLEnum["INCR_WRAP"] = 0x8507] = "INCR_WRAP";
    WebGLEnum[WebGLEnum["DECR_WRAP"] = 0x8508] = "DECR_WRAP";
    WebGLEnum[WebGLEnum["VENDOR"] = 0x1f00] = "VENDOR";
    WebGLEnum[WebGLEnum["RENDERER"] = 0x1f01] = "RENDERER";
    WebGLEnum[WebGLEnum["VERSION"] = 0x1f02] = "VERSION";
    WebGLEnum[WebGLEnum["NEAREST"] = 0x2600] = "NEAREST";
    WebGLEnum[WebGLEnum["LINEAR"] = 0x2601] = "LINEAR";
    WebGLEnum[WebGLEnum["NEAREST_MIPMAP_NEAREST"] = 0x2700] = "NEAREST_MIPMAP_NEAREST";
    WebGLEnum[WebGLEnum["LINEAR_MIPMAP_NEAREST"] = 0x2701] = "LINEAR_MIPMAP_NEAREST";
    WebGLEnum[WebGLEnum["NEAREST_MIPMAP_LINEAR"] = 0x2702] = "NEAREST_MIPMAP_LINEAR";
    WebGLEnum[WebGLEnum["LINEAR_MIPMAP_LINEAR"] = 0x2703] = "LINEAR_MIPMAP_LINEAR";
    WebGLEnum[WebGLEnum["TEXTURE_MAG_FILTER"] = 0x2800] = "TEXTURE_MAG_FILTER";
    WebGLEnum[WebGLEnum["TEXTURE_MIN_FILTER"] = 0x2801] = "TEXTURE_MIN_FILTER";
    WebGLEnum[WebGLEnum["TEXTURE_WRAP_S"] = 0x2802] = "TEXTURE_WRAP_S";
    WebGLEnum[WebGLEnum["TEXTURE_WRAP_T"] = 0x2803] = "TEXTURE_WRAP_T";
    WebGLEnum[WebGLEnum["TEXTURE"] = 0x1702] = "TEXTURE";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP"] = 0x8513] = "TEXTURE_CUBE_MAP";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_CUBE_MAP"] = 0x8514] = "TEXTURE_BINDING_CUBE_MAP";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_POSITIVE_X"] = 0x8515] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 0x8516] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 0x8517] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 0x8518] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 0x8519] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 0x851a] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    WebGLEnum[WebGLEnum["MAX_CUBE_MAP_TEXTURE_SIZE"] = 0x851c] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    WebGLEnum[WebGLEnum["TEXTURE0"] = 0x84c0] = "TEXTURE0";
    WebGLEnum[WebGLEnum["TEXTURE1"] = 0x84c1] = "TEXTURE1";
    WebGLEnum[WebGLEnum["TEXTURE2"] = 0x84c2] = "TEXTURE2";
    WebGLEnum[WebGLEnum["TEXTURE3"] = 0x84c3] = "TEXTURE3";
    WebGLEnum[WebGLEnum["TEXTURE4"] = 0x84c4] = "TEXTURE4";
    WebGLEnum[WebGLEnum["TEXTURE5"] = 0x84c5] = "TEXTURE5";
    WebGLEnum[WebGLEnum["TEXTURE6"] = 0x84c6] = "TEXTURE6";
    WebGLEnum[WebGLEnum["TEXTURE7"] = 0x84c7] = "TEXTURE7";
    WebGLEnum[WebGLEnum["TEXTURE8"] = 0x84c8] = "TEXTURE8";
    WebGLEnum[WebGLEnum["TEXTURE9"] = 0x84c9] = "TEXTURE9";
    WebGLEnum[WebGLEnum["TEXTURE10"] = 0x84ca] = "TEXTURE10";
    WebGLEnum[WebGLEnum["TEXTURE11"] = 0x84cb] = "TEXTURE11";
    WebGLEnum[WebGLEnum["TEXTURE12"] = 0x84cc] = "TEXTURE12";
    WebGLEnum[WebGLEnum["TEXTURE13"] = 0x84cd] = "TEXTURE13";
    WebGLEnum[WebGLEnum["TEXTURE14"] = 0x84ce] = "TEXTURE14";
    WebGLEnum[WebGLEnum["TEXTURE15"] = 0x84cf] = "TEXTURE15";
    WebGLEnum[WebGLEnum["TEXTURE16"] = 0x84d0] = "TEXTURE16";
    WebGLEnum[WebGLEnum["TEXTURE17"] = 0x84d1] = "TEXTURE17";
    WebGLEnum[WebGLEnum["TEXTURE18"] = 0x84d2] = "TEXTURE18";
    WebGLEnum[WebGLEnum["TEXTURE19"] = 0x84d3] = "TEXTURE19";
    WebGLEnum[WebGLEnum["TEXTURE20"] = 0x84d4] = "TEXTURE20";
    WebGLEnum[WebGLEnum["TEXTURE21"] = 0x84d5] = "TEXTURE21";
    WebGLEnum[WebGLEnum["TEXTURE22"] = 0x84d6] = "TEXTURE22";
    WebGLEnum[WebGLEnum["TEXTURE23"] = 0x84d7] = "TEXTURE23";
    WebGLEnum[WebGLEnum["TEXTURE24"] = 0x84d8] = "TEXTURE24";
    WebGLEnum[WebGLEnum["TEXTURE25"] = 0x84d9] = "TEXTURE25";
    WebGLEnum[WebGLEnum["TEXTURE26"] = 0x84da] = "TEXTURE26";
    WebGLEnum[WebGLEnum["TEXTURE27"] = 0x84db] = "TEXTURE27";
    WebGLEnum[WebGLEnum["TEXTURE28"] = 0x84dc] = "TEXTURE28";
    WebGLEnum[WebGLEnum["TEXTURE29"] = 0x84dd] = "TEXTURE29";
    WebGLEnum[WebGLEnum["TEXTURE30"] = 0x84de] = "TEXTURE30";
    WebGLEnum[WebGLEnum["TEXTURE31"] = 0x84df] = "TEXTURE31";
    WebGLEnum[WebGLEnum["ACTIVE_TEXTURE"] = 0x84e0] = "ACTIVE_TEXTURE";
    WebGLEnum[WebGLEnum["REPEAT"] = 0x2901] = "REPEAT";
    WebGLEnum[WebGLEnum["CLAMP_TO_EDGE"] = 0x812f] = "CLAMP_TO_EDGE";
    WebGLEnum[WebGLEnum["MIRRORED_REPEAT"] = 0x8370] = "MIRRORED_REPEAT";
    WebGLEnum[WebGLEnum["FLOAT_VEC2"] = 0x8b50] = "FLOAT_VEC2";
    WebGLEnum[WebGLEnum["FLOAT_VEC3"] = 0x8b51] = "FLOAT_VEC3";
    WebGLEnum[WebGLEnum["FLOAT_VEC4"] = 0x8b52] = "FLOAT_VEC4";
    WebGLEnum[WebGLEnum["INT_VEC2"] = 0x8b53] = "INT_VEC2";
    WebGLEnum[WebGLEnum["INT_VEC3"] = 0x8b54] = "INT_VEC3";
    WebGLEnum[WebGLEnum["INT_VEC4"] = 0x8b55] = "INT_VEC4";
    WebGLEnum[WebGLEnum["BOOL"] = 0x8b56] = "BOOL";
    WebGLEnum[WebGLEnum["BOOL_VEC2"] = 0x8b57] = "BOOL_VEC2";
    WebGLEnum[WebGLEnum["BOOL_VEC3"] = 0x8b58] = "BOOL_VEC3";
    WebGLEnum[WebGLEnum["BOOL_VEC4"] = 0x8b59] = "BOOL_VEC4";
    WebGLEnum[WebGLEnum["FLOAT_MAT2"] = 0x8b5a] = "FLOAT_MAT2";
    WebGLEnum[WebGLEnum["FLOAT_MAT3"] = 0x8b5b] = "FLOAT_MAT3";
    WebGLEnum[WebGLEnum["FLOAT_MAT4"] = 0x8b5c] = "FLOAT_MAT4";
    WebGLEnum[WebGLEnum["SAMPLER_2D"] = 0x8b5e] = "SAMPLER_2D";
    WebGLEnum[WebGLEnum["SAMPLER_CUBE"] = 0x8b60] = "SAMPLER_CUBE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_ENABLED"] = 0x8622] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_SIZE"] = 0x8623] = "VERTEX_ATTRIB_ARRAY_SIZE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_STRIDE"] = 0x8624] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_TYPE"] = 0x8625] = "VERTEX_ATTRIB_ARRAY_TYPE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 0x886a] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_POINTER"] = 0x8645] = "VERTEX_ATTRIB_ARRAY_POINTER";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 0x889f] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["IMPLEMENTATION_COLOR_READ_TYPE"] = 0x8b9a] = "IMPLEMENTATION_COLOR_READ_TYPE";
    WebGLEnum[WebGLEnum["IMPLEMENTATION_COLOR_READ_FORMAT"] = 0x8b9b] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    WebGLEnum[WebGLEnum["COMPILE_STATUS"] = 0x8b81] = "COMPILE_STATUS";
    WebGLEnum[WebGLEnum["LOW_FLOAT"] = 0x8df0] = "LOW_FLOAT";
    WebGLEnum[WebGLEnum["MEDIUM_FLOAT"] = 0x8df1] = "MEDIUM_FLOAT";
    WebGLEnum[WebGLEnum["HIGH_FLOAT"] = 0x8df2] = "HIGH_FLOAT";
    WebGLEnum[WebGLEnum["LOW_INT"] = 0x8df3] = "LOW_INT";
    WebGLEnum[WebGLEnum["MEDIUM_INT"] = 0x8df4] = "MEDIUM_INT";
    WebGLEnum[WebGLEnum["HIGH_INT"] = 0x8df5] = "HIGH_INT";
    WebGLEnum[WebGLEnum["FRAMEBUFFER"] = 0x8d40] = "FRAMEBUFFER";
    WebGLEnum[WebGLEnum["RENDERBUFFER"] = 0x8d41] = "RENDERBUFFER";
    WebGLEnum[WebGLEnum["RGBA4"] = 0x8056] = "RGBA4";
    WebGLEnum[WebGLEnum["RGB5_A1"] = 0x8057] = "RGB5_A1";
    WebGLEnum[WebGLEnum["RGB565"] = 0x8d62] = "RGB565";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT16"] = 0x81a5] = "DEPTH_COMPONENT16";
    WebGLEnum[WebGLEnum["STENCIL_INDEX8"] = 0x8d48] = "STENCIL_INDEX8";
    WebGLEnum[WebGLEnum["DEPTH_STENCIL"] = 0x84f9] = "DEPTH_STENCIL";
    WebGLEnum[WebGLEnum["RENDERBUFFER_WIDTH"] = 0x8d42] = "RENDERBUFFER_WIDTH";
    WebGLEnum[WebGLEnum["RENDERBUFFER_HEIGHT"] = 0x8d43] = "RENDERBUFFER_HEIGHT";
    WebGLEnum[WebGLEnum["RENDERBUFFER_INTERNAL_FORMAT"] = 0x8d44] = "RENDERBUFFER_INTERNAL_FORMAT";
    WebGLEnum[WebGLEnum["RENDERBUFFER_RED_SIZE"] = 0x8d50] = "RENDERBUFFER_RED_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_GREEN_SIZE"] = 0x8d51] = "RENDERBUFFER_GREEN_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_BLUE_SIZE"] = 0x8d52] = "RENDERBUFFER_BLUE_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_ALPHA_SIZE"] = 0x8d53] = "RENDERBUFFER_ALPHA_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_DEPTH_SIZE"] = 0x8d54] = "RENDERBUFFER_DEPTH_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_STENCIL_SIZE"] = 0x8d55] = "RENDERBUFFER_STENCIL_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 0x8cd0] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 0x8cd1] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 0x8cd2] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 0x8cd3] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT0"] = 0x8ce0] = "COLOR_ATTACHMENT0";
    WebGLEnum[WebGLEnum["DEPTH_ATTACHMENT"] = 0x8d00] = "DEPTH_ATTACHMENT";
    WebGLEnum[WebGLEnum["STENCIL_ATTACHMENT"] = 0x8d20] = "STENCIL_ATTACHMENT";
    WebGLEnum[WebGLEnum["DEPTH_STENCIL_ATTACHMENT"] = 0x821a] = "DEPTH_STENCIL_ATTACHMENT";
    WebGLEnum[WebGLEnum["NONE"] = 0x0] = "NONE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_COMPLETE"] = 0x8cd5] = "FRAMEBUFFER_COMPLETE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 0x8cd6] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 0x8cd7] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 0x8cd9] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_UNSUPPORTED"] = 0x8cdd] = "FRAMEBUFFER_UNSUPPORTED";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_BINDING"] = 0x8ca6] = "FRAMEBUFFER_BINDING";
    WebGLEnum[WebGLEnum["RENDERBUFFER_BINDING"] = 0x8ca7] = "RENDERBUFFER_BINDING";
    WebGLEnum[WebGLEnum["MAX_RENDERBUFFER_SIZE"] = 0x84e8] = "MAX_RENDERBUFFER_SIZE";
    WebGLEnum[WebGLEnum["INVALID_FRAMEBUFFER_OPERATION"] = 0x506] = "INVALID_FRAMEBUFFER_OPERATION";
    WebGLEnum[WebGLEnum["UNPACK_FLIP_Y_WEBGL"] = 0x9240] = "UNPACK_FLIP_Y_WEBGL";
    WebGLEnum[WebGLEnum["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 0x9241] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    WebGLEnum[WebGLEnum["CONTEXT_LOST_WEBGL"] = 0x9242] = "CONTEXT_LOST_WEBGL";
    WebGLEnum[WebGLEnum["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 0x9243] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    WebGLEnum[WebGLEnum["BROWSER_DEFAULT_WEBGL"] = 0x9244] = "BROWSER_DEFAULT_WEBGL";
    WebGLEnum[WebGLEnum["TEXTURE_MAX_ANISOTROPY"] = 0x84fe] = "TEXTURE_MAX_ANISOTROPY";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_MAX_ANISOTROPY"] = 0x84ff] = "MAX_TEXTURE_MAX_ANISOTROPY";
})(WebGLEnum || (WebGLEnum = {}));

function isWebGL2(gl) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return !!(gl && gl.texStorage2D);
}
class WebGLError extends Error {
    static errorToString = {
        [WebGLEnum.NO_ERROR]: 'NO_ERROR',
        [WebGLEnum.INVALID_ENUM]: 'INVALID_ENUM',
        [WebGLEnum.INVALID_VALUE]: 'INVALID_VALUE',
        [WebGLEnum.INVALID_OPERATION]: 'INVALID_OPERATION',
        [WebGLEnum.INVALID_FRAMEBUFFER_OPERATION]: 'INVALID_FRAMEBUFFER_OPERATION',
        [WebGLEnum.OUT_OF_MEMORY]: 'OUT_OF_MEMORY',
        [WebGLEnum.CONTEXT_LOST_WEBGL]: 'CONTEXT_LOST_WEBGL'
    };
    code;
    constructor(code){
        super(WebGLError.errorToString[code]);
        this.code = code;
    }
}

const blendEquationMap = {
    add: WebGLEnum.FUNC_ADD,
    subtract: WebGLEnum.FUNC_SUBTRACT,
    'reverse-subtract': WebGLEnum.FUNC_REVERSE_SUBTRACT,
    max: WebGLEnum.FUNC_MAX,
    min: WebGLEnum.FUNC_MIN
};
const blendEquationInvMap = {
    [WebGLEnum.FUNC_ADD]: 'add',
    [WebGLEnum.FUNC_SUBTRACT]: 'subtract',
    [WebGLEnum.FUNC_REVERSE_SUBTRACT]: 'reverse-subtract',
    [WebGLEnum.FUNC_MAX]: 'max',
    [WebGLEnum.FUNC_MIN]: 'min'
};
const blendFuncMap = {
    zero: WebGLEnum.ZERO,
    one: WebGLEnum.ONE,
    'src-alpha': WebGLEnum.SRC_ALPHA,
    'inv-src-alpha': WebGLEnum.ONE_MINUS_SRC_ALPHA,
    'src-alpha-saturate': WebGLEnum.BLEND,
    'dst-alpha': WebGLEnum.DST_ALPHA,
    'inv-dst-alpha': WebGLEnum.ONE_MINUS_DST_ALPHA,
    'src-color': WebGLEnum.SRC_COLOR,
    'inv-src-color': WebGLEnum.ONE_MINUS_SRC_COLOR,
    'dst-color': WebGLEnum.DST_COLOR,
    'inv-dst-color': WebGLEnum.ONE_MINUS_DST_COLOR,
    'const-color': WebGLEnum.CONSTANT_COLOR,
    'inv-const-color': WebGLEnum.ONE_MINUS_CONSTANT_COLOR,
    'const-alpha': WebGLEnum.CONSTANT_ALPHA,
    'inv-const-alpha': WebGLEnum.ONE_MINUS_CONSTANT_ALPHA
};
const blendFuncInvMap = {
    [WebGLEnum.ZERO]: 'zero',
    [WebGLEnum.ONE]: 'one',
    [WebGLEnum.SRC_ALPHA]: 'src-alpha',
    [WebGLEnum.ONE_MINUS_SRC_ALPHA]: 'inv-src-alpha',
    [WebGLEnum.SRC_ALPHA_SATURATE]: 'src-alpha-saturate',
    [WebGLEnum.DST_ALPHA]: 'dst-alpha',
    [WebGLEnum.ONE_MINUS_DST_ALPHA]: 'inv-dst-alpha',
    [WebGLEnum.SRC_COLOR]: 'src-color',
    [WebGLEnum.ONE_MINUS_SRC_COLOR]: 'inv-src-color',
    [WebGLEnum.DST_COLOR]: 'dst-color',
    [WebGLEnum.ONE_MINUS_DST_COLOR]: 'inv-dst-color',
    [WebGLEnum.CONSTANT_COLOR]: 'const-color',
    [WebGLEnum.ONE_MINUS_CONSTANT_COLOR]: 'inv-const-color',
    [WebGLEnum.CONSTANT_ALPHA]: 'const-alpha',
    [WebGLEnum.ONE_MINUS_CONSTANT_ALPHA]: 'inv-const-alpha'
};
const faceModeMap = {
    none: WebGLEnum.NONE,
    front: WebGLEnum.FRONT,
    back: WebGLEnum.BACK
};
const faceModeInvMap = {
    [WebGLEnum.NONE]: 'none',
    [WebGLEnum.FRONT]: 'front',
    [WebGLEnum.BACK]: 'back'
};
({
    cw: WebGLEnum.CW,
    ccw: WebGLEnum.CCW
});
({
    [WebGLEnum.CW]: 'cw',
    [WebGLEnum.CCW]: 'ccw'
});
const stencilOpMap = {
    keep: WebGLEnum.KEEP,
    zero: WebGLEnum.ZERO,
    replace: WebGLEnum.REPLACE,
    incr: WebGLEnum.INCR,
    'incr-wrap': WebGLEnum.INCR_WRAP,
    decr: WebGLEnum.DECR,
    'decr-wrap': WebGLEnum.DECR_WRAP,
    invert: WebGLEnum.INVERT
};
const stencilOpInvMap = {
    [WebGLEnum.KEEP]: 'keep',
    [WebGLEnum.ZERO]: 'zero',
    [WebGLEnum.REPLACE]: 'replace',
    [WebGLEnum.INCR]: 'incr',
    [WebGLEnum.INCR_WRAP]: 'incr-wrap',
    [WebGLEnum.DECR]: 'decr',
    [WebGLEnum.DECR_WRAP]: 'decr-wrap',
    [WebGLEnum.INVERT]: 'invert'
};
const compareFuncMap = {
    always: WebGLEnum.ALWAYS,
    le: WebGLEnum.LEQUAL,
    ge: WebGLEnum.GEQUAL,
    lt: WebGLEnum.LESS,
    gt: WebGLEnum.GREATER,
    eq: WebGLEnum.EQUAL,
    ne: WebGLEnum.NOTEQUAL,
    never: WebGLEnum.NEVER
};
const compareFuncInvMap = {
    [WebGLEnum.NONE]: null,
    [WebGLEnum.ALWAYS]: 'always',
    [WebGLEnum.LEQUAL]: 'le',
    [WebGLEnum.GEQUAL]: 'ge',
    [WebGLEnum.LESS]: 'lt',
    [WebGLEnum.GREATER]: 'gt',
    [WebGLEnum.EQUAL]: 'eq',
    [WebGLEnum.NOTEQUAL]: 'ne',
    [WebGLEnum.NEVER]: 'never'
};
const textureWrappingMap = {
    repeat: WebGLEnum.REPEAT,
    'mirrored-repeat': WebGLEnum.MIRRORED_REPEAT,
    clamp: WebGLEnum.CLAMP_TO_EDGE
};
const typeMap = {
    [PBPrimitiveType.BOOL]: WebGLEnum.BOOL,
    [PBPrimitiveType.BVEC2]: WebGLEnum.BOOL_VEC2,
    [PBPrimitiveType.BVEC3]: WebGLEnum.BOOL_VEC3,
    [PBPrimitiveType.BVEC4]: WebGLEnum.BOOL_VEC4,
    [PBPrimitiveType.F32]: WebGLEnum.FLOAT,
    [PBPrimitiveType.F32VEC2]: WebGLEnum.FLOAT_VEC2,
    [PBPrimitiveType.F32VEC3]: WebGLEnum.FLOAT_VEC3,
    [PBPrimitiveType.F32VEC4]: WebGLEnum.FLOAT_VEC4,
    [PBPrimitiveType.I8]: WebGLEnum.BYTE,
    [PBPrimitiveType.I16]: WebGLEnum.SHORT,
    [PBPrimitiveType.I32]: WebGLEnum.INT,
    [PBPrimitiveType.I32VEC2]: WebGLEnum.INT_VEC2,
    [PBPrimitiveType.I32VEC3]: WebGLEnum.INT_VEC3,
    [PBPrimitiveType.I32VEC4]: WebGLEnum.INT_VEC4,
    [PBPrimitiveType.U8]: WebGLEnum.UNSIGNED_BYTE,
    [PBPrimitiveType.U8_NORM]: WebGLEnum.UNSIGNED_BYTE,
    [PBPrimitiveType.I8_NORM]: WebGLEnum.BYTE,
    [PBPrimitiveType.U16]: WebGLEnum.UNSIGNED_SHORT,
    [PBPrimitiveType.U16_NORM]: WebGLEnum.UNSIGNED_SHORT,
    [PBPrimitiveType.I16_NORM]: WebGLEnum.SHORT,
    [PBPrimitiveType.U32]: WebGLEnum.UNSIGNED_INT,
    [PBPrimitiveType.U32VEC2]: WebGLEnum.UNSIGNED_INT_VEC2,
    [PBPrimitiveType.U32VEC3]: WebGLEnum.UNSIGNED_INT_VEC3,
    [PBPrimitiveType.U32VEC4]: WebGLEnum.UNSIGNED_INT_VEC4
};
const primitiveTypeMap = {
    'triangle-list': WebGLEnum.TRIANGLES,
    'triangle-strip': WebGLEnum.TRIANGLE_STRIP,
    'triangle-fan': WebGLEnum.TRIANGLE_FAN,
    'line-list': WebGLEnum.LINES,
    'line-strip': WebGLEnum.LINE_STRIP,
    'point-list': WebGLEnum.POINTS
};
const textureTargetMap = {
    '2d': WebGLEnum.TEXTURE_2D,
    '3d': WebGLEnum.TEXTURE_3D,
    cube: WebGLEnum.TEXTURE_CUBE_MAP,
    '2darray': WebGLEnum.TEXTURE_2D_ARRAY
};
const cubeMapFaceMap = {
    [CubeFace.PX]: WebGLEnum.TEXTURE_CUBE_MAP_POSITIVE_X,
    [CubeFace.NX]: WebGLEnum.TEXTURE_CUBE_MAP_NEGATIVE_X,
    [CubeFace.PY]: WebGLEnum.TEXTURE_CUBE_MAP_POSITIVE_Y,
    [CubeFace.NY]: WebGLEnum.TEXTURE_CUBE_MAP_NEGATIVE_Y,
    [CubeFace.PZ]: WebGLEnum.TEXTURE_CUBE_MAP_POSITIVE_Z,
    [CubeFace.NZ]: WebGLEnum.TEXTURE_CUBE_MAP_NEGATIVE_Z
};
function textureMagFilterToWebGL(magFilter) {
    switch(magFilter){
        case 'nearest':
            return WebGLEnum.NEAREST;
        case 'linear':
            return WebGLEnum.LINEAR;
        default:
            return WebGLEnum.NONE;
    }
}
function textureMinFilterToWebGL(minFilter, mipFilter) {
    switch(minFilter){
        case 'nearest':
            switch(mipFilter){
                case 'none':
                    return WebGLEnum.NEAREST;
                case 'nearest':
                    return WebGLEnum.NEAREST_MIPMAP_NEAREST;
                case 'linear':
                    return WebGLEnum.NEAREST_MIPMAP_LINEAR;
            }
            break;
        case 'linear':
            switch(mipFilter){
                case 'none':
                    return WebGLEnum.LINEAR;
                case 'nearest':
                    return WebGLEnum.LINEAR_MIPMAP_NEAREST;
                case 'linear':
                    return WebGLEnum.LINEAR_MIPMAP_LINEAR;
            }
            break;
    }
    return WebGLEnum.NONE;
}

let _uniqueId = 0;
class WebGLGPUObject extends makeEventTarget(Object)() {
    _device;
    _object;
    _uid;
    _cid;
    _name;
    _restoreHandler;
    constructor(device){
        super();
        this._device = device;
        this._object = null;
        this._uid = ++_uniqueId;
        this._cid = 1;
        this._name = `${genDefaultName(this)}#${this._uid}`;
        this._restoreHandler = null;
        this._device.addGPUObject(this);
    }
    get device() {
        return this._device;
    }
    get object() {
        return this._object;
    }
    get disposed() {
        return !this._object;
    }
    get restoreHandler() {
        return this._restoreHandler;
    }
    set restoreHandler(handler) {
        this._restoreHandler = handler;
    }
    get uid() {
        return this._uid;
    }
    get cid() {
        return this._cid;
    }
    get name() {
        return this._name;
    }
    set name(val) {
        if (val !== this._name) {
            const evt = new DeviceGPUObjectRenameEvent(this, this._name);
            this._name = val;
            this._device.dispatchEvent(evt);
        }
    }
    isVertexLayout() {
        return false;
    }
    isFramebuffer() {
        return false;
    }
    isSampler() {
        return false;
    }
    isTexture() {
        return false;
    }
    isTexture2D() {
        return false;
    }
    isTexture2DArray() {
        return false;
    }
    isTexture3D() {
        return false;
    }
    isTextureCube() {
        return false;
    }
    isTextureVideo() {
        return false;
    }
    isProgram() {
        return false;
    }
    isBuffer() {
        return false;
    }
    isBindGroup() {
        return false;
    }
    dispose() {
        if (!this.disposed) {
            this._device.disposeObject(this, true);
        }
    }
    async reload() {
        if (this.disposed) {
            const p = this._device.restoreObject(this);
            this._cid++;
            return p;
        }
    }
    destroy() {
        throw new Error('Abstract function call: destroy()');
    }
    async restore() {
        throw new Error('Abstract function call: restore()');
    }
}

class WebGLBaseTexture extends WebGLGPUObject {
    _target;
    _memCost;
    _flags;
    _width;
    _height;
    _depth;
    _format;
    _mipLevelCount;
    _samplerOptions;
    _webgl1fallback;
    constructor(device, target){
        super(device);
        this._target = target || '2d';
        this._memCost = 0;
        this._flags = 0;
        this._width = 0;
        this._height = 0;
        this._depth = 1;
        this._format = 'unknown';
        this._mipLevelCount = 0;
        this._samplerOptions = null;
        this._webgl1fallback = false;
    }
    get target() {
        return this._target;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get depth() {
        return this._depth;
    }
    get format() {
        return this._format;
    }
    get mipLevelCount() {
        return this._mipLevelCount;
    }
    get samplerOptions() {
        return this._samplerOptions;
    }
    set samplerOptions(options) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._samplerOptions = options ? Object.assign({}, this._getSamplerOptions(params, !!options.compare), options) : null;
    }
    get isWebGL1Fallback() {
        return this._webgl1fallback;
    }
    isFilterable() {
        if (!this.getTextureCaps().getTextureFormatInfo(this._format)?.filterable) {
            return false;
        }
        if (!this.device.isWebGL2 && !isPowerOf2(this._width) && !isPowerOf2(this._height)) {
            return false;
        }
        return true;
    }
    destroy() {
        if (this._object) {
            this._device.context.deleteTexture(this._object);
            this._object = null;
            this._device.updateVideoMemoryCost(-this._memCost);
            this._memCost = 0;
        }
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.init();
        }
    }
    isTexture() {
        return true;
    }
    getTextureCaps() {
        return this._device.getDeviceCaps().textureCaps;
    }
    isSRGBFormat() {
        return isSRGBTextureFormat(this._format);
    }
    isFloatFormat() {
        return isFloatTextureFormat(this._format);
    }
    isIntegerFormat() {
        return isIntegerTextureFormat(this._format);
    }
    isSignedFormat() {
        return isSignedTextureFormat(this._format);
    }
    isCompressedFormat() {
        return isCompressedTextureFormat(this._format);
    }
    isDepth() {
        return hasDepthChannel(this._format);
    }
    getDefaultSampler(shadow) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        return this._device.createSampler(!this._samplerOptions || !this._samplerOptions.compare !== !shadow ? this._getSamplerOptions(params, shadow) : this._samplerOptions);
    }
    /** @internal */ allocInternal(format, width, height, depth, numMipLevels) {
        if (!this._device.isWebGL2 && (!isPowerOf2(width) || !isPowerOf2(height))) {
            numMipLevels = 1;
            this._webgl1fallback = true;
        } else {
            this._webgl1fallback = false;
        }
        this._device.setCurrentSamplerForTexture(this, null);
        if (numMipLevels === 0) {
            numMipLevels = this._calcMipLevelCount(format, width, height, depth);
        } else if (numMipLevels !== 1) {
            let size = Math.max(width, height);
            if (this.isTexture3D()) {
                size = Math.max(size, depth);
            }
            const autoMipLevelCount = Math.floor(Math.log2(size)) + 1; //this._calcMipLevelCount(format, width, height, depth);
            if (!Number.isInteger(numMipLevels) || numMipLevels < 0 || numMipLevels > autoMipLevelCount) {
                numMipLevels = autoMipLevelCount;
            }
        }
        if (this._object && (this._format !== format || this._width !== width || this._height !== height || this._depth !== depth, this._mipLevelCount !== numMipLevels)) {
            const obj = this._object;
            this._device.runNextFrame(()=>{
                this._device.context.deleteTexture(obj);
            });
            this._object = null;
        }
        if (!this._object) {
            this._format = format;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._mipLevelCount = numMipLevels;
            if (!this._device.isContextLost()) {
                this._object = this._device.context.createTexture();
                const gl = this._device.context;
                gl.bindTexture(textureTargetMap[this._target], this._object);
                const params = this.getTextureCaps().getTextureFormatInfo(this._format);
                if (isWebGL2(gl) && !this.isTextureVideo()) {
                    if (!this.isTexture3D() && !this.isTexture2DArray()) {
                        gl.texStorage2D(textureTargetMap[this._target], this._mipLevelCount, params.glInternalFormat, this._width, this._height);
                    } else {
                        gl.texStorage3D(textureTargetMap[this._target], this._mipLevelCount, params.glInternalFormat, this._width, this._height, this._depth);
                    }
                    this._device.context.texParameteri(textureTargetMap[this._target], WebGLEnum.TEXTURE_BASE_LEVEL, 0);
                    this._device.context.texParameteri(textureTargetMap[this._target], WebGLEnum.TEXTURE_MAX_LEVEL, this._mipLevelCount - 1);
                } else {
                    let w = this._width;
                    let h = this._height;
                    const isCompressed = isCompressedTextureFormat(this._format);
                    const blockWidth = getTextureFormatBlockWidth(this._format);
                    const blockHeight = getTextureFormatBlockHeight(this._format);
                    const blockSize = getTextureFormatBlockSize(this._format);
                    for(let mip = 0; mip < numMipLevels; mip++){
                        const data = isCompressed ? new Uint8Array(Math.ceil(w / blockWidth) * Math.ceil(h / blockHeight) * blockSize) : null;
                        data?.fill(0xff);
                        if (this.isTextureCube()) {
                            for(let face = 0; face < 6; face++){
                                const faceTarget = cubeMapFaceMap[face];
                                if (isCompressed) {
                                    this._device.context.compressedTexImage2D(faceTarget, mip, params.glInternalFormat, w, h, 0, data);
                                } else {
                                    this._device.context.texImage2D(faceTarget, mip, params.glInternalFormat, w, h, 0, params.glFormat, params.glType[0], null);
                                }
                            }
                        } else {
                            if (isCompressed) {
                                this._device.context.compressedTexImage2D(textureTargetMap[this._target], mip, params.glInternalFormat, w, h, 0, data);
                            } else {
                                this._device.context.texImage2D(textureTargetMap[this._target], mip, params.glInternalFormat, w, h, 0, params.glFormat, params.glType[0], null);
                            }
                        }
                        w = Math.max(w >> 1, 1);
                        h = Math.max(h >> 1, 1);
                    }
                }
                const k = this.isTextureCube() ? 6 : 1;
                const memCost = this.getTextureCaps().calcMemoryUsage(this._format, params.glType[0], this._width * this._height * this._depth * k);
                this._device.updateVideoMemoryCost(memCost - this._memCost);
                this._memCost = memCost;
            }
        }
    }
    /** @internal */ _calcMipLevelCount(format, width, height, depth) {
        if (hasDepthChannel(format) || this.isTextureVideo()) {
            return 1;
        }
        if (this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) {
            return 1;
        }
        if (!this._device.isWebGL2 && (!isPowerOf2(width) || !isPowerOf2(height))) {
            return 1;
        }
        const params = this.getTextureCaps().getTextureFormatInfo(format);
        if (!params || !params.renderable) {
            return 1;
        }
        let size = Math.max(width, height);
        if (this.isTexture3D()) {
            size = Math.max(size, depth);
        }
        return Math.floor(Math.log2(size)) + 1;
    }
    /** @internal */ _getSamplerOptions(params, shadow) {
        const comparison = this.isDepth() && shadow;
        const filterable = params.filterable || comparison;
        const magFilter = filterable ? 'linear' : 'nearest';
        const minFilter = filterable ? 'linear' : 'nearest';
        const mipFilter = this._mipLevelCount > 1 ? filterable ? 'linear' : 'nearest' : 'none';
        return {
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter,
            minFilter,
            mipFilter,
            compare: comparison ? 'le' : null
        };
    }
}

class WebGLTexture2D extends WebGLBaseTexture {
    constructor(device){
        super(device, '2d');
    }
    isTexture2D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, width, height, params.glFormat, params.glType[0], data);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, xOffset, yOffset, x, y, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        if (x === 0 && y === 0 && width === data.width && height === data.height) {
            this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, params.glFormat, params.glType[0], data);
        } else {
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, x, y, width, height, 0, 0, width, height);
            this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, params.glFormat, params.glType[0], cvs);
            cvs.width = 0;
            cvs.height = 0;
        }
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    async readPixels(x, y, w, h, faceOrLevel, mipLevel, buffer) {
        if (faceOrLevel !== 0) {
            throw new Error(`Texture2D.readPixels(): parameter 'faceOrLayer' must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        if (!this.device.isContextLost() && !this.disposed) {
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            await this._device.readPixels(0, x, y, w, h, buffer);
            this._device.popDeviceStates();
            fb.dispose();
        }
    }
    readPixelsToBuffer(x, y, w, h, faceOrLevel, mipLevel, buffer) {
        if (faceOrLevel !== 0) {
            throw new Error(`Texture2D.readPixelsToBuffer(): parameter 'faceOrLayer' must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        if (!this.device.isContextLost() && !this.disposed) {
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
            this._device.popDeviceStates();
            fb.dispose();
        }
    }
    loadFromElement(element, sRGB, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            const format = sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm';
            this.loadImage(element, format);
        }
    }
    createEmpty(format, width, height, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, width, height, 0);
        }
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (data.isCubemap || data.isVolume) {
            console.error('loading 2d texture with mipmap data failed: data is not 2d texture');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error(new Error('webgl device does not support storage texture'));
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, width, height, numMipLevels) {
        this.allocInternal(format, width, height, 1, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    /** @internal */ loadLevels(levels, sRGB) {
        let format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        let swizzle = false;
        if (format === 'bgra8unorm') {
            format = 'rgba8unorm';
            swizzle = true;
        } else if (format === 'bgra8unorm-srgb') {
            format = 'rgba8unorm-srgb';
            swizzle = true;
        }
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.warn('No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            const target = textureTargetMap[this._target];
            this._device.context.bindTexture(target, this._object);
            this.device.clearErrors();
            for(let i = 0; i < this._mipLevelCount; i++){
                if (levels.isCompressed) {
                    this._device.context.compressedTexSubImage2D(target, i, 0, 0, levels.mipDatas[0][i].width, levels.mipDatas[0][i].height, params.glInternalFormat, levels.mipDatas[0][i].data);
                } else {
                    if (swizzle) {
                        // convert bgra to rgba
                        for(let j = 0; j < levels.mipDatas[0][i].width * levels.mipDatas[0][i].height; j++){
                            const t = levels.mipDatas[0][i].data[j * 4];
                            levels.mipDatas[0][i].data[j * 4] = levels.mipDatas[0][i].data[j * 4 + 2];
                            levels.mipDatas[0][i].data[j * 4 + 2] = t;
                        }
                    }
                    this._device.context.texSubImage2D(target, i, 0, 0, levels.mipDatas[0][i].width, levels.mipDatas[0][i].height, params.glFormat, params.glType[0], levels.mipDatas[0][i].data);
                }
                const err = this.device.getError();
                if (err) {
                    console.error(err);
                    return;
                }
            }
        }
    }
    /** @internal */ loadImage(element, format) {
        this.allocInternal(format, Number(element.width), Number(element.height), 1, 0);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            this.device.clearErrors();
            const target = textureTargetMap[this._target];
            this._device.context.bindTexture(target, this._object);
            this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 4);
            this._device.context.texSubImage2D(target, 0, 0, 0, params.glFormat, params.glType[0], element);
            const err = this.device.getError();
            if (err) {
                console.error(err);
            }
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
}

class WebGLTexture2DArray extends WebGLBaseTexture {
    constructor(device){
        if (!device.isWebGL2) {
            throw new Error('device does not support 2d texture array');
        }
        super(device, '2darray');
    }
    isTexture2DArray() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        const gl = this._device.context;
        gl.bindTexture(textureTargetMap[this._target], this._object);
        gl.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, zOffset, width, height, depth, params.glFormat, params.glType[0], data);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, 1) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture2DArray.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, levels.arraySize, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            const gl = this._device.context;
            gl.bindTexture(textureTargetMap[this._target], this._object);
            this.device.clearErrors();
            for(let layer = 0; layer < levels.arraySize; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture2DArray.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    if (levels.isCompressed) {
                        gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glInternalFormat, levels.mipDatas[layer][i].data);
                    } else {
                        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glFormat, params.glType[0], levels.mipDatas[layer][i].data);
                    }
                    const err = this.device.getError();
                    if (err) {
                        console.error(err);
                        return;
                    }
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
    updateFromElement(data, xOffset, yOffset, layerIndex, x, y, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        const gl = this._device.context;
        gl.bindTexture(textureTargetMap[this._target], this._object);
        gl.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        if (x === 0 && y === 0 && width === data.width && height === data.height) {
            gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, layerIndex, width, height, 1, params.glFormat, params.glType[0], data);
        } else {
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, x, y, width, height, 0, 0, width, height);
            gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, layerIndex, width, height, 1, params.glFormat, params.glType[0], cvs);
            cvs.width = 0;
            cvs.height = 0;
        }
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, width, height, depth, 0);
        }
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixels(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        return new Promise((resolve)=>{
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentLayer(0, layer);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixels(0, x, y, w, h, buffer).then(()=>{
                fb.dispose();
                resolve();
            });
            this._device.popDeviceStates();
        });
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        const fb = this._device.createFrameBuffer([
            this
        ], null);
        fb.setColorAttachmentLayer(0, layer);
        fb.setColorAttachmentMipLevel(0, mipLevel);
        fb.setColorAttachmentGenerateMipmaps(0, false);
        this._device.pushDeviceStates();
        this._device.setFramebuffer(fb);
        this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
        this._device.popDeviceStates();
        fb.dispose();
    }
    loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
}

class WebGLTexture3D extends WebGLBaseTexture {
    constructor(device){
        if (!device.isWebGL2) {
            throw new Error('device does not support 3D texture');
        }
        super(device, '3d');
    }
    get depth() {
        return this._depth;
    }
    isTexture3D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        const gl = this._device.context;
        gl.bindTexture(textureTargetMap[this._target], this._object);
        gl.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, zOffset, width, height, depth, params.glFormat, params.glType[0], data);
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, width, height, depth, 0);
        }
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixels(): parameter mipLevel must be 0`);
        }
        return new Promise((resolve)=>{
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentLayer(0, layer);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixels(0, x, y, w, h, buffer).then(()=>{
                fb.dispose();
                resolve();
            });
            this._device.popDeviceStates();
        });
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixelsToBuffer(): parameter mipLevel must be 0`);
        }
        const fb = this._device.createFrameBuffer([
            this
        ], null);
        fb.setColorAttachmentLayer(0, layer);
        fb.setColorAttachmentGenerateMipmaps(0, false);
        this._device.pushDeviceStates();
        this._device.setFramebuffer(fb);
        this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
        this._device.popDeviceStates();
        fb.dispose();
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const depth = levels.depth;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, depth) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture2DArray.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, levels.arraySize, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            const gl = this._device.context;
            gl.bindTexture(textureTargetMap[this._target], this._object);
            this.device.clearErrors();
            for(let layer = 0; layer < depth; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture2DArray.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    if (levels.isCompressed) {
                        gl.compressedTexSubImage3D(gl.TEXTURE_3D, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glInternalFormat, levels.mipDatas[layer][i].data);
                    } else {
                        gl.texSubImage3D(gl.TEXTURE_3D, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glFormat, params.glType[0], levels.mipDatas[layer][i].data);
                    }
                    const err = this.device.getError();
                    if (err) {
                        console.error(err);
                        return;
                    }
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
    /** @internal */ loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
}

class WebGLTextureCube extends WebGLBaseTexture {
    constructor(device){
        super(device, 'cube');
    }
    init() {
        this.loadEmpty(this._format, this._width, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height, face) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        this._device.context.texSubImage2D(cubeMapFaceMap[face], 0, xOffset, yOffset, width, height, params.glFormat, params.glType[0], data);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, xOffset, yOffset, face, x, y, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        if (x === 0 && y === 0 && width === data.width && height === data.height) {
            this._device.context.texSubImage2D(cubeMapFaceMap[face], 0, xOffset, yOffset, params.glFormat, params.glType[0], data);
        } else {
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, x, y, width, height, 0, 0, width, height);
            this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, params.glFormat, params.glType[0], cvs);
            cvs.width = 0;
            cvs.height = 0;
        }
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    createEmpty(format, size, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, size, 0);
        }
    }
    readPixels(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        return new Promise((resolve)=>{
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentCubeFace(0, face);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixels(0, x, y, w, h, buffer).then(()=>{
                fb.dispose();
                resolve();
            });
            this._device.popDeviceStates();
        });
    }
    readPixelsToBuffer(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const fb = this._device.createFrameBuffer([
            this
        ], null);
        fb.setColorAttachmentCubeFace(0, face);
        fb.setColorAttachmentMipLevel(0, mipLevel);
        fb.setColorAttachmentGenerateMipmaps(0, false);
        this._device.pushDeviceStates();
        this._device.setFramebuffer(fb);
        this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
        this._device.popDeviceStates();
        fb.dispose();
    }
    isTextureCube() {
        return true;
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (!data.isCubemap) {
            console.error('loading cubmap with mipmap data failed: data is not cubemap');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('webgl device does not support storage texture');
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, size, mipLevelCount) {
        this.allocInternal(format, size, size, 1, mipLevelCount);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    loadImages(images, format) {
        const width = images[0].width;
        const height = images[0].height;
        if (images.length !== 6) {
            console.error(new Error('cubemap face list must have 6 images'));
            return;
        }
        for(let i = 1; i < 6; i++){
            if (images[i].width !== width || images[i].height !== height) {
                console.error(new Error('cubemap face images must have identical sizes'));
                return;
            }
        }
        if (width === 0 || height === 0) {
            return;
        }
        this.allocInternal(format, width, height, 1, 0);
        if (!this._device.isContextLost()) {
            this.device.clearErrors();
            this._device.context.bindTexture(textureTargetMap[this._target], this._object);
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            for(let face = 0; face < 6; face++){
                this._device.context.texSubImage2D(cubeMapFaceMap[face], 0, 0, 0, params.glFormat, params.glType[0], images[face]);
                const err = this.device.getError();
                if (err) {
                    console.error(err);
                    return;
                }
            }
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
    loadLevels(levels, sRGB) {
        const format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.warn('No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            this._device.context.bindTexture(textureTargetMap[this._target], this._object);
            this.device.clearErrors();
            for(let face = 0; face < 6; face++){
                const faceTarget = cubeMapFaceMap[face];
                if (this._mipLevelCount > 1 && levels.mipDatas[face].length !== this._mipLevelCount) {
                    console.log(`invalid texture data`);
                    return;
                }
                for(let i = 0; i < this._mipLevelCount; i++){
                    if (levels.isCompressed) {
                        this._device.context.compressedTexSubImage2D(faceTarget, i, 0, 0, levels.mipDatas[face][i].width, levels.mipDatas[face][i].height, params.glInternalFormat, levels.mipDatas[face][i].data);
                    } else {
                        this._device.context.texSubImage2D(faceTarget, i, 0, 0, levels.mipDatas[face][i].width, levels.mipDatas[face][i].height, params.glFormat, params.glType[0], levels.mipDatas[face][i].data);
                    }
                    const err = this.device.getError();
                    if (err) {
                        console.error(err);
                        return;
                    }
                }
            }
        }
    }
}

class WebGLTextureVideo extends WebGLBaseTexture {
    _source;
    _callbackId;
    constructor(device, source){
        super(device, '2d');
        this._source = null;
        this._callbackId = null;
        this._format = 'unknown';
        this.loadFromElement(source);
    }
    isTextureVideo() {
        return true;
    }
    get source() {
        return this._source;
    }
    destroy() {
        if (this._source && this._callbackId !== null) {
            this._source.cancelVideoFrameCallback(this._callbackId);
        }
        super.destroy();
    }
    init() {
        this.loadElement(this._source);
    }
    /** @internal */ loadFromElement(el) {
        this._flags = GPUResourceUsageFlags.TF_NO_MIPMAP;
        this.loadElement(el);
    }
    generateMipmaps() {
    // Does nothing
    }
    readPixels(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixels()`);
    }
    readPixelsToBuffer(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixelsToBuffer()`);
    }
    /** @internal */ updateVideoFrame() {
        if (this.object && this._source.currentTime > 0 && !this._source.requestVideoFrameCallback) {
            this.update();
            return true;
        }
        return false;
    }
    /** @internal */ update() {
        this.allocInternal('rgba8unorm', this._source.videoWidth, this._source.videoHeight, 1, 1);
        if (!this._device.isContextLost()) {
            const target = textureTargetMap[this._target];
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            this._device.context.bindTexture(target, this._object);
            this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
            this._device.context.texImage2D(target, 0, params.glInternalFormat, params.glFormat, params.glType[0], this._source);
        }
    }
    /** @internal */ loadElement(element) {
        if (this._source && this._callbackId !== null) {
            this._source.cancelVideoFrameCallback(this._callbackId);
            this._callbackId = null;
        }
        this._source = element;
        if (this._source?.requestVideoFrameCallback) {
            const that = this;
            that._callbackId = this._source.requestVideoFrameCallback(function cb() {
                if (that._object) {
                    that.update();
                    that._callbackId = that._source.requestVideoFrameCallback(cb);
                }
            });
        }
        this.allocInternal('rgba8unorm', Math.max(this._source.videoWidth, 1), Math.max(this._source.videoHeight, 1), 1, 1);
    }
}

class WebGLVertexLayout extends WebGLGPUObject {
    _vertexData;
    _dirty;
    constructor(device, options){
        super(device);
        this._vertexData = new VertexData();
        this._dirty = false;
        for (const vb of options.vertexBuffers){
            this._vertexData.setVertexBuffer(vb.buffer, vb.stepMode);
        }
        if (options.indexBuffer) {
            this._vertexData.setIndexBuffer(options.indexBuffer);
        }
        this.load();
    }
    destroy() {
        if (this._object && this._device.vaoExt) {
            this._device.vaoExt.deleteVertexArray(this._object);
        }
        this._object = null;
    }
    async restore() {
        if (!this._device.isContextLost()) {
            this.load();
        }
    }
    get vertexBuffers() {
        return this._vertexData.vertexBuffers;
    }
    get indexBuffer() {
        return this._vertexData.indexBuffer;
    }
    setDrawOffset(buffer, byteOffset) {
        for (const info of this._vertexData.vertexBuffers){
            if (info?.buffer === buffer && info.drawOffset !== byteOffset) {
                info.drawOffset = byteOffset;
                this._dirty = true;
            }
        }
    }
    getVertexBuffer(semantic) {
        return this._vertexData.getVertexBuffer(semantic);
    }
    getVertexBufferInfo(semantic) {
        return this._vertexData.getVertexBufferInfo(semantic);
    }
    getIndexBuffer() {
        return this._vertexData.getIndexBuffer();
    }
    bind() {
        if (this._object && this._device.vaoExt) {
            this._device.vaoExt.bindVertexArray(this._object);
            if (this._dirty) {
                this._dirty = false;
                this.bindBuffers();
            }
        } else {
            this.bindBuffers();
        }
    }
    draw(primitiveType, first, count) {
        this._device.setVertexLayout(this);
        this._device.draw(primitiveType, first, count);
    }
    drawInstanced(primitiveType, first, count, numInstances) {
        this._device.setVertexLayout(this);
        this._device.drawInstanced(primitiveType, first, count, numInstances);
    }
    isVertexLayout() {
        return true;
    }
    load() {
        if (this._device.isContextLost()) {
            return;
        }
        if (this._device.vaoExt) {
            if (!this._object) {
                this._object = this._device.vaoExt.createVertexArray();
                this._device.vaoExt.bindVertexArray(this._object);
                this.bindBuffers();
                this._device.vaoExt.bindVertexArray(null);
            }
        } else {
            this._object = {};
        }
    }
    bindBuffers() {
        const vertexBuffers = this._vertexData.vertexBuffers;
        const gl = this._device.context;
        for(let loc = 0; loc < vertexBuffers.length; loc++){
            const bufferInfo = vertexBuffers[loc];
            const buffer = bufferInfo?.buffer;
            if (buffer) {
                if (buffer.disposed) {
                    buffer.reload();
                }
                gl.bindBuffer(WebGLEnum.ARRAY_BUFFER, buffer.object);
                gl.enableVertexAttribArray(loc);
                if (bufferInfo.stepMode === 'instance' && this._device.instancedArraysExt) {
                    gl.vertexAttribPointer(loc, bufferInfo.type.cols, typeMap[bufferInfo.type.scalarType], bufferInfo.type.normalized, bufferInfo.stride, bufferInfo.offset);
                    this._device.instancedArraysExt.vertexAttribDivisor(loc, 1);
                } else {
                    gl.vertexAttribPointer(loc, bufferInfo.type.cols, typeMap[bufferInfo.type.scalarType], bufferInfo.type.normalized, bufferInfo.stride, bufferInfo.drawOffset + bufferInfo.offset);
                }
            } else {
                gl.disableVertexAttribArray(loc);
            }
        }
        if (this._vertexData.indexBuffer?.disposed) {
            this._vertexData.indexBuffer.reload();
        }
        gl.bindBuffer(WebGLEnum.ELEMENT_ARRAY_BUFFER, this._vertexData.indexBuffer ? this._vertexData.indexBuffer.object : null);
    }
}

class WebGLGPUBuffer extends WebGLGPUObject {
    _size;
    _usage;
    _systemMemoryBuffer;
    _systemMemory;
    _memCost;
    constructor(device, usage, data, systemMemory = false){
        super(device);
        if (usage & GPUResourceUsageFlags.BF_VERTEX && usage & GPUResourceUsageFlags.BF_INDEX) {
            throw new Error('buffer usage must not have Vertex and Index simultaneously');
        }
        if (!device.isWebGL2 && !(usage & GPUResourceUsageFlags.BF_VERTEX) && !(usage & GPUResourceUsageFlags.BF_INDEX) && !(usage & GPUResourceUsageFlags.BF_UNIFORM)) {
            throw new Error('no Vertex or Index or Uniform usage set when creating buffer');
        }
        if (device.isWebGL2 && !(usage & ~GPUResourceUsageFlags.DYNAMIC)) {
            throw new Error('buffer usage not set when creating buffer');
        }
        if (usage & GPUResourceUsageFlags.DYNAMIC && usage & GPUResourceUsageFlags.MANAGED) {
            throw new Error('buffer usage DYNAMIC and MANAGED can not be both set');
        }
        this._object = null;
        this._memCost = 0;
        this._usage = usage;
        this._size = typeof data === 'number' ? data : data.byteLength;
        if (this._size <= 0) {
            throw new Error('can not create buffer with zero size');
        }
        this._systemMemory = !!systemMemory;
        if (this._systemMemory || this._usage & GPUResourceUsageFlags.MANAGED) {
            this._systemMemoryBuffer = new Uint8Array(this._size);
            if (data && typeof data !== 'number') {
                this._systemMemoryBuffer.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            }
        } else {
            this._systemMemoryBuffer = null;
        }
        if (!this._systemMemory) {
            this.load(this._systemMemoryBuffer || (typeof data === 'number' ? null : data));
        }
    }
    get byteLength() {
        return this._size;
    }
    get systemMemoryBuffer() {
        return this._systemMemoryBuffer?.buffer || null;
    }
    get usage() {
        return this._usage;
    }
    bufferSubData(dstByteOffset, data, srcPos, srcLength) {
        srcPos = Number(srcPos) || 0;
        dstByteOffset = Number(dstByteOffset) || 0;
        srcLength = Number(srcLength) || data.length - srcPos;
        if (srcPos + srcLength > data.length) {
            throw new Error('bufferSubData() failed: source buffer is too small');
        }
        if (dstByteOffset + srcLength * data.BYTES_PER_ELEMENT > this.byteLength) {
            throw new Error('bufferSubData() failed: dest buffer is too small');
        }
        if (this._systemMemory || this._usage & GPUResourceUsageFlags.MANAGED) {
            // copy to system backup buffer if present
            this._systemMemoryBuffer.set(new Uint8Array(data.buffer, data.byteOffset + srcPos * data.BYTES_PER_ELEMENT, srcLength * data.BYTES_PER_ELEMENT), dstByteOffset);
        }
        if (!this._systemMemory && !this.device.isContextLost()) {
            if (this.disposed) {
                this.reload();
            }
            if (!this._device.isWebGL2 && (srcPos !== 0 || srcLength !== data.length)) {
                data = data.subarray(srcPos, srcPos + srcLength);
            }
            this._device.vaoExt?.bindVertexArray(null);
            let target;
            if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                target = WebGLEnum.ELEMENT_ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                target = WebGLEnum.ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                target = WebGLEnum.UNIFORM_BUFFER;
            } else if (this._usage & (GPUResourceUsageFlags.BF_READ | GPUResourceUsageFlags.BF_WRITE)) {
                target = WebGLEnum.COPY_WRITE_BUFFER;
            } else {
                throw new Error(`Invalid buffer usage`);
            }
            this._device.context.bindBuffer(target, this._object);
            if (this._device.isWebGL2) {
                this._device.context.bufferSubData(target, dstByteOffset, data, srcPos, srcLength);
            } else {
                this._device.context.bufferSubData(target, dstByteOffset, data);
            }
        }
    }
    async getBufferSubData(dstBuffer, offsetInBytes, sizeInBytes) {
        if (this.disposed) {
            this.reload();
        }
        return this._getBufferData(dstBuffer, offsetInBytes, sizeInBytes);
    }
    async _getBufferData(dstBuffer, offsetInBytes, sizeInBytes) {
        offsetInBytes = Number(offsetInBytes) || 0;
        sizeInBytes = Number(sizeInBytes) || this.byteLength - offsetInBytes;
        if (offsetInBytes < 0 || offsetInBytes + sizeInBytes > this.byteLength) {
            throw new Error('data query range out of bounds');
        }
        if (dstBuffer && dstBuffer.byteLength < sizeInBytes) {
            throw new Error('no enough space for querying buffer data');
        }
        dstBuffer = dstBuffer || new Uint8Array(sizeInBytes);
        if (this._systemMemoryBuffer) {
            dstBuffer.set(new Uint8Array(this._systemMemoryBuffer, offsetInBytes, sizeInBytes));
        } else {
            const gl = this._device.context;
            if (isWebGL2(gl)) {
                const sync = gl.fenceSync(WebGLEnum.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                await this.clientWaitAsync(gl, sync, 0, 10);
                gl.deleteSync(sync);
            }
            this._device.vaoExt?.bindVertexArray(null);
            let target;
            if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                target = WebGLEnum.ELEMENT_ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                target = WebGLEnum.ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                target = WebGLEnum.UNIFORM_BUFFER;
            } else if (this._usage & (GPUResourceUsageFlags.BF_READ | GPUResourceUsageFlags.BF_WRITE)) {
                target = WebGLEnum.COPY_READ_BUFFER;
            } else {
                throw new Error(`Invalid buffer usage`);
            }
            gl.bindBuffer(target, this._object);
            gl.getBufferSubData(target, offsetInBytes, dstBuffer, 0, sizeInBytes);
            gl.bindBuffer(target, null);
        }
        return dstBuffer;
    }
    async restore() {
        if (!this._systemMemory && !this._object && !this._device.isContextLost()) {
            this.load(this._systemMemoryBuffer);
        }
    }
    destroy() {
        if (!this._systemMemory && this._object) {
            this._device.context.deleteBuffer(this._object);
            this._object = null;
            this._device.updateVideoMemoryCost(-this._memCost);
            this._memCost = 0;
        }
    }
    isBuffer() {
        return true;
    }
    load(data) {
        if (!this._device.isContextLost()) {
            if (!this._object) {
                this._object = this._device.context.createBuffer();
            }
            this._device.vaoExt?.bindVertexArray(null);
            let usage = this._usage & GPUResourceUsageFlags.DYNAMIC ? WebGLEnum.DYNAMIC_DRAW : WebGLEnum.STATIC_DRAW;
            let target;
            if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                target = WebGLEnum.ELEMENT_ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                target = WebGLEnum.ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                target = WebGLEnum.UNIFORM_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_READ) {
                target = WebGLEnum.COPY_READ_BUFFER;
                usage = WebGLEnum.STREAM_READ;
            } else if (this._usage & GPUResourceUsageFlags.BF_WRITE) {
                target = WebGLEnum.COPY_WRITE_BUFFER;
            } else {
                throw new Error(`WebGLGPUBuffer.load() failed: invalid buffer usage: ${this._usage}`);
            }
            this._device.context.bindBuffer(target, this._object);
            if (data) {
                this._device.context.bufferData(target, data, usage);
            } else {
                this._device.context.bufferData(target, this._size + 15 & ~15, usage);
            }
        }
        this._device.updateVideoMemoryCost(this._size - this._memCost);
        this._memCost = this._size;
    }
    /** @internal */ async clientWaitAsync(gl, sync, flags, interval_ms) {
        return new Promise((resolve, reject)=>{
            function test() {
                const res = gl.clientWaitSync(sync, flags, 0);
                if (res == gl.WAIT_FAILED) {
                    reject();
                    return;
                }
                if (res == gl.TIMEOUT_EXPIRED) {
                    setTimeout(test, interval_ms);
                    return;
                }
                resolve();
            }
            test();
        });
    }
}

const typeU16$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const typeU32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
class WebGLIndexBuffer extends WebGLGPUBuffer {
    indexType;
    length;
    constructor(device, data, usage){
        if (!(data instanceof Uint16Array) && !(data instanceof Uint32Array)) {
            throw new Error('invalid index data');
        }
        super(device, GPUResourceUsageFlags.BF_INDEX | usage, data);
        this.indexType = data instanceof Uint16Array ? typeU16$1 : typeU32;
        this.length = data.length;
    }
}

const STATUS_UNCHECKED = 0;
const STATUS_OK = 1;
const STATUS_FAILED = 2;
class WebGLFrameBuffer extends WebGLGPUObject {
    _options;
    _needBindBuffers;
    _drawTags;
    _lastDrawTag;
    _status;
    _statusAA;
    _width;
    _height;
    _isMRT;
    _drawBuffers;
    _depthAttachmentTarget;
    _colorAttachmentsAA;
    _depthAttachmentAA;
    _intermediateAttachments;
    _framebufferAA;
    constructor(device, colorAttachments, depthAttachment, opt){
        super(device);
        if (colorAttachments.length > 0 && colorAttachments.findIndex((val)=>!val) >= 0) {
            throw new Error('WebGLFramebuffer(): invalid color attachments');
        }
        this._object = null;
        this._framebufferAA = null;
        this._colorAttachmentsAA = null;
        this._depthAttachmentAA = null;
        this._intermediateAttachments = null;
        this._needBindBuffers = false;
        this._drawTags = 0;
        this._lastDrawTag = -1;
        this._status = STATUS_UNCHECKED;
        this._statusAA = STATUS_UNCHECKED;
        this._options = {
            colorAttachments: colorAttachments?.length > 0 ? colorAttachments.map((value)=>({
                    texture: value,
                    face: 0,
                    layer: 0,
                    level: 0,
                    generateMipmaps: true
                })) : null,
            depthAttachment: depthAttachment ? {
                texture: depthAttachment,
                face: 0,
                layer: 0,
                level: 0,
                generateMipmaps: false
            } : null,
            sampleCount: device.type === 'webgl' ? 1 : opt?.sampleCount ?? 1,
            ignoreDepthStencil: opt?.ignoreDepthStencil ?? false
        };
        if (!this._options.colorAttachments && !this._options.depthAttachment) {
            throw new Error('WebGLFramebuffer(): colorAttachments or depthAttachment must be specified');
        }
        this._width = this._options.colorAttachments ? this._options.colorAttachments[0].texture.width : this._options.depthAttachment.texture.width;
        this._height = this._options.colorAttachments ? this._options.colorAttachments[0].texture.height : this._options.depthAttachment.texture.height;
        if (this._options.colorAttachments && this._options.colorAttachments.findIndex((val)=>val.texture.width !== this._width || val.texture.height !== this._height) >= 0 || this._options.depthAttachment && (this._options.depthAttachment.texture.width !== this._width || this._options.depthAttachment.texture.height !== this._height)) {
            throw new Error('WebGLFramebuffer(): attachment textures must have same width and height');
        }
        this._drawBuffers = this._options.colorAttachments?.map((val, index)=>WebGLEnum.COLOR_ATTACHMENT0 + index) ?? [];
        this._isMRT = this._drawBuffers.length > 1;
        if (this._options.depthAttachment) {
            const format = this._options.depthAttachment.texture.format;
            this._depthAttachmentTarget = hasStencilChannel(format) ? WebGLEnum.DEPTH_STENCIL_ATTACHMENT : WebGLEnum.DEPTH_ATTACHMENT;
        } else {
            this._depthAttachmentTarget = WebGLEnum.NONE;
        }
        this._init();
    }
    tagDraw() {
        this._drawTags++;
    }
    isMRT() {
        return this._isMRT;
    }
    getWidth() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return Math.max(attachment.texture.width >> attachment.level, 1);
    }
    getHeight() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return Math.max(attachment.texture.height >> attachment.level, 1);
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            if (this._options?.depthAttachment?.texture?.disposed) {
                await this._options.depthAttachment.texture.reload();
            }
            if (this._options?.colorAttachments) {
                for (const k of this._options.colorAttachments){
                    if (k?.texture?.disposed) {
                        await k.texture.reload();
                    }
                }
            }
        }
        this._init();
    }
    destroy() {
        if (this._object) {
            this._device.context.deleteFramebuffer(this._object);
            this._object = null;
            if (this._colorAttachmentsAA) {
                for (const rb of this._colorAttachmentsAA){
                    this._device.context.deleteRenderbuffer(rb);
                }
                this._colorAttachmentsAA = null;
            }
            if (this._depthAttachmentAA) {
                this._device.context.deleteRenderbuffer(this._depthAttachmentAA);
                this._depthAttachmentAA = null;
            }
            if (this._framebufferAA) {
                this._device.context.deleteFramebuffer(this._framebufferAA);
                this._framebufferAA = null;
            }
            if (this._intermediateAttachments) {
                for (const entry of this._intermediateAttachments){
                    for (const rb of entry[1]){
                        if (rb) {
                            this._device.context.deleteTexture(rb.texture);
                        }
                    }
                }
                this._intermediateAttachments = null;
            }
        }
    }
    setColorAttachmentGenerateMipmaps(index, generateMipmaps) {
        const k = this._options.colorAttachments?.[index];
        if (k) {
            k.generateMipmaps = !!generateMipmaps;
        }
    }
    setColorAttachmentCubeFace(index, face) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.face !== face) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.face = face;
                this.bind();
            } else {
                k.face = face;
            }
        }
    }
    setColorAttachmentMipLevel(index, level) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.level !== level) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.level = level;
                this.bind();
            } else {
                k.level = level;
            }
        }
    }
    setColorAttachmentLayer(index, layer) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.layer !== layer) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.layer = layer;
                this.bind();
            } else {
                k.layer = layer;
            }
        }
    }
    setDepthAttachmentCubeFace(face) {
        const k = this._options.depthAttachment;
        if (k && k.face !== face) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.face = face;
                this.bind();
            } else {
                k.face = face;
            }
        }
    }
    setDepthAttachmentLayer(layer) {
        const k = this._options.depthAttachment;
        if (k && k.layer !== layer) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.layer = layer;
                this.bind();
            } else {
                k.layer = layer;
            }
        }
    }
    getDepthAttachment() {
        return this._options?.depthAttachment?.texture || null;
    }
    getColorAttachments() {
        return this._options.colorAttachments?.map((val)=>val.texture || null) || [];
    }
    bind() {
        if (this._object) {
            this._device.context._currentFramebuffer = this;
            this._lastDrawTag = -1;
            if (this._needBindBuffers) {
                this._needBindBuffers = false;
                if (!this._bindBuffersAA() || !this._bindBuffers()) {
                    this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
                    this._device.context._currentFramebuffer = null;
                    return false;
                }
            }
            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._framebufferAA || this._object);
            const drawBuffersExt = this._device.drawBuffersExt;
            if (drawBuffersExt) {
                drawBuffersExt.drawBuffers(this._drawBuffers);
            } else if (this._isMRT) {
                console.error('device does not support multiple framebuffer color attachments');
            }
            this._device.setViewport(null);
            this._device.setScissor(null);
            return true;
        }
        return false;
    }
    unbind() {
        if (this._device.context._currentFramebuffer === this) {
            this._updateMSAABuffer();
            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
            this._device.context._currentFramebuffer = null;
            this._device.setViewport();
            this._device.setScissor();
            const drawBuffersExt = this._device.drawBuffersExt;
            if (drawBuffersExt) {
                drawBuffersExt.drawBuffers([
                    WebGLEnum.BACK
                ]);
            }
            if (this._options.colorAttachments) {
                for (const attachment of this._options.colorAttachments){
                    const tex = attachment.texture;
                    if (attachment.level > 0) {
                        const texture = this._intermediateAttachments?.get(tex)?.[attachment.level];
                        if (texture) {
                            const tmpFramebuffer = this._device.context.createFramebuffer();
                            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, tmpFramebuffer);
                            this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, WebGLEnum.COLOR_ATTACHMENT0, WebGLEnum.TEXTURE_2D, texture.texture, 0);
                            if (tex.isTexture2D()) {
                                this._device.context.bindTexture(WebGLEnum.TEXTURE_2D, tex.object);
                                this._device.context.copyTexSubImage2D(WebGLEnum.TEXTURE_2D, attachment.level, 0, 0, 0, 0, texture.width, texture.height);
                            } else if (tex.isTextureCube()) {
                                this._device.context.bindTexture(WebGLEnum.TEXTURE_CUBE_MAP, tex.object);
                                this._device.context.copyTexSubImage2D(cubeMapFaceMap[attachment.face ?? CubeFace.PX], attachment.level, 0, 0, 0, 0, texture.width, texture.height);
                            }
                            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
                            this._device.context.deleteFramebuffer(tmpFramebuffer);
                        }
                    }
                    if (attachment.generateMipmaps && tex.mipLevelCount > 1) {
                        tex.generateMipmaps();
                    }
                }
            }
        }
    }
    _updateMSAABuffer() {
        if (this._options.sampleCount > 1 && this._lastDrawTag !== this._drawTags) {
            const gl = this._device.context;
            gl.bindFramebuffer(WebGLEnum.READ_FRAMEBUFFER, this._framebufferAA);
            gl.bindFramebuffer(WebGLEnum.DRAW_FRAMEBUFFER, this._object);
            let depthStencilMask = 0;
            if (!this._options.ignoreDepthStencil && this._depthAttachmentTarget !== WebGLEnum.NONE) {
                depthStencilMask = WebGLEnum.DEPTH_BUFFER_BIT | (this._depthAttachmentTarget === WebGLEnum.DEPTH_STENCIL_ATTACHMENT ? WebGLEnum.STENCIL_BUFFER_BIT : 0);
            }
            for(let i = 0; i < this._drawBuffers.length; i++){
                for(let j = 0; j < this._drawBuffers.length; j++){
                    this._drawBuffers[j] = j === i ? WebGLEnum.COLOR_ATTACHMENT0 + i : WebGLEnum.NONE;
                }
                gl.readBuffer(this._drawBuffers[i]);
                gl.drawBuffers(this._drawBuffers);
                gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, WebGLEnum.COLOR_BUFFER_BIT | depthStencilMask, WebGLEnum.NEAREST);
                depthStencilMask = 0;
            }
            if (depthStencilMask !== 0) {
                gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, depthStencilMask, WebGLEnum.NEAREST);
            }
            for(let i = 0; i < this._drawBuffers.length; i++){
                this._drawBuffers[i] = WebGLEnum.COLOR_ATTACHMENT0 + i;
            }
            gl.bindFramebuffer(WebGLEnum.READ_FRAMEBUFFER, null);
            gl.bindFramebuffer(WebGLEnum.DRAW_FRAMEBUFFER, null);
            this._lastDrawTag = this._drawTags;
        }
    }
    _load() {
        if (this._device.isContextLost()) {
            return;
        }
        do {
            if (this._options.sampleCount > 1) {
                this._framebufferAA = this._device.context.createFramebuffer();
                this._colorAttachmentsAA = [];
                this._depthAttachmentAA = null;
                if (!this._bindBuffersAA()) {
                    this.dispose();
                    break;
                }
            }
            this._object = this._device.context.createFramebuffer();
            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._object);
            if (!this._bindBuffers()) {
                this.dispose();
            }
        }while (0)
        this._lastDrawTag = -1;
        this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
        this._device.context._currentFramebuffer = null;
    }
    _bindAttachment(attachment, info) {
        if (info.texture) {
            let intermediateTexture = null;
            if (this.device.type === 'webgl' && info.level > 0) {
                if (!this._intermediateAttachments) {
                    this._intermediateAttachments = new Map();
                }
                let intermediateAttachments = this._intermediateAttachments.get(info.texture);
                if (!intermediateAttachments) {
                    intermediateAttachments = [];
                    this._intermediateAttachments.set(info.texture, intermediateAttachments);
                }
                if (!intermediateAttachments[info.level]) {
                    let width = info.texture.width;
                    let height = info.texture.height;
                    let level = info.level;
                    while(level-- > 0){
                        width = Math.max(width >> 1, 1);
                        height = Math.max(height >> 1, 1);
                    }
                    const formatInfo = this.device.getDeviceCaps().textureCaps.getTextureFormatInfo(info.texture.format);
                    intermediateTexture = this._device.context.createTexture();
                    this._device.context.bindTexture(WebGLEnum.TEXTURE_2D, intermediateTexture);
                    this._device.context.texImage2D(WebGLEnum.TEXTURE_2D, 0, formatInfo.glInternalFormat, width, height, 0, formatInfo.glFormat, formatInfo.glType[0], null);
                    intermediateAttachments[info.level] = {
                        texture: intermediateTexture,
                        width,
                        height
                    };
                } else {
                    intermediateTexture = intermediateAttachments[info.level].texture;
                }
            }
            if (intermediateTexture) {
                this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, attachment, WebGLEnum.TEXTURE_2D, intermediateTexture, 0);
            } else {
                if (info.texture.isTexture2D()) {
                    if (intermediateTexture) {
                        this._device.context.framebufferRenderbuffer(WebGLEnum.FRAMEBUFFER, attachment, WebGLEnum.RENDERBUFFER, intermediateTexture);
                    } else {
                        this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, attachment, WebGLEnum.TEXTURE_2D, info.texture.object, info.level ?? 0);
                    }
                } else if (info.texture.isTextureCube()) {
                    this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, attachment, cubeMapFaceMap[info.face ?? CubeFace.PX], info.texture.object, info.level ?? 0);
                } else if (info.texture.isTexture2DArray() || info.texture.isTexture3D()) {
                    this._device.context.framebufferTextureLayer(WebGLEnum.FRAMEBUFFER, attachment, info.texture.object, info.level ?? 0, info.layer ?? 0);
                } else {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    _bindBuffers() {
        if (!this._object) {
            return false;
        }
        this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._object);
        if (this._depthAttachmentTarget !== WebGLEnum.NONE) {
            if (!this._bindAttachment(this._depthAttachmentTarget, this._options.depthAttachment)) {
                return false;
            }
        }
        for(let i = 0; (i < this._options.colorAttachments?.length) ?? 0; i++){
            const opt = this._options.colorAttachments[i];
            if (opt.texture) {
                if (!this._bindAttachment(WebGLEnum.COLOR_ATTACHMENT0 + i, opt)) {
                    return false;
                }
            }
        }
        if (this._status === STATUS_UNCHECKED) {
            const status = this._device.context.checkFramebufferStatus(WebGLEnum.FRAMEBUFFER);
            if (status !== WebGLEnum.FRAMEBUFFER_COMPLETE) {
                console.error(`Framebuffer not complete: ${status}`);
                this._status = STATUS_FAILED;
            } else {
                this._status = STATUS_OK;
            }
        }
        return this._status === STATUS_OK;
    }
    _createRenderbufferAA(texture) {
        const renderBuffer = this._device.context.createRenderbuffer();
        const formatInfo = this.device.getDeviceCaps().textureCaps.getTextureFormatInfo(texture.format);
        this._device.context.bindRenderbuffer(WebGLEnum.RENDERBUFFER, renderBuffer);
        this._device.context.renderbufferStorageMultisample(WebGLEnum.RENDERBUFFER, this._options.sampleCount, formatInfo.glInternalFormat, this._options.depthAttachment.texture.width, this._options.depthAttachment.texture.height);
        return renderBuffer;
    }
    _bindBuffersAA() {
        if (!this._framebufferAA) {
            return true;
        }
        this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._framebufferAA);
        if (this._depthAttachmentTarget !== WebGLEnum.NONE) {
            if (!this._depthAttachmentAA) {
                this._depthAttachmentAA = this._createRenderbufferAA(this._options.depthAttachment.texture);
            }
            this._device.context.framebufferRenderbuffer(WebGLEnum.FRAMEBUFFER, this._depthAttachmentTarget, WebGLEnum.RENDERBUFFER, this._depthAttachmentAA);
        }
        for(let i = 0; (i < this._options.colorAttachments?.length) ?? 0; i++){
            const opt = this._options.colorAttachments[i];
            if (opt.texture) {
                if (!this._colorAttachmentsAA[i]) {
                    this._colorAttachmentsAA[i] = this._createRenderbufferAA(this._options.colorAttachments[i].texture);
                }
                this._device.context.framebufferRenderbuffer(WebGLEnum.FRAMEBUFFER, WebGLEnum.COLOR_ATTACHMENT0 + i, WebGLEnum.RENDERBUFFER, this._colorAttachmentsAA[i]);
            }
        }
        if (this._statusAA === STATUS_UNCHECKED) {
            const status = this._device.context.checkFramebufferStatus(WebGLEnum.FRAMEBUFFER);
            if (status !== WebGLEnum.FRAMEBUFFER_COMPLETE) {
                console.error(`Framebuffer not complete: ${status}`);
                this._statusAA = STATUS_FAILED;
            } else {
                this._statusAA = STATUS_OK;
            }
        }
        return this._statusAA === STATUS_OK;
    }
    _init() {
        if (this._options.sampleCount !== 1 && this._options.sampleCount !== 4) {
            throw new Error(`WebGLFramebuffer(): Sample should be 1 or 4, got ${this._options.sampleCount}`);
        }
        if (this._options.sampleCount > 1 && !this._device.getDeviceCaps().framebufferCaps.supportMultisampledFramebuffer) {
            throw new Error('WebGLFramebuffer(): Multisampled frame buffer not supported');
        }
        this._load();
    }
    isFramebuffer() {
        return true;
    }
    getSampleCount() {
        return this._options.sampleCount;
    }
}

class WebGLRenderState {
    static _defaultState;
    static _currentState;
    apply(gl, force) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const c = this.constructor;
        if (force || c._currentState !== this) {
            this._apply(gl);
        }
        c._currentState = this;
    }
    static get defaultState() {
        return WebGLRenderState._defaultState;
    }
    static applyDefaults(gl, force) {
        if (force || this._currentState !== this._defaultState) {
            this._defaultState.apply(gl, force);
        }
    }
}
class WebGLColorState extends WebGLRenderState {
    static _defaultState = new WebGLColorState();
    static _currentState = null;
    redMask;
    greenMask;
    blueMask;
    alphaMask;
    constructor(){
        super();
        this.redMask = this.greenMask = this.blueMask = this.alphaMask = true;
    }
    clone() {
        return new WebGLColorState().setColorMask(this.redMask, this.greenMask, this.blueMask, this.alphaMask);
    }
    setColorMask(r, g, b, a) {
        this.redMask = r;
        this.greenMask = g;
        this.blueMask = b;
        this.alphaMask = a;
        return this;
    }
    _apply(gl) {
        gl.colorMask(this.redMask, this.greenMask, this.blueMask, this.alphaMask);
    }
}
class WebGLBlendingState extends WebGLRenderState {
    static _defaultState = new WebGLBlendingState();
    static _currentState = null;
    _srcBlendRGB;
    _dstBlendRGB;
    _srcBlendAlpha;
    _dstBlendAlpha;
    _rgbEquation;
    _alphaEquation;
    enabled;
    alphaToCoverageEnabled;
    constructor(){
        super();
        this.enabled = false;
        this.alphaToCoverageEnabled = false;
        this.srcBlendRGB = 'one';
        this.dstBlendRGB = 'zero';
        this.srcBlendAlpha = 'one';
        this.dstBlendAlpha = 'zero';
        this.rgbEquation = 'add';
        this.alphaEquation = 'add';
    }
    clone() {
        const other = new WebGLBlendingState();
        other.enable(this.enabled);
        other.enableAlphaToCoverage(this.alphaToCoverageEnabled);
        other.setBlendFuncRGB(this.srcBlendRGB, this.dstBlendRGB);
        other.setBlendFuncAlpha(this.srcBlendAlpha, this.dstBlendAlpha);
        other.setBlendEquation(this.rgbEquation, this.alphaEquation);
        return other;
    }
    get srcBlendRGB() {
        return blendFuncInvMap[this._srcBlendRGB];
    }
    set srcBlendRGB(val) {
        this._srcBlendRGB = blendFuncMap[val];
    }
    get dstBlendRGB() {
        return blendFuncInvMap[this._dstBlendRGB];
    }
    set dstBlendRGB(val) {
        this._dstBlendRGB = blendFuncMap[val];
    }
    get srcBlendAlpha() {
        return blendFuncInvMap[this._srcBlendAlpha];
    }
    set srcBlendAlpha(val) {
        this._srcBlendAlpha = blendFuncMap[val];
    }
    get dstBlendAlpha() {
        return blendFuncInvMap[this._dstBlendAlpha];
    }
    set dstBlendAlpha(val) {
        this._dstBlendAlpha = blendFuncMap[val];
    }
    get rgbEquation() {
        return blendEquationInvMap[this._rgbEquation];
    }
    set rgbEquation(val) {
        this._rgbEquation = blendEquationMap[val];
    }
    get alphaEquation() {
        return blendEquationInvMap[this._alphaEquation];
    }
    set alphaEquation(val) {
        this._alphaEquation = blendEquationMap[val];
    }
    enable(b) {
        this.enabled = !!b;
        return this;
    }
    enableAlphaToCoverage(b) {
        this.alphaToCoverageEnabled = !!b;
        return this;
    }
    setBlendFunc(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendFuncRGB(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        return this;
    }
    setBlendFuncAlpha(src, dest) {
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendEquation(rgb, alpha) {
        this.rgbEquation = rgb;
        this.alphaEquation = alpha;
        return this;
    }
    _apply(gl) {
        if (this.enabled) {
            gl.enable(WebGLEnum.BLEND);
            gl.blendEquationSeparate(this._rgbEquation, this._alphaEquation);
            if (this._srcBlendRGB === this._srcBlendAlpha && this._dstBlendRGB === this._dstBlendAlpha) {
                gl.blendFunc(this._srcBlendRGB, this._dstBlendRGB);
            } else {
                gl.blendFuncSeparate(this._srcBlendRGB, this._dstBlendRGB, this._srcBlendAlpha, this._dstBlendAlpha);
            }
        } else {
            gl.disable(WebGLEnum.BLEND);
        }
        if (this.alphaToCoverageEnabled) {
            gl.enable(WebGLEnum.SAMPLE_ALPHA_TO_COVERAGE);
        } else {
            gl.disable(WebGLEnum.SAMPLE_ALPHA_TO_COVERAGE);
        }
    }
}
class WebGLRasterizerState extends WebGLRenderState {
    static _defaultState = new WebGLRasterizerState();
    static _currentState = null;
    _cullMode;
    constructor(){
        super();
        this.cullMode = 'back';
    }
    clone() {
        return new WebGLRasterizerState().setCullMode(this.cullMode);
    }
    get cullMode() {
        return faceModeInvMap[this._cullMode];
    }
    set cullMode(val) {
        this._cullMode = faceModeMap[val];
    }
    setCullMode(mode) {
        this.cullMode = mode;
        return this;
    }
    get depthClampEnabled() {
        return false;
    }
    set depthClampEnabled(val) {
        this.enableDepthClamp(val);
    }
    enableDepthClamp(enable) {
        if (enable) {
            console.error('Depth clamp not supported');
        }
        return this;
    }
    _apply(gl) {
        if (this.cullMode == 'none') {
            gl.disable(WebGLEnum.CULL_FACE);
        } else {
            gl.enable(WebGLEnum.CULL_FACE);
            gl.cullFace(this._cullMode);
        }
    }
}
class WebGLDepthState extends WebGLRenderState {
    static _defaultState = new WebGLDepthState();
    static _currentState = null;
    testEnabled;
    writeEnabled;
    _compareFunc;
    constructor(){
        super();
        this.testEnabled = true;
        this.writeEnabled = true;
        this.compareFunc = 'le';
    }
    clone() {
        const other = new WebGLDepthState();
        other.enableTest(this.testEnabled);
        other.enableWrite(this.writeEnabled);
        other.setCompareFunc(this.compareFunc);
        return other;
    }
    get compareFunc() {
        return compareFuncInvMap[this._compareFunc];
    }
    set compareFunc(val) {
        this._compareFunc = compareFuncMap[val];
    }
    enableTest(b) {
        this.testEnabled = b;
        return this;
    }
    enableWrite(b) {
        this.writeEnabled = b;
        return this;
    }
    setCompareFunc(func) {
        this.compareFunc = func;
        return this;
    }
    _apply(gl) {
        if (this.testEnabled) {
            gl.enable(WebGLEnum.DEPTH_TEST);
            gl.depthFunc(this._compareFunc);
        } else {
            gl.disable(WebGLEnum.DEPTH_TEST);
        }
        gl.depthMask(this.writeEnabled);
    }
}
class WebGLStencilState extends WebGLRenderState {
    static _defaultState = new WebGLStencilState();
    static _currentState = null;
    enabled;
    writeMask;
    ref;
    readMask;
    _failOp;
    _failOpBack;
    _zFailOp;
    _zFailOpBack;
    _passOp;
    _passOpBack;
    _func;
    _funcBack;
    constructor(){
        super();
        this.enabled = false;
        this.failOp = this.failOpBack = 'keep';
        this.zFailOp = this.zFailOpBack = 'keep';
        this.passOp = this.passOpBack = 'keep';
        this.func = this.funcBack = 'always';
        this.ref = 0;
        this.writeMask = 0xffffffff;
        this.readMask = 0xffffffff;
    }
    clone() {
        const other = new WebGLStencilState();
        other.enable(this.enabled);
        other.setWriteMask(this.writeMask);
        other.setFrontOp(this.failOp, this.zFailOp, this.passOp);
        other.setBackOp(this.failOpBack, this.zFailOpBack, this.passOpBack);
        other.setFrontCompareFunc(this.func);
        other.setBackCompareFunc(this.funcBack);
        other.setReference(this.ref);
        other.setReadMask(this.readMask);
        return other;
    }
    get failOp() {
        return stencilOpInvMap[this._failOp];
    }
    set failOp(val) {
        this._failOp = stencilOpMap[val];
    }
    get failOpBack() {
        return stencilOpInvMap[this._failOpBack];
    }
    set failOpBack(val) {
        this._failOpBack = stencilOpMap[val];
    }
    get zFailOp() {
        return stencilOpInvMap[this._zFailOp];
    }
    set zFailOp(val) {
        this._zFailOp = stencilOpMap[val];
    }
    get zFailOpBack() {
        return stencilOpInvMap[this._zFailOpBack];
    }
    set zFailOpBack(val) {
        this._zFailOpBack = stencilOpMap[val];
    }
    get passOp() {
        return stencilOpInvMap[this._passOp];
    }
    set passOp(val) {
        this._passOp = stencilOpMap[val];
    }
    get passOpBack() {
        return stencilOpInvMap[this._passOpBack];
    }
    set passOpBack(val) {
        this._passOpBack = stencilOpMap[val];
    }
    get func() {
        return compareFuncInvMap[this._func];
    }
    set func(val) {
        this._func = compareFuncMap[val];
    }
    get funcBack() {
        return compareFuncInvMap[this._funcBack];
    }
    set funcBack(val) {
        this._funcBack = compareFuncMap[val];
    }
    enable(b) {
        this.enabled = b;
        return this;
    }
    setWriteMask(mask) {
        this.writeMask = mask;
        return this;
    }
    setFrontOp(fail, zfail, zpass) {
        this.failOp = fail;
        this.zFailOp = zfail;
        this.passOp = zpass;
        return this;
    }
    setBackOp(fail, zfail, zpass) {
        this.failOpBack = fail;
        this.zFailOpBack = zfail;
        this.passOpBack = zpass;
        return this;
    }
    setFrontCompareFunc(func) {
        this.func = func;
        return this;
    }
    setBackCompareFunc(func) {
        this.funcBack = func;
        return this;
    }
    setReference(ref) {
        this.ref = ref;
        return this;
    }
    setReadMask(mask) {
        this.readMask = mask;
        return this;
    }
    _apply(gl) {
        if (this.enabled) {
            gl.enable(WebGLEnum.STENCIL_TEST);
            gl.stencilMaskSeparate(WebGLEnum.FRONT, this.writeMask);
            gl.stencilMaskSeparate(WebGLEnum.BACK, this.writeMask);
            gl.stencilFuncSeparate(WebGLEnum.FRONT, this._func, this.ref, this.readMask);
            gl.stencilFuncSeparate(WebGLEnum.BACK, this._funcBack, this.ref, this.readMask);
            gl.stencilOpSeparate(WebGLEnum.FRONT, this._failOp, this._zFailOp, this._passOp);
            gl.stencilOpSeparate(WebGLEnum.BACK, this._failOpBack, this._zFailOpBack, this._passOpBack);
        } else {
            gl.disable(WebGLEnum.STENCIL_TEST);
        }
    }
}
class WebGLRenderStateSet {
    _gl;
    colorState;
    blendingState;
    rasterizerState;
    depthState;
    stencilState;
    constructor(gl){
        this._gl = gl;
        this.colorState = null;
        this.blendingState = null;
        this.rasterizerState = null;
        this.depthState = null;
        this.stencilState = null;
    }
    copyFrom(stateSet) {
        this.colorState = stateSet.colorState;
        this.blendingState = stateSet.blendingState;
        this.rasterizerState = stateSet.rasterizerState;
        this.depthState = stateSet.depthState;
        this.stencilState = stateSet.stencilState;
    }
    apply(force) {
        const gl = this._gl;
        if (this.colorState) {
            this.colorState.apply(gl, force);
        } else {
            WebGLColorState.applyDefaults(gl, force);
        }
        if (this.blendingState) {
            this.blendingState.apply(gl, force);
        } else {
            WebGLBlendingState.applyDefaults(gl, force);
        }
        if (this.rasterizerState) {
            this.rasterizerState.apply(gl, force);
        } else {
            WebGLRasterizerState.applyDefaults(gl, force);
        }
        if (this.depthState) {
            this.depthState.apply(gl, force);
        } else {
            WebGLDepthState.applyDefaults(gl, force);
        }
        if (this.stencilState) {
            this.stencilState.apply(gl, force);
        } else {
            WebGLStencilState.applyDefaults(gl, force);
        }
    }
    useColorState(state) {
        return this.colorState = state ?? this.colorState ?? new WebGLColorState();
    }
    defaultColorState() {
        this.colorState = null;
    }
    useBlendingState(state) {
        return this.blendingState = state ?? this.blendingState ?? new WebGLBlendingState();
    }
    defaultBlendingState() {
        this.blendingState = null;
    }
    useRasterizerState(state) {
        return this.rasterizerState = state ?? this.rasterizerState ?? new WebGLRasterizerState();
    }
    defaultRasterizerState() {
        this.rasterizerState = null;
    }
    useDepthState(state) {
        return this.depthState = state ?? this.depthState ?? new WebGLDepthState();
    }
    defaultDepthState() {
        this.depthState = null;
    }
    useStencilState(state) {
        return this.stencilState = state ?? this.stencilState ?? new WebGLStencilState();
    }
    defaultStencilState() {
        this.stencilState = null;
    }
    static applyDefaults(gl, force) {
        WebGLColorState.applyDefaults(gl, force);
        WebGLBlendingState.applyDefaults(gl, force);
        WebGLRasterizerState.applyDefaults(gl, force);
        WebGLDepthState.applyDefaults(gl, force);
        WebGLStencilState.applyDefaults(gl, force);
    }
}

const GPU_DISJOINT_EXT = 0x8fbb;
const TIME_ELAPSED_EXT = 0x88bf;
var QueryState;
(function(QueryState) {
    QueryState[QueryState["QUERY_STATE_NONE"] = 0] = "QUERY_STATE_NONE";
    QueryState[QueryState["QUERY_STATE_QUERYING"] = 1] = "QUERY_STATE_QUERYING";
    QueryState[QueryState["QUERY_STATE_FINISHED"] = 2] = "QUERY_STATE_FINISHED";
})(QueryState || (QueryState = {}));
class GPUTimer {
    _device;
    _query;
    _state;
    _timerQuery;
    _gpuTime;
    constructor(device){
        this._device = device;
        this._state = 0;
        this._gpuTime = null;
        const gl = this._device.context;
        if (isWebGL2(gl)) {
            const ext = gl.getExtension('EXT_disjoint_timer_query_webgl2');
            if (ext) {
                this._timerQuery = {
                    createQuery: gl.createQuery.bind(gl),
                    deleteQuery: gl.deleteQuery.bind(gl),
                    beginQuery: gl.beginQuery.bind(gl),
                    endQuery: gl.endQuery.bind(gl),
                    isQuery: gl.isQuery.bind(gl),
                    getQuery: gl.getQuery.bind(gl),
                    getQueryObject: gl.getQueryParameter.bind(gl),
                    queryCounter: ext.queryCounterEXT.bind(ext)
                };
            }
        } else {
            const ext = gl.getExtension('EXT_disjoint_timer_query');
            if (ext) {
                this._timerQuery = {
                    createQuery: ext.createQueryEXT.bind(ext),
                    deleteQuery: ext.deleteQueryEXT.bind(ext),
                    beginQuery: ext.beginQueryEXT.bind(ext),
                    endQuery: ext.endQueryEXT.bind(ext),
                    isQuery: ext.isQueryEXT.bind(ext),
                    getQuery: ext.getQueryEXT.bind(ext),
                    getQueryObject: ext.getQueryObjectEXT.bind(ext),
                    queryCounter: ext.queryCounterEXT.bind(ext)
                };
            }
        }
        this._query = this._timerQuery ? this._timerQuery.createQuery() : null;
    }
    get gpuTimerSupported() {
        return !!this._query;
    }
    begin() {
        if (this._state === 1) {
            this.end();
        }
        if (this._query) {
            this._timerQuery.beginQuery(TIME_ELAPSED_EXT, this._query);
        }
        this._gpuTime = null;
        this._state = 1;
    }
    end() {
        if (this._state === 1) {
            if (this._query) {
                this._timerQuery.endQuery(TIME_ELAPSED_EXT);
            }
            this._state = 2;
        }
    }
    ended() {
        return this._state !== 1;
    }
    elapsed() {
        if (this._state === 2) {
            if (this._gpuTime === null && this._query && this._timerQuery.getQueryObject(this._query, WebGLEnum.QUERY_RESULT_AVAILABLE)) {
                const gpuTimerDisjoint = this._device.context.getParameter(GPU_DISJOINT_EXT);
                if (!gpuTimerDisjoint) {
                    this._gpuTime = Number(this._timerQuery.getQueryObject(this._query, WebGLEnum.QUERY_RESULT)) / 1000000;
                }
            }
        }
        return this._gpuTime;
    }
}

class WebGLFramebufferCaps {
    _isWebGL2;
    _extDrawBuffers;
    _extFloatBlending;
    maxDrawBuffers;
    maxColorAttachmentBytesPerSample;
    supportMultisampledFramebuffer;
    supportFloatBlending;
    supportDepth32float;
    supportDepth32floatStencil8;
    constructor(gl){
        this._isWebGL2 = isWebGL2(gl);
        this._extDrawBuffers = this._isWebGL2 ? null : gl.getExtension('WEBGL_draw_buffers');
        this._extFloatBlending = gl.getExtension('EXT_float_blend');
        this.maxDrawBuffers = this._isWebGL2 || this._extDrawBuffers ? Math.min(gl.getParameter(WebGLEnum.MAX_COLOR_ATTACHMENTS), gl.getParameter(WebGLEnum.MAX_DRAW_BUFFERS)) : 1;
        this.maxColorAttachmentBytesPerSample = this.maxDrawBuffers * 16;
        this.supportMultisampledFramebuffer = isWebGL2(gl);
        this.supportFloatBlending = !!this._extFloatBlending;
        this.supportDepth32float = this._isWebGL2;
        this.supportDepth32floatStencil8 = this._isWebGL2;
    }
}
class WebGLMiscCaps {
    _isWebGL2;
    _extIndexUint32;
    _extBlendMinMax;
    supportOversizedViewport;
    supportBlendMinMax;
    support32BitIndex;
    supportDepthClamp;
    maxBindGroups;
    maxTexCoordIndex;
    constructor(gl){
        this._isWebGL2 = isWebGL2(gl);
        this._extBlendMinMax = null;
        this._extIndexUint32 = isWebGL2 ? gl.getExtension('OES_element_index_uint') : null;
        if (this._isWebGL2) {
            this.supportBlendMinMax = true;
            this.support32BitIndex = true;
        } else {
            this._extBlendMinMax = gl.getExtension('EXT_blend_minmax');
            this.supportBlendMinMax = !!this._extBlendMinMax;
            this.support32BitIndex = !!this._extIndexUint32;
        }
        this.supportOversizedViewport = true;
        this.supportDepthClamp = false;
        this.maxBindGroups = 4;
        this.maxTexCoordIndex = 8;
    }
}
class WebGLShaderCaps {
    _extFragDepth;
    _extStandardDerivatives;
    _extShaderTextureLod;
    supportFragmentDepth;
    supportStandardDerivatives;
    supportShaderTextureLod;
    supportHighPrecisionFloat;
    supportHighPrecisionInt;
    maxUniformBufferSize;
    uniformBufferOffsetAlignment;
    constructor(gl){
        this._extFragDepth = null;
        this._extStandardDerivatives = null;
        if (isWebGL2(gl)) {
            this.supportFragmentDepth = true;
            this.supportStandardDerivatives = true;
            this.supportShaderTextureLod = true;
            this.supportHighPrecisionFloat = true;
            this.maxUniformBufferSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE) || 16384;
            this.uniformBufferOffsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT) || 256;
        } else {
            this._extFragDepth = gl.getExtension('EXT_frag_depth');
            this.supportFragmentDepth = !!this._extFragDepth;
            this._extStandardDerivatives = gl.getExtension('OES_standard_derivatives');
            this.supportStandardDerivatives = !!this._extStandardDerivatives;
            this._extShaderTextureLod = gl.getExtension('EXT_shader_texture_lod');
            this.supportShaderTextureLod = !!this._extShaderTextureLod;
            this.supportHighPrecisionFloat = gl.getShaderPrecisionFormat && !!gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT)?.precision && !!gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)?.precision;
            this.maxUniformBufferSize = 0;
            this.uniformBufferOffsetAlignment = 1;
        }
    }
}
class WebGLTextureCaps {
    _isWebGL2;
    _extS3TC;
    _extS3TCSRGB;
    _extTextureFilterAnisotropic;
    _extDepthTexture;
    _extSRGB;
    _extTextureFloat;
    _extTextureFloatLinear;
    _extTextureHalfFloat;
    _extTextureHalfFloatLinear;
    _textureFormatInfos;
    maxTextureSize;
    maxCubeTextureSize;
    npo2Mipmapping;
    npo2Repeating;
    supportS3TC;
    supportS3TCSRGB;
    supportDepthTexture;
    support3DTexture;
    supportSRGBTexture;
    supportFloatTexture;
    supportLinearFloatTexture;
    supportHalfFloatTexture;
    supportLinearHalfFloatTexture;
    supportAnisotropicFiltering;
    supportFloatColorBuffer;
    supportHalfFloatColorBuffer;
    supportFloatBlending;
    constructor(gl){
        this._isWebGL2 = isWebGL2(gl);
        this._extTextureFilterAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        this.supportAnisotropicFiltering = !!this._extTextureFilterAnisotropic;
        if (this._isWebGL2) {
            this.supportDepthTexture = true;
        } else {
            this._extDepthTexture = gl.getExtension('WEBGL_depth_texture');
            this.supportDepthTexture = !!this._extDepthTexture;
        }
        this.support3DTexture = this._isWebGL2;
        this._extSRGB = this._isWebGL2 ? null : gl.getExtension('EXT_sRGB');
        this.supportSRGBTexture = this._isWebGL2 || !!this._extSRGB;
        if (this._isWebGL2) {
            this.supportFloatTexture = true;
        } else {
            this._extTextureFloat = gl.getExtension('OES_texture_float');
            this.supportFloatTexture = !!this._extTextureFloat;
        }
        this._extTextureFloatLinear = gl.getExtension('OES_texture_float_linear');
        this.supportLinearFloatTexture = !!this._extTextureFloatLinear;
        if (this._isWebGL2) {
            this.supportHalfFloatTexture = true;
            this.supportLinearHalfFloatTexture = true;
        } else {
            this._extTextureHalfFloat = gl.getExtension('OES_texture_half_float');
            this.supportHalfFloatTexture = !!this._extTextureHalfFloat;
            this._extTextureHalfFloatLinear = gl.getExtension('OES_texture_half_float_linear');
            this.supportLinearHalfFloatTexture = !!this._extTextureHalfFloatLinear;
        }
        if (this._isWebGL2) {
            if (gl.getExtension('EXT_color_buffer_float')) {
                this.supportHalfFloatColorBuffer = true;
                this.supportFloatColorBuffer = true;
            } else if (gl.getExtension('EXT_color_buffer_half_float')) {
                this.supportHalfFloatColorBuffer = true;
                this.supportFloatColorBuffer = false;
            } else {
                this.supportHalfFloatColorBuffer = false;
                this.supportFloatColorBuffer = false;
            }
        } else {
            this.supportFloatColorBuffer = !!gl.getExtension('WEBGL_color_buffer_float');
            this.supportHalfFloatColorBuffer = !!gl.getExtension('EXT_color_buffer_half_float');
        }
        this.supportFloatBlending = this.supportFloatColorBuffer && !!gl.getExtension('EXT_float_blend');
        this._extS3TC = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        this.supportS3TC = !!this._extS3TC;
        this._extS3TCSRGB = gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');
        this.supportS3TCSRGB = !!this._extS3TCSRGB;
        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.maxCubeTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        if (this._isWebGL2) {
            this.npo2Mipmapping = true;
            this.npo2Repeating = true;
        } else {
            this.npo2Mipmapping = false;
            this.npo2Repeating = false;
        }
        this._textureFormatInfos = {
            rgba8unorm: {
                glFormat: gl.RGBA,
                glInternalFormat: this._isWebGL2 ? gl.RGBA8 : gl.RGBA,
                glType: [
                    gl.UNSIGNED_BYTE,
                    gl.UNSIGNED_SHORT_4_4_4_4,
                    gl.UNSIGNED_SHORT_5_5_5_1
                ],
                filterable: true,
                renderable: true,
                compressed: false
            }
        };
        if (this.supportS3TC) {
            this._textureFormatInfos['dxt1'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt3'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt5'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
        }
        if (this.supportS3TCSRGB) {
            this._textureFormatInfos['dxt1-srgb'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TCSRGB.COMPRESSED_SRGB_S3TC_DXT1_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt3-srgb'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TCSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt5-srgb'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TCSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
        }
        if (isWebGL2(gl)) {
            this._textureFormatInfos['r8unorm'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R8,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: true,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r8snorm'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R8_SNORM,
                glType: [
                    gl.BYTE
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['r16f'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R16F,
                glType: [
                    gl.HALF_FLOAT,
                    gl.FLOAT
                ],
                filterable: this.supportLinearHalfFloatTexture,
                renderable: this.supportHalfFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['r32f'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: this.supportLinearFloatTexture,
                renderable: this.supportFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['r8ui'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R8UI,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r8i'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R8I,
                glType: [
                    gl.BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r16ui'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R16UI,
                glType: [
                    gl.UNSIGNED_SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r16i'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R16I,
                glType: [
                    gl.SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r32ui'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R32UI,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r32i'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R32I,
                glType: [
                    gl.INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg8unorm'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: true,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg8snorm'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8_SNORM,
                glType: [
                    gl.BYTE
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['rg16f'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG16F,
                glType: [
                    gl.HALF_FLOAT,
                    gl.FLOAT
                ],
                filterable: this.supportLinearHalfFloatTexture,
                renderable: this.supportHalfFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rg32f'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: this.supportLinearFloatTexture,
                renderable: this.supportFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rg8ui'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8UI,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg8i'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8I,
                glType: [
                    gl.BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg16ui'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG16UI,
                glType: [
                    gl.UNSIGNED_SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg16i'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG16I,
                glType: [
                    gl.SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg32ui'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG32UI,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg32i'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG32I,
                glType: [
                    gl.INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba8unorm-srgb'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.SRGB8_ALPHA8,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: true,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba8snorm'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.RGBA8_SNORM,
                glType: [
                    gl.BYTE
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['rgba16f'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.RGBA16F,
                glType: [
                    gl.HALF_FLOAT,
                    gl.FLOAT
                ],
                filterable: this.supportLinearHalfFloatTexture,
                renderable: this.supportHalfFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rgba32f'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.RGBA32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: this.supportLinearFloatTexture,
                renderable: this.supportFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rgba8ui'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA8UI,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba8i'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA8I,
                glType: [
                    gl.BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba16ui'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA16UI,
                glType: [
                    gl.UNSIGNED_SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba16i'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA16I,
                glType: [
                    gl.SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba32ui'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA32UI,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba32i'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA32I,
                glType: [
                    gl.INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg11b10uf'] = {
                glFormat: gl.RGB,
                glInternalFormat: gl.R11F_G11F_B10F,
                glType: [
                    gl.UNSIGNED_INT_10F_11F_11F_REV
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['d16'] = {
                glFormat: gl.DEPTH_COMPONENT,
                glInternalFormat: gl.DEPTH_COMPONENT16,
                glType: [
                    gl.UNSIGNED_SHORT,
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d24'] = {
                glFormat: gl.DEPTH_COMPONENT,
                glInternalFormat: gl.DEPTH_COMPONENT24,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d32f'] = {
                glFormat: gl.DEPTH_COMPONENT,
                glInternalFormat: gl.DEPTH_COMPONENT32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d24s8'] = {
                glFormat: gl.DEPTH_STENCIL,
                glInternalFormat: gl.DEPTH24_STENCIL8,
                glType: [
                    gl.UNSIGNED_INT_24_8
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d32fs8'] = {
                glFormat: gl.DEPTH_STENCIL,
                glInternalFormat: gl.DEPTH32F_STENCIL8,
                glType: [
                    gl.FLOAT_32_UNSIGNED_INT_24_8_REV
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
        } else {
            if (this.supportFloatTexture) {
                this._textureFormatInfos['rgba32f'] = {
                    glFormat: gl.RGBA,
                    glInternalFormat: gl.RGBA,
                    glType: [
                        gl.FLOAT,
                        gl.UNSIGNED_BYTE,
                        gl.UNSIGNED_SHORT_4_4_4_4,
                        gl.UNSIGNED_SHORT_5_5_5_1
                    ],
                    filterable: this.supportLinearFloatTexture,
                    renderable: this.supportFloatColorBuffer,
                    compressed: false
                };
            }
            if (this.supportHalfFloatTexture) {
                this._textureFormatInfos['rgba16f'] = {
                    glFormat: gl.RGBA,
                    glInternalFormat: gl.RGBA,
                    glType: [
                        this._extTextureHalfFloat.HALF_FLOAT_OES,
                        gl.UNSIGNED_BYTE,
                        gl.UNSIGNED_SHORT_4_4_4_4,
                        gl.UNSIGNED_SHORT_5_5_5_1
                    ],
                    filterable: this.supportLinearHalfFloatTexture,
                    renderable: this.supportHalfFloatColorBuffer,
                    compressed: false
                };
            }
            if (this.supportSRGBTexture) {
                this._textureFormatInfos['rgba8unorm-srgb'] = {
                    glFormat: this._extSRGB.SRGB_ALPHA_EXT,
                    glInternalFormat: this._extSRGB.SRGB_ALPHA_EXT,
                    glType: [
                        gl.UNSIGNED_BYTE
                    ],
                    filterable: true,
                    renderable: false,
                    compressed: false
                };
            }
            if (this.supportDepthTexture) {
                this._textureFormatInfos['d16'] = {
                    glFormat: gl.DEPTH_COMPONENT,
                    glInternalFormat: gl.DEPTH_COMPONENT,
                    glType: [
                        gl.UNSIGNED_SHORT
                    ],
                    filterable: false,
                    renderable: true,
                    compressed: false
                };
                this._textureFormatInfos['d24'] = {
                    glFormat: gl.DEPTH_COMPONENT,
                    glInternalFormat: gl.DEPTH_COMPONENT,
                    glType: [
                        gl.UNSIGNED_INT
                    ],
                    filterable: false,
                    renderable: true,
                    compressed: false
                };
                this._textureFormatInfos['d24s8'] = {
                    glFormat: gl.DEPTH_STENCIL,
                    glInternalFormat: gl.DEPTH_STENCIL,
                    glType: [
                        this._extDepthTexture.UNSIGNED_INT_24_8_WEBGL
                    ],
                    filterable: false,
                    renderable: true,
                    compressed: false
                };
            }
        }
    }
    calcMemoryUsage(format, type, numPixels) {
        switch(format){
            case 'd16':
            case 'd24':
            case 'd24s8':
            case 'd32f':
                switch(type){
                    case WebGLEnum.UNSIGNED_SHORT:
                        return numPixels * 2;
                    default:
                        return numPixels * 4;
                }
            case 'd32fs8':
                return numPixels * 8;
            case 'dxt1':
            case 'dxt1-srgb':
                return numPixels / 2;
            case 'dxt3':
            case 'dxt3-srgb':
            case 'dxt5':
            case 'dxt5-srgb':
                return numPixels;
            case 'r16f':
                switch(type){
                    case WebGLEnum.HALF_FLOAT:
                        return numPixels * 2;
                    default:
                        return numPixels * 4;
                }
            case 'r16i':
            case 'r16ui':
                return numPixels * 2;
            case 'r32f':
            case 'r32i':
            case 'r32ui':
                return numPixels * 4;
            case 'r8unorm':
            case 'r8snorm':
            case 'r8i':
            case 'r8ui':
                return numPixels;
            case 'rg16f':
                switch(type){
                    case WebGLEnum.HALF_FLOAT:
                        return numPixels * 4;
                    default:
                        return numPixels * 8;
                }
            case 'rg16i':
            case 'rg16ui':
                return numPixels * 4;
            case 'rg32f':
            case 'rg32i':
            case 'rg32ui':
                return numPixels * 8;
            case 'rg8unorm':
            case 'rg8snorm':
            case 'rg8i':
            case 'rg8ui':
                return numPixels * 2;
            case 'rgba16f':
                switch(type){
                    case WebGLEnum.HALF_FLOAT:
                        return numPixels * 8;
                    default:
                        return numPixels * 16;
                }
            case 'rgba16i':
            case 'rgba16ui':
                return numPixels * 8;
            case 'rgba32f':
            case 'rgba32i':
            case 'rgba32ui':
                return numPixels * 16;
            case 'rgba8unorm':
            case 'rgba8unorm-srgb':
            case 'rgba8snorm':
            case 'rgba8i':
            case 'rgba8ui':
                return numPixels * 4;
            default:
                return 0;
        }
    }
    getTextureFormatInfo(format) {
        return this._textureFormatInfos[format];
    }
}

class WebGLStructuredBuffer extends WebGLGPUBuffer {
    _structure;
    _data;
    constructor(device, structure, usage, source){
        if (!structure?.isStructType()) {
            throw new Error('invalid structure type');
        }
        if (usage & GPUResourceUsageFlags.BF_INDEX) {
            throw new Error('structured buffer must not have Index usage flag');
        }
        if (usage & GPUResourceUsageFlags.BF_READ || usage & GPUResourceUsageFlags.BF_WRITE) {
            throw new Error('structured buffer must not have Read or Write usage flags');
        }
        if (usage & GPUResourceUsageFlags.BF_VERTEX) {
            if (structure.structMembers.length !== 1 || !structure.structMembers[0].type.isArrayType()) {
                throw new Error('structured buffer for vertex usage must have only one array member');
            }
            if (!WebGLStructuredBuffer.isValidArrayElementType(structure.structMembers[0].type.elementType)) {
                throw new Error('invalid vertex data type when creating vertex buffer');
            }
        }
        const layout = structure.toBufferLayout(0, structure.layout);
        if (source && layout.byteSize !== source.byteLength) {
            throw new Error(`create structured buffer failed: invalid source size: ${source.byteLength}, should be ${layout.byteSize}`);
        }
        const useSystemMemory = !device.isWebGL2 && (usage & GPUResourceUsageFlags.BF_UNIFORM) !== 0;
        super(device, usage, source || layout.byteSize, useSystemMemory);
        this._data = new StructuredBufferData(layout, useSystemMemory ? this.systemMemoryBuffer : this);
        this._structure = structure;
    }
    set(name, value) {
        this._data.set(name, value);
    }
    get structure() {
        return this._structure;
    }
    set structure(st) {
        if (st && !st.isCompatibleType(this._structure)) {
            const layout = st.toBufferLayout(0, st.layout);
            if (layout.byteSize > this.byteLength) {
                throw new Error(`set structure type failed: new structure type is too large: ${layout.byteSize}`);
            }
            this._data = new StructuredBufferData(layout, this);
            this._structure = st;
        }
    }
    getUniformData() {
        return this._data;
    }
    static isValidArrayElementType(type) {
        if (type.isPrimitiveType()) {
            return type.scalarType !== PBPrimitiveType.BOOL && !type.isMatrixType();
        } else if (type.isStructType()) {
            for (const member of type.structMembers){
                if (!member.type.isPrimitiveType() || member.type.scalarType === PBPrimitiveType.BOOL || member.type.isMatrixType()) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
}

class WebGLBindGroup extends WebGLGPUObject {
    _layout;
    _resources;
    constructor(device, layout){
        super(device);
        this._device = device;
        this._layout = layout;
        this._resources = new Proxy({}, {
            get: function(target, prop) {
                return target[prop];
            },
            set: function(target, prop, value) {
                target[prop] = value;
                return true;
            }
        });
        this._object = {};
    }
    getLayout() {
        return this._layout;
    }
    getBuffer(name) {
        return this._getBuffer(name, true);
    }
    setBuffer(name, buffer) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.name === bindName) {
                if (!entry.buffer) {
                    console.log(`setBuffer() failed: resource '${name}' is not buffer`);
                } else {
                    if (buffer && !(buffer.usage & GPUResourceUsageFlags.BF_UNIFORM)) {
                        console.log(`setBuffer() failed: buffer resource '${name}' must be type '${entry.buffer.type}'`);
                    } else if (buffer !== this._resources[entry.name]) {
                        this._resources[entry.name] = buffer;
                    }
                }
                return;
            }
        }
        console.log(`setBuffer() failed: no buffer resource named '${name}'`);
    }
    setRawData(name, byteOffset, data, srcPos, srcLength) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setRawData(mappedName, byteOffset, data, srcPos, srcLength);
        } else {
            const buffer = this._getBuffer(name, false);
            if (buffer) {
                buffer.bufferSubData(byteOffset, data, srcPos, srcLength);
            } else {
                console.log(`set(): no uniform buffer named '${name}'`);
            }
        }
    }
    setValue(name, value) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setValue(mappedName, {
                [name]: value
            });
        } else {
            const buffer = this._getBuffer(name, false);
            if (buffer) {
                if (!(buffer instanceof WebGLStructuredBuffer)) {
                    throw new Error(`BindGroup.setValue() failed: '${name}' is not structured buffer`);
                }
                if (value?.BYTES_PER_ELEMENT) {
                    buffer.bufferSubData(0, value);
                } else {
                    for(const k in value){
                        buffer.set(k, value[k]);
                    }
                }
            } else {
                console.log(`set(): no uniform buffer named '${name}'`);
            }
        }
    }
    setTextureView(name, value, level, face, mipCount, sampler) {
        throw new Error('setTextureView() not supported for webgl device');
    }
    getTexture(name) {
        const entry = this._findTextureLayout(name);
        if (entry) {
            return (this._resources[name]?.[0]) || null;
        } else {
            throw new Error(`getTexture() failed:${name} is not a texture`);
        }
    }
    setTexture(name, texture, sampler) {
        const entry = this._findTextureLayout(name);
        if (entry) {
            this._resources[name] = [
                texture,
                sampler || texture.getDefaultSampler(!!entry.texture?.autoBindSamplerComparison)
            ];
        } else {
            console.log(`setTexture() failed: no texture uniform named '${name}'`);
        }
    }
    setSampler(name, value) {
    // no sampler uniform support for webgl
    }
    apply(program, offsets) {
        const webgl2 = this._device.isWebGL2;
        let dynamicOffsetIndex = 0;
        for(let i = 0; i < this._layout.entries.length; i++){
            const entry = this._layout.entries[i];
            const res = this._resources[entry.name];
            if (res instanceof WebGLStructuredBuffer) {
                if (webgl2) {
                    if (entry.buffer.hasDynamicOffset) {
                        const offset = offsets?.[dynamicOffsetIndex] || 0;
                        dynamicOffsetIndex++;
                        program.setBlock(entry.type.structName, res, offset);
                    } else {
                        program.setBlock(entry.type.structName, res, 0);
                    }
                } else {
                    program.setUniform(entry.name, res.getUniformData().uniforms);
                }
            } else if (Array.isArray(res)) {
                if (res[0].isTextureVideo()) {
                    res[0].updateVideoFrame();
                }
                // res[0].sampler = res[1];
                program.setUniform(entry.name, res);
            }
        }
    }
    destroy() {
        this._resources = {};
        this._object = null;
    }
    async restore() {
        this._object = {};
    }
    isBindGroup() {
        return true;
    }
    _getBuffer(name, nocreate = false) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.buffer && entry.name === bindName) {
                let buffer = this._resources[entry.name];
                if (!buffer && !nocreate) {
                    buffer = this._device.createStructuredBuffer(entry.type, {
                        usage: 'uniform'
                    });
                    this._resources[entry.name] = buffer;
                }
                return buffer;
            }
        }
        return null;
    }
    _findTextureLayout(name) {
        for (const entry of this._layout.entries){
            if ((entry.texture || entry.storageTexture || entry.externalTexture) && entry.name === name) {
                return entry;
            }
        }
        return null;
    }
}

class WebGLGPUProgram extends WebGLGPUObject {
    _vs;
    _fs;
    _unitCounter;
    _uniformSetters;
    _uniformInfo;
    _blockInfo;
    _bindGroupLayouts;
    _vertexAttributes;
    _error;
    _vertexShader;
    _fragmentShader;
    constructor(device, vertexShader, fragmentShader, bindGroupLayouts, vertexAttributes){
        super(device);
        this._object = this._device.context.createProgram();
        this._unitCounter = 0;
        this._uniformSetters = null;
        this._uniformInfo = null;
        this._blockInfo = null;
        this._error = '';
        this._vertexShader = null;
        this._fragmentShader = null;
        this._vs = vertexShader;
        this._fs = fragmentShader;
        this._bindGroupLayouts = [
            ...bindGroupLayouts
        ];
        this._vertexAttributes = [
            ...vertexAttributes
        ];
        this.load();
    }
    get type() {
        return 'render';
    }
    getCompileError() {
        return this._error;
    }
    getShaderSource(kind) {
        switch(kind){
            case 'vertex':
                return this._vs;
            case 'fragment':
                return this._fs;
            case 'compute':
                return null;
        }
    }
    getBindingInfo(name) {
        for(let group = 0; group < this._bindGroupLayouts.length; group++){
            const layout = this._bindGroupLayouts[group];
            const bindName = layout.nameMap?.[name] ?? name;
            for(let binding = 0; binding < layout.entries.length; binding++){
                const bindingPoint = layout.entries[binding];
                if (bindingPoint.name === bindName) {
                    return {
                        group: group,
                        binding: binding,
                        type: bindingPoint.type
                    };
                }
            }
        }
        return null;
    }
    get bindGroupLayouts() {
        return this._bindGroupLayouts;
    }
    get vertexAttributes() {
        return this._vertexAttributes;
    }
    setUniform(name, value) {
        const setter = this._uniformSetters[name];
        if (setter) {
            setter(value);
        } else {
            const proto = Object.getPrototypeOf(value);
            if (proto === Object.getPrototypeOf({})) {
                this._setUniformStruct(name, value);
            } else if (proto == Object.getPrototypeOf([])) {
                this._setUniformArray(name, value);
            }
        }
    }
    setBlock(name, value, offset) {
        const info = this._blockInfo[name];
        if (info) {
            if (offset) {
                this._device.context.bindBufferRange(WebGLEnum.UNIFORM_BUFFER, info.index, value.object, offset, value.byteLength - offset);
            } else {
                this._device.context.bindBufferBase(WebGLEnum.UNIFORM_BUFFER, info.index, value.object);
            }
        } else {
            console.error(`Block not found: ${name}`);
        }
    }
    destroy() {
        if (this._object) {
            this._device.context.deleteProgram(this._object);
            this._object = null;
            this._unitCounter = 0;
            this._uniformSetters = null;
            this._uniformInfo = null;
            this._blockInfo = null;
            this._error = '';
            this._vertexShader = null;
            this._fragmentShader = null;
        }
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.load();
        }
    }
    isProgram() {
        return true;
    }
    use() {
        if (this !== this._device.context._currentProgram) {
            if (!this.checkLoad()) {
                return false;
            }
            this._device.context._currentProgram = this;
            this._device.context.useProgram(this._object);
        }
        return true;
    }
    createUniformBuffer(uniform) {
        const type = this.getBindingInfo(uniform)?.type;
        return type ? this.device.createStructuredBuffer(type, {
            usage: 'uniform'
        }) : null;
    }
    _setUniformStruct(name, value) {
        for(const k in value){
            this.setUniform(`${name}.${k}`, value[k]);
        }
    }
    _setUniformArray(name, value) {
        for(let i = 0; i < value.length; i++){
            this.setUniform(`${name}[${i}]`, value[i]);
        }
    }
    load() {
        if (this._device.isContextLost()) {
            return;
        }
        const gl = this._device.context;
        this._error = null;
        this._uniformSetters = {};
        if (!this._object) {
            this._object = this._device.context.createProgram();
        }
        this._vertexShader = gl.createShader(WebGLEnum.VERTEX_SHADER);
        gl.attachShader(this._object, this._vertexShader);
        gl.shaderSource(this._vertexShader, this._vs);
        gl.compileShader(this._vertexShader);
        this._fragmentShader = gl.createShader(WebGLEnum.FRAGMENT_SHADER);
        gl.attachShader(this._object, this._fragmentShader);
        gl.shaderSource(this._fragmentShader, this._fs);
        gl.compileShader(this._fragmentShader);
        for(let loc = 0; loc < semanticList.length; loc++){
            gl.bindAttribLocation(this._object, loc, semanticList[loc]);
        }
        gl.linkProgram(this._object);
    }
    checkLoad() {
        if (!this._object) {
            return false;
        }
        if (this._vertexShader) {
            const gl = this._device.context;
            if (!this._device.isContextLost()) {
                if (!gl.getProgramParameter(this._object, WebGLEnum.LINK_STATUS)) {
                    if (!gl.getShaderParameter(this._vertexShader, WebGLEnum.COMPILE_STATUS)) {
                        this._error = gl.getShaderInfoLog(this._vertexShader);
                        console.error(new Error(`Compile shader failed: ${this._error}`));
                    } else if (!gl.getShaderParameter(this._fragmentShader, WebGLEnum.COMPILE_STATUS)) {
                        this._error = gl.getShaderInfoLog(this._fragmentShader);
                        console.error(new Error(`Compile shader failed: ${this._error}`));
                    } else {
                        this._error = gl.getProgramInfoLog(this._object);
                        console.error(new Error(`Load program failed: \n${this._error}`));
                    }
                }
            }
            gl.deleteShader(this._vertexShader);
            this._vertexShader = null;
            gl.deleteShader(this._fragmentShader);
            this._fragmentShader = null;
            if (this._error) {
                gl.deleteProgram(this._object);
                this._object = null;
                return false;
            }
            this._uniformSetters = this.createUniformSetters();
        }
        return true;
    }
    createUniformSetter(info) {
        const loc = info.location;
        const isArray = info.isArray;
        switch(info.type){
            case WebGLEnum.FLOAT:
                return this.getUniformSetterfv(loc);
            case WebGLEnum.FLOAT_VEC2:
                return this.getUniformSetter2fv(loc);
            case WebGLEnum.FLOAT_VEC3:
                return this.getUniformSetter3fv(loc);
            case WebGLEnum.FLOAT_VEC4:
                return this.getUniformSetter4fv(loc);
            case WebGLEnum.INT:
                return this.getUniformSetteriv(loc);
            case WebGLEnum.INT_VEC2:
                return this.getUniformSetter2iv(loc);
            case WebGLEnum.INT_VEC3:
                return this.getUniformSetter3iv(loc);
            case WebGLEnum.INT_VEC4:
                return this.getUniformSetter4iv(loc);
            case WebGLEnum.UNSIGNED_INT:
                return this.getUniformSetteruiv(loc);
            case WebGLEnum.UNSIGNED_INT_VEC2:
                return this.getUniformSetter2uiv(loc);
            case WebGLEnum.UNSIGNED_INT_VEC3:
                return this.getUniformSetter3uiv(loc);
            case WebGLEnum.UNSIGNED_INT_VEC4:
                return this.getUniformSetter4uiv(loc);
            case WebGLEnum.BOOL:
                return this.getUniformSetteriv(loc);
            case WebGLEnum.BOOL_VEC2:
                return this.getUniformSetter2iv(loc);
            case WebGLEnum.BOOL_VEC3:
                return this.getUniformSetter3iv(loc);
            case WebGLEnum.BOOL_VEC4:
                return this.getUniformSetter4iv(loc);
            case WebGLEnum.FLOAT_MAT2:
                return this.getUniformSetterMatrix2(loc);
            case WebGLEnum.FLOAT_MAT2x3:
                return this.getUniformSetterMatrix23(loc);
            case WebGLEnum.FLOAT_MAT2x4:
                return this.getUniformSetterMatrix24(loc);
            case WebGLEnum.FLOAT_MAT3:
                return this.getUniformSetterMatrix3(loc);
            case WebGLEnum.FLOAT_MAT3x2:
                return this.getUniformSetterMatrix32(loc);
            case WebGLEnum.FLOAT_MAT3x4:
                return this.getUniformSetterMatrix34(loc);
            case WebGLEnum.FLOAT_MAT4:
                return this.getUniformSetterMatrix4(loc);
            case WebGLEnum.FLOAT_MAT4x2:
                return this.getUniformSetterMatrix42(loc);
            case WebGLEnum.FLOAT_MAT4x3:
                return this.getUniformSetterMatrix43(loc);
            case WebGLEnum.SAMPLER_2D:
            case WebGLEnum.SAMPLER_2D_SHADOW:
            case WebGLEnum.INT_SAMPLER_2D:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_2D:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_2D, unit);
                    }
                }
            case WebGLEnum.SAMPLER_2D_ARRAY:
            case WebGLEnum.SAMPLER_2D_ARRAY_SHADOW:
            case WebGLEnum.INT_SAMPLER_2D_ARRAY:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_2D_ARRAY, unit);
                    }
                }
            case WebGLEnum.SAMPLER_CUBE:
            case WebGLEnum.SAMPLER_CUBE_SHADOW:
            case WebGLEnum.INT_SAMPLER_CUBE:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_CUBE:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_CUBE_MAP, unit);
                    }
                }
            case WebGLEnum.SAMPLER_3D:
            case WebGLEnum.INT_SAMPLER_3D:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_3D:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_3D, unit);
                    }
                }
        }
        console.error(`Error: unsupported uniform type: ${info.name}`);
        return null;
    }
    createUniformSetters() {
        const uniformSetters = {};
        const gl = this._device.context;
        const numUniforms = gl.getProgramParameter(this._object, WebGLEnum.ACTIVE_UNIFORMS);
        this._uniformInfo = [];
        for(let index = 0; index < numUniforms; index++){
            const info = gl.getActiveUniform(this._object, index);
            let name = info.name;
            let isArray = false;
            if (name.startsWith('gl_') || name.startsWith('webgl_')) {
                this._uniformInfo.push(null);
            } else {
                if (name.substr(-3) === '[0]') {
                    // is array
                    name = name.substr(0, name.length - 3);
                    isArray = true;
                }
                const size = info.size;
                const type = info.type;
                const blockIndex = -1;
                const offset = 0;
                const location = gl.getUniformLocation(this._object, info.name);
                const view = null;
                const { ctor: viewCtor, elementSize: viewElementSize } = this.getTypedArrayInfo(info.type);
                const uniformInfo = {
                    index,
                    name,
                    size,
                    type,
                    blockIndex,
                    offset,
                    isArray,
                    location,
                    view,
                    viewCtor,
                    viewElementSize
                };
                this._uniformInfo.push(uniformInfo);
                if (location) {
                    uniformSetters[name] = this.createUniformSetter(uniformInfo);
                }
            }
        }
        if (isWebGL2(gl)) {
            this._blockInfo = {};
            const numBlocks = gl.getProgramParameter(this._object, WebGLEnum.ACTIVE_UNIFORM_BLOCKS);
            for(let i = 0; i < numBlocks; i++){
                const name = gl.getActiveUniformBlockName(this._object, i);
                const index = gl.getUniformBlockIndex(this._object, name);
                const usedInVS = !!gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER);
                const usedInFS = !!gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER);
                const used = usedInVS || usedInFS;
                const size = gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_DATA_SIZE);
                const uniformIndices = gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES);
                this._blockInfo[name] = {
                    index,
                    used,
                    size,
                    uniformIndices
                };
                gl.uniformBlockBinding(this._object, index, index);
            }
        /*
      const indices: number[] = this._uniformInfo.map(val => val.index);
      const types = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_TYPE);
      const sizes = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_SIZE);
      const blockIndices = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_BLOCK_INDEX);
      const offsets = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_OFFSET);
      this._uniformInfo.forEach((val, index) => {
        val.type = types[index];
        val.size = sizes[index];
        val.blockIndex = blockIndices[index];
        val.offset = offsets[index];
      });
      */ }
        return uniformSetters;
    }
    getUniformSetterf(location) {
        return (value)=>{
            this._device.context.uniform1f(location, value);
        };
    }
    getUniformSetterfv(location) {
        return (value)=>{
            this._device.context.uniform1fv(location, value);
        };
    }
    getUniformSetter2fv(location) {
        return (value)=>{
            this._device.context.uniform2fv(location, value);
        };
    }
    getUniformSetter3fv(location) {
        return (value)=>{
            this._device.context.uniform3fv(location, value);
        };
    }
    getUniformSetter4fv(location) {
        return (value)=>{
            this._device.context.uniform4fv(location, value);
        };
    }
    getUniformSetteri(location) {
        return (value)=>{
            this._device.context.uniform1i(location, value);
        };
    }
    getUniformSetteriv(location) {
        return (value)=>{
            this._device.context.uniform1iv(location, value);
        };
    }
    getUniformSetter2iv(location) {
        return (value)=>{
            this._device.context.uniform2iv(location, value);
        };
    }
    getUniformSetter3iv(location) {
        return (value)=>{
            this._device.context.uniform3iv(location, value);
        };
    }
    getUniformSetter4iv(location) {
        return (value)=>{
            this._device.context.uniform4iv(location, value);
        };
    }
    getUniformSetterui(location) {
        return (value)=>{
            this._device.context.uniform1ui(location, value);
        };
    }
    getUniformSetteruiv(location) {
        return (value)=>{
            this._device.context.uniform1uiv(location, value);
        };
    }
    getUniformSetter2uiv(location) {
        return (value)=>{
            this._device.context.uniform2uiv(location, value);
        };
    }
    getUniformSetter3uiv(location) {
        return (value)=>{
            this._device.context.uniform3uiv(location, value);
        };
    }
    getUniformSetter4uiv(location) {
        return (value)=>{
            this._device.context.uniform4uiv(location, value);
        };
    }
    getUniformSetterMatrix2(location) {
        return (value)=>{
            this._device.context.uniformMatrix2fv(location, false, value);
        };
    }
    getUniformSetterMatrix23(location) {
        return (value)=>{
            this._device.context.uniformMatrix2x3fv(location, false, value);
        };
    }
    getUniformSetterMatrix24(location) {
        return (value)=>{
            this._device.context.uniformMatrix2x4fv(location, false, value);
        };
    }
    getUniformSetterMatrix32(location) {
        return (value)=>{
            this._device.context.uniformMatrix3x2fv(location, false, value);
        };
    }
    getUniformSetterMatrix3(location) {
        return (value)=>{
            this._device.context.uniformMatrix3fv(location, false, value);
        };
    }
    getUniformSetterMatrix34(location) {
        return (value)=>{
            this._device.context.uniformMatrix3x4fv(location, false, value);
        };
    }
    getUniformSetterMatrix42(location) {
        return (value)=>{
            this._device.context.uniformMatrix4x2fv(location, false, value);
        };
    }
    getUniformSetterMatrix43(location) {
        return (value)=>{
            this._device.context.uniformMatrix4x3fv(location, false, value);
        };
    }
    getUniformSetterMatrix4(location) {
        return (value)=>{
            this._device.context.uniformMatrix4fv(location, false, value);
        };
    }
    getSamplerSetter(location, target, unit) {
        const gl = this._device.context;
        return isWebGL2(gl) ? (texture)=>{
            const tex = texture?.[0].object ?? null;
            const sampler = texture?.[1].object ?? null;
            gl.uniform1i(location, unit);
            gl.activeTexture(this._device.context.TEXTURE0 + unit);
            gl.bindTexture(target, tex);
            gl.bindSampler(unit, sampler);
        } : (texture)=>{
            const tex = texture?.[0] ?? null;
            const sampler = texture?.[1] ?? null;
            gl.uniform1i(location, unit);
            gl.activeTexture(this._device.context.TEXTURE0 + unit);
            gl.bindTexture(target, texture?.[0]?.object || null);
            if (tex && sampler && this._device.getCurrentSamplerForTexture(tex) !== sampler) {
                tex.isWebGL1Fallback;
                this._device.setCurrentSamplerForTexture(tex, sampler);
                gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_S, textureWrappingMap[sampler.addressModeU]);
                gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_T, textureWrappingMap[sampler.addressModeV]);
                gl.texParameteri(target, WebGLEnum.TEXTURE_MAG_FILTER, textureMagFilterToWebGL(sampler.magFilter));
                gl.texParameteri(target, WebGLEnum.TEXTURE_MIN_FILTER, textureMinFilterToWebGL(sampler.minFilter, tex.isWebGL1Fallback ? 'none' : sampler.mipFilter));
                if (this._device.getDeviceCaps().textureCaps.supportAnisotropicFiltering) {
                    gl.texParameterf(target, WebGLEnum.TEXTURE_MAX_ANISOTROPY, sampler.maxAnisotropy);
                }
            }
        };
    }
    getTypedArrayInfo(type) {
        let ctor = null;
        let elementSize = 0;
        switch(type){
            case WebGLEnum.INT:
                ctor = Int32Array;
                elementSize = 4;
                break;
            case WebGLEnum.INT_VEC2:
                ctor = Int32Array;
                elementSize = 8;
                break;
            case WebGLEnum.INT_VEC3:
                ctor = Int32Array;
                elementSize = 12;
                break;
            case WebGLEnum.INT_VEC4:
                ctor = Int32Array;
                elementSize = 16;
                break;
            case WebGLEnum.UNSIGNED_INT:
            case WebGLEnum.BOOL:
                ctor = Uint32Array;
                elementSize = 4;
                break;
            case WebGLEnum.UNSIGNED_INT_VEC2:
            case WebGLEnum.BOOL_VEC2:
                ctor = Uint32Array;
                elementSize = 8;
                break;
            case WebGLEnum.UNSIGNED_INT_VEC3:
            case WebGLEnum.BOOL_VEC3:
                ctor = Uint32Array;
                elementSize = 12;
                break;
            case WebGLEnum.UNSIGNED_INT_VEC4:
            case WebGLEnum.BOOL_VEC4:
                ctor = Uint32Array;
                elementSize = 16;
                break;
            case WebGLEnum.FLOAT:
                ctor = Float32Array;
                elementSize = 4;
                break;
            case WebGLEnum.FLOAT_VEC2:
                ctor = Float32Array;
                elementSize = 8;
                break;
            case WebGLEnum.FLOAT_VEC3:
                ctor = Float32Array;
                elementSize = 12;
                break;
            case WebGLEnum.FLOAT_VEC4:
            case WebGLEnum.FLOAT_MAT2:
                ctor = Float32Array;
                elementSize = 16;
                break;
            case WebGLEnum.FLOAT_MAT2x3:
            case WebGLEnum.FLOAT_MAT3x2:
                ctor = Float32Array;
                elementSize = 24;
                break;
            case WebGLEnum.FLOAT_MAT2x4:
            case WebGLEnum.FLOAT_MAT4x2:
                ctor = Float32Array;
                elementSize = 32;
                break;
            case WebGLEnum.FLOAT_MAT3:
                ctor = Float32Array;
                elementSize = 36;
                break;
            case WebGLEnum.FLOAT_MAT3x4:
            case WebGLEnum.FLOAT_MAT4x3:
                ctor = Float32Array;
                elementSize = 48;
                break;
            case WebGLEnum.FLOAT_MAT4:
                ctor = Float32Array;
                elementSize = 64;
                break;
        }
        return {
            ctor,
            elementSize
        };
    }
}

class WebGLTextureSampler extends WebGLGPUObject {
    _options;
    constructor(device, options){
        super(device);
        this._options = Object.assign({
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter: 'nearest',
            minFilter: 'nearest',
            mipFilter: 'none',
            lodMin: 0,
            lodMax: 32,
            compare: null,
            maxAnisotropy: 1
        }, options || {});
        this._load();
    }
    get addressModeU() {
        return this._options.addressU;
    }
    get addressModeV() {
        return this._options.addressV;
    }
    get addressModeW() {
        return this._options.addressW;
    }
    get magFilter() {
        return this._options.magFilter;
    }
    get minFilter() {
        return this._options.minFilter;
    }
    get mipFilter() {
        return this._options.mipFilter;
    }
    get lodMin() {
        return this._options.lodMin;
    }
    get lodMax() {
        return this._options.lodMax;
    }
    get compare() {
        return this._options.compare;
    }
    get maxAnisotropy() {
        return this._options.maxAnisotropy;
    }
    destroy() {
        if (this._object && isWebGL2(this._device.context)) {
            this._device.context.deleteSampler(this._object);
        }
        this._object = null;
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this._load();
        }
    }
    apply(texture) {
        if (texture?.object && !this._device.isWebGL2 && !this._device.isContextLost()) {
            const gl = this._device.context;
            const target = textureTargetMap[texture.target];
            gl.bindTexture(target, texture.object);
            gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_S, textureWrappingMap[this._options.addressU]);
            gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_T, textureWrappingMap[this._options.addressV]);
            gl.texParameteri(target, WebGLEnum.TEXTURE_MAG_FILTER, textureMagFilterToWebGL(this._options.magFilter));
            gl.texParameteri(target, WebGLEnum.TEXTURE_MIN_FILTER, textureMinFilterToWebGL(this._options.minFilter, this._options.mipFilter));
            if (this._device.getDeviceCaps().textureCaps.supportAnisotropicFiltering) {
                gl.texParameterf(target, WebGLEnum.TEXTURE_MAX_ANISOTROPY, this._options.maxAnisotropy);
            }
        }
    }
    _load() {
        if (!isWebGL2(this._device.context)) {
            this._object = {};
            return true;
        }
        if (!this._device.isContextLost()) {
            const gl = this._device.context;
            if (!this._object) {
                this._object = gl.createSampler();
            }
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_WRAP_S, textureWrappingMap[this._options.addressU]);
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_WRAP_T, textureWrappingMap[this._options.addressV]);
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_WRAP_R, textureWrappingMap[this._options.addressW]);
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_MAG_FILTER, textureMagFilterToWebGL(this._options.magFilter));
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_MIN_FILTER, textureMinFilterToWebGL(this._options.minFilter, this._options.mipFilter));
            gl.samplerParameterf(this._object, WebGLEnum.TEXTURE_MIN_LOD, this._options.lodMin);
            gl.samplerParameterf(this._object, WebGLEnum.TEXTURE_MAX_LOD, this._options.lodMax);
            if (this._options.compare === null) {
                gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_COMPARE_MODE, WebGLEnum.NONE);
            } else {
                gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_COMPARE_MODE, WebGLEnum.COMPARE_REF_TO_TEXTURE);
                gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_COMPARE_FUNC, compareFuncMap[this._options.compare]);
            }
            if (this._device.getDeviceCaps().textureCaps.supportAnisotropicFiltering) {
                gl.samplerParameterf(this._object, WebGLEnum.TEXTURE_MAX_ANISOTROPY, this._options.maxAnisotropy);
            }
        }
        return true;
    }
    isSampler() {
        return true;
    }
}

class SamplerCache {
    _device;
    _samplers;
    constructor(device){
        this._device = device;
        this._samplers = {};
    }
    fetchSampler(options) {
        const hash = this.hash(options);
        let sampler = this._samplers[hash];
        if (!sampler) {
            sampler = this.createSampler(options);
            this._samplers[hash] = sampler;
        }
        return sampler;
    }
    hash(options) {
        const addressU = options.addressU ? String(options.addressU) : '';
        const addressV = options.addressV ? String(options.addressV) : '';
        const addressW = options.addressW ? String(options.addressW) : '';
        const magFilter = options.magFilter ? String(options.magFilter) : '';
        const minFilter = options.minFilter ? String(options.minFilter) : '';
        const mipFilter = options.mipFilter ? String(options.mipFilter) : '';
        const lodMin = options.lodMin ? String(options.lodMin) : '';
        const lodMax = options.lodMax ? String(options.lodMax) : '';
        const compare = options.compare ? String(options.compare) : '';
        const maxAnisotropy = options.maxAnisotropy ? String(options.maxAnisotropy) : '';
        return `${addressU}:${addressV}:${addressW}:${magFilter}:${minFilter}:${mipFilter}:${lodMin}:${lodMax}:${compare}:${maxAnisotropy}`;
    }
    createSampler(options) {
        return new WebGLTextureSampler(this._device, options);
    }
}

const typeU16 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const tempInt32Array = new Int32Array(4);
const tempUint32Array = new Uint32Array(4);
class WebGLDevice extends BaseDevice {
    _context;
    _msaaSampleCount;
    _loseContextExtension;
    _contextLost;
    _isRendering;
    _dpr;
    _reverseWindingOrder;
    _deviceCaps;
    _vaoExt;
    _instancedArraysExt;
    _drawBuffersExt;
    _currentProgram;
    _currentVertexData;
    _currentStateSet;
    _currentBindGroups;
    _currentBindGroupOffsets;
    _currentViewport;
    _currentScissorRect;
    _samplerCache;
    _textureSamplerMap;
    constructor(backend, cvs, options){
        super(cvs, backend);
        this._dpr = Math.max(1, Math.floor(options?.dpr ?? window.devicePixelRatio));
        this._isRendering = false;
        this._msaaSampleCount = options?.msaa ? 4 : 1;
        let context = null;
        context = this.canvas.getContext(backend === backend1 ? 'webgl' : 'webgl2', {
            antialias: !!options?.msaa,
            depth: true,
            stencil: true,
            premultipliedAlpha: false
        });
        if (!context) {
            throw new Error('Invalid argument or no webgl support');
        }
        this._contextLost = false;
        this._reverseWindingOrder = false;
        this._deviceCaps = null;
        this._context = context;
        this._currentProgram = null;
        this._currentVertexData = null;
        this._currentStateSet = null;
        this._currentBindGroups = [];
        this._currentBindGroupOffsets = [];
        this._currentViewport = null;
        this._currentScissorRect = null;
        this._samplerCache = new SamplerCache(this);
        this._textureSamplerMap = new WeakMap();
        this._loseContextExtension = this._context.getExtension('WEBGL_lose_context');
        this.canvas.addEventListener('webglcontextlost', (evt)=>{
            this._contextLost = true;
            evt.preventDefault();
            this.handleContextLost();
        }, false);
        this.canvas.addEventListener('webglcontextrestored', (evt)=>{
            this._contextLost = false;
            this.handleContextRestored();
        }, false);
    }
    get context() {
        return this._context;
    }
    getFrameBufferSampleCount() {
        return this.getFramebuffer()?.getSampleCount() ?? this._msaaSampleCount;
    }
    get isWebGL2() {
        return this._context && isWebGL2(this._context);
    }
    get drawingBufferWidth() {
        return this.getDrawingBufferWidth();
    }
    get drawingBufferHeight() {
        return this.getDrawingBufferHeight();
    }
    get clientWidth() {
        return this.canvas.clientWidth;
    }
    get clientHeight() {
        return this.canvas.clientHeight;
    }
    getScale() {
        return this._dpr;
    }
    isContextLost() {
        return this._context.isContextLost();
    }
    getDeviceCaps() {
        return this._deviceCaps;
    }
    get vaoExt() {
        return this._vaoExt;
    }
    get instancedArraysExt() {
        return this._instancedArraysExt;
    }
    get drawBuffersExt() {
        return this._drawBuffersExt;
    }
    getDrawingBufferWidth() {
        return this._context._currentFramebuffer?.getWidth() || this._context.drawingBufferWidth;
    }
    getDrawingBufferHeight() {
        return this._context._currentFramebuffer?.getHeight() || this._context.drawingBufferHeight;
    }
    getBackBufferWidth() {
        return this.canvas.width;
    }
    getBackBufferHeight() {
        return this.canvas.height;
    }
    async initContext() {
        this.initContextState();
        this.on('resize', (evt)=>{
            const width = Math.max(1, Math.round(this.canvas.clientWidth * this._dpr));
            const height = Math.max(1, Math.round(this.canvas.clientHeight * this._dpr));
            if (width !== this.canvas.width || height !== this.canvas.height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this.setViewport(this._currentViewport);
                this.setScissor(this._currentScissorRect);
            }
        });
        this.dispatchEvent(new DeviceResizeEvent(this.canvas.clientWidth, this.canvas.clientHeight));
    }
    clearFrameBuffer(clearColor, clearDepth, clearStencil) {
        const gl = this._context;
        const colorFlag = clearColor ? gl.COLOR_BUFFER_BIT : 0;
        const depthFlag = typeof clearDepth === 'number' ? gl.DEPTH_BUFFER_BIT : 0;
        const stencilFlag = typeof clearStencil === 'number' ? gl.STENCIL_BUFFER_BIT : 0;
        if (colorFlag || depthFlag || stencilFlag) {
            WebGLDepthState.applyDefaults(this._context);
            if (isWebGL2(gl) && gl._currentFramebuffer) {
                if (depthFlag || stencilFlag) {
                    const depthAttachment = gl._currentFramebuffer.getDepthAttachment();
                    if (depthAttachment) {
                        gl.clearBufferfi(WebGLEnum.DEPTH_STENCIL, 0, clearDepth || 1, clearStencil || 0);
                    }
                }
                if (colorFlag) {
                    const attachments = gl._currentFramebuffer.getColorAttachments();
                    for(let i = 0; i < attachments.length; i++){
                        if (isIntegerTextureFormat(attachments[i].format)) {
                            if (isSignedTextureFormat(attachments[i].format)) {
                                tempInt32Array[0] = clearColor[0];
                                tempInt32Array[1] = clearColor[1];
                                tempInt32Array[2] = clearColor[2];
                                tempInt32Array[3] = clearColor[3];
                                gl.clearBufferiv(WebGLEnum.COLOR, i, tempInt32Array);
                            } else {
                                tempUint32Array[0] = clearColor[0];
                                tempUint32Array[1] = clearColor[1];
                                tempUint32Array[2] = clearColor[2];
                                tempUint32Array[3] = clearColor[3];
                                gl.clearBufferuiv(WebGLEnum.COLOR, i, tempUint32Array);
                            }
                        } else {
                            gl.clearBufferfv(WebGLEnum.COLOR, i, clearColor);
                        }
                    }
                }
            } else {
                gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                gl.clearDepth(clearDepth);
                gl.clearStencil(clearStencil);
                gl.clear(colorFlag | depthFlag | stencilFlag);
            }
            gl._currentFramebuffer?.tagDraw();
        }
    }
    // factory
    createGPUTimer() {
        return new GPUTimer(this);
    }
    createRenderStateSet() {
        return new WebGLRenderStateSet(this._context);
    }
    createSampler(options) {
        return this._samplerCache.fetchSampler(options);
    }
    createTextureFromMipmapData(data, sRGB, options) {
        if (!data) {
            console.error(`Device.createTextureFromMipmapData() failed: invalid data`);
            return null;
        }
        if (data.isCubemap) {
            const tex = new WebGLTextureCube(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        } else if (data.isVolume) {
            const tex = new WebGLTexture3D(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else if (data.isArray) {
            const tex = new WebGLTexture2DArray(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else {
            const tex = new WebGLTexture2D(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        }
    }
    createTexture2D(format, width, height, options) {
        const tex = (options?.texture) ?? new WebGLTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2D() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createEmpty(format, width, height, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGLTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromMipmapData() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromImage(element, sRGB, options) {
        const tex = (options?.texture) ?? new WebGLTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromImage() failed: options.texture must be 2d texture');
            return null;
        }
        tex.loadFromElement(element, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArray(format, width, height, depth, options) {
        const tex = (options?.texture) ?? new WebGLTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArray() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromImages(elements, sRGB, options) {
        if (!elements || elements.length === 0) {
            console.error('createTexture2DArrayFromImages() failed: Invalid image elements');
            return null;
        }
        let width = 0;
        let height = 0;
        for (const element of elements){
            if (width === 0 || height === 0) {
                width = element.width;
                height = element.height;
            } else if (width !== element.width || height !== element.height) {
                console.error('createTexture2DArrayFromImages() failed: Image elements must have the same size');
                return null;
            }
        }
        if (options?.texture && !options.texture.isTexture2DArray()) {
            console.error('createTexture2DArrayFromImages() failed: options.texture must be 2d array texture');
            return null;
        }
        let tex = options?.texture;
        if (tex) {
            if (tex.depth !== elements.length) {
                console.error('createTexture2DArrayFromImages() failed: Layer count of options.texture not match the given image elements');
                return null;
            }
            if (tex.width !== width || tex.height !== height) {
                console.error('createTexture2DArrayFromImages() failed: Size of options.texture not match the given image elements');
                return null;
            }
        } else {
            tex = this.createTexture2DArray(sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm', width, height, elements.length, options);
            for(let i = 0; i < elements.length; i++){
                tex.updateFromElement(elements[i], 0, 0, i, 0, 0, width, height);
            }
        }
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture3D(format, width, height, depth, options) {
        if (!this.isWebGL2) {
            console.error('device does not support 3d texture');
            return null;
        }
        const tex = (options?.texture) ?? new WebGLTexture3D(this);
        if (!tex.isTexture3D()) {
            console.error('createTexture3D() failed: options.texture must be 3d texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTexture(format, size, options) {
        const tex = (options?.texture) ?? new WebGLTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTexture() failed: options.texture must be cube texture');
            return null;
        }
        tex.createEmpty(format, size, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTextureFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGLTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTextureFromMipmapData() failed: options.texture must be cube texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromMipmapData(data, options) {
        const tex = (options?.texture) ?? new WebGLTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArrayFromMipmapData() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createWithMipmapData(data, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTextureVideo(el, samplerOptions) {
        const tex = new WebGLTextureVideo(this, el);
        tex.samplerOptions = samplerOptions ?? null;
        return tex;
    }
    createGPUProgram(params) {
        if (params.type === 'compute') {
            throw new Error('device does not support compute shader');
        }
        const renderProgramParams = params.params;
        return new WebGLGPUProgram(this, renderProgramParams.vs, renderProgramParams.fs, renderProgramParams.bindGroupLayouts, renderProgramParams.vertexAttributes);
    }
    createBindGroup(layout) {
        return new WebGLBindGroup(this, layout);
    }
    createBuffer(sizeInBytes, options) {
        return new WebGLGPUBuffer(this, this.parseBufferOptions(options), sizeInBytes);
    }
    createIndexBuffer(data, options) {
        return new WebGLIndexBuffer(this, data, this.parseBufferOptions(options, 'index'));
    }
    createStructuredBuffer(structureType, options, data) {
        return new WebGLStructuredBuffer(this, structureType, this.parseBufferOptions(options), data);
    }
    createVertexLayout(options) {
        return new WebGLVertexLayout(this, options);
    }
    createFrameBuffer(colorAttachments, depthAttachement, options) {
        this.pushDeviceStates();
        const fb = new WebGLFrameBuffer(this, colorAttachments, depthAttachement, options);
        this.popDeviceStates();
        return fb;
    }
    setBindGroup(index, bindGroup, bindGroupOffsets) {
        if (bindGroupOffsets && !isWebGL2(this._context)) {
            throw new Error(`setBindGroup(): no dynamic offset buffer support for WebGL1 device`);
        }
        this._currentBindGroups[index] = bindGroup;
        this._currentBindGroupOffsets[index] = bindGroupOffsets || null;
    }
    getBindGroup(index) {
        return [
            this._currentBindGroups[index],
            this._currentBindGroupOffsets[index]
        ];
    }
    // render related
    setViewport(vp) {
        if (vp === null || vp === undefined || !Array.isArray(vp) && vp.default) {
            this._currentViewport = {
                x: 0,
                y: 0,
                width: this.deviceToScreen(this.drawingBufferWidth),
                height: this.deviceToScreen(this.drawingBufferHeight),
                default: true
            };
        } else {
            if (Array.isArray(vp)) {
                this._currentViewport = {
                    x: vp[0],
                    y: vp[1],
                    width: vp[2],
                    height: vp[3],
                    default: false
                };
            } else {
                this._currentViewport = Object.assign({
                    default: false
                }, vp);
            }
        }
        this._context.viewport(this.screenToDevice(this._currentViewport.x), this.screenToDevice(this._currentViewport.y), this.screenToDevice(this._currentViewport.width), this.screenToDevice(this._currentViewport.height));
    }
    getViewport() {
        return Object.assign({}, this._currentViewport);
    }
    setScissor(scissor) {
        if (scissor === null || scissor === undefined || !Array.isArray(scissor) && scissor.default) {
            this._currentScissorRect = {
                x: 0,
                y: 0,
                width: this.deviceToScreen(this.drawingBufferWidth),
                height: this.deviceToScreen(this.drawingBufferHeight),
                default: true
            };
        } else {
            if (Array.isArray(scissor)) {
                this._currentScissorRect = {
                    x: scissor[0],
                    y: scissor[1],
                    width: scissor[2],
                    height: scissor[3],
                    default: false
                };
            } else {
                this._currentScissorRect = Object.assign({
                    default: false
                }, scissor);
            }
        }
        this._context.scissor(this.screenToDevice(this._currentScissorRect.x), this.screenToDevice(this._currentScissorRect.y), this.screenToDevice(this._currentScissorRect.width), this.screenToDevice(this._currentScissorRect.height));
    }
    getScissor() {
        return Object.assign({}, this._currentScissorRect);
    }
    setProgram(program) {
        this._currentProgram = program;
    }
    getProgram() {
        return this._currentProgram;
    }
    setVertexLayout(vertexData) {
        this._currentVertexData = vertexData;
    }
    getVertexLayout() {
        return this._currentVertexData;
    }
    setRenderStates(stateSet) {
        this._currentStateSet = stateSet;
    }
    getRenderStates() {
        return this._currentStateSet;
    }
    setFramebuffer(rt) {
        if (rt !== this._context._currentFramebuffer) {
            this._context._currentFramebuffer?.unbind();
            rt?.bind();
        }
    }
    getFramebuffer() {
        return this._context._currentFramebuffer ?? null;
    }
    reverseVertexWindingOrder(reverse) {
        if (this._reverseWindingOrder !== !!reverse) {
            this._reverseWindingOrder = !!reverse;
            this._context.frontFace(reverse ? this._context.CW : this._context.CCW);
        }
    }
    isWindingOrderReversed() {
        return !!this._reverseWindingOrder;
    }
    flush() {
        this.context.flush();
    }
    async readPixels(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? fb.getColorAttachments()[index] : null;
        const format = colorAttachment ? colorAttachment.format : 'rgba8unorm';
        let glFormat = WebGLEnum.NONE;
        let glType = WebGLEnum.NONE;
        const pixelSize = getTextureFormatBlockSize(format);
        glFormat = this.context.getParameter(WebGLEnum.IMPLEMENTATION_COLOR_READ_FORMAT);
        glType = this.context.getParameter(WebGLEnum.IMPLEMENTATION_COLOR_READ_TYPE);
        if ((glFormat !== WebGLEnum.RGBA || glType !== WebGLEnum.UNSIGNED_BYTE && glType !== WebGLEnum.FLOAT) && !isWebGL2(this.context)) {
            throw new Error(`readPixels() failed: invalid format: ${format}`);
        }
        const byteSize = w * h * pixelSize;
        if (buffer.byteLength < byteSize) {
            throw new Error(`readPixels() failed: destination buffer must have at least ${byteSize} bytes`);
        }
        if (isWebGL2(this.context)) {
            const stagingBuffer = this.createBuffer(byteSize, {
                usage: 'read',
                managed: false
            });
            this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, stagingBuffer.object);
            this.context.readBuffer(fb ? WebGLEnum.COLOR_ATTACHMENT0 + index : WebGLEnum.COLOR_ATTACHMENT0);
            this.flush();
            this.context.readPixels(x, y, w, h, glFormat, glType, 0);
            this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, null);
            const data = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            await stagingBuffer.getBufferSubData(data);
            stagingBuffer.dispose();
        } else {
            this.context.readPixels(x, y, w, h, glFormat, glType, buffer);
        }
    }
    readPixelsToBuffer(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? fb.getColorAttachments()[index] : null;
        const format = colorAttachment ? colorAttachment.format : 'rgba8unorm';
        let glFormat = WebGLEnum.NONE;
        let glType = WebGLEnum.NONE;
        if (!isWebGL2(this.context)) {
            throw new Error('readPixels() failed: readPixels() requires webgl2 device');
        }
        if (isCompressedTextureFormat(format) || hasDepthChannel(format)) {
            throw new Error(`readPixels() failed: invalid format: ${format}`);
        }
        const r = hasRedChannel(format);
        const g = hasGreenChannel(format);
        const b = hasBlueChannel(format);
        const a = hasAlphaChannel(format);
        const numChannels = (r ? 1 : 0) + (g ? 1 : 0) + (b ? 1 : 0) + (a ? 1 : 0);
        const size = getTextureFormatBlockSize(format) / numChannels;
        const integer = isIntegerTextureFormat(format);
        const float = isFloatTextureFormat(format);
        const signed = isSignedTextureFormat(format);
        if (r && g && b && a) {
            glFormat = integer ? WebGLEnum.RGBA_INTEGER : WebGLEnum.RGBA;
        } else if (r && g) {
            glFormat = integer ? WebGLEnum.RG_INTEGER : WebGLEnum.RG;
        } else if (r) {
            glFormat = integer ? WebGLEnum.RED_INTEGER : WebGLEnum.RED;
        }
        if (size === 1) {
            glType = signed ? WebGLEnum.BYTE : WebGLEnum.UNSIGNED_BYTE;
        } else if (size === 2) {
            glType = float ? WebGLEnum.HALF_FLOAT : signed ? WebGLEnum.SHORT : WebGLEnum.UNSIGNED_SHORT;
        } else if (size === 4) {
            glType = float ? WebGLEnum.FLOAT : signed ? WebGLEnum.INT : WebGLEnum.UNSIGNED_INT;
        }
        this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, buffer.object);
        this.context.readBuffer(fb ? WebGLEnum.COLOR_ATTACHMENT0 + index : WebGLEnum.COLOR_ATTACHMENT0);
        this.flush();
        this.context.readPixels(x, y, w, h, glFormat, glType, 0);
        this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, null);
    }
    looseContext() {
        if (!this.context.isContextLost()) {
            this._loseContextExtension?.loseContext();
        }
    }
    restoreContext() {
        if (this.context.isContextLost()) {
            this.clearErrors();
            this._loseContextExtension?.restoreContext();
            const err = this.getError();
            if (err) {
                console.log(err);
            }
        }
    }
    /** @internal */ onBeginFrame() {
        if (this._contextLost) {
            if (!this._context.isContextLost()) {
                this._contextLost = false;
                this.handleContextRestored();
            }
        }
        return !this._contextLost;
    }
    /** @internal */ onEndFrame() {}
    /** @internal */ _draw(primitiveType, first, count) {
        if (this._currentVertexData) {
            this._currentVertexData.bind();
            if (this._currentProgram) {
                if (!this._currentProgram.use()) {
                    return;
                }
                for(let i = 0; i < this._currentProgram.bindGroupLayouts.length; i++){
                    const bindGroup = this._currentBindGroups[i];
                    if (bindGroup) {
                        const offsets = this._currentBindGroupOffsets[i];
                        bindGroup.apply(this._currentProgram, offsets);
                    } else {
                        console.error(`Missing bind group (${i}) when drawing with program '${this._currentProgram.name}'`);
                        return;
                    }
                }
            }
            if (this._currentStateSet) {
                this._currentStateSet.apply();
            } else {
                WebGLRenderStateSet.applyDefaults(this._context);
            }
            const indexBuffer = this._currentVertexData.indexBuffer;
            if (indexBuffer) {
                this.context.drawElements(primitiveTypeMap[primitiveType], count, typeMap[indexBuffer.indexType.primitiveType], first * (indexBuffer.indexType === typeU16 ? 2 : 4));
            } else {
                this.context.drawArrays(primitiveTypeMap[primitiveType], first, count);
            }
            this._context._currentFramebuffer?.tagDraw();
        }
    }
    /** @internal */ _drawInstanced(primitiveType, first, count, numInstances) {
        if (this.instancedArraysExt && this._currentVertexData) {
            this._currentVertexData.bind();
            if (this._currentProgram) {
                if (!this._currentProgram.use()) {
                    return;
                }
                for(let i = 0; i < this._currentBindGroups.length; i++){
                    const bindGroup = this._currentBindGroups[i];
                    if (bindGroup) {
                        const offsets = this._currentBindGroupOffsets[i];
                        bindGroup.apply(this._currentProgram, offsets);
                    }
                }
            }
            this._currentStateSet?.apply();
            const indexBuffer = this._currentVertexData.indexBuffer;
            if (indexBuffer) {
                this.instancedArraysExt.drawElementsInstanced(primitiveTypeMap[primitiveType], count, typeMap[indexBuffer.indexType.primitiveType], first * (indexBuffer.indexType === typeU16 ? 2 : 4), numInstances);
            } else {
                this.instancedArraysExt.drawArraysInstanced(primitiveTypeMap[primitiveType], first, count, numInstances);
            }
            this._context._currentFramebuffer?.tagDraw();
        }
    }
    /** @internal */ _compute() {
        throw new Error('WebGL device does not support compute shader');
    }
    /** @internal */ createInstancedArraysEXT() {
        const gl = this._context;
        if (isWebGL2(gl)) {
            return {
                vertexAttribDivisor: gl.vertexAttribDivisor.bind(gl),
                drawArraysInstanced: gl.drawArraysInstanced.bind(gl),
                drawElementsInstanced: gl.drawElementsInstanced.bind(gl)
            };
        } else {
            const extInstancedArray = gl.getExtension('ANGLE_instanced_arrays');
            return extInstancedArray ? {
                vertexAttribDivisor: extInstancedArray.vertexAttribDivisorANGLE.bind(extInstancedArray),
                drawArraysInstanced: extInstancedArray.drawArraysInstancedANGLE.bind(extInstancedArray),
                drawElementsInstanced: extInstancedArray.drawElementsInstancedANGLE.bind(extInstancedArray)
            } : null;
        }
    }
    /** @internal */ createDrawBuffersEXT() {
        const gl = this._context;
        if (isWebGL2(gl)) {
            return {
                drawBuffers: gl.drawBuffers.bind(gl)
            };
        } else {
            const extDrawBuffers = gl.getExtension('WEBGL_draw_buffers');
            return extDrawBuffers ? {
                drawBuffers: extDrawBuffers.drawBuffersWEBGL.bind(extDrawBuffers)
            } : null;
        }
    }
    /** @internal */ createVertexArrayObjectEXT() {
        const gl = this._context;
        if (isWebGL2(gl)) {
            return {
                createVertexArray: gl.createVertexArray.bind(gl),
                bindVertexArray: gl.bindVertexArray.bind(gl),
                deleteVertexArray: gl.deleteVertexArray.bind(gl),
                isVertexArray: gl.isVertexArray.bind(gl)
            };
        } else {
            const extVAO = gl.getExtension('OES_vertex_array_object');
            return extVAO ? {
                createVertexArray: extVAO.createVertexArrayOES.bind(extVAO),
                bindVertexArray: extVAO.bindVertexArrayOES.bind(extVAO),
                deleteVertexArray: extVAO.deleteVertexArrayOES.bind(extVAO),
                isVertexArray: extVAO.isVertexArrayOES.bind(extVAO)
            } : null;
        }
    }
    /** @internal */ handleContextLost() {
        this._isRendering = this.isRendering;
        this.exitLoop();
        console.log('handle context lost');
        this.invalidateAll();
        this.dispatchEvent(new DeviceLostEvent());
    }
    /** @internal */ handleContextRestored() {
        console.log('handle context restored');
        this.initContextState();
        this._textureSamplerMap = new WeakMap();
        this._currentProgram = null;
        this._currentVertexData = null;
        this._currentStateSet = null;
        this._currentBindGroups = [];
        this._currentBindGroupOffsets = [];
        this._currentViewport = null;
        this._currentScissorRect = null;
        this._samplerCache = new SamplerCache(this);
        if (this._isRendering) {
            this._isRendering = false;
            this.reloadAll().then(()=>{
                this.dispatchEvent(new DeviceRestoreEvent());
                this.runLoop(this.runLoopFunction);
            });
        }
    }
    /** @internal */ initContextState() {
        this._deviceCaps = {
            miscCaps: new WebGLMiscCaps(this._context),
            framebufferCaps: new WebGLFramebufferCaps(this._context),
            shaderCaps: new WebGLShaderCaps(this._context),
            textureCaps: new WebGLTextureCaps(this._context)
        };
        this._vaoExt = this.createVertexArrayObjectEXT();
        this._instancedArraysExt = this.createInstancedArraysEXT();
        this._drawBuffersExt = this.createDrawBuffersEXT();
        this._context.pixelStorei(WebGLEnum.UNPACK_COLORSPACE_CONVERSION_WEBGL, WebGLEnum.NONE);
        this._context.pixelStorei(WebGLEnum.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.setViewport(null);
        this.setScissor(null);
        this._context.enable(WebGLEnum.SCISSOR_TEST);
        this.enableGPUTimeRecording(true);
        this._context._currentFramebuffer = undefined;
        this._context._currentProgram = undefined;
    }
    /** @internal */ clearErrors() {
        while(this._context.getError());
    }
    /** @internal */ getCurrentSamplerForTexture(tex) {
        return this._textureSamplerMap.get(tex);
    }
    /** @internal */ setCurrentSamplerForTexture(tex, sampler) {
        this._textureSamplerMap.set(tex, sampler);
    }
    getError(throwError) {
        const errcode = this._context.getError();
        const err = errcode === WebGLEnum.NO_ERROR ? null : new WebGLError(errcode);
        if (err && throwError) {
            throw err;
        }
        return err;
    }
}
let webGL1Supported = null;
let webGL2Supported = null;
const factory = makeEventTarget(WebGLDevice)();
async function createWebGLDevice(backend, cvs, options) {
    try {
        const device = new factory(backend, cvs, options);
        await device.initContext();
        device.setViewport();
        device.setScissor();
        return device;
    } catch (err) {
        console.error(err);
        return null;
    }
}
/** @internal */ const backend1 = {
    typeName () {
        return 'webgl';
    },
    supported () {
        if (webGL1Supported === null) {
            const cvs = document.createElement('canvas');
            const gl = cvs.getContext('webgl');
            webGL1Supported = !!gl;
            cvs.width = 0;
            cvs.height = 0;
        }
        return webGL1Supported;
    },
    async createDevice (cvs, options) {
        return createWebGLDevice(this, cvs, options);
    }
};
/** @internal */ const backend2 = {
    typeName () {
        return 'webgl2';
    },
    supported () {
        if (webGL2Supported === null) {
            const cvs = document.createElement('canvas');
            const gl = cvs.getContext('webgl2');
            webGL2Supported = !!gl;
            cvs.width = 0;
            cvs.height = 0;
        }
        return webGL2Supported;
    },
    async createDevice (cvs, options) {
        return createWebGLDevice(this, cvs, options);
    }
};

/**
 * The WebGL1 backend
 * @public
 */ const backendWebGL1 = backend1;
/**
 * The WebGL2 backend
 * @public
 */ const backendWebGL2 = backend2;

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

// deno-lint-ignore-file no-this-alias prefer-const

// Global

const MAX_BITS$1 = 15;
const D_CODES = 30;
const BL_CODES = 19;

const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = (LITERALS + 1 + LENGTH_CODES);
const HEAP_SIZE = (2 * L_CODES + 1);

const END_BLOCK = 256;

// Bit length codes must not exceed MAX_BL_BITS bits
const MAX_BL_BITS = 7;

// repeat previous bit length 3-6 times (2 bits of repeat count)
const REP_3_6 = 16;

// repeat a zero length 3-10 times (3 bits of repeat count)
const REPZ_3_10 = 17;

// repeat a zero length 11-138 times (7 bits of repeat count)
const REPZ_11_138 = 18;

// The lengths of the bit length codes are sent in order of decreasing
// probability, to avoid transmitting the lengths for unused bit
// length codes.

const Buf_size = 8 * 2;

// JZlib version : "1.0.2"
const Z_DEFAULT_COMPRESSION = -1;

// compression strategy
const Z_FILTERED = 1;
const Z_HUFFMAN_ONLY = 2;
const Z_DEFAULT_STRATEGY = 0;

const Z_NO_FLUSH$1 = 0;
const Z_PARTIAL_FLUSH = 1;
const Z_FULL_FLUSH = 3;
const Z_FINISH$1 = 4;

const Z_OK$1 = 0;
const Z_STREAM_END$1 = 1;
const Z_NEED_DICT$1 = 2;
const Z_STREAM_ERROR$1 = -2;
const Z_DATA_ERROR$1 = -3;
const Z_BUF_ERROR$1 = -5;

// Tree

function extractArray(array) {
	return flatArray(array.map(([length, value]) => (new Array(length)).fill(value, 0, length)));
}

function flatArray(array) {
	return array.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}

// see definition of array dist_code below
const _dist_code = [0, 1, 2, 3].concat(...extractArray([
	[2, 4], [2, 5], [4, 6], [4, 7], [8, 8], [8, 9], [16, 10], [16, 11], [32, 12], [32, 13], [64, 14], [64, 15], [2, 0], [1, 16],
	[1, 17], [2, 18], [2, 19], [4, 20], [4, 21], [8, 22], [8, 23], [16, 24], [16, 25], [32, 26], [32, 27], [64, 28], [64, 29]
]));

function Tree() {
	const that = this;

	// dyn_tree; // the dynamic tree
	// max_code; // largest code with non zero frequency
	// stat_desc; // the corresponding static tree

	// Compute the optimal bit lengths for a tree and update the total bit
	// length
	// for the current block.
	// IN assertion: the fields freq and dad are set, heap[heap_max] and
	// above are the tree nodes sorted by increasing frequency.
	// OUT assertions: the field len is set to the optimal bit length, the
	// array bl_count contains the frequencies for each bit length.
	// The length opt_len is updated; static_len is also updated if stree is
	// not null.
	function gen_bitlen(s) {
		const tree = that.dyn_tree;
		const stree = that.stat_desc.static_tree;
		const extra = that.stat_desc.extra_bits;
		const base = that.stat_desc.extra_base;
		const max_length = that.stat_desc.max_length;
		let h; // heap index
		let n, m; // iterate over the tree elements
		let bits; // bit length
		let xbits; // extra bits
		let f; // frequency
		let overflow = 0; // number of elements with bit length too large

		for (bits = 0; bits <= MAX_BITS$1; bits++)
			s.bl_count[bits] = 0;

		// In a first pass, compute the optimal bit lengths (which may
		// overflow in the case of the bit length tree).
		tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap

		for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
			n = s.heap[h];
			bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
			if (bits > max_length) {
				bits = max_length;
				overflow++;
			}
			tree[n * 2 + 1] = bits;
			// We overwrite tree[n*2+1] which is no longer needed

			if (n > that.max_code)
				continue; // not a leaf node

			s.bl_count[bits]++;
			xbits = 0;
			if (n >= base)
				xbits = extra[n - base];
			f = tree[n * 2];
			s.opt_len += f * (bits + xbits);
			if (stree)
				s.static_len += f * (stree[n * 2 + 1] + xbits);
		}
		if (overflow === 0)
			return;

		// This happens for example on obj2 and pic of the Calgary corpus
		// Find the first bit length which could increase:
		do {
			bits = max_length - 1;
			while (s.bl_count[bits] === 0)
				bits--;
			s.bl_count[bits]--; // move one leaf down the tree
			s.bl_count[bits + 1] += 2; // move one overflow item as its brother
			s.bl_count[max_length]--;
			// The brother of the overflow item also moves one step up,
			// but this does not affect bl_count[max_length]
			overflow -= 2;
		} while (overflow > 0);

		for (bits = max_length; bits !== 0; bits--) {
			n = s.bl_count[bits];
			while (n !== 0) {
				m = s.heap[--h];
				if (m > that.max_code)
					continue;
				if (tree[m * 2 + 1] != bits) {
					s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
					tree[m * 2 + 1] = bits;
				}
				n--;
			}
		}
	}

	// Reverse the first len bits of a code, using straightforward code (a
	// faster
	// method would use a table)
	// IN assertion: 1 <= len <= 15
	function bi_reverse(code, // the value to invert
		len // its bit length
	) {
		let res = 0;
		do {
			res |= code & 1;
			code >>>= 1;
			res <<= 1;
		} while (--len > 0);
		return res >>> 1;
	}

	// Generate the codes for a given tree and bit counts (which need not be
	// optimal).
	// IN assertion: the array bl_count contains the bit length statistics for
	// the given tree and the field len is set for all tree elements.
	// OUT assertion: the field code is set for all tree elements of non
	// zero code length.
	function gen_codes(tree, // the tree to decorate
		max_code, // largest code with non zero frequency
		bl_count // number of codes at each bit length
	) {
		const next_code = []; // next code value for each
		// bit length
		let code = 0; // running code value
		let bits; // bit index
		let n; // code index
		let len;

		// The distribution counts are first used to generate the code values
		// without bit reversal.
		for (bits = 1; bits <= MAX_BITS$1; bits++) {
			next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);
		}

		// Check that the bit counts in bl_count are consistent. The last code
		// must be all ones.
		// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
		// "inconsistent bit counts");
		// Tracev((stderr,"gen_codes: max_code %d ", max_code));

		for (n = 0; n <= max_code; n++) {
			len = tree[n * 2 + 1];
			if (len === 0)
				continue;
			// Now reverse the bits
			tree[n * 2] = bi_reverse(next_code[len]++, len);
		}
	}

	// Construct one Huffman tree and assigns the code bit strings and lengths.
	// Update the total bit length for the current block.
	// IN assertion: the field freq is set for all tree elements.
	// OUT assertions: the fields len and code are set to the optimal bit length
	// and corresponding code. The length opt_len is updated; static_len is
	// also updated if stree is not null. The field max_code is set.
	that.build_tree = function (s) {
		const tree = that.dyn_tree;
		const stree = that.stat_desc.static_tree;
		const elems = that.stat_desc.elems;
		let n, m; // iterate over heap elements
		let max_code = -1; // largest code with non zero frequency
		let node; // new node being created

		// Construct the initial heap, with least frequent element in
		// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
		// heap[0] is not used.
		s.heap_len = 0;
		s.heap_max = HEAP_SIZE;

		for (n = 0; n < elems; n++) {
			if (tree[n * 2] !== 0) {
				s.heap[++s.heap_len] = max_code = n;
				s.depth[n] = 0;
			} else {
				tree[n * 2 + 1] = 0;
			}
		}

		// The pkzip format requires that at least one distance code exists,
		// and that at least one bit should be sent even if there is only one
		// possible code. So to avoid special checks later on we force at least
		// two codes of non zero frequency.
		while (s.heap_len < 2) {
			node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
			tree[node * 2] = 1;
			s.depth[node] = 0;
			s.opt_len--;
			if (stree)
				s.static_len -= stree[node * 2 + 1];
			// node is 0 or 1 so it does not have extra bits
		}
		that.max_code = max_code;

		// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
		// establish sub-heaps of increasing lengths:

		for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
			s.pqdownheap(tree, n);

		// Construct the Huffman tree by repeatedly combining the least two
		// frequent nodes.

		node = elems; // next internal node of the tree
		do {
			// n = node of least frequency
			n = s.heap[1];
			s.heap[1] = s.heap[s.heap_len--];
			s.pqdownheap(tree, 1);
			m = s.heap[1]; // m = node of next least frequency

			s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency
			s.heap[--s.heap_max] = m;

			// Create a new node father of n and m
			tree[node * 2] = (tree[n * 2] + tree[m * 2]);
			s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
			tree[n * 2 + 1] = tree[m * 2 + 1] = node;

			// and insert the new node in the heap
			s.heap[1] = node++;
			s.pqdownheap(tree, 1);
		} while (s.heap_len >= 2);

		s.heap[--s.heap_max] = s.heap[1];

		// At this point, the fields freq and dad are set. We can now
		// generate the bit lengths.

		gen_bitlen(s);

		// The field len is now set, we can generate the bit codes
		gen_codes(tree, that.max_code, s.bl_count);
	};

}

Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...extractArray([
	[2, 8], [2, 9], [2, 10], [2, 11], [4, 12], [4, 13], [4, 14], [4, 15], [8, 16], [8, 17], [8, 18], [8, 19],
	[16, 20], [16, 21], [16, 22], [16, 23], [32, 24], [32, 25], [32, 26], [31, 27], [1, 28]]));

Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];

Tree.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,
	24576];

// Mapping from a distance to a distance code. dist is the distance - 1 and
// must not have side effects. _dist_code[256] and _dist_code[257] are never
// used.
Tree.d_code = function (dist) {
	return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);
};

// extra bits for each length code
Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

// extra bits for each distance code
Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

// extra bits for each bit length code
Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

// StaticTree

function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
	const that = this;
	that.static_tree = static_tree;
	that.extra_bits = extra_bits;
	that.extra_base = extra_base;
	that.elems = elems;
	that.max_length = max_length;
}

const static_ltree2_first_part = [12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82,
	210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86,
	214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81,
	209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85,
	213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 19, 275, 147, 403, 83, 339, 211, 467, 51, 307,
	179, 435, 115, 371, 243, 499, 11, 267, 139, 395, 75, 331, 203, 459, 43, 299, 171, 427, 107, 363, 235, 491, 27, 283, 155, 411, 91, 347, 219, 475,
	59, 315, 187, 443, 123, 379, 251, 507, 7, 263, 135, 391, 71, 327, 199, 455, 39, 295, 167, 423, 103, 359, 231, 487, 23, 279, 151, 407, 87, 343, 215,
	471, 55, 311, 183, 439, 119, 375, 247, 503, 15, 271, 143, 399, 79, 335, 207, 463, 47, 303, 175, 431, 111, 367, 239, 495, 31, 287, 159, 415, 95,
	351, 223, 479, 63, 319, 191, 447, 127, 383, 255, 511, 0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52,
	116, 3, 131, 67, 195, 35, 163, 99, 227];
const static_ltree2_second_part = extractArray([[144, 8], [112, 9], [24, 7], [8, 8]]);
StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value, index) => [value, static_ltree2_second_part[index]]));

const static_dtree_first_part = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23];
const static_dtree_second_part = extractArray([[30, 5]]);
StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value, index) => [value, static_dtree_second_part[index]]));

StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS$1);

StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS$1);

StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);

// Deflate

const MAX_MEM_LEVEL = 9;
const DEF_MEM_LEVEL = 8;

function Config(good_length, max_lazy, nice_length, max_chain, func) {
	const that = this;
	that.good_length = good_length;
	that.max_lazy = max_lazy;
	that.nice_length = nice_length;
	that.max_chain = max_chain;
	that.func = func;
}

const STORED$1 = 0;
const FAST = 1;
const SLOW = 2;
const config_table = [
	new Config(0, 0, 0, 0, STORED$1),
	new Config(4, 4, 8, 4, FAST),
	new Config(4, 5, 16, 8, FAST),
	new Config(4, 6, 32, 32, FAST),
	new Config(4, 4, 16, 16, SLOW),
	new Config(8, 16, 32, 32, SLOW),
	new Config(8, 16, 128, 128, SLOW),
	new Config(8, 32, 128, 256, SLOW),
	new Config(32, 128, 258, 1024, SLOW),
	new Config(32, 258, 258, 4096, SLOW)
];

const z_errmsg = ["need dictionary", // Z_NEED_DICT
	// 2
	"stream end", // Z_STREAM_END 1
	"", // Z_OK 0
	"", // Z_ERRNO (-1)
	"stream error", // Z_STREAM_ERROR (-2)
	"data error", // Z_DATA_ERROR (-3)
	"", // Z_MEM_ERROR (-4)
	"buffer error", // Z_BUF_ERROR (-5)
	"",// Z_VERSION_ERROR (-6)
	""];

// block not completed, need more input or more output
const NeedMore = 0;

// block flush performed
const BlockDone = 1;

// finish started, need only more output at next deflate
const FinishStarted = 2;

// finish done, accept no more input or output
const FinishDone = 3;

// preset dictionary flag in zlib header
const PRESET_DICT$1 = 0x20;

const INIT_STATE = 42;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

// The deflate compression method
const Z_DEFLATED$1 = 8;

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

function smaller(tree, n, m, depth) {
	const tn2 = tree[n * 2];
	const tm2 = tree[m * 2];
	return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));
}

function Deflate() {

	const that = this;
	let strm; // pointer back to this zlib stream
	let status; // as the name implies
	// pending_buf; // output still pending
	let pending_buf_size; // size of pending_buf
	// pending_out; // next pending byte to output to the stream
	// pending; // nb of bytes in the pending buffer

	// dist_buf; // buffer for distances
	// lc_buf; // buffer for literals or lengths
	// To simplify the code, dist_buf and lc_buf have the same number of elements.
	// To use different lengths, an extra flag array would be necessary.

	let last_flush; // value of flush param for previous deflate call

	let w_size; // LZ77 win size (32K by default)
	let w_bits; // log2(w_size) (8..16)
	let w_mask; // w_size - 1

	let win;
	// Sliding win. Input bytes are read into the second half of the win,
	// and move to the first half later to keep a dictionary of at least wSize
	// bytes. With this organization, matches are limited to a distance of
	// wSize-MAX_MATCH bytes, but this ensures that IO is always
	// performed with a length multiple of the block size. Also, it limits
	// the win size to 64K, which is quite useful on MSDOS.
	// To do: use the user input buffer as sliding win.

	let window_size;
	// Actual size of win: 2*wSize, except when the user input buffer
	// is directly used as sliding win.

	let prev;
	// Link to older string with same hash index. To limit the size of this
	// array to 64K, this link is maintained only for the last 32K strings.
	// An index in this array is thus a win index modulo 32K.

	let head; // Heads of the hash chains or NIL.

	let ins_h; // hash index of string to be inserted
	let hash_size; // number of elements in hash table
	let hash_bits; // log2(hash_size)
	let hash_mask; // hash_size-1

	// Number of bits by which ins_h must be shifted at each input
	// step. It must be such that after MIN_MATCH steps, the oldest
	// byte no longer takes part in the hash key, that is:
	// hash_shift * MIN_MATCH >= hash_bits
	let hash_shift;

	// Window position at the beginning of the current output block. Gets
	// negative when the win is moved backwards.

	let block_start;

	let match_length; // length of best match
	let prev_match; // previous match
	let match_available; // set if previous match exists
	let strstart; // start of string to insert
	let match_start; // start of matching string
	let lookahead; // number of valid bytes ahead in win

	// Length of the best match at previous step. Matches not greater than this
	// are discarded. This is used in the lazy match evaluation.
	let prev_length;

	// To speed up deflation, hash chains are never searched beyond this
	// length. A higher limit improves compression ratio but degrades the speed.
	let max_chain_length;

	// Attempt to find a better match only when the current match is strictly
	// smaller than this value. This mechanism is used only for compression
	// levels >= 4.
	let max_lazy_match;

	// Insert new strings in the hash table only if the match length is not
	// greater than this length. This saves time but degrades compression.
	// max_insert_length is used only for compression levels <= 3.

	let level; // compression level (1..9)
	let strategy; // favor or force Huffman coding

	// Use a faster search when the previous match is longer than this
	let good_match;

	// Stop searching when current match exceeds this
	let nice_match;

	let dyn_ltree; // literal and length tree
	let dyn_dtree; // distance tree
	let bl_tree; // Huffman tree for bit lengths

	const l_desc = new Tree(); // desc for literal tree
	const d_desc = new Tree(); // desc for distance tree
	const bl_desc = new Tree(); // desc for bit length tree

	// that.heap_len; // number of elements in the heap
	// that.heap_max; // element of largest frequency
	// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	// The same heap array is used to build all trees.

	// Depth of each subtree used as tie breaker for trees of equal frequency
	that.depth = [];

	// Size of match buffer for literals/lengths. There are 4 reasons for
	// limiting lit_bufsize to 64K:
	// - frequencies can be kept in 16 bit counters
	// - if compression is not successful for the first block, all input
	// data is still in the win so we can still emit a stored block even
	// when input comes from standard input. (This can also be done for
	// all blocks if lit_bufsize is not greater than 32K.)
	// - if compression is not successful for a file smaller than 64K, we can
	// even emit a stored file instead of a stored block (saving 5 bytes).
	// This is applicable only for zip (not gzip or zlib).
	// - creating new Huffman trees less frequently may not provide fast
	// adaptation to changes in the input data statistics. (Take for
	// example a binary file with poorly compressible code followed by
	// a highly compressible string table.) Smaller buffer sizes give
	// fast adaptation but have of course the overhead of transmitting
	// trees more frequently.
	// - I can't count above 4
	let lit_bufsize;

	let last_lit; // running index in dist_buf and lc_buf

	// that.opt_len; // bit length of current block with optimal trees
	// that.static_len; // bit length of current block with static trees
	let matches; // number of string matches in current block
	let last_eob_len; // bit length of EOB code for last block

	// Output buffer. bits are inserted starting at the bottom (least
	// significant bits).
	let bi_buf;

	// Number of valid bits in bi_buf. All bits above the last valid bit
	// are always zero.
	let bi_valid;

	// number of codes at each bit length for an optimal tree
	that.bl_count = [];

	// heap used to build the Huffman trees
	that.heap = [];

	dyn_ltree = [];
	dyn_dtree = [];
	bl_tree = [];

	function lm_init() {
		window_size = 2 * w_size;

		head[hash_size - 1] = 0;
		for (let i = 0; i < hash_size - 1; i++) {
			head[i] = 0;
		}

		// Set the default configuration parameters:
		max_lazy_match = config_table[level].max_lazy;
		good_match = config_table[level].good_length;
		nice_match = config_table[level].nice_length;
		max_chain_length = config_table[level].max_chain;

		strstart = 0;
		block_start = 0;
		lookahead = 0;
		match_length = prev_length = MIN_MATCH - 1;
		match_available = 0;
		ins_h = 0;
	}

	function init_block() {
		let i;
		// Initialize the trees.
		for (i = 0; i < L_CODES; i++)
			dyn_ltree[i * 2] = 0;
		for (i = 0; i < D_CODES; i++)
			dyn_dtree[i * 2] = 0;
		for (i = 0; i < BL_CODES; i++)
			bl_tree[i * 2] = 0;

		dyn_ltree[END_BLOCK * 2] = 1;
		that.opt_len = that.static_len = 0;
		last_lit = matches = 0;
	}

	// Initialize the tree data structures for a new zlib stream.
	function tr_init() {

		l_desc.dyn_tree = dyn_ltree;
		l_desc.stat_desc = StaticTree.static_l_desc;

		d_desc.dyn_tree = dyn_dtree;
		d_desc.stat_desc = StaticTree.static_d_desc;

		bl_desc.dyn_tree = bl_tree;
		bl_desc.stat_desc = StaticTree.static_bl_desc;

		bi_buf = 0;
		bi_valid = 0;
		last_eob_len = 8; // enough lookahead for inflate

		// Initialize the first block of the first file:
		init_block();
	}

	// Restore the heap property by moving down the tree starting at node k,
	// exchanging a node with the smallest of its two sons if necessary,
	// stopping
	// when the heap property is re-established (each father smaller than its
	// two sons).
	that.pqdownheap = function (tree, // the tree to restore
		k // node to move down
	) {
		const heap = that.heap;
		const v = heap[k];
		let j = k << 1; // left son of k
		while (j <= that.heap_len) {
			// Set j to the smallest of the two sons:
			if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
				j++;
			}
			// Exit if v is smaller than both sons
			if (smaller(tree, v, heap[j], that.depth))
				break;

			// Exchange v with the smallest son
			heap[k] = heap[j];
			k = j;
			// And continue down the tree, setting j to the left son of k
			j <<= 1;
		}
		heap[k] = v;
	};

	// Scan a literal or distance tree to determine the frequencies of the codes
	// in the bit length tree.
	function scan_tree(tree,// the tree to be scanned
		max_code // and its largest code of non zero frequency
	) {
		let prevlen = -1; // last emitted length
		let curlen; // length of current code
		let nextlen = tree[0 * 2 + 1]; // length of next code
		let count = 0; // repeat count of the current code
		let max_count = 7; // max repeat count
		let min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		tree[(max_code + 1) * 2 + 1] = 0xffff; // guard

		for (let n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen == nextlen) {
				continue;
			} else if (count < min_count) {
				bl_tree[curlen * 2] += count;
			} else if (curlen !== 0) {
				if (curlen != prevlen)
					bl_tree[curlen * 2]++;
				bl_tree[REP_3_6 * 2]++;
			} else if (count <= 10) {
				bl_tree[REPZ_3_10 * 2]++;
			} else {
				bl_tree[REPZ_11_138 * 2]++;
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen == nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	// Construct the Huffman tree for the bit lengths and return the index in
	// bl_order of the last bit length code to send.
	function build_bl_tree() {
		let max_blindex; // index of last bit length code of non zero freq

		// Determine the bit length frequencies for literal and distance trees
		scan_tree(dyn_ltree, l_desc.max_code);
		scan_tree(dyn_dtree, d_desc.max_code);

		// Build the bit length tree:
		bl_desc.build_tree(that);
		// opt_len now includes the length of the tree representations, except
		// the lengths of the bit lengths codes and the 5+5+4 bits for the
		// counts.

		// Determine the number of bit length codes to send. The pkzip format
		// requires that at least 4 bit length codes be sent. (appnote.txt says
		// 3 but the actual value used is 4.)
		for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
			if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
				break;
		}
		// Update opt_len to include the bit length tree and counts
		that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;

		return max_blindex;
	}

	// Output a byte on the stream.
	// IN assertion: there is enough room in pending_buf.
	function put_byte(p) {
		that.pending_buf[that.pending++] = p;
	}

	function put_short(w) {
		put_byte(w & 0xff);
		put_byte((w >>> 8) & 0xff);
	}

	function putShortMSB(b) {
		put_byte((b >> 8) & 0xff);
		put_byte((b & 0xff) & 0xff);
	}

	function send_bits(value, length) {
		let val;
		const len = length;
		if (bi_valid > Buf_size - len) {
			val = value;
			// bi_buf |= (val << bi_valid);
			bi_buf |= ((val << bi_valid) & 0xffff);
			put_short(bi_buf);
			bi_buf = val >>> (Buf_size - bi_valid);
			bi_valid += len - Buf_size;
		} else {
			// bi_buf |= (value) << bi_valid;
			bi_buf |= (((value) << bi_valid) & 0xffff);
			bi_valid += len;
		}
	}

	function send_code(c, tree) {
		const c2 = c * 2;
		send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);
	}

	// Send a literal or distance tree in compressed form, using the codes in
	// bl_tree.
	function send_tree(tree,// the tree to be sent
		max_code // and its largest code of non zero frequency
	) {
		let n; // iterates over all tree elements
		let prevlen = -1; // last emitted length
		let curlen; // length of current code
		let nextlen = tree[0 * 2 + 1]; // length of next code
		let count = 0; // repeat count of the current code
		let max_count = 7; // max repeat count
		let min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}

		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen == nextlen) {
				continue;
			} else if (count < min_count) {
				do {
					send_code(curlen, bl_tree);
				} while (--count !== 0);
			} else if (curlen !== 0) {
				if (curlen != prevlen) {
					send_code(curlen, bl_tree);
					count--;
				}
				send_code(REP_3_6, bl_tree);
				send_bits(count - 3, 2);
			} else if (count <= 10) {
				send_code(REPZ_3_10, bl_tree);
				send_bits(count - 3, 3);
			} else {
				send_code(REPZ_11_138, bl_tree);
				send_bits(count - 11, 7);
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen == nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	// Send the header for a block using dynamic Huffman trees: the counts, the
	// lengths of the bit length codes, the literal tree and the distance tree.
	// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	function send_all_trees(lcodes, dcodes, blcodes) {
		let rank; // index in bl_order

		send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt
		send_bits(dcodes - 1, 5);
		send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt
		for (rank = 0; rank < blcodes; rank++) {
			send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
		}
		send_tree(dyn_ltree, lcodes - 1); // literal tree
		send_tree(dyn_dtree, dcodes - 1); // distance tree
	}

	// Flush the bit buffer, keeping at most 7 bits in it.
	function bi_flush() {
		if (bi_valid == 16) {
			put_short(bi_buf);
			bi_buf = 0;
			bi_valid = 0;
		} else if (bi_valid >= 8) {
			put_byte(bi_buf & 0xff);
			bi_buf >>>= 8;
			bi_valid -= 8;
		}
	}

	// Send one empty static block to give enough lookahead for inflate.
	// This takes 10 bits, of which 7 may remain in the bit buffer.
	// The current inflate code requires 9 bits of lookahead. If the
	// last two codes for the previous block (real code plus EOB) were coded
	// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
	// the last real code. In this case we send two empty static blocks instead
	// of one. (There are no problems if the previous block is stored or fixed.)
	// To simplify the code, we assume the worst case of last real code encoded
	// on one bit only.
	function _tr_align() {
		send_bits(STATIC_TREES << 1, 3);
		send_code(END_BLOCK, StaticTree.static_ltree);

		bi_flush();

		// Of the 10 bits for the empty block, we have already sent
		// (10 - bi_valid) bits. The lookahead for the last real code (before
		// the EOB of the previous block) was thus at least one plus the length
		// of the EOB plus what we have just sent of the empty static block.
		if (1 + last_eob_len + 10 - bi_valid < 9) {
			send_bits(STATIC_TREES << 1, 3);
			send_code(END_BLOCK, StaticTree.static_ltree);
			bi_flush();
		}
		last_eob_len = 7;
	}

	// Save the match info and tally the frequency counts. Return true if
	// the current block must be flushed.
	function _tr_tally(dist, // distance of matched string
		lc // match length-MIN_MATCH or unmatched char (if dist==0)
	) {
		let out_length, in_length, dcode;
		that.dist_buf[last_lit] = dist;
		that.lc_buf[last_lit] = lc & 0xff;
		last_lit++;

		if (dist === 0) {
			// lc is the unmatched char
			dyn_ltree[lc * 2]++;
		} else {
			matches++;
			// Here, lc is the match length - MIN_MATCH
			dist--; // dist = match distance - 1
			dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;
			dyn_dtree[Tree.d_code(dist) * 2]++;
		}

		if ((last_lit & 0x1fff) === 0 && level > 2) {
			// Compute an upper bound for the compressed length
			out_length = last_lit * 8;
			in_length = strstart - block_start;
			for (dcode = 0; dcode < D_CODES; dcode++) {
				out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
			}
			out_length >>>= 3;
			if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))
				return true;
		}

		return (last_lit == lit_bufsize - 1);
		// We avoid equality with lit_bufsize because of wraparound at 64K
		// on 16 bit machines and because stored blocks are restricted to
		// 64K-1 bytes.
	}

	// Send the block data compressed using the given Huffman trees
	function compress_block(ltree, dtree) {
		let dist; // distance of matched string
		let lc; // match length or unmatched char (if dist === 0)
		let lx = 0; // running index in dist_buf and lc_buf
		let code; // the code to send
		let extra; // number of extra bits to send

		if (last_lit !== 0) {
			do {
				dist = that.dist_buf[lx];
				lc = that.lc_buf[lx];
				lx++;

				if (dist === 0) {
					send_code(lc, ltree); // send a literal byte
				} else {
					// Here, lc is the match length - MIN_MATCH
					code = Tree._length_code[lc];

					send_code(code + LITERALS + 1, ltree); // send the length
					// code
					extra = Tree.extra_lbits[code];
					if (extra !== 0) {
						lc -= Tree.base_length[code];
						send_bits(lc, extra); // send the extra length bits
					}
					dist--; // dist is now the match distance - 1
					code = Tree.d_code(dist);

					send_code(code, dtree); // send the distance code
					extra = Tree.extra_dbits[code];
					if (extra !== 0) {
						dist -= Tree.base_dist[code];
						send_bits(dist, extra); // send the extra distance bits
					}
				} // literal or match pair ?
			} while (lx < last_lit);
		}

		send_code(END_BLOCK, ltree);
		last_eob_len = ltree[END_BLOCK * 2 + 1];
	}

	// Flush the bit buffer and align the output on a byte boundary
	function bi_windup() {
		if (bi_valid > 8) {
			put_short(bi_buf);
		} else if (bi_valid > 0) {
			put_byte(bi_buf & 0xff);
		}
		bi_buf = 0;
		bi_valid = 0;
	}

	// Copy a stored block, storing first the length and its
	// one's complement if requested.
	function copy_block(buf, // the input data
		len, // its length
		header // true if block header must be written
	) {
		bi_windup(); // align on byte boundary
		last_eob_len = 8; // enough lookahead for inflate

		if (header) {
			put_short(len);
			put_short(~len);
		}

		that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
		that.pending += len;
	}

	// Send a stored block
	function _tr_stored_block(buf, // input block
		stored_len, // length of input block
		eof // true if this is the last block for a file
	) {
		send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type
		copy_block(buf, stored_len, true); // with header
	}

	// Determine the best encoding for the current block: dynamic trees, static
	// trees or store, and output the encoded block to the zip file.
	function _tr_flush_block(buf, // input block, or NULL if too old
		stored_len, // length of input block
		eof // true if this is the last block for a file
	) {
		let opt_lenb, static_lenb;// opt_len and static_len in bytes
		let max_blindex = 0; // index of last bit length code of non zero freq

		// Build the Huffman trees unless a stored block is forced
		if (level > 0) {
			// Construct the literal and distance trees
			l_desc.build_tree(that);

			d_desc.build_tree(that);

			// At this point, opt_len and static_len are the total bit lengths
			// of
			// the compressed block data, excluding the tree representations.

			// Build the bit length tree for the above two trees, and get the
			// index
			// in bl_order of the last bit length code to send.
			max_blindex = build_bl_tree();

			// Determine the best encoding. Compute first the block length in
			// bytes
			opt_lenb = (that.opt_len + 3 + 7) >>> 3;
			static_lenb = (that.static_len + 3 + 7) >>> 3;

			if (static_lenb <= opt_lenb)
				opt_lenb = static_lenb;
		} else {
			opt_lenb = static_lenb = stored_len + 5; // force a stored block
		}

		if ((stored_len + 4 <= opt_lenb) && buf != -1) {
			// 4: two words for the lengths
			// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
			// Otherwise we can't have processed more than WSIZE input bytes
			// since
			// the last block flush, because compression would have been
			// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
			// transform a block into a stored block.
			_tr_stored_block(buf, stored_len, eof);
		} else if (static_lenb == opt_lenb) {
			send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
			compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
		} else {
			send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
			send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
			compress_block(dyn_ltree, dyn_dtree);
		}

		// The above check is made mod 2^32, for files larger than 512 MB
		// and uLong implemented on 32 bits.

		init_block();

		if (eof) {
			bi_windup();
		}
	}

	function flush_block_only(eof) {
		_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
		block_start = strstart;
		strm.flush_pending();
	}

	// Fill the win when the lookahead becomes insufficient.
	// Updates strstart and lookahead.
	//
	// IN assertion: lookahead < MIN_LOOKAHEAD
	// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	// At least one byte has been read, or avail_in === 0; reads are
	// performed for at least two bytes (required for the zip translate_eol
	// option -- not supported here).
	function fill_window() {
		let n, m;
		let p;
		let more; // Amount of free space at the end of the win.

		do {
			more = (window_size - lookahead - strstart);

			// Deal with !@#$% 64K limit:
			if (more === 0 && strstart === 0 && lookahead === 0) {
				more = w_size;
			} else if (more == -1) {
				// Very unlikely, but possible on 16 bit machine if strstart ==
				// 0
				// and lookahead == 1 (input done one byte at time)
				more--;

				// If the win is almost full and there is insufficient
				// lookahead,
				// move the upper half to the lower one to make room in the
				// upper half.
			} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
				win.set(win.subarray(w_size, w_size + w_size), 0);

				match_start -= w_size;
				strstart -= w_size; // we now have strstart >= MAX_DIST
				block_start -= w_size;

				// Slide the hash table (could be avoided with 32 bit values
				// at the expense of memory usage). We slide even when level ==
				// 0
				// to keep the hash table consistent if we switch back to level
				// > 0
				// later. (Using level 0 permanently is not an optimal usage of
				// zlib, so we don't care about this pathological case.)

				n = hash_size;
				p = n;
				do {
					m = (head[--p] & 0xffff);
					head[p] = (m >= w_size ? m - w_size : 0);
				} while (--n !== 0);

				n = w_size;
				p = n;
				do {
					m = (prev[--p] & 0xffff);
					prev[p] = (m >= w_size ? m - w_size : 0);
					// If n is not on any hash chain, prev[n] is garbage but
					// its value will never be used.
				} while (--n !== 0);
				more += w_size;
			}

			if (strm.avail_in === 0)
				return;

			// If there was no sliding:
			// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
			// more == window_size - lookahead - strstart
			// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
			// => more >= window_size - 2*WSIZE + 2
			// In the BIG_MEM or MMAP case (not yet supported),
			// window_size == input_size + MIN_LOOKAHEAD &&
			// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
			// Otherwise, window_size == 2*WSIZE so more >= 2.
			// If there was sliding, more >= WSIZE. So in all cases, more >= 2.

			n = strm.read_buf(win, strstart + lookahead, more);
			lookahead += n;

			// Initialize the hash value now that we have some input:
			if (lookahead >= MIN_MATCH) {
				ins_h = win[strstart] & 0xff;
				ins_h = (((ins_h) << hash_shift) ^ (win[strstart + 1] & 0xff)) & hash_mask;
			}
			// If the whole input has less than MIN_MATCH bytes, ins_h is
			// garbage,
			// but this is not important since only literal bytes will be
			// emitted.
		} while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);
	}

	// Copy without compression as much as possible from the input stream,
	// return
	// the current block state.
	// This function does not insert new strings in the dictionary since
	// uncompressible data is probably not useful. This function is used
	// only for the level=0 compression option.
	// NOTE: this function should be optimized to avoid extra copying from
	// win to pending_buf.
	function deflate_stored(flush) {
		// Stored blocks are limited to 0xffff bytes, pending_buf is limited
		// to pending_buf_size, and each stored block has a 5 byte header:

		let max_block_size = 0xffff;
		let max_start;

		if (max_block_size > pending_buf_size - 5) {
			max_block_size = pending_buf_size - 5;
		}

		// Copy as much as possible from input to output:
		// eslint-disable-next-line no-constant-condition
		while (true) {
			// Fill the win as much as possible:
			if (lookahead <= 1) {
				fill_window();
				if (lookahead === 0 && flush == Z_NO_FLUSH$1)
					return NeedMore;
				if (lookahead === 0)
					break; // flush the current block
			}

			strstart += lookahead;
			lookahead = 0;

			// Emit a stored block if pending_buf will be full:
			max_start = block_start + max_block_size;
			if (strstart === 0 || strstart >= max_start) {
				// strstart === 0 is possible when wraparound on 16-bit machine
				lookahead = (strstart - max_start);
				strstart = max_start;

				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;

			}

			// Flush if we may have to slide, otherwise block_start may become
			// negative and the data will be gone:
			if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;
			}
		}

		flush_block_only(flush == Z_FINISH$1);
		if (strm.avail_out === 0)
			return (flush == Z_FINISH$1) ? FinishStarted : NeedMore;

		return flush == Z_FINISH$1 ? FinishDone : BlockDone;
	}

	function longest_match(cur_match) {
		let chain_length = max_chain_length; // max hash chain length
		let scan = strstart; // current string
		let match; // matched string
		let len; // length of current match
		let best_len = prev_length; // best match length so far
		const limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
		let _nice_match = nice_match;

		// Stop when cur_match becomes <= limit. To simplify the code,
		// we prevent matches with the string of win index 0.

		const wmask = w_mask;

		const strend = strstart + MAX_MATCH;
		let scan_end1 = win[scan + best_len - 1];
		let scan_end = win[scan + best_len];

		// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of
		// 16.
		// It is easy to get rid of this optimization if necessary.

		// Do not waste too much time if we already have a good match:
		if (prev_length >= good_match) {
			chain_length >>= 2;
		}

		// Do not look for matches beyond the end of the input. This is
		// necessary
		// to make deflate deterministic.
		if (_nice_match > lookahead)
			_nice_match = lookahead;

		do {
			match = cur_match;

			// Skip to next match if the match length cannot increase
			// or if the match length is less than 2:
			if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan]
				|| win[++match] != win[scan + 1])
				continue;

			// The check at best_len-1 can be removed because it will be made
			// again later. (This heuristic is not always a win.)
			// It is not necessary to compare scan[2] and match[2] since they
			// are always equal when the other bytes match, given that
			// the hash keys are equal and that HASH_BITS >= 8.
			scan += 2;
			match++;

			// We check for insufficient lookahead only every 8th comparison;
			// the 256th check will be made at strstart+258.
			// eslint-disable-next-line no-empty
			do {
				// empty block
			} while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match]
			&& win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match]
			&& win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend);

			len = MAX_MATCH - (strend - scan);
			scan = strend - MAX_MATCH;

			if (len > best_len) {
				match_start = cur_match;
				best_len = len;
				if (len >= _nice_match)
					break;
				scan_end1 = win[scan + best_len - 1];
				scan_end = win[scan + best_len];
			}

		} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);

		if (best_len <= lookahead)
			return best_len;
		return lookahead;
	}

	// Compress as much as possible from the input stream, return the current
	// block state.
	// This function does not perform lazy evaluation of matches and inserts
	// new strings in the dictionary only for unmatched strings or for short
	// matches. It is used only for the fast compression options.
	function deflate_fast(flush) {
		// short hash_head = 0; // head of the hash chain
		let hash_head = 0; // head of the hash chain
		let bflush; // set if current block must be flushed

		// eslint-disable-next-line no-constant-condition
		while (true) {
			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.
			if (lookahead < MIN_LOOKAHEAD) {
				fill_window();
				if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH$1) {
					return NeedMore;
				}
				if (lookahead === 0)
					break; // flush the current block
			}

			// Insert the string win[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:
			if (lookahead >= MIN_MATCH) {
				ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;

				// prev[strstart&w_mask]=hash_head=head[ins_h];
				hash_head = (head[ins_h] & 0xffff);
				prev[strstart & w_mask] = head[ins_h];
				head[ins_h] = strstart;
			}

			// Find the longest match, discarding those <= prev_length.
			// At this point we have always match_length < MIN_MATCH

			if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
				// To simplify the code, we prevent matches with the string
				// of win index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				if (strategy != Z_HUFFMAN_ONLY) {
					match_length = longest_match(hash_head);
				}
				// longest_match() sets match_start
			}
			if (match_length >= MIN_MATCH) {
				// check_match(strstart, match_start, match_length);

				bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);

				lookahead -= match_length;

				// Insert new strings in the hash table only if the match length
				// is not too large. This saves time but degrades compression.
				if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {
					match_length--; // string at strstart already in hash table
					do {
						strstart++;

						ins_h = ((ins_h << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
						// prev[strstart&w_mask]=hash_head=head[ins_h];
						hash_head = (head[ins_h] & 0xffff);
						prev[strstart & w_mask] = head[ins_h];
						head[ins_h] = strstart;

						// strstart never exceeds WSIZE-MAX_MATCH, so there are
						// always MIN_MATCH bytes ahead.
					} while (--match_length !== 0);
					strstart++;
				} else {
					strstart += match_length;
					match_length = 0;
					ins_h = win[strstart] & 0xff;

					ins_h = (((ins_h) << hash_shift) ^ (win[strstart + 1] & 0xff)) & hash_mask;
					// If lookahead < MIN_MATCH, ins_h is garbage, but it does
					// not
					// matter since it will be recomputed at next deflate call.
				}
			} else {
				// No match, output a literal byte

				bflush = _tr_tally(0, win[strstart] & 0xff);
				lookahead--;
				strstart++;
			}
			if (bflush) {

				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;
			}
		}

		flush_block_only(flush == Z_FINISH$1);
		if (strm.avail_out === 0) {
			if (flush == Z_FINISH$1)
				return FinishStarted;
			else
				return NeedMore;
		}
		return flush == Z_FINISH$1 ? FinishDone : BlockDone;
	}

	// Same as above, but achieves better compression. We use a lazy
	// evaluation for matches: a match is finally adopted only if there is
	// no better match at the next win position.
	function deflate_slow(flush) {
		// short hash_head = 0; // head of hash chain
		let hash_head = 0; // head of hash chain
		let bflush; // set if current block must be flushed
		let max_insert;

		// Process the input block.
		// eslint-disable-next-line no-constant-condition
		while (true) {
			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.

			if (lookahead < MIN_LOOKAHEAD) {
				fill_window();
				if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH$1) {
					return NeedMore;
				}
				if (lookahead === 0)
					break; // flush the current block
			}

			// Insert the string win[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:

			if (lookahead >= MIN_MATCH) {
				ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
				// prev[strstart&w_mask]=hash_head=head[ins_h];
				hash_head = (head[ins_h] & 0xffff);
				prev[strstart & w_mask] = head[ins_h];
				head[ins_h] = strstart;
			}

			// Find the longest match, discarding those <= prev_length.
			prev_length = match_length;
			prev_match = match_start;
			match_length = MIN_MATCH - 1;

			if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
				// To simplify the code, we prevent matches with the string
				// of win index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).

				if (strategy != Z_HUFFMAN_ONLY) {
					match_length = longest_match(hash_head);
				}
				// longest_match() sets match_start

				if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {

					// If prev_match is also MIN_MATCH, match_start is garbage
					// but we will ignore the current match anyway.
					match_length = MIN_MATCH - 1;
				}
			}

			// If there was a match at the previous step and the current
			// match is not better, output the previous match:
			if (prev_length >= MIN_MATCH && match_length <= prev_length) {
				max_insert = strstart + lookahead - MIN_MATCH;
				// Do not insert strings in hash table beyond this.

				// check_match(strstart-1, prev_match, prev_length);

				bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);

				// Insert in hash table all strings up to the end of the match.
				// strstart-1 and strstart are already inserted. If there is not
				// enough lookahead, the last two strings are not inserted in
				// the hash table.
				lookahead -= prev_length - 1;
				prev_length -= 2;
				do {
					if (++strstart <= max_insert) {
						ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
						// prev[strstart&w_mask]=hash_head=head[ins_h];
						hash_head = (head[ins_h] & 0xffff);
						prev[strstart & w_mask] = head[ins_h];
						head[ins_h] = strstart;
					}
				} while (--prev_length !== 0);
				match_available = 0;
				match_length = MIN_MATCH - 1;
				strstart++;

				if (bflush) {
					flush_block_only(false);
					if (strm.avail_out === 0)
						return NeedMore;
				}
			} else if (match_available !== 0) {

				// If there was no match at the previous position, output a
				// single literal. If there was a match but the current match
				// is longer, truncate the previous match to a single literal.

				bflush = _tr_tally(0, win[strstart - 1] & 0xff);

				if (bflush) {
					flush_block_only(false);
				}
				strstart++;
				lookahead--;
				if (strm.avail_out === 0)
					return NeedMore;
			} else {
				// There is no previous match to compare with, wait for
				// the next step to decide.

				match_available = 1;
				strstart++;
				lookahead--;
			}
		}

		if (match_available !== 0) {
			bflush = _tr_tally(0, win[strstart - 1] & 0xff);
			match_available = 0;
		}
		flush_block_only(flush == Z_FINISH$1);

		if (strm.avail_out === 0) {
			if (flush == Z_FINISH$1)
				return FinishStarted;
			else
				return NeedMore;
		}

		return flush == Z_FINISH$1 ? FinishDone : BlockDone;
	}

	function deflateReset(strm) {
		strm.total_in = strm.total_out = 0;
		strm.msg = null; //

		that.pending = 0;
		that.pending_out = 0;

		status = BUSY_STATE;

		last_flush = Z_NO_FLUSH$1;

		tr_init();
		lm_init();
		return Z_OK$1;
	}

	that.deflateInit = function (strm, _level, bits, _method, memLevel, _strategy) {
		if (!_method)
			_method = Z_DEFLATED$1;
		if (!memLevel)
			memLevel = DEF_MEM_LEVEL;
		if (!_strategy)
			_strategy = Z_DEFAULT_STRATEGY;

		// byte[] my_version=ZLIB_VERSION;

		//
		// if (!version || version[0] != my_version[0]
		// || stream_size != sizeof(z_stream)) {
		// return Z_VERSION_ERROR;
		// }

		strm.msg = null;

		if (_level == Z_DEFAULT_COMPRESSION)
			_level = 6;

		if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED$1 || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0
			|| _strategy > Z_HUFFMAN_ONLY) {
			return Z_STREAM_ERROR$1;
		}

		strm.dstate = that;

		w_bits = bits;
		w_size = 1 << w_bits;
		w_mask = w_size - 1;

		hash_bits = memLevel + 7;
		hash_size = 1 << hash_bits;
		hash_mask = hash_size - 1;
		hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);

		win = new Uint8Array(w_size * 2);
		prev = [];
		head = [];

		lit_bufsize = 1 << (memLevel + 6); // 16K elements by default

		that.pending_buf = new Uint8Array(lit_bufsize * 4);
		pending_buf_size = lit_bufsize * 4;

		that.dist_buf = new Uint16Array(lit_bufsize);
		that.lc_buf = new Uint8Array(lit_bufsize);

		level = _level;

		strategy = _strategy;

		return deflateReset(strm);
	};

	that.deflateEnd = function () {
		if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
			return Z_STREAM_ERROR$1;
		}
		// Deallocate in reverse order of allocations:
		that.lc_buf = null;
		that.dist_buf = null;
		that.pending_buf = null;
		head = null;
		prev = null;
		win = null;
		// free
		that.dstate = null;
		return status == BUSY_STATE ? Z_DATA_ERROR$1 : Z_OK$1;
	};

	that.deflateParams = function (strm, _level, _strategy) {
		let err = Z_OK$1;

		if (_level == Z_DEFAULT_COMPRESSION) {
			_level = 6;
		}
		if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
			return Z_STREAM_ERROR$1;
		}

		if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
			// Flush the last buffer:
			err = strm.deflate(Z_PARTIAL_FLUSH);
		}

		if (level != _level) {
			level = _level;
			max_lazy_match = config_table[level].max_lazy;
			good_match = config_table[level].good_length;
			nice_match = config_table[level].nice_length;
			max_chain_length = config_table[level].max_chain;
		}
		strategy = _strategy;
		return err;
	};

	that.deflateSetDictionary = function (_strm, dictionary, dictLength) {
		let length = dictLength;
		let n, index = 0;

		if (!dictionary || status != INIT_STATE)
			return Z_STREAM_ERROR$1;

		if (length < MIN_MATCH)
			return Z_OK$1;
		if (length > w_size - MIN_LOOKAHEAD) {
			length = w_size - MIN_LOOKAHEAD;
			index = dictLength - length; // use the tail of the dictionary
		}
		win.set(dictionary.subarray(index, index + length), 0);

		strstart = length;
		block_start = length;

		// Insert all strings in the hash table (except for the last two bytes).
		// s->lookahead stays null, so s->ins_h will be recomputed at the next
		// call of fill_window.

		ins_h = win[0] & 0xff;
		ins_h = (((ins_h) << hash_shift) ^ (win[1] & 0xff)) & hash_mask;

		for (n = 0; n <= length - MIN_MATCH; n++) {
			ins_h = (((ins_h) << hash_shift) ^ (win[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
			prev[n & w_mask] = head[ins_h];
			head[ins_h] = n;
		}
		return Z_OK$1;
	};

	that.deflate = function (_strm, flush) {
		let i, header, level_flags, old_flush, bstate;

		if (flush > Z_FINISH$1 || flush < 0) {
			return Z_STREAM_ERROR$1;
		}

		if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH$1)) {
			_strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_STREAM_ERROR$1)];
			return Z_STREAM_ERROR$1;
		}
		if (_strm.avail_out === 0) {
			_strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_BUF_ERROR$1)];
			return Z_BUF_ERROR$1;
		}

		strm = _strm; // just in case
		old_flush = last_flush;
		last_flush = flush;

		// Write the zlib header
		if (status == INIT_STATE) {
			header = (Z_DEFLATED$1 + ((w_bits - 8) << 4)) << 8;
			level_flags = ((level - 1) & 0xff) >> 1;

			if (level_flags > 3)
				level_flags = 3;
			header |= (level_flags << 6);
			if (strstart !== 0)
				header |= PRESET_DICT$1;
			header += 31 - (header % 31);

			status = BUSY_STATE;
			putShortMSB(header);
		}

		// Flush as much pending output as possible
		if (that.pending !== 0) {
			strm.flush_pending();
			if (strm.avail_out === 0) {
				// console.log(" avail_out==0");
				// Since avail_out is 0, deflate will be called again with
				// more output space, but possibly with both pending and
				// avail_in equal to zero. There won't be anything to do,
				// but this is not an error situation so make sure we
				// return OK instead of BUF_ERROR at next call of deflate:
				last_flush = -1;
				return Z_OK$1;
			}

			// Make sure there is something to do and avoid duplicate
			// consecutive
			// flushes. For repeated and useless calls with Z_FINISH, we keep
			// returning Z_STREAM_END instead of Z_BUFF_ERROR.
		} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH$1) {
			strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_BUF_ERROR$1)];
			return Z_BUF_ERROR$1;
		}

		// User must not provide more input after the first FINISH:
		if (status == FINISH_STATE && strm.avail_in !== 0) {
			_strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_BUF_ERROR$1)];
			return Z_BUF_ERROR$1;
		}

		// Start a new block or continue the current one.
		if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH$1 && status != FINISH_STATE)) {
			bstate = -1;
			switch (config_table[level].func) {
				case STORED$1:
					bstate = deflate_stored(flush);
					break;
				case FAST:
					bstate = deflate_fast(flush);
					break;
				case SLOW:
					bstate = deflate_slow(flush);
					break;
			}

			if (bstate == FinishStarted || bstate == FinishDone) {
				status = FINISH_STATE;
			}
			if (bstate == NeedMore || bstate == FinishStarted) {
				if (strm.avail_out === 0) {
					last_flush = -1; // avoid BUF_ERROR next call, see above
				}
				return Z_OK$1;
				// If flush != Z_NO_FLUSH && avail_out === 0, the next call
				// of deflate should use the same flush parameter to make sure
				// that the flush is complete. So we don't have to output an
				// empty block here, this will be done at next call. This also
				// ensures that for a very small output buffer, we emit at most
				// one empty block.
			}

			if (bstate == BlockDone) {
				if (flush == Z_PARTIAL_FLUSH) {
					_tr_align();
				} else { // FULL_FLUSH or SYNC_FLUSH
					_tr_stored_block(0, 0, false);
					// For a full flush, this empty block will be recognized
					// as a special marker by inflate_sync().
					if (flush == Z_FULL_FLUSH) {
						// state.head[s.hash_size-1]=0;
						for (i = 0; i < hash_size/*-1*/; i++)
							// forget history
							head[i] = 0;
					}
				}
				strm.flush_pending();
				if (strm.avail_out === 0) {
					last_flush = -1; // avoid BUF_ERROR at next call, see above
					return Z_OK$1;
				}
			}
		}

		if (flush != Z_FINISH$1)
			return Z_OK$1;
		return Z_STREAM_END$1;
	};
}

// ZStream

function ZStream$1() {
	const that = this;
	that.next_in_index = 0;
	that.next_out_index = 0;
	// that.next_in; // next input byte
	that.avail_in = 0; // number of bytes available at next_in
	that.total_in = 0; // total nb of input bytes read so far
	// that.next_out; // next output byte should be put there
	that.avail_out = 0; // remaining free space at next_out
	that.total_out = 0; // total nb of bytes output so far
	// that.msg;
	// that.dstate;
}

ZStream$1.prototype = {
	deflateInit(level, bits) {
		const that = this;
		that.dstate = new Deflate();
		if (!bits)
			bits = MAX_BITS$1;
		return that.dstate.deflateInit(that, level, bits);
	},

	deflate(flush) {
		const that = this;
		if (!that.dstate) {
			return Z_STREAM_ERROR$1;
		}
		return that.dstate.deflate(that, flush);
	},

	deflateEnd() {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$1;
		const ret = that.dstate.deflateEnd();
		that.dstate = null;
		return ret;
	},

	deflateParams(level, strategy) {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$1;
		return that.dstate.deflateParams(that, level, strategy);
	},

	deflateSetDictionary(dictionary, dictLength) {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$1;
		return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
	},

	// Read a new buffer from the current input stream, update the
	// total number of bytes read. All deflate() input goes through
	// this function so some applications may wish to modify it to avoid
	// allocating a large strm->next_in buffer and copying from it.
	// (See also flush_pending()).
	read_buf(buf, start, size) {
		const that = this;
		let len = that.avail_in;
		if (len > size)
			len = size;
		if (len === 0)
			return 0;
		that.avail_in -= len;
		buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
		that.next_in_index += len;
		that.total_in += len;
		return len;
	},

	// Flush as much pending output as possible. All deflate() output goes
	// through this function so some applications may wish to modify it
	// to avoid allocating a large strm->next_out buffer and copying into it.
	// (See also read_buf()).
	flush_pending() {
		const that = this;
		let len = that.dstate.pending;

		if (len > that.avail_out)
			len = that.avail_out;
		if (len === 0)
			return;

		// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index
		// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +
		// len)) {
		// console.log(that.dstate.pending_buf.length + ", " + that.dstate.pending_out + ", " + that.next_out.length + ", " +
		// that.next_out_index + ", " + len);
		// console.log("avail_out=" + that.avail_out);
		// }

		that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);

		that.next_out_index += len;
		that.dstate.pending_out += len;
		that.total_out += len;
		that.avail_out -= len;
		that.dstate.pending -= len;
		if (that.dstate.pending === 0) {
			that.dstate.pending_out = 0;
		}
	}
};

// Deflate

function ZipDeflate(options) {
	const that = this;
	const z = new ZStream$1();
	const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
	const flush = Z_NO_FLUSH$1;
	const buf = new Uint8Array(bufsize);
	let level = options ? options.level : Z_DEFAULT_COMPRESSION;
	if (typeof level == "undefined")
		level = Z_DEFAULT_COMPRESSION;
	z.deflateInit(level);
	z.next_out = buf;

	that.append = function (data, onprogress) {
		let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
		const buffers = [];
		if (!data.length)
			return;
		z.next_in_index = 0;
		z.next_in = data;
		z.avail_in = data.length;
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			err = z.deflate(flush);
			if (err != Z_OK$1)
				throw new Error("deflating: " + z.msg);
			if (z.next_out_index)
				if (z.next_out_index == bufsize)
					buffers.push(new Uint8Array(buf));
				else
					buffers.push(buf.subarray(0, z.next_out_index));
			bufferSize += z.next_out_index;
			if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
				onprogress(z.next_in_index);
				lastIndex = z.next_in_index;
			}
		} while (z.avail_in > 0 || z.avail_out === 0);
		if (buffers.length > 1) {
			array = new Uint8Array(bufferSize);
			buffers.forEach(function (chunk) {
				array.set(chunk, bufferIndex);
				bufferIndex += chunk.length;
			});
		} else {
			array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
		}
		return array;
	};
	that.flush = function () {
		let err, array, bufferIndex = 0, bufferSize = 0;
		const buffers = [];
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			err = z.deflate(Z_FINISH$1);
			if (err != Z_STREAM_END$1 && err != Z_OK$1)
				throw new Error("deflating: " + z.msg);
			if (bufsize - z.avail_out > 0)
				buffers.push(buf.slice(0, z.next_out_index));
			bufferSize += z.next_out_index;
		} while (z.avail_in > 0 || z.avail_out === 0);
		z.deflateEnd();
		array = new Uint8Array(bufferSize);
		buffers.forEach(function (chunk) {
			array.set(chunk, bufferIndex);
			bufferIndex += chunk.length;
		});
		return array;
	};
}

function getMaximumCompressedSize(uncompressedSize) {
	return uncompressedSize + (5 * (Math.floor(uncompressedSize / 16383) + 1));
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

// deno-lint-ignore-file no-this-alias prefer-const

// Global

const MAX_BITS = 15;

const Z_OK = 0;
const Z_STREAM_END = 1;
const Z_NEED_DICT = 2;
const Z_STREAM_ERROR = -2;
const Z_DATA_ERROR = -3;
const Z_MEM_ERROR = -4;
const Z_BUF_ERROR = -5;

const inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,
	0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];

const MANY = 1440;

// JZlib version : "1.0.2"
const Z_NO_FLUSH = 0;
const Z_FINISH = 4;

// InfTree
const fixed_bl = 9;
const fixed_bd = 5;

const fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,
	0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,
	0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,
	0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,
	0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,
	35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,
	26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,
	7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,
	8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,
	8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,
	0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,
	81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,
	0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,
	84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,
	0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,
	80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,
	0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,
	0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,
	0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,
	193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,
	120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,
	227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,
	92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,
	249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,
	130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,
	181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,
	102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,
	221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,
	8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,
	147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,
	85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,
	235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,
	141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,
	167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,
	107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,
	207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,
	127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255];
const fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,
	8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,
	24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577];

// Tables for deflate from PKZIP's appnote.txt.
const cplens = [ // Copy lengths for literal codes 257..285
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

// see note #13 above about 258
const cplext = [ // Extra bits for literal codes 257..285
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid
];

const cpdist = [ // Copy offsets for distance codes 0..29
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];

const cpdext = [ // Extra bits for distance codes
	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

// If BMAX needs to be larger than 16, then h and x[] should be uLong.
const BMAX = 15; // maximum bit length of any code

function InfTree() {
	const that = this;

	let hn; // hufts used in space
	let v; // work area for huft_build
	let c; // bit length count table
	let r; // table entry for structure assignment
	let u; // table stack
	let x; // bit offsets, then code stack

	function huft_build(b, // code lengths in bits (all assumed <=
		// BMAX)
		bindex, n, // number of codes (assumed <= 288)
		s, // number of simple-valued codes (0..s-1)
		d, // list of base values for non-simple codes
		e, // list of extra bits for non-simple codes
		t, // result: starting table
		m, // maximum lookup bits, returns actual
		hp,// space for trees
		hn,// hufts used in space
		v // working area: values in order of bit length
	) {
		// Given a list of code lengths and a maximum table size, make a set of
		// tables to decode that set of codes. Return Z_OK on success,
		// Z_BUF_ERROR
		// if the given code set is incomplete (the tables are still built in
		// this
		// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set
		// of
		// lengths), or Z_MEM_ERROR if not enough memory.

		let a; // counter for codes of length k
		let f; // i repeats in table every f entries
		let g; // maximum code length
		let h; // table level
		let i; // counter, current code
		let j; // counter
		let k; // number of bits in current code
		let l; // bits per table (returned in m)
		let mask; // (1 << w) - 1, to avoid cc -O bug on HP
		let p; // pointer into c[], b[], or v[]
		let q; // points to current table
		let w; // bits before this table == (l * h)
		let xp; // pointer into x
		let y; // number of dummy codes added
		let z; // number of entries in current table

		// Generate counts for each bit length

		p = 0;
		i = n;
		do {
			c[b[bindex + p]]++;
			p++;
			i--; // assume all entries <= BMAX
		} while (i !== 0);

		if (c[0] == n) { // null input--all zero length codes
			t[0] = -1;
			m[0] = 0;
			return Z_OK;
		}

		// Find minimum and maximum length, bound *m by those
		l = m[0];
		for (j = 1; j <= BMAX; j++)
			if (c[j] !== 0)
				break;
		k = j; // minimum code length
		if (l < j) {
			l = j;
		}
		for (i = BMAX; i !== 0; i--) {
			if (c[i] !== 0)
				break;
		}
		g = i; // maximum code length
		if (l > i) {
			l = i;
		}
		m[0] = l;

		// Adjust last length count to fill out codes, if needed
		for (y = 1 << j; j < i; j++, y <<= 1) {
			if ((y -= c[j]) < 0) {
				return Z_DATA_ERROR;
			}
		}
		if ((y -= c[i]) < 0) {
			return Z_DATA_ERROR;
		}
		c[i] += y;

		// Generate starting offsets into the value table for each length
		x[1] = j = 0;
		p = 1;
		xp = 2;
		while (--i !== 0) { // note that i == g from above
			x[xp] = (j += c[p]);
			xp++;
			p++;
		}

		// Make a table of values in order of bit lengths
		i = 0;
		p = 0;
		do {
			if ((j = b[bindex + p]) !== 0) {
				v[x[j]++] = i;
			}
			p++;
		} while (++i < n);
		n = x[g]; // set n to length of v

		// Generate the Huffman codes and for each, make the table entries
		x[0] = i = 0; // first Huffman code is zero
		p = 0; // grab values in bit order
		h = -1; // no tables yet--level -1
		w = -l; // bits decoded == (l * h)
		u[0] = 0; // just to keep compilers happy
		q = 0; // ditto
		z = 0; // ditto

		// go through the bit lengths (k already is bits in shortest code)
		for (; k <= g; k++) {
			a = c[k];
			while (a-- !== 0) {
				// here i is the Huffman code of length k bits for value *p
				// make tables up to required level
				while (k > w + l) {
					h++;
					w += l; // previous table always l bits
					// compute minimum size table less than or equal to l bits
					z = g - w;
					z = (z > l) ? l : z; // table size upper limit
					if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
						// too few codes for
						// k-w bit table
						f -= a + 1; // deduct codes from patterns left
						xp = k;
						if (j < z) {
							while (++j < z) { // try smaller tables up to z bits
								if ((f <<= 1) <= c[++xp])
									break; // enough codes to use up j bits
								f -= c[xp]; // else deduct codes from patterns
							}
						}
					}
					z = 1 << j; // table entries for j-bit table

					// allocate new table
					if (hn[0] + z > MANY) { // (note: doesn't matter for fixed)
						return Z_DATA_ERROR; // overflow of MANY
					}
					u[h] = q = /* hp+ */hn[0]; // DEBUG
					hn[0] += z;

					// connect to last table, if there is one
					if (h !== 0) {
						x[h] = i; // save pattern for backing up
						r[0] = /* (byte) */j; // bits in this table
						r[1] = /* (byte) */l; // bits to dump before this table
						j = i >>> (w - l);
						r[2] = /* (int) */(q - u[h - 1] - j); // offset to this table
						hp.set(r, (u[h - 1] + j) * 3);
						// to
						// last
						// table
					} else {
						t[0] = q; // first table is returned result
					}
				}

				// set up table entry in r
				r[1] = /* (byte) */(k - w);
				if (p >= n) {
					r[0] = 128 + 64; // out of values--invalid code
				} else if (v[p] < s) {
					r[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is
					// end-of-block
					r[2] = v[p++]; // simple code is just the value
				} else {
					r[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look
					// up in lists
					r[2] = d[v[p++] - s];
				}

				// fill code-like entries with r
				f = 1 << (k - w);
				for (j = i >>> w; j < z; j += f) {
					hp.set(r, (q + j) * 3);
				}

				// backwards increment the k-bit code i
				for (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {
					i ^= j;
				}
				i ^= j;

				// backup over finished tables
				mask = (1 << w) - 1; // needed on HP, cc -O bug
				while ((i & mask) != x[h]) {
					h--; // don't need to update q
					w -= l;
					mask = (1 << w) - 1;
				}
			}
		}
		// Return Z_BUF_ERROR if we were given an incomplete table
		return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
	}

	function initWorkArea(vsize) {
		let i;
		if (!hn) {
			hn = []; // []; //new Array(1);
			v = []; // new Array(vsize);
			c = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
			r = []; // new Array(3);
			u = new Int32Array(BMAX); // new Array(BMAX);
			x = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
		}
		if (v.length < vsize) {
			v = []; // new Array(vsize);
		}
		for (i = 0; i < vsize; i++) {
			v[i] = 0;
		}
		for (i = 0; i < BMAX + 1; i++) {
			c[i] = 0;
		}
		for (i = 0; i < 3; i++) {
			r[i] = 0;
		}
		// for(int i=0; i<BMAX; i++){u[i]=0;}
		u.set(c.subarray(0, BMAX), 0);
		// for(int i=0; i<BMAX+1; i++){x[i]=0;}
		x.set(c.subarray(0, BMAX + 1), 0);
	}

	that.inflate_trees_bits = function (c, // 19 code lengths
		bb, // bits tree desired/actual depth
		tb, // bits tree result
		hp, // space for trees
		z // for messages
	) {
		let result;
		initWorkArea(19);
		hn[0] = 0;
		result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);

		if (result == Z_DATA_ERROR) {
			z.msg = "oversubscribed dynamic bit lengths tree";
		} else if (result == Z_BUF_ERROR || bb[0] === 0) {
			z.msg = "incomplete dynamic bit lengths tree";
			result = Z_DATA_ERROR;
		}
		return result;
	};

	that.inflate_trees_dynamic = function (nl, // number of literal/length codes
		nd, // number of distance codes
		c, // that many (total) code lengths
		bl, // literal desired/actual bit depth
		bd, // distance desired/actual bit depth
		tl, // literal/length tree result
		td, // distance tree result
		hp, // space for trees
		z // for messages
	) {
		let result;

		// build literal/length tree
		initWorkArea(288);
		hn[0] = 0;
		result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
		if (result != Z_OK || bl[0] === 0) {
			if (result == Z_DATA_ERROR) {
				z.msg = "oversubscribed literal/length tree";
			} else if (result != Z_MEM_ERROR) {
				z.msg = "incomplete literal/length tree";
				result = Z_DATA_ERROR;
			}
			return result;
		}

		// build distance tree
		initWorkArea(288);
		result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);

		if (result != Z_OK || (bd[0] === 0 && nl > 257)) {
			if (result == Z_DATA_ERROR) {
				z.msg = "oversubscribed distance tree";
			} else if (result == Z_BUF_ERROR) {
				z.msg = "incomplete distance tree";
				result = Z_DATA_ERROR;
			} else if (result != Z_MEM_ERROR) {
				z.msg = "empty distance tree with lengths";
				result = Z_DATA_ERROR;
			}
			return result;
		}

		return Z_OK;
	};

}

InfTree.inflate_trees_fixed = function (bl, // literal desired/actual bit depth
	bd, // distance desired/actual bit depth
	tl,// literal/length tree result
	td// distance tree result
) {
	bl[0] = fixed_bl;
	bd[0] = fixed_bd;
	tl[0] = fixed_tl;
	td[0] = fixed_td;
	return Z_OK;
};

// InfCodes

// waiting for "i:"=input,
// "o:"=output,
// "x:"=nothing
const START = 0; // x: set up for LEN
const LEN = 1; // i: get length/literal/eob next
const LENEXT = 2; // i: getting length extra (have base)
const DIST = 3; // i: get distance next
const DISTEXT = 4;// i: getting distance extra
const COPY = 5; // o: copying bytes in win, waiting
// for space
const LIT = 6; // o: got literal, waiting for output
// space
const WASH = 7; // o: got eob, possibly still output
// waiting
const END = 8; // x: got eob and all data flushed
const BADCODE = 9;// x: got error

function InfCodes() {
	const that = this;

	let mode; // current inflate_codes mode

	// mode dependent information
	let len = 0;

	let tree; // pointer into tree
	let tree_index = 0;
	let need = 0; // bits needed

	let lit = 0;

	// if EXT or COPY, where and how much
	let get = 0; // bits to get for extra
	let dist = 0; // distance back to copy from

	let lbits = 0; // ltree bits decoded per branch
	let dbits = 0; // dtree bits decoder per branch
	let ltree; // literal/length/eob tree
	let ltree_index = 0; // literal/length/eob tree
	let dtree; // distance tree
	let dtree_index = 0; // distance tree

	// Called with number of bytes left to write in win at least 258
	// (the maximum string length) and number of input bytes available
	// at least ten. The ten bytes are six bytes for the longest length/
	// distance pair plus four bytes for overloading the bit buffer.

	function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
		let t; // temporary pointer
		let tp; // temporary pointer
		let tp_index; // temporary pointer
		let e; // extra bits or operation
		let b; // bit buffer
		let k; // bits in bit buffer
		let p; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer
		let ml; // mask for literal/length tree
		let md; // mask for distance tree
		let c; // bytes to copy
		let d; // distance back to copy from
		let r; // copy source pointer

		let tp_index_t_3; // (tp_index+t)*3

		// load input, output, bit values
		p = z.next_in_index;
		n = z.avail_in;
		b = s.bitb;
		k = s.bitk;
		q = s.write;
		m = q < s.read ? s.read - q - 1 : s.end - q;

		// initialize masks
		ml = inflate_mask[bl];
		md = inflate_mask[bd];

		// do until not enough input or output space for fast loop
		do { // assume called with m >= 258 && n >= 10
			// get literal/length code
			while (k < (20)) { // max bits for literal/length code
				n--;
				b |= (z.read_byte(p++) & 0xff) << k;
				k += 8;
			}

			t = b & ml;
			tp = tl;
			tp_index = tl_index;
			tp_index_t_3 = (tp_index + t) * 3;
			if ((e = tp[tp_index_t_3]) === 0) {
				b >>= (tp[tp_index_t_3 + 1]);
				k -= (tp[tp_index_t_3 + 1]);

				s.win[q++] = /* (byte) */tp[tp_index_t_3 + 2];
				m--;
				continue;
			}
			do {

				b >>= (tp[tp_index_t_3 + 1]);
				k -= (tp[tp_index_t_3 + 1]);

				if ((e & 16) !== 0) {
					e &= 15;
					c = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);

					b >>= e;
					k -= e;

					// decode distance base of block to copy
					while (k < (15)) { // max bits for distance code
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					t = b & md;
					tp = td;
					tp_index = td_index;
					tp_index_t_3 = (tp_index + t) * 3;
					e = tp[tp_index_t_3];

					do {

						b >>= (tp[tp_index_t_3 + 1]);
						k -= (tp[tp_index_t_3 + 1]);

						if ((e & 16) !== 0) {
							// get extra bits to add to distance base
							e &= 15;
							while (k < (e)) { // get extra bits (up to 13)
								n--;
								b |= (z.read_byte(p++) & 0xff) << k;
								k += 8;
							}

							d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);

							b >>= (e);
							k -= (e);

							// do the copy
							m -= c;
							if (q >= d) { // offset before dest
								// just copy
								r = q - d;
								if (q - r > 0 && 2 > (q - r)) {
									s.win[q++] = s.win[r++]; // minimum
									// count is
									// three,
									s.win[q++] = s.win[r++]; // so unroll
									// loop a
									// little
									c -= 2;
								} else {
									s.win.set(s.win.subarray(r, r + 2), q);
									q += 2;
									r += 2;
									c -= 2;
								}
							} else { // else offset after destination
								r = q - d;
								do {
									r += s.end; // force pointer in win
								} while (r < 0); // covers invalid distances
								e = s.end - r;
								if (c > e) { // if source crosses,
									c -= e; // wrapped copy
									if (q - r > 0 && e > (q - r)) {
										do {
											s.win[q++] = s.win[r++];
										} while (--e !== 0);
									} else {
										s.win.set(s.win.subarray(r, r + e), q);
										q += e;
										r += e;
										e = 0;
									}
									r = 0; // copy rest from start of win
								}

							}

							// copy all or what's left
							if (q - r > 0 && c > (q - r)) {
								do {
									s.win[q++] = s.win[r++];
								} while (--c !== 0);
							} else {
								s.win.set(s.win.subarray(r, r + c), q);
								q += c;
								r += c;
								c = 0;
							}
							break;
						} else if ((e & 64) === 0) {
							t += tp[tp_index_t_3 + 2];
							t += (b & inflate_mask[e]);
							tp_index_t_3 = (tp_index + t) * 3;
							e = tp[tp_index_t_3];
						} else {
							z.msg = "invalid distance code";

							c = z.avail_in - n;
							c = (k >> 3) < c ? k >> 3 : c;
							n += c;
							p -= c;
							k -= c << 3;

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;

							return Z_DATA_ERROR;
						}
						// eslint-disable-next-line no-constant-condition
					} while (true);
					break;
				}

				if ((e & 64) === 0) {
					t += tp[tp_index_t_3 + 2];
					t += (b & inflate_mask[e]);
					tp_index_t_3 = (tp_index + t) * 3;
					if ((e = tp[tp_index_t_3]) === 0) {

						b >>= (tp[tp_index_t_3 + 1]);
						k -= (tp[tp_index_t_3 + 1]);

						s.win[q++] = /* (byte) */tp[tp_index_t_3 + 2];
						m--;
						break;
					}
				} else if ((e & 32) !== 0) {

					c = z.avail_in - n;
					c = (k >> 3) < c ? k >> 3 : c;
					n += c;
					p -= c;
					k -= c << 3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;

					return Z_STREAM_END;
				} else {
					z.msg = "invalid literal/length code";

					c = z.avail_in - n;
					c = (k >> 3) < c ? k >> 3 : c;
					n += c;
					p -= c;
					k -= c << 3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;

					return Z_DATA_ERROR;
				}
				// eslint-disable-next-line no-constant-condition
			} while (true);
		} while (m >= 258 && n >= 10);

		// not enough input or output--restore pointers and return
		c = z.avail_in - n;
		c = (k >> 3) < c ? k >> 3 : c;
		n += c;
		p -= c;
		k -= c << 3;

		s.bitb = b;
		s.bitk = k;
		z.avail_in = n;
		z.total_in += p - z.next_in_index;
		z.next_in_index = p;
		s.write = q;

		return Z_OK;
	}

	that.init = function (bl, bd, tl, tl_index, td, td_index) {
		mode = START;
		lbits = /* (byte) */bl;
		dbits = /* (byte) */bd;
		ltree = tl;
		ltree_index = tl_index;
		dtree = td;
		dtree_index = td_index;
		tree = null;
	};

	that.proc = function (s, z, r) {
		let j; // temporary storage
		let tindex; // temporary pointer
		let e; // extra bits or operation
		let b = 0; // bit buffer
		let k = 0; // bits in bit buffer
		let p = 0; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer
		let f; // pointer to copy strings from

		// copy input/output information to locals (UPDATE macro restores)
		p = z.next_in_index;
		n = z.avail_in;
		b = s.bitb;
		k = s.bitk;
		q = s.write;
		m = q < s.read ? s.read - q - 1 : s.end - q;

		// process input and output based on current state
		// eslint-disable-next-line no-constant-condition
		while (true) {
			switch (mode) {
				// waiting for "i:"=input, "o:"=output, "x:"=nothing
				case START: // x: set up for LEN
					if (m >= 258 && n >= 10) {

						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);

						p = z.next_in_index;
						n = z.avail_in;
						b = s.bitb;
						k = s.bitk;
						q = s.write;
						m = q < s.read ? s.read - q - 1 : s.end - q;

						if (r != Z_OK) {
							mode = r == Z_STREAM_END ? WASH : BADCODE;
							break;
						}
					}
					need = lbits;
					tree = ltree;
					tree_index = ltree_index;

					mode = LEN;
				/* falls through */
				case LEN: // i: get length/literal/eob next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>>= (tree[tindex + 1]);
					k -= (tree[tindex + 1]);

					e = tree[tindex];

					if (e === 0) { // literal
						lit = tree[tindex + 2];
						mode = LIT;
						break;
					}
					if ((e & 16) !== 0) { // length
						get = e & 15;
						len = tree[tindex + 2];
						mode = LENEXT;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					if ((e & 32) !== 0) { // end of block
						mode = WASH;
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid literal/length code";
					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case LENEXT: // i: getting length extra (have base)
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					len += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					need = dbits;
					tree = dtree;
					tree_index = dtree_index;
					mode = DIST;
				/* falls through */
				case DIST: // i: get distance next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>= tree[tindex + 1];
					k -= tree[tindex + 1];

					e = (tree[tindex]);
					if ((e & 16) !== 0) { // distance
						get = e & 15;
						dist = tree[tindex + 2];
						mode = DISTEXT;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid distance code";
					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case DISTEXT: // i: getting distance extra
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					dist += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					mode = COPY;
				/* falls through */
				case COPY: // o: copying bytes in win, waiting for space
					f = q - dist;
					while (f < 0) { // modulo win size-"while" instead
						f += s.end; // of "if" handles invalid distances
					}
					while (len !== 0) {

						if (m === 0) {
							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.write = q;
								r = s.inflate_flush(z, r);
								q = s.write;
								m = q < s.read ? s.read - q - 1 : s.end - q;

								if (q == s.end && s.read !== 0) {
									q = 0;
									m = q < s.read ? s.read - q - 1 : s.end - q;
								}

								if (m === 0) {
									s.bitb = b;
									s.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									s.write = q;
									return s.inflate_flush(z, r);
								}
							}
						}

						s.win[q++] = s.win[f++];
						m--;

						if (f == s.end)
							f = 0;
						len--;
					}
					mode = START;
					break;
				case LIT: // o: got literal, waiting for output space
					if (m === 0) {
						if (q == s.end && s.read !== 0) {
							q = 0;
							m = q < s.read ? s.read - q - 1 : s.end - q;
						}
						if (m === 0) {
							s.write = q;
							r = s.inflate_flush(z, r);
							q = s.write;
							m = q < s.read ? s.read - q - 1 : s.end - q;

							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.bitb = b;
								s.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								s.write = q;
								return s.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK;

					s.win[q++] = /* (byte) */lit;
					m--;

					mode = START;
					break;
				case WASH: // o: got eob, possibly more output
					if (k > 7) { // return unused byte, if any
						k -= 8;
						n++;
						p--; // can always return one
					}

					s.write = q;
					r = s.inflate_flush(z, r);
					q = s.write;
					m = q < s.read ? s.read - q - 1 : s.end - q;

					if (s.read != s.write) {
						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						return s.inflate_flush(z, r);
					}
					mode = END;
				/* falls through */
				case END:
					r = Z_STREAM_END;
					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case BADCODE: // x: got error

					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);
			}
		}
	};

	that.free = function () {
		// ZFREE(z, c);
	};

}

// InfBlocks

// Table for deflate from PKZIP's appnote.txt.
const border = [ // Order of the bit length code lengths
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

const TYPE = 0; // get type bits (3, including end bit)
const LENS = 1; // get lengths for stored
const STORED = 2;// processing stored block
const TABLE = 3; // get table lengths
const BTREE = 4; // get bit lengths tree for a dynamic
// block
const DTREE = 5; // get length, distance trees for a
// dynamic block
const CODES = 6; // processing fixed or dynamic block
const DRY = 7; // output remaining win bytes
const DONELOCKS = 8; // finished last block, done
const BADBLOCKS = 9; // ot a data error--stuck here

function InfBlocks(z, w) {
	const that = this;

	let mode = TYPE; // current inflate_block mode

	let left = 0; // if STORED, bytes left to copy

	let table = 0; // table lengths (14 bits)
	let index = 0; // index into blens (or border)
	let blens; // bit lengths of codes
	const bb = [0]; // bit length tree depth
	const tb = [0]; // bit length decoding tree

	const codes = new InfCodes(); // if CODES, current state

	let last = 0; // true if this block is the last block

	let hufts = new Int32Array(MANY * 3); // single malloc for tree space
	const check = 0; // check on output
	const inftree = new InfTree();

	that.bitk = 0; // bits in bit buffer
	that.bitb = 0; // bit buffer
	that.win = new Uint8Array(w); // sliding win
	that.end = w; // one byte after sliding win
	that.read = 0; // win read pointer
	that.write = 0; // win write pointer

	that.reset = function (z, c) {
		if (c)
			c[0] = check;
		// if (mode == BTREE || mode == DTREE) {
		// }
		if (mode == CODES) {
			codes.free(z);
		}
		mode = TYPE;
		that.bitk = 0;
		that.bitb = 0;
		that.read = that.write = 0;
	};

	that.reset(z, null);

	// copy as much as possible from the sliding win to the output area
	that.inflate_flush = function (z, r) {
		let n;
		let p;
		let q;

		// local copies of source and destination pointers
		p = z.next_out_index;
		q = that.read;

		// compute number of bytes to copy as far as end of win
		n = /* (int) */((q <= that.write ? that.write : that.end) - q);
		if (n > z.avail_out)
			n = z.avail_out;
		if (n !== 0 && r == Z_BUF_ERROR)
			r = Z_OK;

		// update counters
		z.avail_out -= n;
		z.total_out += n;

		// copy as far as end of win
		z.next_out.set(that.win.subarray(q, q + n), p);
		p += n;
		q += n;

		// see if more to copy at beginning of win
		if (q == that.end) {
			// wrap pointers
			q = 0;
			if (that.write == that.end)
				that.write = 0;

			// compute bytes to copy
			n = that.write - q;
			if (n > z.avail_out)
				n = z.avail_out;
			if (n !== 0 && r == Z_BUF_ERROR)
				r = Z_OK;

			// update counters
			z.avail_out -= n;
			z.total_out += n;

			// copy
			z.next_out.set(that.win.subarray(q, q + n), p);
			p += n;
			q += n;
		}

		// update pointers
		z.next_out_index = p;
		that.read = q;

		// done
		return r;
	};

	that.proc = function (z, r) {
		let t; // temporary storage
		let b; // bit buffer
		let k; // bits in bit buffer
		let p; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer

		let i;

		// copy input/output information to locals (UPDATE macro restores)
		// {
		p = z.next_in_index;
		n = z.avail_in;
		b = that.bitb;
		k = that.bitk;
		// }
		// {
		q = that.write;
		m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
		// }

		// process input based on current state
		// DEBUG dtree
		// eslint-disable-next-line no-constant-condition
		while (true) {
			let bl, bd, tl, td, bl_, bd_, tl_, td_;
			switch (mode) {
				case TYPE:

					while (k < (3)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}
					t = /* (int) */(b & 7);
					last = t & 1;

					switch (t >>> 1) {
						case 0: // stored
							// {
							b >>>= (3);
							k -= (3);
							// }
							t = k & 7; // go to byte boundary

							// {
							b >>>= (t);
							k -= (t);
							// }
							mode = LENS; // get length of stored block
							break;
						case 1: // fixed
							// {
							bl = []; // new Array(1);
							bd = []; // new Array(1);
							tl = [[]]; // new Array(1);
							td = [[]]; // new Array(1);

							InfTree.inflate_trees_fixed(bl, bd, tl, td);
							codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
							// }

							// {
							b >>>= (3);
							k -= (3);
							// }

							mode = CODES;
							break;
						case 2: // dynamic

							// {
							b >>>= (3);
							k -= (3);
							// }

							mode = TABLE;
							break;
						case 3: // illegal

							// {
							b >>>= (3);
							k -= (3);
							// }
							mode = BADBLOCKS;
							z.msg = "invalid block type";
							r = Z_DATA_ERROR;

							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
					}
					break;
				case LENS:

					while (k < (32)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {
						mode = BADBLOCKS;
						z.msg = "invalid stored block lengths";
						r = Z_DATA_ERROR;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					left = (b & 0xffff);
					b = k = 0; // dump bits
					mode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);
					break;
				case STORED:
					if (n === 0) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					if (m === 0) {
						if (q == that.end && that.read !== 0) {
							q = 0;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
						}
						if (m === 0) {
							that.write = q;
							r = that.inflate_flush(z, r);
							q = that.write;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							if (q == that.end && that.read !== 0) {
								q = 0;
								m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							}
							if (m === 0) {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK;

					t = left;
					if (t > n)
						t = n;
					if (t > m)
						t = m;
					that.win.set(z.read_buf(p, t), q);
					p += t;
					n -= t;
					q += t;
					m -= t;
					if ((left -= t) !== 0)
						break;
					mode = last !== 0 ? DRY : TYPE;
					break;
				case TABLE:

					while (k < (14)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}

						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					table = t = (b & 0x3fff);
					if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {
						mode = BADBLOCKS;
						z.msg = "too many length or distance symbols";
						r = Z_DATA_ERROR;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
					if (!blens || blens.length < t) {
						blens = []; // new Array(t);
					} else {
						for (i = 0; i < t; i++) {
							blens[i] = 0;
						}
					}

					// {
					b >>>= (14);
					k -= (14);
					// }

					index = 0;
					mode = BTREE;
				/* falls through */
				case BTREE:
					while (index < 4 + (table >>> 10)) {
						while (k < (3)) {
							if (n !== 0) {
								r = Z_OK;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						blens[border[index++]] = b & 7;

						// {
						b >>>= (3);
						k -= (3);
						// }
					}

					while (index < 19) {
						blens[border[index++]] = 0;
					}

					bb[0] = 7;
					t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
					if (t != Z_OK) {
						r = t;
						if (r == Z_DATA_ERROR) {
							blens = null;
							mode = BADBLOCKS;
						}

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					index = 0;
					mode = DTREE;
				/* falls through */
				case DTREE:
					// eslint-disable-next-line no-constant-condition
					while (true) {
						t = table;
						if (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {
							break;
						}

						let j, c;

						t = bb[0];

						while (k < (t)) {
							if (n !== 0) {
								r = Z_OK;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						// if (tb[0] == -1) {
						// System.err.println("null...");
						// }

						t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
						c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];

						if (c < 16) {
							b >>>= (t);
							k -= (t);
							blens[index++] = c;
						} else { // c == 16..18
							i = c == 18 ? 7 : c - 14;
							j = c == 18 ? 11 : 3;

							while (k < (t + i)) {
								if (n !== 0) {
									r = Z_OK;
								} else {
									that.bitb = b;
									that.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									that.write = q;
									return that.inflate_flush(z, r);
								}
								n--;
								b |= (z.read_byte(p++) & 0xff) << k;
								k += 8;
							}

							b >>>= (t);
							k -= (t);

							j += (b & inflate_mask[i]);

							b >>>= (i);
							k -= (i);

							i = index;
							t = table;
							if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {
								blens = null;
								mode = BADBLOCKS;
								z.msg = "invalid bit length repeat";
								r = Z_DATA_ERROR;

								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}

							c = c == 16 ? blens[i - 1] : 0;
							do {
								blens[i++] = c;
							} while (--j !== 0);
							index = i;
						}
					}

					tb[0] = -1;
					// {
					bl_ = []; // new Array(1);
					bd_ = []; // new Array(1);
					tl_ = []; // new Array(1);
					td_ = []; // new Array(1);
					bl_[0] = 9; // must be <= 9 for lookahead assumptions
					bd_[0] = 6; // must be <= 9 for lookahead assumptions

					t = table;
					t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);

					if (t != Z_OK) {
						if (t == Z_DATA_ERROR) {
							blens = null;
							mode = BADBLOCKS;
						}
						r = t;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
					// }
					mode = CODES;
				/* falls through */
				case CODES:
					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;

					if ((r = codes.proc(that, z, r)) != Z_STREAM_END) {
						return that.inflate_flush(z, r);
					}
					r = Z_OK;
					codes.free(z);

					p = z.next_in_index;
					n = z.avail_in;
					b = that.bitb;
					k = that.bitk;
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);

					if (last === 0) {
						mode = TYPE;
						break;
					}
					mode = DRY;
				/* falls through */
				case DRY:
					that.write = q;
					r = that.inflate_flush(z, r);
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
					if (that.read != that.write) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					mode = DONELOCKS;
				/* falls through */
				case DONELOCKS:
					r = Z_STREAM_END;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
				case BADBLOCKS:
					r = Z_DATA_ERROR;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
			}
		}
	};

	that.free = function (z) {
		that.reset(z, null);
		that.win = null;
		hufts = null;
		// ZFREE(z, s);
	};

	that.set_dictionary = function (d, start, n) {
		that.win.set(d.subarray(start, start + n), 0);
		that.read = that.write = n;
	};

	// Returns true if inflate is currently at the end of a block generated
	// by Z_SYNC_FLUSH or Z_FULL_FLUSH.
	that.sync_point = function () {
		return mode == LENS ? 1 : 0;
	};

}

// Inflate

// preset dictionary flag in zlib header
const PRESET_DICT = 0x20;

const Z_DEFLATED = 8;

const METHOD = 0; // waiting for method byte
const FLAG = 1; // waiting for flag byte
const DICT4 = 2; // four dictionary check bytes to go
const DICT3 = 3; // three dictionary check bytes to go
const DICT2 = 4; // two dictionary check bytes to go
const DICT1 = 5; // one dictionary check byte to go
const DICT0 = 6; // waiting for inflateSetDictionary
const BLOCKS = 7; // decompressing blocks
const DONE = 12; // finished check, done
const BAD = 13; // got an error--stay here

const mark = [0, 0, 0xff, 0xff];

function Inflate() {
	const that = this;

	that.mode = 0; // current inflate mode

	// mode dependent information
	that.method = 0; // if FLAGS, method byte

	// if CHECK, check values to compare
	that.was = [0]; // new Array(1); // computed check value
	that.need = 0; // stream check value

	// if BAD, inflateSync's marker bytes count
	that.marker = 0;

	// mode independent information
	that.wbits = 0; // log2(win size) (8..15, defaults to 15)

	// this.blocks; // current inflate_blocks state

	function inflateReset(z) {
		if (!z || !z.istate)
			return Z_STREAM_ERROR;

		z.total_in = z.total_out = 0;
		z.msg = null;
		z.istate.mode = BLOCKS;
		z.istate.blocks.reset(z, null);
		return Z_OK;
	}

	that.inflateEnd = function (z) {
		if (that.blocks)
			that.blocks.free(z);
		that.blocks = null;
		// ZFREE(z, z->state);
		return Z_OK;
	};

	that.inflateInit = function (z, w) {
		z.msg = null;
		that.blocks = null;

		// set win size
		if (w < 8 || w > 15) {
			that.inflateEnd(z);
			return Z_STREAM_ERROR;
		}
		that.wbits = w;

		z.istate.blocks = new InfBlocks(z, 1 << w);

		// reset state
		inflateReset(z);
		return Z_OK;
	};

	that.inflate = function (z, f) {
		let r;
		let b;

		if (!z || !z.istate || !z.next_in)
			return Z_STREAM_ERROR;
		const istate = z.istate;
		f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
		r = Z_BUF_ERROR;
		// eslint-disable-next-line no-constant-condition
		while (true) {
			switch (istate.mode) {
				case METHOD:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					if (((istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {
						istate.mode = BAD;
						z.msg = "unknown compression method";
						istate.marker = 5; // can't try inflateSync
						break;
					}
					if ((istate.method >> 4) + 8 > istate.wbits) {
						istate.mode = BAD;
						z.msg = "invalid win size";
						istate.marker = 5; // can't try inflateSync
						break;
					}
					istate.mode = FLAG;
				/* falls through */
				case FLAG:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					b = (z.read_byte(z.next_in_index++)) & 0xff;

					if ((((istate.method << 8) + b) % 31) !== 0) {
						istate.mode = BAD;
						z.msg = "incorrect header check";
						istate.marker = 5; // can't try inflateSync
						break;
					}

					if ((b & PRESET_DICT) === 0) {
						istate.mode = BLOCKS;
						break;
					}
					istate.mode = DICT4;
				/* falls through */
				case DICT4:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;
					istate.mode = DICT3;
				/* falls through */
				case DICT3:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;
					istate.mode = DICT2;
				/* falls through */
				case DICT2:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;
					istate.mode = DICT1;
				/* falls through */
				case DICT1:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += (z.read_byte(z.next_in_index++) & 0xff);
					istate.mode = DICT0;
					return Z_NEED_DICT;
				case DICT0:
					istate.mode = BAD;
					z.msg = "need dictionary";
					istate.marker = 0; // can try inflateSync
					return Z_STREAM_ERROR;
				case BLOCKS:

					r = istate.blocks.proc(z, r);
					if (r == Z_DATA_ERROR) {
						istate.mode = BAD;
						istate.marker = 0; // can try inflateSync
						break;
					}
					if (r == Z_OK) {
						r = f;
					}
					if (r != Z_STREAM_END) {
						return r;
					}
					r = f;
					istate.blocks.reset(z, istate.was);
					istate.mode = DONE;
				/* falls through */
				case DONE:
					z.avail_in = 0;
					return Z_STREAM_END;
				case BAD:
					return Z_DATA_ERROR;
				default:
					return Z_STREAM_ERROR;
			}
		}
	};

	that.inflateSetDictionary = function (z, dictionary, dictLength) {
		let index = 0, length = dictLength;
		if (!z || !z.istate || z.istate.mode != DICT0)
			return Z_STREAM_ERROR;
		const istate = z.istate;
		if (length >= (1 << istate.wbits)) {
			length = (1 << istate.wbits) - 1;
			index = dictLength - length;
		}
		istate.blocks.set_dictionary(dictionary, index, length);
		istate.mode = BLOCKS;
		return Z_OK;
	};

	that.inflateSync = function (z) {
		let n; // number of bytes to look at
		let p; // pointer to bytes
		let m; // number of marker bytes found in a row
		let r, w; // temporaries to save total_in and total_out

		// set up
		if (!z || !z.istate)
			return Z_STREAM_ERROR;
		const istate = z.istate;
		if (istate.mode != BAD) {
			istate.mode = BAD;
			istate.marker = 0;
		}
		if ((n = z.avail_in) === 0)
			return Z_BUF_ERROR;
		p = z.next_in_index;
		m = istate.marker;

		// search
		while (n !== 0 && m < 4) {
			if (z.read_byte(p) == mark[m]) {
				m++;
			} else if (z.read_byte(p) !== 0) {
				m = 0;
			} else {
				m = 4 - m;
			}
			p++;
			n--;
		}

		// restore
		z.total_in += p - z.next_in_index;
		z.next_in_index = p;
		z.avail_in = n;
		istate.marker = m;

		// return no joy or set up to restart on a new block
		if (m != 4) {
			return Z_DATA_ERROR;
		}
		r = z.total_in;
		w = z.total_out;
		inflateReset(z);
		z.total_in = r;
		z.total_out = w;
		istate.mode = BLOCKS;
		return Z_OK;
	};

	// Returns true if inflate is currently at the end of a block generated
	// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
	// implementation to provide an additional safety check. PPP uses
	// Z_SYNC_FLUSH
	// but removes the length bytes of the resulting empty stored block. When
	// decompressing, PPP checks that at the end of input packet, inflate is
	// waiting for these length bytes.
	that.inflateSyncPoint = function (z) {
		if (!z || !z.istate || !z.istate.blocks)
			return Z_STREAM_ERROR;
		return z.istate.blocks.sync_point();
	};
}

// ZStream

function ZStream() {
}

ZStream.prototype = {
	inflateInit(bits) {
		const that = this;
		that.istate = new Inflate();
		if (!bits)
			bits = MAX_BITS;
		return that.istate.inflateInit(that, bits);
	},

	inflate(f) {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		return that.istate.inflate(that, f);
	},

	inflateEnd() {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		const ret = that.istate.inflateEnd(that);
		that.istate = null;
		return ret;
	},

	inflateSync() {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		return that.istate.inflateSync(that);
	},
	inflateSetDictionary(dictionary, dictLength) {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		return that.istate.inflateSetDictionary(that, dictionary, dictLength);
	},
	read_byte(start) {
		const that = this;
		return that.next_in[start];
	},
	read_buf(start, size) {
		const that = this;
		return that.next_in.subarray(start, start + size);
	}
};

// Inflater

function ZipInflate(options) {
	const that = this;
	const z = new ZStream();
	const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
	const flush = Z_NO_FLUSH;
	const buf = new Uint8Array(bufsize);
	let nomoreinput = false;

	z.inflateInit();
	z.next_out = buf;

	that.append = function (data, onprogress) {
		const buffers = [];
		let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
		if (data.length === 0)
			return;
		z.next_in_index = 0;
		z.next_in = data;
		z.avail_in = data.length;
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			if ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it
				z.next_in_index = 0;
				nomoreinput = true;
			}
			err = z.inflate(flush);
			if (nomoreinput && (err === Z_BUF_ERROR)) {
				if (z.avail_in !== 0)
					throw new Error("inflating: bad input");
			} else if (err !== Z_OK && err !== Z_STREAM_END)
				throw new Error("inflating: " + z.msg);
			if ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))
				throw new Error("inflating: bad input");
			if (z.next_out_index)
				if (z.next_out_index === bufsize)
					buffers.push(new Uint8Array(buf));
				else
					buffers.push(buf.subarray(0, z.next_out_index));
			bufferSize += z.next_out_index;
			if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
				onprogress(z.next_in_index);
				lastIndex = z.next_in_index;
			}
		} while (z.avail_in > 0 || z.avail_out === 0);
		if (buffers.length > 1) {
			array = new Uint8Array(bufferSize);
			buffers.forEach(function (chunk) {
				array.set(chunk, bufferIndex);
				bufferIndex += chunk.length;
			});
		} else {
			array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
		}
		return array;
	};
	that.flush = function () {
		z.inflateEnd();
	};
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const MAX_32_BITS = 0xffffffff;
const MAX_16_BITS = 0xffff;
const COMPRESSION_METHOD_DEFLATE = 0x08;
const COMPRESSION_METHOD_STORE = 0x00;
const COMPRESSION_METHOD_AES = 0x63;

const LOCAL_FILE_HEADER_SIGNATURE = 0x04034b50;
const SPLIT_ZIP_FILE_SIGNATURE = 0x08074b50;
const CENTRAL_FILE_HEADER_SIGNATURE = 0x02014b50;
const END_OF_CENTRAL_DIR_SIGNATURE = 0x06054b50;
const ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 0x06064b50;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 0x07064b50;
const END_OF_CENTRAL_DIR_LENGTH = 22;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;

const EXTRAFIELD_TYPE_ZIP64 = 0x0001;
const EXTRAFIELD_TYPE_AES = 0x9901;
const EXTRAFIELD_TYPE_NTFS = 0x000a;
const EXTRAFIELD_TYPE_NTFS_TAG1 = 0x0001;
const EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 0x5455;
const EXTRAFIELD_TYPE_UNICODE_PATH = 0x7075;
const EXTRAFIELD_TYPE_UNICODE_COMMENT = 0x6375;
const EXTRAFIELD_TYPE_USDZ = 0x1986;

const BITFLAG_ENCRYPTED = 0x01;
const BITFLAG_LEVEL = 0x06;
const BITFLAG_DATA_DESCRIPTOR = 0x0008;
const BITFLAG_LANG_ENCODING_FLAG = 0x0800;
const FILE_ATTR_MSDOS_DIR_MASK = 0x10;

const DIRECTORY_SIGNATURE = "/";

const UNDEFINED_VALUE = undefined;
const UNDEFINED_TYPE = "undefined";
const FUNCTION_TYPE = "function";

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


class StreamAdapter {

	constructor(Codec) {
		return class extends TransformStream {
			constructor(_format, options) {
				const codec = new Codec(options);
				super({
					transform(chunk, controller) {
						controller.enqueue(codec.append(chunk));
					},
					flush(controller) {
						const chunk = codec.flush();
						if (chunk) {
							controller.enqueue(chunk);
						}
					}
				});
			}
		};
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const MINIMUM_CHUNK_SIZE = 64;
let maxWorkers = 2;
try {
	if (typeof navigator != UNDEFINED_TYPE && navigator.hardwareConcurrency) {
		maxWorkers = navigator.hardwareConcurrency;
	}
} catch (_error) {
	// ignored
}
const DEFAULT_CONFIGURATION = {
	chunkSize: 512 * 1024,
	maxWorkers,
	terminateWorkerTimeout: 5000,
	useWebWorkers: true,
	useCompressionStream: true,
	workerScripts: UNDEFINED_VALUE,
	CompressionStreamNative: typeof CompressionStream != UNDEFINED_TYPE && CompressionStream,
	DecompressionStreamNative: typeof DecompressionStream != UNDEFINED_TYPE && DecompressionStream
};

const config = Object.assign({}, DEFAULT_CONFIGURATION);

function getConfiguration() {
	return config;
}

function getChunkSize(config) {
	return Math.max(config.chunkSize, MINIMUM_CHUNK_SIZE);
}

function configure(configuration) {
	const {
		baseURL,
		chunkSize,
		maxWorkers,
		terminateWorkerTimeout,
		useCompressionStream,
		useWebWorkers,
		Deflate,
		Inflate,
		CompressionStream,
		DecompressionStream,
		workerScripts
	} = configuration;
	setIfDefined("baseURL", baseURL);
	setIfDefined("chunkSize", chunkSize);
	setIfDefined("maxWorkers", maxWorkers);
	setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
	setIfDefined("useCompressionStream", useCompressionStream);
	setIfDefined("useWebWorkers", useWebWorkers);
	if (Deflate) {
		config.CompressionStream = new StreamAdapter(Deflate);
	}
	if (Inflate) {
		config.DecompressionStream = new StreamAdapter(Inflate);
	}
	setIfDefined("CompressionStream", CompressionStream);
	setIfDefined("DecompressionStream", DecompressionStream);
	if (workerScripts !== UNDEFINED_VALUE) {
		const { deflate, inflate } = workerScripts;
		if (deflate || inflate) {
			if (!config.workerScripts) {
				config.workerScripts = {};
			}
		}
		if (deflate) {
			if (!Array.isArray(deflate)) {
				throw new Error("workerScripts.deflate must be an array");
			}
			config.workerScripts.deflate = deflate;
		}
		if (inflate) {
			if (!Array.isArray(inflate)) {
				throw new Error("workerScripts.inflate must be an array");
			}
			config.workerScripts.inflate = inflate;
		}
	}
}

function setIfDefined(propertyName, propertyValue) {
	if (propertyValue !== UNDEFINED_VALUE) {
		config[propertyName] = propertyValue;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const table$1 = {
	"application": {
		"andrew-inset": "ez",
		"annodex": "anx",
		"atom+xml": "atom",
		"atomcat+xml": "atomcat",
		"atomserv+xml": "atomsrv",
		"bbolin": "lin",
		"cu-seeme": "cu",
		"davmount+xml": "davmount",
		"dsptype": "tsp",
		"ecmascript": [
			"es",
			"ecma"
		],
		"futuresplash": "spl",
		"hta": "hta",
		"java-archive": "jar",
		"java-serialized-object": "ser",
		"java-vm": "class",
		"m3g": "m3g",
		"mac-binhex40": "hqx",
		"mathematica": [
			"nb",
			"ma",
			"mb"
		],
		"msaccess": "mdb",
		"msword": [
			"doc",
			"dot",
			"wiz"
		],
		"mxf": "mxf",
		"oda": "oda",
		"ogg": "ogx",
		"pdf": "pdf",
		"pgp-keys": "key",
		"pgp-signature": [
			"asc",
			"sig"
		],
		"pics-rules": "prf",
		"postscript": [
			"ps",
			"ai",
			"eps",
			"epsi",
			"epsf",
			"eps2",
			"eps3"
		],
		"rar": "rar",
		"rdf+xml": "rdf",
		"rss+xml": "rss",
		"rtf": "rtf",
		"xhtml+xml": [
			"xhtml",
			"xht"
		],
		"xml": [
			"xml",
			"xsl",
			"xsd",
			"xpdl"
		],
		"xspf+xml": "xspf",
		"zip": "zip",
		"vnd.android.package-archive": "apk",
		"vnd.cinderella": "cdy",
		"vnd.google-earth.kml+xml": "kml",
		"vnd.google-earth.kmz": "kmz",
		"vnd.mozilla.xul+xml": "xul",
		"vnd.ms-excel": [
			"xls",
			"xlb",
			"xlt",
			"xlm",
			"xla",
			"xlc",
			"xlw"
		],
		"vnd.ms-pki.seccat": "cat",
		"vnd.ms-pki.stl": "stl",
		"vnd.ms-powerpoint": [
			"ppt",
			"pps",
			"pot",
			"ppa",
			"pwz"
		],
		"vnd.oasis.opendocument.chart": "odc",
		"vnd.oasis.opendocument.database": "odb",
		"vnd.oasis.opendocument.formula": "odf",
		"vnd.oasis.opendocument.graphics": "odg",
		"vnd.oasis.opendocument.graphics-template": "otg",
		"vnd.oasis.opendocument.image": "odi",
		"vnd.oasis.opendocument.presentation": "odp",
		"vnd.oasis.opendocument.presentation-template": "otp",
		"vnd.oasis.opendocument.spreadsheet": "ods",
		"vnd.oasis.opendocument.spreadsheet-template": "ots",
		"vnd.oasis.opendocument.text": "odt",
		"vnd.oasis.opendocument.text-master": [
			"odm",
			"otm"
		],
		"vnd.oasis.opendocument.text-template": "ott",
		"vnd.oasis.opendocument.text-web": "oth",
		"vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
		"vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
		"vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
		"vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
		"vnd.openxmlformats-officedocument.presentationml.template": "potx",
		"vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
		"vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
		"vnd.smaf": "mmf",
		"vnd.stardivision.calc": "sdc",
		"vnd.stardivision.chart": "sds",
		"vnd.stardivision.draw": "sda",
		"vnd.stardivision.impress": "sdd",
		"vnd.stardivision.math": [
			"sdf",
			"smf"
		],
		"vnd.stardivision.writer": [
			"sdw",
			"vor"
		],
		"vnd.stardivision.writer-global": "sgl",
		"vnd.sun.xml.calc": "sxc",
		"vnd.sun.xml.calc.template": "stc",
		"vnd.sun.xml.draw": "sxd",
		"vnd.sun.xml.draw.template": "std",
		"vnd.sun.xml.impress": "sxi",
		"vnd.sun.xml.impress.template": "sti",
		"vnd.sun.xml.math": "sxm",
		"vnd.sun.xml.writer": "sxw",
		"vnd.sun.xml.writer.global": "sxg",
		"vnd.sun.xml.writer.template": "stw",
		"vnd.symbian.install": [
			"sis",
			"sisx"
		],
		"vnd.visio": [
			"vsd",
			"vst",
			"vss",
			"vsw",
			"vsdx",
			"vssx",
			"vstx",
			"vssm",
			"vstm"
		],
		"vnd.wap.wbxml": "wbxml",
		"vnd.wap.wmlc": "wmlc",
		"vnd.wap.wmlscriptc": "wmlsc",
		"vnd.wordperfect": "wpd",
		"vnd.wordperfect5.1": "wp5",
		"x-123": "wk",
		"x-7z-compressed": "7z",
		"x-abiword": "abw",
		"x-apple-diskimage": "dmg",
		"x-bcpio": "bcpio",
		"x-bittorrent": "torrent",
		"x-cbr": [
			"cbr",
			"cba",
			"cbt",
			"cb7"
		],
		"x-cbz": "cbz",
		"x-cdf": [
			"cdf",
			"cda"
		],
		"x-cdlink": "vcd",
		"x-chess-pgn": "pgn",
		"x-cpio": "cpio",
		"x-csh": "csh",
		"x-director": [
			"dir",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		],
		"x-dms": "dms",
		"x-doom": "wad",
		"x-dvi": "dvi",
		"x-httpd-eruby": "rhtml",
		"x-font": "pcf.Z",
		"x-freemind": "mm",
		"x-gnumeric": "gnumeric",
		"x-go-sgf": "sgf",
		"x-graphing-calculator": "gcf",
		"x-gtar": [
			"gtar",
			"taz"
		],
		"x-hdf": "hdf",
		"x-httpd-php": [
			"phtml",
			"pht",
			"php"
		],
		"x-httpd-php-source": "phps",
		"x-httpd-php3": "php3",
		"x-httpd-php3-preprocessed": "php3p",
		"x-httpd-php4": "php4",
		"x-httpd-php5": "php5",
		"x-ica": "ica",
		"x-info": "info",
		"x-internet-signup": [
			"ins",
			"isp"
		],
		"x-iphone": "iii",
		"x-iso9660-image": "iso",
		"x-java-jnlp-file": "jnlp",
		"x-jmol": "jmz",
		"x-killustrator": "kil",
		"x-latex": "latex",
		"x-lyx": "lyx",
		"x-lzx": "lzx",
		"x-maker": [
			"frm",
			"fb",
			"fbdoc"
		],
		"x-ms-wmd": "wmd",
		"x-msdos-program": [
			"com",
			"exe",
			"bat",
			"dll"
		],
		"x-netcdf": [
			"nc"
		],
		"x-ns-proxy-autoconfig": [
			"pac",
			"dat"
		],
		"x-nwc": "nwc",
		"x-object": "o",
		"x-oz-application": "oza",
		"x-pkcs7-certreqresp": "p7r",
		"x-python-code": [
			"pyc",
			"pyo"
		],
		"x-qgis": [
			"qgs",
			"shp",
			"shx"
		],
		"x-quicktimeplayer": "qtl",
		"x-redhat-package-manager": [
			"rpm",
			"rpa"
		],
		"x-ruby": "rb",
		"x-sh": "sh",
		"x-shar": "shar",
		"x-shockwave-flash": [
			"swf",
			"swfl"
		],
		"x-silverlight": "scr",
		"x-stuffit": "sit",
		"x-sv4cpio": "sv4cpio",
		"x-sv4crc": "sv4crc",
		"x-tar": "tar",
		"x-tex-gf": "gf",
		"x-tex-pk": "pk",
		"x-texinfo": [
			"texinfo",
			"texi"
		],
		"x-trash": [
			"~",
			"%",
			"bak",
			"old",
			"sik"
		],
		"x-ustar": "ustar",
		"x-wais-source": "src",
		"x-wingz": "wz",
		"x-x509-ca-cert": [
			"crt",
			"der",
			"cer"
		],
		"x-xcf": "xcf",
		"x-xfig": "fig",
		"x-xpinstall": "xpi",
		"applixware": "aw",
		"atomsvc+xml": "atomsvc",
		"ccxml+xml": "ccxml",
		"cdmi-capability": "cdmia",
		"cdmi-container": "cdmic",
		"cdmi-domain": "cdmid",
		"cdmi-object": "cdmio",
		"cdmi-queue": "cdmiq",
		"docbook+xml": "dbk",
		"dssc+der": "dssc",
		"dssc+xml": "xdssc",
		"emma+xml": "emma",
		"epub+zip": "epub",
		"exi": "exi",
		"font-tdpfr": "pfr",
		"gml+xml": "gml",
		"gpx+xml": "gpx",
		"gxf": "gxf",
		"hyperstudio": "stk",
		"inkml+xml": [
			"ink",
			"inkml"
		],
		"ipfix": "ipfix",
		"jsonml+json": "jsonml",
		"lost+xml": "lostxml",
		"mads+xml": "mads",
		"marc": "mrc",
		"marcxml+xml": "mrcx",
		"mathml+xml": [
			"mathml",
			"mml"
		],
		"mbox": "mbox",
		"mediaservercontrol+xml": "mscml",
		"metalink+xml": "metalink",
		"metalink4+xml": "meta4",
		"mets+xml": "mets",
		"mods+xml": "mods",
		"mp21": [
			"m21",
			"mp21"
		],
		"mp4": "mp4s",
		"oebps-package+xml": "opf",
		"omdoc+xml": "omdoc",
		"onenote": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		],
		"oxps": "oxps",
		"patch-ops-error+xml": "xer",
		"pgp-encrypted": "pgp",
		"pkcs10": "p10",
		"pkcs7-mime": [
			"p7m",
			"p7c"
		],
		"pkcs7-signature": "p7s",
		"pkcs8": "p8",
		"pkix-attr-cert": "ac",
		"pkix-crl": "crl",
		"pkix-pkipath": "pkipath",
		"pkixcmp": "pki",
		"pls+xml": "pls",
		"prs.cww": "cww",
		"pskc+xml": "pskcxml",
		"reginfo+xml": "rif",
		"relax-ng-compact-syntax": "rnc",
		"resource-lists+xml": "rl",
		"resource-lists-diff+xml": "rld",
		"rls-services+xml": "rs",
		"rpki-ghostbusters": "gbr",
		"rpki-manifest": "mft",
		"rpki-roa": "roa",
		"rsd+xml": "rsd",
		"sbml+xml": "sbml",
		"scvp-cv-request": "scq",
		"scvp-cv-response": "scs",
		"scvp-vp-request": "spq",
		"scvp-vp-response": "spp",
		"sdp": "sdp",
		"set-payment-initiation": "setpay",
		"set-registration-initiation": "setreg",
		"shf+xml": "shf",
		"sparql-query": "rq",
		"sparql-results+xml": "srx",
		"srgs": "gram",
		"srgs+xml": "grxml",
		"sru+xml": "sru",
		"ssdl+xml": "ssdl",
		"ssml+xml": "ssml",
		"tei+xml": [
			"tei",
			"teicorpus"
		],
		"thraud+xml": "tfi",
		"timestamped-data": "tsd",
		"vnd.3gpp.pic-bw-large": "plb",
		"vnd.3gpp.pic-bw-small": "psb",
		"vnd.3gpp.pic-bw-var": "pvb",
		"vnd.3gpp2.tcap": "tcap",
		"vnd.3m.post-it-notes": "pwn",
		"vnd.accpac.simply.aso": "aso",
		"vnd.accpac.simply.imp": "imp",
		"vnd.acucobol": "acu",
		"vnd.acucorp": [
			"atc",
			"acutc"
		],
		"vnd.adobe.air-application-installer-package+zip": "air",
		"vnd.adobe.formscentral.fcdt": "fcdt",
		"vnd.adobe.fxp": [
			"fxp",
			"fxpl"
		],
		"vnd.adobe.xdp+xml": "xdp",
		"vnd.adobe.xfdf": "xfdf",
		"vnd.ahead.space": "ahead",
		"vnd.airzip.filesecure.azf": "azf",
		"vnd.airzip.filesecure.azs": "azs",
		"vnd.amazon.ebook": "azw",
		"vnd.americandynamics.acc": "acc",
		"vnd.amiga.ami": "ami",
		"vnd.anser-web-certificate-issue-initiation": "cii",
		"vnd.anser-web-funds-transfer-initiation": "fti",
		"vnd.antix.game-component": "atx",
		"vnd.apple.installer+xml": "mpkg",
		"vnd.apple.mpegurl": "m3u8",
		"vnd.aristanetworks.swi": "swi",
		"vnd.astraea-software.iota": "iota",
		"vnd.audiograph": "aep",
		"vnd.blueice.multipass": "mpm",
		"vnd.bmi": "bmi",
		"vnd.businessobjects": "rep",
		"vnd.chemdraw+xml": "cdxml",
		"vnd.chipnuts.karaoke-mmd": "mmd",
		"vnd.claymore": "cla",
		"vnd.cloanto.rp9": "rp9",
		"vnd.clonk.c4group": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		],
		"vnd.cluetrust.cartomobile-config": "c11amc",
		"vnd.cluetrust.cartomobile-config-pkg": "c11amz",
		"vnd.commonspace": "csp",
		"vnd.contact.cmsg": "cdbcmsg",
		"vnd.cosmocaller": "cmc",
		"vnd.crick.clicker": "clkx",
		"vnd.crick.clicker.keyboard": "clkk",
		"vnd.crick.clicker.palette": "clkp",
		"vnd.crick.clicker.template": "clkt",
		"vnd.crick.clicker.wordbank": "clkw",
		"vnd.criticaltools.wbs+xml": "wbs",
		"vnd.ctc-posml": "pml",
		"vnd.cups-ppd": "ppd",
		"vnd.curl.car": "car",
		"vnd.curl.pcurl": "pcurl",
		"vnd.dart": "dart",
		"vnd.data-vision.rdz": "rdz",
		"vnd.dece.data": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		],
		"vnd.dece.ttml+xml": [
			"uvt",
			"uvvt"
		],
		"vnd.dece.unspecified": [
			"uvx",
			"uvvx"
		],
		"vnd.dece.zip": [
			"uvz",
			"uvvz"
		],
		"vnd.denovo.fcselayout-link": "fe_launch",
		"vnd.dna": "dna",
		"vnd.dolby.mlp": "mlp",
		"vnd.dpgraph": "dpg",
		"vnd.dreamfactory": "dfac",
		"vnd.ds-keypoint": "kpxx",
		"vnd.dvb.ait": "ait",
		"vnd.dvb.service": "svc",
		"vnd.dynageo": "geo",
		"vnd.ecowin.chart": "mag",
		"vnd.enliven": "nml",
		"vnd.epson.esf": "esf",
		"vnd.epson.msf": "msf",
		"vnd.epson.quickanime": "qam",
		"vnd.epson.salt": "slt",
		"vnd.epson.ssf": "ssf",
		"vnd.eszigno3+xml": [
			"es3",
			"et3"
		],
		"vnd.ezpix-album": "ez2",
		"vnd.ezpix-package": "ez3",
		"vnd.fdf": "fdf",
		"vnd.fdsn.mseed": "mseed",
		"vnd.fdsn.seed": [
			"seed",
			"dataless"
		],
		"vnd.flographit": "gph",
		"vnd.fluxtime.clip": "ftc",
		"vnd.framemaker": [
			"fm",
			"frame",
			"maker",
			"book"
		],
		"vnd.frogans.fnc": "fnc",
		"vnd.frogans.ltf": "ltf",
		"vnd.fsc.weblaunch": "fsc",
		"vnd.fujitsu.oasys": "oas",
		"vnd.fujitsu.oasys2": "oa2",
		"vnd.fujitsu.oasys3": "oa3",
		"vnd.fujitsu.oasysgp": "fg5",
		"vnd.fujitsu.oasysprs": "bh2",
		"vnd.fujixerox.ddd": "ddd",
		"vnd.fujixerox.docuworks": "xdw",
		"vnd.fujixerox.docuworks.binder": "xbd",
		"vnd.fuzzysheet": "fzs",
		"vnd.genomatix.tuxedo": "txd",
		"vnd.geogebra.file": "ggb",
		"vnd.geogebra.tool": "ggt",
		"vnd.geometry-explorer": [
			"gex",
			"gre"
		],
		"vnd.geonext": "gxt",
		"vnd.geoplan": "g2w",
		"vnd.geospace": "g3w",
		"vnd.gmx": "gmx",
		"vnd.grafeq": [
			"gqf",
			"gqs"
		],
		"vnd.groove-account": "gac",
		"vnd.groove-help": "ghf",
		"vnd.groove-identity-message": "gim",
		"vnd.groove-injector": "grv",
		"vnd.groove-tool-message": "gtm",
		"vnd.groove-tool-template": "tpl",
		"vnd.groove-vcard": "vcg",
		"vnd.hal+xml": "hal",
		"vnd.handheld-entertainment+xml": "zmm",
		"vnd.hbci": "hbci",
		"vnd.hhe.lesson-player": "les",
		"vnd.hp-hpgl": "hpgl",
		"vnd.hp-hpid": "hpid",
		"vnd.hp-hps": "hps",
		"vnd.hp-jlyt": "jlt",
		"vnd.hp-pcl": "pcl",
		"vnd.hp-pclxl": "pclxl",
		"vnd.hydrostatix.sof-data": "sfd-hdstx",
		"vnd.ibm.minipay": "mpy",
		"vnd.ibm.modcap": [
			"afp",
			"listafp",
			"list3820"
		],
		"vnd.ibm.rights-management": "irm",
		"vnd.ibm.secure-container": "sc",
		"vnd.iccprofile": [
			"icc",
			"icm"
		],
		"vnd.igloader": "igl",
		"vnd.immervision-ivp": "ivp",
		"vnd.immervision-ivu": "ivu",
		"vnd.insors.igm": "igm",
		"vnd.intercon.formnet": [
			"xpw",
			"xpx"
		],
		"vnd.intergeo": "i2g",
		"vnd.intu.qbo": "qbo",
		"vnd.intu.qfx": "qfx",
		"vnd.ipunplugged.rcprofile": "rcprofile",
		"vnd.irepository.package+xml": "irp",
		"vnd.is-xpr": "xpr",
		"vnd.isac.fcs": "fcs",
		"vnd.jam": "jam",
		"vnd.jcp.javame.midlet-rms": "rms",
		"vnd.jisp": "jisp",
		"vnd.joost.joda-archive": "joda",
		"vnd.kahootz": [
			"ktz",
			"ktr"
		],
		"vnd.kde.karbon": "karbon",
		"vnd.kde.kchart": "chrt",
		"vnd.kde.kformula": "kfo",
		"vnd.kde.kivio": "flw",
		"vnd.kde.kontour": "kon",
		"vnd.kde.kpresenter": [
			"kpr",
			"kpt"
		],
		"vnd.kde.kspread": "ksp",
		"vnd.kde.kword": [
			"kwd",
			"kwt"
		],
		"vnd.kenameaapp": "htke",
		"vnd.kidspiration": "kia",
		"vnd.kinar": [
			"kne",
			"knp"
		],
		"vnd.koan": [
			"skp",
			"skd",
			"skt",
			"skm"
		],
		"vnd.kodak-descriptor": "sse",
		"vnd.las.las+xml": "lasxml",
		"vnd.llamagraphics.life-balance.desktop": "lbd",
		"vnd.llamagraphics.life-balance.exchange+xml": "lbe",
		"vnd.lotus-1-2-3": "123",
		"vnd.lotus-approach": "apr",
		"vnd.lotus-freelance": "pre",
		"vnd.lotus-notes": "nsf",
		"vnd.lotus-organizer": "org",
		"vnd.lotus-screencam": "scm",
		"vnd.lotus-wordpro": "lwp",
		"vnd.macports.portpkg": "portpkg",
		"vnd.mcd": "mcd",
		"vnd.medcalcdata": "mc1",
		"vnd.mediastation.cdkey": "cdkey",
		"vnd.mfer": "mwf",
		"vnd.mfmp": "mfm",
		"vnd.micrografx.flo": "flo",
		"vnd.micrografx.igx": "igx",
		"vnd.mif": "mif",
		"vnd.mobius.daf": "daf",
		"vnd.mobius.dis": "dis",
		"vnd.mobius.mbk": "mbk",
		"vnd.mobius.mqy": "mqy",
		"vnd.mobius.msl": "msl",
		"vnd.mobius.plc": "plc",
		"vnd.mobius.txf": "txf",
		"vnd.mophun.application": "mpn",
		"vnd.mophun.certificate": "mpc",
		"vnd.ms-artgalry": "cil",
		"vnd.ms-cab-compressed": "cab",
		"vnd.ms-excel.addin.macroenabled.12": "xlam",
		"vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
		"vnd.ms-excel.sheet.macroenabled.12": "xlsm",
		"vnd.ms-excel.template.macroenabled.12": "xltm",
		"vnd.ms-fontobject": "eot",
		"vnd.ms-htmlhelp": "chm",
		"vnd.ms-ims": "ims",
		"vnd.ms-lrm": "lrm",
		"vnd.ms-officetheme": "thmx",
		"vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
		"vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
		"vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
		"vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
		"vnd.ms-powerpoint.template.macroenabled.12": "potm",
		"vnd.ms-project": [
			"mpp",
			"mpt"
		],
		"vnd.ms-word.document.macroenabled.12": "docm",
		"vnd.ms-word.template.macroenabled.12": "dotm",
		"vnd.ms-works": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		],
		"vnd.ms-wpl": "wpl",
		"vnd.ms-xpsdocument": "xps",
		"vnd.mseq": "mseq",
		"vnd.musician": "mus",
		"vnd.muvee.style": "msty",
		"vnd.mynfc": "taglet",
		"vnd.neurolanguage.nlu": "nlu",
		"vnd.nitf": [
			"ntf",
			"nitf"
		],
		"vnd.noblenet-directory": "nnd",
		"vnd.noblenet-sealer": "nns",
		"vnd.noblenet-web": "nnw",
		"vnd.nokia.n-gage.data": "ngdat",
		"vnd.nokia.n-gage.symbian.install": "n-gage",
		"vnd.nokia.radio-preset": "rpst",
		"vnd.nokia.radio-presets": "rpss",
		"vnd.novadigm.edm": "edm",
		"vnd.novadigm.edx": "edx",
		"vnd.novadigm.ext": "ext",
		"vnd.oasis.opendocument.chart-template": "otc",
		"vnd.oasis.opendocument.formula-template": "odft",
		"vnd.oasis.opendocument.image-template": "oti",
		"vnd.olpc-sugar": "xo",
		"vnd.oma.dd2+xml": "dd2",
		"vnd.openofficeorg.extension": "oxt",
		"vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
		"vnd.osgeo.mapguide.package": "mgp",
		"vnd.osgi.dp": "dp",
		"vnd.osgi.subsystem": "esa",
		"vnd.palm": [
			"pdb",
			"pqa",
			"oprc"
		],
		"vnd.pawaafile": "paw",
		"vnd.pg.format": "str",
		"vnd.pg.osasli": "ei6",
		"vnd.picsel": "efif",
		"vnd.pmi.widget": "wg",
		"vnd.pocketlearn": "plf",
		"vnd.powerbuilder6": "pbd",
		"vnd.previewsystems.box": "box",
		"vnd.proteus.magazine": "mgz",
		"vnd.publishare-delta-tree": "qps",
		"vnd.pvi.ptid1": "ptid",
		"vnd.quark.quarkxpress": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		],
		"vnd.realvnc.bed": "bed",
		"vnd.recordare.musicxml": "mxl",
		"vnd.recordare.musicxml+xml": "musicxml",
		"vnd.rig.cryptonote": "cryptonote",
		"vnd.rn-realmedia": "rm",
		"vnd.rn-realmedia-vbr": "rmvb",
		"vnd.route66.link66+xml": "link66",
		"vnd.sailingtracker.track": "st",
		"vnd.seemail": "see",
		"vnd.sema": "sema",
		"vnd.semd": "semd",
		"vnd.semf": "semf",
		"vnd.shana.informed.formdata": "ifm",
		"vnd.shana.informed.formtemplate": "itp",
		"vnd.shana.informed.interchange": "iif",
		"vnd.shana.informed.package": "ipk",
		"vnd.simtech-mindmapper": [
			"twd",
			"twds"
		],
		"vnd.smart.teacher": "teacher",
		"vnd.solent.sdkm+xml": [
			"sdkm",
			"sdkd"
		],
		"vnd.spotfire.dxp": "dxp",
		"vnd.spotfire.sfs": "sfs",
		"vnd.stepmania.package": "smzip",
		"vnd.stepmania.stepchart": "sm",
		"vnd.sus-calendar": [
			"sus",
			"susp"
		],
		"vnd.svd": "svd",
		"vnd.syncml+xml": "xsm",
		"vnd.syncml.dm+wbxml": "bdm",
		"vnd.syncml.dm+xml": "xdm",
		"vnd.tao.intent-module-archive": "tao",
		"vnd.tcpdump.pcap": [
			"pcap",
			"cap",
			"dmp"
		],
		"vnd.tmobile-livetv": "tmo",
		"vnd.trid.tpt": "tpt",
		"vnd.triscape.mxs": "mxs",
		"vnd.trueapp": "tra",
		"vnd.ufdl": [
			"ufd",
			"ufdl"
		],
		"vnd.uiq.theme": "utz",
		"vnd.umajin": "umj",
		"vnd.unity": "unityweb",
		"vnd.uoml+xml": "uoml",
		"vnd.vcx": "vcx",
		"vnd.visionary": "vis",
		"vnd.vsf": "vsf",
		"vnd.webturbo": "wtb",
		"vnd.wolfram.player": "nbp",
		"vnd.wqd": "wqd",
		"vnd.wt.stf": "stf",
		"vnd.xara": "xar",
		"vnd.xfdl": "xfdl",
		"vnd.yamaha.hv-dic": "hvd",
		"vnd.yamaha.hv-script": "hvs",
		"vnd.yamaha.hv-voice": "hvp",
		"vnd.yamaha.openscoreformat": "osf",
		"vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
		"vnd.yamaha.smaf-audio": "saf",
		"vnd.yamaha.smaf-phrase": "spf",
		"vnd.yellowriver-custom-menu": "cmp",
		"vnd.zul": [
			"zir",
			"zirz"
		],
		"vnd.zzazz.deck+xml": "zaz",
		"voicexml+xml": "vxml",
		"widget": "wgt",
		"winhlp": "hlp",
		"wsdl+xml": "wsdl",
		"wspolicy+xml": "wspolicy",
		"x-ace-compressed": "ace",
		"x-authorware-bin": [
			"aab",
			"x32",
			"u32",
			"vox"
		],
		"x-authorware-map": "aam",
		"x-authorware-seg": "aas",
		"x-blorb": [
			"blb",
			"blorb"
		],
		"x-bzip": "bz",
		"x-bzip2": [
			"bz2",
			"boz"
		],
		"x-cfs-compressed": "cfs",
		"x-chat": "chat",
		"x-conference": "nsc",
		"x-dgc-compressed": "dgc",
		"x-dtbncx+xml": "ncx",
		"x-dtbook+xml": "dtb",
		"x-dtbresource+xml": "res",
		"x-eva": "eva",
		"x-font-bdf": "bdf",
		"x-font-ghostscript": "gsf",
		"x-font-linux-psf": "psf",
		"x-font-pcf": "pcf",
		"x-font-snf": "snf",
		"x-font-ttf": [
			"ttf",
			"ttc"
		],
		"x-font-type1": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		],
		"x-freearc": "arc",
		"x-gca-compressed": "gca",
		"x-glulx": "ulx",
		"x-gramps-xml": "gramps",
		"x-install-instructions": "install",
		"x-lzh-compressed": [
			"lzh",
			"lha"
		],
		"x-mie": "mie",
		"x-mobipocket-ebook": [
			"prc",
			"mobi"
		],
		"x-ms-application": "application",
		"x-ms-shortcut": "lnk",
		"x-ms-xbap": "xbap",
		"x-msbinder": "obd",
		"x-mscardfile": "crd",
		"x-msclip": "clp",
		"application/x-ms-installer": "msi",
		"x-msmediaview": [
			"mvb",
			"m13",
			"m14"
		],
		"x-msmetafile": [
			"wmf",
			"wmz",
			"emf",
			"emz"
		],
		"x-msmoney": "mny",
		"x-mspublisher": "pub",
		"x-msschedule": "scd",
		"x-msterminal": "trm",
		"x-mswrite": "wri",
		"x-nzb": "nzb",
		"x-pkcs12": [
			"p12",
			"pfx"
		],
		"x-pkcs7-certificates": [
			"p7b",
			"spc"
		],
		"x-research-info-systems": "ris",
		"x-silverlight-app": "xap",
		"x-sql": "sql",
		"x-stuffitx": "sitx",
		"x-subrip": "srt",
		"x-t3vm-image": "t3",
		"x-tex-tfm": "tfm",
		"x-tgif": "obj",
		"x-xliff+xml": "xlf",
		"x-xz": "xz",
		"x-zmachine": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		],
		"xaml+xml": "xaml",
		"xcap-diff+xml": "xdf",
		"xenc+xml": "xenc",
		"xml-dtd": "dtd",
		"xop+xml": "xop",
		"xproc+xml": "xpl",
		"xslt+xml": "xslt",
		"xv+xml": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		],
		"yang": "yang",
		"yin+xml": "yin",
		"envoy": "evy",
		"fractals": "fif",
		"internet-property-stream": "acx",
		"olescript": "axs",
		"vnd.ms-outlook": "msg",
		"vnd.ms-pkicertstore": "sst",
		"x-compress": "z",
		"x-perfmon": [
			"pma",
			"pmc",
			"pmr",
			"pmw"
		],
		"ynd.ms-pkipko": "pko",
		"gzip": [
			"gz",
			"tgz"
		],
		"smil+xml": [
			"smi",
			"smil"
		],
		"vnd.debian.binary-package": [
			"deb",
			"udeb"
		],
		"vnd.hzn-3d-crossword": "x3d",
		"vnd.sqlite3": [
			"db",
			"sqlite",
			"sqlite3",
			"db-wal",
			"sqlite-wal",
			"db-shm",
			"sqlite-shm"
		],
		"vnd.wap.sic": "sic",
		"vnd.wap.slc": "slc",
		"x-krita": [
			"kra",
			"krz"
		],
		"x-perl": [
			"pm",
			"pl"
		],
		"yaml": [
			"yaml",
			"yml"
		]
	},
	"audio": {
		"amr": "amr",
		"amr-wb": "awb",
		"annodex": "axa",
		"basic": [
			"au",
			"snd"
		],
		"flac": "flac",
		"midi": [
			"mid",
			"midi",
			"kar",
			"rmi"
		],
		"mpeg": [
			"mpga",
			"mpega",
			"mp3",
			"m4a",
			"mp2a",
			"m2a",
			"m3a"
		],
		"mpegurl": "m3u",
		"ogg": [
			"oga",
			"ogg",
			"spx"
		],
		"prs.sid": "sid",
		"x-aiff": "aifc",
		"x-gsm": "gsm",
		"x-ms-wma": "wma",
		"x-ms-wax": "wax",
		"x-pn-realaudio": "ram",
		"x-realaudio": "ra",
		"x-sd2": "sd2",
		"adpcm": "adp",
		"mp4": "mp4a",
		"s3m": "s3m",
		"silk": "sil",
		"vnd.dece.audio": [
			"uva",
			"uvva"
		],
		"vnd.digital-winds": "eol",
		"vnd.dra": "dra",
		"vnd.dts": "dts",
		"vnd.dts.hd": "dtshd",
		"vnd.lucent.voice": "lvp",
		"vnd.ms-playready.media.pya": "pya",
		"vnd.nuera.ecelp4800": "ecelp4800",
		"vnd.nuera.ecelp7470": "ecelp7470",
		"vnd.nuera.ecelp9600": "ecelp9600",
		"vnd.rip": "rip",
		"webm": "weba",
		"x-caf": "caf",
		"x-matroska": "mka",
		"x-pn-realaudio-plugin": "rmp",
		"xm": "xm",
		"aac": "aac",
		"aiff": [
			"aiff",
			"aif",
			"aff"
		],
		"opus": "opus",
		"wav": "wav"
	},
	"chemical": {
		"x-alchemy": "alc",
		"x-cache": [
			"cac",
			"cache"
		],
		"x-cache-csf": "csf",
		"x-cactvs-binary": [
			"cbin",
			"cascii",
			"ctab"
		],
		"x-cdx": "cdx",
		"x-chem3d": "c3d",
		"x-cif": "cif",
		"x-cmdf": "cmdf",
		"x-cml": "cml",
		"x-compass": "cpa",
		"x-crossfire": "bsd",
		"x-csml": [
			"csml",
			"csm"
		],
		"x-ctx": "ctx",
		"x-cxf": [
			"cxf",
			"cef"
		],
		"x-embl-dl-nucleotide": [
			"emb",
			"embl"
		],
		"x-gamess-input": [
			"inp",
			"gam",
			"gamin"
		],
		"x-gaussian-checkpoint": [
			"fch",
			"fchk"
		],
		"x-gaussian-cube": "cub",
		"x-gaussian-input": [
			"gau",
			"gjc",
			"gjf"
		],
		"x-gaussian-log": "gal",
		"x-gcg8-sequence": "gcg",
		"x-genbank": "gen",
		"x-hin": "hin",
		"x-isostar": [
			"istr",
			"ist"
		],
		"x-jcamp-dx": [
			"jdx",
			"dx"
		],
		"x-kinemage": "kin",
		"x-macmolecule": "mcm",
		"x-macromodel-input": "mmod",
		"x-mdl-molfile": "mol",
		"x-mdl-rdfile": "rd",
		"x-mdl-rxnfile": "rxn",
		"x-mdl-sdfile": "sd",
		"x-mdl-tgf": "tgf",
		"x-mmcif": "mcif",
		"x-mol2": "mol2",
		"x-molconn-Z": "b",
		"x-mopac-graph": "gpt",
		"x-mopac-input": [
			"mop",
			"mopcrt",
			"zmt"
		],
		"x-mopac-out": "moo",
		"x-ncbi-asn1": "asn",
		"x-ncbi-asn1-ascii": [
			"prt",
			"ent"
		],
		"x-ncbi-asn1-binary": "val",
		"x-rosdal": "ros",
		"x-swissprot": "sw",
		"x-vamas-iso14976": "vms",
		"x-vmd": "vmd",
		"x-xtel": "xtel",
		"x-xyz": "xyz"
	},
	"font": {
		"otf": "otf",
		"woff": "woff",
		"woff2": "woff2"
	},
	"image": {
		"gif": "gif",
		"ief": "ief",
		"jpeg": [
			"jpeg",
			"jpg",
			"jpe",
			"jfif",
			"jfif-tbnl",
			"jif"
		],
		"pcx": "pcx",
		"png": "png",
		"svg+xml": [
			"svg",
			"svgz"
		],
		"tiff": [
			"tiff",
			"tif"
		],
		"vnd.djvu": [
			"djvu",
			"djv"
		],
		"vnd.wap.wbmp": "wbmp",
		"x-canon-cr2": "cr2",
		"x-canon-crw": "crw",
		"x-cmu-raster": "ras",
		"x-coreldraw": "cdr",
		"x-coreldrawpattern": "pat",
		"x-coreldrawtemplate": "cdt",
		"x-corelphotopaint": "cpt",
		"x-epson-erf": "erf",
		"x-icon": "ico",
		"x-jg": "art",
		"x-jng": "jng",
		"x-nikon-nef": "nef",
		"x-olympus-orf": "orf",
		"x-portable-anymap": "pnm",
		"x-portable-bitmap": "pbm",
		"x-portable-graymap": "pgm",
		"x-portable-pixmap": "ppm",
		"x-rgb": "rgb",
		"x-xbitmap": "xbm",
		"x-xpixmap": "xpm",
		"x-xwindowdump": "xwd",
		"bmp": "bmp",
		"cgm": "cgm",
		"g3fax": "g3",
		"ktx": "ktx",
		"prs.btif": "btif",
		"sgi": "sgi",
		"vnd.dece.graphic": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		],
		"vnd.dwg": "dwg",
		"vnd.dxf": "dxf",
		"vnd.fastbidsheet": "fbs",
		"vnd.fpx": "fpx",
		"vnd.fst": "fst",
		"vnd.fujixerox.edmics-mmr": "mmr",
		"vnd.fujixerox.edmics-rlc": "rlc",
		"vnd.ms-modi": "mdi",
		"vnd.ms-photo": "wdp",
		"vnd.net-fpx": "npx",
		"vnd.xiff": "xif",
		"webp": "webp",
		"x-3ds": "3ds",
		"x-cmx": "cmx",
		"x-freehand": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		],
		"x-pict": [
			"pic",
			"pct"
		],
		"x-tga": "tga",
		"cis-cod": "cod",
		"avif": "avifs",
		"heic": [
			"heif",
			"heic"
		],
		"pjpeg": [
			"pjpg"
		],
		"vnd.adobe.photoshop": "psd",
		"x-adobe-dng": "dng",
		"x-fuji-raf": "raf",
		"x-icns": "icns",
		"x-kodak-dcr": "dcr",
		"x-kodak-k25": "k25",
		"x-kodak-kdc": "kdc",
		"x-minolta-mrw": "mrw",
		"x-panasonic-raw": [
			"raw",
			"rw2",
			"rwl"
		],
		"x-pentax-pef": [
			"pef",
			"ptx"
		],
		"x-sigma-x3f": "x3f",
		"x-sony-arw": "arw",
		"x-sony-sr2": "sr2",
		"x-sony-srf": "srf"
	},
	"message": {
		"rfc822": [
			"eml",
			"mime",
			"mht",
			"mhtml",
			"nws"
		]
	},
	"model": {
		"iges": [
			"igs",
			"iges"
		],
		"mesh": [
			"msh",
			"mesh",
			"silo"
		],
		"vrml": [
			"wrl",
			"vrml"
		],
		"x3d+vrml": [
			"x3dv",
			"x3dvz"
		],
		"x3d+xml": "x3dz",
		"x3d+binary": [
			"x3db",
			"x3dbz"
		],
		"vnd.collada+xml": "dae",
		"vnd.dwf": "dwf",
		"vnd.gdl": "gdl",
		"vnd.gtw": "gtw",
		"vnd.mts": "mts",
		"vnd.usdz+zip": "usdz",
		"vnd.vtu": "vtu"
	},
	"text": {
		"cache-manifest": [
			"manifest",
			"appcache"
		],
		"calendar": [
			"ics",
			"icz",
			"ifb"
		],
		"css": "css",
		"csv": "csv",
		"h323": "323",
		"html": [
			"html",
			"htm",
			"shtml",
			"stm"
		],
		"iuls": "uls",
		"plain": [
			"txt",
			"text",
			"brf",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"bas",
			"diff",
			"ksh"
		],
		"richtext": "rtx",
		"scriptlet": [
			"sct",
			"wsc"
		],
		"texmacs": "tm",
		"tab-separated-values": "tsv",
		"vnd.sun.j2me.app-descriptor": "jad",
		"vnd.wap.wml": "wml",
		"vnd.wap.wmlscript": "wmls",
		"x-bibtex": "bib",
		"x-boo": "boo",
		"x-c++hdr": [
			"h++",
			"hpp",
			"hxx",
			"hh"
		],
		"x-c++src": [
			"c++",
			"cpp",
			"cxx",
			"cc"
		],
		"x-component": "htc",
		"x-dsrc": "d",
		"x-diff": "patch",
		"x-haskell": "hs",
		"x-java": "java",
		"x-literate-haskell": "lhs",
		"x-moc": "moc",
		"x-pascal": [
			"p",
			"pas",
			"pp",
			"inc"
		],
		"x-pcs-gcd": "gcd",
		"x-python": "py",
		"x-scala": "scala",
		"x-setext": "etx",
		"x-tcl": [
			"tcl",
			"tk"
		],
		"x-tex": [
			"tex",
			"ltx",
			"sty",
			"cls"
		],
		"x-vcalendar": "vcs",
		"x-vcard": "vcf",
		"n3": "n3",
		"prs.lines.tag": "dsc",
		"sgml": [
			"sgml",
			"sgm"
		],
		"troff": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		],
		"turtle": "ttl",
		"uri-list": [
			"uri",
			"uris",
			"urls"
		],
		"vcard": "vcard",
		"vnd.curl": "curl",
		"vnd.curl.dcurl": "dcurl",
		"vnd.curl.scurl": "scurl",
		"vnd.curl.mcurl": "mcurl",
		"vnd.dvb.subtitle": "sub",
		"vnd.fly": "fly",
		"vnd.fmi.flexstor": "flx",
		"vnd.graphviz": "gv",
		"vnd.in3d.3dml": "3dml",
		"vnd.in3d.spot": "spot",
		"x-asm": [
			"s",
			"asm"
		],
		"x-c": [
			"c",
			"h",
			"dic"
		],
		"x-fortran": [
			"f",
			"for",
			"f77",
			"f90"
		],
		"x-opml": "opml",
		"x-nfo": "nfo",
		"x-sfv": "sfv",
		"x-uuencode": "uu",
		"webviewhtml": "htt",
		"javascript": "js",
		"json": "json",
		"markdown": [
			"md",
			"markdown",
			"mdown",
			"markdn"
		],
		"vnd.wap.si": "si",
		"vnd.wap.sl": "sl"
	},
	"video": {
		"avif": "avif",
		"3gpp": "3gp",
		"annodex": "axv",
		"dl": "dl",
		"dv": [
			"dif",
			"dv"
		],
		"fli": "fli",
		"gl": "gl",
		"mpeg": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v",
			"mp2",
			"mpa",
			"mpv2"
		],
		"mp4": [
			"mp4",
			"mp4v",
			"mpg4"
		],
		"quicktime": [
			"qt",
			"mov"
		],
		"ogg": "ogv",
		"vnd.mpegurl": [
			"mxu",
			"m4u"
		],
		"x-flv": "flv",
		"x-la-asf": [
			"lsf",
			"lsx"
		],
		"x-mng": "mng",
		"x-ms-asf": [
			"asf",
			"asx",
			"asr"
		],
		"x-ms-wm": "wm",
		"x-ms-wmv": "wmv",
		"x-ms-wmx": "wmx",
		"x-ms-wvx": "wvx",
		"x-msvideo": "avi",
		"x-sgi-movie": "movie",
		"x-matroska": [
			"mpv",
			"mkv",
			"mk3d",
			"mks"
		],
		"3gpp2": "3g2",
		"h261": "h261",
		"h263": "h263",
		"h264": "h264",
		"jpeg": "jpgv",
		"jpm": [
			"jpm",
			"jpgm"
		],
		"mj2": [
			"mj2",
			"mjp2"
		],
		"vnd.dece.hd": [
			"uvh",
			"uvvh"
		],
		"vnd.dece.mobile": [
			"uvm",
			"uvvm"
		],
		"vnd.dece.pd": [
			"uvp",
			"uvvp"
		],
		"vnd.dece.sd": [
			"uvs",
			"uvvs"
		],
		"vnd.dece.video": [
			"uvv",
			"uvvv"
		],
		"vnd.dvb.file": "dvb",
		"vnd.fvt": "fvt",
		"vnd.ms-playready.media.pyv": "pyv",
		"vnd.uvvu.mp4": [
			"uvu",
			"uvvu"
		],
		"vnd.vivo": "viv",
		"webm": "webm",
		"x-f4v": "f4v",
		"x-m4v": "m4v",
		"x-ms-vob": "vob",
		"x-smv": "smv",
		"mp2t": "ts"
	},
	"x-conference": {
		"x-cooltalk": "ice"
	},
	"x-world": {
		"x-vrml": [
			"vrm",
			"flr",
			"wrz",
			"xaf",
			"xof"
		]
	}
};

(() => {
	const mimeTypes = {};
	for (const type of Object.keys(table$1)) {
		for (const subtype of Object.keys(table$1[type])) {
			const value = table$1[type][subtype];
			if (typeof value == "string") {
				mimeTypes[value] = type + "/" + subtype;
			} else {
				for (let indexMimeType = 0; indexMimeType < value.length; indexMimeType++) {
					mimeTypes[value[indexMimeType]] = type + "/" + subtype;
				}
			}
		}
	}
	return mimeTypes;
})();

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const table = [];
for (let i = 0; i < 256; i++) {
	let t = i;
	for (let j = 0; j < 8; j++) {
		if (t & 1) {
			t = (t >>> 1) ^ 0xEDB88320;
		} else {
			t = t >>> 1;
		}
	}
	table[i] = t;
}

class Crc32 {

	constructor(crc) {
		this.crc = crc || -1;
	}

	append(data) {
		let crc = this.crc | 0;
		for (let offset = 0, length = data.length | 0; offset < length; offset++) {
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		}
		this.crc = crc;
	}

	get() {
		return ~this.crc;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


class Crc32Stream extends TransformStream {

	constructor() {
		let stream;
		const crc32 = new Crc32();
		super({
			transform(chunk, controller) {
				crc32.append(chunk);
				controller.enqueue(chunk);
			},
			flush() {
				const value = new Uint8Array(4);
				const dataView = new DataView(value.buffer);
				dataView.setUint32(0, crc32.get());
				stream.value = value;
			}
		});
		stream = this;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


function encodeText(value) {
	if (typeof TextEncoder == UNDEFINED_TYPE) {
		value = unescape(encodeURIComponent(value));
		const result = new Uint8Array(value.length);
		for (let i = 0; i < result.length; i++) {
			result[i] = value.charCodeAt(i);
		}
		return result;
	} else {
		return new TextEncoder().encode(value);
	}
}

// Derived from https://github.com/xqdoo00o/jszip/blob/master/lib/sjcl.js and https://github.com/bitwiseshiftleft/sjcl

// deno-lint-ignore-file no-this-alias

/*
 * SJCL is open. You can use, modify and redistribute it under a BSD
 * license or under the GNU GPL, version 2.0.
 */

/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bits, encoded as arrays of Numbers.
 * @namespace
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
const bitArray = {
	/**
	 * Concatenate two bit arrays.
	 * @param {bitArray} a1 The first array.
	 * @param {bitArray} a2 The second array.
	 * @return {bitArray} The concatenation of a1 and a2.
	 */
	concat(a1, a2) {
		if (a1.length === 0 || a2.length === 0) {
			return a1.concat(a2);
		}

		const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
		if (shift === 32) {
			return a1.concat(a2);
		} else {
			return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
		}
	},

	/**
	 * Find the length of an array of bits.
	 * @param {bitArray} a The array.
	 * @return {Number} The length of a, in bits.
	 */
	bitLength(a) {
		const l = a.length;
		if (l === 0) {
			return 0;
		}
		const x = a[l - 1];
		return (l - 1) * 32 + bitArray.getPartial(x);
	},

	/**
	 * Truncate an array.
	 * @param {bitArray} a The array.
	 * @param {Number} len The length to truncate to, in bits.
	 * @return {bitArray} A new array, truncated to len bits.
	 */
	clamp(a, len) {
		if (a.length * 32 < len) {
			return a;
		}
		a = a.slice(0, Math.ceil(len / 32));
		const l = a.length;
		len = len & 31;
		if (l > 0 && len) {
			a[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> (len - 1), 1);
		}
		return a;
	},

	/**
	 * Make a partial word for a bit array.
	 * @param {Number} len The number of bits in the word.
	 * @param {Number} x The bits.
	 * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
	 * @return {Number} The partial word.
	 */
	partial(len, x, _end) {
		if (len === 32) {
			return x;
		}
		return (_end ? x | 0 : x << (32 - len)) + len * 0x10000000000;
	},

	/**
	 * Get the number of bits used by a partial word.
	 * @param {Number} x The partial word.
	 * @return {Number} The number of bits used by the partial word.
	 */
	getPartial(x) {
		return Math.round(x / 0x10000000000) || 32;
	},

	/** Shift an array right.
	 * @param {bitArray} a The array to shift.
	 * @param {Number} shift The number of bits to shift.
	 * @param {Number} [carry=0] A byte to carry in
	 * @param {bitArray} [out=[]] An array to prepend to the output.
	 * @private
	 */
	_shiftRight(a, shift, carry, out) {
		if (out === undefined) {
			out = [];
		}

		for (; shift >= 32; shift -= 32) {
			out.push(carry);
			carry = 0;
		}
		if (shift === 0) {
			return out.concat(a);
		}

		for (let i = 0; i < a.length; i++) {
			out.push(carry | a[i] >>> shift);
			carry = a[i] << (32 - shift);
		}
		const last2 = a.length ? a[a.length - 1] : 0;
		const shift2 = bitArray.getPartial(last2);
		out.push(bitArray.partial(shift + shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(), 1));
		return out;
	}
};

/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bytes
 * @namespace
 */
const codec = {
	bytes: {
		/** Convert from a bitArray to an array of bytes. */
		fromBits(arr) {
			const bl = bitArray.bitLength(arr);
			const byteLength = bl / 8;
			const out = new Uint8Array(byteLength);
			let tmp;
			for (let i = 0; i < byteLength; i++) {
				if ((i & 3) === 0) {
					tmp = arr[i / 4];
				}
				out[i] = tmp >>> 24;
				tmp <<= 8;
			}
			return out;
		},
		/** Convert from an array of bytes to a bitArray. */
		toBits(bytes) {
			const out = [];
			let i;
			let tmp = 0;
			for (i = 0; i < bytes.length; i++) {
				tmp = tmp << 8 | bytes[i];
				if ((i & 3) === 3) {
					out.push(tmp);
					tmp = 0;
				}
			}
			if (i & 3) {
				out.push(bitArray.partial(8 * (i & 3), tmp));
			}
			return out;
		}
	}
};

const hash = {};

/**
 * Context for a SHA-1 operation in progress.
 * @constructor
 */
hash.sha1 = class {
	constructor(hash) {
		const sha1 = this;
		/**
		 * The hash's block size, in bits.
		 * @constant
		 */
		sha1.blockSize = 512;
		/**
		 * The SHA-1 initialization vector.
		 * @private
		 */
		sha1._init = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
		/**
		 * The SHA-1 hash key.
		 * @private
		 */
		sha1._key = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
		if (hash) {
			sha1._h = hash._h.slice(0);
			sha1._buffer = hash._buffer.slice(0);
			sha1._length = hash._length;
		} else {
			sha1.reset();
		}
	}

	/**
	 * Reset the hash state.
	 * @return this
	 */
	reset() {
		const sha1 = this;
		sha1._h = sha1._init.slice(0);
		sha1._buffer = [];
		sha1._length = 0;
		return sha1;
	}

	/**
	 * Input several words to the hash.
	 * @param {bitArray|String} data the data to hash.
	 * @return this
	 */
	update(data) {
		const sha1 = this;
		if (typeof data === "string") {
			data = codec.utf8String.toBits(data);
		}
		const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
		const ol = sha1._length;
		const nl = sha1._length = ol + bitArray.bitLength(data);
		if (nl > 9007199254740991) {
			throw new Error("Cannot hash more than 2^53 - 1 bits");
		}
		const c = new Uint32Array(b);
		let j = 0;
		for (let i = sha1.blockSize + ol - ((sha1.blockSize + ol) & (sha1.blockSize - 1)); i <= nl;
			i += sha1.blockSize) {
			sha1._block(c.subarray(16 * j, 16 * (j + 1)));
			j += 1;
		}
		b.splice(0, 16 * j);
		return sha1;
	}

	/**
	 * Complete hashing and output the hash value.
	 * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
	 */
	finalize() {
		const sha1 = this;
		let b = sha1._buffer;
		const h = sha1._h;

		// Round out and push the buffer
		b = bitArray.concat(b, [bitArray.partial(1, 1)]);
		// Round out the buffer to a multiple of 16 words, less the 2 length words.
		for (let i = b.length + 2; i & 15; i++) {
			b.push(0);
		}

		// append the length
		b.push(Math.floor(sha1._length / 0x100000000));
		b.push(sha1._length | 0);

		while (b.length) {
			sha1._block(b.splice(0, 16));
		}

		sha1.reset();
		return h;
	}

	/**
	 * The SHA-1 logical functions f(0), f(1), ..., f(79).
	 * @private
	 */
	_f(t, b, c, d) {
		if (t <= 19) {
			return (b & c) | (~b & d);
		} else if (t <= 39) {
			return b ^ c ^ d;
		} else if (t <= 59) {
			return (b & c) | (b & d) | (c & d);
		} else if (t <= 79) {
			return b ^ c ^ d;
		}
	}

	/**
	 * Circular left-shift operator.
	 * @private
	 */
	_S(n, x) {
		return (x << n) | (x >>> 32 - n);
	}

	/**
	 * Perform one cycle of SHA-1.
	 * @param {Uint32Array|bitArray} words one block of words.
	 * @private
	 */
	_block(words) {
		const sha1 = this;
		const h = sha1._h;
		// When words is passed to _block, it has 16 elements. SHA1 _block
		// function extends words with new elements (at the end there are 80 elements). 
		// The problem is that if we use Uint32Array instead of Array, 
		// the length of Uint32Array cannot be changed. Thus, we replace words with a 
		// normal Array here.
		const w = Array(80); // do not use Uint32Array here as the instantiation is slower
		for (let j = 0; j < 16; j++) {
			w[j] = words[j];
		}

		let a = h[0];
		let b = h[1];
		let c = h[2];
		let d = h[3];
		let e = h[4];

		for (let t = 0; t <= 79; t++) {
			if (t >= 16) {
				w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
			}
			const tmp = (sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] +
				sha1._key[Math.floor(t / 20)]) | 0;
			e = d;
			d = c;
			c = sha1._S(30, b);
			b = a;
			a = tmp;
		}

		h[0] = (h[0] + a) | 0;
		h[1] = (h[1] + b) | 0;
		h[2] = (h[2] + c) | 0;
		h[3] = (h[3] + d) | 0;
		h[4] = (h[4] + e) | 0;
	}
};

/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

const cipher = {};

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 */
cipher.aes = class {
	constructor(key) {
		/**
		 * The expanded S-box and inverse S-box tables.  These will be computed
		 * on the client so that we don't have to send them down the wire.
		 *
		 * There are two tables, _tables[0] is for encryption and
		 * _tables[1] is for decryption.
		 *
		 * The first 4 sub-tables are the expanded S-box with MixColumns.  The
		 * last (_tables[01][4]) is the S-box itself.
		 *
		 * @private
		 */
		const aes = this;
		aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];

		if (!aes._tables[0][0][0]) {
			aes._precompute();
		}

		const sbox = aes._tables[0][4];
		const decTable = aes._tables[1];
		const keyLen = key.length;

		let i, encKey, decKey, rcon = 1;

		if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
			throw new Error("invalid aes key size");
		}

		aes._key = [encKey = key.slice(0), decKey = []];

		// schedule encryption keys
		for (i = keyLen; i < 4 * keyLen + 28; i++) {
			let tmp = encKey[i - 1];

			// apply sbox
			if (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {
				tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];

				// shift rows and add rcon
				if (i % keyLen === 0) {
					tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
					rcon = rcon << 1 ^ (rcon >> 7) * 283;
				}
			}

			encKey[i] = encKey[i - keyLen] ^ tmp;
		}

		// schedule decryption keys
		for (let j = 0; i; j++, i--) {
			const tmp = encKey[j & 3 ? i : i - 4];
			if (i <= 4 || j < 4) {
				decKey[j] = tmp;
			} else {
				decKey[j] = decTable[0][sbox[tmp >>> 24]] ^
					decTable[1][sbox[tmp >> 16 & 255]] ^
					decTable[2][sbox[tmp >> 8 & 255]] ^
					decTable[3][sbox[tmp & 255]];
			}
		}
	}
	// public
	/* Something like this might appear here eventually
	name: "AES",
	blockSize: 4,
	keySizes: [4,6,8],
	*/

	/**
	 * Encrypt an array of 4 big-endian words.
	 * @param {Array} data The plaintext.
	 * @return {Array} The ciphertext.
	 */
	encrypt(data) {
		return this._crypt(data, 0);
	}

	/**
	 * Decrypt an array of 4 big-endian words.
	 * @param {Array} data The ciphertext.
	 * @return {Array} The plaintext.
	 */
	decrypt(data) {
		return this._crypt(data, 1);
	}

	/**
	 * Expand the S-box tables.
	 *
	 * @private
	 */
	_precompute() {
		const encTable = this._tables[0];
		const decTable = this._tables[1];
		const sbox = encTable[4];
		const sboxInv = decTable[4];
		const d = [];
		const th = [];
		let xInv, x2, x4, x8;

		// Compute double and third tables
		for (let i = 0; i < 256; i++) {
			th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
		}

		for (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
			// Compute sbox
			let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
			s = s >> 8 ^ s & 255 ^ 99;
			sbox[x] = s;
			sboxInv[s] = x;

			// Compute MixColumns
			x8 = d[x4 = d[x2 = d[x]]];
			let tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
			let tEnc = d[s] * 0x101 ^ s * 0x1010100;

			for (let i = 0; i < 4; i++) {
				encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
				decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
			}
		}

		// Compactify.  Considerable speedup on Firefox.
		for (let i = 0; i < 5; i++) {
			encTable[i] = encTable[i].slice(0);
			decTable[i] = decTable[i].slice(0);
		}
	}

	/**
	 * Encryption and decryption core.
	 * @param {Array} input Four words to be encrypted or decrypted.
	 * @param dir The direction, 0 for encrypt and 1 for decrypt.
	 * @return {Array} The four encrypted or decrypted words.
	 * @private
	 */
	_crypt(input, dir) {
		if (input.length !== 4) {
			throw new Error("invalid aes block size");
		}

		const key = this._key[dir];

		const nInnerRounds = key.length / 4 - 2;
		const out = [0, 0, 0, 0];
		const table = this._tables[dir];

		// load up the tables
		const t0 = table[0];
		const t1 = table[1];
		const t2 = table[2];
		const t3 = table[3];
		const sbox = table[4];

		// state variables a,b,c,d are loaded with pre-whitened data
		let a = input[0] ^ key[0];
		let b = input[dir ? 3 : 1] ^ key[1];
		let c = input[2] ^ key[2];
		let d = input[dir ? 1 : 3] ^ key[3];
		let kIndex = 4;
		let a2, b2, c2;

		// Inner rounds.  Cribbed from OpenSSL.
		for (let i = 0; i < nInnerRounds; i++) {
			a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
			b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
			c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
			d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
			kIndex += 4;
			a = a2; b = b2; c = c2;
		}

		// Last round.
		for (let i = 0; i < 4; i++) {
			out[dir ? 3 & -i : i] =
				sbox[a >>> 24] << 24 ^
				sbox[b >> 16 & 255] << 16 ^
				sbox[c >> 8 & 255] << 8 ^
				sbox[d & 255] ^
				key[kIndex++];
			a2 = a; a = b; b = c; c = d; d = a2;
		}

		return out;
	}
};

/**
 * Random values
 * @namespace
 */
const random = {
	/** 
	 * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
	 * @param {TypedArray} typedArray The array to fill.
	 * @return {TypedArray} The random values.
	 */
	getRandomValues(typedArray) {
		const words = new Uint32Array(typedArray.buffer);
		const r = (m_w) => {
			let m_z = 0x3ade68b1;
			const mask = 0xffffffff;
			return function () {
				m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
				m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
				const result = ((((m_z << 0x10) + m_w) & mask) / 0x100000000) + .5;
				return result * (Math.random() > .5 ? 1 : -1);
			};
		};
		for (let i = 0, rcache; i < typedArray.length; i += 4) {
			const _r = r((rcache || Math.random()) * 0x100000000);
			rcache = _r() * 0x3ade67b7;
			words[i / 4] = (_r() * 0x100000000) | 0;
		}
		return typedArray;
	}
};

/** @fileOverview CTR mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Brian Gladman's CTR Mode.
* @constructor
* @param {Object} _prf The aes instance to generate key.
* @param {bitArray} _iv The iv for ctr mode, it must be 128 bits.
*/

const mode = {};

/**
 * Brian Gladman's CTR Mode.
 * @namespace
 */
mode.ctrGladman = class {
	constructor(prf, iv) {
		this._prf = prf;
		this._initIv = iv;
		this._iv = iv;
	}

	reset() {
		this._iv = this._initIv;
	}

	/** Input some data to calculate.
	 * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
	 */
	update(data) {
		return this.calculate(this._prf, data, this._iv);
	}

	incWord(word) {
		if (((word >> 24) & 0xff) === 0xff) { //overflow
			let b1 = (word >> 16) & 0xff;
			let b2 = (word >> 8) & 0xff;
			let b3 = word & 0xff;

			if (b1 === 0xff) { // overflow b1   
				b1 = 0;
				if (b2 === 0xff) {
					b2 = 0;
					if (b3 === 0xff) {
						b3 = 0;
					} else {
						++b3;
					}
				} else {
					++b2;
				}
			} else {
				++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
		} else {
			word += (0x01 << 24);
		}
		return word;
	}

	incCounter(counter) {
		if ((counter[0] = this.incWord(counter[0])) === 0) {
			// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
			counter[1] = this.incWord(counter[1]);
		}
	}

	calculate(prf, data, iv) {
		let l;
		if (!(l = data.length)) {
			return [];
		}
		const bl = bitArray.bitLength(data);
		for (let i = 0; i < l; i += 4) {
			this.incCounter(iv);
			const e = prf.encrypt(iv);
			data[i] ^= e[0];
			data[i + 1] ^= e[1];
			data[i + 2] ^= e[2];
			data[i + 3] ^= e[3];
		}
		return bitArray.clamp(data, bl);
	}
};

const misc = {
	importKey(password) {
		return new misc.hmacSha1(codec.bytes.toBits(password));
	},
	pbkdf2(prf, salt, count, length) {
		count = count || 10000;
		if (length < 0 || count < 0) {
			throw new Error("invalid params to pbkdf2");
		}
		const byteLength = ((length >> 5) + 1) << 2;
		let u, ui, i, j, k;
		const arrayBuffer = new ArrayBuffer(byteLength);
		const out = new DataView(arrayBuffer);
		let outLength = 0;
		const b = bitArray;
		salt = codec.bytes.toBits(salt);
		for (k = 1; outLength < (byteLength || 1); k++) {
			u = ui = prf.encrypt(b.concat(salt, [k]));
			for (i = 1; i < count; i++) {
				ui = prf.encrypt(ui);
				for (j = 0; j < ui.length; j++) {
					u[j] ^= ui[j];
				}
			}
			for (i = 0; outLength < (byteLength || 1) && i < u.length; i++) {
				out.setInt32(outLength, u[i]);
				outLength += 4;
			}
		}
		return arrayBuffer.slice(0, length / 8);
	}
};

/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [Hash=hash.sha1] The hash function to use.
 */
misc.hmacSha1 = class {

	constructor(key) {
		const hmac = this;
		const Hash = hmac._hash = hash.sha1;
		const exKey = [[], []];
		hmac._baseHash = [new Hash(), new Hash()];
		const bs = hmac._baseHash[0].blockSize / 32;

		if (key.length > bs) {
			key = new Hash().update(key).finalize();
		}

		for (let i = 0; i < bs; i++) {
			exKey[0][i] = key[i] ^ 0x36363636;
			exKey[1][i] = key[i] ^ 0x5C5C5C5C;
		}

		hmac._baseHash[0].update(exKey[0]);
		hmac._baseHash[1].update(exKey[1]);
		hmac._resultHash = new Hash(hmac._baseHash[0]);
	}
	reset() {
		const hmac = this;
		hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
		hmac._updated = false;
	}

	update(data) {
		const hmac = this;
		hmac._updated = true;
		hmac._resultHash.update(data);
	}

	digest() {
		const hmac = this;
		const w = hmac._resultHash.finalize();
		const result = new (hmac._hash)(hmac._baseHash[1]).update(w).finalize();

		hmac.reset();

		return result;
	}

	encrypt(data) {
		if (!this._updated) {
			this.update(data);
			return this.digest(data);
		} else {
			throw new Error("encrypt on already updated hmac called!");
		}
	}
};

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const GET_RANDOM_VALUES_SUPPORTED = typeof crypto != UNDEFINED_TYPE && typeof crypto.getRandomValues == FUNCTION_TYPE;

const ERR_INVALID_PASSWORD = "Invalid password";
const ERR_INVALID_SIGNATURE = "Invalid signature";
const ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";

function getRandomValues(array) {
	if (GET_RANDOM_VALUES_SUPPORTED) {
		return crypto.getRandomValues(array);
	} else {
		return random.getRandomValues(array);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = { name: "PBKDF2" };
const HASH_ALGORITHM = { name: "HMAC" };
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1000, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = ["deriveBits"];
const SALT_LENGTH = [8, 12, 16];
const KEY_LENGTH = [16, 24, 32];
const SIGNATURE_LENGTH = 10;
const COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];
// deno-lint-ignore valid-typeof
const CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE;
const subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
const SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE;
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;

let IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE;
let DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE;

class AESDecryptionStream extends TransformStream {

	constructor({ password, rawPassword, signed, encryptionStrength, checkPasswordOnly }) {
		super({
			start() {
				Object.assign(this, {
					ready: new Promise(resolve => this.resolveReady = resolve),
					password: encodePassword(password, rawPassword),
					signed,
					strength: encryptionStrength - 1,
					pending: new Uint8Array()
				});
			},
			async transform(chunk, controller) {
				const aesCrypto = this;
				const {
					password,
					strength,
					resolveReady,
					ready
				} = aesCrypto;
				if (password) {
					await createDecryptionKeys(aesCrypto, strength, password, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
					chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
					if (checkPasswordOnly) {
						controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
					} else {
						resolveReady();
					}
				} else {
					await ready;
				}
				const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - ((chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH));
				controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));
			},
			async flush(controller) {
				const {
					signed,
					ctr,
					hmac,
					pending,
					ready
				} = this;
				if (hmac && ctr) {
					await ready;
					const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
					const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
					let decryptedChunkArray = new Uint8Array();
					if (chunkToDecrypt.length) {
						const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
						hmac.update(encryptedChunk);
						const decryptedChunk = ctr.update(encryptedChunk);
						decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
					}
					if (signed) {
						const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);
						for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {
							if (signature[indexSignature] != originalSignature[indexSignature]) {
								throw new Error(ERR_INVALID_SIGNATURE);
							}
						}
					}
					controller.enqueue(decryptedChunkArray);
				}
			}
		});
	}
}

class AESEncryptionStream extends TransformStream {

	constructor({ password, rawPassword, encryptionStrength }) {
		// deno-lint-ignore prefer-const
		let stream;
		super({
			start() {
				Object.assign(this, {
					ready: new Promise(resolve => this.resolveReady = resolve),
					password: encodePassword(password, rawPassword),
					strength: encryptionStrength - 1,
					pending: new Uint8Array()
				});
			},
			async transform(chunk, controller) {
				const aesCrypto = this;
				const {
					password,
					strength,
					resolveReady,
					ready
				} = aesCrypto;
				let preamble = new Uint8Array();
				if (password) {
					preamble = await createEncryptionKeys(aesCrypto, strength, password);
					resolveReady();
				} else {
					await ready;
				}
				const output = new Uint8Array(preamble.length + chunk.length - (chunk.length % BLOCK_LENGTH));
				output.set(preamble, 0);
				controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
			},
			async flush(controller) {
				const {
					ctr,
					hmac,
					pending,
					ready
				} = this;
				if (hmac && ctr) {
					await ready;
					let encryptedChunkArray = new Uint8Array();
					if (pending.length) {
						const encryptedChunk = ctr.update(toBits(codecBytes, pending));
						hmac.update(encryptedChunk);
						encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
					}
					stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
					controller.enqueue(concat(encryptedChunkArray, stream.signature));
				}
			}
		});
		stream = this;
	}
}

function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
	const {
		ctr,
		hmac,
		pending
	} = aesCrypto;
	const inputLength = input.length - paddingEnd;
	if (pending.length) {
		input = concat(pending, input);
		output = expand(output, inputLength - (inputLength % BLOCK_LENGTH));
	}
	let offset;
	for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {
		const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
		if (verifySignature) {
			hmac.update(inputChunk);
		}
		const outputChunk = ctr.update(inputChunk);
		if (!verifySignature) {
			hmac.update(outputChunk);
		}
		output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
	}
	aesCrypto.pending = subarray(input, offset);
	return output;
}

async function createDecryptionKeys(decrypt, strength, password, preamble) {
	const passwordVerificationKey = await createKeys$1(decrypt, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
	const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
	if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
		throw new Error(ERR_INVALID_PASSWORD);
	}
}

async function createEncryptionKeys(encrypt, strength, password) {
	const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));
	const passwordVerification = await createKeys$1(encrypt, strength, password, salt);
	return concat(salt, passwordVerification);
}

async function createKeys$1(aesCrypto, strength, password, salt) {
	aesCrypto.password = null;
	const baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
	const derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), baseKey, 8 * ((KEY_LENGTH[strength] * 2) + 2));
	const compositeKey = new Uint8Array(derivedBits);
	const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
	const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
	const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
	Object.assign(aesCrypto, {
		keys: {
			key,
			authentication,
			passwordVerification
		},
		ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
		hmac: new HmacSha1(authentication)
	});
	return passwordVerification;
}

async function importKey(format, password, algorithm, extractable, keyUsages) {
	if (IMPORT_KEY_SUPPORTED) {
		try {
			return await subtle.importKey(format, password, algorithm, extractable, keyUsages);
		} catch (_error) {
			IMPORT_KEY_SUPPORTED = false;
			return misc.importKey(password);
		}
	} else {
		return misc.importKey(password);
	}
}

async function deriveBits(algorithm, baseKey, length) {
	if (DERIVE_BITS_SUPPORTED) {
		try {
			return await subtle.deriveBits(algorithm, baseKey, length);
		} catch (_error) {
			DERIVE_BITS_SUPPORTED = false;
			return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
		}
	} else {
		return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
	}
}

function encodePassword(password, rawPassword) {
	if (rawPassword === UNDEFINED_VALUE) {
		return encodeText(password);
	} else {
		return rawPassword;
	}
}

function concat(leftArray, rightArray) {
	let array = leftArray;
	if (leftArray.length + rightArray.length) {
		array = new Uint8Array(leftArray.length + rightArray.length);
		array.set(leftArray, 0);
		array.set(rightArray, leftArray.length);
	}
	return array;
}

function expand(inputArray, length) {
	if (length && length > inputArray.length) {
		const array = inputArray;
		inputArray = new Uint8Array(length);
		inputArray.set(array, 0);
	}
	return inputArray;
}

function subarray(array, begin, end) {
	return array.subarray(begin, end);
}

function fromBits(codecBytes, chunk) {
	return codecBytes.fromBits(chunk);
}
function toBits(codecBytes, chunk) {
	return codecBytes.toBits(chunk);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const HEADER_LENGTH = 12;

class ZipCryptoDecryptionStream extends TransformStream {

	constructor({ password, passwordVerification, checkPasswordOnly }) {
		super({
			start() {
				Object.assign(this, {
					password,
					passwordVerification
				});
				createKeys(this, password);
			},
			transform(chunk, controller) {
				const zipCrypto = this;
				if (zipCrypto.password) {
					const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
					zipCrypto.password = null;
					if (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {
						throw new Error(ERR_INVALID_PASSWORD);
					}
					chunk = chunk.subarray(HEADER_LENGTH);
				}
				if (checkPasswordOnly) {
					controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
				} else {
					controller.enqueue(decrypt(zipCrypto, chunk));
				}
			}
		});
	}
}

class ZipCryptoEncryptionStream extends TransformStream {

	constructor({ password, passwordVerification }) {
		super({
			start() {
				Object.assign(this, {
					password,
					passwordVerification
				});
				createKeys(this, password);
			},
			transform(chunk, controller) {
				const zipCrypto = this;
				let output;
				let offset;
				if (zipCrypto.password) {
					zipCrypto.password = null;
					const header = getRandomValues(new Uint8Array(HEADER_LENGTH));
					header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
					output = new Uint8Array(chunk.length + header.length);
					output.set(encrypt(zipCrypto, header), 0);
					offset = HEADER_LENGTH;
				} else {
					output = new Uint8Array(chunk.length);
					offset = 0;
				}
				output.set(encrypt(zipCrypto, chunk), offset);
				controller.enqueue(output);
			}
		});
	}
}

function decrypt(target, input) {
	const output = new Uint8Array(input.length);
	for (let index = 0; index < input.length; index++) {
		output[index] = getByte(target) ^ input[index];
		updateKeys(target, output[index]);
	}
	return output;
}

function encrypt(target, input) {
	const output = new Uint8Array(input.length);
	for (let index = 0; index < input.length; index++) {
		output[index] = getByte(target) ^ input[index];
		updateKeys(target, input[index]);
	}
	return output;
}

function createKeys(target, password) {
	const keys = [0x12345678, 0x23456789, 0x34567890];
	Object.assign(target, {
		keys,
		crcKey0: new Crc32(keys[0]),
		crcKey2: new Crc32(keys[2]),
	});
	for (let index = 0; index < password.length; index++) {
		updateKeys(target, password.charCodeAt(index));
	}
}

function updateKeys(target, byte) {
	let [key0, key1, key2] = target.keys;
	target.crcKey0.append([byte]);
	key0 = ~target.crcKey0.get();
	key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
	target.crcKey2.append([key1 >>> 24]);
	key2 = ~target.crcKey2.get();
	target.keys = [key0, key1, key2];
}

function getByte(target) {
	const temp = target.keys[2] | 2;
	return getInt8(Math.imul(temp, (temp ^ 1)) >>> 8);
}

function getInt8(number) {
	return number & 0xFF;
}

function getInt32(number) {
	return number & 0xFFFFFFFF;
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const COMPRESSION_FORMAT = "deflate-raw";

class DeflateStream extends TransformStream {

	constructor(options, { chunkSize, CompressionStream, CompressionStreamNative }) {
		super({});
		const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level } = options;
		const stream = this;
		let crc32Stream, encryptionStream;
		let readable = filterEmptyChunks(super.readable);
		if ((!encrypted || zipCrypto) && signed) {
			crc32Stream = new Crc32Stream();
			readable = pipeThrough(readable, crc32Stream);
		}
		if (compressed) {
			readable = pipeThroughCommpressionStream(readable, useCompressionStream, { level, chunkSize }, CompressionStreamNative, CompressionStream);
		}
		if (encrypted) {
			if (zipCrypto) {
				readable = pipeThrough(readable, new ZipCryptoEncryptionStream(options));
			} else {
				encryptionStream = new AESEncryptionStream(options);
				readable = pipeThrough(readable, encryptionStream);
			}
		}
		setReadable(stream, readable, () => {
			let signature;
			if (encrypted && !zipCrypto) {
				signature = encryptionStream.signature;
			}
			if ((!encrypted || zipCrypto) && signed) {
				signature = new DataView(crc32Stream.value.buffer).getUint32(0);
			}
			stream.signature = signature;
		});
	}
}

class InflateStream extends TransformStream {

	constructor(options, { chunkSize, DecompressionStream, DecompressionStreamNative }) {
		super({});
		const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream } = options;
		let crc32Stream, decryptionStream;
		let readable = filterEmptyChunks(super.readable);
		if (encrypted) {
			if (zipCrypto) {
				readable = pipeThrough(readable, new ZipCryptoDecryptionStream(options));
			} else {
				decryptionStream = new AESDecryptionStream(options);
				readable = pipeThrough(readable, decryptionStream);
			}
		}
		if (compressed) {
			readable = pipeThroughCommpressionStream(readable, useCompressionStream, { chunkSize }, DecompressionStreamNative, DecompressionStream);
		}
		if ((!encrypted || zipCrypto) && signed) {
			crc32Stream = new Crc32Stream();
			readable = pipeThrough(readable, crc32Stream);
		}
		setReadable(this, readable, () => {
			if ((!encrypted || zipCrypto) && signed) {
				const dataViewSignature = new DataView(crc32Stream.value.buffer);
				if (signature != dataViewSignature.getUint32(0, false)) {
					throw new Error(ERR_INVALID_SIGNATURE);
				}
			}
		});
	}
}

function filterEmptyChunks(readable) {
	return pipeThrough(readable, new TransformStream({
		transform(chunk, controller) {
			if (chunk && chunk.length) {
				controller.enqueue(chunk);
			}
		}
	}));
}

function setReadable(stream, readable, flush) {
	readable = pipeThrough(readable, new TransformStream({ flush }));
	Object.defineProperty(stream, "readable", {
		get() {
			return readable;
		}
	});
}

function pipeThroughCommpressionStream(readable, useCompressionStream, options, CodecStreamNative, CodecStream) {
	try {
		const CompressionStream = useCompressionStream && CodecStreamNative ? CodecStreamNative : CodecStream;
		readable = pipeThrough(readable, new CompressionStream(COMPRESSION_FORMAT, options));
	} catch (error) {
		if (useCompressionStream) {
			try {
				readable = pipeThrough(readable, new CodecStream(COMPRESSION_FORMAT, options));
			} catch (error) {
				return readable;
			}
		} else {
			return readable;
		}
	}
	return readable;
}

function pipeThrough(readable, transformStream) {
	return readable.pipeThrough(transformStream);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const MESSAGE_EVENT_TYPE = "message";
const MESSAGE_START = "start";
const MESSAGE_PULL = "pull";
const MESSAGE_DATA = "data";
const MESSAGE_ACK_DATA = "ack";
const MESSAGE_CLOSE = "close";
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";

class CodecStream extends TransformStream {

	constructor(options, config) {
		super({});
		const codec = this;
		const { codecType } = options;
		let Stream;
		if (codecType.startsWith(CODEC_DEFLATE)) {
			Stream = DeflateStream;
		} else if (codecType.startsWith(CODEC_INFLATE)) {
			Stream = InflateStream;
		}
		let outputSize = 0;
		let inputSize = 0;
		const stream = new Stream(options, config);
		const readable = super.readable;
		const inputSizeStream = new TransformStream({
			transform(chunk, controller) {
				if (chunk && chunk.length) {
					inputSize += chunk.length;
					controller.enqueue(chunk);
				}
			},
			flush() {
				Object.assign(codec, {
					inputSize
				});
			}
		});
		const outputSizeStream = new TransformStream({
			transform(chunk, controller) {
				if (chunk && chunk.length) {
					outputSize += chunk.length;
					controller.enqueue(chunk);
				}
			},
			flush() {
				const { signature } = stream;
				Object.assign(codec, {
					signature,
					outputSize,
					inputSize
				});
			}
		});
		Object.defineProperty(codec, "readable", {
			get() {
				return readable.pipeThrough(inputSizeStream).pipeThrough(stream).pipeThrough(outputSizeStream);
			}
		});
	}
}

class ChunkStream extends TransformStream {

	constructor(chunkSize) {
		let pendingChunk;
		super({
			transform,
			flush(controller) {
				if (pendingChunk && pendingChunk.length) {
					controller.enqueue(pendingChunk);
				}
			}
		});

		function transform(chunk, controller) {
			if (pendingChunk) {
				const newChunk = new Uint8Array(pendingChunk.length + chunk.length);
				newChunk.set(pendingChunk);
				newChunk.set(chunk, pendingChunk.length);
				chunk = newChunk;
				pendingChunk = null;
			}
			if (chunk.length > chunkSize) {
				controller.enqueue(chunk.slice(0, chunkSize));
				transform(chunk.slice(chunkSize), controller);
			} else {
				pendingChunk = chunk;
			}
		}
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


// deno-lint-ignore valid-typeof
let WEB_WORKERS_SUPPORTED = typeof Worker != UNDEFINED_TYPE;

class CodecWorker {

	constructor(workerData, { readable, writable }, { options, config, streamOptions, useWebWorkers, transferStreams, scripts }, onTaskFinished) {
		const { signal } = streamOptions;
		Object.assign(workerData, {
			busy: true,
			readable: readable
				.pipeThrough(new ChunkStream(config.chunkSize))
				.pipeThrough(new ProgressWatcherStream(readable, streamOptions), { signal }),
			writable,
			options: Object.assign({}, options),
			scripts,
			transferStreams,
			terminate() {
				return new Promise(resolve => {
					const { worker, busy } = workerData;
					if (worker) {
						if (busy) {
							workerData.resolveTerminated = resolve;
						} else {
							worker.terminate();
							resolve();
						}
						workerData.interface = null;
					} else {
						resolve();
					}
				});
			},
			onTaskFinished() {
				const { resolveTerminated } = workerData;
				if (resolveTerminated) {
					workerData.resolveTerminated = null;
					workerData.terminated = true;
					workerData.worker.terminate();
					resolveTerminated();
				}
				workerData.busy = false;
				onTaskFinished(workerData);
			}
		});
		return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config);
	}
}

class ProgressWatcherStream extends TransformStream {

	constructor(readableSource, { onstart, onprogress, size, onend }) {
		let chunkOffset = 0;
		super({
			async start() {
				if (onstart) {
					await callHandler(onstart, size);
				}
			},
			async transform(chunk, controller) {
				chunkOffset += chunk.length;
				if (onprogress) {
					await callHandler(onprogress, chunkOffset, size);
				}
				controller.enqueue(chunk);
			},
			async flush() {
				readableSource.size = chunkOffset;
				if (onend) {
					await callHandler(onend, chunkOffset);
				}
			}
		});
	}
}

async function callHandler(handler, ...parameters) {
	try {
		await handler(...parameters);
	} catch (_error) {
		// ignored
	}
}

function createWorkerInterface(workerData, config) {
	return {
		run: () => runWorker$1(workerData, config)
	};
}

function createWebWorkerInterface(workerData, config) {
	const { baseURL, chunkSize } = config;
	if (!workerData.interface) {
		let worker;
		try {
			worker = getWebWorker(workerData.scripts[0], baseURL, workerData);
		} catch (error) {
			WEB_WORKERS_SUPPORTED = false;
			return createWorkerInterface(workerData, config);
		}
		Object.assign(workerData, {
			worker,
			interface: {
				run: () => runWebWorker(workerData, { chunkSize })
			}
		});
	}
	return workerData.interface;
}

async function runWorker$1({ options, readable, writable, onTaskFinished }, config) {
	try {
		const codecStream = new CodecStream(options, config);
		await readable.pipeThrough(codecStream).pipeTo(writable, { preventClose: true, preventAbort: true });
		const {
			signature,
			inputSize,
			outputSize
		} = codecStream;
		return {
			signature,
			inputSize,
			outputSize
		};
	} finally {
		onTaskFinished();
	}
}

async function runWebWorker(workerData, config) {
	let resolveResult, rejectResult;
	const result = new Promise((resolve, reject) => {
		resolveResult = resolve;
		rejectResult = reject;
	});
	Object.assign(workerData, {
		reader: null,
		writer: null,
		resolveResult,
		rejectResult,
		result
	});
	const { readable, options, scripts } = workerData;
	const { writable, closed } = watchClosedStream(workerData.writable);
	const streamsTransferred = sendMessage({
		type: MESSAGE_START,
		scripts: scripts.slice(1),
		options,
		config,
		readable,
		writable
	}, workerData);
	if (!streamsTransferred) {
		Object.assign(workerData, {
			reader: readable.getReader(),
			writer: writable.getWriter()
		});
	}
	const resultValue = await result;
	try {
		await writable.getWriter().close();
	} catch (_error) {
		// ignored
	}
	await closed;
	return resultValue;
}

function watchClosedStream(writableSource) {
	let resolveStreamClosed;
	const closed = new Promise(resolve => resolveStreamClosed = resolve);
	const writable = new WritableStream({
		async write(chunk) {
			const writer = writableSource.getWriter();
			await writer.ready;
			await writer.write(chunk);
			writer.releaseLock();
		},
		close() {
			resolveStreamClosed();
		},
		abort(reason) {
			const writer = writableSource.getWriter();
			return writer.abort(reason);
		}
	});
	return { writable, closed };
}

let classicWorkersSupported = true;
let transferStreamsSupported = true;

function getWebWorker(url, baseURL, workerData) {
	const workerOptions = { type: "module" };
	let scriptUrl, worker;
	// deno-lint-ignore valid-typeof
	if (typeof url == FUNCTION_TYPE) {
		url = url();
	}
	try {
		scriptUrl = new URL(url, baseURL);
	} catch (_error) {
		scriptUrl = url;
	}
	if (classicWorkersSupported) {
		try {
			worker = new Worker(scriptUrl);
		} catch (_error) {
			classicWorkersSupported = false;
			worker = new Worker(scriptUrl, workerOptions);
		}
	} else {
		worker = new Worker(scriptUrl, workerOptions);
	}
	worker.addEventListener(MESSAGE_EVENT_TYPE, event => onMessage(event, workerData));
	return worker;
}

function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
	try {
		let { value, readable, writable } = message;
		const transferables = [];
		if (value) {
			if (value.byteLength < value.buffer.byteLength) {
				message.value = value.buffer.slice(0, value.byteLength);
			}
			else {
				message.value = value.buffer;
			}
			transferables.push(message.value);
		}
		if (transferStreams && transferStreamsSupported) {
			if (readable) {
				transferables.push(readable);
			}
			if (writable) {
				transferables.push(writable);
			}
		} else {
			message.readable = message.writable = null;
		}
		if (transferables.length) {
			try {
				worker.postMessage(message, transferables);
				return true;
			} catch (_error) {
				transferStreamsSupported = false;
				message.readable = message.writable = null;
				worker.postMessage(message);
			}
		} else {
			worker.postMessage(message);
		}
	} catch (error) {
		if (writer) {
			writer.releaseLock();
		}
		onTaskFinished();
		throw error;
	}
}

async function onMessage({ data }, workerData) {
	const { type, value, messageId, result, error } = data;
	const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
	try {
		if (error) {
			const { message, stack, code, name } = error;
			const responseError = new Error(message);
			Object.assign(responseError, { stack, code, name });
			close(responseError);
		} else {
			if (type == MESSAGE_PULL) {
				const { value, done } = await reader.read();
				sendMessage({ type: MESSAGE_DATA, value, done, messageId }, workerData);
			}
			if (type == MESSAGE_DATA) {
				await writer.ready;
				await writer.write(new Uint8Array(value));
				sendMessage({ type: MESSAGE_ACK_DATA, messageId }, workerData);
			}
			if (type == MESSAGE_CLOSE) {
				close(null, result);
			}
		}
	} catch (error) {
		sendMessage({ type: MESSAGE_CLOSE, messageId }, workerData);
		close(error);
	}

	function close(error, result) {
		if (error) {
			rejectResult(error);
		} else {
			resolveResult(result);
		}
		if (writer) {
			writer.releaseLock();
		}
		onTaskFinished();
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


let pool = [];
const pendingRequests = [];

let indexWorker = 0;

async function runWorker(stream, workerOptions) {
	const { options, config } = workerOptions;
	const { transferStreams, useWebWorkers, useCompressionStream, codecType, compressed, signed, encrypted } = options;
	const { workerScripts, maxWorkers } = config;
	workerOptions.transferStreams = transferStreams || transferStreams === UNDEFINED_VALUE;
	const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
	workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || (useWebWorkers === UNDEFINED_VALUE && config.useWebWorkers));
	workerOptions.scripts = workerOptions.useWebWorkers && workerScripts ? workerScripts[codecType] : [];
	options.useCompressionStream = useCompressionStream || (useCompressionStream === UNDEFINED_VALUE && config.useCompressionStream);
	return (await getWorker()).run();

	async function getWorker() {
		const workerData = pool.find(workerData => !workerData.busy);
		if (workerData) {
			clearTerminateTimeout(workerData);
			return new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
		} else if (pool.length < maxWorkers) {
			const workerData = { indexWorker };
			indexWorker++;
			pool.push(workerData);
			return new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
		} else {
			return new Promise(resolve => pendingRequests.push({ resolve, stream, workerOptions }));
		}
	}

	function onTaskFinished(workerData) {
		if (pendingRequests.length) {
			const [{ resolve, stream, workerOptions }] = pendingRequests.splice(0, 1);
			resolve(new CodecWorker(workerData, stream, workerOptions, onTaskFinished));
		} else if (workerData.worker) {
			clearTerminateTimeout(workerData);
			terminateWorker(workerData, workerOptions);
		} else {
			pool = pool.filter(data => data != workerData);
		}
	}
}

function terminateWorker(workerData, workerOptions) {
	const { config } = workerOptions;
	const { terminateWorkerTimeout } = config;
	if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
		if (workerData.terminated) {
			workerData.terminated = false;
		} else {
			workerData.terminateTimeout = setTimeout(async () => {
				pool = pool.filter(data => data != workerData);
				try {
					await workerData.terminate();
				} catch (_error) {
					// ignored
				}
			}, terminateWorkerTimeout);
		}
	}
}

function clearTerminateTimeout(workerData) {
	const { terminateTimeout } = workerData;
	if (terminateTimeout) {
		clearTimeout(terminateTimeout);
		workerData.terminateTimeout = null;
	}
}

function e(e){const t=()=>URL.createObjectURL(new Blob(['const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={p:{m(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)0==(3&s)&&(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},g(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3==(3&n)&&(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t.A=e.A):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e.A=0,e}update(e){const t=this;"string"==typeof e&&(e=I._.g(e));const n=t.C=_.concat(t.C,e),r=t.A,i=t.A=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}P(){const e=this;let t=e.C;const n=e.S;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e.A/4294967296)),t.push(0|e.A);t.length;)e.I(t.splice(0,16));return e.reset(),n}D(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}V(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.V(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.V(5,o)+n.D(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.V(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.R(I.p.g(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.p.g(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=P,r=[[],[]];t.U=[new n,new n];const s=t.U[0].blockSize/32;e.length>s&&(e=(new n).update(e).P());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.U[0].update(r[0]),t.U[1].update(r[1]),t.K=new n(t.U[0])}reset(){const e=this;e.K=new e.M(e.U[0]),e.N=!1}update(e){this.N=!0,this.K.update(e)}digest(){const e=this,t=e.K.P(),n=new e.M(e.U[1]).update(t).P();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.p,X=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255==(e>>24&255)){let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.R;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),signed:r,X:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:o,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.B(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.B(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,$:u,passwordVerification:w},Y:new Y(new X(l),e.from(F)),Z:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.m(t)}function ae(e,t){return e.g(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new x(r[0]),te:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0});try{await c.getWriter().close()}catch(e){}const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Le(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}He.ge=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.Se=e=>256>e?je[e]:je[256+(e>>>7)],He.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He.Ae=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le._e=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Ie=e,i.Pe=t,i.De=n,i.Ve=r,i.Re=s}Le.Be=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Ee=new Le(Le._e,He.ze,257,286,15),Le.Me=new Le(Le.Be,He.Ce,0,30,15),Le.Ue=new Le(null,He.xe,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ke[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ge[n]+256+1)]++,M[2*He.Se(t)]++),0==(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=He.ge[s],Y(i+256+1,t),o=He.ze[i],0!==o&&(s-=He.ke[i],X(s,o)),r--,i=He.Se(r),Y(i,n),o=He.Ce[i],0!==o&&(r-=He.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ke.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.ne(e),N.ne(e),o=(()=>{let t;for(G(E,K.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===U[2*He.Ae[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le._e,Le.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He.Ae[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],U=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&$e(t,r[i+1],r[i],e.le)&&i++,!$e(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ke=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),D=S,V=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=Xe,c=0,K.re=E,K.ie=Le.Ee,N.re=M,N.ie=Le.Me,O.re=U,O.ie=Le.Ue,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Oe=null,e.Ne=null,e.Ke=null,d=null,h=null,u=null,e.Fe=null,n==Xe?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Re!=Je[t].Re&&0!==e.qe&&(r=e.Ye(1)),D!=t&&(D=t,P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve),V=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.$e||!r.et&&0!==r.We||n==Ye&&4!=i)return r.Le=Qe[4],Oe;if(0===r.tt)return r.Le=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=Qe[7],-5;if(n==Ye&&0!==t.We)return r.Le=Qe[7],-5;if(0!==t.We||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.tt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le._e),$(),9>1+H+10-F&&(X(2,3),Y(256,Le._e),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={He(e,t){const n=this;return n.Fe=new et,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Oe},Qe(){const e=this;if(!e.Fe)return Oe;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Oe},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Oe},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ke.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;0!=(g&k);k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Le="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=st),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Le="oversubscribed distance tree":h==it?(w.Le="incomplete distance tree",h=st):-4!=h&&(w.Le="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(0!=(64&u))return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(0!=(64&u))return 0!=(32&u)?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(0!=(16&k)){a=15&k,i=n[g+2],t=2;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}if(0!=(32&k)){t=7;break}return t=9,y.Le="invalid literal/length code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],0!=(16&k)){a=15&k,l=n[g+2],t=4;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 9:return m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);default:return m=rt,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ht.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=rt,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):rt}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),rt):(e.zt=r,n.gt.kt=new yt(n,1<<r),t(n),0)),e.At=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return rt;const s=e.gt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=mt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=mt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Le="incorrect header check",s.marker=5;break}if(0==(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=mt,e.Le="need dictionary",s.marker=0,rt;case 7:if(n=s.kt.ut(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case mt:return st;default:return rt}},e._t=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return rt;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return rt;const c=e.gt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.We))return it;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==bt[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?st:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Pt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t.At(0),c&&a===it){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}kt.prototype={xt(e){const t=this;return t.gt=new gt,e||(e=15),t.gt.xt(t,e)},At(e){const t=this;return t.gt?t.gt.At(t,e):rt},Ct(){const e=this;if(!e.gt)return rt;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):rt},_t(e,t){const n=this;return n.gt?n.gt._t(n,e,t):rt},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};\n'],{type:"text/javascript"}));e({workerScripts:{inflate:[t],deflate:[t]}});}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
const HTTP_HEADER_CONTENT_TYPE = "Content-Type";
const DEFAULT_CHUNK_SIZE = 64 * 1024;

const PROPERTY_NAME_WRITABLE = "writable";

class Stream {

	constructor() {
		this.size = 0;
	}

	init() {
		this.initialized = true;
	}
}

class Reader extends Stream {

	get readable() {
		const reader = this;
		const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
		const readable = new ReadableStream({
			start() {
				this.chunkOffset = 0;
			},
			async pull(controller) {
				const { offset = 0, size, diskNumberStart } = readable;
				const { chunkOffset } = this;
				controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));
				if (chunkOffset + chunkSize > size) {
					controller.close();
				} else {
					this.chunkOffset += chunkSize;
				}
			}
		});
		return readable;
	}
}

class BlobReader extends Reader {

	constructor(blob) {
		super();
		Object.assign(this, {
			blob,
			size: blob.size
		});
	}

	async readUint8Array(offset, length) {
		const reader = this;
		const offsetEnd = offset + length;
		const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
		let arrayBuffer = await blob.arrayBuffer();
		if (arrayBuffer.byteLength > length) {
			arrayBuffer = arrayBuffer.slice(offset, offsetEnd);
		}
		return new Uint8Array(arrayBuffer);
	}
}

class BlobWriter extends Stream {

	constructor(contentType) {
		super();
		const writer = this;
		const transformStream = new TransformStream();
		const headers = [];
		if (contentType) {
			headers.push([HTTP_HEADER_CONTENT_TYPE, contentType]);
		}
		Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
			get() {
				return transformStream.writable;
			}
		});
		writer.blob = new Response(transformStream.readable, { headers }).blob();
	}

	getData() {
		return this.blob;
	}
}

class SplitDataReader extends Reader {

	constructor(readers) {
		super();
		this.readers = readers;
	}

	async init() {
		const reader = this;
		const { readers } = reader;
		reader.lastDiskNumber = 0;
		reader.lastDiskOffset = 0;
		await Promise.all(readers.map(async (diskReader, indexDiskReader) => {
			await diskReader.init();
			if (indexDiskReader != readers.length - 1) {
				reader.lastDiskOffset += diskReader.size;
			}
			reader.size += diskReader.size;
		}));
		super.init();
	}

	async readUint8Array(offset, length, diskNumber = 0) {
		const reader = this;
		const { readers } = this;
		let result;
		let currentDiskNumber = diskNumber;
		if (currentDiskNumber == -1) {
			currentDiskNumber = readers.length - 1;
		}
		let currentReaderOffset = offset;
		while (currentReaderOffset >= readers[currentDiskNumber].size) {
			currentReaderOffset -= readers[currentDiskNumber].size;
			currentDiskNumber++;
		}
		const currentReader = readers[currentDiskNumber];
		const currentReaderSize = currentReader.size;
		if (currentReaderOffset + length <= currentReaderSize) {
			result = await readUint8Array(currentReader, currentReaderOffset, length);
		} else {
			const chunkLength = currentReaderSize - currentReaderOffset;
			result = new Uint8Array(length);
			result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));
			result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);
		}
		reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
		return result;
	}
}

class SplitDataWriter extends Stream {

	constructor(writerGenerator, maxSize = 4294967295) {
		super();
		const writer = this;
		Object.assign(writer, {
			diskNumber: 0,
			diskOffset: 0,
			size: 0,
			maxSize,
			availableSize: maxSize
		});
		let diskSourceWriter, diskWritable, diskWriter;
		const writable = new WritableStream({
			async write(chunk) {
				const { availableSize } = writer;
				if (!diskWriter) {
					const { value, done } = await writerGenerator.next();
					if (done && !value) {
						throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
					} else {
						diskSourceWriter = value;
						diskSourceWriter.size = 0;
						if (diskSourceWriter.maxSize) {
							writer.maxSize = diskSourceWriter.maxSize;
						}
						writer.availableSize = writer.maxSize;
						await initStream(diskSourceWriter);
						diskWritable = value.writable;
						diskWriter = diskWritable.getWriter();
					}
					await this.write(chunk);
				} else if (chunk.length >= availableSize) {
					await writeChunk(chunk.slice(0, availableSize));
					await closeDisk();
					writer.diskOffset += diskSourceWriter.size;
					writer.diskNumber++;
					diskWriter = null;
					await this.write(chunk.slice(availableSize));
				} else {
					await writeChunk(chunk);
				}
			},
			async close() {
				await diskWriter.ready;
				await closeDisk();
			}
		});
		Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
			get() {
				return writable;
			}
		});

		async function writeChunk(chunk) {
			const chunkLength = chunk.length;
			if (chunkLength) {
				await diskWriter.ready;
				await diskWriter.write(chunk);
				diskSourceWriter.size += chunkLength;
				writer.size += chunkLength;
				writer.availableSize -= chunkLength;
			}
		}

		async function closeDisk() {
			diskWritable.size = diskSourceWriter.size;
			await diskWriter.close();
		}
	}
}

async function initStream(stream, initSize) {
	if (stream.init && !stream.initialized) {
		await stream.init(initSize);
	} else {
		return Promise.resolve();
	}
}

function initReader(reader) {
	if (Array.isArray(reader)) {
		reader = new SplitDataReader(reader);
	}
	if (reader instanceof ReadableStream) {
		reader = {
			readable: reader
		};
	}
	return reader;
}

function initWriter(writer) {
	if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {
		writer = new SplitDataWriter(writer);
	}
	if (writer instanceof WritableStream) {
		writer = {
			writable: writer
		};
	}
	const { writable } = writer;
	if (writable.size === UNDEFINED_VALUE) {
		writable.size = 0;
	}
	if (!(writer instanceof SplitDataWriter)) {
		Object.assign(writer, {
			diskNumber: 0,
			diskOffset: 0,
			availableSize: Infinity,
			maxSize: Infinity
		});
	}
	return writer;
}

function readUint8Array(reader, offset, size, diskNumber) {
	return reader.readUint8Array(offset, size, diskNumber);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* global TextDecoder */

const CP437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split("");
const VALID_CP437 = CP437.length == 256;

function decodeCP437(stringValue) {
	if (VALID_CP437) {
		let result = "";
		for (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {
			result += CP437[stringValue[indexCharacter]];
		}
		return result;
	} else {
		return new TextDecoder().decode(stringValue);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


function decodeText(value, encoding) {
	if (encoding && encoding.trim().toLowerCase() == "cp437") {
		return decodeCP437(value);
	} else {
		return new TextDecoder(encoding).decode(value);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const PROPERTY_NAME_FILENAME = "filename";
const PROPERTY_NAME_RAW_FILENAME = "rawFilename";
const PROPERTY_NAME_COMMENT = "comment";
const PROPERTY_NAME_RAW_COMMENT = "rawComment";
const PROPERTY_NAME_UNCOMPPRESSED_SIZE = "uncompressedSize";
const PROPERTY_NAME_COMPPRESSED_SIZE = "compressedSize";
const PROPERTY_NAME_OFFSET = "offset";
const PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
const PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
const PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
const PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
const PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
const PROPERTY_NAME_CREATION_DATE = "creationDate";
const PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
const PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE = "internalFileAttribute";
const PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE = "externalFileAttribute";
const PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
const PROPERTY_NAME_ZIP64 = "zip64";

const PROPERTY_NAMES = [
	PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, PROPERTY_NAME_COMPPRESSED_SIZE, PROPERTY_NAME_UNCOMPPRESSED_SIZE,
	PROPERTY_NAME_LAST_MODIFICATION_DATE, PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT,
	PROPERTY_NAME_LAST_ACCESS_DATE, PROPERTY_NAME_CREATION_DATE, PROPERTY_NAME_OFFSET, PROPERTY_NAME_DISK_NUMBER_START,
	PROPERTY_NAME_DISK_NUMBER_START, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE,
	PROPERTY_NAME_MS_DOS_COMPATIBLE, PROPERTY_NAME_ZIP64,
	"directory", "bitFlag", "encrypted", "signature", "filenameUTF8", "commentUTF8", "compressionMethod", "version", "versionMadeBy",
	"extraField", "rawExtraField", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "extraFieldNTFS",
	"extraFieldExtendedTimestamp"];

class Entry {

	constructor(data) {
		PROPERTY_NAMES.forEach(name => this[name] = data[name]);
	}

}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const ERR_SPLIT_ZIP_FILE = "Split zip file";
const CHARSET_UTF8 = "utf-8";
const CHARSET_CP437 = "cp437";
const ZIP64_PROPERTIES = [
	[PROPERTY_NAME_UNCOMPPRESSED_SIZE, MAX_32_BITS],
	[PROPERTY_NAME_COMPPRESSED_SIZE, MAX_32_BITS],
	[PROPERTY_NAME_OFFSET, MAX_32_BITS],
	[PROPERTY_NAME_DISK_NUMBER_START, MAX_16_BITS]
];
const ZIP64_EXTRACTION = {
	[MAX_16_BITS]: {
		getValue: getUint32,
		bytes: 4
	},
	[MAX_32_BITS]: {
		getValue: getBigUint64,
		bytes: 8
	}
};

class ZipReader {

	constructor(reader, options = {}) {
		Object.assign(this, {
			reader: initReader(reader),
			options,
			config: getConfiguration()
		});
	}

	async* getEntriesGenerator(options = {}) {
		const zipReader = this;
		let { reader } = zipReader;
		const { config } = zipReader;
		await initStream(reader);
		if (reader.size === UNDEFINED_VALUE || !reader.readUint8Array) {
			reader = new BlobReader(await new Response(reader.readable).blob());
			await initStream(reader);
		}
		if (reader.size < END_OF_CENTRAL_DIR_LENGTH) {
			throw new Error(ERR_BAD_FORMAT);
		}
		reader.chunkSize = getChunkSize(config);
		const endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);
		if (!endOfDirectoryInfo) {
			const signatureArray = await readUint8Array(reader, 0, 4);
			const signatureView = getDataView(signatureArray);
			if (getUint32(signatureView) == SPLIT_ZIP_FILE_SIGNATURE) {
				throw new Error(ERR_SPLIT_ZIP_FILE);
			} else {
				throw new Error(ERR_EOCDR_NOT_FOUND);
			}
		}
		const endOfDirectoryView = getDataView(endOfDirectoryInfo);
		let directoryDataLength = getUint32(endOfDirectoryView, 12);
		let directoryDataOffset = getUint32(endOfDirectoryView, 16);
		const commentOffset = endOfDirectoryInfo.offset;
		const commentLength = getUint16(endOfDirectoryView, 20);
		const appendedDataOffset = commentOffset + END_OF_CENTRAL_DIR_LENGTH + commentLength;
		let lastDiskNumber = getUint16(endOfDirectoryView, 4);
		const expectedLastDiskNumber = reader.lastDiskNumber || 0;
		let diskNumber = getUint16(endOfDirectoryView, 6);
		let filesLength = getUint16(endOfDirectoryView, 8);
		let prependedDataLength = 0;
		let startOffset = 0;
		if (directoryDataOffset == MAX_32_BITS || directoryDataLength == MAX_32_BITS || filesLength == MAX_16_BITS || diskNumber == MAX_16_BITS) {
			const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);
			const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
			if (getUint32(endOfDirectoryLocatorView, 0) != ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {
				throw new Error(ERR_EOCDR_ZIP64_NOT_FOUND);
			}
			directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
			let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
			let endOfDirectoryView = getDataView(endOfDirectoryArray);
			const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;
			if (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
				const originalDirectoryDataOffset = directoryDataOffset;
				directoryDataOffset = expectedDirectoryDataOffset;
				prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
				endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
				endOfDirectoryView = getDataView(endOfDirectoryArray);
			}
			if (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {
				throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
			}
			if (lastDiskNumber == MAX_16_BITS) {
				lastDiskNumber = getUint32(endOfDirectoryView, 16);
			}
			if (diskNumber == MAX_16_BITS) {
				diskNumber = getUint32(endOfDirectoryView, 20);
			}
			if (filesLength == MAX_16_BITS) {
				filesLength = getBigUint64(endOfDirectoryView, 32);
			}
			if (directoryDataLength == MAX_32_BITS) {
				directoryDataLength = getBigUint64(endOfDirectoryView, 40);
			}
			directoryDataOffset -= directoryDataLength;
		}
		if (directoryDataOffset >= reader.size) {
			prependedDataLength = reader.size - directoryDataOffset - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
			directoryDataOffset = reader.size - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
		}
		if (expectedLastDiskNumber != lastDiskNumber) {
			throw new Error(ERR_SPLIT_ZIP_FILE);
		}
		if (directoryDataOffset < 0) {
			throw new Error(ERR_BAD_FORMAT);
		}
		let offset = 0;
		let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
		let directoryView = getDataView(directoryArray);
		if (directoryDataLength) {
			const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
			if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
				const originalDirectoryDataOffset = directoryDataOffset;
				directoryDataOffset = expectedDirectoryDataOffset;
				prependedDataLength += directoryDataOffset - originalDirectoryDataOffset;
				directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
				directoryView = getDataView(directoryArray);
			}
		}
		const expectedDirectoryDataLength = endOfDirectoryInfo.offset - directoryDataOffset - (reader.lastDiskOffset || 0);
		if (directoryDataLength != expectedDirectoryDataLength && expectedDirectoryDataLength >= 0) {
			directoryDataLength = expectedDirectoryDataLength;
			directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
			directoryView = getDataView(directoryArray);
		}
		if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
			throw new Error(ERR_BAD_FORMAT);
		}
		const filenameEncoding = getOptionValue(zipReader, options, "filenameEncoding");
		const commentEncoding = getOptionValue(zipReader, options, "commentEncoding");
		for (let indexFile = 0; indexFile < filesLength; indexFile++) {
			const fileEntry = new ZipEntry(reader, config, zipReader.options);
			if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {
				throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
			}
			readCommonHeader(fileEntry, directoryView, offset + 6);
			const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
			const filenameOffset = offset + 46;
			const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
			const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
			const versionMadeBy = getUint16(directoryView, offset + 4);
			const msDosCompatible = (versionMadeBy & 0) == 0;
			const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
			const commentLength = getUint16(directoryView, offset + 32);
			const endOffset = commentOffset + commentLength;
			const rawComment = directoryArray.subarray(commentOffset, endOffset);
			const filenameUTF8 = languageEncodingFlag;
			const commentUTF8 = languageEncodingFlag;
			const directory = msDosCompatible && ((getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK);
			const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
			Object.assign(fileEntry, {
				versionMadeBy,
				msDosCompatible,
				compressedSize: 0,
				uncompressedSize: 0,
				commentLength,
				directory,
				offset: offsetFileEntry,
				diskNumberStart: getUint16(directoryView, offset + 34),
				internalFileAttribute: getUint16(directoryView, offset + 36),
				externalFileAttribute: getUint32(directoryView, offset + 38),
				rawFilename,
				filenameUTF8,
				commentUTF8,
				rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset)
			});
			const [filename, comment] = await Promise.all([
				decodeText(rawFilename, filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437),
				decodeText(rawComment, commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437)
			]);
			Object.assign(fileEntry, {
				rawComment,
				filename,
				comment,
				directory: directory || filename.endsWith(DIRECTORY_SIGNATURE)
			});
			startOffset = Math.max(offsetFileEntry, startOffset);
			await readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
			const entry = new Entry(fileEntry);
			entry.getData = (writer, options) => fileEntry.getData(writer, entry, options);
			offset = endOffset;
			const { onprogress } = options;
			if (onprogress) {
				try {
					await onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
				} catch (_error) {
					// ignored
				}
			}
			yield entry;
		}
		const extractPrependedData = getOptionValue(zipReader, options, "extractPrependedData");
		const extractAppendedData = getOptionValue(zipReader, options, "extractAppendedData");
		if (extractPrependedData) {
			zipReader.prependedData = startOffset > 0 ? await readUint8Array(reader, 0, startOffset) : new Uint8Array();
		}
		zipReader.comment = commentLength ? await readUint8Array(reader, commentOffset + END_OF_CENTRAL_DIR_LENGTH, commentLength) : new Uint8Array();
		if (extractAppendedData) {
			zipReader.appendedData = appendedDataOffset < reader.size ? await readUint8Array(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
		}
		return true;
	}

	async getEntries(options = {}) {
		const entries = [];
		for await (const entry of this.getEntriesGenerator(options)) {
			entries.push(entry);
		}
		return entries;
	}

	async close() {
	}
}

class ZipEntry {

	constructor(reader, config, options) {
		Object.assign(this, {
			reader,
			config,
			options
		});
	}

	async getData(writer, fileEntry, options = {}) {
		const zipEntry = this;
		const {
			reader,
			offset,
			diskNumberStart,
			extraFieldAES,
			compressionMethod,
			config,
			bitFlag,
			signature,
			rawLastModDate,
			uncompressedSize,
			compressedSize
		} = zipEntry;
		const localDirectory = fileEntry.localDirectory = {};
		const dataArray = await readUint8Array(reader, offset, 30, diskNumberStart);
		const dataView = getDataView(dataArray);
		let password = getOptionValue(zipEntry, options, "password");
		let rawPassword = getOptionValue(zipEntry, options, "rawPassword");
		password = password && password.length && password;
		rawPassword = rawPassword && rawPassword.length && rawPassword;
		if (extraFieldAES) {
			if (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {
				throw new Error(ERR_UNSUPPORTED_COMPRESSION);
			}
		}
		if (compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE) {
			throw new Error(ERR_UNSUPPORTED_COMPRESSION);
		}
		if (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {
			throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
		}
		readCommonHeader(localDirectory, dataView, 4);
		localDirectory.rawExtraField = localDirectory.extraFieldLength ?
			await readUint8Array(reader, offset + 30 + localDirectory.filenameLength, localDirectory.extraFieldLength, diskNumberStart) :
			new Uint8Array();
		await readCommonFooter(zipEntry, localDirectory, dataView, 4, true);
		Object.assign(fileEntry, {
			lastAccessDate: localDirectory.lastAccessDate,
			creationDate: localDirectory.creationDate
		});
		const encrypted = zipEntry.encrypted && localDirectory.encrypted;
		const zipCrypto = encrypted && !extraFieldAES;
		if (encrypted) {
			if (!zipCrypto && extraFieldAES.strength === UNDEFINED_VALUE) {
				throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
			} else if (!password && !rawPassword) {
				throw new Error(ERR_ENCRYPTED);
			}
		}
		const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
		const size = compressedSize;
		const readable = reader.readable;
		Object.assign(readable, {
			diskNumberStart,
			offset: dataOffset,
			size
		});
		const signal = getOptionValue(zipEntry, options, "signal");
		const checkPasswordOnly = getOptionValue(zipEntry, options, "checkPasswordOnly");
		if (checkPasswordOnly) {
			writer = new WritableStream();
		}
		writer = initWriter(writer);
		await initStream(writer, uncompressedSize);
		const { writable } = writer;
		const { onstart, onprogress, onend } = options;
		const workerOptions = {
			options: {
				codecType: CODEC_INFLATE,
				password,
				rawPassword,
				zipCrypto,
				encryptionStrength: extraFieldAES && extraFieldAES.strength,
				signed: getOptionValue(zipEntry, options, "checkSignature"),
				passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? ((rawLastModDate >>> 8) & 0xFF) : ((signature >>> 24) & 0xFF)),
				signature,
				compressed: compressionMethod != 0,
				encrypted,
				useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers"),
				useCompressionStream: getOptionValue(zipEntry, options, "useCompressionStream"),
				transferStreams: getOptionValue(zipEntry, options, "transferStreams"),
				checkPasswordOnly
			},
			config,
			streamOptions: { signal, size, onstart, onprogress, onend }
		};
		let outputSize = 0;
		try {
			({ outputSize } = (await runWorker({ readable, writable }, workerOptions)));
		} catch (error) {
			if (!checkPasswordOnly || error.message != ERR_ABORT_CHECK_PASSWORD) {
				throw error;
			}
		} finally {
			const preventClose = getOptionValue(zipEntry, options, "preventClose");
			writable.size += outputSize;
			if (!preventClose && !writable.locked) {
				await writable.getWriter().close();
			}
		}
		return checkPasswordOnly ? UNDEFINED_VALUE : writer.getData ? writer.getData() : writable;
	}
}

function readCommonHeader(directory, dataView, offset) {
	const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
	const encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;
	const rawLastModDate = getUint32(dataView, offset + 6);
	Object.assign(directory, {
		encrypted,
		version: getUint16(dataView, offset),
		bitFlag: {
			level: (rawBitFlag & BITFLAG_LEVEL) >> 1,
			dataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,
			languageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG
		},
		rawLastModDate,
		lastModDate: getDate(rawLastModDate),
		filenameLength: getUint16(dataView, offset + 22),
		extraFieldLength: getUint16(dataView, offset + 24)
	});
}

async function readCommonFooter(fileEntry, directory, dataView, offset, localDirectory) {
	const { rawExtraField } = directory;
	const extraField = directory.extraField = new Map();
	const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
	let offsetExtraField = 0;
	try {
		while (offsetExtraField < rawExtraField.length) {
			const type = getUint16(rawExtraFieldView, offsetExtraField);
			const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
			extraField.set(type, {
				type,
				data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
			});
			offsetExtraField += 4 + size;
		}
	} catch (_error) {
		// ignored
	}
	const compressionMethod = getUint16(dataView, offset + 4);
	Object.assign(directory, {
		signature: getUint32(dataView, offset + 10),
		uncompressedSize: getUint32(dataView, offset + 18),
		compressedSize: getUint32(dataView, offset + 14)
	});
	const extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);
	if (extraFieldZip64) {
		readExtraFieldZip64(extraFieldZip64, directory);
		directory.extraFieldZip64 = extraFieldZip64;
	}
	const extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);
	if (extraFieldUnicodePath) {
		await readExtraFieldUnicode(extraFieldUnicodePath, PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, directory, fileEntry);
		directory.extraFieldUnicodePath = extraFieldUnicodePath;
	}
	const extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);
	if (extraFieldUnicodeComment) {
		await readExtraFieldUnicode(extraFieldUnicodeComment, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, directory, fileEntry);
		directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
	}
	const extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);
	if (extraFieldAES) {
		readExtraFieldAES(extraFieldAES, directory, compressionMethod);
		directory.extraFieldAES = extraFieldAES;
	} else {
		directory.compressionMethod = compressionMethod;
	}
	const extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);
	if (extraFieldNTFS) {
		readExtraFieldNTFS(extraFieldNTFS, directory);
		directory.extraFieldNTFS = extraFieldNTFS;
	}
	const extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
	if (extraFieldExtendedTimestamp) {
		readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory);
		directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
	}
	const extraFieldUSDZ = extraField.get(EXTRAFIELD_TYPE_USDZ);
	if (extraFieldUSDZ) {
		directory.extraFieldUSDZ = extraFieldUSDZ;
	}
}

function readExtraFieldZip64(extraFieldZip64, directory) {
	directory.zip64 = true;
	const extraFieldView = getDataView(extraFieldZip64.data);
	const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max]) => directory[propertyName] == max);
	for (let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {
		const [propertyName, max] = missingProperties[indexMissingProperty];
		if (directory[propertyName] == max) {
			const extraction = ZIP64_EXTRACTION[max];
			directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
			offset += extraction.bytes;
		} else if (extraFieldZip64[propertyName]) {
			throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
		}
	}
}

async function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
	const extraFieldView = getDataView(extraFieldUnicode.data);
	const crc32 = new Crc32();
	crc32.append(fileEntry[rawPropertyName]);
	const dataViewSignature = getDataView(new Uint8Array(4));
	dataViewSignature.setUint32(0, crc32.get(), true);
	const signature = getUint32(extraFieldView, 1);
	Object.assign(extraFieldUnicode, {
		version: getUint8(extraFieldView, 0),
		[propertyName]: decodeText(extraFieldUnicode.data.subarray(5)),
		valid: !fileEntry.bitFlag.languageEncodingFlag && signature == getUint32(dataViewSignature, 0)
	});
	if (extraFieldUnicode.valid) {
		directory[propertyName] = extraFieldUnicode[propertyName];
		directory[propertyName + "UTF8"] = true;
	}
}

function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
	const extraFieldView = getDataView(extraFieldAES.data);
	const strength = getUint8(extraFieldView, 4);
	Object.assign(extraFieldAES, {
		vendorVersion: getUint8(extraFieldView, 0),
		vendorId: getUint8(extraFieldView, 2),
		strength,
		originalCompressionMethod: compressionMethod,
		compressionMethod: getUint16(extraFieldView, 5)
	});
	directory.compressionMethod = extraFieldAES.compressionMethod;
}

function readExtraFieldNTFS(extraFieldNTFS, directory) {
	const extraFieldView = getDataView(extraFieldNTFS.data);
	let offsetExtraField = 4;
	let tag1Data;
	try {
		while (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {
			const tagValue = getUint16(extraFieldView, offsetExtraField);
			const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
			if (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {
				tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
			}
			offsetExtraField += 4 + attributeSize;
		}
	} catch (_error) {
		// ignored
	}
	try {
		if (tag1Data && tag1Data.length == 24) {
			const tag1View = getDataView(tag1Data);
			const rawLastModDate = tag1View.getBigUint64(0, true);
			const rawLastAccessDate = tag1View.getBigUint64(8, true);
			const rawCreationDate = tag1View.getBigUint64(16, true);
			Object.assign(extraFieldNTFS, {
				rawLastModDate,
				rawLastAccessDate,
				rawCreationDate
			});
			const lastModDate = getDateNTFS(rawLastModDate);
			const lastAccessDate = getDateNTFS(rawLastAccessDate);
			const creationDate = getDateNTFS(rawCreationDate);
			const extraFieldData = { lastModDate, lastAccessDate, creationDate };
			Object.assign(extraFieldNTFS, extraFieldData);
			Object.assign(directory, extraFieldData);
		}
	} catch (_error) {
		// ignored
	}
}

function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory) {
	const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
	const flags = getUint8(extraFieldView, 0);
	const timeProperties = [];
	const timeRawProperties = [];
	if (localDirectory) {
		if ((flags & 0x1) == 0x1) {
			timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
		}
		if ((flags & 0x2) == 0x2) {
			timeProperties.push(PROPERTY_NAME_LAST_ACCESS_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE);
		}
		if ((flags & 0x4) == 0x4) {
			timeProperties.push(PROPERTY_NAME_CREATION_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_CREATION_DATE);
		}
	} else if (extraFieldExtendedTimestamp.data.length >= 5) {
		timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
		timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
	}
	let offset = 1;
	timeProperties.forEach((propertyName, indexProperty) => {
		if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
			const time = getUint32(extraFieldView, offset);
			directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);
			const rawPropertyName = timeRawProperties[indexProperty];
			extraFieldExtendedTimestamp[rawPropertyName] = time;
		}
		offset += 4;
	});
}

async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
	const signatureArray = new Uint8Array(4);
	const signatureView = getDataView(signatureArray);
	setUint32(signatureView, 0, signature);
	const maximumBytes = minimumBytes + maximumLength;
	return (await seek(minimumBytes)) || await seek(Math.min(maximumBytes, startOffset));

	async function seek(length) {
		const offset = startOffset - length;
		const bytes = await readUint8Array(reader, offset, length);
		for (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {
			if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] &&
				bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
				return {
					offset: offset + indexByte,
					buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
				};
			}
		}
	}
}

function getOptionValue(zipReader, options, name) {
	return options[name] === UNDEFINED_VALUE ? zipReader.options[name] : options[name];
}

function getDate(timeRaw) {
	const date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
	try {
		return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
	} catch (_error) {
		// ignored
	}
}

function getDateNTFS(timeRaw) {
	return new Date((Number((timeRaw / BigInt(10000)) - BigInt(11644473600000))));
}

function getUint8(view, offset) {
	return view.getUint8(offset);
}

function getUint16(view, offset) {
	return view.getUint16(offset, true);
}

function getUint32(view, offset) {
	return view.getUint32(offset, true);
}

function getBigUint64(view, offset) {
	return Number(view.getBigUint64(offset, true));
}

function setUint32(view, offset, value) {
	view.setUint32(offset, value, true);
}

function getDataView(array) {
	return new DataView(array.buffer);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


let baseURL;
try {
	baseURL = import.meta.url;
} catch (_error) {
	// ignored
}
configure({ baseURL });
e(configure);

/// <reference types="./index.d.ts" />


configure({ Deflate: ZipDeflate, Inflate: ZipInflate });

class TreeMaterialMetallicRoughness extends applyMaterialMixins(MeshMaterial, mixinPBRMetallicRoughness, mixinFoliage) {
    _textureSize;
    constructor(){
        super();
        this._textureSize = Vector2.zero();
    }
    get textureWidth() {
        return this._textureSize.x;
    }
    set textureWidth(val) {
        if (val !== this._textureSize.x) {
            this._textureSize.x = val;
            this.uniformChanged();
        }
    }
    get textureHeight() {
        return this._textureSize.y;
    }
    set textureHeight(val) {
        if (val !== this._textureSize.y) {
            this._textureSize.y = val;
            this.uniformChanged();
        }
    }
    applyUniformValues(bindGroup, ctx, pass) {
        super.applyUniformValues(bindGroup, ctx, pass);
        if (this.needFragmentColor(ctx)) {
            bindGroup.setValue('albedoTextureSize', this._textureSize);
        }
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        scope.$l.oNorm = pb.normalize(pb.mul(scope.oPos, pb.vec3(1, 0.5, 1)));
        //scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
        scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            scope.albedoTextureSize = pb.vec2().uniform(2);
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            scope.albedo = that.calculateFoliageAlbedo(scope, scope.albedo, pb.mul(that.getAlbedoTexCoord(scope), scope.albedoTextureSize));
            scope.$l.litColor = pb.vec3(0);
            if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.worldNorm);
                scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
                scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            }
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}
class TreeMaterialSpecularGlossiness extends applyMaterialMixins(MeshMaterial, mixinPBRSpecularGlossness, mixinFoliage) {
    _textureSize;
    constructor(){
        super();
        this._textureSize = Vector2.zero();
    }
    get textureWidth() {
        return this._textureSize.x;
    }
    set textureWidth(val) {
        if (val !== this._textureSize.x) {
            this._textureSize.x = val;
            this.uniformChanged();
        }
    }
    get textureHeight() {
        return this._textureSize.y;
    }
    set textureHeight(val) {
        if (val !== this._textureSize.y) {
            this._textureSize.y = val;
            this.uniformChanged();
        }
    }
    applyUniformValues(bindGroup, ctx, pass) {
        super.applyUniformValues(bindGroup, ctx, pass);
        if (this.needFragmentColor(ctx)) {
            bindGroup.setValue('albedoTextureSize', this._textureSize);
        }
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        scope.$l.oNorm = pb.normalize(pb.mul(scope.oPos, pb.vec3(1, 0.5, 1)));
        //scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
        scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            scope.albedoTextureSize = pb.vec2().uniform(2);
            scope.$l.albedo = that.calculateAlbedoColor(scope);
            scope.albedo = that.calculateFoliageAlbedo(scope, scope.albedo, pb.mul(that.getAlbedoTexCoord(scope), scope.albedoTextureSize));
            scope.$l.litColor = pb.vec3(0);
            if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.worldNorm);
                scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
                scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            }
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var bindImgui$1 = {
    exports: {}
};

(function(module, exports) {
    var Module = (()=>{
        var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
        return function(Module = {}) {
            // include: shell.js
            // The Module object: Our interface to the outside world. We import
            // and export values on it. There are various ways Module can be used:
            // 1. Not defined. We create it here
            // 2. A function parameter, function(Module) { ..generated code.. }
            // 3. pre-run appended it, var Module = {}; ..generated code..
            // 4. External script tag defines var Module.
            // We need to check if Module already exists (e.g. case 3 above).
            // Substitution will be replaced with actual code on later stage of the build,
            // this way Closure Compiler will not mangle it (e.g. case 4. above).
            // Note that if you want to run closure, and also to use Module
            // after the generated code, you will need to define   var Module = {};
            // before the code. Then that object will be used in the code, and you
            // can continue to use Module afterwards as well.
            var Module = typeof Module != 'undefined' ? Module : {};
            // Set up the promise that indicates the Module is initialized
            var readyPromiseResolve, readyPromiseReject;
            Module['ready'] = new Promise((resolve, reject)=>{
                readyPromiseResolve = resolve;
                readyPromiseReject = reject;
            });
            [
                "_main",
                "_fflush",
                "__embind_initialize_bindings",
                "onRuntimeInitialized"
            ].forEach((prop)=>{
                if (!Object.getOwnPropertyDescriptor(Module['ready'], prop)) {
                    Object.defineProperty(Module['ready'], prop, {
                        get: ()=>abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),
                        set: ()=>abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js')
                    });
                }
            });
            // --pre-jses are emitted after the Module integration code, so that they can
            // refer to Module (if they choose; they can also define Module)
            // Sometimes an existing Module object exists with properties
            // meant to overwrite the default module functionality. Here
            // we collect those properties and reapply _after_ we configure
            // the current environment's defaults to avoid having to be so
            // defensive during initialization.
            var moduleOverrides = Object.assign({}, Module);
            // Determine the runtime environment we are in. You can customize this by
            // setting the ENVIRONMENT setting at compile time (see settings.js).
            var ENVIRONMENT_IS_WEB = true;
            var ENVIRONMENT_IS_WORKER = false;
            var ENVIRONMENT_IS_NODE = false;
            var ENVIRONMENT_IS_SHELL = false;
            if (Module['ENVIRONMENT']) {
                throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
            }
            // `/` should be present at the end if `scriptDirectory` is not empty
            var scriptDirectory = '';
            function locateFile(path) {
                if (Module['locateFile']) {
                    return Module['locateFile'](path, scriptDirectory);
                }
                return scriptDirectory + path;
            }
            // Hooks that are implemented differently in different runtime environments.
            var readBinary;
            {
                if (typeof document != 'undefined' && document.currentScript) {
                    scriptDirectory = document.currentScript.src;
                }
                // When MODULARIZE, this JS may be executed later, after document.currentScript
                // is gone, so we saved it, and we use it here instead of any other info.
                if (_scriptDir) {
                    scriptDirectory = _scriptDir;
                }
                // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
                // otherwise, slice off the final part of the url to find the script directory.
                // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
                // and scriptDirectory will correctly be replaced with an empty string.
                // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
                // they are removed because they could contain a slash.
                if (scriptDirectory.indexOf('blob:') !== 0) {
                    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/') + 1);
                } else {
                    scriptDirectory = '';
                }
                if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');
            }
            var out = Module['print'] || console.log.bind(console);
            var err = Module['printErr'] || console.error.bind(console);
            // Merge back in the overrides
            Object.assign(Module, moduleOverrides);
            // Free the object hierarchy contained in the overrides, this lets the GC
            // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
            moduleOverrides = null;
            checkIncomingModuleAPI();
            // Emit code to handle expected values on the Module object. This applies Module.x
            // to the proper local x. This has two benefits: first, we only emit it if it is
            // expected to arrive, and second, by using a local everywhere else that can be
            // minified.
            if (Module['arguments']) Module['arguments'];
            legacyModuleProp('arguments', 'arguments_');
            if (Module['thisProgram']) Module['thisProgram'];
            legacyModuleProp('thisProgram', 'thisProgram');
            if (Module['quit']) Module['quit'];
            legacyModuleProp('quit', 'quit_');
            // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
            // Assertions on removed incoming Module JS APIs.
            assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
            assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
            assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
            assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
            assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
            assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
            legacyModuleProp('read', 'read_');
            legacyModuleProp('readAsync', 'readAsync');
            legacyModuleProp('readBinary', 'readBinary');
            legacyModuleProp('setWindowTitle', 'setWindowTitle');
            assert(!ENVIRONMENT_IS_WORKER, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.");
            assert(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.");
            assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
            // end include: shell.js
            // include: preamble.js
            // === Preamble library stuff ===
            // Documentation for the public APIs defined in this file must be updated in:
            //    site/source/docs/api_reference/preamble.js.rst
            // A prebuilt local version of the documentation is available at:
            //    site/build/text/docs/api_reference/preamble.js.txt
            // You can also build docs locally as HTML or other formats in site/
            // An online HTML version (which may be of a different version of Emscripten)
            //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
            var wasmBinary;
            if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
            legacyModuleProp('wasmBinary', 'wasmBinary');
            Module['noExitRuntime'] || false;
            legacyModuleProp('noExitRuntime', 'noExitRuntime');
            if (typeof WebAssembly != 'object') {
                abort('no native wasm support detected');
            }
            // Wasm globals
            var wasmMemory;
            //========================================
            // Runtime essentials
            //========================================
            // whether we are quitting the application. no code should run after this.
            // set in exit() and abort()
            var ABORT = false;
            /** @type {function(*, string=)} */ function assert(condition, text) {
                if (!condition) {
                    abort('Assertion failed' + (text ? ': ' + text : ''));
                }
            }
            // We used to include malloc/free by default in the past. Show a helpful error in
            // builds with assertions.
            // Memory management
            var /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;
            function updateMemoryViews() {
                var b = wasmMemory.buffer;
                Module['HEAP8'] = HEAP8 = new Int8Array(b);
                Module['HEAP16'] = HEAP16 = new Int16Array(b);
                Module['HEAP32'] = HEAP32 = new Int32Array(b);
                Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
                Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
                Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
                Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
                Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
            }
            assert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');
            assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, 'JS engine does not provide full typed array support');
            // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
            assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
            assert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');
            // include: runtime_init_table.js
            // In regular non-RELOCATABLE mode the table is exported
            // from the wasm module and this will be assigned once
            // the exports are available.
            var wasmTable;
            // end include: runtime_init_table.js
            // include: runtime_stack_check.js
            // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
            function writeStackCookie() {
                var max = _emscripten_stack_get_end();
                assert((max & 3) == 0);
                // If the stack ends at address zero we write our cookies 4 bytes into the
                // stack.  This prevents interference with SAFE_HEAP and ASAN which also
                // monitor writes to address zero.
                if (max == 0) {
                    max += 4;
                }
                // The stack grow downwards towards _emscripten_stack_get_end.
                // We write cookies to the final two words in the stack and detect if they are
                // ever overwritten.
                HEAPU32[max >> 2] = 0x02135467;
                HEAPU32[max + 4 >> 2] = 0x89BACDFE;
                // Also test the global address 0 for integrity.
                HEAPU32[0 >> 2] = 1668509029;
            }
            function checkStackCookie() {
                if (ABORT) return;
                var max = _emscripten_stack_get_end();
                // See writeStackCookie().
                if (max == 0) {
                    max += 4;
                }
                var cookie1 = HEAPU32[max >> 2];
                var cookie2 = HEAPU32[max + 4 >> 2];
                if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
                    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
                }
                // Also test the global address 0 for integrity.
                if (HEAPU32[0 >> 2] != 0x63736d65 /* 'emsc' */ ) {
                    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
                }
            }
            // end include: runtime_stack_check.js
            // include: runtime_assertions.js
            // Endianness check
            (function() {
                var h16 = new Int16Array(1);
                var h8 = new Int8Array(h16.buffer);
                h16[0] = 0x6373;
                if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
            })();
            // end include: runtime_assertions.js
            var __ATPRERUN__ = []; // functions called before the runtime is initialized
            var __ATINIT__ = []; // functions called during startup
            var __ATPOSTRUN__ = []; // functions called after the main() is called
            var runtimeInitialized = false;
            var runtimeExited = false;
            function preRun() {
                if (Module['preRun']) {
                    if (typeof Module['preRun'] == 'function') Module['preRun'] = [
                        Module['preRun']
                    ];
                    while(Module['preRun'].length){
                        addOnPreRun(Module['preRun'].shift());
                    }
                }
                callRuntimeCallbacks(__ATPRERUN__);
            }
            function initRuntime() {
                assert(!runtimeInitialized);
                runtimeInitialized = true;
                checkStackCookie();
                callRuntimeCallbacks(__ATINIT__);
            }
            function postRun() {
                checkStackCookie();
                if (Module['postRun']) {
                    if (typeof Module['postRun'] == 'function') Module['postRun'] = [
                        Module['postRun']
                    ];
                    while(Module['postRun'].length){
                        addOnPostRun(Module['postRun'].shift());
                    }
                }
                callRuntimeCallbacks(__ATPOSTRUN__);
            }
            function addOnPreRun(cb) {
                __ATPRERUN__.unshift(cb);
            }
            function addOnInit(cb) {
                __ATINIT__.unshift(cb);
            }
            function addOnPostRun(cb) {
                __ATPOSTRUN__.unshift(cb);
            }
            // include: runtime_math.js
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
            assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
            // end include: runtime_math.js
            // A counter of dependencies for calling run(). If we need to
            // do asynchronous work before running, increment this and
            // decrement it. Incrementing must happen in a place like
            // Module.preRun (used by emcc to add file preloading).
            // Note that you can add dependencies in preRun, even though
            // it happens right before run - run will be postponed until
            // the dependencies are met.
            var runDependencies = 0;
            var runDependencyWatcher = null;
            var dependenciesFulfilled = null; // overriden to take different actions when all run dependencies are fulfilled
            var runDependencyTracking = {};
            function addRunDependency(id) {
                runDependencies++;
                if (Module['monitorRunDependencies']) {
                    Module['monitorRunDependencies'](runDependencies);
                }
                if (id) {
                    assert(!runDependencyTracking[id]);
                    runDependencyTracking[id] = 1;
                    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
                        // Check for missing dependencies every few seconds
                        runDependencyWatcher = setInterval(()=>{
                            if (ABORT) {
                                clearInterval(runDependencyWatcher);
                                runDependencyWatcher = null;
                                return;
                            }
                            var shown = false;
                            for(var dep in runDependencyTracking){
                                if (!shown) {
                                    shown = true;
                                    err('still waiting on run dependencies:');
                                }
                                err('dependency: ' + dep);
                            }
                            if (shown) {
                                err('(end of list)');
                            }
                        }, 10000);
                    }
                } else {
                    err('warning: run dependency added without ID');
                }
            }
            function removeRunDependency(id) {
                runDependencies--;
                if (Module['monitorRunDependencies']) {
                    Module['monitorRunDependencies'](runDependencies);
                }
                if (id) {
                    assert(runDependencyTracking[id]);
                    delete runDependencyTracking[id];
                } else {
                    err('warning: run dependency removed without ID');
                }
                if (runDependencies == 0) {
                    if (runDependencyWatcher !== null) {
                        clearInterval(runDependencyWatcher);
                        runDependencyWatcher = null;
                    }
                    if (dependenciesFulfilled) {
                        var callback = dependenciesFulfilled;
                        dependenciesFulfilled = null;
                        callback(); // can add another dependenciesFulfilled
                    }
                }
            }
            /** @param {string|number=} what */ function abort(what) {
                if (Module['onAbort']) {
                    Module['onAbort'](what);
                }
                what = 'Aborted(' + what + ')';
                // TODO(sbc): Should we remove printing and leave it up to whoever
                // catches the exception?
                err(what);
                ABORT = true;
                // Use a wasm runtime error, because a JS error might be seen as a foreign
                // exception, which means we'd run destructors on it. We need the error to
                // simply make the program stop.
                // FIXME This approach does not work in Wasm EH because it currently does not assume
                // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
                // a trap or not based on a hidden field within the object. So at the moment
                // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
                // allows this in the wasm spec.
                // Suppress closure compiler warning here. Closure compiler's builtin extern
                // defintion for WebAssembly.RuntimeError claims it takes no arguments even
                // though it can.
                // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
                /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);
                readyPromiseReject(e);
                // Throw the error whether or not MODULARIZE is set because abort is used
                // in code paths apart from instantiation where an exception is expected
                // to be thrown when abort is called.
                throw e;
            }
            // include: memoryprofiler.js
            // end include: memoryprofiler.js
            // show errors on likely calls to FS when it was not included
            var FS = {
                error: function() {
                    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
                },
                init: function() {
                    FS.error();
                },
                createDataFile: function() {
                    FS.error();
                },
                createPreloadedFile: function() {
                    FS.error();
                },
                createLazyFile: function() {
                    FS.error();
                },
                open: function() {
                    FS.error();
                },
                mkdev: function() {
                    FS.error();
                },
                registerDevice: function() {
                    FS.error();
                },
                analyzePath: function() {
                    FS.error();
                },
                ErrnoError: function ErrnoError() {
                    FS.error();
                }
            };
            Module['FS_createDataFile'] = FS.createDataFile;
            Module['FS_createPreloadedFile'] = FS.createPreloadedFile;
            // include: URIUtils.js
            // Prefix of data URIs emitted by SINGLE_FILE and related options.
            var dataURIPrefix = 'data:application/octet-stream;base64,';
            // Indicates whether filename is a base64 data URI.
            function isDataURI(filename) {
                // Prefix of data URIs emitted by SINGLE_FILE and related options.
                return filename.startsWith(dataURIPrefix);
            }
            // Indicates whether filename is delivered via file protocol (as opposed to http/https)
            function isFileURI(filename) {
                return filename.startsWith('file://');
            }
            // end include: URIUtils.js
            /** @param {boolean=} fixedasm */ function createExportWrapper(name, fixedasm) {
                return function() {
                    var displayName = name;
                    var asm = fixedasm;
                    if (!fixedasm) {
                        asm = Module['asm'];
                    }
                    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');
                    assert(!runtimeExited, 'native function `' + displayName + '` called after runtime exit (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
                    if (!asm[name]) {
                        assert(asm[name], 'exported native function `' + displayName + '` not found');
                    }
                    return asm[name].apply(null, arguments);
                };
            }
            // include: runtime_exceptions.js
            // end include: runtime_exceptions.js
            var wasmBinaryFile;
            wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAAB8oqAgACiAWACf38AYAF/AGACf38Bf2ABfwF/YAN/f38AYAN/f38Bf2AAAGAEf39/fwF/YAABf2AEf39/fwBgB39/f39/f38Bf2AFf39/f38AYAJ/fwF9YAZ/f39/f38Bf2AFf39/f38Bf2AGf39/f39/AGAAAX1gCH9/f39/f39/AX9gAn99AGADf399AGAHf39/f39/fwBgAX0AYAF9AX1gAX8BfWAFf399f38AYAZ/f39/f30AYAl/f39/f39/f38Bf2AFf39/f30AYAR/f31/AGADf35/AX5gAXwBfGAFf35+fn4AYAp/f39/f39/f39/AGAIf39/f39/f38AYAV/f399fwBgB39/fX9/f38Bf2AGf399fX9/AX9gAX8BfGAGfX19f39/AGACfX0AYAR/f399AGAHf39/f39/fQBgBn9/fX9/fQBgB39/fX19f38Bf2AJf39/f39/f39/AGADf399AX9gBH99f38AYAJ/fQF/YAZ/f39/fX8AYAh/f39/f399fwBgB39/f39/fX8AYAt/f39/f39/f39/fwBgCX9/f39/f399fwBgAX8BfmACf30BfWAFf39/fX0AYAN/fX0Bf2ADf319AGAEf399fQBgBn9/fX19fwBgB39/f399f30AYAV/f39/fQF/YAN9f38AYAZ/f3x8f38Bf2ADf31/AGAJf399fX1/f39/AGAGf399f39/AGACfX0BfWABfQF/YAR/fn5/AGAAAXxgBn9/f39/fQF/YAh/f399f39/fwF/YAd/f31+fn9/AX9gB39/f39/fX0BfWAHf31/f399fQF/YAd/fn5+f319AX1gB399fn5/fX0BfmADf39+AX5gB399fX1/fX0BfWAJf39/f35+f39/AX9gA39/fwF9YAl/f39/f319f38AYAl/f39/f399fX8AYAh/f31/f399fwBgBn9/f31/fwBgBH99f30Bf2ABfAF9YAN/fn8Bf2ABfAF/YAF+AX9gAnx/AXxgBn98f39/fwF/YAJ+fwF/YAR+fn5+AX9gDX9/f39/f39/f39/f38AYAN/f38BfGADf398AGAIf39/fX1/f38AYAR9fX19AX9gC399fX19fX19fX1/AGAJf319fX19fX1/AGAJf399f39/f31/AGAHf399f39/fwBgBn9/f319fQBgCH9/f399f31/AGAHf39/f319fwF/YAd/f318fH9/AX9gA39/fQF9YAd/fHx8f319AX1gB399fHx/fX0BfGADf398AXxgCX9/f399f39/fwF/YAl/f399fX1/f38Bf2AJf39/fX9/f39/AX9gCX9/f399fX9/fwF/YAl/f39/fHx/f38Bf2AHf39/fX1/fwF/YAp/f39/f39/fX1/AX9gBH99fX0BfWAIf39/f399f30AYAh/f39/f39/fQBgB39/f31/f30AYAl/f399f39/fX8AYAx/f39/f39/f39/f38AYAp/f39/f39/f31/AGAHf39/fX19fwBgCX9/fX19f39/fwF/YAV/f31/fQF/YAd/f399f39/AGAEf39/fQF/YAp/f39/f39/f39/AX9gB39/f3x8f38Bf2AFf39/fX8Bf2AHf319fX9/fwBgBH9/fX0Bf2AEf399fwF/YAV/fX9/fQF/YAp/f31/f39/f31/AGACfX8Bf2ACf3wBfGACfHwBfGACfn8BfGADfHx/AXxgA3x+fgF8YAF8AGACfH8BfWACf34AYAJ+fgF/YAN/fn4AYAJ/fwF+YAJ/fwF8YAN+f38Bf2ABfAF+YAR/f39+AX5gA39/fgBgAn98AGACfn4BfGACfn4BfWAEf39+fwF+YAV/f39+fgBgBH9+f38BfwKJiYCAACoDZW52DV9fYXNzZXJ0X2ZhaWwACQNlbnYRX2VtdmFsX25ld19vYmplY3QACANlbnYRX2VtdmFsX3Rha2VfdmFsdWUAAgNlbnYNX2VtdmFsX2RlY3JlZgABA2VudhJfZW12YWxfbmV3X2NzdHJpbmcAAwNlbnYTX2VtdmFsX3NldF9wcm9wZXJ0eQAEA2VudhlfZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uABQDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAXwNlbnYJX2VtdmFsX2FzAGADZW52Fl9lbXZhbF9ydW5fZGVzdHJ1Y3RvcnMAAQNlbnYTX2VtdmFsX2dldF9wcm9wZXJ0eQACA2VudhZfZW12YWxfc3RyaWN0bHlfZXF1YWxzAAIDZW52DV9lbXZhbF9pbmNyZWYAAQNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19wcm9wZXJ0eQAgA2Vudh9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uACwDZW52C19fY3hhX3Rocm93AAQDZW52Il9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IADwNlbnYLX2VtdmFsX2NhbGwABwNlbnYZX2VtYmluZF9yZWdpc3Rlcl9jb25zdGFudABhA2Vudg1fZW12YWxfdHlwZW9mAAMDZW52EF9lbXZhbF9uZXdfYXJyYXkACANlbnYYX2VtdmFsX2dldF9tZXRob2RfY2FsbGVyAAIDZW52F19lbXZhbF9jYWxsX3ZvaWRfbWV0aG9kAAkDZW52FV9lbWJpbmRfcmVnaXN0ZXJfdm9pZAAAA2VudhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wACwNlbnYYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAAsDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQABANlbnYbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAADZW52HF9lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcABANlbnYWX2VtYmluZF9yZWdpc3Rlcl9lbXZhbAAAA2VudhxfZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3AAQDZW52FWVtc2NyaXB0ZW5fbWVtY3B5X2JpZwAEA2VudhBfX3N5c2NhbGxfb3BlbmF0AAcDZW52EV9fc3lzY2FsbF9mY250bDY0AAUDZW52D19fc3lzY2FsbF9pb2N0bAAFFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3JlYWQABxZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAMDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAwNlbnYFYWJvcnQABgNlbnYXX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQAFBZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsADgP8kYCAANgRBgMSAwAAAwAAAAUBCQcUCwQDAwUBAgcBAwcHBTUHDgIHAgIAAyYmBQIFBQQEAgEELRUFBAQELgMDEwEnAwgvAwMDAAABEgABAwIJBAAoIRsUYhsTBAUFAwMBAgIFAgICBgEBAAYBAQMIAgUIBQIBNggBCAgB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7QruCu8K8ArxCvIKgwOGA4cDiwOMA4gDiQOPA94C8wqNA44D9Aq3AvUK9gr3Cm74CnH5CroCuwK8Ar0C9wL5Alv6Ar4CvwL6CtkC+wr8Cv0K/gr/CoALgQuCC4MLhwXqAoQFggWEC/UC9gKEA+kChQvvAvAChgvyAvMChwuIC4kLhQX8Av0C/gL/AooL7gGLC4wLjQuOC48LkAuRC5ILkwuUC5ULlguXC5gLmQuaC5sLnAudC54LnwugC6ELogujC6QLpQumC6cLgQWoC4sFqQuqC6sLrAutC64LrwuwC7ELsguzC7QLtQu2C7cLuAu5C7oLuwu8C70Lvgu/C8ALwQvCC8MLxAvFC8YLxwvIC8kLygvLC8wLzQvOC88L0AvRC9IL0wvUC9UL1gvXC9gL2QvaC9sL3AvdC94L3wvgC+EL4gvjC4gG5AvlC+YL5wvoC+kL6gvrC+wL7QvuC+8LlgaXBvAL8QuYBvIL8wv0C/UL9gv3C/gL+Qv6C54G+wv8C/0L/gv/C4AMgQyCDIMMhAyFDK0GrgavBrAGhgyzBocMiAyJDIoMkAPbAYsMjAyNDJYDjgyPDJQDkAyRDJIMkwyUDJUMlgyXDJgMmQyaDJsMnAydDJ4MnwygDKEMogyjDKQMpQymDKcMqAypDKoMqwysDK0MrgzZBMwErwzQBNIEzwTRBM0EsAy9BrEMygayDLMMqQO0DKsDgAKsA7UMogO2DLcMowOlA7gMpwO5DLoMuwz5Ad0C3AKRAZoCkgGeAqMCpAKbApwCnQKfAqACoQKiArwMvQy+DKUCvwzADMEMwgzDDLcBuAHEDMUMxgzHDMgMyQzKDMsMzAzNDLICzgzPDNAM0QzSDNMM1AzVDIgCzQHWDNEBiwLXDIoCmAKCAowCjQKOAtgM2QzaDJMC2wzcDN0MkALeDN8MlQKWApcCmQLgDOEM4gzjDOQM5QzmDOcM6AzpDOoM9QyDDeYN6Q3qDfMN9A31DfcN+Q36DewM7Qz9Df4N/w2ADoEOgw6EDoUOhg6HDogOiQ6KDosOjA6NDo8OkA6RDpIOkw6UDpUOlg6XDpgOmQ6aDpsOnA6dDp4Onw6gDqEOog6jDqQOpQ6mDqcOqA6pDqoOqw6sDq0Org6vDrAOsQ6yDrMOtA61DrYOtw64DrkOug7sBvcGgAeZB6AHrAe1B78HxwfJCNsI6Aj9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NgIAAkAgAEGwA2ooAgBBBXEiBQ0AIABBrANqIgMgAygCAEEBajYCAAsCQCACKAKkNSABRyIGDQAgAi0A/DlFDQAgAi0AwDVBAXENACACKALoOQ0AIAIgADYC6DkgAkEAQX8gBRtBASACQf0Bai0AABsgAEGsA2ooAgBqNgL4OQtBACEDAkACQCACKALkOSAARw0AIAQgAigC7DlGDQECQCAFDQAgAEGsA2ooAgAgAigC8DlHDQAgAiABNgLgNwwCCyAGDQBBACEDQQBBABCNAQsgAw8LQQELKgEBfyAAQagDaiIBIAEoAgBBf2o2AgAgAEGsA2oiACAAKAIAQX9qNgIAC3sCAX0Bf0MAAAAAIQICQCABQwAAAABdDQBBACgCsOYLKALsNCEDAkACQCABQwAAAABcDQAgA0GcBGoqAgAhAQwBCyABQwAAAABeRQ0AIAMqAgwgAyoCWJMgAZIhAQsgASAAKgIAkyIBQwAAgD8gAUMAAIA/YBshAgsgAgsuAQJ/AkBBACgCsOYLIgBB0AFqKAIAIgENAEGW3AgPCyAAQdgBaigCACABEQMACywBAn8CQEEAKAKw5gsiAUHUAWooAgAiAkUNACABQdgBaigCACAAIAIRAAALCwYAQau0BgsJAEEAKAKw5gsLCwBBACAANgKw5gsLHQBBACABNgKU2ApBACAANgKQ2ApBACACNgK45gsLXgEBfwJAQQAoArDmCyIBRQ0AIAFB8AZqIgEgASgCAEEBajYCAAtBgPwAQQAoArjmC0EAKAKQ2AoRAgAgABChASEAAkBBACgCsOYLDQBBACAANgKw5gsLIAAQogEgAAvsDAEBfyAAQQhqEC0aIABBmCpqECsaIABBuDJqEMUDIQIgAEIANwKENSAAQgA3A/g3IABCADcDyDUgAEGAOGpCADcDACAAQgA3A6A4IABBqDhqQgA3AwAgAEHUOGpBADYCACAAQgA3Asw4IABBrDRqQQBBPBCgDxogAEHwNWpBAEHUARCgDxogAEHgOGpB////+wc2AgAgAEHkOGpCADcCACAAQdg4akL////79///v/8ANwMAIABB7DhqQgA3AgAgAEH0OGpCADcCACAAQfw4akEANgIAIABBiDlqQf////sHNgIAIABBjDlqQgA3AgAgAEGAOWpC////+/f//7//ADcDACAAQZQ5akIANwIAIABBnDlqQgA3AgAgAEGkOWpBADYCACAAQbA5akH////7BzYCACAAQbQ5akIANwIAIABBqDlqQv////v3//+//wA3AwAgAEG8OWpCADcCACAAQQA6AIA6IABByDpqQQBBkAEQoA8aIABBhDpqQQBBwAAQoA8aIABB9DpqIAI2AgAgAEHYO2pBAEGQARCgDxogAEGEPGogAjYCACAAQZA9akEAQSEQoA8aIABBhD1qQgA3AgAgAEIANwL8PCAAQYw9akF/NgIAIABCADcCtD0gAEGxPWpBADsAACAAQbw9akIANwIAIABB6D1qQQA2AgAgAEIANwPgPSAAQYA+akEAQcAAEKAPGiAAQcQ+akEAQcwdEKAPGiAAQZDcAGoQ+A4aIABBtN4AakIANwIAIABCADcCrF4gAEH63wBqQQA6AAAgAEEAOwH4XyAAQdjfAGpBADYCACAAQgA3A9BfIABB2N4AakEAQSgQoA8aIABBiN8AakEAQTwQoA8aIABBgOAAakJ/NwMAIABB+98AakGBAjsAACAAQQA2ArQyIAAgAUU6AAEgAEEAOgAAIABCADcCrDIgAEH4N2ohAgJAIAENAAJAQQAoArDmCyIBRQ0AIAFB8AZqIgEgASgCAEEBajYCAAtBtAhBACgCuOYLQQAoApDYChECABDwDiEBCyAAQgA3A4g0IABCADcCpDQgAEKAgICAcDcDkDQgAEL/////DzcDmDQgAEIANwPoNCAAQZgBaiABNgIAIABBoDRqQQA6AAAgAEHwNGpCADcDACAAQfg0akIANwMAIABBgDVqQQA2AgAgAEGMNWpBAEErEKAPGiAAQcA1akIANwMAIABCADcDuDUgAEEANgLsNSAAQgA3AuQ1IABCgICA/IuAgMC/fzcDyDUgAEIANwPQNSAAQdg1akIANwMAIABB4DVqQQA7AQAgAEHEN2pBAEE0EKAPGiACQQhqQgA3AwAgAkIANwMAIABBADYCvDggAEIANwK0OCAAQQA6ALA4IABBADYCnDggAEEBOgCWOCAAQQA7AZQ4IABB/////wc2ApA4IABCADcDiDggAEF/NgLIOCAAQQA2AJc4IABCfzcDwDggAEIANwLkOSAAQgA3AsQ5IABBzDlqQgA3AgAgAEHUOWpCADcCACAAQdk5akIANwAAIABB/////wc2AvA5IABB/////wc2Auw5IABC//////f/////ADcC9DkgAEH4OmpBn9gFNgIAIABBiDxqQazYBTYCACAAQQA2AvA8IABBADYCxDogAEEAOgD8OSAAQQA2Aug8IABB6zxqQQA2AAAgAEJ/NwL0PCAAQgA3AsQ9IABBzD1qQgA3AgAgAEHUPWpBADYCACAAQQA2AsA+IABBADYCkF4gAEL/////DzcD2D0gAEIANwP4PiAAQfw9akEANgIAIABB9D1qQgA3AgAgAEIANwLsPSAAQQA2ApxeIABBqN4AakH////7BzYCACAAQoCAwNQANwKUXiAAQoCAgICg4fWRPDcCxF4gAEIANwLMXiAAQv////v3//+//wA3A/heIABBgICA+AM2AtReIABBADsBwF4gAEEANgK8XiAAQv////v3//+//wA3A6BeIABBADoAxF8gAEEAOgDgXyAAQQA2AuRfIABBAjYC7F8gAEL////79///v/8ANwPwXiAAQgA3A8hfIABBLjsBgF8gAEH////7BzYC3F8gAEEANgKEXyAAQQA2AvRfIABBADoA8F8gAEECNgLoXyAAQYjgAGpBAEHoAxCgDxogAEF/NgL4YyAAQn83A/BjIABB/OMAakEAQYEYEKAPGiAAC6QDAQV/AkAgAC0AAA0AIAAtAIFfDQBBoJIEQQBBABBFIQECQCAAKAKUXyICIABBmN8AaigCAEcNACACQQFqIQMCQAJAIAINAEEIIQQMAQsgAkECbSACaiEECyACIAQgAyAEIANKGyIDTg0AIANBJGwhAgJAQQAoArDmCyIERQ0AIARB8AZqIgQgBCgCAEEBajYCAAsgAkEAKAK45gtBACgCkNgKEQIAIQICQCAAQZzfAGooAgAiBEUNACACIAQgACgClF9BJGwQng8aAkAgACgCnF8iBEUNAEEAKAKw5gsiBUUNACAFQfAGaiIFIAUoAgBBf2o2AgALIARBACgCuOYLQQAoApTYChEAAAsgACADNgKYXyAAIAI2ApxfIAAoApRfIQILIABBnN8AaigCACACQSRsaiICQQA2AiAgAkEENgIcIAJBBTYCGCACQQY2AhQgAkEHNgIQIAJBADYCDCACQQg2AgggAiABNgIEIAJBoJIENgIAIAAgACgClF9BAWo2ApRfIAAQwgQgAEEBOgAADwtB4OQFQYLpBEGeH0H7qwUQAAAL0gUCB38BfSMAQcAAayIDJAACQCAAKAKsNCIERQ0AIABBoN8AaiEFQQAhBgJAAkACQANAIAQgBkwNAQJAIAAoArQ0IAZBAnRqKAIAIgdBCWotAABBAXENAAJAAkAgBygChAUiBEF/Rg0AIARBBEgNBSAFKAIAIARMDQUgACgCqF8gBGohBAwBCyAHKAIEEN4BIQQLAkAgBA0AIAcgBSAHKAIAEPQBIgQQ3wE2AoQFCyAEKAIAIAcoAgRHDQQCQAJAIAcqAgwiCotDAAAAT11FDQAgCqghCAwBC0GAgICAeCEICyAIQf//A3EhCAJAAkAgB0EQaioCACIKi0MAAABPXUUNACAKqCEJDAELQYCAgIB4IQkLIAQgCUEQdCAIcjYCBAJAAkAgByoCHCIKi0MAAABPXUUNACAKqCEIDAELQYCAgIB4IQgLIAhB//8DcSEIAkACQCAHQSBqKgIAIgqLQwAAAE9dRQ0AIAqoIQkMAQtBgICAgHghCQsgBCAJQRB0IAhyNgIIIAQgBy0AjQE6AAwgACgCrDQhBAsgBkEBaiIGIARHDQAMBAsAC0HgtAVB744FQdwMQcv5BRAAAAtB8LMFQdCOBUHbBEGSrwQQAAALQb6OBkGC6QRBw9AAQbaBBRAAAAsgAiAAKAKgX0EGbEEAIAIoAgAiB0F/aiIGIAYgB0sbahD1AQJAIABBqN8AaigCACIHRQ0AIABBoN8AaiEEIAdBBGohBwNAIAEoAgAhBiADIAdBEGo2AjQgAyAGNgIwIAJBidQIIANBMGoQXiAHLgEEIQYgAyAHQQZqLgEANgIkIAMgBjYCICACQe7PCCADQSBqEF4gBy4BCCEGIAMgB0EKai4BADYCFCADIAY2AhAgAkH5zwggA0EQahBeIAMgBy0ADDYCACACQeDPCCADEF4gAkGV3AhBABBdIAQgBxDzASIHDQALCyADQcAAaiQAC2cBAn8CQCAAQajfAGooAgAiAkUNACAAQaDfAGohAyACQQRqIQADQAJAIAAtAA1FDQACQEEAKAKw5gtB3DRqIAAoAgAQUiICRQ0AIAIgABDgAQsgAEEAOgANCyADIAAQ8wEiAA0ACwsLvgEBAX8jAEHAAGsiBCQAIAQgBEE8ajYCICAEIARBOGo2AiQCQAJAIANBiocFIARBIGoQ+Q9BAkcNACACIAQoAjhBEHQgBC8BPHI2AgQMAQsgBCAEQThqNgIUIAQgBEE8ajYCEAJAIANBlIcFIARBEGoQ+Q9BAkcNACACIAQoAjhBEHQgBC8BPHI2AggMAQsgBCAEQTRqNgIAIANBpukFIAQQ+Q9BAUcNACACIAQoAjRBAEc6AAwLIARBwABqJAALIQAgAhDyASICQQxqQQA7AQAgAkIANwIEIAJBAToADSACC2cBAn8CQAJAIAAoAqw0IgJFDQBBACEDA0AgAiADTA0CIAAoArQ0IANBAnRqKAIAQX82AoQFIANBAWoiAyAAKAKsNCICRw0ACwsgAEGg3wBqELIBDwtB4LQFQe+OBUHcDEHL+QUQAAALMAAgAEEAKAKw5gsgABsiABCpAQJAQQAoArDmCyAARw0AQQBBADYCsOYLCyAAEKoBC90OAQN/AkAgAEGYAWooAgAiAUUNACAALQABRQ0AIAFBADoAHCABEKsBCyAAQQA2ApgBAkAgAC0AAEUNAAJAIAAtAIFfRQ0AIABBIGooAgAiAUUNAEEAKAKw5gshAkEAIAA2ArDmCyABEKwBQQAgAjYCsOYLCwJAIAAoArhfIgNBAUgNAEEAIQEDQAJAIAAoAsBfIAFBBHRqIgIoAgBBBkcNACAAIAIgAigCCBEAACAAKAK4XyEDCyABQQFqIgEgA0gNAAsLAkAgACgCrDQiA0EBSA0AQQAhAQNAAkAgACgCtDQgAUECdGooAgAiAkUNACACEIEBGgJAQQAoArDmCyIDRQ0AIANB8AZqIgMgAygCAEF/ajYCAAsgAkEAKAK45gtBACgClNgKEQAAIAAoAqw0IQMLIAFBAWoiASADSA0ACwsCQCAAQbQ0aigCACIBRQ0AIABCADcCrDQCQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAACAAQQA2ArQ0CwJAIABBwDRqKAIAIgFFDQAgAEIANwK4NAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAAIABBADYCwDQLAkAgAEHMNGooAgAiAUUNACAAQgA3AsQ0AkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgLMNAsgAEEANgLsNAJAIABB2DRqKAIAIgFFDQAgAEIANwLQNAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAAIABBADYC2DQLIABB3DRqEK0BIABBADYC5DUgAEEANgLENyAAQQA2AtA1IABCADcD8DQgAEH4NGpCADcDAAJAIABB7DZqKAIAIgFFDQAgAEIANwLkNgJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAAIABBADYC7DYLAkAgAEH4NmooAgAiAUUNACAAQgA3AvA2AkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgL4NgsCQCAAQYQ3aigCACIBRQ0AIABCADcC/DYCQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAACAAQQA2AoQ3CwJAIABBtDdqKAIAIgFFDQAgAEIANwKsNwJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAAIABBADYCtDcLAkAgAEHAN2ooAgAiAUUNACAAQgA3Arg3AkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgLANwsgAEGsOmoQrgEgAEHIOmoQyAMgAEHYO2oQyAMgAEHEPmoQrwECQCAAQeg+aigCACIBRQ0AIABCADcC4D4CQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAACAAQQA2Aug+CwJAIABB9D5qKAIAIgFFDQAgAEIANwLsPgJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAAIABBADYC9D4LIABBgD5qELABAkAgAEGkPmooAgAiAUUNACAAQgA3Apw+AkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgKkPgsCQCAAQbw+aigCACIBRQ0AIABCADcCtD4CQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAACAAQQA2Arw+CwJAIABB4N4AaigCACIBRQ0AIABCADcC2F4CQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAACAAQQA2AuBeCwJAIABB7N4AaigCACIBRQ0AIABCADcC5F4CQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAACAAQQA2AuxeCyAAQYA/ahCxASAAQaDfAGoQsgECQCAAQZzfAGooAgAiAUUNACAAQgA3ApRfAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgKcXwsCQCAAKALMXyIBRQ0AAkAgAUEAKAKYxgpGDQAgARClDxoLIABBADYCzF8LIABB0N8AahCzASAAQQA6AAALC0gBAX8CQCAARQ0AIAAQtAEhAAJAQQAoArDmCyIBRQ0AIAFB8AZqIgEgASgCAEF/ajYCAAsgAEEAKAK45gtBACgClNgKEQAACwtIAQF/AkAgAEUNACAAEPEOIQACQEEAKAKw5gsiAUUNACABQfAGaiIBIAEoAgBBf2o2AgALIABBACgCuOYLQQAoApTYChEAAAsLXQECfyMAQRBrIgEkAEEAKAKw5gtBADYChF8CQCAARQ0AIAFBADYCDCABQQxqEPYBIQIgAEHgmQQQsg8iAEUNACACQQEgASgCDCAAEL0PGiAAEKUPGgsgAUEQaiQAC1QBAn8CQCAAKAIIIgFFDQAgAEIANwIAAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgIICwuBAQEEf0EBIQFBACECA0ACQCAAIAJBDGxqIgIoAggiA0UNACACQQhqIQQgAkIANwIAAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyADQQAoArjmC0EAKAKU2AoRAAAgBEEANgIAC0EBIQIgAUEBcSEDQQAhASADDQALC9wCAQV/IABBDGohAQJAIAAoAgxBAUgNAEEAIQIDQAJAIAAoAhQgAkEDdGooAgQiA0F/Rg0AAkACQCADQQBIDQAgACgCACADSg0BC0HgtAVB744FQdwMQcv5BRAAAAsCQCAAKAIIIANBkAFsaiIDQYwBaigCACIERQ0AAkBBACgCsOYLIgVFDQAgBUHwBmoiBSAFKAIAQX9qNgIACyAEQQAoArjmC0EAKAKU2AoRAAALIAMoAggiA0UNAAJAQQAoArDmCyIERQ0AIARB8AZqIgQgBCgCAEF/ajYCAAsgA0EAKAK45gtBACgClNgKEQAACyACQQFqIgIgASgCAEgNAAsLIAEQrQECQCAAKAIIIgJFDQAgAEIANwIAAkBBACgCsOYLIgNFDQAgA0HwBmoiAyADKAIAQX9qNgIACyACQQAoArjmC0EAKAKU2AoRAAAgAEEANgIICyAAQQA2AhgL3QEBA38CQCAAKAIMIgFBAUgNAEEAIQIDQAJAIAAoAhQgAkEDdGooAgQiA0F/Rg0AAkACQCADQQBIDQAgACgCACADSg0BC0HgtAVB744FQdwMQcv5BRAAAAsgACgCCCADQagEbGoQ9wEaIAAoAgwhAQsgAkEBaiICIAFIDQALCyAAQQxqEK0BAkAgACgCCCICRQ0AIABCADcCAAJAQQAoArDmCyIDRQ0AIANB8AZqIgMgAygCAEF/ajYCAAsgAkEAKAK45gtBACgClNgKEQAAIABBADYCCAsgAEEANgIYC/0BAQJ/AkAgAEEUaigCACIBRQ0AIABCADcCDAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAAIABBADYCFAsCQCAAQSBqKAIAIgFFDQAgAEIANwIYAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgIgCwJAIABBLGooAgAiAUUNACAAQgA3AiQCQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAACAAQQA2AiwLC1QBAn8CQCAAKAIIIgFFDQAgAEIANwIAAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAAgAEEANgIICwtUAQJ/AkAgACgCCCIBRQ0AIABCADcCAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAAIABBADYCCAsLtRIBBH8CQCAAQdjfAGooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABBwN8AaigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEG03wBqKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsCQCAAQajfAGooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABBnN8AaigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEGQ3wBqKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsCQCAAQezeAGooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABB4N4AaigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALIABBkNwAahD5DhoCQCAAQaw/aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEGgP2ooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABBlD9qKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsCQCAAQfQ+aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEHoPmooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACyAAQcQ+ahDAAxoCQCAAQbw+aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEGwPmooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABBpD5qKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsgAEGAPmoQwQMaAkAgAEHoPWooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACyAAQdg7ahCCARogAEHIOmoQggEaIABBxDpqIQEgAEGsOmohAwNAAkAgAUF0aiIBQQhqKAIAIgJFDQACQEEAKAKw5gsiBEUNACAEQfAGaiIEIAQoAgBBf2o2AgALIAJBACgCuOYLQQAoApTYChEAAAsgASADRw0ACyAAQQA6AIA6IABBhDpqQQBBKBCgDxoCQCAAQcA3aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEG0N2ooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABBqDdqKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsCQCAAQZw3aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEGQN2ooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABBhDdqKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsCQCAAQfg2aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEHsNmooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABB5DRqKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsCQCAAQdg0aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEHMNGooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACwJAIABBwDRqKAIAIgFFDQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBf2o2AgALIAFBACgCuOYLQQAoApTYChEAAAsCQCAAQbQ0aigCACIBRQ0AAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyABQQAoArjmC0EAKAKU2AoRAAALAkAgAEGQKmooAgAiAUUNAAJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEF/ajYCAAsgAUEAKAK45gtBACgClNgKEQAACyAACykBAX8CQEEAKAKw5gsiAA0AQcGkCEGC6QRBqBpB+oUGEAAACyAAQQhqCxoBAX9BACgCsOYLIgBBgDpqQQAgAC0AgDobCw0AQQAoArDmCysDiDQLDQBBACgCsOYLKAKQNAsNAEEAKAKw5gtByDpqCw0AQQAoArDmC0G4MmoLiwECAn8BfUEAKAKw5gshASAAELwBIAAoAlAgABCNASABQQE6ALI1IAFBAToAljggACgCoAYiAkEQaioCACEDIAEgAUHkAWoqAgAgAioCDJM4Asg1IAFBzDVqIAFB6AFqKgIAIAOTOAIAAkAgAC0ACEEEcQ0AIAAoAqAGLQAIQQRxDQAgASAANgL8NAsLhwIBA39BACEBAkBBACgCsOYLIgIoAsQ3IABGDQAgAiAANgLENwJAAkAgAEUNAAJAIAItAJc4RQ0AIAJBAToAlTgLIAJBADoAmTggACgCsAYhAwwBC0EAIQMgAkEAOgCZOAsgAkEAOgCUOCACQQA2Asw3IAIgAzYCyDcgAkEANgKMOAsgAEEAEL0BAkACQCAARQ0AIAAoAqAGIgFFDQELAkAgAigCpDVFDQAgAigC0DUiA0UNACADKAKgBiABRg0AIAItALI1DQBBAEEAEI0BCwJAIABFDQAgARC+ASABKAIIIAAoAghyQYDAAHENACABEL8BCw8LQa6IBkGC6QRBiTFBnJAEEAAAC9UBAQV/QQAhAgJAQQAoArDmCyIDKAKsNyIERQ0AAkAgAEUNACAEQQFIDQAgA0G0N2ooAgAhBUEAIQIDQAJAIAUgAkEkbGooAgQiA0UNAAJAIAMoAggiBkGAgIAgcUUNACACIQMgBkGAgIAIcQ0BA0ACQCAFIANBJGxqKAIEIgZFDQAgBigCoAYgACgCoAZGDQMLIANBAWoiAyAERw0ADAQLAAtBnLwGQYLpBEG6PkG6kAQQAAALIAJBAWoiAiAERw0ADAILAAsgAiAETg0AIAIgARDHAQsL9gEBBn8CQAJAAkBBACgCsOYLIgEoArg0IgJBAEwNAAJAIAJBAnQgAUHANGooAgAiA2pBfGooAgAgAEYNACACQQFGDQAgAkF+aiEEA0ACQCADIARBAnRqIgUoAgAgAEcNACACIARBAWoiBkwNBCAFIAMgBkECdGogAiAEQX9zakECdBCfDxogASgCuDQiBEEATA0FIARBAnQgASgCwDRqQXxqIAA2AgAPCyAEQQBKIQUgBEF/aiEEIAUNAAsLDwtBqbcGQe+OBUHmDEGlhgUQAAALQeC0BUHvjgVB3AxBy/kFEAAAC0HgtAVB744FQdwMQcv5BRAAAAuDAgEGfwJAAkACQEEAKAKw5gsiASgCrDQiAkEATA0AAkAgAkECdCABQbQ0aigCACIDakF8aigCACIEIABGDQAgBCgCoAYgAEYNACACQQJJDQAgAkF+aiEEA0ACQCADIARBAnRqIgUoAgAgAEcNACACIARBAWoiBkwNBCAFIAMgBkECdGogAiAEQX9zakECdBCfDxogASgCrDQiBEEATA0FIARBAnQgASgCtDRqQXxqIAA2AgAPCyAEQQBKIQUgBEF/aiEEIAUNAAsLDwtBqbcGQe+OBUHmDEGlhgUQAAALQeC0BUHvjgVB3AxBy/kFEAAAC0HgtAVB744FQdwMQcv5BRAAAAuIAwIEfwN9IwBBEGsiACQAAkACQAJAQQAoArDmCyIBKAL8NCICRQ0AIAEgASgCpDUiAzYCqDUCQCADIAEoAtw1Rw0AIAFBAToA4DULIAIoAqAGIgJFDQICQCABQewBai0AAEUNACABQeQBahDBAUUNACABKgLINSEEIAEqAuQBIQUgACABQegBaioCACABQcw1aioCAJMiBjgCDCAAIAUgBJMiBDgCCAJAAkAgAioCDCAEXA0AIAJBEGoqAgAgBlsNAQsCQCACQQlqLQAAQQFxDQBBACgCsOYLIgMqAoRfQwAAAABfRQ0AIAMgA0EcaioCADgChF8LIAIgAEEIakEBEMIBCyABKAL8NBC8AQwCC0EAQQAQjQEgAUEANgL8NAwBCyABKALQNSICRQ0AIAIoAlAiAiABKAKkNUcNACABIAI2Aqg1AkAgASgC3DUgAkcNACABQQE6AOA1CyABQewBai0AAA0AQQBBABCNAQsgAEEQaiQADwtBw44EQYLpBEHsGkGWxgUQAAALRgEBfwJAQQAoArDmCyIBDQBBrIkGQYLpBEGKJEHP2wUQAAALIAAgAUHkAWogABsiACoCAEMAAHrIYCAAKgIEQwAAeshgcQvLAgIBfwR9IAAoAKsBIQMCQAJAAkAgAkUNACADwCACcUUNASACIAJBf2pxDQILIABC////+/f//7//ADcCsAEgACADQXFxNgCrASAAQRBqIgIqAgAhBCABKgIAIQUCQAJAIAEqAgQiBotDAAAAT11FDQAgBqghAQwBC0GAgICAeCEBCyACIAGyIgY4AgAgACoCDCEHAkACQCAFi0MAAABPXUUNACAFqCECDAELQYCAgIB4IQILIAAgArIiBTgCDCAAIAUgB5MiBSAAKgLMAZI4AswBIABB0AFqIgIgBiAEkyIEIAIqAgCSOAIAIABB5AFqIgIgBSACKgIAkjgCACAAQegBaiICIAQgAioCAJI4AgAgAEHcAWoiAiAFIAIqAgCSOAIAIABB4AFqIgAgBCAAKgIAkjgCAAsPC0HEgQhBgukEQY4zQbvBBBAAAAu6AwIHfwJ9IwBBEGsiACQAAkBBACgCsOYLIgEoAqQ1DQAgASgCkDUNAAJAIAEoAsQ3IgJFDQAgAi0AkAENAQsCQCABQdgHai0AAEUNAAJAIAEoAvQ0IgNFDQACQCADQQtqLQAAQQRxRQ0AIAEoAqw3IgRBAUgNAiADKAKcASEFIAFBtDdqKAIAIQZBACECA0AgBiACQSRsaigCACAFRg0BIAJBAWoiAiAERg0DDAALAAsgASgC8DQQuwECQCABQbUBai0AAEUNACADLQAIQQFxDQAgACADEMQBAkAgAUGIB2oqAgAiByAAKgIAYEUNACABQYwHaioCACIIIAAqAgRgRQ0AIAcgACoCCF1FDQAgCCAAQQxqKgIAXQ0BCyABQQA2Avw0CyABLQCbNUUNASABQQA2Avw0DAELIAJFDQAQxQENAEEAELwBCyABQdkHai0AAEUNABDFASEEAkAgASgC8DQiBUUNAEEAKAKw5gsiBigCrDQhAQNAIAFBAUgNAQJAIAYoArQ0IAFBf2oiAUECdGooAgAiAiAFRw0AIAUhBAwCCyACIARHDQALCyAEQQEQvQELIABBEGokAAubAQMFfQJ/AX4gAUEQaioCACECIAEqAhwhAyABKgIMIQRDAAAAACEFAkAgAS0ACEEBcQ0AQQAoArDmCyIHKgK0MiABKgKABZQhBQJAIAEoApwGIghFDQAgBSAIKgKABZQhBQsgB0HUKmoqAgAiBiAGkiAFkiEFCyABKQIMIQkgAEEMaiACIAWSOAIAIAAgBCADkjgCCCAAIAk3AgALZgEEfwJAAkBBACgCsOYLIgAoAqw3IgFBAUgNACAAQbQ3aigCACECA0ACQCACIAFBf2oiAEEkbGooAgQiA0UNACADQQtqLQAAQQhxDQMLIAFBAUshAyAAIQEgAw0ACwtBACEDCyADC/QBAQN/QQAoArDmCyECAkACQAJAIAFBgAFxRQ0AIAANASACKAKsNyEAAkAgAUGAAnFFDQAgAEEASg8LIAAgAigCuDdKDwsgAigCrDchAwJAAkAgAUGAAnFFDQACQCADQQFODQBBAA8LIAJBtDdqKAIAIQJBACEBA0AgAiABQSRsaigCACAARiIEDQIgAUEBaiIBIANHDQAMAgsAC0EAIQQgAyACKAK4NyIBTA0AIAFBf0wNAiACQbQ3aigCACABQSRsaigCACAARiEECyAEDwtBxbkGQYLpBEHEPUHV+gQQAAALQeC0BUHvjgVB3AxBy/kFEAAAC4cDAQd/AkAgAEEASA0AQQAoArDmCyICKAKsNyAATA0AIAJBtDdqKAIAIABBJGxqIgMoAgQhBCADKAIIIQUCQCACQbA3aigCACIDIABODQACQAJAIAMNAEEIIQYMAQsgA0ECbSADaiEGCyADIAYgACAGIABKGyIGTg0AIAJB8AZqIgMgAygCAEEBajYCACAGQSRsQQAoArjmC0EAKAKQ2AoRAgAhAwJAIAIoArQ3IgdFDQAgAyAHIAIoAqw3QSRsEJ4PGgJAIAIoArQ3IgdFDQBBACgCsOYLIghFDQAgCEHwBmoiCCAIKAIAQX9qNgIACyAHQQAoArjmC0EAKAKU2AoRAAALIAIgBjYCsDcgAiADNgK0NwsgAiAANgKsNwJAIAFFDQACQAJAIAUNAEEAIQAMAQsCQCAFLQCLAQ0AIARFDQAgBEEAENkBDwsCQCACKAKMOA0AIAUoAqwGIgBFDQAgAC0AiwENAQsgBSEACyAAELwBCw8LQfmyBUGC6QRB2j5BkoIFEAAAC/cIAgx/CH1BACEAQQAhAQJAQQAoArDmCyICKAL8NCIDRQ0AQQAgAyADQQlqLQAAQQJxGyEBCwJAAkACQAJAIAIoAqw0IgRBAUgNACACQfwqaioCACIMQwAAgEAgDEMAAIBAYBsgDCACQbQBai0AACIFGyENIAJB+CpqKgIAIg5DAACAQCAOQwAAgEBgGyAOIAUbIQ8gAkG0NGooAgAhBkEAIQADQAJAIAYgBCIHQX9qIgRBAnRqKAIAIgUtAIoBRQ0AIAUtAJEBDQAgBSgCCCIIQYAEcQ0AIAIqAuQBIhAgBSoC5AMgDiAPIAhBwoCACHEiCBsiEZNgRQ0AIAIqAugBIhIgBUHoA2oqAgAgDCANIAgbIhOTYEUNACAQIBEgBUHsA2oqAgCSXUUNACASIBMgBUHwA2oqAgCSXUUNAAJAIAUvAdQEIghFDQAgECAFKgIMIAUuAdgEspIiEWBFDQAgECARIAjBspJdRQ0AIBIgBUEQaioCACAFQdoEai4BALKSIhBgRQ0AIBIgECAFQdYEai4BALKSXQ0BCyAAIAUgABshCCABIAUgARshAQJAIANFDQAgAA0AIAUhCCAFKAKgBiADKAKgBkcNAEEAIQAMAQsgAQ0DIAghAEEAIQELIAdBAUsNAAsLIAIgATYC8DQCQCABRQ0AIAAhCAwCC0EAIQEgACEIQQAhBQwCCyACIAE2AvA0CyABKAKgBiEFCyACIAg2Avg0IAIgBTYC9DRBACEJAkAQxQEiA0UNAEEAIQkgBUUNAEEAIQkgBSgCoAYgA0YNAANAIAUgA0chCSAFIANGDQEgBSgCnAYiBQ0ACwsgAigCCCIKQRBxIQsgAkGwB2ohAEF/IQhBACEFQQAhBwNAAkAgAiAFaiIEQdgHai0AAEUNAEEBIQYCQCABDQAgAigCrDdBAEohBgsgBEHnB2ogBjoAAAsgBEHsAWotAAAiBiAHQQFxciEEAkAgBkUNAAJAIAhBf0YNACAAIAVBA3RqKwMAIAAgCEEDdGorAwBjRQ0BCyAFIQgLIARBAEchByAFQQFqIgVBBUcNAAtBASEHQQEhBQJAIAhBf0YNACACIAhqQecHai0AAEEARyEFCyALQQBHIQYCQCACLQDsPEUNACACLQDwPEEQcUUhBwsgCSAGciEGAkACQAJAAkACQAJAAkAgBQ0AIAcgBnJFDQEgAkEANgL4NCACQgA3A/A0IAIoAvBjIgVBf0cNBQwECyAGRQ0BQQAhASACQQA2Avg0IAJCADcD8DQgAigC8GMiBUF/Rw0EDAILIAIoAvBjIgVBf0YNAgwDCyACKALwYyIFQX9HDQILQQEhBSABDQIgBA0CCyACKAKsN0EASiEFDAELIAVBAEchBQsgAkHUBmogBToAAAJAAkAgAigC9GMiBUF/Rg0AIAVBAEchBQwBCyADIAIoAqQ1ckEARyEFCyACQdYGaiACKAL4Y0F/akF+SToAACACQdUGakEBIAUgCkEJcUEBRhsgBSACQdkGai0AABs6AAALRwECf0EAKAKw5gsiAEH8AWotAAAiAUECciABIABB/QFqLQAAGyIBQQRyIAEgAEH+AWotAAAbIgFBCHIgASAAQf8Bai0AABsLmnQED38HfQF+AXwjAEEgayIAJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkBBACgCsOYLIgFFDQAgASECAkAgASgCuF8iA0EBSA0AQQAhBANAAkAgASgCwF8gBEEEdGoiAigCAA0AIAEgAiACKAIIEQAAIAEoArhfIQMLIARBAWoiBCADSA0AC0EAKAKw5gshAgsgAi0AAEUNASACKAKQNCEEAkACQCACQRhqKgIAQwAAAABeDQAgBEUNAUGAwAhBgukEQbI2QYvIBBAAAAsgBEUNACACKAKUNCAERw0DCyACQRBqKgIAQwAAAABgRQ0DIAJBFGoqAgBDAAAAAGBFDQMgAkGYAWooAgAoAqgIQQBMDQQgAkHUK2oqAgBDAAAAAF5FDQUgAkHYK2oqAgBDAAAAAF5FDQYgAioCmCoiD0MAAAAAYEUNByAPQwAAgD9fRQ0HIAJBrCpqKgIAQwAAgD9gRQ0IIAJBsCpqKgIAQwAAgD9gRQ0IIAJBvCpqKAIAQQFqQQNPDQ5BACEEA0ACQCACIARBAnRqQTRqKAIAQQFqQYEESQ0AQYWtCEGC6QRBvTZBi8gEEAAACyAEQQFqIgRBFkcNAAsCQCACLQAIQQFxRQ0AIAJB5ABqKAIAQX9GDQwLAkAgAkG0AWotAABFDQAgAkEMai0AAEECcQ0AIAJBADoAtAELAkAgAi0AgV8NACACKAKgXw0KAkAgAkEgaigCACIERQ0AIAQQywELIAJBAToAgV8LAkAgAioChF8iD0MAAAAAXkUNACACIA8gAioCGJMiDzgChF8gD0MAAAAAX0UNAAJAAkAgAkEgaigCACIERQ0AIAQQrAEMAQsgAkHYBmpBAToAAAsgAkEANgKEXwsgAUEBOgCcNCABQQA2AtBeIAFBADYC6DQgASABKAKQNEEBajYCkDQgASABKwOINCABQRhqKgIAIg+7oDkDiDQCQCABQejeAGooAgBBf0oNAAJAQQAoArDmCyIERQ0AIARB8AZqIgQgBCgCAEEBajYCAAtBAEEAKAK45gtBACgCkNgKEQIAIQQCQCABQezeAGooAgAiAkUNACAEIAIgASgC5F5BAnQQng8aAkAgASgC7F4iAkUNAEEAKAKw5gsiA0UNACADQfAGaiIDIAMoAgBBf2o2AgALIAJBACgCuOYLQQAoApTYChEAAAsgAUEANgLoXiABIAQ2AuxeIAEqAhghDwsgAUEANgLkXiABIAEqAuxjIA8gASABKALoYyIEQQJ0akGI4ABqIgIqAgCTkjgC7GMgAiAPOAIAIAEgBEEBakH4AG82AuhjQ///f38hDwJAIAEqAuxjIhBDAAAAAF5FDQBDAACAPyAQQwAA8EKVlSEPCyABQdwGaiAPOAIAIAFBmAFqKAIAQQE6ABwCQEEAKAKw5gsiAkGkAWooAgAiBA0AIAJBmAFqKAIAIgQoAqgIQQBMDQsgBEGwCGooAgAoAgAhBAsgBBDMASABQdAyakIANwMAIAFB2DJqIAFBEGopAwA3AwAgAUHIMmogAUHUK2oqAgA4AgAgAUG4MmogAUHYK2oqAgAQxgMgAUHgMmogAUHQK2otAAAiBDYCAAJAIAFB0StqLQAARQ0AIAEoAqwyKAJULQAAQQRxDQAgASAEQQJyIgQ2AuAyCwJAIAFB0itqLQAARQ0AIAEgBEEEciIENgLgMgsCQCABQQxqLQAAQQhxRQ0AIAEgBEEIcjYC4DILIAFByDpqIgQQxwMgBCABKAKYASgCBBDSAyAEENADIAFB2DtqIgQQxwMgBCABKAKYASgCBBDSAyAEENADIAFBADoAgDogAUGEOmpBAEEoEKAPGgJAIAEtAOw8RQ0AIAFBhD1qKAIAIgQgASgCpDVHDQACQEEAKAKw5gsiAigCpDUgBEcNACACIAQ2Aqg1CyACKALcNSAERw0AIAJBAToA4DULAkACQCABKAKUNUUNACABKAKQNSICRQ0BIAEoAqQ1IAJHDQ4gAUEANgKgNQwOCyABQgA3Apw1IAEoApA1IgINDQsgASgCpDUhBEEAIQIMDQtBwaQIQYLpBEHFHUGtxgUQAAALQaLcBUGC6QRBsTZBi8gEEAAAC0G2nwhBgukEQbM2QYvIBBAAAAtBp78IQYLpBEG0NkGLyAQQAAALQcejCEGC6QRBtTZBi8gEEAAAC0HmvQhBgukEQbc2QYvIBBAAAAtBpb0IQYLpBEG4NkGLyAQQAAALQdq8CEGC6QRBuTZBi8gEEAAAC0HoqAhBgukEQbo2QYvIBBAAAAtB85EIQYLpBEG6zgBB5MkEEAAAC0HgtAVB744FQdwMQcv5BRAAAAtBrqYIQYLpBEHBNkGLyAQQAAALIAEgASoCGCIPIAEqApw1kjgCnDUCQCABKAKkNSIEIAJHDQAgAiEEDAELIAEgDyABKgKgNZI4AqA1CyABIAI2ApQ1IAFBADoAmzUgAUEANgKQNSABIAEtAJk1OgCaNSABQQA7AZg1AkAgASgCqDUgBEYNACAERQ0AIAEoAtw1IARHDQBBAEEAEI0BIAEoAqQ1IQQLIAEqAhghEQJAIARFDQAgASARIAEqAqw1kjgCrDULIAEgBDYC3DUgAUEAOgDgNSABQQA6ALU1IAFBADYCqDUgAUEAOgCwNSABIAEoAtA1NgLkNSABIAEtALQ1OgDhNSABIBEgASoC7DWSOALsNQJAIAEoApBeIgJFDQAgBCACRg0AIAFBADYCkF4LAkAgBA0AIAFCADcDuDUgAUHANWpCADcDAAtBACEEIAFBADYC3D0gAUEAOwDtPCABIAEoAtA9NgLUPSABQv////sHNwLMPSABQfwGakEAKAKw5gsiAkH8AWotAAAiA0ECciADIAJB/QFqLQAAGyIDQQRyIAMgAkH+AWotAAAbIgNBCHIgAyACQf8Bai0AABs2AgAgAUHYGGogAUHYCGpBgBAQng8aA0ACQAJAIAEgBGpBgAJqLQAADQBDAACAvyEPDAELQwAAAAAhDyABIARBAnRqQdgIaioCACIQQwAAAABdDQAgECARkiEPCyABIARBAnRqQdgIaiAPOAIAIARBAWoiBEGABEcNAAsgAkIANwLEOUEAIQUgAkHXBmpBADoAACACKAIIIgRBAXEhBgJAIARBAnFFDQAgAkEMai0AAEEBcUUNAEEBIQUgAigC9DdBBEYNAAJAIAJBgAZqKgIAQwAAAABeDQAgAkGIBmoqAgBDAAAAAF4NACACQYQGaioCAEMAAAAAXg0AIAJBjAZqKgIAQwAAAABeDQAgAkGQBmoqAgBDAAAAAF4NACACQZQGaioCAEMAAAAAXg0AIAJBmAZqKgIAQwAAAABeDQAgAkGcBmoqAgBDAAAAAF5FDQELIAJBBDYC9DcLAkAgBkUNAAJAIAJB5ABqKAIAEM0BRQ0AIAJBAzYC9DcgAkGABmpBgICA/AM2AgALAkAgAkHoAGooAgAQzQFFDQAgAkEDNgL0NyACQYgGakGAgID8AzYCAAsCQCACQewAaigCABDNAUUNACACQQM2AvQ3IAJBhAZqQYCAgPwDNgIACwJAIAJBOGooAgAQzQFFDQAgAkEDNgL0NyACQcQGakGAgID8AzYCAAsCQCACQTxqKAIAEM0BRQ0AIAJBAzYC9DcgAkHIBmpBgICA/AM2AgALAkAgAkHAAGooAgAQzQFFDQAgAkEDNgL0NyACQcwGakGAgID8AzYCAAsCQCACQcQAaigCABDNAUUNACACQQM2AvQ3IAJB0AZqQYCAgPwDNgIACwJAIAItAPwBIgRFDQAgAkG4BmpBgICA/AM2AgALAkAgAi0A/QFFDQAgAkG8BmpBgICA/AM2AgALIAQNACACLQD+AUH/AXFFDQAgAkHABmpBgICA/AM2AgALIAJBrClqIAJB2ChqQdQAEJ4PGkEAIQQDQEMAAIC/IQ8CQCACIARBAnRqIgNBgAZqKgIAQwAAAABeRQ0AQwAAAAAhDyADQdgoaioCACIQQwAAAABdDQAgECACKgIYkiEPCyADQdgoaiAPOAIAIARBAWoiBEEVRw0ACwJAIAIoApw4RQ0AAkAgAi0AljhFDQAgAi0AmjhFDQELQQAoArDmCyIEKALEN0UNACAEKAKMOCEDIAQoApw4IQcCQAJAIAQtAJo4RQ0AIAcgA0EAEM4BIAQoAsQ3IANBBHRqIgNBwAZqIARBqDhqKQIANwIAIANBuAZqIAQpAqA4NwIAIARBAToAlzggBEEBOwCVOAwBCyAHIANBABDOAQsgBCgCxDcgBCgCjDhBBHRqIgNBwAZqIARBqDhqKQIANwIAIANBuAZqIAQpAqA4NwIACyACQQA2Apw4IAJBADsAmTggAkEANgLkNwJAAkACQAJAAkACQCACLQCwOEUNAAJAAkBBACgCsOYLIgRB0DhqKAIAIgMNACAEQaA5aigCAA0AIAQoAsg3DQEMAgsgBEHMOGogBEGcOWoiByADGyEDAkAgBCgCtDgiCEEgcUUNACAEQfg4aigCACIJRQ0AIAMgBEH0OGogCSAEKALIN0YbIQMLAkACQCADIAdGDQAgBEGgOWooAgBFDQEgBCgCnDkoApwGIAQoAsQ3Rw0BIARBqDlqKgIAIg8gAyoCDCIQXQ0AIA8gEFwNASAEQaw5aioCACADKgIQXUUNAQsgByEDCyAEKALEN0UNAiADKAIAIgdFDQICQCAEKAKMOA0AAkACQCAIQcAAcUUNAEMAAAAAIQ9DAAAAACEQAkAgBCgCwDhBAkcNACAHQeQAaioCACEQCyAHQfwAakEANgIAIAdB9ABqQQA2AgAgB0HsAGogEDgCACAHQdwAaioCACAQkyEQDAELIANBHGoqAgAhECADQSBqKgIAIREgByoCDCEPIAMqAhghEiAAQRxqIAdBEGoqAgAiEyADQSRqKgIAkjgCACAAIBIgD5I4AhAgACAPIBGSOAIYIAAgECATkjgCFCAAQQhqIAMoAgAgAEEQahDPASAAKgIMIRAgACoCCCEPCyADIAMqAhggD5M4AhggA0EgaiIHIAcqAgAgD5M4AgAgA0EcaiIHIAcqAgAgEJM4AgAgA0EkaiIHIAcqAgAgEJM4AgALQQBBABCNASAEIAMoAgA2AsQ3AkACQCAEKALINyADKAIEIghHDQAgAygCCCEJDAELIAQgCDYC5DcgBCADKAIIIgk2Aug3IAQgBCgCvDg2Auw3C0EAKAKw5gshByAIIAQoAow4IgQgCRDOASAHKALENyAEQQR0aiIEQcAGaiADQSBqKQIANwIAIARBuAZqIAMpAhg3AgAgB0EBOgCVOCAHIQQLIARBgAI7AZY4CwJAIAIoArg4QQJHDQAgAi0AsDhFDQICQCACQdA4aigCAA0AIAJBoDlqKAIADQAgAkEAOgCWOAsgAkEANgK4OAsCQCACLQCVOEUNACACLQCUOEUNAAJAIAItAAhBBHFFDQAgAkEMai0AAEEEcUUNACACLQCWOA0AIAItAJc4RQ0AIAIoAsQ3RQ0AIABBEGoQ0AEgAkHkAWogACkDECIWNwIAIAJBgAdqIBY3AwAgAkEBOgDXBgsgAkEAOgCVOAsgAkEANgLgNyACQQA6AJQ4IAIoAow4IgdBAk8NAgJAIAIoAsQ3IgNFDQAgAyEEAkACQANAIAQoAghBgICAqAFxQYCAgAhHDQEgBCgCnAYiBA0ADAILAAsgBCADRg0AIAQgAzYCrAYLIAcNACADKAKsBkUNACADQQA2AqwGC0EAKAKw5gshBAJAEMUBIgdFDQAgBEEANgLMOQsCQCAEKALQOUUNACAEKALMOQ0AIAQgBCoC3DkgBEEYaioCAEMAACDBlJIiD0MAAAAAIA9DAAAAAGAbIg84Atw5IAQqAsQ6QwAAAABfRQ0AIA9DAAAAAF9FDQAgBEEANgLQOQtBACEDIAcNAyAEKALMOQ0DQwAAAABDAACAP0MAAAAAIARB5ChqKgIAIg9DAAAAAFsbIA9DAAAAAF0bQwAAAABeIQcgBEH8AWotAABFDQRBACEDIARBNGooAgAiCEEASA0EIAhBARDRAUUNBCAELQAIQQFxIQMMBAtBiZIEQYLpBEGYxwBBmakEEAAAC0GloARBgukEQZTFAEHRugUQAAALQeeyBkGC6QRBqsUAQdG6BRAAAAtBACEHCwJAAkAgBw0AIANFDQELAkAgBCgCxDciBw0AIAQoArg0QX9qQYGAgIB4QX8Q0gEiB0UNAQsgBCAHKAKgBiIHNgLMOSAEIAc2AtA5IAQgA0EBczoA4DkgBEIANwPYOSAEQQNBBCADGzYC9DcLIAQgBEEYaioCACAEKgLYOZIiDzgC2DkCQAJAAkACQAJAIAQoAsw5DQBBACEIDAELIAQoAvQ3IgdBBEcNAiAEIAQqAtw5IhBDAAAAAEMAAIA/IA9DzcxMvpJDzcxMPZUiDyAPQwAAgD9eGyAPQwAAAABdGyIPIBAgD2AbIg84Atw5AkBBDEEEENMBQwAAAABeQQ1BBBDTAUMAAAAAXmsiA0UNACADENQBIARBgICA/AM2Atw5QwAAgD8hDwtBACEIAkBBACgCsOYLQYwGaioCAEMAAAAAXg0AIAQgD0MAAIA/XSAELQDgOUEAR3EiAzoA4DkCQAJAIANBAUcNAEEAIQMgBCgCxDdBAEchCAwBCyAEKALMOSEDQQAhCAsgBEEANgLMOQwECyAEKALMOQ0BC0EAIQMMAgsgBCgC9DchBwtBACEIQQAhAyAHQQNHDQAgBCAEKgLcOSIQQwAAAABDAACAPyAEKgLYOUPNzEy+kkPNzEw9lSIPIA9DAACAP14bIA9DAAAAAF0bIg8gECAPYBs4Atw5QQAhCAJAQQAoArDmC0E0aigCACIDQQBIDQAgA0EBENEBRQ0AQQFBfyAEQf0Bai0AABsQ1AELQQAhAyAEQfwBai0AAA0AIAQoAsw5IQNBACEICwJAQQAoArDmCyIHQZgpaioCACIPQwAAAABcDQAgBEEBOgDgOQsCQAJAIAQoAqQ1RQ0AIAQtALE1RQ0BCyAPQwAAAABdRQ0AIAQtAOA5Qf8BcUUNACAHQewpaioCAEMAAAAAYEUNACAEQeQBahDBASAEQYAHahDBAXNBAXMgCHIhCAsCQCAEKALMOSIHRQ0AIActAAhBBHENAEMAAAAAIQ9DAAAAACEQAkACQAJAAkAgBCgC9DdBfWoOAgABAwtDAAAAACEPQwAAAAAhECAEQf0Bai0AAA0CIABBEGpBAUEAQwAAAABDAAAAABDVAQwBCyAAQRBqQQRBAEMAAAAAQwAAAAAQ1QELIAAqAhQhECAAKgIQIQ8LAkAgD0MAAAAAXA0AIBBDAAAAAFsNAQsCQAJAIAQqAhhDAABIRJQgBEGoAWoqAgAiESAEQawBaioCACISIBEgEl0blCIRi0MAAABPXUUNACARqCEJDAELQYCAgIB4IQkLIAcoAqAGIgcqAgwhESAAIAdBEGoqAgAgECAJsiISlJI4AhQgACARIA8gEpSSOAIQIAcgAEEQakEBEMIBAkAgB0EJai0AAEEBcQ0AQQAoArDmCyIHKgKEX0MAAAAAX0UNACAHIAdBHGoqAgA4AoRfCyAEQQE6AJc4CwJAIANFDQACQAJAIAQoAsQ3IgdFDQAgAyAHKAKgBkYNAQtBAEEAEI0BIARBgAI7AZY4AkACQCADKAKsBiIHRQ0AIActAIsBDQELIAMhBwsgB0EAEL0BIAcQvAECQCAHKAKwBg0AIAdBABDWAQsgB0HEAmooAgBBAkcNACAEQQE2Aow4CyAEQQA2Asw5CwJAIAhFDQAgBCgCxDciCEUNACAIIQcCQANAIAciAygCnAYiB0UNASADQcQCai0AAEECcQ0BIAMoAghBgICAqAFxQYCAgAhGDQALCwJAIAMgCEYNACADELwBIAMgCDYCrAYgBCgCxDchCAsgBEGAAjsBljhBACEDAkAgCEHEAmotAABBAnFFDQAgBCgCjDhBAXMhAwsgAxDXAQsCQAJAAkAgBkUgBUEBc3ENACACKALENyIERQ0AIAJB2QZqIAQoAghBgIAQcSIERToAACAEDQEgAigCyDdFDQEgAi0AljgNAUEBIQQMAgsgAkHZBmpBADoAAAsgAigCzDlBAEchBAsgAkHaBmogBDoAAEEAIQcCQAJAAkACQAJAAkACQAJAAkBBACgCsOYLIgRB3ChqKgIAQwAAAABcDQACQCACKAKkNUUNACAELQC8NUECcQ0BQQBBABCNAQwBCwJAIAIoAsQ3IgRFDQAgBCgCCEGAgIAocUGAgIAIRw0AIAQoApwGIgNFDQAgBCgCVEUNAiADELwBQQAoArDmCyIDKALENyIIRQ0DIAQoAlQhBCADQQA2Asw3IAMgBDYCyDcgCCAENgKwBiACQQA6AJQ4IAItAJc4RQ0BIAJBAToAlTgMAQsCQCACKAKsNyIDQQFIDQAgAkG0N2ooAgAgA0F/aiIEQSRsaigCBEELai0AAEEIcQ0BIARBARDHAQwBCwJAIAIoAow4RQ0AQQAQ1wEMAQsCQCAERQ0AIAQoAghBgICAKHFBgICACEYNACAEQQA2ArAGCyACQgA3A8g3CyACQgA3A9A3IAJB2DdqQgA3AwAgAigCyDciA0UNBSACLQCWOA0FQQAhBCACKALMOQ0GAkAgAigCxDciCA0AQQEhCEEAIQMMCAtBACEHQQAhBCAIQQpqLQAAQQRxDQZBACEHAkACQAJAAkBBACgCsOYLIghBgAZqKgIAQwAAAABeDQBBACEFIAIoAqQ1IgkNAQwICwJAAkAgCEHYKGoqAgAiD0MAAAAAXUUNACACKAKkNSIJDQEMBwsgAigCpDUhCQJAIA9DAAAAAFwNACAJDQAgAiADNgLUNyACIAM2AtA3IAMhBQwECyAJRQ0CIAkgA0cNASACIAM2AtQ3QQAhBSAPQwAAAABbDQMMBwsgCSADRg0FC0EAIQdBACEFQQAhBCAJIANGDQYMCAsgAiADNgLUN0EAIQUgAyEHIA9DAAAAAFwNBQsgAiADNgLYNwwDC0HWuwZBgukEQcfFAEHRugUQAAALQfqNBEGC6QRBpsEAQaKNBhAAAAsgAiADNgLUN0EAIQULIAMhBwsCQCAIQeAoaioCAEMAAAAAXA0AIAIgAzYC3DcLIAUhBAwBC0EAIQQLAkAgAigCxDciA0UNACADQQpqLQAAQQRxRQ0AIAJBAToAljgLIANFIQggBEUNACAHIARGDQBB4OYFQYLpBEH1xQBB0boFEAAACyACQQA6ALA4AkAgAigC8DciBEUNACACIAQ2Atg3IAIgBDYC3DcgAiAENgLUNyACIAQ2AtA3CyACQQA2AvA3AkACQAJAAkACQAJAIAIoArg4IgQNACACQQA2ArQ4QX8hBCACQX82AsA4AkAgCA0AIAIoAsw5DQAgA0EKai0AAEEEcQ0AQX8hBAJAQQAoArDmCygCuDUiA0EBcQ0AAkBBBEEDENMBQwAAAABeDQBBEUEDENMBQwAAAABeRQ0BC0EAIQQgAkEANgLAOAsCQCADQQJxDQACQEEFQQMQ0wFDAAAAAF4NAEESQQMQ0wFDAAAAAF5FDQELQQEhBCACQQE2AsA4CwJAIANBBHENAAJAQQZBAxDTAUMAAAAAXg0AQRNBAxDTAUMAAAAAXkUNAQtBAiEEIAJBAjYCwDgLIANBCHENAAJAQQdBAxDTAUMAAAAAXg0AQRRBAxDTAUMAAAAAXkUNAQsgAkEDNgLAOEEDIQQLIAIgBDYCyDgMAQsgAigCwDhBf0YNASACKALIOEF/Rg0BIARBAUcNAiACQQI2Arg4C0MAAAAAIQ8CQCAGRQ0AQQAoArDmCyIEKALAOEF/Rw0AIAQoAsQ3IgNFDQAgA0EKai0AAEEEcQ0AIAQoAsw5DQAgBCgCjDgNAEEAIQdBACEGAkAgBEHIAGooAgAQzQFFDQBBACgCsOYLLQDANUEgcUUhBgsCQCAEQcwAaigCABDNAUUNAEEAKAKw5gstAMA1QcAAcUUhBwtBACEFQQAhCAJAIARB0ABqKAIAQQEQ0QFFDQBBACgCsOYLLQDANUGAAXFFIQgLAkAgBEHUAGooAgBBARDRAUUNAEEAKAKw5gtBwTVqLQAAQQFxRSEFCwJAIAYgB0cNACAIIAVzRQ0BCwJAIANBxAJqKAIADQAgA0HRAmotAABFDQACQCAEKAJIQQEQ0QFFDQAgA0H8AGpBADYCACADQfQAakEANgIAIANB7ABqIANB3ABqKgIAIANBgARqKgIAIANB+ANqKgIAk5M4AgAMAgsCQCAEKAJMQQEQ0QFFDQAgA0H8AGpBADYCACADQfQAakEANgIAIANB7ABqIANB3ABqKgIAIANBgARqKgIAIANB+ANqKgIAk5I4AgAMAgsCQCAIRQ0AIANB/ABqQQA2AgAgA0H0AGpBADYCACADQewAakEANgIADAILIAVFDQEgA0H8AGpBADYCACADQfQAakEANgIAIANB7ABqIANB5ABqKgIAOAIADAELIANBgARqKgIAIANB+ANqKgIAkyEQQQAoArDmCyoCtDIgAyoCgAWUIQ8gAyAEKAKMOCIKQQR0aiIGQbgGaiEHAkAgAygCnAYiCUUNACAPIAkqAoAFlCEPC0MAAAAAIBAgD5MgBkHEBmoiBioCACAHKgIEk5IiDyAPQwAAAABfGyEPAkAgBCgCSEEBENEBRQ0AIARBAjYCyDggBEEDNgLAOCAEQTA2ArQ4IA+MIQ8MAQsCQCAEKAJMQQEQ0QFFDQAgBEEDNgLIOCAEQQI2AsA4IARBMDYCtDgMAQsCQCAIRQ0AIAYgA0HcAGoqAgCMIg84AgAgByAPOAIEAkAgByoCACADIApBBHRqQcAGaiIDKgIAXkUNACADQQA2AgAgB0EANgIACyAEQdAANgK0OCAEQQM2AsA4QwAAAAAhDwwBC0MAAAAAIQ8gBUUNACAGIANB5ABqKgIAIANBIGoqAgCSIANB3ABqKgIAkyIQOAIAIAcgEDgCBAJAIAcqAgAgAyAKQQR0akHABmoiAyoCAF5FDQAgA0EANgIAIAdBADYCAAsgBEHQADYCtDggBEECNgLAOAsCQCACKALAOCIGQX9GDQAgAkEBOgCwOCACIAY2AsQ4IAIgAkH8BmooAgA2Arw4DAMLIAItALA4DQJBASEHDAMLQc7ABUGC6QRBkMYAQdG6BRAAAAtB6dwFQYLpBEGRxgBB0boFEAAAC0EAIQcgAigCyDcNAEEAIQcgAkEANgKcOCACQYECOwCZOCACQQA6AJY4CwJAAkACQAJAAkACQEEAKAKw5gsiAy0AsDgNACADIAMtAJk4IgQ6AJg4IAQNAQwCCyADQQE6AJg4CyADKALEN0UNAQsCQCACKALENyIERQ0AIARBCmotAABBBHENACACKALMOQ0AIAMqArQyIAQqAoAFlCEQAkAgBCgCnAYiCEUNACAQIAgqAoAFlCEQCwJAAkAgEEMAAMhClCACKgIYlEMAAAA/kiIQi0MAAABPXUUNACAQqCEIDAELQYCAgIB4IQgLIAiyIRACQCAEQcQCaigCAA0AIAcgBEHRAmotAABFcg0AAkACQCAGQQFLDQAgBEEANgJwAkACQEMAAIA/QwAAgL8gBhsgEJQgBCoCWJIiEYtDAAAAT11FDQAgEaghBgwBC0GAgICAeCEGCyAEIAayOAJoIARB+ABqIQYMAQsgBkF+cUECRw0BIARB9ABqQQA2AgACQAJAQwAAgL9DAACAPyAGQQJGGyAQlCAEQdwAaioCAJIiEYtDAAAAT11FDQAgEaghBgwBC0GAgICAeCEGCyAEQewAaiAGsjgCACAEQfwAaiEGCyAGQQA2AgALIABBEGpBBEEAQ83MzD1DAAAgQRDVAQJAIAAqAhAiEUMAAAAAWw0AIAQtAIgBRQ0AIARBADYCeCAEQQA2AnACQAJAIBEgEJQgBCoCWJIiEYtDAAAAT11FDQAgEaghBgwBC0GAgICAeCEGCyAEIAayOAJoCyAAKgIUIhFDAAAAAFsNACAEQfwAakEANgIAIARB9ABqQQA2AgACQAJAIBEgEJQgBEHcAGoqAgCSIhCLQwAAAE9dRQ0AIBCoIQYMAQtBgICAgHghBgsgBEHsAGogBrI4AgALIAJCADcCzDggAkHUOGpBADYCACACQeA4akH////7BzYCACACQeQ4akIANwIAIAJB2DhqQv////v3//+//wA3AgAgAkHsOGpCADcCACACQfQ4akIANwIAIAJB/DhqQQA2AgAgAkGIOWpB////+wc2AgAgAkGMOWpCADcCACACQYA5akL////79///v/8ANwIAIAJBlDlqQgA3AgAgAkGcOWpCADcCACACQaw5akL////79///v/8ANwIAIAJBpDlqQoCAgIDw//+//wA3AgAgAkG0OWpCADcCACACQbw5akIANwIAAkAgBw0AIAIoAvQ3QQRHDQAgAigCjDgNACAEQYAEaioCACAEQRBqKgIAIhCTQwAAgD+SIRMgBEH4A2oqAgAgEJNDAACAv5IhESAEQfwDaioCACAEKgIMIhCTQwAAgD+SIRICQCAEKgK4BiAEKgL0AyAQk0MAAIC/kiIUYEUNACAEQbwGaioCACARYEUNACAEQcAGaioCACASX0UNACAEQcQGaioCACATXw0BCyAEQbgGaiEHIAMqArQyIAQqAoAFlCEQAkAgBCgCnAYiBEUNACAQIAQqAoAFlCEQCyAAIBMgEyARkyIVIBBDAAAAP5QiECAVIBBdGyIVkzgCHCAAIBIgEiAUkyITIBAgEyAQXRsiEJM4AhggACARIBWSOAIUIAAgFCAQkjgCECAHIABBEGoQ2AEgAkIANwPINyACKALENyEECwJAAkAgBEUNACAEIAIoAow4QQR0aiIDQcQGaioCACAEQRBqKgIAIhCSIRIgA0G8BmoqAgAgEJIhEyADQcAGaioCACAEKgIMIhGSIRAgA0G4BmoqAgAgEZJDAACAP5IhEQwBC0EAKAKw5gsiBEEUaioCACESIARBEGoqAgAhEEMAAIA/IRFDAAAAACETCyACQYQ4aiAPIBKSIhI4AgAgAkH8N2ogDyATkiIPOAIAIAJBgDhqIBEgECARIBBdGyIQOAIAIAIgEDgC+DcCQCAPIBJeDQAgAkEANgKIOAJAQQAoArDmCyICQeQBaiILEMEBRQ0AAkACQCACKgLkASIPi0MAAABPXUUNACAPqCEEDAELQYCAgIB4IQQLIAIgBLIiDzgC+D4gAiAPOALkASACQfw+aiEEAkACQCACQegBaiIDKgIAIg+LQwAAAE9dRQ0AIA+oIQcMAQtBgICAgHghBwsgBCAHsiIPOAIAIAMgDzgCAAsCQAJAAkAgCxDBAUUNACACQYAHahDBAQ0BCyACQfQGakIANwIADAELIAJB9AZqIAIqAuQBIAIqAoAHkyIPOAIAIAJB+AZqIAJB6AFqKgIAIAJBhAdqKgIAkyIQOAIAAkAgD0MAAAAAXA0AIBBDAAAAAFsNAQsgAkEAOgCXOAsgAkGAB2ogAikC5AE3AwAgAkEIaiEHQQAhBANAIAcgBEECdGoiBkGACGohCCAGQewHaiEDAkACQCAHIARqIgpB5AFqIgUtAABFDQAgAyoCACEPIAIgBGoiDEHiB2oiDUEAOgAAIAxB2AdqIgkgD0MAAAAAXSIOOgAAIAggDzgCAAJAIA5FDQAgA0EANgIAIApB1QdqIghBADoAAAJAIAIqAiggAisDiDQiFyAHIARBA3QiDmoiA0GoB2oiDCsDAKG2XkUNAEMAAAAAIQ9DAAAAACEQAkAgCxDBAUUNACACKgLoASACIA5qIg5BjAdqKgIAkyEQIAIqAuQBIA5BiAdqKgIAkyEPCwJAIA8gD5QgECAQlJIgAioCLCIPIA+UXUUNACAIQQE6AAALIAIqAihDAAAAwJS7IRcLIAwgFzkDACADQYAHaiACKQLkATcDACAKQeQHaiAILQAAOgAAIANBlAhqQgA3AgAgBkG8CGpBADYCAAwCCyADIA8gAioCGJI4AgAgDEHdB2pBADoAAEMAAAAAIQ9DAAAAACEQAkAgCxDBAUUNACACKgLoASACIARBA3RqIgNBjAdqKgIAkyEPIAIqAuQBIANBiAdqKgIAkyEQCyAGQbwIaiIDIAMqAgAiESAQIBCUIA8gD5SSIhIgESASYBs4AgAgByAEQQN0aiIDQZQIaiIGIAYqAgAiESAQjCAQIBBDAAAAAF0bIhAgESAQYBs4AgAgA0GYCGoiAyADKgIAIhAgD4wgDyAPQwAAAABdGyIPIBAgD2AbOAIADAELIAIgBGoiBkHYB2oiCUEAOgAAIAZB4gdqIg0gAyoCACIPQwAAAABgOgAAIAggDzgCACADQYCAgPx7NgIAIAZB3QdqQQA6AAALAkAgBS0AAA0AIA0tAAANACACIARqQewHakEAOgAACwJAIAktAABFDQAgAkEAOgCXOAsgBEEBaiIEQQVHDQALEMgBEMABAkACQAJAEMUBDQAgASgCzDlFDQEgASoC3DlDAAAAAF5FDQELIAEgASoCGEMAAMBAlCABKgLEOpIiD0MAAIA/IA9DAACAP10bOALEOgwBCyABIAEqAsQ6IAEqAhhDAAAgwZSSIg9DAAAAACAPQwAAAABgGzgCxDoLIAFBfzYC+GMgAUEANgLoPCABQn83A/BjIAFCgICA/IOAgMA/NwPwXgJAQQAoArDmCyIEKAKANUUNACAEIAQqAow1IARBGGoqAgCTOAKMNQJAAkBBABDBAUUNACAEQeQBaioCACAEKgKENZMiDyAPlCAEQegBaioCACAEQYg1aioCAJMiDyAPlJIgBEEwaioCACIPIA+UXg0BCyAEKgKMNUMAAAAAX0UNAQsgBEEANgKMNSAEQQA2AoA1CwJAAkAgBEH0AWoqAgAiD0MAAAAAXA0AIARB+AFqKgIAQwAAAABbDQELAkAgBCgCpDVFDQAgBC0AtjUNAQsCQCAEKAKUNUUNACAELQCaNQ0BCwJAIAQoAoA1IgINACAEKALwNCICRQ0BCyACLQCNAQ0AAkAgD0MAAAAAWw0AAkAgBEH8AWotAABFDQAgBEGgAWotAABFDQECQEEAKAKw5gsiAygCgDUgAkYNACADQYCAgIAENgKMNSADIAI2AoA1IAMgA0HkAWopAgA3AoQ1IAQqAvQBIQ8LIAJDAAAAP0MAACBAIA9DzczMPZQgAioCgAUiEJIiDyAPQwAAIEBeGyAPQwAAAD9dGyIPOAKABSACQQtqLQAAQQFxDQIgBEHkAWoqAgAhEyACKgIUIREgAioCDCESIAAgAkEQaioCACIUQwAAgD8gDyAQlSIPkyIQIAJBGGoiAyoCACIVlCAEQegBaioCACAUk5QgFZWSOAIUIAAgEiAQIBGUIBMgEpOUIBGVkjgCECACIABBEGpBABDCAQJAAkAgDyADKgIAlCIQi0MAAABPXUUNACAQqCEEDAELQYCAgIB4IQQLIAMgBLI4AgACQAJAIA8gAioCFJQiEItDAAAAT11FDQAgEKghBAwBC0GAgICAeCEECyACIASyOAIUAkACQCAPIAIqAhyUIhCLQwAAAE9dRQ0AIBCoIQQMAQtBgICAgHghBAsgAiAEsjgCHAJAAkAgDyACQSBqIgQqAgCUIg+LQwAAAE9dRQ0AIA+oIQIMAQtBgICAgHghAgsgBCACsjgCAAwCCyAEQf0Bai0AAA0AAkBBACgCsOYLIgcoAoA1IAJGDQAgByACNgKANSAHQYCAgIAENgKMNSAHIAdB5AFqKQIANwKENQsCQCACKAIIIgNBgICACHFFDQADQAJAIANBkARxQRBGDQAgAkHkAGoqAgBDAAAAAFwNAgsgAigCnAYiAigCCCIDQYCAgAhxDQALCyADQZAEcQ0AIAJBgARqKgIAIAJB+ANqKgIAk0MfhSs/lCERIAcqArQyIAIqAoAFlCEQAkAgAigCnAYiA0UNACAQIAMqAoAFlCEQCyACQfwAakEANgIAIAJB9ABqQQA2AgACQAJAIBBDAACgQJQiECARIBAgEV0bIhCLQwAAAE9dRQ0AIBCoIQMMAQtBgICAgHghAwsgAkHsAGogAkHcAGoqAgAgDyADspSTOAIACwJAAkAgBEH4AWoqAgAiD0MAAAAAWw0AIARB/QFqLQAARQ0BCyAEKgL0ASIPQwAAAABbDQEgBEH9AWotAABFDQELIA9DAAAAAFsNACAEQfwBai0AAA0AAkBBACgCsOYLIgMoAoA1IAJGDQAgAyACNgKANSADQYCAgIAENgKMNSADIANB5AFqKQIANwKENQsCQCACKAIIIgRBgICACHFFDQADQAJAIARBkARxQRBGDQAgAioCYEMAAAAAXA0CCyACKAKcBiICKAIIIgRBgICACHENAAsLIARBkARxDQAgAyoCtDIgAioCgAWUIRAgAkH8A2oqAgAgAioC9AOTQx+FKz+UIRECQCACKAKcBiIERQ0AIBAgBCoCgAWUIRALIAJBADYCeCACQQA2AnACQAJAIBAgEJIiECARIBAgEV0bIhCLQwAAAE9dRQ0AIBCoIQQMAQtBgICAgHghBAsgAiACKgJYIA8gBLKUkzgCaAsCQAJAAkACQAJAQQAoArDmCyIEKALENyICRQ0AIAItAIoBRQ0AIAJBCmotAABBBHENACAEQfwBai0AAA0AIARBNGooAgAiAkF/Sg0BCyAEQQA6APw5DAELIAQgAkEBENEBIgI6APw5IAJFDQAgBCgCpDVFDQELIAQoAug5IQIMAQsgBEH/////BzYC9DkgBCAEKALENyICNgLoOQJAIAQoAsg3RQ0AIAQoApA4IgNB/////wdGDQAgBCADQX9BASAEQf0Bai0AABtqQQFqNgL4OQwBCyAEQQAgBEH9AWotAABrwDYC+DkLIARBADYC5DkgBEL/////9/////8ANwLsOQJAIAJFDQAgBCACNgLkOQJAIAQoAvQ5IgNB/////wdGDQAgAkGoA2ooAgAiB0F/Rg0AIAQgB0EBaiIHIANqIAdvNgLsOQsCQCAEKAL4OSIDQf////8HRg0AIAJBrANqKAIAIgJBf0YNACAEIAJBAWoiAiADaiACbzYC8DkLIARBADYC6DkgBEL/////9/////8ANwL0OQsgBEH/////BzYCkDgCQAJAAkAgASgCuDQiBCABKAKsNEcNAEP//39/IRACQCABLQCfNA0AIAFBuAFqKgIAIg9DAAAAAF0NACABKwOINLYgD5MhEAsCQCAERQ0AQQAhAgNAIAQgAkwNAyABKAK0NCACQQJ0aigCACIEQQA7AZYBIARBADoAjAEgBCAELQCKASIDOgCLASAEQQA6AIoBAkAgAw0AIAQtAOAGDQAgBCoC4AQgEF1FDQAgBBCLAQsgAkEBaiICIAEoAqw0IgRHDQALCwJAIAEoAqg+IgJBAUgNAEEAIQQDQAJAIAEoArA+IARBAnRqKgIAIg9DAAAAAGBFDQAgDyAQXUUNACABKAKAPiAETA0FIAEoAog+IARBqARsahDIBCABKAKoPiECCyAEQQFqIgQgAkgNAAsLAkAgAS0AnzRFDQAQigELIAFBADoAnzQCQCABKALENyIERQ0AIAQtAIsBDQBBAEEAENkBCwJAIAFB1DRqKAIAQX9KDQACQEEAKAKw5gsiBEUNACAEQfAGaiIEIAQoAgBBAWo2AgALQQBBACgCuOYLQQAoApDYChECACEEAkAgAUHYNGooAgAiAkUNACAEIAIgASgC0DRBAnQQng8aAkAgASgC2DQiAkUNAEEAKAKw5gsiA0UNACADQfAGaiIDIAMoAgBBf2o2AgALIAJBACgCuOYLQQAoApTYChEAAAsgAUEANgLUNCABIAQ2Atg0CyABQQA2AtA0AkAgAUG8N2ooAgBBf0oNAAJAQQAoArDmCyIERQ0AIARB8AZqIgQgBCgCAEEBajYCAAtBAEEAKAK45gtBACgCkNgKEQIAIQQCQCABQcA3aigCACICRQ0AIAQgAiABKAK4N0EkbBCeDxoCQCABKALANyICRQ0AQQAoArDmCyIDRQ0AIANB8AZqIgMgAygCAEF/ajYCAAsgAkEAKAK45gtBACgClNgKEQAACyABQQA2Arw3IAEgBDYCwDcLIAFBADYCuDcCQCABQZg3aigCACIEQX9KDQACQEEAKAKw5gsiBEUNACAEQfAGaiIEIAQoAgBBAWo2AgALQQBBACgCuOYLQQAoApDYChECACEEAkAgAUGcN2ooAgAiAkUNACAEIAIgASgClDdBAnQQng8aAkAgASgCnDciAkUNAEEAKAKw5gsiA0UNACADQfAGaiIDIAMoAgBBf2o2AgALIAJBACgCuOYLQQAoApTYChEAAAsgASAENgKcNyABQgA3ApQ3DAYLQQAhAiABQQA2ApQ3IARFDQUgAUGcN2ooAgAhBAwGC0GFrwVBgukEQdAeQa3GBRAAAAtB4LQFQe+OBUHcDEHL+QUQAAALQeC0BUHvjgVB3AxBy/kFEAAAC0GWlAhBgukEQeDGAEHRugUQAAALQZyIBkGC6QRBgMQAQaSaBRAAAAsCQEEAKAKw5gsiBEUNACAEQfAGaiIEIAQoAgBBAWo2AgALQSBBACgCuOYLQQAoApDYChECACEEAkAgAUGcN2ooAgAiAkUNACAEIAIgASgClDdBAnQQng8aAkAgASgCnDciAkUNAEEAKAKw5gsiA0UNACADQfAGaiIDIAMoAgBBf2o2AgALIAJBACgCuOYLQQAoApTYChEAAAsgAUEINgKYNyABIAQ2Apw3IAEoApQ3IQILIAQgAkECdGpBADYCACABIAEoApQ3QQFqNgKUNwJAIAFBpDdqKAIAQX9KDQACQEEAKAKw5gsiBEUNACAEQfAGaiIEIAQoAgBBAWo2AgALQQBBACgCuOYLQQAoApDYChECACEEAkAgAUGoN2ooAgAiAkUNACAEIAIgASgCoDdBMGwQng8aAkAgASgCqDciAkUNAEEAKAKw5gsiA0UNACADQfAGaiIDIAMoAgBBf2o2AgALIAJBACgCuOYLQQAoApTYChEAAAsgAUEANgKkNyABIAQ2Aqg3CyABQQA2AqA3IAEoAsQ3QQAQvQFBACgCsOYLIgRBADYC9F8CQCAELQDwX0UNACAEQQc2Aug8IAQoApQ1IQMCQCAEQewAaigCACICQQBIDQAgAkEBENEBRQ0AIARBADoA8F8LAkACQEEAKAKw5gsiAkH0B2oqAgBDAAAAAFsNACADRSEHDAELAkAgAw0AQQEhBwwBC0EAIQcgBEEAOgDwXyAEIAM2AvRfCyACQcQ2akGas+b4AzYCACACIAIoAvA1QcAAcjYC8DVBAEEAENoBIAAgAzYCAEHj/wUgABDeBEHpkgdBABDeBEEAKAKw5gsgB0EEdGpB3CtqQYbICEEAEOAEENsBQQAoArDmCyEECyABQQE6AJ00IARBkDZqQoCAoJ6EgIDkwwA3AwAgBEH4NWpBBDYCACAEIAQoAvA1QQJyNgLwNUHcqQRBAEEAENwBGgJAIAEoAuw0LQCSAUUNAAJAIAEoArhfIgNBAUgNAEEAIQQDQAJAIAEoAsBfIARBBHRqIgIoAgBBAUcNACABIAIgAigCCBEAACABKAK4XyEDCyAEQQFqIgQgA0gNAAsLIABBIGokAA8LQa64BUGC6QRB/R5BrcYFEAAAC0H4rARBgukEQbs2QYvIBBAAAAtxAQJ/IwBBEGsiASQAIAFBADYCDAJAIABB9fMFIAFBDGpBABBHIgBFDQAgACABKAIMELEDAkBBACgCsOYLIgJFDQAgAkHwBmoiAiACKAIAQX9qNgIACyAAQQAoArjmC0EAKAKU2AoRAAALIAFBEGokAAv4AQMCfQJ/AX4CQAJAIABFDQBDAAAAACEBIAAqAtgBIgJDAAAAAF5FDQFBACgCsOYLIgMgADYCrDIgA0MAAIA/IAIgA0GcAWoqAgAgACoCNJSUIgIgAkMAAIA/XxsiAjgCtDICQCADKALsNCIERQ0AIAIgBCoCgAWUIQEgBCgCnAYiBEUNACABIAQqAoAFlCEBCyADIAE4ArAyIAAoAlQiBCkCICEFIANBhDRqIARBKGo2AgAgAyAFNwO4MiADQcQyaiABOAIAIANBwDJqIAA2AgAPC0G1lAhBgukEQbsxQcumBBAAAAtBmqcFQYLpBEG8MUHLpgQQAAALSAEBf0EAIQECQAJAIABBAEgNACAAQYAETw0BQQAoArDmCyAAakGAAmotAABBAEchAQsgAQ8LQeWPCEGC6QRBhSNBmfAEEAAAC2sBAn8CQAJAQQAoArDmCyIDKALENyIERQ0AIAFBAk8NASADIAI2Asw3IAMgADYCyDcgBCABQQJ0akGwBmogADYCAA8LQfqNBEGC6QRBpsEAQaKNBhAAAAtBxrIGQYLpBEGnwQBBoo0GEAAAC/MEAgN/Cn0jAEEgayIDJAAgAUH4A2oqAgAhBiABQfwDaioCACEHIAFBgARqKgIAIQhBACgCsOYLIQQgASoC9AMhCSAAQgA3AgAgCEMAAIA/kiEKIAdDAACAP5IhCyAGQwAAgL+SIQwgAkEMaioCACENIAIqAgghDiACKgIEIQgCQAJAIAIqAgAiDyAJQwAAgL+SIglgRQ0AIAggDGBFDQAgDiALX0UNAEMAAAAAIQZDAAAAACEHIA0gCl8NAQsCQCABLQCIAUUNAAJAAkAgDyAJXUUNACAPIAEqAgyTIARB4CpqKgIAkyEGQwAAAAAhBwwBCyAOIAtgRQ0BIA4gASoCDJMgBEHgKmoqAgCSIQZDAACAPyEHCyABQQA2AnggASAHOAJwAkACQCABKgJYIAaSIgaLQwAAAE9dRQ0AIAaoIQUMAQtBgICAgHghBQsgASAFsjgCaAsCQAJAIAggDF1FDQAgASAIIAFBEGoqAgCTIARB5CpqKgIAk0MAAAAAEN8CDAELIA0gCmBFDQAgASANIAFBEGoqAgCTIARB5CpqKgIAkkMAAIA/EN8CCyADQQhqIAEQ7wEgAUHcAGoqAgAhBiADKgIMIQggACADKgIIIAEqAliTIgc4AgAgACAIIAaTIgY4AgQLAkAgAUELai0AAEEBcUUNACABKAKcBiEBIAIqAgAhCCACKgIEIQwgAioCCCENIANBFGogAioCDCAGkzgCACADIA0gB5M4AhAgAyAMIAaTOAIMIAMgCCAHkzgCCCADQRhqIAEgA0EIahDPASAAIAcgAyoCGJI4AgAgACAGIAMqAhySOAIECyADQSBqJAAL7wICBH8FfQJAAkBBACgCsOYLIgEtAJY4DQAgAS0AlzhFDQAgASgCxDciAg0BCwJAIAFB5AFqIgIQwQFFDQAgACACKQIANwIADwsgACABKQP4PjcCAA8LAkACQEMAAAAAIAFBFGoqAgAiBSACQRBqKgIAIAIgASgCjDhBBHRqIgNBxAZqKgIAIgYgAUHUKmoqAgAiByAGIANBvAZqKgIAkyIGIAcgBl0bk5IiBiAGIAVeGyAGQwAAAABdGyIGi0MAAABPXUUNACAGqCEEDAELQYCAgIB4IQQLIAFBEGoqAgAhBiABQdAqaioCACEHIANBwAZqKgIAIQggA0G4BmoqAgAhBSACKgIMIQkgACAEsjgCBAJAAkBDAAAAACAGIAkgBSAHQwAAgECUIgcgCCAFkyIIIAcgCF0bkpIiBSAFIAZeGyAFQwAAAABdGyIGi0MAAABPXUUNACAGqCEBDAELQYCAgIB4IQELIAAgAbI4AgALhQECAn8CfUEAIQICQAJAIABBAEgNACAAQYAETw0BQQAoArDmCyIDIABBAnRqQdgIaioCACIEQwAAAABbIgINACABRQ0AQQAhAiAEIANBjAFqKgIAIgVeRQ0AIAAgBSADQZABaioCABCKAkEASiECCyACDwtB5Y8IQYLpBEGqI0H03gUQAAALewEDf0EAIQMCQCAAQQBIDQBBACgCsOYLIgQoArg0IQUCQANAIAAgAUYNASAAIAVODQECQCAEKALANCAAQQJ0aigCACIDLQCLAUUNACADKAKgBiADRw0AIANBCmotAABBCHFFDQMLIAAgAmoiAEF/Sg0ACwtBACEDCyADC8ACAgF/An1BACgCsOYLIQICQCABDQAgAiAAQQJ0akGABmoqAgAPCyACIABBAnRqQdgoaioCACEDAkAgAUECRw0AIANDAAAAAF1FDQBDAACAP0MAAAAAIAIgAEECdGpBrClqKgIAQwAAAABgGw8LQwAAAAAhBAJAIANDAAAAAF0NAAJAAkACQAJAIAFBf2oOBQAEAQIDBAtDAACAP0MAAAAAIANDAAAAAFsbDwsgAyACQRhqKgIAkyADIAJBjAFqKgIAQ+xROD+UIAJBkAFqKgIAQ83MTD+UEIkCsg8LIAMgAkEYaioCAJMgAyACQYwBaioCAEMAAKA/lCACQZABaioCACIEIASSEIkCsg8LIAMgAkEYaioCAJMgAyACQYwBaioCAEPsUTg/lCACQZABaioCAEOamZk+lBCJArIhBAsgBAu/AQEEfwJAQQAoArDmCyIBKALMOSICRQ0AAkAgAkELai0AAEEIcQ0AIAEoArg0IgMhBAJAA0ACQCAEQQFODQBBfyEEDAILIAEoAsA0IARBf2oiBEECdGooAgAgAkcNAAsLAkACQCAEIABqQYGAgIB4IAAQ0gEiAg0AIABBH3UgA0F/anEgBCAAENIBIgJFDQELIAEgAjYCzDkgASACNgLQOQsgAUEAOgDgOQsPC0H3sQRBgukEQdnIAEH6jwQQAAAL+gIBBn0gAEIANwIAQwAAAAAhBUMAAAAAIQYCQCABQQFxRQ0AQRIgAhDTASEFQREgAhDTASEGQRQgAhDTASEHQRMgAhDTASEIIAAgBSAGk0MAAAAAkiIGOAIAIAAgByAIk0MAAAAAkiIFOAIECwJAIAFBAnFFDQBBBSACENMBIQdBBCACENMBIQhBByACENMBIQlBBiACENMBIQogACAHIAiTIAaSIgY4AgAgACAJIAqTIAWSIgU4AgQLAkAgAUEEcUUNAEEJIAIQ0wEhB0EIIAIQ0wEhCEELIAIQ0wEhCUEKIAIQ0wEhCiAAIAcgCJMgBpIiBjgCACAAIAkgCpMgBZIiBTgCBAsCQCADQwAAAABbDQBBACgCsOYLQbgGaioCAEMAAAAAXkUNACAAIAUgA5QiBTgCBCAAIAYgA5QiBjgCAAsCQCAEQwAAAABbDQBBACgCsOYLQbwGaioCAEMAAAAAXkUNACAAIAUgBJQ4AgQgACAGIASUOAIACwv+AQECfwJAAkACQEEAKAKw5gsiAigCxDcgAEcNAAJAIAAoAggiA0GAgBBxRQ0AIAAoArAGIQAMAgsCQCADQYCAgChxQYCAgAhHDQAgACgCsAYiAEUNACABRQ0CC0EAIAIoAow4QQAQzgEgAkIANwOgOCACQQA2Apw4IAJBATsAmTggAkGoOGpCADcDAAJAAkBBACgCsOYLIgItALA4DQAgAiACLQCZOCIAOgCYOCAARQ0EDAELIAJBAToAmDgLIAIoAsQ3DQJBnIgGQYLpBEGAxABBpJoFEAAAC0HwjQRBgukEQYfEAEHsjwQQAAALIAJBADYCzDcgAiAANgLINwsLiAEBAn9BACgCsOYLIgEgADYCjDggASgCxDchAgJAAkAgAA0AAkACQCACKAKsBiIARQ0AIAAtAIsBDQELIAIhAAsgASAANgLENyAAKAKwBiICDQEgACECCyACQQEQ1gEPCyABQQA2Asw3IAEgAjYCyDcgACACNgKwBiABQQE6AJc4IAFBATsAlTgLswECBH0BfiABKgIEIQIgACABKgIAIgMgASkCCCIGp74iBCAAKgIAIgUgBSAEXhsgBSADXRs4AgAgACACIAZCIIinviIDIAAqAgQiBSAFIANeGyAFIAJdGzgCBCABKgIEIQIgACABKgIAIgMgASkCCCIGp74iBCAAKgIIIgUgBSAEXhsgBSADXRs4AgggAEEMaiIAIAIgBkIgiKe+IgMgACoCACIFIAUgA14bIAUgAl0bOAIAC/gBAQV/QQAoArDmCyICKAK4NCIDQX9qIQQCQCAARQ0AIAMhBQNAIAUiBkEBSA0BIAIoAsA0IAZBf2oiBUECdGooAgAgAEcNAAsgBkF+aiEECwJAAkAgBEEASA0AIAQgA0ghBgNAIAQhBSAGRQ0CAkAgAigCwDQgBUECdGooAgAiBCABRg0AIAQtAIsBRQ0AIAQoAggiAEGAgIAIcQ0AIABBgIQQcUGAhBBGDQACQAJAIAQoAqwGIgVFDQAgBS0AiwENAQsgBCEFCyAFELwBDwsgBUF/aiEEIAVBAEoNAAsLQQAQvAEPC0HgtAVB744FQdwMQcv5BRAAAAvPAgICfwF9IwBBMGsiAiQAAkACQEEAKAKw5gsiAy0A7TwNACADLQDuPEUNAQsgA0GINmpCADcDAEEBIQEgA0H0NWpBATYCACADIAMoAvA1QcEAcjYC8DUgA0HENmogA0GoLGoqAgBDmpkZP5Q4AgAgA0GENmogA0HMK2oqAgAiBEMAAABBlCADQegBaioCAJI4AgAgA0GANmogA0HkAWoqAgAgBEMAAIBBlJI4AgALIAIgAygC0F42AhAgAkEgakEQQY7oBSACQRBqEEMaAkAgAUEBcUUNAEEAKAKw5gtB3DRqIAJBIGpBAEEAEEUQUiIBRQ0AIAEtAIoBRQ0AIAFBAToAqAEgAUEBOgCRASADIAMoAtBeQQFqIgE2AtBeIAIgATYCACACQSBqQRBBjugFIAIQQxoLIAJBIGpBACAAQceGsBByENwBGiACQTBqJAALMAACQEEAKAKw5gsoAuw0QQtqLQAAQQJxDQBBnesEQYLpBEGlPUGS6wQQAAALEPsBC5qLAQQcfwJ+AXwTfSMAQeABayIDJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEUNACAALQAARQ0AQQAoArDmCyIELQCcNEUNASAEKAKUNCAEKAKQNEYNAiAEQdw0aiIFIABBAEEAEEUQUiIGIQcCQCAGDQAgBEHwBmoiByAHKAIAQQFqNgIAQeQGQQAoArjmC0EAKAKQ2AoRAgAiByAEIAAQfxogAyAHNgK4ASAHIAI2AgggBSAHKAIEIAcQViAHQoCAwJOEgIC4wgA3AgwCQCACQYACcQ0AIAcoAgQQ3gEiBUUNACAHIARBoN8AaiAFEN8BNgKEBSAHIAcoAKsBQfv3b3E2AKsBIAcgBRDgAQsgB0HkAWogBykCDCIfNwIAIAdB3AFqIB83AgACQAJAIAJBwABxRQ0AIAdBADoAowEgB0GCBDsBoAEMAQsCQCAHKgIUQwAAAABfRQ0AIAdBAjoAoAELAkAgB0EYaioCAEMAAAAAX0UNACAHQQI6AKEBC0EBIQUCQCAHLACgAUEASg0AIAcsAKEBQQBKIQULIAcgBToAowELAkAgBCgCuDQiBSAEQbw0aigCAEcNACAFQQFqIQgCQAJAIAUNAEEIIQkMAQsgBUECbSAFaiEJCyAFIAkgCCAJIAhKGyIJTg0AIAlBAnQhBQJAQQAoArDmCyIIRQ0AIAhB8AZqIgggCCgCAEEBajYCAAsgBUEAKAK45gtBACgCkNgKEQIAIQUCQCAEQcA0aigCACIIRQ0AIAUgCCAEKAK4NEECdBCeDxoCQCAEKALANCIIRQ0AQQAoArDmCyIKRQ0AIApB8AZqIgogCigCAEF/ajYCAAsgCEEAKAK45gtBACgClNgKEQAACyAEIAk2Arw0IAQgBTYCwDQgBCgCuDQhBQsgBEHANGooAgAgBUECdGogBzYCACAEIAQoArg0QQFqNgK4NCAEKAKsNCEHAkACQCACQYDAAHFFDQAgBEGsNGohBQJAIAcNAAJAAkAgBEGwNGooAgBFDQAgBEG0NGooAgAhB0EAIQkMAQsCQEEAKAKw5gsiB0UNACAHQfAGaiIHIAcoAgBBAWo2AgALQSBBACgCuOYLQQAoApDYChECACEHAkAgBEG0NGooAgAiCUUNACAHIAkgBCgCrDRBAnQQng8aAkAgBCgCtDQiCUUNAEEAKAKw5gsiCEUNACAIQfAGaiIIIAgoAgBBf2o2AgALIAlBACgCuOYLQQAoApTYChEAAAsgBEEINgKwNCAEIAc2ArQ0IAQoAqw0IQkLIAcgCUECdGogAygCuAE2AgAgBSAFKAIAQQFqNgIADAILIAUgBEG0NGooAgAgA0G4AWoQ4QEaDAELAkAgByAEQbA0aigCAEcNACAHQQFqIQUCQAJAIAcNAEEIIQkMAQsgB0ECbSAHaiEJCyAHIAkgBSAJIAVKGyIFTg0AIAVBAnQhBwJAQQAoArDmCyIJRQ0AIAlB8AZqIgkgCSgCAEEBajYCAAsgB0EAKAK45gtBACgCkNgKEQIAIQcCQCAEQbQ0aigCACIJRQ0AIAcgCSAEKAKsNEECdBCeDxoCQCAEKAK0NCIJRQ0AQQAoArDmCyIIRQ0AIAhB8AZqIgggCCgCAEF/ajYCAAsgCUEAKAK45gtBACgClNgKEQAACyAEIAU2ArA0IAQgBzYCtDQgBCgCrDQhBwsgBEG0NGooAgAgB0ECdGogAygCuAE2AgAgBCAEKAKsNEEBajYCrDQLIAMoArgBIQcLIAJBBnIgAiACQYCEMHFBgIQwRhsiCUGAgIAMcUGAgIAERg0DIAQoApA0IQtBACECAkAgBCgC0DQNACAELQCdNEEARyECCyAHKALcBCEMIAcgAjoAkgEgC0F/aiECIAcsAKkBIQgCQAJAIAlBgICAIHENACAMIAJIIQ0MAQsgBCgCuDciBUEASA0FIAQoAqw3IAVMDQUgDCACSCAHKAKcASAEQbQ3aigCACAFQSRsaiICKAIARyAHIAIoAgRHcnIhDQsgByANIAhBAEpyIgI6AJABAkAgAkEBRw0AIAcgBygAqwFBiJAgcjYAqwELAkACQCAMIAtGIgUNACAHIAs2AtwEIAcgCTYCCCAEKwOINCEhIAdBADsBmAEgByAhtjgC4AQgBCAEKALoNCICQQFqNgLoNCAHIAI7AZoBDAELIAcoAgghCQsCQAJAIAQoAtA0IgINAEEAIQoMAQsgAkEATA0GIAJBAnQgBEHYNGooAgBqQXxqKAIAIQoLAkACQCAFDQAgCkEAIAlBgICAKHEbIQoMAQsgBygCnAYhCgsgCUGAgIAIcSEOAkAgCg0AIA4NBwsCQCAHKALAAQ0AAkACQCAHQcQBaigCAEUNACAHQcgBaigCACECQQAhDwwBCwJAQQAoArDmCyICRQ0AIAJB8AZqIgIgAigCAEEBajYCAAtBIEEAKAK45gtBACgCkNgKEQIAIQICQCAHQcgBaigCACIPRQ0AIAIgDyAHKALAAUECdBCeDxoCQCAHKALIASIPRQ0AQQAoArDmCyIQRQ0AIBBB8AZqIhAgECgCAEF/ajYCAAsgD0EAKAK45gtBACgClNgKEQAACyAHQQg2AsQBIAcgAjYCyAEgBygCwAEhDwsgAiAPQQJ0aiAHKAIENgIAIAcgBygCwAFBAWo2AsABIAQoAtA0IQILAkAgAiAEQdQ0aigCAEcNACACQQFqIQ8CQAJAIAINAEEIIRAMAQsgAkECbSACaiEQCyACIBAgDyAQIA9KGyIPTg0AIA9BAnQhAgJAQQAoArDmCyIQRQ0AIBBB8AZqIhAgECgCAEEBajYCAAsgAkEAKAK45gtBACgCkNgKEQIAIQICQCAEQdg0aigCACIQRQ0AIAIgECAEKALQNEECdBCeDxoCQCAEKALYNCIQRQ0AQQAoArDmCyIRRQ0AIBFB8AZqIhEgESgCAEF/ajYCAAsgEEEAKAK45gtBACgClNgKEQAACyAEIA82AtQ0IAQgAjYC2DQgBCgC0DQhAgsgBEHYNGooAgAgAkECdGogBzYCACAEIAc2Auw0IAQgBCgC0DRBAWo2AtA0IAdB1ANqQQAoArDmCyICKALsNCgCwAE7AQAgB0HWA2ogAigC5DY7AQAgB0HYA2ogAigC8DY7AQAgB0HaA2ogAigC/DY7AQAgB0HcA2ogAigCiDc7AQAgB0HeA2ogAigCoDc7AQAgB0HgA2ogAigCuDc7AQAgBEEANgLsNAJAIAlBgICAIHEiEkUNACAEKAK4NyICQQBIDQggBCgCrDcgAkwNCCAEQbQ3aigCACACQSRsaiIPIAc2AgQCQCACIARBvDdqKAIARw0AIAIgAkEBdiACakEIIAIbIhAgAkEBaiIRIBAgEUobIhBPDQAgEEEkbCECAkBBACgCsOYLIhFFDQAgEUHwBmoiESARKAIAQQFqNgIACyACQQAoArjmC0EAKAKQ2AoRAgAhAgJAIARBwDdqKAIAIhFFDQAgAiARIAQoArg3QSRsEJ4PGgJAIAQoAsA3IhFFDQBBACgCsOYLIhNFDQAgE0HwBmoiEyATKAIAQX9qNgIACyARQQAoArjmC0EAKAKU2AoRAAALIAQgEDYCvDcgBCACNgLANyAEKAK4NyECCyAEQcA3aigCACACQSRsaiAPQSQQng8aIAQgBCgCuDdBAWo2Arg3IAcgDygCADYCnAELAkAgCEEBSA0AIA4NACAHQQA2ArAGCwJAIAUNACAHIAkgChDiAQtBACEQQQAhDwJAIAQtAPA1QQFxRQ0AAkAgBygAqwEiEcAgBEH0NWooAgAiAnEiD0UNACAEQYg2aioCACIiICKUIARBjDZqKgIAIiIgIpSSQ6zFJzdeRQ0AIAcgBEGANmopAwA3ArABIAQpA4g2IR8gByARQXFxNgCrASAHIB83ArgBQQEhDwwBCyAPQQBHIQ8gByAEQYA2aiACEMIBC0EAIRECQCAEKALwNSICQQJxRQ0AAkACQCAHKACrAUEQdEEYdSAEQfg1aigCACICcQ0AQQAhEUEAIRAMAQsgBEGUNmoqAgBDAAAAAF4hECAEQZA2aioCAEMAAAAAXiERCyAHIARBkDZqIAIQ4wEgBCgC8DUhAgsCQCACQYABcUUNAAJAIARBoDZqKgIAIiJDAAAAAGBFDQAgB0EANgJwIAcgIjgCaAsgBEGkNmoqAgAiIkMAAAAAYEUNACAHQfQAakEANgIAIAdB7ABqICI4AgALAkACQCACQQRxRQ0AIAcgBEGYNmopAwA3AjQMAQsgBQ0AIAdCADcCNAsCQCAEKALwNSICQQhxRQ0AIARBqDZqLQAAIRQgBygAqwEhEwJAIARB/DVqKAIAIhVFDQAgE0EIdEEYdSAVcUUNAQsgByAUOgCNASAHIBNB//9HcTYAqwEgBCgC8DUhAgsCQCACQSBxRQ0AIAcQvAELAkAgBy0AkAFFDQAgByAHKACrAUH3719xNgCrAQsCQCAFDQAgB0L////7////v383ArQEIAdBAToAigEgB0G8BGpC////+/f//7//ADcCACAHIAFBAEc6AJMBAkAgB0HEAWooAgAiAkEASg0AIAJBACACa0EBdmsiBUEBIAVBAUobQQggAhsiBUECdCECAkBBACgCsOYLIhNFDQAgE0HwBmoiEyATKAIAQQFqNgIACyACQQAoArjmC0EAKAKQ2AoRAgAhAgJAIAdByAFqKAIAIhNFDQAgAiATIAcoAsABQQJ0EJ4PGgJAIAcoAsgBIhNFDQBBACgCsOYLIhRFDQAgFEHwBmoiFCAUKAIAQX9qNgIACyATQQAoArjmC0EAKAKU2AoRAAALIAcgBTYCxAEgByACNgLIAQsgB0EBNgLAASAHKAKIBRDHAyAHQZwDakF/NgIAAkAgBy0A4AZFDQAgBxCMAQsCQCAEKALUOUUNACAGRQ0AIAcoAghBgIAgcQ0AIAAgBygCACICEP4PRQ0AIAMgBygCTDYCuAEgByACIANBuAFqIAAQPTYCACAHIAMoArgBNgJMCyAHIAdBJGoiFSAHQSxqIgUQ5AECQCAHLACoASICQQFIDQAgByACQX9qOgCoAQsCQCAHLACpASICQQFIDQAgByACQX9qOgCpAQsCQCAHLACqASICQQFIDQAgByACQX9qOgCqAQsCQCAGDQAgESAQcQ0AIAdBAToAqQELAkAgDSAJQYCAgDBxIgJBAEdxQQFHDQAgB0EBOgCpASAJQcAAcUUNAAJAIBENACAHQQA2AhQgB0EANgIcCwJAIBANACAHQRhqQQA2AgAgB0EgakEANgIACyAVQgA3AgAgFUEIakIANwIACyAHEOUBAkACQCAODQAgByAEQagqQcwqIAlBgICAwABxG0GoKiACG2oqAgA4AkggByAEQZwqaikCACIfNwI8IB+nviEiDAELIAcgBEHEKmoqAgAiIzgCSCAHIARBnCpqKQIAIh83AjwgH6e+ISIgCUGAgIQgcQ0AQwAAAAAhJCAjQwAAAABcDQACQCAJQYAIcUUNACAEQaAqaioCACEkCyAHQQA2AjwgB0HAAGogJDgCAEMAAAAAISILIAdB1AJqICIgBEHgKmoqAgAiIyAiICNgGyIiIARByDZqKgIAIiMgIiAjYBs4AgAgB0HYAmogBEHMNmoqAgA4AgACQAJAIAlBIXENACADQbgBaiAHEMQBAkAgBCgC8DQgB0cNACAEKAKQNQ0AIAQoApQ1DQAgA0G4AWogA0HAAWpBARCUAUUNACAEQd0Hai0AAEUNACAHQQE6AI4BCyAHLQCOAUUNASAHIActAI0BQQFzOgCNAQJAIAdBCWotAABBAXENAEEAKAKw5gsiAioChF9DAAAAAF9FDQAgAiACQRxqKgIAOAKEXwsgBxC8AQwBCyAHQQA6AI0BCyAGRSECIAdBADoAjgEgA0GIAWogByAFEOYBAkACQCAJQcAAcSITRQ0AIActAI0BDQAgAiEWAkAgEQ0AIAcgAyoCiAE4AhxBASEWCyAQDQEgB0EgaiADKgKMATgCAEEBIQIMAQsCQAJAIAcsAKABQQBKDQAgAiEWIAcsAKEBQQBKDQEgAiEWDAILIAIhFiARDQACQAJAIActAKMBRQ0AIAcqAhwiIiADKgKIASIjICIgI2AbISIMAQsgAyoCiAEhIgsgByAiOAIcQQEhFgsCQCAQDQAgBywAoQFBAUgNAAJAAkAgBy0AowFFDQAgB0EgaioCACIiIAMqAowBIiMgIiAjYBshIgwBCyADKgKMASEiCyAHQSBqICI4AgBBASECCyAHLQCNAQ0AIAdBCWotAABBAXENAEEAKAKw5gsiBSoChF9DAAAAAF9FDQAgBSAFQRxqKgIAOAKEXwsgAyAHKQIcIh83AyggAyAfNwOAASADQbgBaiAHIANBKGoQ5wEgByADKQO4ASIfNwIcAkACQCAHLQCNAUUNACAODQAgA0G4AWogBxDEASADQcQBaioCACADKgK8AZMhIiADKgLAASADKgK4AZMhIwwBCyAfQiCIp74hIiAfp74hIwsgByAjOAIUIAdBGGogIjgCAEMAAAAAISUCQCAHLQAIQQFxDQBBACgCsOYLIgUqArQyIAcqAoAFlCEiAkAgBygCnAYiEEUNACAiIBAqAoAFlCEiCyAFQdQqaioCACIjICOSICKSISULIAcQ6AEhJgJAIA1FDQAgB0F/NgKkASAJQYCAgOAAcUGAgIAgRyAPcg0AIAQoArg3IgVBAEwNCiAHIAVBJGwgBEHAN2ooAgBqQXBqKQIANwIMCyAJQYCAgBhxIQUCQCAORQ0AIApFDQsgCi0AigFFDQsgByAKQYgDaigCACIQOwGYAQJAIBAgCkGMA2ooAgBHDQAgEEEBaiERAkACQCAQDQBBCCEUDAELIBBBAm0gEGohFAsgECAUIBEgFCARShsiEU4NACARQQJ0IRACQEEAKAKw5gsiFEUNACAUQfAGaiIUIBQoAgBBAWo2AgALIBBBACgCuOYLQQAoApDYChECACEQAkAgCkGQA2ooAgAiFEUNACAQIBQgCigCiANBAnQQng8aAkAgCigCkAMiFEUNAEEAKAKw5gsiF0UNACAXQfAGaiIXIBcoAgBBf2o2AgALIBRBACgCuOYLQQAoApTYChEAAAsgCiARNgKMAyAKIBA2ApADIAooAogDIRALIApBkANqKAIAIBBBAnRqIAc2AgAgCiAKKAKIA0EBajYCiAMgDyASQQBHcg0AIAVBgICAGEYNACAHIAopAswBNwIMCyAJQYCAgBBxIRQgDkEARyEQAkACQCAHKgKwASIiQ///f39bDQAgBy0AqQENACAHQbQBaioCACEjIAdBvAFqKgIAISQgByoCGCEnIAMgIiAHKgIUIAcqArgBlJM4ArgBIAMgIyAnICSUkzgCvAEgByADQbgBakEAEMIBDAELAkAgCUGAgICAAXFFDQAgA0G4AWogBxDpASAHIAMpA7gBNwIMDAELAkAgEkUgD3INACAIQQFIDQAgA0G4AWogBxDpASAHIAMpA7gBNwIMDAELIBRFIA9yDQAgBUGAgIAYRg0AIANBuAFqIAcQ6QEgByADKQO4ATcCDAtBACgCsOYLIghBEGoqAgAhIiADQfAAakEMaiAIQRRqKgIAIic4AgAgAyAiOAJ4IANCADcCcCAEQbwraioCACEjIARBxCtqKgIAISQgA0HgAGpBDGogJyAEQcAraioCACIoIARByCtqKgIAIikgKCApYBsiKJMiKjgCACADICIgIyAkICMgJGAbIiOTIis4AmggAyAoQwAAAACSIig4AmQgAyAjQwAAAACSIik4AmACQCAPIBByDQAgBywAoAFBAEoNACAHLAChAUEASg0AICJDAAAAAF5FDQAgJ0MAAAAAXkUNACAHIANB4ABqEOoBCwJAAkAgByoCDCIii0MAAABPXUUNACAiqCEIDAELQYCAgIB4IQgLIAcgCLI4AgwCQAJAIAdBEGoiCCoCACIii0MAAABPXUUNACAiqCEPDAELQYCAgIB4IQ8LIAggD7I4AgACQAJAIA5FDQAgBEHAKmohCAwBCwJAIAlBgICA4ABxQYCAgCBHDQAgBEHIKmohCAwBCyAEQaQqaiEICyAHIAgqAgAiIjgCRCADQgA3A1ggA0IANwNQAkACQCAEKgKwMiIjQ83MjD+UIiQgI0PNzEw+lCAiQwAAgD+SIiOSIiIgJCAiYBsiIotDAAAAT11FDQAgIqghGAwBC0GAgICAeCEYCyAlICaSISwgB0EMaiEZQQJBASAEQbQBai0AABshESASQQBHIQ8CQCAHLQCNAUUNACAHQf8BOgCUASAHQZQBaiEXDA8LIActAAhBwgBxDQsgBywAoAFBAEoNCyAHLAChAUEASg0LIActAIsBRQ0LQQAoArDmCyIXQbQBai0AACEaIBcqArAyISIgA0L////79///v/8ANwJAIANC////+/f//7//ADcDMCAHQcACakEBNgIAQcmMBhDrAQJAAkAgIkPNzKw/lCIkICJDzcxMPpQgI5IiIiAkICJgGyIii0MAAABPXUUNACAiqCEIDAELQYCAgIB4IQgLAkACQCAIskMAAEA/lCIii0MAAABPXUUNACAiqCEIDAELQYCAgIB4IQgLIAiyIiSMIS1DAACAQEMAAAAAIBobIS4gAykDiAEhHyADQcABaiEbQQAhCEEAIRwDQCAHKgIUISUgByoCDCEiIAMgByoCECIj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AgAiBUEgcjYCAAsgASgCpDUgASgC3DVGDQAgAiAFQeAAcjYCAAsgASgCoDciAkEATA0BCyABIAJBf2o2AqA3IABBIGokAA8LQam3BkHvjgVB8gxBoYYFEAAAC9EBAQJ/QQAoArDmCyICKALsNCIDQQE6AIwBAkAgAy0AjwENAAJAAkAgAEMAAAAAWw0AIANBlAJqKgIAQwAAAAAgASABQwAAAABdGyADKgIMIAMqAliTIACSkpIhACADQZACaioCACEBDAELAkAgAUMAAAAAXUUNACACQeAqaioCACEBCyADQdQBaioCACEACyADIAEgAJI4AswBIANB0AFqIANB2AFqKgIAOAIAIANB9AFqIANB/AFqKQIANwIAIANBhAJqIANBiAJqKgIAOAIACwtLAgF/An0jAEEQayICJAAgAEEMaioCACEDIAAqAgQhBCACIAAqAgggACoCAJM4AgggAiADIASTOAIMIAJBCGogARCuAiACQRBqJAALFgAgAEEAKAKw5gsoAuw0KQLMATcCAAtnAwF/AX4CfUEAKAKw5gsoAuw0IgFBAToAjAEgASAAKQIAIgI3AswBIAFB5AFqIgAgACoCACIDIAKnviIEIAMgBGAbOAIAIAFB6AFqIgEgASoCACIDIAJCIIinviIEIAMgBGAbOAIAC1UCAX8DfUEAKAKw5gsoAuw0IgFB3ABqKgIAIQIgAUEQaioCACEDIAFB0AFqKgIAIQQgACABKgLMASABKgIMkyABKgJYkjgCACAAIAIgBCADk5I4AgQLIQEBf0EAKAKw5gsoAuw0IgAqAswBIAAqAgyTIAAqAliSCysBAX9BACgCsOYLKALsNCIAQdABaioCACAAQRBqKgIAkyAAQdwAaioCAJILjQECAX8DfUEAKAKw5gsoAuw0IgFBAToAjAEgACoCBCECIAEgASoCDCABKgJYkyAAKgIAkiIDOALMASABQdABaiACIAFBEGoqAgAgAUHcAGoqAgCTkiICOAIAIAFB5AFqIgAgACoCACIEIAMgBCADYBs4AgAgAUHoAWoiASABKgIAIgMgAiADIAJgGzgCAAtJAgF/AX1BACgCsOYLKALsNCIBQQE6AIwBIAEgASoCDCABKgJYkyAAkiIAOALMASABQeQBaiIBIAEqAgAiAiAAIAIgAGAbOAIAC1MCAX8BfUEAKAKw5gsoAuw0IgFBAToAjAEgAUHQAWogAUEQaioCACABQdwAaioCAJMgAJIiADgCACABQegBaiIBIAEqAgAiAiAAIAIgAGAbOAIAC0QCAX8CfUEAKAKw5gsoAuw0IgFB3AFqKgIAIQIgASoCDCEDIAAgAUHgAWoqAgAgAUEQaioCAJM4AgQgACACIAOTOAIAC14BAn9BACgCsOYLIgEoAuw0IgJBAToAjAECQCAAQwAAAABcDQAgAUGAK2oqAgAhAAsgAkGMAmoiASAAIAEqAgCSIgA4AgAgAiAAIAIqAgySIAJBkAJqKgIAkjgCzAELXgECf0EAKAKw5gsiASgC7DQiAkEBOgCMAQJAIABDAAAAAFwNACABQYAraioCACEACyACQYwCaiIBIAEqAgAgAJMiADgCACACIAAgAioCDJIgAkGQAmoqAgCSOALMAQvjAgEGf0EAKAKw5gsiASgC7DQhAgJAIABDAAAAAFwNACACKgLkBCEACyACQbQDaiAAOAIAIAC8IQMCQCACQbwDaigCACIEIAJBwANqKAIARw0AIARBAWohBQJAAkAgBA0AQQghBgwBCyAEQQJtIARqIQYLIAQgBiAFIAYgBUobIgVODQAgAUHwBmoiBCAEKAIAQQFqNgIAIAVBAnRBACgCuOYLQQAoApDYChECACEEAkAgAkHEA2ooAgAiA0UNACAEIAMgAigCvANBAnQQng8aAkAgAigCxAMiA0UNAEEAKAKw5gsiBkUNACAGQfAGaiIGIAYoAgBBf2o2AgALIANBACgCuOYLQQAoApTYChEAAAsgAiAFNgLAAyACIAQ2AsQDIAIoArQDIQMgAigCvAMhBAsgAkHEA2ooAgAgBEECdGogAzYCACACIAIoArwDQQFqNgK8AyABIAEoAtA2QX5xNgLQNgu0BgIHfwN9AkACQCABQQAoArDmCyICQegqaioCACIJIABBf2oiA7IiCpSTIACylSILi0MAAABPXUUNACALqCEEDAELQYCAgIB4IQQLAkACQCABIAlDAACAPyAEsiILIAtDAACAP18bIguSIAqUkyIBi0MAAABPXUUNACABqCEEDAELQYCAgIB4IQQLQwAAgD8gBLIiASABQwAAgD9fGyEBAkAgAigC7DQiBEG8A2ooAgAiBSAEQcADaigCAEcNACAFQQFqIQYCQAJAIAUNAEEIIQcMAQsgBUECbSAFaiEHCyAFIAcgBiAHIAZKGyIGTg0AIAJB8AZqIgUgBSgCAEEBajYCACAGQQJ0QQAoArjmC0EAKAKQ2AoRAgAhBQJAIARBxANqKAIAIgdFDQAgBSAHIAQoArwDQQJ0EJ4PGgJAIAQoAsQDIgdFDQBBACgCsOYLIghFDQAgCEHwBmoiCCAIKAIAQX9qNgIACyAHQQAoArjmC0EAKAKU2AoRAAALIAQgBjYCwAMgBCAFNgLEAyAEKAK8AyEFCyAEQcQDaigCACAFQQJ0aiABOAIAIAQgBCgCvANBAWoiBTYCvAMCQCAAQQFMDQBBACEAA0ACQCAFIAQoAsADRw0AAkACQCAFDQBBCCEGDAELIAVBAm0gBWohBgsgBSAGIAVBAWoiByAGIAdKGyIGTg0AIAZBAnQhBQJAQQAoArDmCyIHRQ0AIAdB8AZqIgcgBygCAEEBajYCAAsgBUEAKAK45gtBACgCkNgKEQIAIQUCQCAEKALEAyIHRQ0AIAUgByAEKAK8A0ECdBCeDxoCQCAEKALEAyIHRQ0AQQAoArDmCyIIRQ0AIAhB8AZqIgggCCgCAEF/ajYCAAsgB0EAKAK45gtBACgClNgKEQAACyAEIAY2AsADIAQgBTYCxAMgBCgCvAMhBQsgBCgCxAMgBUECdGogCzgCACAEIAQoArwDQQFqIgU2ArwDIABBAWoiACADRw0ACwsCQCAFQQBMDQAgBEG0A2ogBUECdCAEKALEA2pBfGoqAgA4AgAgAiACKALQNkF+cTYC0DYPC0GptwZB744FQeYMQaWGBRAAAAuAAQEDf0EAKAKw5gsoAuw0IgBBAToAjAECQCAAQbwDaigCACIBQQBMDQAgACABQX9qIgI2ArwDAkACQCACDQAgAEHkBGohAQwBCyABQQJ0IABBxANqKAIAakF4aiEBCyAAQbQDaiABKgIAOAIADwtBqbcGQe+OBUHyDEGhhgUQAAALqgECAn8BfQJAQQAoArDmCyIAQdQ2aiAAKALsNCIBQbQDaiAALQDQNkEBcRsqAgAiAkMAAAAAXUUNAAJAAkAgAUGYA2ooAgANACAAKAL8PQ0AIAFBzARqIQAMAQsgAUGcBGohAAtDAACAPyACIAAqAgAgASoCzAGTkiICIAJDAACAP18bIQILAkACQCACi0MAAABPXUUNACACqCEADAELQYCAgIB4IQALIACyC5gCAgR9A39DAAAAACEEIAEqAgQhBUEAKAKw5gsiCCgC7DQhCQJAAkAgASoCACIGQwAAAABdDQBDAAAAACEHIAVDAAAAAF1FDQELIAlB0ARqIQoCQAJAIAlBmANqKAIADQAgCCgC/D0NACAJQcwEaiEIDAELIAlBnARqIQgLIAoqAgAhByAIKgIAIQQLAkACQCAGQwAAAABbDQAgBkMAAAAAXUUNAUMAAIBAIAYgBCAJKgLMAZOSIgYgBkMAAIBAXxshAgsgASACOAIACwJAAkAgBUMAAAAAWw0AIAVDAAAAAF1FDQFDAACAQCAFIAcgCUHQAWoqAgCTkiIFIAVDAACAQF8bIQMLIAEgAzgCBAsgACABKQIANwIACw0AQQAoArDmCyoCsDILGwEBf0EAKAKw5gsiACoCsDIgAEHkKmoqAgCSCyICAX8BfUEAKAKw5gsiAEHUKmoqAgAiASABkiAAKgKwMpILLAIBfwF9QQAoArDmCyIAQdQqaioCACIBIAGSIAAqArAykiAAQeQqaioCAJILcQICfwJ9QQAoArDmCyIBKALsNCICQcwEaioCACEDIAIqAgwhBCAAIAJB0ARqKgIAIAJBEGoqAgCTOAIEIAAgAyAEkzgCAAJAAkAgAkGYA2ooAgANACABKAL8PUUNAQsgACACQZwEaioCACAEkzgCAAsLQQIBfwJ9QQAoArDmCygC7DQiAUEQaioCACECIAFByARqKgIAIQMgACABKgLEBCABKgIMkzgCACAAIAMgApM4AgQLRAIBfwJ9QQAoArDmCygC7DQiAUHMBGoqAgAhAiABKgIMIQMgACABQdAEaioCACABQRBqKgIAkzgCBCAAIAIgA5M4AgALHwEBf0EAKAKw5gsoAuw0IgBBzARqKgIAIAAqAsQEkwuCBAIIfwF9QQAoArDmCyIAKAKgNyIBQQFqIQIgACgC7DQhAwJAIABBpDdqKAIAIgQgAUoNAAJAAkAgBA0AQQghBQwBCyAEQQJtIARqIQULIAQgBSACIAUgAkobIgVODQAgAEHwBmoiBCAEKAIAQQFqNgIAIAVBMGxBACgCuOYLQQAoApDYChECACEEAkAgAEGoN2ooAgAiBkUNACAEIAYgACgCoDdBMGwQng8aAkAgACgCqDciBkUNAEEAKAKw5gsiB0UNACAHQfAGaiIHIAcoAgBBf2o2AgALIAZBACgCuOYLQQAoApTYChEAAAsgACAFNgKkNyAAIAQ2Aqg3CyAAIAI2AqA3AkAgAUF/TA0AIABBqDdqKAIAIAFBMGxqIgEgAygCBDYCACABIAMpAswBNwIEIAEgA0HkAWoiAikCADcCDCABIANBjAJqIgQoAgA2AhQgASADQZQCaiIFKAIANgIYIAEgA0H0AWoiBikCADcCHCABIANBhAJqKgIAOAIkIAEgACgCqDU2AiggAC0A4DUhByABQQE6AC0gASAHOgAsIAZCADcCACACIAMpAswBNwIAIAUgAyoCzAEgAyoCDJMgA0GQAmoqAgCTIgg4AgAgBCAIOAIAAkAgAC0AxF9FDQAgAEH///97NgLcXwsPC0GptwZB744FQeYMQaWGBRAAAAtvAQF/AkAgAkMAAAAAYEUNACACQwAAgD9fRQ0AIABBADYCeCAAIAI4AnACQAJAIAAqAlggAZIiAotDAAAAT11FDQAgAqghAwwBC0GAgICAeCEDCyAAIAOyOAJoDwtBg6UFQYLpBEHFPEGP/AUQAAALEABBACgCsOYLKALsNCoCWAsUAEEAKAKw5gsoAuw0QdwAaioCAAsQAEEAKAKw5gsoAuw0KgJgCxQAQQAoArDmCygC7DRB5ABqKgIACyMAIABB/ABqQQA2AgAgAEH0AGpBADYCACAAQewAaiABOAIACyQBAX9BACgCsOYLKALsNCIBQQA2AnggAUEANgJwIAEgADgCaAswAQF/QQAoArDmCygC7DQiAUH8AGpBADYCACABQfQAakEANgIAIAFB7ABqIAA4AgALFABBACgCsOYLKALsNCAAIAEQhQMLFABBACgCsOYLKALsNCAAIAEQ3wILZwICfwJ9QQAoArDmCyIBKALsNCICIAFB4CpqKgIAIgMgAkGoAmoqAgCSIAJBoAJqKgIAIAOTIgSTIACUIASSIAIqAgyTIAAQhQMgAkMAAAAAIAIqAjwgA5MiACAAQwAAAABfGzgCeAsJAEEAQQAQ2gELTgEBf0EAIQICQCABQYABcQ0AQQAoArDmCygC7DQgAEEAEIABIQIgAUGAAnFFDQAgAkUNAEGUqAhBgukEQeE9QdX6BBAAAAsgAiABEMYBCxkAQQAoArDmCygC7DQgAEEAEIABIAEQkwMLvQcCCH8CfiMAQRBrIgIkAEEAKAKw5gsiAygCuDchBCADKALsNCEFAkACQAJAAkAgAUEgcUUNACADKAKsNyAESg0BCyAFKALAASIBQQBMDQEgAygCkDQhBiADKALENyEHIAFBAnQgBUHIAWooAgBqQXxqKAIAIQEgAhDQASACIAIpAwAiCjcDCCADQeQBaiEFIAUgAkEIaiAFEMEBGykCACELAkAgAygCrDciBSAESg0AAkAgBSADQbA3aigCAEcNACAFQQFqIQQCQAJAIAUNAEEIIQgMAQsgBUECbSAFaiEICyAFIAggBCAIIARKGyIETg0AIARBJGwhBQJAQQAoArDmCyIIRQ0AIAhB8AZqIgggCCgCAEEBajYCAAsgBUEAKAK45gtBACgCkNgKEQIAIQUCQCADQbQ3aigCACIIRQ0AIAUgCCADKAKsN0EkbBCeDxoCQCADKAK0NyIIRQ0AQQAoArDmCyIJRQ0AIAlB8AZqIgkgCSgCAEF/ajYCAAsgCEEAKAK45gtBACgClNgKEQAACyADIAQ2ArA3IAMgBTYCtDcgAygCrDchBQsgA0G0N2ooAgAgBUEkbGoiBCALNwIcIAQgCjcCFCAEIAE2AhAgBCAGNgIMIAQgBzYCCCAEQQA2AgQgBCAANgIAIAMgAygCrDdBAWo2Aqw3DAELIARBf0wNAgJAIANBtDdqKAIAIARBJGxqIgUoAgAgAEcNACAFKAIMIAMoApA0QX9qRw0AIAVBDGogBjYCAAwBCyAEQQAQxwECQCADKAKsNyIEIANBsDdqKAIARw0AIARBAWohBQJAAkAgBA0AQQghCAwBCyAEQQJtIARqIQgLIAQgCCAFIAggBUobIgVODQAgBUEkbCEEAkBBACgCsOYLIghFDQAgCEHwBmoiCCAIKAIAQQFqNgIACyAEQQAoArjmC0EAKAKQ2AoRAgAhBAJAIAMoArQ3IghFDQAgBCAIIAMoAqw3QSRsEJ4PGgJAIAMoArQ3IghFDQBBACgCsOYLIglFDQAgCUHwBmoiCSAJKAIAQX9qNgIACyAIQQAoArjmC0EAKAKU2AoRAAALIAMgBTYCsDcgAyAENgK0NyADKAKsNyEECyADKAK0NyAEQSRsaiIEIAs3AhwgBCAKNwIUIAQgATYCECAEIAY2AgwgBCAHNgIIIARBADYCBCAEIAA2AgAgAyADKAKsN0EBajYCrDcLIAJBEGokAA8LQam3BkHvjgVB5gxBpYYFEAAAC0HgtAVB744FQdwMQcv5BRAAAAvxAQEIfwJAQQAoArDmCyIAKAK4NyIBQQFIDQAgASAAKAKsNyICSg0AIABBwDdqKAIAIAFBf2oiA0EkbCIBaigCACAAQbQ3aigCACIEIAFqKAIARw0AQQAhBQJAIANFDQAgAyEBAkACQANAIAMgAk4NASAEIAFBJGxqIgYoAgQiB0UNAiAHQQtqLQAAQRBxRQ0CAkAgBkFgaigCACIHRQ0AIAdBC2otAABBCHENAwsgAUF/aiIBDQAMAwsAC0HgtAVB744FQdwMQcv5BRAAAAsgASEFCyAFQQEQxwEgACgCxDciAUUNACABQdACakEBOgAACwugAQEDfyMAQcAAayICJABBACEDQQAoArDmCyEEAkACQCAAQQAQxgENACAEQQA2AvA1DAELAkACQCABQYCAgIABcUUNACACIAQoArg3NgIQIAJBIGpBFEGC6AUgAkEQahBDGgwBCyACIAA2AgAgAkEgakEUQfyKBCACEEMaCyACQSBqQQAgAUGAgIAgchDcASIDDQAQlgMLIAJBwABqJAAgAwuzAQEDfwJAAkACQEEAKAKw5gsiACgC7DQiASgCCCICQYCAgCBxRQ0AIAAoArg3QQBMDQECQCAAKALENyABRw0AIABBAjYCyDkgACABNgLEOQsgAC0AnjQNAgJAIAJBgICACHFFDQAgAEEBOgCeNAsQ+wEgAEEAOgCeNA8LQdvnBEGC6QRB1z9B0ucEEAAAC0GBtwZBgukEQdg/QdLnBBAAAAtBg70FQYLpBEHfP0HS5wQQAAALPgEBfwJAQQAoArDmCyICKAKsNyACKAK4N0oNACACQQA2AvA1QQAPCyACKALsNCAAQQAQgAEgAUHBAnIQlQML6gECA38CfUEAIQMCQEEAKAKw5gsiBCgC7DQgAEEAEIABQQAQxgENACAEQQA2AvA1QQAPCwJAIAQtAPA1QQFxDQAgBEEQaioCACEGIARBFGoqAgAhB0EAKAKw5gsiBUGINmpCgICA+IOAgIA/NwMAIAVB9DVqQQQ2AgAgBUGENmogB0MAAAA/lDgCACAFQYA2aiAGQwAAAD+UOAIAIAUgBSgC8DVBAXI2AvA1CwJAAkAgACABIAJBoICA4AByENwBRQ0AQQEhAyABRQ0BIAEtAAANARCWAyAEKAK4N0EBEMcBQQAPCxCWAwsgAwuTAQECfwJAAkAgAUEfcSICQQVPDQACQEEAKAKw5gsiAyACakHiB2otAABFDQAgAygC7DQhAkEIEJEBRQ0AAkACQCAARQ0AIAIgAEEAEIABIQIMAQsgAkGYAmooAgAhAgsgAkUNAiACIAEQkwMLDwtBn5EIQYLpBEHXI0GE4AUQAAALQbi7BkGC6QRB7z9BjoUFEAAAC68BAQJ/QQAhAgJAAkACQEEAKAKw5gsoAuw0IgMtAI8BDQACQAJAIABFDQAgAyAAQQAQgAEhAgwBCyADQZgCaigCACECCyACRQ0BIAFBH3EiAEEFTw0CAkBBACgCsOYLIABqQeIHai0AAEUNAEEIEJEBRQ0AIAIgARCTAwsgAkHBAhCVAyECCyACDwtBuLsGQYLpBEH/P0HW/QQQAAALQZ+RCEGC6QRB1yNBhOAFEAAAC5IBAQF/QQAoArDmCygC7DQgAEHYlgQgABtBABCAASEAAkAgAUEfcSICQQVPDQACQEEAKAKw5gsgAmpB4gdqLQAARQ0AQQgQwAJFDQACQCABQcAAcUUNAEEAKAKw5gsiAigCkDUNASACKAKUNQ0BCyAAIAEQkwMLIABBwQIQlQMPC0GfkQhBgukEQdcjQYTgBRAAAAtzAQF/QQAoArDmCygC7DQgAEHnlgQgABtBABCAASEAAkAgAUEfcSICQQVPDQACQEEAKAKw5gsgAmpB4gdqLQAARQ0AQQQQwAINABDFAQ0AIAAgARCTAwsgAEHBAhCVAw8LQZ+RCEGC6QRB1yNBhOAFEAAAC4YBAgF/BH1BACgCsOYLIgJBEGoqAgAhAyACQcQraioCACEEIABBDGogAkEUaioCACIFIAJByCtqKgIAIgaMQwAAAAAgBSAGIAaSXhsiBpI4AgAgACADIASMQwAAAAAgAyAEIASSXhsiBJI4AgggAEMAAAAAIAaTOAIEIABDAAAAACAEkzgCAAtRAQF/QQAoArDmCyEEIAAgASACEM4BIAQoAsQ3IAFBBHRqIgFBwAZqIANBCGopAgA3AgAgAUG4BmogAykCADcCACAEQQE6AJc4IARBATsAlTgLqQICAn8FfQJAIABFDQAgAUHAAmooAgAhAgJAQQAoArDmCyIDKALENyABRg0AIANBADoAmTgLIAMgAjYCjDggAyAANgLINyADIAE2AsQ3IAMgAUHMAmooAgA2Asw3IAEgAkECdGpBsAZqIAA2AgACQCABQZgCaigCACAARw0AIAFBoAJqKgIAIQQgAUGkAmoqAgAhBSABQagCaioCACEGIAEqAgwhByABIAJBBHRqIgBBxAZqIAFBrAJqKgIAIAFBEGoqAgAiCJM4AgAgAEHABmogBiAHkzgCACAAQbwGaiAFIAiTOAIAIABBuAZqIAQgB5M4AgALAkAgAygC1DVBAkcNACADQQE6AJc4DwsgA0EBOgCWOA8LQbi7BkGC6QRBusEAQbGNBhAAAAs0AQJ/QQAhAAJAQQAoArDmCyIBLQCwOEUNACABQdA4aigCAA0AIAFBoDlqKAIARSEACyAAC0QBAn9BACgCsOYLIgBBADoAsDggACAALQCZOCIBOgCYOAJAIAFFDQAgACgCxDcNAEGciAZBgukEQYDEAEGkmgUQAAALC48FAgV/An1BACEBQQAoArDmCyECAkACQAJAAkACQAJAAkAgAEEQcQ0AAkACQCACKALsNCIBQZgCaigCACIDRQ0AQQAhBCACKAKkNSADRw0FQQAhBCACQewBai0AAEUNBUEAIQUMAQtBACEEIAJB7AFqLQAARQ0EIABBCHFFDQUCQCABQZwCai0AAEEBcQ0AIAIoAqQ1RQ0FIAIoAtA1IAFHDQULIAEgASABQaACaiIFEIkBIgM2ApgCAkAgBSADEJMBIgVFDQAgAkHYB2otAABFDQAgAyABEI0BIAEQvAELIAIoAqQ1IANHDQQLIAIgBToAsTUgASgCwAEiBUEATA0FQQAoArDmCyIEQewBai0AAA0BIAJCfzcDuDUgAkHANWpCfzcDAEEADwtBqfEEQQBBABBFIQNBACEFDAELIAVBAnQgAUHIAWooAgBqQXxqKAIAIQUgBEHECGoqAgAhBiAEQTBqKgIAIQcgAkHANWpCfzcDACACQn83A7g1QQAhBCAGIAcgB5RgRQ0BCwJAIAItAOw8DQAgA0UNBBD9ASACQQA2Avg8IAIgADYC8DwgAkEBOgDsPCACQYg9aiAFNgIAIAJBhD1qIAM2AgAgAyACKAKkNUcNACACQQE6ALI1C0EBIQQgAkEBOgDtPCACIAIoApA0NgL0PAJAIABBAXENAEEAQQAQ2gEgAigC1D1FDQAgAkHJPWotAABBEHFFDQAgAigC7DQiAkEBOgCoASACQQE6AI8BCyAAQRJxDQAgAUGcAmoiAiACKAIAQX5xNgIACyAEDwtBzrwGQYLpBEHIygBB5dQFEAAAC0GptwZB744FQeYMQaWGBRAAAAtBsbsGQYLpBEH3ygBB5dQFEAAAC3cBAX8CQAJAQQAoArDmCyIALQDsPEUNACAALQDtPEUNAQJAIAAtAPA8QQFxDQAQ2wELAkAgAEGMPWooAgBBf0cNABD9AQsgAEEAOgDtPA8LQc62BUGC6QRBncsAQfnUBRAAAAtBiKMIQYLpBEGeywBB+dQFEAAAC54GAQN/AkACQAJAAkACQCAARQ0AQQAoArDmCyEEIAAQgBBBIU8NAQJAAkAgAUUNACACDQELIAENAyACDQMLAkAgA0ECSQ0AIANBASADQQFLG0ECRw0ECyAEQYQ9aigCAEUNBAJAAkAgA0ECSQ0AIARBjD1qKAIAQX9HDQELIARBkD1qIABBIBCDEBogBEGwPWpBADoAAAJAIARB5D1qKAIAIgNBf0oNACAEQfAGaiIDIAMoAgBBAWo2AgBBAEEAKAK45gtBACgCkNgKEQIAIQACQCAEQeg9aigCACIDRQ0AIAAgAyAEKALgPRCeDxoCQCAEKALoPSIDRQ0AQQAoArDmCyIFRQ0AIAVB8AZqIgUgBSgCAEF/ajYCAAsgA0EAKAK45gtBACgClNgKEQAAC0EAIQMgBEEANgLkPSAEIAA2Aug9CyAEQQA2AuA9AkACQCACQRFJDQACQCADIAJODQAgAyADQQF2IANqQQggAxsiACACIAAgAkobIgBPDQACQEEAKAKw5gsiA0UNACADQfAGaiIDIAMoAgBBAWo2AgALIABBACgCuOYLQQAoApDYChECACEDAkAgBEHoPWooAgAiBUUNACADIAUgBCgC4D0Qng8aAkAgBCgC6D0iBUUNAEEAKAKw5gsiBkUNACAGQfAGaiIGIAYoAgBBf2o2AgALIAVBACgCuOYLQQAoApTYChEAAAsgBCAANgLkPSAEIAM2Aug9CyAEIAI2AuA9IAQgBEHoPWooAgAiAzYC/DwgAyABIAIQng8aDAELAkAgAkUNACAEQgA3Auw9IARB9D1qQgA3AgAgBCAEQew9aiIDNgL8PCADIAEgAhCeDxoMAQsgBEEANgL8PAsgBEGAPWogAjYCAAsgBEGMPWogBCgCkDQiAjYCACACIAQoAtg9IgRGIAQgAkF/akZyDwtBxYkGQYLpBEGxywBBk+YFEAAAC0GFmwhBgukEQbLLAEGT5gUQAAALQdeHCEGC6QRBs8sAQZPmBRAAAAtBqNUFQYLpBEG0ywBBk+YFEAAAC0HAuwZBgukEQbXLAEGT5gUQAAAL2QEBBX9BACEAAkACQEEAKAKw5gsiAS0A7DxFDQAgASgC7DQiAkGcAmooAgAiA0EBcUUNACABKAL4NCIERQ0AIAIoAqAGIAQoAqAGRw0AIAJB5ABB1AAgA0ECcRtqQcwBaiEEAkAgAkGYAmooAgAiAw0AIAIgBBCJASEDCyABQYQ9aigCACADRg0AIAEtAO48DQEgASAEKQIANwK0PSABQbw9aiAEQQhqKQIANwIAIAEgAzYCxD1BASEAIAFBAToA7jwLIAAPC0HEvAVBgukEQYTMAEGtsQQQAAALhwYCCH8GfSMAQcAAayICJAACQAJAAkBBACgCsOYLIgMtAOw8RQ0AIANBjD1qKAIAQX9GDQEgAygC7DQhBAJAAkAgAEUNAEEAIQUgACADQZA9ahD+Dw0BCyADKALEPSEAIAMoAtQ9IQUgAkEoaiIGIANBvD1qKQIANwMAIAIgAykCtD03AyAgBSAARiEHAkAgBioCACIKIAIqAiAiC5MgAkEsaioCACIMIAIqAiQiDZOUIg4gAyoCzD1fRQ0AIAMgADYC0D0gAyABNgLIPSADIA44Asw9CyADQbE9aiAHOgAAAkAgAygC8DwgAXJBgBBxDQAgBSAARw0AIAIgDEMAAGBAkiIPOAIsIAIgCkMAAGBAkiIOOAIoIAIgDUMAAGDAkiIMOAIkIAIgC0MAAGDAkiIKOAIgAkACQCAKIAQqArQEYEUNACAMIARBuARqKgIAYEUNACAOIARBvARqKgIAX0UNAEEBIQggAyEHIA8gBEHABGoqAgBfDQELIAQoAogFIQcgAiAMQwAAgL+SOAIcIAIgCkMAAIC/kjgCGCACIA9DAACAP5I4AhQgAiAOQwAAgD+SOAIQIAIgAikCGDcDCCACIAIpAhA3AwBBACEIIAcgAkEIaiACQQAQzwNBACgCsOYLIQcLIAQoAogFIQkgAkE4aiAHQeQxaikCADcDACACIAdB3DFqKQIANwMwIAIgByoCmCogAioCPJQ4AjwgCSACQSBqIAYgAkEwahBOQwAAAABBf0MAAABAEOMDIAgNACAEKAKIBRDRAwsgAyADKAKQNDYC2D0CQAJAIAUgAEcNACADKAL4PCIAQQVPDQVBACEFIANBsj1qQQAoArDmCyAAakHsAWotAAAiAEU6AAAgAUGACHENASAARQ0BDAILQQAhBSADQbI9akEAOgAAIAFBgAhxRQ0BCyADQfw8aiEFCyACQcAAaiQAIAUPC0HOtgVBgukEQZbMAEH95QUQAAALQb6uBkGC6QRBl8wAQf3lBRAAAAtBn5EIQYLpBEG+I0H78AQQAAALUgEBfwJAAkBBACgCsOYLIgAtAOw8RQ0AIAAtAO48RQ0BIABBADoA7jwPC0HOtgVBgukEQcbMAEHBsQQQAAALQdOxBEGC6QRBx8wAQcGxBBAAAAu+AQECfwJAAkACQEEAKAKw5gsiAi0AxF8NACACKALMXw0BIAIoAtBfQQJODQIgAigC7DQhAyACIAA2AshfIAJBAToAxF8gAiADQYADaigCADYC5F8CQCABQX9KDQAgAigC7F8hAQsgAkEBOgDgXyACQf////sHNgLcXyACIAE2AuhfDwtBvb0FQYLpBEGhzQBBlvkEEAAAC0GMiAZBgukEQaLNAEGW+QQQAAALQY2SCEGC6QRBo80AQZb5BBAAAAsqAQF/AkBBACgCsOYLIgEtAMRfDQBBASAAEKgDIAFBACgCmMYKNgLMXwsLZgEBfwJAAkBBACgCsOYLIgItAMRfDQACQCABDQAgAkEkaigCACIBRQ0BCyABLQAARQ0AIAFBuvQFELIPIgFFDQFBAiAAEKgDIAIgATYCzF8LDwtBzrwGQYLpBEHJzQBBqcoFEAAACxkAAkBBACgCsOYLLQDEXw0AQQQgABCoAwsL3QQCB38BfSMAQRBrIgAkAEEAKAKw5gshAUGMxAQQ6wEgAEIANwIIQar7BSAAQQhqEOwEIQJBACgCsOYLIgMoAuw0IgRBAToAjAECQCAELQCPAQ0AIANB4CpqKgIAIQcgBEHQAWogBEHYAWoqAgA4AgAgBEH0AWogBEH8AWopAgA3AgAgBEGEAmogBEGIAmoqAgA4AgAgBCAHIARB1AFqKgIAkjgCzAELIABCADcCCEGzygUgAEEIahDsBCEDQQAoArDmCyIFKALsNCIEQQE6AIwBAkAgBC0AjwENACAFQeAqaioCACEHIARB0AFqIARB2AFqKgIAOAIAIARB9AFqIARB/AFqKQIANwIAIARBhAJqIARBiAJqKgIAOAIAIAQgByAEQdQBaioCAJI4AswBCyAAQgA3AghB0tcFIABBCGoQ7AQhBUEAKAKw5gsiBigC7DQiBEEBOgCMAQJAIAQtAI8BDQAgBkHgKmoqAgAhByAEQdABaiAEQdgBaioCADgCACAEQfQBaiAEQfwBaikCADcCACAEQYQCaiAEQYgCaioCADgCACAEIAcgBEHUAWoqAgCSOALMAQtBAUEBELgCQQAoArDmCyIEQdQ2akGAgICVBDYCACAEIAQoAtA2QQFyNgLQNkGlhwUgAUHs3wBqQQBBCUEAQQAQ0AUaELkCEO4BAkAgAkUNAEEAKAKw5gsiBC0AxF8NAEEBQX8QqAMgBEEAKAKYxgo2AsxfCwJAIANFDQBBf0EAEKoDCwJAIAVFDQBBACgCsOYLLQDEXw0AQQRBfxCoAwsgAEEQaiQACysBAX8CQEEAKAKw5gsiACoChF9DAAAAAF9FDQAgACAAQRxqKgIAOAKEXwsLiQIBBn8CQCAAKAIEIgIgACgCACIDIAFBB2pBfHEiBGoiAU4NAAJAAkAgAg0AQQghBQwBCyACQQJtIAJqIQULIAIgBSABIAUgAUobIgVODQACQEEAKAKw5gsiAkUNACACQfAGaiICIAIoAgBBAWo2AgALIAVBACgCuOYLQQAoApDYChECACECAkAgACgCCCIGRQ0AIAIgBiAAKAIAEJ4PGgJAIAAoAggiBkUNAEEAKAKw5gsiB0UNACAHQfAGaiIHIAcoAgBBf2o2AgALIAZBACgCuOYLQQAoApTYChEAAAsgACAFNgIEIAAgAjYCCAsgACABNgIAIAAoAgggA2oiACAENgIAIABBBGoLagEDf0EAIQEgAEEAQQAQRSECAkBBACgCsOYLIgAoApRfIgNBAUgNACAAQZzfAGooAgAhAUEAIQACQANAIAEgAEEkbGooAgQgAkYNASAAQQFqIgAgA0cNAAtBAA8LIAEgAEEkbGohAQsgAQtiAQV/QQAhAEEAKAKw5gsiAUGI3wBqELMBAkAgASgClF8iAkEBSA0AA0ACQCABKAKcXyAAQSRsaiIDKAIIIgRFDQAgASADIAQRAAAgASgClF8hAgsgAEEBaiIAIAJIDQALCwucBgEKfwJAAkBBACgCsOYLIgItAABFDQACQCABDQAgABCAECEBCyABQQFqIQMCQCACQYzfAGooAgAiBCABSg0AAkACQCAEDQBBCCEFDAELIARBAm0gBGohBQsgBCAFIAMgBSADShsiBU4NACACQfAGaiIEIAQoAgBBAWo2AgAgBUEAKAK45gtBACgCkNgKEQIAIQQCQCACQZDfAGooAgAiBkUNACAEIAYgAigCiF8Qng8aAkAgAigCkF8iBkUNAEEAKAKw5gsiB0UNACAHQfAGaiIHIAcoAgBBf2o2AgALIAZBACgCuOYLQQAoApTYChEAAAsgAiAFNgKMXyACIAQ2ApBfCyACIAM2AohfQQAhAyACQZDfAGooAgAgACABEJ4PIgggAWoiBUEAOgAAAkAgAigClF8iBEEBSA0AA0ACQCACKAKcXyADQSRsaiIGKAIMIgdFDQAgAiAGIAcRAAAgAigClF8hBAsgA0EBaiIDIARIDQALCyABQQFIDQFBACEJIAghA0EAIQcDQAJAAkAgAy0AAEF2ag4EAQAAAQALIAMhBAJAIAMgBU8NACADIQQDQAJAIAQtAABBdmoOBAIAAAIACyAEQQFqIgQgBUkNAAsgBSEECyAEQQA6AAACQCADLQAAIgZBO0YNAAJAIAZB2wBHDQAgBCADTQ0AIARBf2oiBi0AAEHdAEcNACAGQQA6AAAgA0EBaiIDQd0AIAYgA2sQyg8iCkUNASAKQQFqIgtB2wAgBiALaxDKDyIGRQ0BQQAhByAKQQA6AABBACEJIAMQrwMiA0UNASACIAMgBkEBaiADKAIQEQUAIQkgAyEHDAELIAdFDQAgCUUNACACIAcgCSADIAcoAhQRCQALIARBAWoiAyAFTw0DDAELIANBAWohAwwACwALQaLcBUGC6QRBpc8AQdGBBBAAAAsgAkEBOgCBXyAIIAAgARCeDxoCQCACKAKUXyIEQQFIDQBBACEDA0ACQCACKAKcXyADQSRsaiIFKAIYIgZFDQAgAiAFIAYRAAAgAigClF8hBAsgA0EBaiIDIARIDQALCwv2LwMRfwR9AX4jAEHACGsiASQAAkBBmOAEIABBABDcAUUNACABQau0BjYCsAZBACgCsOYLIQJBgtcEIAFBsAZqEN4EIAEgAkHcBmoqAgAiErs5A6gGIAFDAAB6RCASlbs5A6AGQYCFCCABQaAGahDeBCACQeAGaigCACEAIAEgAkHkBmooAgAiAzYClAYgASAANgKQBiABIANBA202ApgGQazlByABQZAGahDeBCABIAJB6AZqKQMAQiCJNwOABkGlgQggAUGABmoQ3gQgASACQfAGaigCADYC8AVB6MQEIAFB8AVqEN4EEIcFIAFBuAhqQQApA8jnCDcDACABQbAIakEAKQPA5wg3AwAgAUEAKQO45wg3A6gIIAFBACkDsOcINwOgCCABQeAHakHQ5whBNBCeDxoCQCACQYDgAGoiBCgCAEF/Sg0AIARBBDYCAAsCQCACQYTgAGoiBSgCAEF/Sg0AIAVBAjYCAAsgAkH43wBqIQYCQEHOxgQQjgZFDQAgAUIANwLgBkGrugcgAUHgBmoQ7AQhAEEAKAKw5gshAwJAIABFDQAgA0EBOgDwXwsgAygC7DQiAEEBOgCMAQJAIAAtAI8BDQAgA0HgKmoqAgAhEiAAQdABaiAAQdgBaioCADgCACAAQfQBaiAAQfwBaikCADcCACAAQYQCaiAAQYgCaioCADgCACAAIBIgAEHUAWoqAgCSOALMAQtB1oUIQQAQ4gQCQEEAEJEBRQ0AQQBBABDaAUEAKAKw5gsqArAyQwAADEKUEL4CQeqNB0EAEN0EEL8CENsBC0HE4QQgAkH53wBqEPkEGkH+zwQgBhD5BBpBACgCsOYLIgAoAuw0IgNBAToAjAECQCADLQCPAQ0AIABB4CpqKgIAIRIgA0HQAWogA0HYAWoqAgA4AgAgA0H0AWogA0H8AWopAgA3AgAgA0GEAmogA0GIAmoqAgA4AgAgAyASIANB1AFqKgIAkjgCzAELIABB1DZqIAAqArAyQwAAQEGUOAIAIAAgACgC0DZBAXI2AtA2IAZBqb8FIAQgAUGgCGpBCEEIEI4FIAYtAAByIgA6AAACQCAAQf8BcUUNACACKALENyIARQ0AIAEgACgCADYC4AVB06EGIAFB4AVqEOgEQQAhAEEAKAKw5gsiBygC7DQiA0EBOgCMASADQYwCaiIIIAdBgCtqKgIAIAgqAgCSIhI4AgAgAyASIAMqAgySIANBkAJqKgIAkjgCzAEgAUHQBWohAyABQbAFaiEHIAFBuAVqIQggAUHABWohCSABQcgFaiEKA0AgAUHgBmogAigCxDcgABCzAyADIAFBoAhqIABBAnRqKAIANgIAIAcgASoC6AYiErs5AwAgCCABKgLsBiITuzkDACAJIBIgASoC4AYiFJO7OQMAIAogEyABKgLkBiISk7s5AwAgASAUuzkDoAUgASASuzkDqAVBvNkEIAFBoAVqEN4EIABBAWoiAEEIRw0AC0EAKAKw5gsiAygC7DQiAEEBOgCMASAAQYwCaiIHIAcqAgAgA0GAK2oqAgCTIhI4AgAgACASIAAqAgySIABBkAJqKgIAkjgCzAELQcqSBSACQfvfAGoQ+QQaQZ6SBSACQfzfAGoQ+QQaQZbQBCACQfrfAGoiBxD5BBpBACgCsOYLIgAoAuw0IgNBAToAjAECQCADLQCPAQ0AIABB4CpqKgIAIRIgA0HQAWogA0HYAWoqAgA4AgAgA0H0AWogA0H8AWopAgA3AgAgA0GEAmogA0GIAmoqAgA4AgAgAyASIANB1AFqKgIAkjgCzAELIABB1DZqIAAqArAyQwAAQEGUOAIAIAAgACgC0DZBAXI2AtA2IAdBwr8FIAUgAUHgB2pBDUENEI4FIActAAByIgA6AAACQCAAQf8BcUUNACACKALEN0UNACACKAKAPiIAQQFIDQAgAUGQBGpBMGohCyABQcQEaiEMIAFBkARqQRBqIQ0gAUGQBGpBGGohDiABQZAEakEgaiEPIAFBkARqQShqIRBBACERA0ACQCACKAKIPiARQagEbGoiCCgCUCACKAKQNEF/akgNAAJAIAgoArADIgcgAigCxDciA0YNACAIKAK0AyADRw0BCyAIKAJUIQAgCCgCACEDIAEgBygCADYCmAUgASAANgKUBSABIAM2ApAFQc6UCCABQZAFahDoBAJAQQAQkQFFDQBBACgCsOYLIQAgCEHYAWoqAgAhEiABIAgqAtQBQwAAgL+SOALgBiABIBJDAACAv5I4AuQGIAhB3AFqKgIAIRIgASAIQeABaioCAEMAAIA/kjgC1AYgASASQwAAgD+SOALQBiAAQdg7aiABQeAGaiABQdAGakH//4N4QwAAAABBf0MAAABAEOMDCyAIQdQAaiEJQQAhB0EAKAKw5gsiAygC7DQiAEEBOgCMASAAQYwCaiIKIANBgCtqKgIAIAoqAgCSIhI4AgAgACASIAAqAgySIABBkAJqKgIAkjgCzAEDQAJAAkAgB0EGSQ0AAkAgB0F6ag4DAAIAAgsgCSgCAEEBSA0BIAFB4AdqIAdBAnRqIQpBACEAA0AgAUHQBmogCCAHIAAQtAMgCigCACEDIAsgADYCACAMIAM2AgAgDSABKgLYBiISuzkDACAOIAEqAtwGIhO7OQMAIA8gEiABKgLQBiIUk7s5AwAgECATIAEqAtQGIhWTuzkDACABIBS7OQOQBCABIBW7OQOYBCABQeAGakGAAUGg1wQgAUGQBGoQQxogAUIANwLIBiABQeAGakEAQQAgAUHIBmoQjQUaAkBBABCRAUUNAEEAKAKw5gshAyABIBVDAACAv5I4AswGIAEgFEMAAIC/kjgCyAYgASATQwAAgD+SOALEBiABIBJDAACAP5I4AsAGIANB2DtqIAFByAZqIAFBwAZqQf//g3hDAAAAAEF/QwAAAEAQ4wMLIABBAWoiACAJKAIASA0ADAILAAsgAUHQBmogCCAHQX8QtAMgAUHQBGpBEGogASoC2AYiErs5AwAgAUHQBGpBGGogASoC3AYiE7s5AwAgAUHQBGpBMGogAUHgB2ogB0ECdGooAgA2AgAgAUHQBGpBIGogEiABKgLQBiIUk7s5AwAgAUHQBGpBKGogEyABKgLUBiIVk7s5AwAgASAUuzkD0AQgASAVuzkD2AQgAUHgBmpBgAFBvNkEIAFB0ARqEEMaIAFCADcCyAYgAUHgBmpBAEEAIAFByAZqEI0FGkEAEJEBRQ0AQQAoArDmCyEAIAEgFUMAAIC/kjgCzAYgASAUQwAAgL+SOALIBiABIBNDAACAP5I4AsQGIAEgEkMAAIA/kjgCwAYgAEHYO2ogAUHIBmogAUHABmpB//+DeEMAAAAAQX9DAAAAQBDjAwsgB0EBaiIHQQ1HDQALQQAoArDmCyIDKALsNCIAQQE6AIwBIABBjAJqIgcgByoCACADQYAraioCAJMiEjgCACAAIBIgACoCDJIgAEGQAmoqAgCSOALMASACKAKAPiEACyARQQFqIhEgAEgNAAsLEJYGCyACQaw0aiIKQf62BBC1AyABIAIoAqw6NgKABAJAQZm5BEH/gQggAUGABGoQiQZFDQACQCACKAKsOkEBSA0AQQAhAANAQQAgAigCtDogAEECdGooAgBB158EELYDIABBAWoiACACKAKsOkgNAAsLEJYGCyABIAIoAqw3NgLwAwJAQYHBBEG1ggggAUHwA2oQiQZFDQACQCACKAKsN0EBSA0AQQAhAANAIAIoArQ3IABBJGxqIgMoAgAhBwJAAkAgAygCBCIDDQBBtIcGIQNBltwIIQhBltwIIQkMAQtBlZYEQZbcCCADKAIIIghBgICAgAFxGyEJQeuRBEGW3AggCEGAgIAIcRshCCADKAIAIQMLIAEgCTYC7AMgASAINgLoAyABIAM2AuQDIAEgBzYC4ANBjtUEIAFB4ANqEOgEIABBAWoiACACKAKsN0gNAAsLEJYGCyABIAIoAsQ+NgLQAwJAQfnABEGnggggAUHQA2oQiQZFDQACQCACKALEPkEBSA0AQQAhAANAIAIoAsw+IABBkAFsakHO5QQQtwMgAEEBaiIAIAIoAsQ+SA0ACwsQlgYLIAEgAigCgD42AsADAkBB5NAEQc2CCCABQcADahCJBkUNAAJAIAIoAoA+QQFIDQBBACEAA0AgAigCiD4gAEGoBGxqEMoEIABBAWoiACACKAKAPkgNAAsLEJYGCwJAQaDKBBCOBkUNAAJAQcHjBBDtBEUNABCwAwtBACgCsOYLIgMoAuw0IgBBAToAjAECQCAALQCPAQ0AIANB4CpqKgIAIRIgAEHQAWogAEHYAWoqAgA4AgAgAEH0AWogAEH8AWopAgA3AgAgAEGEAmogAEGIAmoqAgA4AgAgACASIABB1AFqKgIAkjgCzAELAkBBl4EEEO0ERQ0AQQAQ9gEaC0EAKAKw5gsiAygC7DQiAEEBOgCMAQJAIAAtAI8BDQAgA0HgKmoqAgAhEiAAQdABaiAAQdgBaioCADgCACAAQfQBaiAAQfwBaikCADcCACAAQYQCaiAAQYgCaioCADgCACAAIBIgAEHUAWoqAgCSOALMAQsCQEGZhAUQ7QRFDQAgAkEgaigCABCsAQtBACgCsOYLIgMoAuw0IgBBAToAjAECQCAALQCPAQ0AIANB4CpqKgIAIRIgAEHQAWogAEHYAWoqAgA4AgAgAEH0AWogAEH8AWopAgA3AgAgAEGEAmogAEGIAmoqAgA4AgAgACASIABB1AFqKgIAkjgCzAELAkACQCACQSBqKAIAIgBFDQAgASAANgKwA0GAmwggAUGwA2oQ3gQMAQtBjZoGQQAQ3QQLIAEgAioChF+7OQOgA0HrnwUgAUGgA2oQ3gQgASACKAKUXzYCkAMCQEGavgRB7IIIIAFBkANqEIkGRQ0AAkAgAigClF9BAUgNAEEAIQADQCABIAIoApxfIABBJGxqKAIANgKAA0Hr2QQgAUGAA2oQ6AQgAEEBaiIAIAIoApRfSA0ACwsQlgYLIAEgAigCoF82AvACAkBBv7YEQf7MBCABQfACahCJBkUNAAJAIAJBqN8AaigCACIARQ0AIAJBoN8AaiEMIABBBGohACABQegCaiENIAFB5AJqIQ4DQCAAQQZqLgEAIQMgAEEKai4BACEHIAAoAgAhCCAALgEEIQkgAC4BCCELIA0gAC0ADDYCACAOIAc2AgAgAUHQAmpBEGogCzYCACABIAM2AtwCIAEgCTYC2AIgASAAQRBqNgLUAiABIAg2AtACQYHpBSABQdACahDeBCAMIAAQ8wEiAA0ACwsQlgYLIAEgAigCrF82AsACAkBB3NAEQabNBCABQcACahCJBkUNAAJAIAJBtN8AaigCACIARQ0AIAJBrN8AaiEDIABBBGohAANAIAAQywQgAyAAELgDIgANAAsLEJYGCyABQQAgAigCiF8iAEF/aiIDIAMgAEsbNgKwAgJAQbr3BUHNzQQgAUGwAmoQiQZFDQAgAkGQ3wBqKAIAIQAgAigCiF8hA0EAKAKw5gsqArAyIRIgAUGAgICEeDYC4AYgASASQwAAoEGUOALkBkH2hgUgAEG05gsgABsgAyABQeAGakGAgAFBAEEAEPAFGhCWBgsQlgYLAkBBrbkFEI4GRQ0AQY+MBkEAEN4EQQAoArDmCyIDKALsNCIAQQE6AIwBIABBjAJqIgcgA0GAK2oqAgAgByoCAJIiEjgCACAAIBIgACoCDJIgAEGQAmoqAgCSOALMAUG0hwYhAEG0hwYhAwJAIAIoAvA0IgdFDQAgBygCACEDCyABIAM2AqACQeKVCCABQaACahDeBAJAIAIoAvQ0IgNFDQAgAygCACEACyABIAA2ApACQaWVCCABQZACahDeBEG0hwYhAEG0hwYhAwJAIAIoAvg0IgdFDQAgBygCACEDCyABIAM2AoACQb2VCCABQYACahDeBAJAIAIoAvw0IgNFDQAgAygCACEACyABIAA2AvABQc+VCCABQfABahDeBEEAKAKw5gsiAygC7DQiAEEBOgCMASAAQYwCaiIHIAcqAgAgA0GAK2oqAgCTIhI4AgAgACASIAAqAgySIABBkAJqKgIAkjgCzAFBw4UGQQAQ3gRBACgCsOYLIgMoAuw0IgBBAToAjAEgAEGMAmoiByADQYAraioCACAHKgIAkiISOAIAIAAgEiAAKgIMkiAAQZACaioCAJI4AswBIAIqAqw1IRIgAigCpDUhACACKALcNSEDIAIoAtQ1IQcgAUHQAWpBEGogAi0AsTU2AgAgAUHkAWogB0ECdEGQ6AhqKAIANgIAIAEgAzYC1AEgASAANgLQASABIBK7OQPYAUHE2AQgAUHQAWoQ3gRBtIcGIQNBtIcGIQACQCACKALQNSIHRQ0AIAcoAgAhAAsgASAANgLAAUH2lQggAUHAAWoQ3gQgAioCnDUhEiACKQOQNSEWIAFBoAFqQRBqIAItAJg1NgIAIAEgFjcDoAEgASASuzkDqAFB4O8FIAFBoAFqEN4EIAJBhD1qKAIAIQAgAi0A7DwhByABIAJBgD1qKAIANgKcASABIAJBkD1qNgKYASABIAA2ApQBIAEgBzYCkAFB8+QHIAFBkAFqEN4EQQAoArDmCyIHKALsNCIAQQE6AIwBIABBjAJqIgggCCoCACAHQYAraioCAJMiEjgCACAAIBIgACoCDJIgAEGQAmoqAgCSOALMAUGXhQZBABDeBEEAKAKw5gsiBygC7DQiAEEBOgCMASAAQYwCaiIIIAdBgCtqKgIAIAgqAgCSIhI4AgAgACASIAAqAgySIABBkAJqKgIAkjgCzAECQCACKALENyIARQ0AIAAoAgAhAwsgASADNgKAAUGVlQggAUGAAWoQ3gQgAigCyDchACABIAIoAow4NgJ0IAEgADYCcEHj7gUgAUHwAGoQ3gQgASACKAL0N0ECdEGQ6AhqKAIANgJgQbHYBCABQeAAahDeBCACQdkGai0AACEAIAEgAkHaBmotAAA2AlQgASAANgJQQfnwBSABQdAAahDeBCACKALQNyEAIAEgAigC3Dc2AkQgASAANgJAQbn/BSABQcAAahDeBCACLQCWOCEAIAEgAi0Alzg2AjQgASAANgIwQf/uBSABQTBqEN4EIAEgAigCzDc2AiBB3/4FIAFBIGoQ3gQCQAJAIAIoAsw5IgANAEG0hwYhAAwBCyAAKAIAIQALIAEgADYCEEGLlgggAUEQahDeBEEAKAKw5gsiAygC7DQiAEEBOgCMASAAQYwCaiIHIAcqAgAgA0GAK2oqAgCTIhI4AgAgACASIAAqAgySIABBkAJqKgIAkjgCzAEQlgYLAkACQCAGLQAADQAgAkH53wBqLQAARQ0BCyAKKAIAQQFIDQAgAUHoBmohCEEAIQADQAJAIAIoArQ0IABBAnRqKAIAIgMtAIsBRQ0AQQAoArDmC0HYO2ohBwJAIAYtAABFDQAgAUHgBmogAyAEKAIAELMDIAcgAUHgBmogCEH/gYB8QwAAAABBD0MAAIA/EOMDCyACLQD5X0UNACADQQtqLQAAQQFxDQAgASADLgGaATYCACABQeAGakEgQYDyBSABEEMaIAMqAgwhEiABQQAoArDmCyoCsDIiEyADQRBqKgIAkjgC1AYgASATIBKSOALQBiAHIANBDGoiAyABQdAGakHIyZF7QwAAAABBDxDkAyAHIANBfyABQeAGakEAEPEDCyAAQQFqIgAgCigCAEgNAAsLIAJB+t8Aai0AAEUNACACKAKAPkEBSA0AIAFB6AZqIQlBACEMA0ACQCACKAKIPiAMQagEbGoiBygCUCACKAKQNEF/akgNAEEAKAKw5gtB2DtqIQgCQCAFKAIAIgBBBkgNACAHKAJUQQFIDQEgB0HUAGohCiAHQYAEaiELQQAhAANAIAFB4AZqIAcgBSgCACAAELQDIAggAUHgBmogCUH//4N8Qf+BgHwgACALLAAARiIDG0MAAAAAQX9DAABAQEMAAIA/IAMbEOMDIABBAWoiACAKKAIASA0ADAILAAsgAUHgBmogByAAQX8QtAMgCCABQeAGaiAJQf+BgHxDAAAAAEEPQwAAgD8Q4wMLIAxBAWoiDCACKAKAPkgNAAsLEPsBIAFBwAhqJAAL9QMBBn0CQAJAAkACQAJAAkACQAJAAkAgAg4ICAABAgMEBQYHCyAAIAEpAuQDNwIAIABBCGogAUHsA2opAgA3AgAPCyAAIAEpAvQDNwIAIABBCGogAUH8A2opAgA3AgAPCyAAIAEpAoQENwIAIABBCGogAUGMBGopAgA3AgAPCyAAIAEpApQENwIAIABBCGogAUGcBGopAgA3AgAPCyABQShqKgIAIQMgAUHAAGoqAgAhBCABQdwAaioCACEFIAFB+ANqKgIAIQYgASoCJCEHIAAgASoC9AMgASoCWJMgASoCPJIiCDgCACAAIAggB5I4AgggACAEIAYgBZOSIgQ4AgQgAEEMaiAEIAOSOAIADwsgAUEwaioCACEDIAFBwABqKgIAIQQgAUHcAGoqAgAhBSABQfgDaioCACEGIAEqAiwhByAAIAEqAvQDIAEqAliTIAEqAjySIgg4AgAgACAIIAeSOAIIIAAgBCAGIAWTkiIEOAIEIABBDGogBCADkjgCAA8LIAAgASkCxAQ3AgAgAEEIaiABQcwEaikCADcCAA8LQc68BkGC6QRB49IAQZeyBBAAAAsgAUEYaioCACEEIAFBEGoqAgAhAyAAIAEqAgwiBSABKgIUkjgCCCAAIAM4AgQgACAFOAIAIABBDGogAyAEkjgCAAvRCAEEfQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDg0NAAECAwQFBgcICQoLDAsgACABKQLkATcCACAAQQhqIAFB7AFqKQIANwIADwsgACABKQL0ATcCACAAQQhqIAFB/AFqKQIANwIADwsgACABKQLEAjcCACAAQQhqIAFBzAJqKQIANwIADwsgACABKQKEAjcCACAAQQhqIAFBjAJqKQIANwIADwsgACABKQKUAjcCACAAQQhqIAFBnAJqKQIANwIADwsgA0EASA0IIAEoAgwiAiADQegAbGogAUEQaigCAE8NCCACIANB6ABsaiIDKgIIIQQgAyoCDCEFIABBDGogAUGIAmoqAgAiBiABKgK0AZI4AgAgACAFOAIIIAAgBjgCBCAAIAQ4AgAPCyADQQBIDQggASgCDCICIANB6ABsaiABQRBqKAIATw0IIAIgA0HoAGxqIgMqAjQhBCABQfgBaioCACEFIAMqAjghBiAAQQxqIAFBgAJqKgIAOAIAIAAgBjgCCCAAIAU4AgQgACAEOAIADwsgA0EASA0IIAEoAgwiAiADQegAbGogAUEQaigCAE8NCCAAIAIgA0HoAGxqIgEpAiA3AgAgAEEIaiABQShqKQIANwIADwsgA0EASA0IIAEoAgwiAiADQegAbGogAUEQaigCAE8NCCACIANB6ABsaiIDKgI0IQQgAyoCSCEFIABBDGogAUGIAmoqAgAiBiABKgK4AZI4AgAgACAFOAIIIAAgBjgCBCAAIAQ4AgAPCyADQQBIDQggASgCDCICIANB6ABsaiABQRBqKAIATw0IIAIgA0HoAGxqIgMqAjQhBCADKgJMIQUgAEEMaiABQYgCaioCACIGIAEqArgBkjgCACAAIAU4AgggACAGOAIEIAAgBDgCAA8LIANBAEgNCCABKAIMIgIgA0HoAGxqIAFBEGooAgBPDQggAiADQegAbGoiAyoCNCEEIAMqAkAhBSAAQQxqIAFBiAJqKgIAIgYgASoCuAGSOAIAIAAgBTgCCCAAIAY4AgQgACAEOAIADwsgA0EASA0IIAEoAgwiAiADQegAbGogAUEQaigCAE8NCCACIANB6ABsaiIDKgI0IQQgAUGIAmoqAgAhBSADKgJEIQYgASoCuAEhByAAQQxqIAFBkAJqKgIAOAIAIAAgBjgCCCAAIAUgB5I4AgQgACAEOAIADwtBzrwGQYLpBEHV0gBBqbQEEAAACyAAIAEpAtQBNwIAIABBCGogAUHcAWopAgA3AgAPC0G72QVB0I4FQY4EQcv5BRAAAAtBu9kFQdCOBUGOBEHL+QUQAAALQbvZBUHQjgVBjgRBy/kFEAAAC0G72QVB0I4FQY4EQcv5BRAAAAtBu9kFQdCOBUGOBEHL+QUQAAALQbvZBUHQjgVBjgRBy/kFEAAAC0G72QVB0I4FQY4EQcv5BRAAAAvPAQEDfyMAQRBrIgIkACACIAAoAgA2AgQgAiABNgIAAkACQAJAIAFB5IIIIAIQiQZFDQBB2oUIQQAQ3gQCQCAAKAIAIgFBAUgNAANAIAAoAgAgAUgNAyAAKAIIIAFBf2oiA0ECdCIEaigCABDgAiAAKAIAIAFIDQQgACgCCCAEaigCAEGgkgQQuQMgAUEBSyEEEO4BIAMhASAEDQALCxCWBgsgAkEQaiQADwtB4LQFQe+OBUHcDEHL+QUQAAALQeC0BUHvjgVB3AxBy/kFEAAAC/8NAhF/BH0jAEGwBGsiAyQAAkAgASgCACIEQQFIDQAgASgCCCAEQX9qIgVBKGxqIgYoAhwNACAEIAUgBigCIBshBAtBACgCsOYLIQcgASgCMCEFIAEoAhghBiABKAIMIQggA0GwAWogBDYCACADIAg2AqwBIAMgBjYCqAEgAyACNgKgASADIAVBltwIIAUbNgKkASABQdHSBCADQaABahCMBiECQQAoArDmCyIJKALsNCIFQQE6AIwBAkACQAJAIAUoAogFIAFHDQACQCAFLQCPAQ0AIAlB4CpqKgIAIRQgBUHQAWogBUHYAWoqAgA4AgAgBUH0AWogBUH8AWopAgA3AgAgBUGEAmogBUGIAmoqAgA4AgAgBSAUIAVB1AFqKgIAkjgCzAELIANCzZmz9oOAgMA/NwKIAiADQoCAgPzTmbPmPjcCgAIgA0GAAmpBmYwGQQAQ4AQgAg0BDAILIAlB2DtqIQoCQAJAIABFDQACQEEAEJEBRQ0AIABBGGoqAgAhFCAAQRBqKgIAIRUgAyAAKgIMIAAqAhSSOAKAAiADIBUgFJI4AoQCIAogAEEMaiADQYACakH//4N4QwAAAABBD0MAAIA/EOMDCyACRQ0DIAAtAIsBDQFBhMsIQQAQ4gQMAQsgAkUNAgsgBEEBSA0AIANBgAJqQawCaiELIAEoAgghDCADQeAAakEgaiENIANB4ABqQRhqIQ4gA0HgAGpBEGohDwNAAkACQCAMKAIgIgVFDQAgAyAMKAIkNgKUASADIAU2ApABQePsBCADQZABahDoBAwBCyAMKAIcIQUgDCoCACEUIAwoAhAhACAMKgIEIRUgDCoCCCEWIA0gDCoCDLs5AwAgDiAWuzkDACAPIBW7OQMAIAMgADYCZCADIBS7OQNoIAMgBUEDbjYCYCADQYACakGsAkHL/AcgA0HgAGoQQxogASgCCCEFIAMgA0GAAmo2AlAgDCAFa0EobUHr2QQgA0HQAGoQjAYhBQJAQQAQkQFFDQAgBy0A/F8hAAJAIActAPtfIgINACAAQf8BcSEGQQEhACAGRQ0BCyADIAEgDCACQQBHIABB/wFxQQBHELoDCyAFRQ0AAkACQCABKAIMQQFODQBBACEIDAELIAEoAhQhCAsgASgCICAMKAIUIhBBFGxqIRFDAAAAACEUAkAgDCgCGCISIBIgDCgCHCITaiIGTw0AQwAAAAAhFCASIQUDQCADQeABakEQakIANwMAIANCADcD6AEgA0IANwPgAUEAIQADQCAFIQICQCAIRQ0AIAggBUEBdGovAQAhAgsgA0HgAWogAEEDdGogESACQRRsaikCADcDACAFQQFqIQUgAEEBaiIAQQNHDQALIBQgAyoC8AEgAyoC5AEiFSADKgLsASIWk5QgAyoC4AEgFiADKgL0ASIXk5QgAyoC6AEgFyAVk5SSkotDAAAAP5SSIRQgBSAGSQ0ACwsgA0EwakEQaiAUuzkDACADIBI2AjggAyAQNgI0IAMgEzYCMCADQYACakGsAkHwhgQgA0EwahBDGiADQgA3AuABIANBgAJqQQBBACADQeABahCNBRoCQEEAEJEBRQ0AIAMgASAMQQFBABC6AwsgA0HgAWoQYRogDCgCHEEDbiEAQQAoArDmCyIFKALsNCECAkAgBSgC/D0iBUUNACAFLQCVBEUNACAFEKAECyACQdABaioCACEUIANBgICA/Hs2AvQBIAMgFDgC+AEgAyAANgLoASADQgA3AuwBIANC/////w83AuABAkAgA0HgAWoQZkUNAANAAkAgAygC4AEiEiADKALkAU4NACAMKAIYIBJBA2xqIQADQCADQcABakEQakIANwMAIANCADcDyAEgA0IANwPAASADQYACaiECQQAhBgNAIAAhBQJAIAhFDQAgCCAAQQF0ai8BACEFCyADQcABaiAGQQN0aiARIAVBFGxqIgUpAgA3AwAgBSoCACEUIAUqAgQhFSAFKgIIIRYgBUEMaioCACEXIANBKGogBSgCEDYCACADQSBqIBe7OQMAIANBGGogFrs5AwAgA0EQaiAVuzkDACADQebOCEGUmwYgBhs2AgAgAyAUuzkDCCADIAA2AgQgAEEBaiEAIAIgAiALIAJrQaTUCCADEENqIQIgBkEBaiIGQQNHDQALIANCADcCuAEgA0GAAmpBAEEAIANBuAFqEI0FGgJAQQAQkQFFDQAgCSAJKAL8OyIFQX5xNgL8OyAKIANBwAFqQQNB//+DeEEBQwAAgD8Q2QMgCSAFNgL8OwsgEkEBaiISIAMoAuQBSA0ACwsgA0HgAWoQZg0ACwsQlgYgA0HgAWoQYhoLIAxBKGoiDCABKAIIIARBKGxqSQ0ACwsQlgYLIANBsARqJAALgQcCB38CfSMAQfACayICJAAgACgCJCEDQQAoArDmCygCkDQhBCAAKAIAIQUgACgCECEGIAIgATYCUCACIAY2AlQgAiAFNgJYIAJB39kHQZbcCCADIARBfmoiAUgbNgJcIAJB8ABqQYACQZzWBCACQdAAahBDGgJAAkACQCADIAFODQBBAEEAKAKw5gtB7CtqEG0gAiACQfAAajYCMCAAQevZBCACQTBqEIwGIQNBARBuIAMNAQwCCyACIAJB8ABqNgJAIABB69kEIAJBwABqEIwGIQMCQEEAEJEBRQ0AQQAoArDmC0HYO2oiASAAQShqIABBMGpB//+DeEMAAAAA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DzgCACABQQFqIgFBDEcNAAsgAguXAQICfwF9AkAgACoCFCABWw0AIAAgATgCFEEAIQIDQAJAAkBD2w/JQCACskMAAIA/kiIEIAGTIASVEJAPlSIEi0MAAABPXUUNACAEqCEDDAELQYCAgIB4IQMLIAAgAmpBjAFqIANBgAQgA0GABEgbIgNBDCADQQxKGyIDQf8BIANB/wFIGzoAACACQQFqIgJBwABHDQALCwvpBQEDfwJAIAAoAgRBf0oNAEEAEDwhAQJAIAAoAggiAkUNACABIAIgACgCAEEobBCeDxogACgCCBA+CyAAQQA2AgQgACABNgIICyAAQQA2AgACQCAAQRBqKAIAQX9KDQBBABA8IQECQCAAQRRqKAIAIgJFDQAgASACIAAoAgxBAXQQng8aIAAoAhQQPgsgAEEANgIQIAAgATYCFAsgAEEANgIMAkAgAEEcaigCAEF/Sg0AQQAQPCEBAkAgAEEgaigCACICRQ0AIAEgAiAAKAIYQRRsEJ4PGiAAKAIgED4LIABBADYCHCAAIAE2AiALIABBADYCGCAAKAIsKAIoIQEgAEIANwJgIAAgATYCJCAAQegAakIANwIAIABB8ABqQgA3AgAgAEIANwI0IABBADYCKAJAIABBwABqKAIAQX9KDQBBABA8IQECQCAAQcQAaigCACICRQ0AIAEgAiAAKAI8QQR0EJ4PGiAAKAJEED4LIABBADYCQCAAIAE2AkQLIABBADYCPAJAIABBzABqKAIAQX9KDQBBABA8IQECQCAAQdAAaigCACICRQ0AIAEgAiAAKAJIQQJ0EJ4PGiAAKAJQED4LIABBADYCTCAAIAE2AlALIABBADYCSAJAIABB2ABqKAIAQX9KDQBBABA8IQECQCAAQdwAaigCACICRQ0AIAEgAiAAKAJUQQN0EJ4PGiAAKAJcED4LIABBADYCWCAAIAE2AlwLIABCgICAgBA3AnggAEEANgJUAkAgACgCACIBIAAoAgRHDQAgAUEBaiECAkACQCABDQBBCCEDDAELIAFBAm0gAWohAwsgASADIAIgAyACShsiAk4NACACQShsEDwhAQJAIAAoAggiA0UNACABIAMgACgCAEEobBCeDxogACgCCBA+CyAAIAI2AgQgACABNgIIIAAoAgAhAQsgACgCCCABQShsakEAQSgQoA8aIABBgICA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QYCAgBhxGyIDQf9vcSADIANBgCBxGyIDQRByIgcgAyAHIANBD3EbIApBgAJxGyIHNgIEIA0gBCkCADcCnAMCQAJAIAtFDQAgB0GAgIAYcSEDAkACQCAFQ///f38gB0GAgIAIcSIBQRh2G0P//39/IAVDAAAAAF4bIgVD//9/f1wiBA0AIANBgICACEcNAQsgBkMAAIAAQwAAAAAgA0GAgIAIRhs4AiAgBiAFQwAAAAAgBBs4AhwgBkEcahDSAgsCQCAPQYCAgBhxDQAgBkIANwIcIAZBHGoQ0wILIAYgBioCYCAGKgJYkzgCHCAGIAZB5ABqKgIAIAYqAlyTOAIgIAAgESAGQRxqQQAgAUENdhCpAhogDSAIKALsNCIDNgK0AyANIAMpApQENwL0ASANQfwBaiADQZwEaikCADcCACADQRhqKgIAIRIgAyoCFCETIAMqAgwhBSANQdgBaiADQRBqKgIAIhQ4AgAgDSAFOALUASANQeABaiAUIBKSOAIAIA1B3AFqIAUgE5I4AgAgDUHsAWogA0H8A2opAgA3AgAgDSADKQL0AzcC5AECQCADKgI8QwAAAABcDQAgA0HAAGoqAgBDAAAAAFwNACADKgJIQwAAAABbDQILQe2nBUHS6ARB9wJB74oEEAAACyANIAYpA1g3AuQBIA1B7AFqIAZB4ABqIgMpAwA3AgAgDSAGKQNYNwLUASANQdwBaiADKQMANwIAIA0gBikDWDcC9AEgDUH8AWogAykDADcCAAsgERDiAiANIA0oArQDIgBBjAJqKgIAOAKYASANIAApArQENwLEAiANQcwCaiAAQbwEaikCADcCACANIAAtAI8BOgCiBCANQdwCaiAAQZwEaikCADcCACANIAApApQENwLUAiANIAApAqQENwLkAiANQewCaiAAQawEaikCADcCACANIAlBkAJqKAIANgKkAyANIABB/AFqIgMpAgA3AoQDIA0gAEH0AWoiASkCADcCjAMgDSAAQeQBaikCADcClAMgDSAJQbQDaioCADgCqAMgDSAJQbwDaigCADYCrAMgA0IANwIAIAFCADcCACAHQYCAgAJxRSAHQYCIgAFxQQBHcSEDQwAAAAAhBUMAAIA/QwAAAAAgB0GABHEbIRMCQAJAAkAgB0GAhIAEcSIBQYAERg0AIAENASAIQfAqaioCACESDAIL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M7s5AwBDAAAAACE0IAFBoAJqQRhqQf3nB0GW3AggM0MAAAAAWxs2AgAgASAyuzkDqAIgASAxuzkDoAJBrtUEIAFBoAJqEOgEIAAqAqQBITEgACoCrAEhMiAAKgKwASEzIAFBgAJqQRhqIAAqAqABuzkDACABQYACakEQaiAzuzkDACABIDK7OQOIAiABIDG7OQOAAkGeogUgAUGAAmoQ6AQgACwAgAQhAiABIAAsAIEENgL0ASABIAI2AvABQbHvBSABQfABahDoBCAALACDBCECIAAsAIYEIQMgASAALACFBDYC6AEgASADNgLkASABIAI2AuABQanwBSABQeABahDoBAJAIAAoAlQiBEEBSA0AIABBEGooAgAhBSAAKAIMIQdBACECA0AgByACQegAbGoiAyAFTw0DAkAgAy0AAEEEcUUNACA0IAMqAhiSITQLIAJBAWoiAiAERw0ACyAEQQFIDQAgAUGoA2pBCGohCCABQdABaiEJIAFBzAFqIQogAUHIAWohCyABQcQBaiEMIAFBwAFqIQ0gAUG4AWohDiABQYABaiEPIAFB+ABqIRAgAUHwAGohESABQeAAaiESIAFB2ABqIRMgAUHQAGohFCABQcgAaiEVIAFBwABqIRYgAUE8aiEXIAFBOGohGCABQTRqIRkgAUEwaiEaIAFBLGohGyABQSRqIRwgAUEgaiEdIAFBGGohHiABQbABaiEfIAFBqAFqISAgAUGgAWohISABQZgBaiEiIAFBiAFqISMgAUGQAWohJCABQbwBaiElQQAhAwNAIAAoAgwgA0HoAGxqIgIgACgCEE8NBCAAIAMQnQQhBUHi6gdBltwIIAMgACwAjgRIGyEHQwAAAAAhNSACLQBZISYgAi0AWCEnIAItAF8hKCACLQBeISkgAi0AXSEqIAItAFwhKyACLQBaISwgAiwAUiEtIAIqAhgiMbshPCACKgIUuyE9IAIqAhC7IT4gAioCBLshPyACKgIMIjIgACoC9AEiNpO7IUAgAioCCCIzIDaTuyFBAkAgMUMAAAAAXkUNACAxIDSVQwAAyEKUITULIAItAGQhLiACQShqKgIAITYgAioCQCE3IAIqAkQhOCACKgJIITkgAioCTCE6IAIqAjQhMSACKgIgITsgAiwAViEvIAIoAjAhMCAJQbDNCEGW3AggAigCACIEQRBxGzYC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GGogDSANkiADKgJokiAKIAqSIAMqAmySEPsCIAMgCzgCTCADQdQAaiALIAMqAmSSOAIAIAMgCTYCSCADIAMqAmAgDJI4AlAgA0HgAGogCCoCABCuAiADQcgAaiAHQQAQrwJFDQAgA0HIAGogByADQccAaiADQcYAaiAGQbADaigCAEEJdEGACHEgAnIQ6gQhBEEXQRYgAy0ARhtBFSADLQBHG0MAAIA/EGghBiADQcgAaiAHQQEQfiADIAMpA0giDjcDOCADIAMpA1AiDzcDMCAFQdgqaioCACEKIAMgDjcDECADIA83AwggA0EQaiADQQhqIAZBASAKEHwgBSoC0CohCiADIAMqAkwgBSoC1CoiC5I4AiwgAyAKIAMqAkiSOAIoIAMgAyoCVCALkzgCJCADIAMqAlAgCpM4AiAgA0EoaiADQSBqIABBACADQegAaiAFQawraiADQcgAahB6CyADQfAAaiQAIAQLCwAgACABQQAQ6wQLTwICfwF9IwBBEGsiASQAQQAoArDmC0HUKmoiAioCACEDIAJBADYCACABQgA3AgggACABQQhqQYCAAhDrBCEAIAIgAzgCACABQRBqJAAgAAuRAgMDfwF+AX0jAEEwayIDJABBACEEQQAoArDmCygC7DQiBUEBOgCMAQJAAkAgBS0AjwENACABKgIAQwAAAABbDQEgASoCBEMAAAAAWw0BQQAhBCAFIABBABCAASEAIAMgASkCACIGNwMAIAMgBjcDICADQShqIANDAAAAAEMAAAAAEPsCIAUqAswBIQcgBSkCzAEhBiADQRxqIAVB0AFqKgIAIAMqAiySOAIAIAMgBjcDECADIAcgAyoCKJI4AhggA0EoakMAAIC/EK4CIANBEGogAEEAEK8CRQ0AIANBEGogACADQQ9qIANBDmogAhDqBCEECyADQTBqJAAgBA8LQYypBUG96ARB2gVBrvMEEAAAC+YDAwV/A30CfiMAQdAAayIEJABBACEFQQAoArDmCyIGKALsNCIHQQE6AIwBAkAgBy0AjwENAEEAIQUgByAAQQAQgAEhACACKgIAIQkgByoCzAEhCiAHKQLMASEMIARBzABqIAdB0AFqKgIAIAIqAgQiC5I4AgAgBCAMNwNAIAQgCiAJkjgCSEMAAIC/IQkCQCALEP4CYEUNACAGQdQqaioCACEJCyACIAkQ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Ay8BACIBIAQvAQBrIgAgACABSxs7AQAPCwJAIAFBK0cNACADKAIAIQACQAJAIAQoAgAiAUF/Sg0AQYCAgIB4IQRBgICAgHggAWsgAEoNAQtB/////wcgASAAaiIEIAFB/////wdzIABIGyAEIAFBAEobIQQLIAIgBDYCAA8LIAFBLUcNBSADKAIAIQACQAJAIAQoAgAiAUEBSA0AQYCAgIB4IQQgAUGAgICAeHIgAEoNAQtB/////wcgACABayIEIAFB/////wdqIABIGyAEIAFBAEgbIQQLIAIgBDYCAA8LAkAgAUErRw0AIAJBfyAEKAIAIgEgAygCAGoiACAAIAFJGzYCAA8LIAFBLUcNBCACQQAgAygCACIBIAQoAgBrIgAgACABSxs2AgAPCwJAIAFBK0cNACADKQMAIQUCQAJAIAQpAwAiBkJ/VQ0AQoCAgICAgICAgH8hB0KAgICAgICAgIB/IAZ9IAVVDQELQv///////////wAgBiAFfCIHIAZC////////////AIUgBVMbIAcgBkIAVRshBwsgAiAHNwMADwsgAUEtRw0DIAMpAwAhBQJAAkAgBCkDACIGQgFTDQBCgICAgICAgICAfyEHIAZCgICAgICAgICAf4QgBVUNAQtC////////////ACAFIAZ9IgcgBkL///////////8AfCAFUxsgByAGQgBTGyEHCyACIAc3AwAPCwJAIAFBK0cNACACQn8gBCkDACIGIAMpAwB8IgUgBSAGVBs3AwAPCyABQS1HDQIgAkIAIAMpAwAiBiAEKQMAfSIFIAUgBlYbNwMADwsCQCABQStHDQAgAiADKgIAIAQqAgCSOAIADwsgAUEtRw0BIAIgAyoCACAEKgIAkzgCAA8LAkAgAUErRw0AIAIgAysDACAEKwMAoDkDAA8LIAFBLUcNACACIAMrAwAgBCsDAKE5AwALDwtBzrwGQb3oBEHXDkHT7AQQAAAL+gkDBX8BfQF8IwBB0AFrIgUkAAN/QQAhBgJAAkACQAJAAkAgAC0AACIHQR9KDQAgB0EJRw0BDAQLIAdBIEYNAyAHQVZqQQJJDQEgB0EvRg0BCyAHIQgMAQsDQCAALQABIQggAEEBaiIJIQAgCEEJRg0AIAkhACAIQSBGDQALIAchBiAJIQALAkACQAJAIAhFDQAgAkEKTw0CIAVByAFq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0gpBiPMIQfABIABB7NIKQYzzCEHxASABEA1BBBDfECIAQcAANgIAQQQQ3xAiAUHAADYCAEHIhglBncsEQcDTCkGI8whB+QEgAEHA0wpBjPMIQfoBIAEQDUEEEN8QIgBBxAA2AgBBBBDfECIBQcQANgIAQciGCUH9gQRB/NMKQdTwCEH0ASAAQfzTCkHY8AhB9QEgARANQQQQ3xAiAEH7ATYCAEEEEN8QIgFB/AE2AgBByIYJQcnIBUGQ7whBiPMIQe4BIABBkO8IQYzzCEHvASABEA1BBBDfECIAQf0BNgIAQciGCUHDpgRBkO8IQYjzCEHuASAAQQBBAEEAQQAQDQsGAEHIhgkLDwACQCAARQ0AIAAQ4BALCy4BAX8jAEEQayICJAAgAkHonQQ2AgBBjc8IIAIQ5w8aIABBAjYCACACQRBqJAALJwEBfyMAQRBrIgIkACACQcKcBDYCAEGNzwggAhDnDxogAkEQaiQACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAAAgAigCDBAMIAIoAgwiABADIAJBEGokACAACzUBAX8jAEEQayIDJAAgACgCACEAIAMgAjYCDCABIANBDGogABEAACADKAIMEAMgA0EQaiQACw0AIAEgACgCAGotAAALDwAgASAAKAIAaiACOgAACw0AIAEgACgCAGooAgALDwAgASAAKAIAaiACNgIACw0AIAEgACgCAGoqAgALDwAgASAAKAIAaiACOAIACy4BAX8jAEEQayICJAAgAiABQSBqNgIIIABBxPAIIAJBCGoQAjYCACACQRBqJAALLgEBfyMAQRBrIgIkACACIAFBKGo2AgggAEHE8AggAkEIahACNgIAIAJBEGokAAtEAQF/IwBBEGsiAiQAAkACQCABKAIwIgENAEECIQEMAQsgAiABNgIIQczTCiACQQhqEAIhAQsgACABNgIAIAJBEGokAAsNACABIAAoAgBqKAIACw8AIAEgACgCAGogAjYCAAs/AQF/IwBBEGsiAiQAIAAgAkEEaiABQcoAahCSByIBEJMHGgJAIAEsAAtBf0oNACABKAIAEOAQCyACQRBqJAALUAEBfyMAQRBrIgIkACACQQRqIAEQ6QYgAEHKAGogAigCBCIAIAJBBGogAiwADyIBQQBIG0EnEIMQGgJAIAFBf0oNACAAEOAQCyACQRBqJAALRAEBfyMAQRBrIgIkAAJAAkAgASgCdCIBDQBBAiEBDAELIAIgATYCCEHo/gggAkEIahACIQELIAAgATYCACACQRBqJAAL7QIBAn9BpIcJQbyHCUHchwlBAEGY7whB/gFBhPAIQQBBhPAIQQBBr9QEQYbwCEH/ARAHQbypBEGAAhCBCUEIEN8QIgBBADYCBCAAQYECNgIAQaSHCUHrqQRBAkH4hwlBiPMIQYICIABBAEEAEA5BiqIGQYMCEIUJQQQQ3xAiAEGEAjYCAEEEEN8QIgFBhQI2AgBBpIcJQZyNBkGQ7whBiPMIQYYCIABBkO8IQYzzCEGHAiABEA1BBBDfECIAQQg2AgBBBBDfECIBQQg2AgBBpIcJQYuIBUG00wpBiPMIQYgCIABBtNMKQYzzCEGJAiABEA1BBBDfECIAQQw2AgBBBBDfECIBQQw2AgBBpIcJQbGsBEG00wpBiPMIQYgCIABBtNMKQYzzCEGJAiABEA1BBBDfECIAQYoCNgIAQaSHCUGCggVBkO8IQYjzCEGGAiAAQQBBAEEAQQAQDUHauQRBiwIQjglBzqYEQYwCEJAJCwYAQaSHCQsSAAJAIABFDQAgABDxDhDgEAsLewECfyMAQZABayIDJAACQAJAIAIoAgAiBEECRw0AIANBEGoQ/AMaDAELIAMgBDYCDCAEEAwgA0EQaiADQQxqEOgGIAQQAwsgAyABQQAgA0EQaiACKAIAQQJGGxDyDjYCiAEgAEHo/gggA0GIAWoQAjYCACADQZABaiQACysBAX9BBBDfECICIAE2AgBBpIcJIABBA0HshwlBhPEIQY0CIAJBAEEAEA4LBABBAQs5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAwALqAIBBH8jAEEgayICJAAgAkEANgIUIAJBfzYCECACQX82AgwgAkF/NgIIIAEgAkEUaiACQRBqIAJBDGogAkEIahD2DiAAEAEiATYCAEH2xgQQBCEAIAIoAgghAyACKAIMIQQgAigCECEFIAIgAigCFDYCHCACIAMgBCAFbGw2AhggASAAQaiICSACQRhqEAIiAxAFIAMQAyAAEANBhYgFEAQhACACIAIoAhA2AhggASAAQbTTCiACQRhqEAIiAxAFIAMQAyAAEANBo6wEEAQhACACIAIoAgw2AhggASAAQbTTCiACQRhqEAIiAxAFIAMQAyAAEANB64EFEAQhACACIAIoAgg2AhggASAAQbTTCiACQRhqEAIiAxAFIAMQAyAAEAMgAkEgaiQACysBAX9BBBDfECICIAE2AgBBpIcJIABBAkGAiAlBiPMIQY4CIAJBAEEAEA4LLgEBfyMAQRBrIgIkACACIAEoAgQ2AgggAEG00wogAkEIahACNgIAIAJBEGokAAtbAgF/AXwjAEEQayICJAAgASgCAEG00wogAkEMahAIIQMgAigCDBAJAkACQCADmUQAAAAAAADgQWNFDQAgA6ohAQwBC0GAgICAeCEBCyAAIAE2AgQgAkEQaiQACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAAAgAigCDBAMIAIoAgwiABADIAJBEGokACAACzUBAX8jAEEQayIDJAAgACgCACEAIAMgAjYCDCABIANBDGogABEAACADKAIMEAMgA0EQaiQACw0AIAEgACgCAGooAgALDwAgASAAKAIAaiACNgIACy4BAX8jAEEQayICJAAgAiABQSBqNgIIIABBxPAIIAJBCGoQAjYCACACQRBqJAALewEDfyMAQRBrIgIkAAJAIAAoAqgIQQFIDQBBACEDA0AgAiAAKAKwCCADQQJ0aigCADYCCEHo/gggAkEIahACIgQQDCACIAQ2AgggASgCAEEBQfjuCCACQQhqEBEQAyAEEAMgA0EBaiIDIAAoAqgISA0ACwsgAkEQaiQACysBAX9BBBDfECICIAE2AgBBpIcJIABBA0GwiAlBjPMIQY8CIAJBAEEAEA4LLAEBfyMAQRBrIgIkACACEO8ONgIIIABB6P4IIAJBCGoQAjYCACACQRBqJAALKwEBf0EEEN8QIgIgATYCAEGkhwkgAEECQYCICUGI8whBjgIgAkEAQQAQDgtMAQF/IwBBEGsiAyQAIAAoAgAhACADIAI2AgggA0EMaiABIANBCGogABEEACADKAIMEAwgAygCDCIAEAMgAygCCBADIANBEGokACAACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAAAgAigCDBAMIAIoAgwiABADIAJBEGokACAACzUBAX8jAEEQayIDJAAgACgCACEAIAMgAjYCDCABIANBDGogABEAACADKAIMEAMgA0EQ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AAsHACAAERAAC0EBAX8jAEEQayIEJAAgBCADNgIIIAQgATYCDCAEQQxqIAIgBEEIaiAAEQQAIAQoAggQAyAEKAIMEAMgBEEQaiQACzwBAX8jAEEQayIDJAAgA0IANwIIIAAgA0EIahDdBiEAIANCADcCACAAIAEgAiADEN0GENACIANBEGokAAsuAQF/IwBBEGsiAyQAIAMgATYCDCADQQxqIAIgABEAACADKAIMEAMgA0EQaiQACyoBAX8jAEEQayICJAAgAkIANwIIIAAgAkEIahDdBiABEN0BIAJBEGokAAtiAQF/IwBBEGsiBSQAIAUgAjYCCCAFIAE2AgwgBSADNgIEIAUgBDYCACAFQQxqIAVBCGogBUEEaiAFIAARCQAgBSgCABADIAUoAgQQAyAFKAIIEAMgBSgCDBADIAVBEGokAAubAQEDfyMAQRBrIgQkAAJAAkAgAigCACIFQQJGDQBBACgCxOYLIQYgBRAMIAYoAkwQAyAGIAIoAgA2AkwgBEIANwIIIAAgBEEIahDdBiECIARCADcCACACIAEgBBDdBkHMBkEAENECDAELIARCADcCCCAAIARBCGoQ3QYhAiAEQgA3AgAgAiABIAQQ3QZBAEEAENECCyAEQRBqJAALKAEBfyMAQRBrIgEkACABQgA3AgggACABQQhqEN0GENICIAFBEGokAAsLACABIAIgABEAAAsJACABIAARFQALKgEBfyMAQRBrIgIkACACQgA3AgggACACQQhqEN0GIAEQxQIgAkEQaiQACyoBAX8jAEEQayICJAAgAkIANwIIIAAgAkEIahDdBiABEMgCIAJBEGokAAsJACAAIAEQygILBQAQzgILVgEBfyMAQRBrIgQkACAEQQRqIAFBBGogASgCABDqBiEBIAQgAjYCACABIAQgAyAAEQQAIAQoAgAQAwJAIAEsAAtBf0oNACABKAIAEOAQCyAEQRBqJAALQgEDfyMAQRBrIgMkACAAKAIAIQQgACwACyEFIANCADcCCCAEIAAgBUEASBsgASADQQhqEN0GIAIQxgIgA0EQaiQAC0IBA38jAEEQayIDJAAgACgCACEEIAAsAAshBSADQgA3AgggBCAAIAVBAEgbIAEgA0EIahDdBiACEMkCIANBEGokAAtGAQF/IwBBEGsiBCQAIARBBGogAUEEaiABKAIAEOoG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IQAMAQtBgICAgHghAAsgABDlAiEADAELIAFBBGogABDpBiABKAIEIAFBBGogASwAD0EASBsQ5AIhACABLAAPQX9KDQAgASgCBBDgEAsgAUEQaiQAIAALFwAgACgCACAAIAAsAAtBAEgbQQAQ3QQLMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDeBCABQRBqJAALUgEBfyMAQRBrIgMkACADIAE2AgwgA0EMaiADIAJBBGogAigCABDqBiICIAARAAACQCACLAALQX9KDQAgAigCABDgEAsgAygCDBADIANBEGokAAtRAQF/IwBBIGsiAiQAIAJBGGpCADcDACACQgA3AxAgACACQRBqEOMGIQAgAiABKAIAIAEgASwAC0EASBs2AgAgAEHr2QQgAhDgBCACQSBqJAALMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDiBCABQRBqJAALMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDkBCABQRBqJAALawEBfyMAQSBrIgMkACADQRRqIAFBBGogASgCABDqBiIBIANBCGogAkEEaiACKAIAEOoGIgIgABEAAAJAIAIsAAtBf0oNACACKAIAEOAQCwJAIAEsAAtBf0oNACABKAIAEOAQCyADQSBqJAALSgEDfyMAQRBrIgIkACAAKAIAIQMgACwACyEEIAIgASgCACABIAEsAAtBAEgbNgIAIAMgACAEQQBIG0Hr2QQgAhDmBCACQRBqJAALMgEBfyMAQRBrIgEkACABIAAoAgAgACAALAALQQBIGzYCAEHr2QQgARDoBCABQRBqJAALWAEBfyMAQRBrIgMkACADQQRqIAFBBGogASgCABDqBiEBIAMgAjYCACABIAMgABECACECIAMoAgAQAwJAIAEsAAtBf0oNACABKAIAEOAQCyADQRBqJAAgAgtEAQN/IwBBEGsiAiQAIAAoAgAhAyAALAALIQQgAkIANwIIIAMgACAEQQBIGyABIAJBCGoQ3QYQ7AQhACACQRBqJAAgAAtGAQF/IwBBEGsiAiQAIAJBBGogAUEEaiABKAIAEOoGIgEgABEDACEAAkAgASwAC0F/Sg0AIAEoAgAQ4BALIAJBEGokACAACxUAIAAoAgAgACAALAALQQBIGxDtBAtGAQN/IwBBEGsiAyQAIAAoAgAhBCAALAALIQUgA0IANwIIIAQgACAFQQBIGyABIANBCGoQ3QYgAhDuBCEAIANBEGokACAAC0gBAX8jAEEQayIDJAAgA0EEaiABQQRqIAEoAgAQ6gYiASACIAARAgAhAgJAIAEsAAtBf0oNACABKAIAEOAQCyADQRBqJAAgAgsXACAAKAIAIAAgACwAC0EASBsgARDwBAuLAQEBfyMAQSBrIgckACAHIAI2AhggByABNgIcIAcgAzYCFCAHIAQ2AhAgByAFNgIMIAcgBjYCCCAHQRxqIAdBGGogB0EUaiAHQRBqIAdBDGogB0EIaiAAEQ8AIAcoAggQAyAHKAIMEAMgBygCEBADIAcoAhQQAyAHKAIYEAMgBygCHBADIAdBIGokAAvaAQIBfwF8IwBBwABrIgYkACAAKAIAQbTTCiAGQRhqEAghByAGKAIYEAkgBkIANwI4IAEgBkE4ahDdBiEAIAZCADcCMCACIAZBMGoQ3QYhASAGQgA3AiggAyAGQShqEN0GIQIgBkEYakEIakIANwMAIAZCADcDGCAEIAZBGGoQ4wYhAyAGQQhqQQhqQgA3AwAgBkIANwMIAkACQCAHmUQAAAAAAADgQWNFDQAgB6ohBAwBC0GAgICAeCEECyAEIAAgASACIAMgBSAGQQhqEOMGEPYEIAZBwABqJAALkQEBAX8jAEEgayIIJAAgCCACNgIYIAggATYCHCAIIAM2AhQgCCAENgIQIAggBjYCDCAIIAc2AgggCEEcaiAIQRhqIAhBFGogCEEQaiAFIAhBDGogCEEIaiAAEQoAIQIgCCgCCBADIAgoAgwQAyAIKAIQEAMgCCgCFBADIAgoAhgQAyAIKAIcEAMgCEEgaiQAIAIL4AECAX8BfCMAQcAAayIHJAAgACgCAEG00wogB0EYahAIIQggBygCGBAJIAdCADcCOCABIAdBOGoQ3QYhACAHQgA3AjAgAiAHQTBqEN0GIQEgB0IANwIoIAMgB0EoahDdBiECIAdBGGpBCGpCADcDACAHQgA3AxggBSAHQRhqEOMGIQMgB0EIakEIakIANwMAIAdCADcDCAJAAkAgCJlEAAAAAAAA4EFjRQ0AIAiqIQUMAQtBgICAgHghBQsgBSAAIAEgAiAEIAMgBiAHQQhqEOMGEPgEIQAgB0HAAGokACAAC2QBA38jAEEQayICJAAgACgCACEDIAAsAAshBCACIAE2AgwgAkGckglBCGoiATYCBCACQQRqEPYMIAMgACAEQQBIGyACQQhqEPkEIQAgAiABNgIEIAJBBGoQ9wwgAkEQaiQAIAALWgEBfyMAQRBrIgQkACAEQQRqIAFBBGogASgCABDqBiEBIAQgAjYCACABIAQgAyAAEQUAIQIgBCgCABADAkAgASwAC0F/Sg0AIAEoAgAQ4BALIARBEGokACACC2YBA38jAEEQayIDJAAgACgCACEEIAAsAAshBSADIAE2AgwgA0HwkglBCGoiATYCBCADQQRqEPoMIAQgACAFQQBIGyADQQhqIAIQ/AQhACADIAE2AgQgA0EEahD7DCADQRBqJAAgAAtIAQF/IwBBEGsiAyQAIANBBGogAUEEaiABKAIAEOoGIgEgAiAAEQIAIQICQCABLAALQX9KDQAgASgCABDgEAsgA0EQaiQAIAILFwAgACgCACAAIAAsAAtBAEgbIAEQ/gQLZgEDfyMAQRBrIgMkACAAKAIAIQQgACwACyEFIAMgATYCDCADQbSTCUEIaiIBNgIEIANBBGoQ/gwgBCAAIAVBAEgbIANBCGogAhD/BCEAIAMgATYCBCADQQRqEP8MIANBEGokACAAC0EBAX8jAEEQayIEJAAgBCADNgIIIAQgAjYCDCABIARBDGogBEEIaiAAET4AIAQoAggQAyAEKAIMEAMgBEEQaiQAC7oBAQN/IwBBIGsiAyQAIANCADcCGCABIANBGGoQ3QYhBEEAIQEgA0EQakEANgIAIANCADcCCCADQaCVCUEIaiIFNgIEIAMgAjYCFAJAIAIoAgBBAkYNACADQQRqEIINQQAgAygCCCADQQhqIAMsABNBAEgbIAMoAhQoAgBBAkYbIQELIANBiJQJQQhqNgIEIAAgBCABEIAFIAMgBTYCBAJAIAMsABNBf0oNACADKAIIEOAQCyADQSBqJAALxQEBBX8jAEEgayIDJAAgACgCACEEIAAsAAshBUEAIQYgA0EYakEANgIAIANCADcCECADQaCVCUEIaiIHNgIMIAQgACAFQQBIGyEAIAMgATYCHAJAIAEoAgBBAkYNACADQQxqEIINQQAgAygCECADQRBqIAMsABtBAEgbIAMoAhwoAgBBAkYb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EI4NIAQgACAFQQBIGyADQRBqIAIQ/wUhACADIAE2AgwgA0EMahCPDSADQSBqJAAgAAtmAQN/IwBBIGsiAyQAIAAoAgAhBCAALAALIQUgAyABNgIcIANBuJcJQQhqIgE2AgggA0EIahCSDSAEIAAgBUEASBsgA0EMaiACEIAGIQAgAyABNgIIIANBCGoQkw0gA0EgaiQAIAALZgEDfyMAQSBrIgMkACAAKAIAIQQgACwACyEFIAMgATYCHCADQYCXCUEIaiIBNgIMIANBDGoQjg0gBCAAIAVBAEgbIANBEGogAhCHBiEAIAMgATYCDCADQQxqEI8NIANBIGokACAAC3ABAX8jAEEgayIFJAAgBUEUaiABQQRqIAEoAgAQ6gYhASAFIAQ2AgwgBSACNgIQIAEgBUEQaiADIAVBDGogABEHACEEIAUoAgwQAyAFKAIQEAMCQCABLAALQX9KDQAgASgCABDgEAsgBUEgaiQAIAQL1AEBA38jAEEwayIEJAAgACgCACEFIAAsAAshBiAEIAE2AiwgBEG4lwlBCGo2AhggBEEYahCSDSAEQdSjCUEIajYCAEEAIQEgBSAAIAZBAEgbIQAgBCADNgIUIARBGGpBBGohBQJAIAMoAgBBAkYNACAEEO8NIAQoAhQoAgBBAkYNACAEQQRqIQELIAAgBSACIAEQgwYhACAEQdSjCUEIajYCAAJAIAQoAhQoAgBBAkYNACAEEPANCyAEQbiXCUEIajYCGCAEQRhqEJMNIARBMGokACAAC28BA38jAEEgayIEJAAgACgCACEFIAAsAAshBiAEQRhqQgA3AwAgBEIANwMQIAEgBEEQahDjBiEBIARCADcCCCAEIAMgBEEIahDdBikCADcDACAFIAAgBkEASBsgASACIAQQggYhACAEQSBqJAAgAAsVACAAKAIAIAAgACwAC0EASBsQjgYLbwEBfyMAQSBrIgMkACADQRRqIAFBBGogASgCABDqBiIBIANBCGogAkEEaiACKAIAEOoGIgIgABECACEAAkAgAiwAC0F/Sg0AIAIoAgAQ4BALAkAgASwAC0F/Sg0AIAEoAgAQ4BALIANBIGokACAAC04BA38jAEEQayICJAAgACgCACEDIAAsAAshBCACIAEoAgAgASABLAALQQBIGzYCACADIAAgBEEASBtB69kEIAIQiQYhASAC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AkBBAkYNACACKAJIEAwgASACKAJINgIQIAEgAigCQEEBQYyOCSABQRBqEBE2AgwgAkE0aiEDIAFBEGogAUEMahDpBgJAIAIsAD9Bf0oNACADKAIAEOAQCyADIAEpAhA3AgAgA0EIaiABQRBqQQhqKAIANgIAIAFBADoAGyABQQA6ABAgASgCDBADCyACLAA/IQMgAigCNCEEIAFBIGokACAEIAJBNGogA0EASBsLVwECfyABKAIAEAwgACABKAIANgIAIAIoAgQgAi0ACyIBIAHAQQBIIgMbIgFBBGoQxBAiBCABNgIAIARBBGogAigCACACIAMbIAEQng8aIAAgBDYCCCAAC4ABAgJ/AXwjAEEQayIBJAAgAUEANgIIA0AgAUEEaiAAKAIIIAFBCGoQ8wwgASgCBEHs0gogAUEMahAIIQMgASgCDBAJIAAgASgCCGpBBGogA0QAAAAAAAAAAGI6AAAgASgCBBADIAEgASgCCEEBaiICNgIIIAJFDQALIAFBEGokAAtmAQJ/IwBBEGsiASQAIAFBADYCBANAIAAoAgghAiABIAAtAAQ2AgggAUHs0gogAUEIahACNgIAIAIgAUEEaiABEPQMIAEoAgAQAyABIAEoAgRBAWoiAjYCBCACRQ0ACyABQRBqJAALJQAgAEGwjglBCGo2AgACQCAAKAIIKAIAQQJGDQAgABDwDAsgAAsoACAAQbCOCUEIajYCAAJAIAAoAggoAgBBAkYNACAAEPAMCyAAEOAQCz8BAX8jAEEQayIDJAAgASgCACEBIAMgAigCADYCCCAAIAFB2NMKIANBCGoQAiICEAo2AgAgAhADIANBEGokAAs/AQF/IwBBEGsiAyQAIAAoAgAhACADIAEoAgA2AgggAEHY0wogA0EIahACIgEgAigCABAFIAEQAyADQRBqJAALUgECfyMAQRBrIgEkAEEAKALE5gshAiABIAA2AghB1PQIIAFBCGoQAiIAEAwgASAANgIIIAIoAkxBAUH47gggAUEIahAREAMgABADIAFBEGokAAuAAQICfwF8IwBBEGsiASQAIAFBADYCCANAIAFBBGogACgCCCABQQhqEPMMIAEoAgRB7NIKIAFBDGoQCCEDIAEoAgwQCSAAIAEoAghqQQRqIANEAAAAAAAAAABiOgAAIAEoAgQQAyABIAEoAghBAWoiAjYC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AgQQAyABIAEoAghBAWoiAjYCCCACQQJJDQALIAFBEGokAAt1AQN/IwBBEGsiASQAQQAhAiABQQA2AgQDQCAAKAIMIQMgASAAIAJBAnRqQQRqKAIANgIIIAFBtNMKIAFBCGoQAjYCACADIAFBBGogARD0DCABKAIAEAMgASABKAIEQQFqIgI2AgQgAkECSQ0ACyABQRBqJAALFQAgAEHQmAlBCGo2AgAgABCXDSAACxgAIABB0JgJQQhqNgIAIAAQlw0gABDgEAukAQIDfwF8IwBBEGsiASQAIAFBADYCCANAIAFBBGogACgCECABQQhqEPMMIAEoAgRBtNMKIAFBDGoQCCEEIAEoAgwQCSAAIAEoAghBAnRqQQRqIQICQAJAIASZRAAAAAAAAOBBY0UNACAEqiEDDAELQYCAgIB4IQMLIAIgAzYCACABKAIEEAMgASABKAIIQQFqIgI2AgggAkEDSQ0ACyABQRBqJAALdQEDfyMAQRBrIgEkAEEAIQIgAUEANgIEA0AgACgCECEDIAEgACACQQJ0akEEaigCADYCCCABQbTTCiABQQhqEAI2AgAgAyABQQRqIAEQ9AwgASgCABADIAEgASgCBEEBaiICNgIEIAJBA0kNAAsgAUEQaiQACxUAIABBiJkJQQhqNgIAIAAQmw0gAAsYACAAQYiZCUEIajYCACAAEJsNIAAQ4BALpAECA38BfCMAQRBrIgEkACABQQA2AggDQCABQQRqIAAoAhQgAUEIahDzDCABKAIEQbTTCiABQQxqEAghBCABKAIMEAkgACABKAIIQQJ0akEEaiECAkACQCAEmUQAAAAAAADgQWNFDQAgBKohAwwBC0GAgICAeCEDCyACIAM2AgAgASgCBBADIAEgASgCCEEBaiICNgIIIAJBBEkNAAsgAUEQaiQAC3UBA38jAEEQayIBJABBACECIAFBADYCBANAIAAoAhQhAyABIAAgAkECdGpBBGooAgA2AgggAUG00wogAUEIahACNgIAIAMgAUEEaiABEPQMIAEoAgAQAyABIAEoAgRBAWoiAjYCBCACQQRJDQALIAFBEGokAAsVACAAQcCZCUEIajYCACAAEJ8NIAALGAAgAEHAmQlBCGo2AgAgABCfDSAAEOAQC8oBAgJ/AXwjAEEQayICJAAgACABNgIMIABBADYCCCAAQgA3AgAgASgCAEHGhwUQBCIDEAohASADEAMgAUHY0wogAkEEahAIIQQgAigCBBAJAkACQCAERAAAAAAAAPBBYyAERAAAAAAAAAAAZnFFDQAgBKshAwwBC0EAIQMLIAAgAxC3DSABEAMgACgCBCEBIAIgACgCACIDNgIMIAIgASADazYCCEHQmgkgAkEIahACIgFB+bAEIAAoAgwQuA0gARADIAJBEGokACAAC1YCAX8BfCMAQRBrIgEkACAAKAIAQZDTCiABQQxqEAghAiABKAIMEAkCQAJAIAKZRAAAAAAAAOBBY0UNACACqiEADAELQYCAgIB4IQALIAFBEGokACAAC2QBBH8jAEEQayIBJAAgACgCDCECIAAoAgQhAyABIAAoAgAiBDYCDCABIAMgBGs2AgggAigCAEH5sAQgAUEIahC5DQJAIAAoAgAiAkUNACAAIAI2AgQgAhDgEAsgAUEQaiQAIAALygECAn8BfCMAQRBrIgIkACAAIAE2AgwgAEEANgIIIABCADcCACABKAIAQcaHBRAEIgMQCiEBIAMQAyABQdjTCiACQQRqEAghBCACKAIEEAkCQAJAIAREAAAAAAAA8EFjIAREAAAAAAAAAABmcUUNACAEqyEDDAELQQAhAwsgACADELoNIAEQAyAAKAIEIQEgAiAAKAIAIgM2AgwgAiABIANrNgIIQaiICSACQQhqEAIiAUH5sAQgACgCDBC4DSABEAMgAkEQaiQAIAALXgIBfwF8IwBBEGsiASQAIAAoAgBBhNMKIAFBDGoQCCECIAEoAgwQCQJAAkAgAkQAAAAAAADwQWMgAkQAAAAAAAAAAGZxRQ0AIAKrIQAMAQtBACEACyABQRBqJAAgAAtkAQR/IwBBEGsiASQAIAAoAgwhAiAAKAIEIQMgASAAKAIAIgQ2AgwgASADIARrNgIIIAIoAgBB+bAEIAFBCGoQuw0CQCAAKAIAIgJFDQAgACACNgIEIAIQ4BALIAFBEGokACAAC80BAgJ/AXwjAEEQayICJAAgACABNgIMIABBADYCCCAAQgA3AgAgASgCAEHGhwUQBCIDEAohASADEAMgAUHY0wogAkEEahAIIQQgAigCBBAJAkACQCAERAAAAAAAAPBBYyAERAAAAAAAAAAAZnFFDQAgBKshAwwBC0EAIQMLIAAgAxC8DSABEAMgACgCBCEBIAIgACgCACIDNgIMIAIgASADa0EBdTYCCEH4mwkgAkEIahACIgFB+bAEIAAoAgwQuA0gARADIAJBEGokACAAC1YCAX8BfCMAQRBrIgEkACAAKAIAQZzTCiABQQxqEAghAiABKAIMEAkCQAJAIAKZRAAAAAAAAOBBY0UNACACqiEADAELQYCAgIB4IQALIAFBEGokACAAC2cBBH8jAEEQayIBJAAgACgCDCECIAAoAgQhAyABIAAoAgAiBDYCDCABIAMgBGtBAXU2AgggAigCAEH5sAQgAUEIahC9DQJAIAAoAgAiAkUNACAAIAI2AgQgAhDgEAsgAUEQaiQAIAALzQECAn8BfCMAQRBrIgIkACAAIAE2AgwgAEEANgIIIABCADcCACABKAIAQcaHBRAEIgMQCiEBIAMQAyABQdjTCiACQQRqEAghBCACKAIEEAkCQAJAIAREAAAAAAAA8EFjIAREAAAAAAAAAABmcUUNACAEqyEDDAELQQAhAwsgACADEL4NIAEQAyAAKAIEIQEgAiAAKAIAIgM2AgwgAiABIANrQQF1NgIIQdycCSACQQhqEAIiAUH5sAQgACgCDBC4DSABEAMgAkEQaiQAIAALXgIBfwF8IwBBEGsiASQAIAAoAgBBqNMKIAFBDGoQCCECIAEoAgwQCQJAAkAgAkQAAAAAAADwQWMgAkQAAAAAAAAAAGZxRQ0AIAKrIQAMAQtBACEACyABQRBqJAAgAAtnAQR/IwBBEGsiASQAIAAoAgwhAiAAKAIEIQMgASAAKAIAIgQ2AgwgASADIARrQQF1NgIIIAIoAgBB+bAEIAFBCGoQvw0CQCAAKAIAIgJFDQAgACACNgIEIAIQ4BALIAFBEGokACAAC80BAgJ/AXwjAEEQayICJAAgACABNgIMIABBADYCCCAAQgA3AgAgASgCAEHGhwUQBCIDEAohASADEAMgAUHY0wogAkEEahAIIQQgAigCBBAJAkACQCAERAAAAAAAAPBBYyAERAAAAAAAAAAAZnFFDQAgBKshAwwBC0EAIQMLIAAgAxDADSABEAMgACgCBCEBIAIgACgCACIDNgIMIAIgASADa0ECdTYCCEHAnQkgAkEIahACIgFB+bAEIAAoAgwQuA0gARADIAJBEGokACAAC2cBBH8jAEEQayIBJAAgACgCDCECIAAoAgQhAyABIAAoAgAiBDYCDCABIAMgBGtBAnU2AgggAigCAEH5sAQgAUEIahDBDQJAIAAoAgAiAkUNACAAIAI2AgQgAhDgEAsgAUEQaiQAIAALzQECAn8BfCMAQRBrIgIkACAAIAE2AgwgAEEANgIIIABCADcCACABKAIAQcaHBRAEIgMQCiEBIAMQAyABQdjTCiACQQRqEAghBCACKAIEEAkCQAJAIAREAAAAAAAA8EFjIAREAAAAAAAAAABmcUUNACAEqyEDDAELQQAhAwsgACADEMINIAEQAyAAKAIEIQEgAiAAKAIAIgM2AgwgAiABIANrQQJ1NgIIQaSeCSACQQhqEAIiAUH5sAQgACgCDBC4DSABEAMgAkEQaiQAIAALZwEEfyMAQRBrIgEkACAAKAIMIQIgACgCBCEDIAEgACgCACIENgIMIAEgAyAEa0ECdTYCCCACKAIAQfmwBCABQQhqEMMNAkAgACgCACICRQ0AIAAgAjYCBCACEOAQCyABQRBqJAAgAAvNAQICfwF8IwBBEGsiAiQAIAAgATYCDCAAQQA2AgggAEIANwIAIAEoAgBBxocFEAQiAxAKIQEgAxADIAFB2NMKIAJBBGoQCCEEIAIoAgQQCQJAAkAgBEQAAAAAAADwQWMgBEQAAAAAAAAAAGZxRQ0AIASrIQMMAQtBACEDCyAAIAMQxA0gARADIAAoAgQhASACIAAoAgAiAzYCDCACIAEgA2tBAnU2AghBiJ8JIAJBCGoQAiIBQfmwBCAAKAIMELgNIAEQAyACQRBqJAAgAAtnAQR/IwBBEGsiASQAIAAoAgwhAiAAKAIEIQMgASAAKAIAIgQ2AgwgASADIARrQQJ1NgIIIAIoAgBB+bAEIAFBCGoQxQ0CQCAAKAIAIgJFDQAgACACNgIEIAIQ4BALIAFBEGokACAAC80BAgJ/AXwjAEEQayICJAAgACABNgIMIABBADYCCCAAQgA3AgAgASgCAEHGhwUQBCIDEAohASADEAMgAUHY0wogAkEEahAIIQQgAigCBBAJAkACQCAERAAAAAAAAPBBYyAERAAAAAAAAAAAZnFFDQAgBKshAwwBC0EAIQMLIAAgAxDGDSABEAMgACgCBCEBIAIgACgCACIDNgIMIAIgASADa0EDdTYCCEHsnwkgAkEIahACIgFB+bAEIAAoAgwQuA0gARADIAJBEGokACAAC1cCAX8BfCMAQRBrIgIkACAAIAE2AhAgAEH0nwlBCGo2AgACQCABKAIAIgFBAkYNACABQYjUCiACQQxqEAghAyACKAIMEAkgACADOQMICyACQRBqJAAgAAtnAQR/IwBBEGsiASQAIAAoAgwhAiAAKAIEIQMgASAAKAIAIgQ2AgwgASADIARrQQN1NgIIIAIoAgBB+bAEIAFBCGoQxw0CQCAAKAIAIgJFDQAgACACNgIEIAIQ4BALIAFBEGokACAACzoBAn8CQCAAKAIEIAAoAgAiAmsiAyABTw0AIAAgASADaxDIDQ8LAkAgAyABTQ0AIAAgAiABajYCBAsLZgECfyMAQRBrIgMkAAJAQQAtAPTnC0EBcQ0AQQJB2JoJEBUhBEEAQQE6APTnC0EAIAQ2AvDnCwtB8OcLKAIAIQQgAigCABAMIAMgAigCADYCCCAEIAAgASADQQhqEBYgA0EQaiQAC18BAn8jAEEQayIDJAACQEEALQD85wtBAXENAEECQZSbCRAVIQRBAEEBOgD85wtBACAENgL45wsLQfjnCygCACEEIAMgAikCADcDCCAEIAAgASADQQhqEBYgA0EQaiQACzoBAn8CQCAAKAIEIAAoAgAiAmsiAyABTw0AIAAgASADaxDLDQ8LAkAgAyABTQ0AIAAgAiABajYCBAsLXwECfyMAQRBrIgMkAAJAQQAtAIToC0EBcQ0AQQJB0JsJEBUhBEEAQQE6AIToC0EAIAQ2AoDoCwtBgOgLKAIAIQQgAyACKQIANwMIIAQgACABIANBCGoQFiADQRBqJAALQAECfwJAIAAoAgQgACgCACICa0EBdSIDIAFPDQAgACABIANrEM4NDwsCQCADIAFNDQAgACACIAFBAXRqNgIECwtfAQJ/IwBBEGsiAyQAAkBBAC0AjOgLQQFxDQBBAkG0nAkQFSEEQQBBAToAjOgLQQAgBDYCiOgLC0GI6AsoAgAhBCADIAIpAgA3AwggBCAAIAEgA0EIahAWIANBEGokAAtAAQJ/AkAgACgCBCAAKAIAIgJrQQF1IgMgAU8NACAAIAEgA2sQ0g0PCwJAIAMgAU0NACAAIAIgAUEBdGo2AgQLC18BAn8jAEEQayIDJAACQEEALQCU6AtBAXENAEECQZidCRAVIQRBAEEBOgCU6AtBACAENgKQ6AsLQZDoCygCACEEIAMgAikCADcDCCAEIAAgASADQQhqEBYgA0EQaiQAC0ABAn8CQCAAKAIEIAAoAgAiAmtBAnUiAyABTw0AIAAgASADaxDWDQ8LAkAgAyABTQ0AIAAgAiABQQJ0ajYCBAsLXwECfyMAQRBrIgMkAAJAQQAtAJzoC0EBcQ0AQQJB/J0JEBUhBEEAQQE6AJzoC0EAIAQ2ApjoCwtBmOgLKAIAIQQgAyACKQIANwMIIAQgACABIANBCGoQFiADQRBqJAALQAECfwJAIAAoAgQgACgCACICa0ECdSIDIAFPDQAgACABIANrENoNDwsCQCADIAFNDQAgACACIAFBAnRqNgIECwtfAQJ/IwBBEGsiAyQAAkBBAC0ApOgLQQFxDQBBAkHgngkQFSEEQQBBAToApOgLQQAgBDYCoOgLC0Gg6AsoAgAhBCADIAIpAgA3AwggBCAAIAEgA0EIahAWIANBEGokAAtAAQJ/AkAgACgCBCAAKAIAIgJrQQJ1IgMgAU8NACAAIAEgA2sQ3g0PCwJAIAMgAU0NACAAIAIgAUECdGo2AgQLC18BAn8jAEEQayIDJAACQEEALQCs6AtBAXENAEECQcSfCRAVIQRBAEEBOgCs6AtBACAENgKo6AsLQajoCygCACEEIAMgAikCADcDCCAEIAAgASADQQhqEBYgA0EQaiQAC0ABAn8CQCAAKAIEIAAoAgAiAmtBA3UiAyABTw0AIAAgASADaxDiDQ8LAkAgAyABTQ0AIAAgAiABQQN0ajYCBAsLXwECfyMAQRBrIgMkAAJAQQAtALToC0EBcQ0AQQJBqKAJEBUhBEEAQQE6ALToC0EAIAQ2ArDoCwtBsOgLKAIAIQQgAyACKQIANwMIIAQgACABIANBCGoQFiADQRBqJAALhgIBB38CQCAAKAIIIgIgACgCBCIDayABSQ0AAkAgAUUNACADQQAgARCgDyABaiEDCyAAIAM2AgQPCwJAIAMgACgCACIEayIFIAFqIgZBf0wNAEEAIQcCQCACIARrIgJBAXQiCCAGIAggBksbQf////8HIAJB/////wNJGyICRQ0AIAIQ3xAhBwsgByACaiEGIAcgBWoiAkEAIAEQoA8iBSABaiEBAkACQCADIARHDQAgBSEHDAELA0AgAkF/aiICIANBf2oiAy0AADoAACADIARHDQALIAAoAgAhAwsgACAGNgIIIAAgATYCBCAAIAc2AgACQCADRQ0AIAMQ4BALDwsgABDJDQALCgBB7doEEJUHAAsPACAAIAAoAggQow06AAQLhgIBB38CQCAAKAIIIgIgACgCBCIDayABSQ0AAkAgAUUNACADQQAgARCgDyABaiEDCyAAIAM2AgQPCwJAIAMgACgCACIEayIFIAFqIgZBf0wNAEEAIQcCQCACIARrIgJBAXQiCCAGIAggBksbQf////8HIAJB/////wNJGyICRQ0AIAIQ3xAhBwsgByACaiEGIAcgBWoiAkEAIAEQoA8iBSABaiEBAkACQCADIARHDQAgBSEHDAELA0AgAkF/aiICIANBf2oiAy0AADoAACADIARHDQALIAAoAgAhAwsgACAGNgIIIAAgATYCBCAAIAc2AgACQCADRQ0AIAMQ4BALDwsgABDMDQALCgBB7doEEJUHAAsPACAAIAAoAggQpg06AAQLlwMBB38jAEEgayICJAACQAJAAkAgACgCCCIDIAAoAgQiBGtBAXUgAUkNAAJAIAFFDQAgBEEAIAFBAXQiARCgDyABaiEECyAAIAQ2AgQMAQsgBCAAKAIAIgVrQQF1IgYgAWoiBEF/TA0BIAJBDGogAyAFayIDIAQgAyAESxtB/////wcgA0H+////B0kbIAYgAEEIahDPDSIFKAIIQQAgAUEBdCIBEKAPIAFqIQcgBSgCBCEEAkACQCAAKAIEIgYgACgCACIDRiIIDQAgBiEBA0AgBEF+aiIEIAFBfmoiAS8BADsBACABIANHDQALIAAgBDYCACAFIAM2AgQgACAHNgIEIAUgBjYCCCAAKAIIIQEgACAFKAIMNgIIIAUgAzYCACAFIAE2AgwgCA0BIAUgBiADIAZrQQFqQX5xajYCCAwBCyAAIAQ2AgAgBSADNgIEIAAgBzYCBCAFIAY2AgggACgCCCEBIAAgBSgCDDYCCCAFIAM2AgAgBSABNgIMCyADRQ0AIAMQ4BALIAJBIGokAA8LIAAQ0A0AC2YBAX9BACEEIABBADYCDCAAQRBqIAM2AgACQAJAIAFFDQAgAUF/TA0BIAFBAXQQ3xAhBAsgACAENgIAIAAgBCACQQF0aiIDNgIIIAAgBCABQQF0ajYCDCAAIAM2AgQgAA8LEJcHAAsKAEHt2gQQlQcACw8AIAAgACgCCBCpDTsBBAuXAwEHfyMAQSBrIgIkAAJAAkACQCAAKAIIIgMgACgCBCIEa0EBdSABSQ0AAkAgAUUNACAEQQAgAUEBdCIBEKAPIAFqIQQLIAAgBDYCBAwBCyAEIAAoAgAiBWtBAXUiBiABaiIEQX9MDQEgAkEMaiADIAVrIgMgBCADIARLG0H/////ByADQf7///8HSRsgBiAAQQhqENMNIgUoAghBACABQQF0IgEQoA8gAWohByAFKAIEIQQCQAJAIAAoAgQiBiAAKAIAIgNGIggNACAGIQEDQCAEQX5qIgQgAUF+aiIBLwEAOwEAIAEgA0cNAAsgACAENgIAIAUgAzYCBCAAIAc2AgQgBSAGNgIIIAAoAgghASAAIAUoAgw2AgggBSADNgIAIAUgATYCDCAIDQEgBSAGIAMgBmtBAWpBfnFqNgIIDAELIAAgBDYCACAFIAM2AgQgACAHNgIEIAUgBjYCCCAAKAIIIQEgACAFKAIMNgIIIAUgAzYCACAFIAE2AgwLIANFDQAgAxDgEAsgAkEgaiQADwsgABDUDQALZgEBf0EAIQQgAEEANgIMIABBEGogAzYCAAJAAkAgAUUNACABQX9MDQEgAUEBdBDfECEECyAAIAQ2AgAgACAEIAJBAXRqIgM2AgggACAEIAFBAXRqNgIMIAAgAzYCBCAADwsQlwcACwoAQe3aBBCVBwALDwAgACAAKAIIEKwNOwEEC6ADAQd/IwBBIGsiAiQAAkACQAJAIAAoAggiAyAAKAIEIgRrQQJ1IAFJDQACQCABRQ0AIARBACABQQJ0IgEQoA8gAWohBAsgACAENgIEDAELIAQgACgCACIFa0ECdSIGIAFqIgRBgICAgARPDQEgAkEMaiADIAVrIgNBAXUiBSAEIAUgBEsbQf////8DIANB/P///wdJGyAGIABBCGoQ1w0iBSgCCEEAIAFBAnQiARCgDyABaiEHIAUoAgQhBAJAAkAgACgCBCIGIAAoAgAiA0YiCA0AIAYhAQNAIARBfGoiBCABQXxqIgEoAgA2AgAgASADRw0ACyAAIAQ2AgAgBSADNgIEIAAgBzYCBCAFIAY2AgggACgCCCEBIAAgBSgCDDYCCCAFIAM2AgAgBSABNgIMIAgNASAFIAYgAyAGa0EDakF8cWo2AggMAQsgACAENgIAIAUgAzYCBCAAIAc2AgQgBSAGNgIIIAAoAgghASAAIAUoAgw2AgggBSADNgIAIAUgATYCDAsgA0UNACADEOAQCyACQSBqJAAPCyAAENgNAAtqAQF/QQAhBCAAQQA2AgwgAEEQaiADNgIAAkACQCABRQ0AIAFBgICAgARPDQEgAUECdBDfECEECyAAIAQ2AgAgACAEIAJBAnRqIgM2AgggACAEIAFBAnRqNgIMIAAgAzYCBCAADwsQlwcACwoAQe3aBBCVBwALXgICfwF8IwBBEGsiASQAIAAoAggoAgBBtNMKIAFBDGoQCCEDIAEoAgwQCQJAAkAgA5lEAAAAAAAA4EFjRQ0AIAOqIQIMAQtBgICAgHghAgsgACACNgIEIAFBEGokAAugAwEHfyMAQSBrIgIkAAJAAkACQCAAKAIIIgMgACgCBCIEa0ECdSABSQ0AAkAgAUUNACAEQQAgAUECdCIBEKAPIAFqIQQLIAAgBDYCBAwBCyAEIAAoAgAiBWtBAnUiBiABaiIEQYCAgIAETw0BIAJBDGogAyAFayIDQQF1IgUgBCAFIARLG0H/////AyADQfz///8HSRsgBiAAQQhqENsNIgUoAghBACABQQJ0IgEQoA8gAWohByAFKAIEIQQCQAJAIAAoAgQiBiAAKAIAIgNGIggNACAGIQEDQCAEQXxqIgQgAUF8aiIBKAIANgIAIAEgA0cNAAsgACAENgIAIAUgAzYCBCAAIAc2AgQgBSAGNgIIIAAoAgghASAAIAUoAgw2AgggBSADNgIAIAUgATYCDCAIDQEgBSAGIAMgBmtBA2pBfHFqNgIIDAELIAAgBDYCACAFIAM2AgQgACAHNgIEIAUgBjYCCCAAKAIIIQEgACAFKAIMNgIIIAUgAzYCACAFIAE2AgwLIANFDQAgAxDgEAsgAkEgaiQADwsgABDcDQALagEBf0EAIQQgAEEANgIMIABBEGogAzYCAAJAAkAgAUUNACABQYCAgIAETw0BIAFBAnQQ3xAhBAsgACAENgIAIAAgBCACQQJ0aiIDNgIIIAAgBCABQQJ0ajYCDCAAIAM2AgQgAA8LEJcHAAsKAEHt2gQQlQcAC2YCAn8BfCMAQRBrIgEkACAAKAIIKAIAQcDTCiABQQxqEAghAyABKAIMEAkCQAJAIANEAAAAAAAA8EFjIANEAAAAAAAAAABmcUUNACADqyECDAELQQAhAgsgACACNgIEIAFBEGokAAugAwEHfyMAQSBrIgIkAAJAAkACQCAAKAIIIgMgACgCBCIEa0ECdSABSQ0AAkAgAUUNACAEQQAgAUECdCIBEKAPIAFqIQQLIAAgBDYCBAwBCyAEIAAoAgAiBWtBAnUiBiABaiIEQYCAgIAETw0BIAJBDGogAyAFayIDQQF1IgUgBCAFIARLG0H/////AyADQfz///8HSRsgBiAAQQhqEN8NIgUoAghBACABQQJ0IgEQoA8gAWohByAFKAIEIQQCQAJAIAAoAgQiBiAAKAIAIgNGIggNACAGIQEDQCAEQXxqIgQgAUF8aiIBKgIAOAIAIAEgA0cNAAsgACAENgIAIAUgAzYCBCAAIAc2AgQgBSAGNgIIIAAoAgghASAAIAUoAgw2AgggBSADNgIAIAUgATYCDCAIDQEgBSAGIAMgBmtBA2pBfHFqNgIIDAELIAAgBDYCACAFIAM2AgQgACAHNgIEIAUgBjYCCCAAKAIIIQEgACAFKAIMNgIIIAUgAzYCACAFIAE2AgwLIANFDQAgAxDgEAsgAkEgaiQADwsgABDgDQALagEBf0EAIQQgAEEANgIMIABBEGogAzYCAAJAAkAgAUUNACABQYCAgIAETw0BIAFBAnQQ3xAhBAsgACAENgIAIAAgBCACQQJ0aiIDNgIIIAAgBCABQQJ0ajYCDCAAIAM2AgQgAA8LEJcHAAsKAEHt2gQQlQcACw8AIAAgACgCCBDcBjgCBAugAwEHfyMAQSBrIgIkAAJAAkACQCAAKAIIIgMgACgCBCIEa0EDdSABSQ0AAkAgAUUNACAEQQAgAUEDdCIBEKAPIAFqIQQLIAAgBDYCBAwBCyAEIAAoAgAiBWtBA3UiBiABaiIEQYCAgIACTw0BIAJBDGogAyAFayIDQQJ1IgUgBCAFIARLG0H/////ASADQfj///8HSRsgBiAAQQhqEOMNIgUoAghBACABQQN0IgEQoA8gAWohByAFKAIEIQQCQAJAIAAoAgQiBiAAKAIAIgNGIggNACAGIQEDQCAEQXhqIgQgAUF4aiIBKwMAOQMAIAEgA0cNAAsgACAENgIAIAUgAzYCBCAAIAc2AgQgBSAGNgIIIAAoAgghASAAIAUoAgw2AgggBSADNgIAIAUgATYCDCAIDQEgBSAGIAMgBmtBB2pBeHFqNgIIDAELIAAgBDYCACAFIAM2AgQgACAHNgIEIAUgBjYCCCAAKAIIIQEgACAFKAIMNgIIIAUgAzYCACAFIAE2AgwLIANFDQAgAxDgEAsgAkEgaiQADwsgABDkDQALagEBf0EAIQQgAEEANgIMIABBEGogAzYCAAJAAkAgAUUNACABQYCAgIACTw0BIAFBA3QQ3xAhBAsgACAENgIAIAAgBCACQQN0aiIDNgIIIAAgBCABQQN0ajYCDCAAIAM2AgQgAA8LEJcHAAsKAEHt2gQQlQcACzkCAX8BfCMAQRBrIgEkACAAKAIQKAIAQYjUCiABQQxqEAghAiABKAIMEAkgACACOQMIIAFBEGokAAuTAQICfwF8IwBBEGsiASQAQQAoAsTmCyECIAEgADYCCEHI8gggAUEIahACIgAQDCABIAA2AgggAigCeEEBQfjuCCABQQhqEBEiAkG00wogAUEIahAIIQMgASgCCBAJIAIQAyAAEAMCQAJAIAOZRAAAAAAAAOBBY0UNACADqiEADAELQYCAgIB4IQALIAFBEGokACAAC1ABAX8jAEEQayIDJAAgACgCACEAIAMgASgCADYCCCAAQbTTCiADQQhqEAIiASADQQRqIAIQ6A0iAigCABAFIAIoAgAQAyABEAMgA0EQaiQAC2YBBH8jAEEQayICJAAgASgCBCABLQALIgMgA8BBAEgiBBsiA0EEahDEECIFIAM2AgAgBUEEaiABKAIAIAEgBBsgAxCeDxogAiAFNgIIIABB0PMIIAJBCGoQAjYCACACQRBqJAAgAAuTAQICfwF8IwBBEGsiASQAQQAoAsTmCyECIAEgADYCCEHI8gggAUEIahACIgAQDCABIAA2AgggAigCfEEBQfjuCCABQQhqEBEiAkG00wogAUEIahAIIQMgASgCCBAJIAIQAyAAEAMCQAJAIAOZRAAAAAAAAOBBY0UNACADqiEADAELQYCAgIB4IQALIAFBEGokACAAC5MBAgJ/AXwjAEEQayIBJABBACgCxOYLIQIgASAANgIIQcjyCCABQQhqEAIiABAMIAEgADYCCCACKAJ4QQFB+O4IIAFBCGoQESICQbTTCiABQQhqEAghAyABKAIIEAkgAhADIAAQAwJAAkAgA5lEAAAAAAAA4EFjRQ0AIAOqIQAMAQtBgICAgHghAAsgAUEQaiQAIAALeQICfwF8IwBBEGsiASQAIAFBADYCCANAIAFBBGogACgCECABQQhqEPMMIAEoAgRBiNQKIAFBDGoQCCEDIAEoAgwQCSAAIAEoAghBA3RqQQhqIAM5AwAgASgCBBADIAEgASgCCEEBaiICNgIIIAJFDQALIAFBEGokAAtmAQJ/IwBBEGsiASQAIAFBADYCBANAIAAoAhAhAiABIAArAwg5AwggAUGI1AogAUEIahACNgIAIAIgAUEEaiABEPQMIAEoAgAQAyABIAEoAgRBAWoiAjYCBCACRQ0ACyABQRBqJAALFQAgAEGIowlBCGo2AgAgABDsDSAACxgAIABBiKMJQQhqNgIAIAAQ7A0gABDgEAtsAgJ/AX0jAEEQayIBJAAgAUEANgIMA0AgAUEIaiAAKAIUIAFBDGoQ8wwgAUEIahDcBiEDIAAgASgCDEECdGpBBGogAzgCACABKAIIEAMgASABKAIMQQFqIgI2AgwgAkEESQ0ACyABQRBqJAALdQEDfyMAQRBrIgEkAEEAIQIgAUEANgIEA0AgACgCFCEDIAEgACACQQJ0akEEaioCADgCCCABQfzTCiABQQhqEAI2AgAgAyABQQRqIAEQ9AwgASgCABADIAEgASgCBEEBaiICNgIEIAJBBEkNAAsgAUEQaiQACyUAIABB1KMJQQhqNgIAAkAgACgCFCgCAEECRg0AIAAQ8A0LIAALKAAgAEHUowlBCGo2AgACQCAAKAIUKAIAQQJGDQAgABDwDQsgABDgEAvIAQEDfyMAQSBrIgMkACADIAE2AhxBACEEAkAgAUEASA0AQQAoAsTmCyIFKAKEASABSA0AIANBDGogBUGAAWogA0EcahC5CCAFQYgBaiEBIANBEGogA0EMahDpBgJAIAUsAJMBQX9KDQAgASgCABDgEAsgASADKQIQNwIAIAFBCGogA0EQakEIaigCADYCACADQQA6ABsgA0EAOgAQIAMoAgwQAyACIAUoAogBIAEgBSwAkwFBAEgbNgIAQQEhBAsgA0EgaiQAIAQLtwMCBH8BfCMAQTBrIgMkAEEAIQQCQCABQQBIDQBBACgCxOYLIgUoApwBIAFIDQAgBUGgAWohBAJAAkAgBSwAqwFBf0oNACAFQaQBakEANgIAIAUoAqABIQYMAQsgBUEAOgCrASAEIQYLIAZBADoAACADEBQ2AhQgA0EANgIYIANBFGogA0EYaiADQRBqIAQQhA0iBhCFDSAGKAIAEAMgAyABNgIYQbTTCiADQRhqEAIhASAFKAKYARAMIAMgBSgCmAE2AhggARAMIAMgATYCICADKAIUEAwgAyADKAIUNgIoIAUoApQBQQNB2JUJIANBGGoQESEGIAEQAyADQQA2AgwgA0EQaiADQRRqIANBDGoQuQggA0EYaiADQRBqEOkGAkAgBSwAqwFBf0oNACAEKAIAEOAQCyAEIAMpAhg3AgAgBEEIaiADQRhqQQhqKAIANgIAIANBADoAIyADQQA6ABggAygCEBADIAIgBSgCoAEgBCAFLACrAUEASBs2AgAgBkHs0gogA0EYahAIIQcgAygCGBAJIAYQAyADKAIUEAMgB0QAAAAAAAAAAGIhBAsgA0EwaiQAIAQLaQICfwF9IwBBEGsiAiQAQQAoAsTmCyEDIAIgATYCCCACQbTTCiACQQhqEAI2AgQgAkEIaiADQdAAaiADQdQAaiACQQRqEPYNIAJBCGoQ3AYhBCACKAIIEAMgAigCBBADIAJBEGokACAEC0oBAX8jAEEQayIEJAAgAigCABAMIAQgAigCADYCACADKAIAEAwgBCADKAIANgIIIAAgASgCAEECQdSlCSAEEBE2AgAgBEEQaiQAC2kCAn8BfSMAQRBrIgIkAEEAKALE5gshAyACIAE2AgggAkG00wogAkEIahACNgIEIAJBCGogA0HYAGogA0HcAGogAkEEahD2DSACQQhqENwGIQQgAigCCBADIAIoAgQQAyACQRBqJAAgBAs0AQJ/IwBBEGsiASQAIAAoAgwhAiABQgA3AwggACACIAFBCGoQ3QYpAwA3AgQgAUEQaiQAC6IBAgJ/AXwjAEEQayICJABBACgCxOYLIQMgAiAANgIIIAJB2NMKIAJBCGoQAjYCACACQQRqIANBrAFqIAIgA0G0AWoQ+w0gAigCBEHM0gogAkEIahAIIQQgAigCCBAJIAIoAgQQAyACKAIAEAMCQAJAIAREAAAAAAAA8EFjIAREAAAAAAAAAABmcUUNACAEqyEDDAELQQAhAwsgAkEQaiQAIAMLWwECfyMAQRBrIgIkAEEAKALE5gshAyACIAA2AgggAkHM0gogAkEIahACNgIEIAJBCGogA0GwAWogAkEEaiADQbQBahD7DSACKAIIEAMgAigCBBADIAJBEGokAAtKAQF/IwBBEGsiBCQAIAIoAgAQDCAEIAIoAgA2AgAgAygCABAMIAQgAygCADYCCCAAIAEoAgBBAkGArAkgBBARNgIAIARBEGokAAuKAQEBf0GYrAlBrKwJQcisCUEAQZjvCEHZBkGE8AhBAEGE8AhBAEH1swRBhvAIQdoGEAdBBBDfECIAQdsGNgIAQZisCUHY+QRBkO8IQYjzCEHcBiAAQQBBAEEAQQAQDUEEEN8QIgBB3QY2AgBBmKwJQbaKBEGQ7whBiPMIQdwGIABBAEEAQQBBABANCwYAQZisCQsPAAJAIABFDQAgABDgEAsLKwEBfyMAQRBrIgIkACACIAE2AgggAEHE8AggAkEIahACNgIAIAJBEGokAAs1AQF/IwBBEGsiAiQAIAJBDGogASAAKAIAEQAAIAIoAgwQDCACKAIMIgAQAyACQRBqJAAgAAsuAQF/IwBBEGsiAiQAIAIgAUEIajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQAC5YCAQJ/QfCsCUGQrQlBuK0JQQBBmO8IQd4GQYTwCEEAQYTwCEEAQc65BUGG8AhB3wYQB0EEEN8QIgBBADYCAEEEEN8QIgFBADYCAEHwrAlBpI8GQcDTCkGI8whB4AYgAEHA0wpBjPMIQeEGIAEQDUEEEN8QIgBB8Bw2AgBBBBDfECIBQfAcNgIAQfCsCUGKzARBtNMKQYjzCEHiBiAAQbTTCkGM8whB4wYgARANQQQQ3xAiAEHkBjYCAEHwrAlBtJEGQZDvCEGI8whB5QYgAEEAQQBBAEEAEA1BBBDfECIAQeYGNgIAQQQQ3xAiAUHnBjYCAEHwrAlB25kEQZDvCEGI8whB5QYgAEGQ7whBjPMIQegGIAEQDQsGAEHwrAkLTQEBfwJAIABFDQACQCAAQSxqKAIAIgFFDQAgARA+CwJAIABBIGooAgAiAUUNACABED4LAkAgAEEUaigCACIBRQ0AIAEQPgsgABDgEAsLDQAgASAAKAIAaigCAAsPACABIAAoAgBqIAI2AgALDQAgASAAKAIAaigCAAsPACABIAAoAgBqIAI2AgALLwEBfyMAQRBrIgIkACACIAFBgB1qNgIIIABByKwJIAJBCGoQAjYCACACQRBqJAALNQEBfyMAQRBrIgIkACACQQxqIAEgACgCABEAACACKAIMEAwgAigCDCIAEAMgAkEQaiQAIAALQQEBfyMAQRBrIgIkACAAIAJBBGogAUEsaigCABCSByIBEIQNGgJAIAEsAAtBf0oNACABKAIAEOAQCyACQRBqJAAL3wIBB38jAEEQayICJAAgACgCDCEDIAJBBGogARDpBiADQX9qIQQCQCAAQRxqKAIAIgUgAigCCCIGIAItAA8iASABwCIHQQBIG0EBaiIDTg0AAkACQCAFDQBBCCEIDAELIAVBAm0gBWohCAsgBSAIIAMgCCADShsiCE4NACAIEDwhAQJAIABBIGooAgAiBUUNACABIAUgACgCGBCeDxogACgCIBA+CyAAIAg2AhwgACABNgIgIAIoAgghBiACLQAPIgEhBwsgACADNgIYIABBIGooAgAgAigCBCACQQRqIAfAQQBIIgMbIAYgASADG0EBahCeDxogACACKAIIIAItAA8iASABwEEASCIBGyIDNgIIIABBFGooAgAgBCACKAIEIAJBBGogARsiASABIANqQQAQSCEBIABBAToA7xwgACABNgIEAkAgAiwAD0F/Sg0AIAIoAgQQ4BALIAJBEGokAAs1AQF/IwBBEGsiAyQAIAAoAgAhACADIAI2AgwgASADQQxqIAARAAAgAygCDBADIANBEGokAAvLDQECf0HYrQlB8K0JQZCuCUEAQZjvCEHpBkGE8AhBAEGE8AhBAEH9kARBhvAIQeoGEAdBBBDfECIAQQQ2AgBBBBDfECIBQQQ2AgBB2K0JQaSPBkHA0wpBiPMIQesGIABBwNMKQYzzCEHsBiABEA1BBBDfECIAQQg2AgBBBBDfECIBQQg2AgBB2K0JQYrMBEG00wpBiPMIQe0GIABBtNMKQYzzCEHuBiABEA1BBBDfECIAQe8GNgIAQditCUHZwwRBkO8IQYjzCEHwBiAAQQBBAEEAQQAQDUEEEN8QIgBB8QY2AgBB2K0JQa21BUGQ7whBiPMIQfAGIABBAEEAQQBBABANQQQQ3xAiAEHyBjYCAEHYrQlB0v8EQZDvCEGI8whB8AYgAEEAQQBBAEEAEA1BBBDfECIAQfMGNgIAQditCUGDrQVBkO8IQYjzCEHwBiAAQQBBAEEAQQAQDUEEEN8QIgBB9AY2AgBB2K0JQe+DBUGQ7whBiPMIQfAGIABBAEEAQQBBABANQQQQ3xAiAEH1BjYCAEHYrQlB06oEQZDvCEGI8whB8AYgAEEAQQBBAEEAEA1BBBDfECIAQfYGNgIAQditCUGJlwVBkO8IQYjzCEHwBiAAQQBBAEEAQQAQDUEEEN8QIgBB9wY2AgBB2K0JQdGzBEGQ7whBiPMIQfAGIABBAEEAQQBBABANQQQQ3xAiAEH4BjYCAEHYrQlBg7QEQZDvCEGI8whB8AYgAEEAQQBBAEEAEA1BBBDfECIAQfkGNgIAQditCUG7sgRBkO8IQYjzCEHwBiAAQQBBAEEAQQAQDUEEEN8QIgBBxAA2AgBBBBDfECIBQcQANgIAQditCUGllQVB/NMKQdTwCEH6BiAAQfzTCkHY8AhB+wYgARANQQQQ3xAiAEHIADYCAEEEEN8QIgFByAA2AgBB2K0JQbetBUH80wpB1PAIQfoGIABB/NMKQdjwCEH7BiABEA1BBBDfECIAQfwGNgIAQditCUGFgAVBkO8IQYjzCEHwBiAAQQBBAEEAQQAQDUEEEN8QIgBB/QY2AgBB2K0JQbCKBEGQ7whBiPMIQfAGIABBAEEAQQBBABANQQQQ3xAiAEH+BjYCAEHYrQlB6rEEQZDvCEGI8whB8AYgAEEAQQBBAEEAEA1BBBDfECIAQf8GNgIAQditCUHm7QRBkO8IQYjzCEHwBiAAQQBBAEEAQQAQDUEEEN8QIgBBgAc2AgBB2K0JQYygBEGQ7whBiPMIQfAGIABBAEEAQQBBABANQQQQ3xAiAEGBBzYCAEHYrQlBkMwEQZDvCEGI8whB8AYgAEEAQQBBAEEAEA1BBBDfECIAQYgBNgIAQQQQ3xAiAUGIATYCAEHYrQlB8/wFQezSCkGI8whBggcgAEHs0gpBjPMIQYMHIAEQDUEEEN8QIgBBiQE2AgBBBBDfECIBQYkBNgIAQditCUG7+gVB7NIKQYjzCEGCByAAQezSCkGM8whBgwcgARANQQQQ3xAiAEGKATYCAEEEEN8QIgFBigE2AgBB2K0JQZi4BUHs0gpBiPMIQYIHIABB7NIKQYzzCEGDByABEA1BBBDfECIAQYsBNgIAQQQQ3xAiAUGLATYCAEHYrQlBgLYFQezSCkGI8whBggcgAEHs0gpBjPMIQYMHIAEQDUEEEN8QIgBB5AQ2AgBBBBDfECIBQeQENgIAQditCUHLqQRB/NMKQdTwCEH6BiAAQfzTCkHY8AhB+wYgARANQQQQ3xAiAEGEBzYCAEHYrQlB348EQZDvCEGI8whB8AYgAEEAQQBBAEEAEA1BBBDfECIAQYUHNgIAQditCUHljgRBkO8IQYjzCEHwBiAAQQBBAEEAQQAQDUEEEN8QIgBBhgc2AgBB2K0JQcqrBEGQ7whBiPMIQfAGIABBAEEAQQBBABANQQQQ3xAiAEGHBzYCAEHYrQlB9pQEQZDvCEGI8whB8AYgAEEAQQBBAEEAEA1B8I4EQQFB+O4IQZjvCEEYQYgHQQAQBkH4kQRBAUH47ghBmO8IQRhBiQdBABAGQa6OBEEBQfjuCEGY7whBGEGKB0EAEAZBiZEEQQFB+O4IQZjvCEEYQYsHQQAQBkG75wVBAUH47ghBmO8IQRhBjAdBABAGQc/GBUEBQfjuCEGY7whBGEGNB0EAEAZB1OYFQQFB+O4IQZjvCEEYQY4HQQAQBkG2xgVBAUH47ghBmO8IQRhBjwdBABAGQcjmBUECQcSuCUGg9ghBkAdBkQdBABAGQby5BUECQcyuCUGI8whBkgdBkwdBABAGQbnmBUEBQfjuCEGY7whBGEGUB0EAEAYLBgBB2K0JCxIAAkAgAEUNACAAEIEBEOAQCwsNACABIAAoAgBqKAIACw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACw8AIAEgACgCAGogAjYCAAsuAQF/IwBBEGsiAiQAIAIgAUEMajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACzUBAX8jAEEQayICJAAgAkEMaiABIAAoAgARAAAgAigCDBAMIAIoAgwiABADIAJBEGokACAACy4BAX8jAEEQayICJAAgAiABQRRqNgIIIABBxPAIIAJBCGoQAjYCACACQRBqJAALLgEBfyMAQRBrIgIkACACIAFBHGo2AgggAEHE8AggAkEIahACNgIAIAJBEGokAAsuAQF/IwBBEGsiAiQAIAIgAUEkajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy4BAX8jAEEQayICJAAgAiABQSxqNgIIIABBxPAIIAJBCGoQAjYCACACQRBqJAALLgEBfyMAQRBrIgIkACACIAFBNGo2AgggAEHE8AggAkEIahACNgIAIAJBEGokAAsuAQF/IwBBEGsiAiQAIAIgAUE8ajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQbQEajYCCCAAQcisCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQZQEajYCCCAAQcisCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQfQDajYCCCAAQcisCSACQQhqEAI2AgAgAkEQaiQACw0AIAEgACgCAGoqAgALDwAgASAAKAIAaiACOAIACy8BAX8jAEEQayICJAAgAiABQdgAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQeAAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQegAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQfAAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQfgAajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQYABajYCCCAAQcTwCCACQQhqEAI2AgAgAkEQaiQACw0AIAEgACgCAGotAAALDwAgASAAKAIAaiACOgAACy8BAX8jAEEQayICJAAgAiABQZwGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQaAGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQaQGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACy8BAX8jAEEQayICJAAgAiABQagGajYCCCAAQbSuCSACQQhqEAI2AgAgAkEQaiQACzABAX8jAEEQayIBJAAgARCdASgC7DQ2AgggAEHwrQkgAUEIahACNgIAIAFBEGokAAswAQF/IwBBEGsiASQAIAEQnQEoAvA0NgIIIABB8K0JIAFBCGoQAjYCACABQRBqJAALMAEBfyMAQRBrIgEkACABEJ0BKAL0NDYCCCAAQfCtCSABQQhqEAI2AgAgAUEQaiQACzABAX8jAEEQayIBJAAgARCdASgC0DU2AgggAEHwrQkgAUEIahACNgIAIAFBEGokAAswAQF/IwBBEGsiASQAIAEQnQEoApA1NgIIIABBwNMKIAFB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AgA2AgBB95oIIAEQ3gRBACAAQQhqIgIQbUGAswdBABDkBEEBEG4gAUKAgKCWBDcCCAJAQYyDBCABQQhqEOwERQ0AIABBAToABgtDAAAAAEMAAIC/EOoCIAFCgICglgQ3AggCQEGpuAUgAUEIahDsBEUNACAAQQA6AAYLQd3cBCACQQAQ/wUaEO4BIAFBEGokAAsXAQF/AkBBACgCxI8MIgFFDQAgARA+CwuIBgEDfyAAQYACakEAQSQQoA8aIABBqAJqQZbcCBBXGiAAEIEPIABBAEGAAhCgDyIAQX82AqQCAkAgACgCjAIiASAAQZACaigCAEcNACABQQFqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiABQQJ0akHthQY2AgAgACAAKAKMAiICQQFqIgE2AowCAkAgASAAKAKQAkcNACACQQJqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiABQQJ0akG1+wU2AgAgACAAKAKMAiICQQFqIgE2AowCAkAgASAAKAKQAkcNACACQQJqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiABQQJ0akHnhQY2AgAgACAAKAKMAiICQQFqIgE2AowCAkAgASAAKAKQAkcNACACQQJqIQICQAJAIAENAEEIIQMMAQsgAUECbSABaiEDCyABIAMgAiADIAJKGyICTg0AIAJBAnQQPCEBAkAgACgClAIiA0UNACABIAMgACgCjAJBAnQQng8aIAAoApQCED4LIAAgAjYCkAIgACABNgKUAiAAKAKMAiEBCyAAKAKUAiAB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ADYCnAcgAEEBNgKYByAAQTI2ApQHIABBgICAgHw2ApAHIABB/////wM2AowHIABBm////wM2AogHIABB/////wM2AoQHIABBADYCgAcgAEEBNgL8BiAAQTI2AvgGIABBADYC9AYgAEH/////BzYC8AYgAEGb////BzYC7AYgAEH/////BzYC6AYgAEIANwOQCCAAQgE3A+AIIABCMjcDgAkgAEKAgICAgICAgEA3A/gIIABC//////////8/NwPwCCAAQpv/////////PzcD2AggAEL//////////z83A9AIIABCADcDyAggAEIBNwPgBiAAQjI3A9gGIABCADcD0AYgAEL///////////8ANwPIBiAAQpv//////////wA3A8AGIABC////////////ADcDuAYgAEEANgK0BiAAQYCAgPwDNgKwBiAAQfmF1IB9NgKsBiAAQfmF1IAFNgKoBiAAQgA3A6AGIABCgICAgICAgPg/NwOYBiAAQoCA0LHS/pqGQzcDkAYgAEKAgNCx0v6ahsMANwOIBkGMnAZBABDeBEG8tAZBvIEMEPkEGkMAAAAAQwAAgL8Q6gJBhpoHEMsOQYKiBkEAQdzcC0PNzEw+IABBvwdqQQBBAC0AvIEMIgIbIABBvQdqQQAgAhtBAEEAELAFGkHxoQZBAUHd3AtDzcxMPiAAQboHakEAQQAtALyBDCICGyAAQbgHakEAIAIbQcjGBEEAELAFGkGyowZBAkHe3AtDzcxMPiAAQbQHakEAQQAtALyBDCICGyAAQbAHakEAIAIbQQBBABCwBRpBn6MGQQNB4NwLQ83MTD4gAEGqB2pBAEEALQC8gQwiAhsgAEGmB2pBACACG0HIxgRBABCwBRpBm6oGQQRB5NwLQ83MTD4gAEGcB2pBAEEALQC8gQwiAhsgAEGUB2pBACACG0EAQQAQsAUaQYiqBkEFQejcC0PNzEw+IABBgAdqQQBBAC0AvIEMIgIbIABB+AZqQQAgAhtByMYEQQAQsAUaQcelBkEGQfDcC0PNzEw+IABBkAhqQQBBAC0AvIEMIgIbIABBgAlqQQAgAhtBAEEAELAFGkG0pQZBB0H43AtDzcxMPiAAQcgIakEAQQAtALyBDCICGyAAQdgGakEAIAIbQQBBABCwBRpB6LQEQQhBgN0LQwrXozsgAEG0BmogAEGwBmpB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AgAgAEEVakIANwAAIABBEGpCADcCACAAQQhqIgFCADcCACAAQSBqQQBBlAgQoA8aIAFCgIKAgIAINwIAIAALiwEBA38CQCAAKAKoCCIBQQFIDQBBACECA0ACQCAAKAKwCCACQQJ0aigCACIDRQ0AIAMQ+Q4aIAMQPiAAKAKoCCEBCyACQQFqIgIgAUgNAAsLAkAgAEGwCGooAgAiAkUNACAAQgA3AqgIIAIQPiAAQQA2ArAICwJAIABBGGooAgAiAkUNACACED4LIAAL7gMCBH8BfSMAQYABayICJABBgAIQPCIDEPgOGiADEPMOIANBATsB0AEgA0HYAGohBAJAAkAgAUUNACAEIAFB+AAQnw8aDAELIAQgAkEIahD8A0H4ABCeDxogA0H0AGpBAToAACADQewAakKBgICAEDcCAAsCQCADQegAaioCACIGQwAAAABfRQ0AIANBgICAiwQ2AmhDAABgQSEGCwJAIANBogFqIgEtAAANACABQShB25wFQQAQQxogAyoCaCEGCyADQaABakGFATsBACADQYQBaiEEAkACQCAGQwAAUEGVIgaLQwAAAE9dRQ0AIAaoIQUMAQtBgICAgHghBQsgBCAFsjgCACADQRBqIAEQmREaIANBgICA/AM2AuABIAMgADYCVCADIAMqAmg4AjQCQCAAKAKoCCIBIABBrAhqKAIARw0AIAFBAWohBAJAAkAgAQ0AQQghBQwBCyABQQJtIAFqIQULIAEgBSAEIAUgBEobIgRODQAgBEECdBA8IQECQCAAQbAIaigCACIFRQ0AIAEgBSAAKAKoCEECdBCeDxogACgCsAgQPgsgACAENgKsCCAAIAE2ArAIIAAoAqgIIQELIABBsAhqKAIAIAFBAnRqIAM2AgAgACAAKAKoCEEBajYCqAggAkGAAWokACADC7gFAQN/AkAgACgCRCIBIABByABqKAIARw0AIAFBAWohAgJAAkAgAQ0AQQghAwwBCyABQQJtIAFqIQMLIAEgAyACIAMgAkobIgJODQAgAkEwbBA8IQECQCAAQcwAaigCACIDRQ0AIAEgAyAAKAJEQTBsEJ4PGiAAKAJMED4LIAAgAjYCSCAAIAE2AkwgACgCRCEBCyAAQcwAaigCACABQTBsakEAQTAQoA8aIAAgACgCRCICQQFqIgE2AkQCQCABIAAoAkhHDQAg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DQYgASAEQX9qIgRqLQAAIAYgBGotAABGDQALIA0hBCAOIQcMAgsgCCALayEEC0EAIQcLIAYgBGohBgwACwALQQAhBgsgAkGgCGokACAGC0EBAn8jAEEQayIBJABBfyECAkAgABCzDw0AIAAgAUEPakEBIAAoAiARBQBBAUcNACABLQAPIQILIAFBEGokACACC0cBAn8gACABNwNwIAAgACgCLCAAKAIEIgJrrDcDeCAAKAIIIQMCQCABUA0AIAMgAmusIAFXDQAgAiABp2ohAwsgACADNgJoC90BAgN/An4gACkDeCAAKAIEIgEgACgCLCICa6x8IQQCQAJAAkAgACkDcCIFUA0AIAQgBVkNAQsgABCJECICQX9KDQEgACgCBCEBIAAoAiwhAgsgAEJ/NwNwIAAgATYCaCAAIAQgAiABa6x8NwN4QX8PCyAEQgF8IQQgACgCBCEBIAAoAgghAwJAIAApA3AiBUIAUQ0AIAUgBH0iBSADIAFrrFkNACABIAWnaiEDCyAAIAM2AmggACAEIAAoAiwiAyABa6x8NwN4AkAgASADSw0AIAFBf2ogAjoAAAsgAgsQACAAQSBGIABBd2pBBUlyCzUAIAAgATcDACAAIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGIAJC////////P4OENwMIC+cCAQF/IwBB0ABrIgQkAAJAAkAgA0GAgAFIDQAgBEEgaiABIAJCAEKAgICAgICA//8AENkQIARBIGpBCGopAwAhAiAEKQMgIQECQCADQf//AU8NACADQYGAf2ohAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQ2RAgA0H9/wIgA0H9/wJIG0GCgH5qIQMgBEEQakEIaikDACECIAQpAxAhAQwBCyADQYGAf0oNACAEQcAAaiABIAJCAEKAgICAgICAORDZECAEQcAAakEIaikDACECIAQpA0AhAQJAIANB9IB+TQ0AIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQ2RAgA0HogX0gA0HogX1KG0Ga/gFqIQMgBEEwakEIaikDACECIAQpAzAhAQsgBCABIAJCACADQf//AGqtQjCGENkQIAAgBEEIaikDADcDCCAAIAQpAwA3AwAgBEHQAGokAAtLAgF+An8gAUL///////8/gyECAkACQCABQjCIp0H//wFxIgNB//8BRg0AQQQhBCADDQFBAkEDIAIgAIRQGw8LIAIgAIRQIQQLIAQL1QYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABDPEEUNACADIAQQjxAhBiACQjCIpyIHQf//AXEiCEH//wFGDQAgBg0BCyAFQRBqIAEgAiADIAQQ2RAgBSAFKQMQIgQgBUEQakEIaikDACIDIAQgAxDRECAFQQhqKQMAIQIgBSkDACEEDAELAkAgASACQv///////////wCDIgkgAyAEQv///////////wCDIgoQzxBBAEoNAAJAIAEgCSADIAoQzxBFDQAgASEEDAILIAVB8ABqIAEgAkIAQgAQ2RAgBUH4AGopAwAhAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGAkACQCAIRQ0AIAEhBAwBCyAFQeAAaiABIAlCAEKAgICAgIDAu8AAENkQIAVB6ABqKQMAIglCMIinQYh/aiEIIAUpA2AhBAsCQCAGDQAgBUHQAGogAyAKQgBCgICAgICAwLvAABDZECAFQdgAaikDACIKQjCIp0GIf2ohBiAFKQNQIQMLIApC////////P4NCgICAgICAwACEIQsgCUL///////8/g0KAgICAgIDAAIQhCQJAIAggBkwNAANAAkACQCAJIAt9IAQgA1StfSIKQgBTDQACQCAKIAQgA30iBIRCAFINACAFQSBqIAEgAkIAQgAQ2RAgBUEoaikDACECIAUpAyAhBAwFCyAKQgGGIARCP4iEIQkMAQsgCUIBhiAEQj+IhCEJCyAEQgGGIQQgCEF/aiIIIAZKDQALIAYhCAsCQAJAIAkgC30gBCADVK19IgpCAFkNACAJIQoMAQsgCiAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAENkQIAVBOGopAwAhAiAFKQMwIQQMAQsCQCAKQv///////z9WDQADQCAEQj+IIQMgCEF/aiEIIARCAYYhBCADIApCAYaEIgpCgICAgICAwABUDQALCyAHQYCAAnEhBgJAIAhBAEoNACAFQcAAaiAEIApC////////P4MgCEH4AGogBnKtQjCGhEIAQoCAgICAgMDDPxDZECAFQcgAaikDACECIAUpA0AhBAwBCyAKQv///////z+DIAggBnKtQjCGhCECCyAAIAQ3AwAgACACNwMIIAVBgAFqJAALHAAgACACQv///////////wCDNwMIIAAgATcDAAuHCQIFfwN+IwBBMGsiBCQAQgAhCQJAAkAgAkECSw0AIAJBAnQiAkHcxgpqKAIAIQUgAkHQxgpqKAIAIQYDQAJAAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAItAAAhAgwBCyABEIsQIQILIAIQjBANAAtBASEHAkACQCACQVVqDgMAAQABC0F/QQEgAkEtRhshBwJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARCLECECC0EAIQgCQAJAAkADQCACQSByIAhB5IAEaiwAAEcNAQJAIAhBBksNAAJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARCLECECCyAIQQFqIghBCEcNAAwCCwALAkAgCEEDRg0AIAhBCEYNASADRQ0CIAhBBEkNAiAIQQhGDQELAkAgASkDcCIJQgBTDQAgASABKAIEQX9qNgIECyADRQ0AIAhBBEkNACAJQgBTIQIDQAJAIAINACABIAEoAgRBf2o2AgQLIAhBf2oiCEEDSw0ACwsgBCAHskMAAIB/lBDTECAEQQhqKQMAIQogBCkDACEJDAILAkACQAJAIAgNAEEAIQgDQCACQSByIAhB0fsEaiwAAEcNAQJAIAhBAUsNAAJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARCLECECCyAIQQFqIghBA0cNAAwCCwALAkACQCAIDgQAAQECAQsCQCACQTBHDQACQAJAIAEoAgQiCCABKAJoRg0AIAEgCEEBajYCBCAILQAAIQgMAQsgARCLECEICwJAIAhBX3FB2ABHDQAgBEEQaiABIAYgBSAHIAMQkxAgBEEYaikDACEKIAQpAxAhCQwGCyABKQNwQgBTDQAgASABKAIEQX9qNgIECyAEQSBqIAEgAiAGIAUgByADEJQQIARBKGopAwAhCiAEKQMgIQkMBAtCACEJAkAgASkDcEIAUw0AIAEgASgCBEF/ajYCBAsQqg9BHDYCAAwBCwJAAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAItAAAhAgwBCyABEIsQIQILAkACQCACQShHDQBBASEIDAELQgAhCUKAgICAgIDg//8AIQogASkDcEIA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EGoiAigCACIGDQALIAIgADYCACAAIAQ2AhgLIAAgADYCDCAAIAA2AggPCyAEKAIIIgEgADYCDCAEIAA2AgggAEEANgIYIAAgBDYCDCAAIAE2AggLC2UCAX8BfgJAAkAgAA0AQQAhAgwBCyAArSABrX4iA6chAiABIAByQYCABEkNAEF/IAIgA0IgiKdBAEcbIQILAkAgAhDEECIARQ0AIABBfGotAABBA3FFDQAgAEEAIAIQoA8aCyAAC+gKAgR/BH4jAEHwAGsiBSQAIARC////////////AIMhCQJAAkACQCABUCIGIAJC////////////AIMiCkKAgICAgIDAgIB/fEKAgICAgIDAgIB/VCAKUBsNACADQgBSIAlCgICAgICAwICAf3wiC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCwJAIAYgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhBCABIQMMAgsCQCADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEEDAILAkAgASAKQoCAgICAgMD//wCFhEIAUg0AQoCAgICAgOD//wAgAiADIAGFIAQgAoVCgICAgICAgICAf4WEUCIGGyEEQgAgASAGGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQECQCABIAqEQgBSDQAgAyAJhEIAUg0CIAMgAYMhAyAEIAKDIQQMAgsgAyAJhFBFDQAgASEDIAIhBAwBCyADIAEgAyABViAJIApWIAkgClEbIgcbIQkgBCACIAcbIgtC////////P4MhCiACIAQgBxsiAkIwiKdB//8BcSEIAkAgC0IwiKdB//8BcSIGDQAgBUHgAGogCSAKIAkgCiAKUCIGG3kgBkEGdK18pyIGQXFqEM4QQRAgBmshBiAFQegAaikDACEKIAUpA2AhCQsgASADIAcbIQMgAkL///////8/gyEEAkAgCA0AIAVB0ABqIAMgBCADIAQgBFAiBxt5IAdBBnStfKciB0FxahDOEEEQIAdrIQggBUHYAGopAwAhBCAFKQNQIQMLIARCA4YgA0I9iIRCgICAgICAgASEIQEgCkIDhiAJQj2IhCEEIANCA4YhCiALIAKFIQMCQCAGIAhGDQACQCAGIAhrIgdB/wBNDQBCACEBQgEhCgwBCyAFQcAAaiAKIAFBgAEgB2sQzhAgBUEwaiAKIAEgBxDYECAFKQMwIAUpA0AgBUHAAGpBCGopAwCEQgBSrYQhCiAFQTBqQQhqKQMAIQELIARCgICAgICAgASEIQwgCUIDhiEJAkACQCADQn9VDQBCACEDQgAhBCAJIAqFIAwgAYWEUA0CIAkgCn0hAiAMIAF9IAkgClStfSIEQv////////8DVg0BIAVBIGogAiAEIAIgBCAEUCIHG3kgB0EGdK18p0F0aiIHEM4QIAYgB2shBiAFQShqKQMAIQQgBSkDICECDAELIAEgDHwgCiAJfCICIApUrXwiBEKAgICAgICACINQDQAgAkIBiCAEQj+GhCAKQgGDhCECIAZBAWohBiAEQgGIIQQLIAtCgICAgICAgICAf4MhCgJAIAZB//8BSA0AIApCgICAgICAwP//AIQhBEIAIQMMAQtBACEHAkACQCAGQQBMDQAgBiEHDAELIAVBEGogAiAEIAZB/wBqEM4QIAUgAiAEQQEgBmsQ2BAgBSkDACAFKQMQIAVBEGpBCGopAwCEQgBSrYQhAiAFQQhqKQMAIQQLIAJCA4ggBEI9hoQhAyAHrUIwhiAEQgOIQv///////z+DhCAKhCEEIAKnQQdxIQYCQAJAAkACQAJAENYQDgMAAQIDCyAEIAMgBkEES618IgogA1StfCEEAkAgBkEERg0AIAohAwwDCyAEIApCAYMiASAKfCIDIAFUrXwhBAwDCyAEIAMgCkIAUiAGQQBHca18IgogA1StfCEEIAohAwwBCyAEIAMgClAgBkEAR3GtfCIKIANUrXwhBCAKIQMLIAZFDQELENcQGgsgACADNwMAIAAgBDcDCCAFQfAAaiQAC1MBAX4CQAJAIANBwABxRQ0AIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAUHAACADa62IIAIgA60iBIaEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC+ABAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvYAQIBfwJ+QX8hBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNACAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwsgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC+cQAgV/D34jAEHQAmsiBSQAIARC////////P4MhCiACQv///////z+DIQsgBCAChUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEMDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEMIAMhAQwCCwJAIAEgDUKAgICAgIDA//8AhYRCAFINAAJAIAMgAkKAgICAgIDA//8AhYRQRQ0AQgAhAUKAgICAgIDg//8AIQwMAwsgDEKAgICAgIDA//8AhCEMQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINAEIAIQEMAgsCQCABIA2EQgBSDQBCgICAgICA4P//ACAMIAMgAoRQGyEMQgAhAQwCCwJAIAMgAoRCAFINACAMQoCAgICAgMD//wCEIQxCACEBDAILQQAhCAJAIA1C////////P1YNACAFQcACaiABIAsgASALIAtQIggbeSAIQQZ0rXynIghBcWoQzhBBECAIayEIIAVByAJqKQMAIQsgBSkDwAIhAQsgAkL///////8/Vg0AIAVBsAJqIAMgCiADIAogClAiCRt5IAlBBnStfKciCUFxahDOECAJIAhqQXBqIQggBUG4AmopAwAhCiAFKQOwAiEDCyAFQaACaiADQjGIIApCgICAgICAwACEIg5CD4aEIgJCAEKAgICAsOa8gvUAIAJ9IgRCABDaECAFQZACakIAIAVBoAJqQQhqKQMAfUIAIARCABDaECAFQYACaiAFKQOQAkI/iCAFQZACakEIaikDAEIBhoQiBEIAIAJCABDaECAFQfABaiAEQgBCACAFQYACakEIaikDAH1CABDaECAFQeABaiAFKQPwAUI/iCAFQfABakEIaikDAEIBhoQiBEIAIAJCABDaECAFQdABaiAEQgBCACAFQeABakEIaikDAH1CABDaECAFQcABaiAFKQPQAUI/iCAFQdABakEIaikDAEIBhoQiBEIAIAJCABDaECAFQbABaiAEQgBCACAFQcABakEIaikDAH1CABDaECAFQaABaiACQgAgBSkDsAFCP4ggBUGwAWpBCGopAwBCAYaEQn98IgRCABDaECAFQZABaiADQg+GQgAgBEIAENoQIAVB8ABqIARCAEIAIAVBoAFqQQhqKQMAIAUpA6ABIgogBUGQAWpBCGopAwB8IgIgClStfCACQgFWrXx9QgAQ2hAgBUGAAWpCASACfUIAIARCABDaECAIIAcgBmtqIQYCQAJAIAUpA3AiD0IBhiIQIAUpA4ABQj+IIAVBgAFqQQhqKQMAIhFCAYaEfCINQpmTf3wiEkIgiCICIAtCgICAgICAwACEIhNCAYYiFEIgiCIEfiIVIAFCAYYiFkIgiCIKIAVB8ABqQQhqKQMAQgGGIA9CP4iEIBFCP4h8IA0gEFStfCASIA1UrXxCf3wiD0IgiCINfnwiECAVVK0gECAPQv////8PgyIPIAFCP4giFyALQgGGhEL/////D4MiC358IhEgEFStfCANIAR+fCAPIAR+IhUgCyANfnwiECAVVK1CIIYgEEIgiIR8IBEgEEIghnwiECARVK18IBAgEkL/////D4MiEiALfiIVIAIgCn58IhEgFVStIBEgDyAWQv7///8PgyIVfnwiGCARVK18fCIRIBBUrXwgESASIAR+IhAgFSANfnwiBCACIAt+fCINIA8gCn58Ig9CIIggBCAQVK0gDSAEVK18IA8gDVStfEIghoR8IgQgEVStfCAEIBggAiAVfiICIBIgCn58IgpCIIggCiACVK1CIIaEfCICIBhUrSACIA9CIIZ8IAJUrXx8IgIgBFStfCIEQv////////8AVg0AIBQgF4QhEyAFQdAAaiACIAQgAyAOENoQIAFCMYYgBUHQAGpBCGopAwB9IAUpA1AiAUIAUq19IQ0gBkH+/wBqIQZCACABfSEKDAELIAVB4ABqIAJCAYggBEI/hoQiAiAEQgGIIgQgAyAOENoQIAFCMIYgBUHgAGpBCGopAwB9IAUpA2AiCkIAUq19IQ0gBkH//wBqIQZCACAKfSEKIAEhFgsCQCAGQf//AUgNACAMQoCAgICAgMD//wCEIQxCACEBDAELAkACQCAGQQFIDQAgDUIBhiAKQj+IhCENIAatQjCGIARC////////P4OEIQ8gCkIBhiEEDAELAkAgBkGPf0oNAEIAIQEMAgsgBUHAAGogAiAEQQEgBmsQ2BAgBUEwaiAWIBMgBkHwAGoQzhAgBUEgaiADIA4gBSkDQCICIAVBwABqQQhqKQMAIg8Q2hAgBUEwakEIaikDACAFQSBqQQhqKQMAQgGGIAUpAyAiAUI/iIR9IAUpAzAiBCABQgGGIgFUrX0hDSAEIAF9IQQLIAVBEGogAyAOQgNCABDaECAFIAMgDkIFQgAQ2hAgDyACIAJCAYMiASAEfCIEIANWIA0gBCABVK18IgEgDlYgASAOURutfCIDIAJUrXwiAiADIAJCgICAgICAwP//AFQgBCAFKQMQViABIAVBEGpBCGopAwAiAlYgASACURtxrXwiAiADVK18IgMgAiADQoCAgICAgMD//wBUIAQgBSkDAFYgASAFQQhqKQMAIgRWIAEgBFEbca18IgEgAlStfCAMhCEMCyAAIAE3AwAgACAMNwMIIAVB0AJqJAALjgICAn8DfiMAQRBrIgIkAAJAAkAgAb0iBEL///////////8AgyIFQoCAgICAgIB4fEL/////////7/8AVg0AIAVCPIYhBiAFQgSIQoCAgICAgICAPHwhBQwBCwJAIAVCgICAgICAgPj/AFQNACAEQjyGIQYgBEIEiEKAgICAgIDA//8AhCEFDAELAkAgBVBFDQBCACEGQgAhBQwBCyACIAVCACAEp2dBIGogBUIgiKdnIAVCgICAgBBUGyIDQTFqEM4QIAJBCGopAwBCgICAgICAwACFQYz4ACADa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIARCgICAgICAgICAf4OENwMIIAJBEGokAAvhAQIDfwJ+IwBBEGsiAiQAAkACQCABvCIDQf////8HcSIEQYCAgHxqQf////cHSw0AIAStQhmGQoCAgICAgIDAP3whBUIAIQYMAQsCQCAEQYCAgPwHSQ0AIAOtQhmGQoCAgICAgMD//wCEIQVCACEGDAELAkAgBA0AQgAhBkIAIQUMAQsgAiAErUIAIARnIgRB0QBqEM4QIAJBCGopAwBCgICAgICAwACFQYn/ACAEa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIANBgICAgHhxrUIghoQ3AwggAkEQaiQAC40BAgJ/An4jAEEQayICJAACQAJAIAENAEIAIQRCACEFDAELIAIgASABQR91IgNzIANrIgOtQgAgA2ciA0HRAGoQzhAgAkEIaikDAEKAgICAgIDAAIVBnoABIANrrUIwhnwgAUGAgICAeHGtQiCGhCEFIAIpAwAhBAsgACAENwMAIAAgBTcDCCACQRBqJAALcgIBfwJ+IwBBEGsiAiQAAkACQCABDQBCACEDQgAhBAwBCyACIAGtQgAgAWciAUHRAGoQzhAgAkEIaikDAEKAgICAgIDAAIVBnoABIAFrrUIwhnwhBCACKQMAIQMLIAAgAzcDACAAIAQ3AwggAkEQaiQACwQAQQALBABBAAtTAQF+AkACQCADQcAAcUUNACACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAuaCwIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQogBCAChUKAgICAgICAgIB/gyELIAJC////////P4MiDEIgiCENIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyIOQoCAgICAgMD//wBUIA5CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCELDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCELIAMhAQwCCwJAIAEgDkKAgICAgIDA//8AhYRCAFINAAJAIAMgAoRQRQ0AQoCAgICAgOD//wAhC0IAIQEMAwsgC0KAgICAgIDA//8AhCELQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINACABIA6EIQJCACEBAkAgAlBFDQBCgICAgICA4P//ACELDAMLIAtCgICAgICAwP//AIQhCwwCCwJAIAEgDoRCAFINAEIAIQEMAgsCQCADIAKEQgBSDQBCACEBDAILQQAhCAJAIA5C////////P1YNACAFQdAAaiABIAwgASAMIAxQIggbeSAIQQZ0rXynIghBcWoQzhBBECAIayEIIAVB2ABqKQMAIgxCIIghDSAFKQNQIQELIAJC////////P1YNACAFQcAAaiADIAogAyAKIApQIgkbeSAJQQZ0rXynIglBcWoQzhAgCCAJa0EQaiEIIAVByABqKQMAIQogBSkDQCEDCyADQg+GIg5CgID+/w+DIgIgAUIgiCIEfiIPIA5CIIgiDiABQv////8PgyIBfnwiEEIghiIRIAIgAX58IhIgEVStIAIgDEL/////D4MiDH4iEyAOIAR+fCIRIANCMYggCkIPhiIUhEL/////D4MiAyABfnwiCiAQQiCIIBAgD1StQiCGhHwiDyACIA1CgIAEhCIQfiIVIA4gDH58Ig0gFEIgiEKAgICACIQiAiABfnwiFCADIAR+fCIWQiCGfCIXfCEBIAcgBmogCGpBgYB/aiEGAkACQCACIAR+IhggDiAQfnwiBCAYVK0gBCADIAx+fCIOIARUrXwgAiAQfnwgDiARIBNUrSAKIBFUrXx8IgQgDlStfCADIBB+IgMgAiAMfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgFkIgiCANIBVUrSAUIA1UrXwgFiAUVK18QiCGhHwiBCACVK18IAQgDyAKVK0gFyAPVK18fCICIARUrXwiBEKAgICAgIDAAINQDQAgBkEBaiEGDAELIBJCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIBJCAYYhEiADIAFCAYaEIQELAkAgBkH//wFIDQAgC0KAgICAgIDA//8AhCELQgAhAQwBCwJAAkAgBkEASg0AAkBBASAGayIHQf8ASw0AIAVBMGogEiABIAZB/wBqIgYQzhAgBUEgaiACIAQgBhDOECAFQRBqIBIgASAHENgQIAUgAiAEIAcQ2BAgBSkDICAFKQMQhCAFKQMwIAVBMGpBCGopAwCEQgBSrYQhEiAFQSBqQQhqKQMAIAVBEGpBCGopAwCEIQEgBUEIaikDACEEIAUpAwAhAgwCC0IAIQEMAgsgBq1CMIYgBEL///////8/g4QhBAsgBCALhCELAkAgElAgAUJ/VSABQoCAgICAgICAgH9RGw0AIAsgAkIBfCIBUK18IQsMAQsCQCASIAFCgICAgICAgICAf4WEQgBRDQAgAiEBDAELIAsgAiACQgGDfCIBIAJUrXwhCwsgACABNwMAIAAgCzcDCCAFQeAAaiQAC3UBAX4gACAEIAF+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgA0L/////D4MgAiABfnwiAUIgiHw3AwggACABQiCGIAVC/////w+DhDcDAAtIAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRDNECAFKQMAIQQgACAFQQhqKQMANwMIIAAgBDcDACAFQRBqJAAL5AMCAn8CfiMAQSBrIgIkAAJAAkAgAUL///////////8AgyIEQoCAgICAgMD/Q3wgBEKAgICAgIDAgLx/fFoNACAAQjyIIAFCBIaEIQQCQCAAQv//////////D4MiAEKBgICAgICAgAhUDQAgBEKBgICAgICAgMAAfCEFDAILIARCgICAgICAgIDAAHwhBSAAQoCAgICAgICACFINASAFIARCAYN8IQUMAQsCQCAAUCAEQoCAgICAgMD//wBUIARCgICAgICAwP//AFEbDQAgAEI8iCABQgSGhEL/////////A4NCgICAgICAgPz/AIQhBQwBC0KAgICAgICA+P8AIQUgBEL///////+//8MAVg0AQgAhBSAEQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQzhAgAiAAIARBgfgAIANrENgQIAIpAwAiBEI8iCACQQhqKQMAQgSGhCEFAkAgBEL//////////w+DIAIpAxAgAkEQakEIaikDAIRCAFKthCIEQoGAgICAgICACFQNACAFQgF8IQUMAQsgBEKAgICAgICAgAhSDQAgBUIBgyAFfCEFCyACQSBqJAAgBSABQoCAgICAgICAgH+DhL8LxAMCA38BfiMAQSBrIgIkAAJAAkAgAUL///////////8AgyIFQoCAgICAgMC/QHwgBUKAgICAgIDAwL9/fFoNACABQhmIpyEDAkAgAFAgAUL///8PgyIFQoCAgAhUIAVCgICACFEbDQAgA0GBgICABGohBAwCCyADQYCAgIAEaiEEIAAgBUKAgIAIhYRCAFINASAEIANBAXFqIQQMAQsCQCAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbDQAgAUIZiKdB////AXFBgICA/gdyIQQMAQtBgICA/AchBCAFQv///////7+/wABWDQBBACEEIAVCMIinIgNBkf4ASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIFIANB/4F/ahDOECACIAAgBUGB/wAgA2sQ2BAgAkEIaikDACIFQhmIpyEEAkAgAikDACACKQMQIAJBEGpBCGopAwCEQgBSrYQiAFAgBUL///8PgyIFQoCAgAhUIAVCgICACFEbDQAgBEEBaiEEDAELIAAgBUKAgIAIhYRCAFINACAEQQFxIARqIQQLIAJBIGokACAEIAFCIIinQYCAgIB4cXK+C0UBAn8jAEEQayICJABBACEDAkAgAEEDcQ0AIAEgAHANACACQQxqIAAgARDJECEAQQAgAigCDCAAGyEDCyACQRBqJAAgAws2AQF/IABBASAAQQFLGyEBAkADQCABEMQQIgANAQJAEMQRIgBFDQAgABEGAAwBCwsQJwALIAALBwAgABDFEAs/AQJ/IAFBBCABQQRLGyECIABBASAAQQFLGyEAAkADQCACIAAQ4hAiAw0BEMQRIgFFDQEgAREGAAwACwALIAMLIQEBfyAAIAAgAWpBf2pBACAAa3EiAiABIAIgAUsbEN4QCwcAIAAQ5BALBwAgABDFEAsQACAAQaTWCkEIajYCACAACzwBAn8gARCAECICQQ1qEN8QIgNBADYCCCADIAI2AgQgAyACNgIAIAAgAxDnECABIAJBAWoQng82AgAgAAsHACAAQQxqCyAAIAAQ5RAiAEGU1wpBCGo2AgAgAEEEaiABEOYQGiAACwQAQQELBAAgAAsNACAAEOwQLQALQQd2CwcAIAAQ7RALBAAgAAsYAAJAIAAQ6xBFDQAgABD1EA8LIAAQ9hAL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sxELDQAgACACIAMgBBCyEQsJACAAIAEQtRELCQAgACABELYRCwwAIAAgASACELQRGgs4AQF/IwBBEGsiAyQAIAMgARC3ETYCDCADIAIQtxE2AgggACADQQxqIANBCGoQuBEaIANBEGokAAtAAQF/IwBBEGsiBCQAIAQgAjYCDCAEIAMgASACIAFrIgIQnw8gAmo2AgggACAEQQxqIARBCGoQuhEgBEEQaiQACwcAIAAQ8RALGAAgACABKAIANgIAIAAgAigCADYCBCAACwkAIAAgARC8EQsNACAAIAEgABDxEGtqCwcAIAAQuRELGAAgACABKAIANgIAIAAgAigCADYCBCAACwcAIAAQ6hALDAAgACABIAIQuxEaCxgAIAAgASgCADYCACAAIAIoAgA2AgQgAAsJACAAIAEQvRELDQAgACABIAAQ6hBragseAAJAIAIQoxFFDQAgACABIAIQvxEPCyAAIAEQwBELCQAgACACEMERCwcAIAAQwhELCQAgACABEOMQCwcAIAAQ4BALBwAgACgCAAsJAEG4nwwQwxELDwAgAEHQAGoQxBBB0ABqCwcAIAAQ8xELAgALAgALCgAgABDGERDgEAsKACAAEMYREOAQCwoAIAAQxhEQ4BALCgAgABDGERDgEAsKACAAEMYREOAQCwsAIAAgAUEAEM8RCzAAAkAgAg0AIAAoAgQgASgCBEYPCwJAIAAgAUcNAEEBDwsgABDQESABENAREP4PRQsHACAAKAIECwQAQQALrQEBAn8jAEHAAGsiAyQAQQEhBAJAIAAgAUEAEM8RDQBBACEEIAFFDQBBACEEIAFB4M8KQZDQCkEAENMRIgFFDQAgA0EMakEAQTQQoA8aIANBATYCOCADQX82AhQgAyAANgIQIAMgATYCCCABIANBCGogAigCAEEBIAEoAgAoAhwRCQACQCADKAIgIgRBAUcNACACIAMoAhg2AgALIARBAUYhBAsgA0HAAGokACAEC8wCAQN/IwBBwABrIgQkACAAKAIAIgVBfGooAgAhBiAFQXhqKAIAIQUgBEEgakIANwIAIARBKGpCADcCACAEQTBqQgA3AgAgBEE3akIANwAAIARCADcCGCAEIAM2AhQgBCABNgIQIAQgADYCDCAEIAI2AgggACAFaiEAQQAhAwJAAkAgBiACQQAQzxFFDQAgBEEBNgI4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c0Zyb21NZW1vcnkAQ2VsZXJ5AENvcHkARHVtbXkAUmFzdGVyaXplck11bHRpcGx5AFJlc2l6ZSBob3Jpem9udGFsIG9ubHkAUmVzaXplIHZlcnRpY2FsIG9ubHkAaW8uQ29uZmlnV2luZG93c01vdmVGcm9tVGl0bGVCYXJPbmx5AEltR3VpSW5wdXRUZXh0RmxhZ3NfUmVhZE9ubHkAdGFibGVfc2Nyb2xseQBNb2RpZnkARXZlbnRLZXkASW1HdWlUYWJsZUZsYWdzX0NvbnRleHRNZW51SW5Cb2R5AEltR3VpVGFibGVGbGFnc19Ob0JvcmRlcnNJbkJvZHkAU2l6aW5nIFBvbGljeQBCb2JieQBFeGFtcGxlOiBTaW1wbGUgb3ZlcmxheQBFeGFtcGxlOiBMb25nIHRleHQgZGlzcGxheQBLZXlSZXBlYXREZWxheQBNeQB0YWJsZS0+QmdDbGlwUmVjdC5NaW4ueSA8PSB0YWJsZS0+QmdDbGlwUmVjdC5NYXgueQB0YWJsZS0+QmcyQ2xpcFJlY3RGb3JEcmF3Q21kLk1pbi55IDw9IHRhYmxlLT5CZzJDbGlwUmVjdEZvckRyYXdDbWQuTWF4LnkAdGFibGUtPlJvd1Bvc1kyID09IGlubmVyX3dpbmRvdy0+REMuQ3Vyc29yUG9zLnkAV2UgY2FsbCBBbGlnblRleHRUb0ZyYW1lUGFkZGluZygpIHRvIHZlcnRpY2FsbHkgYWxpZ24gdGhlIHRleHQgYmFzZWxpbmUgYnkgK0ZyYW1lUGFkZGluZy55AFByaW1WdHgAUHJpbVdyaXRlVnR4ACMjY3N4ACslLjBmIHB4AFgvWSA9ICUuMGYgcHgATWVzaDogRWxlbUNvdW50OiAlZCwgVnR4T2Zmc2V0OiArJWQsIElkeE9mZnNldDogKyVkLCBBcmVhOiB+JTAuZiBweABUZXh0dXJlIEFyZWE6IGFib3V0ICVkIHB4IH4lZHglZCBweABjaGVja2JveABJVEVNOiBDaGVja2JveABJVEVNOiBMaXN0Qm94AERlYnVnTm9kZURyYXdDbWRTaG93TWVzaEFuZEJvdW5kaW5nQm94AHRhYmxlX3Njcm9sbHgAU2l4AFBhdGhGaWxsQ29udmV4ACMjaGV4AGlucHV0IHUzMiBoZXgAaW5wdXQgczMyIGhleABHZXRLZXlJbmRleABUYWJsZUdldFJvd0luZGV4AEdldEluZGV4AFRhYmxlU2V0Q29sdW1uSW5kZXgAVGFibGVHZXRDb2x1bW5JbmRleABBbnRpQWxpYXNlZExpbmVzVXNlVGV4AEhleABQcmltV3JpdGVJZHgAIyNtYXgAR2V0Q2xpcFJlY3RNYXgAR2V0SXRlbVJlY3RNYXgAR2V0V2luZG93Q29udGVudFJlZ2lvbk1heABHZXRDb250ZW50UmVnaW9uTWF4AFNjcm9sbE1heABJbnB1dFRleHRFeABQbG90RXgAU2VwYXJhdG9yRXgAU2Nyb2xsYmFyRXgAVGFiSXRlbUV4AEJlZ2luVGFibGVFeAAjI1BvcHVwXyUwOHgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABSZW5kZXJBcnJvdwBJbUd1aVRyZWVOb2RlRmxhZ3NfT3Blbk9uQXJyb3cAWWVsbG93AHNsaWRlciBmbG9hdCBsb3cAc2xpZGVyIGRvdWJsZSBsb3cAc2xpZGVyIHU2NCBsb3cAc2xpZGVyIHM2NCBsb3cAc2xpZGVyIHUzMiBsb3cAc2xpZGVyIHMzMiBsb3cATWVudSBpbnNpZGUgYSByZWd1bGFyIHdpbmRvdwBNZW51cyBpbnNpZGUgYSByZWd1bGFyIHdpbmRvdwBTaG93IEhvcml6b250YWwgY29udGVudHMgc2l6ZSBkZW1vIHdpbmRvdwBFeGFtcGxlOiBBdXRvLXJlc2l6aW5nIHdpbmRvdwBDb25zdHJhaW5lZC1yZXNpemluZyB3aW5kb3cAZy5DdXJyZW50V2luZG93ID09IHdpbmRvdwB3aW5kb3cgPT0gZy5OYXZXaW5kb3cAQmVnaW5Qb3B1cENvbnRleHRXaW5kb3cAU2hvd0Fib3V0V2luZG93AEdldEhvdmVyZWRSb290V2luZG93AGcuTW92aW5nV2luZG93ICYmIGcuTW92aW5nV2luZG93LT5Sb290V2luZG93AEdldEN1cnJlbnRXaW5kb3cAaW5uZXJfd2luZG93ID09IGcuQ3VycmVudFdpbmRvdwBvdXRlcl93aW5kb3cgPT0gaW5uZXJfd2luZG93IHx8IG91dGVyX3dpbmRvdyA9PSBpbm5lcl93aW5kb3ctPlBhcmVudFdpbmRvdwBOYXZJbml0V2luZG93AE5hdlVwZGF0ZVdpbmRvd2luZ0hpZ2hsaWdodFdpbmRvdwBGb2N1c1dpbmRvdwBTaG93TWV0cmljc1dpbmRvdwBDbG9zZVBvcHVwc092ZXJXaW5kb3cAd2luZG93ID09IHRhYmxlLT5Jbm5lcldpbmRvdwBTaG93RGVtb1dpbmRvdwB+SW1HdWlXaW5kb3cAR2V0QWN0aXZlV2luZG93AGZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19DaGlsZFdpbmRvdwB3aW5kb3ctPkZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19DaGlsZFdpbmRvdwAgQ2hpbGRXaW5kb3cAR2V0SG92ZXJlZFdpbmRvdwBnLk5hdldpbmRvdyAmJiByZXN1bHQtPldpbmRvdwBCb3JkZXJTaGFkb3cAVGFibGVOZXh0Um93AFRhYmxlSGVhZGVyc1JvdwBUYWJsZUJlZ2luUm93ACF0YWJsZS0+SXNJbnNpZGVSb3cAVGFibGVFbmRSb3cAIyNwcmV2aWV3AEltR3VpQ29tYm9GbGFnc19Ob1ByZXZpZXcAV2l0aCBTaWRlIFByZXZpZXcAV2l0aCBBbHBoYSBQcmV2aWV3AFdpdGggSGFsZiBBbHBoYSBQcmV2aWV3AGl0ZW0gdmlldwBUcmVlIHZpZXcATmV3AGRyYXdfY21kLkNsaXBSZWN0LnggPD0gZHJhd19jbWQuQ2xpcFJlY3QueiAmJiBkcmF3X2NtZC5DbGlwUmVjdC55IDw9IGRyYXdfY21kLkNsaXBSZWN0LncAIyNoc3YARmlsZTFfYi53YXYARmlsZTFfYS53YXYATm8gbmF2AFJvb3RXaW5kb3dGb3JOYXYAIyN2AHRhYmxlX2NvbnRleHRfbWVudQBTdWItbWVudQBpdGVtIGNvbnRleHQgbWVudQBFbmFibGUgY29udGV4dCBtZW51AE5vIG1lbnUAVGFibGVPcGVuQ29udGV4dE1lbnUAIyNDb250ZXh0TWVudQBNeUhlbHBNZW51AEJlZ2luTWVudQBFbmRNZW51ACBDaGlsZE1lbnUAV2l0aCBPcHRpb25zIE1lbnUARGlzYWJsZSBNZW51ACVsbHUAJXNfJXUAaW1ndWlfbG9nLnR4dAB3aW5kb3dfY29udGV4dAB2b2lkX2NvbnRleHQARGVzdHJveUNvbnRleHQAU2V0Q3VycmVudENvbnRleHQAR2V0Q3VycmVudENvbnRleHQAV3JhcEltR3VpQ29udGV4dABDcmVhdGVDb250ZXh0AHNob3dfd3JhcHBlZF90ZXh0AGlucHV0IHRleHQAQnVsbGV0IHRleHQAc29tZSBtb3JlIHRleHQAJWQgc29tZSB0ZXh0AFRlbXBJbnB1dFRleHQAaW8uQ29uZmlnRHJhZ0NsaWNrVG9JbnB1dFRleHQASVRFTTogSW5wdXRUZXh0AEJ1bGxldFRleHQARGF0YVR5cGVBcHBseU9wRnJvbVRleHQATGFiZWxUZXh0AExvZ1RleHQAU2V0Q2xpcGJvYXJkVGV4dABHZXRDbGlwYm9hcmRUZXh0AEFkZFRleHQAIyNUZXh0AENvbG9yZnVsIFRleHQAQWRkIERlYnVnIFRleHQASVRFTTogVGV4dABVVEYtOCBUZXh0AHd0AFVURi04IGlucHV0AFdhbnRUZXh0SW5wdXQASW1HdWlTbGlkZXJGbGFnc19Ob0lucHV0AEltR3VpSW5wdXRUZXh0RmxhZ3NfQWxsb3dUYWJJbnB1dABNdWx0aS1saW5lIFRleHQgSW5wdXQARmlsdGVyZWQgVGV4dCBJbnB1dABQYXNzd29yZCBJbnB1dABFeGFtcGxlOiBTaW1wbGUgbGF5b3V0AFRhYkJhckxheW91dABUYWJsZVVwZGF0ZUxheW91dABEZWJ1Z0NoZWNrVmVyc2lvbkFuZERhdGFMYXlvdXQAQmFzaWMgSG9yaXpvbnRhbCBMYXlvdXQAQ29jb251dABDdXQAa2VlcGNvc3QAYXV0byBlbWJpbmRfaW5pdF9JbUd1aSgpOjooYW5vbnltb3VzIGNsYXNzKTo6b3BlcmF0b3IoKShlbXNjcmlwdGVuOjp2YWwpIGNvbnN0AGF1dG8gZW1iaW5kX2luaXRfSW1Gb250Q29uZmlnKCk6Oihhbm9ueW1vdXMgY2xhc3MpOjpvcGVyYXRvcigpKEltRm9udENvbmZpZyAmLCBlbXNjcmlwdGVuOjp2YWwpIGNvbnN0AGF1dG8gZW1iaW5kX2luaXRfSW1HdWkoKTo6KGFub255bW91cyBjbGFzcyk6Om9wZXJhdG9yKCkoKSBjb25zdABhdXRvIGVtYmluZF9pbml0X0ltRm9udENvbmZpZygpOjooYW5vbnltb3VzIGNsYXNzKTo6b3BlcmF0b3IoKShjb25zdCBJbUZvbnRDb25maWcgJikgY29uc3QARHJhd0xpc3QgPT0gJkRyYXdMaXN0SW5zdABEcmF3IGluIEJhY2tncm91bmQgZHJhdyBsaXN0AERyYXcgaW4gRm9yZWdyb3VuZCBkcmF3IGxpc3QAR2V0V2luZG93RHJhd0xpc3QASW1EcmF3TGlzdABHZXRCYWNrZ3JvdW5kRHJhd0xpc3QAR2V0Rm9yZWdyb3VuZERyYXdMaXN0ACMjI05hdldpbmRvd2luZ0xpc3QATW91c2VEb3VibGVDbGlja01heERpc3QAU2Nyb2xsVGFyZ2V0RWRnZVNuYXBEaXN0AGcuTmF2TW92ZVJlcXVlc3QAUGF0aEFyY1RvRmFzdABFeHBvcnQAdW5zaWduZWQgc2hvcnQAX0RlZmF1bHRTb3J0AF9Ob1NvcnQAUmV2ZXJ0AGluc2VydABEaXNwbGF5U3RhcnQAU2VsZWN0aW9uU3RhcnQAQ2Fycm90AEJlZXRyb290AFJvb3QAQXByaWNvdABHZXRLZXlQcmVzc2VkQW1vdW50ACMjY29sdW1uc19jb3VudABpdGVtc19jb3VudAB2X2lkeCA+PSAwICYmIHZfaWR4IDwgdmFsdWVzX2NvdW50AHYxX2lkeCA+PSAwICYmIHYxX2lkeCA8IHZhbHVlc19jb3VudABTYW1wbGUgY291bnQAVG90YWxWdHhDb3VudABUb3RhbElkeENvdW50AENtZExpc3RzQ291bnQAR2V0Q29sdW1uc0NvdW50AHNldHRpbmdzLT5Db2x1bW5zQ291bnQgPT0gdGFibGUtPkNvbHVtbnNDb3VudCAmJiBzZXR0aW5ncy0+Q29sdW1uc0NvdW50TWF4ID49IHNldHRpbmdzLT5Db2x1bW5zQ291bnQAY29sdW1uX24gPj0gLTEgJiYgY29sdW1uX24gPCB0YWJsZS0+Q29sdW1uc0NvdW50AGNvbHVtbl9uID49IDAgJiYgY29sdW1uX24gPCB0YWJsZS0+Q29sdW1uc0NvdW50AGNvbHVtbl9uID49IDAgJiYgdGFibGUtPkNvbHVtbnNDb3VudABJdGVtc0NvdW50AGNvbHVtbi0+U29ydE9yZGVyIDwgdGFibGUtPlNvcnRTcGVjc0NvdW50AFRhYmxlR2V0Q29sdW1uQ291bnQARWxlbUNvdW50AG4gPCBjb2x1bW4tPlNvcnREaXJlY3Rpb25zQXZhaWxDb3VudABHZXRGcmFtZUNvdW50AGcuRnJhbWVDb3VudEVuZGVkICE9IGcuRnJhbWVDb3VudABDb25maWdEYXRhQ291bnQAaWR4ID49IDAgJiYgaWR4IDwgX0NvdW50AE5vIGJyaW5nIHRvIGZyb250AERzdEZvbnQAU2V0Q3VycmVudEZvbnQAR2V0Rm9udABQb3BGb250AEltRm9udABQdXNoRm9udABDb2RlcG9pbnQAQW5vdGhlciBidWxsZXQgcG9pbnQAQ29uc3RyYWludABJbnB1dFRleHRXaXRoSGludAAjI2ludABpbnB1dCBpbnQAc2xpZGVyIGludABkcmFnIGludAByYW5nZSBpbnQAdW5zaWduZWQgaW50AFBhdWNpbG9xdWVudABDb250ZW50ACMjY3VycmVudABDaGFubmVsc1NldEN1cnJlbnQAU29tZSBEb2N1bWVudABUZXh0IEJhc2VsaW5lIEFsaWdubWVudABVbmluZGVudABJbmRlbnQARGVzY2VudABBc2NlbnQAT3BlbiBSZWNlbnQARWdncGxhbnQASW5wdXRJbnQAVlNsaWRlckludABEcmFnSW50AE5hdlVwZGF0ZU1vdmVSZXN1bHQAU2V0IGFzIGRlZmF1bHQAQWRkRm9udERlZmF1bHQASXRlbVdpZHRoRGVmYXVsdABEZWJ1ZyMjRGVmYXVsdABJc0J1aWx0AEtleUFsdABUYWJsZVJvd0JnQWx0AEV4aXQAR3JhcGVmcnVpdABRdWl0AHNwbGl0AENoYW5uZWxzU3BsaXQAIyNlZGl0AElzSXRlbURlYWN0aXZhdGVkQWZ0ZXJFZGl0AENvbnRlbnRTaXplRXhwbGljaXQASW1HdWlUYWJsZUZsYWdzX1NpemluZ0ZpeGVkRml0AFRlc3RCaXQAU2V0Qml0AENsZWFyQml0AFRvcC1yaWdodABCb3R0b20tcmlnaHQAIyNyaWdodABOYXZIaWdobGlnaHQAUm9vdFdpbmRvd0ZvclRpdGxlQmFySGlnaGxpZ2h0AE5hdldpbmRvd2luZ0hpZ2hsaWdodAB0YWJsZV9yb3dfaGVpZ2h0AHJvd19taW5faGVpZ2h0AFJvdyBoZWlnaHQAV2VpZ2h0AFRleEhlaWdodABHZXRXaW5kb3dIZWlnaHQASXRlbXNIZWlnaHQAR2V0VGV4dExpbmVIZWlnaHQAR2V0RnJhbWVIZWlnaHQAZy5TdHlsZS5XaW5kb3dNZW51QnV0dG9uUG9zaXRpb24gPT0gSW1HdWlEaXJfTm9uZSB8fCBnLlN0eWxlLldpbmRvd01lbnVCdXR0b25Qb3NpdGlvbiA9PSBJbUd1aURpcl9MZWZ0IHx8IGcuU3R5bGUuV2luZG93TWVudUJ1dHRvblBvc2l0aW9uID09IEltR3VpRGlyX1JpZ2h0AEhlbGxvIFJpZ2h0AFN0eWxlQ29sb3JzTGlnaHQAVGFibGVCb3JkZXJMaWdodABLZXlTaGlmdABUb3AtbGVmdABCb3R0b20tbGVmdAAjI2xlZnQASW1HdWlDb21ib0ZsYWdzX1BvcHVwQWxpZ25MZWZ0AEhlbGxvIExlZnQAcHRyX2Zyb21fb2Zmc2V0AGlvLkJhY2tlbmRGbGFnczogUmVuZGVyZXJIYXNWdHhPZmZzZXQAX09uQ2hhbmdlZFZ0eE9mZnNldABJZHhPZmZzZXQASW1EcmF3VmVydFBvc09mZnNldABTZXRDb2x1bW5PZmZzZXQAR2V0Q29sdW1uT2Zmc2V0AEdldERyYWdnZWRDb2x1bW5PZmZzZXQASW1EcmF3VmVydENvbE9mZnNldABHbHlwaE9mZnNldABieXRlT2Zmc2V0AEltRHJhd1ZlcnRVVk9mZnNldABTY3JvbGwgT2Zmc2V0AExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0AEJ1bGxldAByb3cgYmcgdGFyZ2V0AEJlZ2luRHJhZ0Ryb3BUYXJnZXQARW5kRHJhZ0Ryb3BUYXJnZXQAZy5EcmFnRHJvcFdpdGhpblRhcmdldABTY3JvbGxUYXJnZXQAZy5OYXZXaW5kb3dpbmdUYXJnZXQAU2V0AE9iamVjdABHZXRXaW5kb3dSZWN0AENvbHVtbnNSZWN0AE91dGVyUmVjdABJbm5lclJlY3QAR2V0UmVzaXplQm9yZGVyUmVjdABHZXRXaW5kb3dTY3JvbGxiYXJSZWN0AEhvc3RDbGlwUmVjdABDb2x1bW5zQ2xpcFJlY3QASW5uZXJDbGlwUmVjdABQb3BDbGlwUmVjdABQdXNoQ2xpcFJlY3QAQmFja2dyb3VuZENsaXBSZWN0AF9PbkNoYW5nZWRDbGlwUmVjdABDb250ZW50UmVnaW9uUmVjdABQcmltUmVjdABJbVJlY3QAQ29sdW1uc1dvcmtSZWN0AFBhdGhSZWN0AElzTW91c2VIb3ZlcmluZ1JlY3QAR2V0VGFibGVSZWN0AEFkZFJlY3QAaW5wdXQgZmxvYXQAc2xpZGVyIGZsb2F0AGRyYWcgc21hbGwgZmxvYXQAZHJhZyBmbG9hdAByYW5nZSBmbG9hdABJVEVNOiBJbnB1dEZsb2F0AFZTbGlkZXJGbG9hdABJVEVNOiBTbGlkZXJGbG9hdABEcmFnRmxvYXQASW1HdWlTbGlkZXJGbGFnc19Ob1JvdW5kVG9Gb3JtYXQAUG9wQnV0dG9uUmVwZWF0AFB1c2hCdXR0b25SZXBlYXQARWF0AHVpbnQ2NF90ADN3YXlzAGZyZWV6ZV9yb3dzAFBvcHVwcyAmIE1vZGFsIHdpbmRvd3MAQ2hpbGQgd2luZG93cwBTZXR0aW5nc1dpbmRvd3MATWV0cmljc1JlbmRlcldpbmRvd3MATWV0cmljc0FjdGl2ZVdpbmRvd3MAQ2hpbGRXaW5kb3dzAENhdHR5d2FtcHVzACMjcHJldmlvdXMAUHJldmlvdXMAQ29udGV4dCBtZW51cwBTZXROZXh0V2luZG93Rm9jdXMAU2V0V2luZG93Rm9jdXMAU2V0SXRlbURlZmF1bHRGb2N1cwBTZXRXaW5kb3dOYW1lRm9jdXMAUG9wQWxsb3dLZXlib2FyZEZvY3VzAFB1c2hBbGxvd0tleWJvYXJkRm9jdXMASW5wdXRzLCBOYXZpZ2F0aW9uICYgRm9jdXMATm9OYXZJbnB1dHMAX3NldEF0X05hdklucHV0cwBfZ2V0QXRfTmF2SW5wdXRzAE5vTW91c2VJbnB1dHMAQkcvRkcgZHJhdyBsaXN0cwBJdGVyYXRlRHJhd0xpc3RzAFRhYmxlQmVnaW5BcHBseVJlcXVlc3RzAFRpdGxlIGJhciBIb3ZlcmVkL0FjdGl2ZSB0ZXN0cwBJdGVyYXRlRm9udHMAU2V0TmV4dFdpbmRvd1NpemVDb25zdHJhaW50cwBTb21lIG90aGVyIGNvbnRlbnRzAEV2ZW4gbW9yZSBjb250ZW50cwBTb21lIGNvbnRlbnRzAFNvbWUgdHJlZSBjb250ZW50cwBOb2RlIGNvbnRlbnRzAENvbnRlbnRzAENsb3NlIEFsbCBEb2N1bWVudHMARXhhbXBsZTogRG9jdW1lbnRzAEdyYWRpZW50cwBNYXg6ICVkIHVuaXRzAE1pbjogJWQgdW5pdHMAQnVsbGV0cwBEcmFnIGFuZCBkcm9wIGluIHN0YW5kYXJkIHdpZGdldHMAU2hvd0RlbW9XaW5kb3dXaWRnZXRzAE11bHRpLWNvbXBvbmVudCBXaWRnZXRzAFBsb3RzIFdpZGdldHMAQ29sb3IvUGlja2VyIFdpZGdldHMAUmFuZ2UgV2lkZ2V0cwBTY2FsZUNsaXBSZWN0cwBUaGlja25lc3MATW91c2UgY3Vyc29ycwBpby5CYWNrZW5kRmxhZ3M6IEhhc01vdXNlQ3Vyc29ycwAjI2NvbG9ycwBGaWx0ZXIgY29sb3JzAEhTViBlbmNvZGVkIGNvbG9ycwBfc2V0QXRfQ29sb3JzAF9nZXRBdF9Db2xvcnMAT25seSBNb2RpZmllZCBDb2xvcnMAaW8uQ29uZmlnTWFjT1NYQmVoYXZpb3JzACJpbWd1aSIgbGV0dGVycwBDbGVhcklucHV0Q2hhcmFjdGVycwBTZXR0aW5nc0hhbmRsZXJzAFRhYmxlR2NDb21wYWN0VHJhbnNpZW50QnVmZmVycwBEZUluZGV4QWxsQnVmZmVycwBUYWJsZVVwZGF0ZUJvcmRlcnMASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnMAVmVydGljYWwgU2xpZGVycwBzaG93X2hlYWRlcnMAdGFibGVfY3VzdG9tX2hlYWRlcnMARGlzcGxheSBoZWFkZXJzAEN1c3RvbSBoZWFkZXJzAFJlb3JkZXJhYmxlLCBoaWRlYWJsZSwgd2l0aCBoZWFkZXJzAERpc2FibGUgdmVydGljYWwgYm9yZGVycyBpbiBjb2x1bW5zIEJvZHkgKGJvcmRlcnMgd2lsbCBhbHdheXMgYXBwZWFycyBpbiBIZWFkZXJzAENvbGxhcHNpbmcgSGVhZGVycwBJbnNlcnRDaGFycwBEZWxldGVDaGFycwBUYWJCYXJzAFBvcHVwcwBHcm91cHMAIyNwb3MAY2ZnX2luZm9zAERpc3BsYXlQb3MAU2V0TmV4dFdpbmRvd1BvcwBTZXRXaW5kb3dQb3MAR2V0V2luZG93UG9zAEdldEN1cnNvclN0YXJ0UG9zAFNldEN1cnNvclBvcwBHZXRDdXJzb3JQb3MAUG9wVGV4dFdyYXBQb3MAUHVzaFRleHRXcmFwUG9zAFNldEN1cnNvclNjcmVlblBvcwBHZXRDdXJzb3JTY3JlZW5Qb3MAV2FudFNldE1vdXNlUG9zAGlvLkJhY2tlbmRGbGFnczogSGFzU2V0TW91c2VQb3MAaW8uQ29uZmlnRmxhZ3M6IE5hdkVuYWJsZVNldE1vdXNlUG9zAEdldE1vdXNlUG9zAFNldFdpbmRvd05hbWVQb3MAX2dldEF0X01vdXNlQ2xpY2tlZFBvcwBTY3JvbGwgVG8gUG9zAFNob3cgc3RlcCBidXR0b25zAFNtYWxsIGJ1dHRvbnMATm9ybWFsIGJ1dHRvbnMATG9nQnV0dG9ucwBXaW5kb3cgb3B0aW9ucwBTZXRDb2xvckVkaXRPcHRpb25zAFNldEFsbG9jYXRvckZ1bmN0aW9ucwBSZW5kZXJXaW5kb3dEZWNvcmF0aW9ucwAlZCBhY3RpdmUgYWxsb2NhdGlvbnMATWV0cmljc0FjdGl2ZUFsbG9jYXRpb25zAG15Y29sdW1ucwBJbiBjb2x1bW5zACVkIGNvbHVtbnMAQmVnaW5Db2x1bW5zAEVuZENvbHVtbnMAVGFibGVzICYgQ29sdW1ucwAlLjA2ZiBucwBEcmFnIGFuZCBkcm9wIHRvIGNvcHkvc3dhcCBpdGVtcwBNaXhlZCBpdGVtcwBTaG93IGluZGVudGVkIGl0ZW1zACUuMTBmIGdyYW1zACVlIGdyYW1zACVJNjR1IG1zACV1IG1zAFRvb2xzAGZyZWV6ZV9jb2xzAERlYnVnIGRldGFpbHMARGV0YWlscwBwaXhlbHMAU2l6ZVBpeGVscwBUYWJsZVNldHVwRHJhd0NoYW5uZWxzAFRhYmxlTWVyZ2VEcmF3Q2hhbm5lbHMARXF1YWxzAE1vZGFscwBVcGRhdGVXaW5kb3dQYXJlbnRBbmRSb290TGlua3MAdXNtYmxrcwBmc21ibGtzAGhibGtzAHVvcmRibGtzAGZvcmRibGtzAEVycm9yQ2hlY2tOZXdGcmFtZVNhbml0eUNoZWNrcwBFcnJvckNoZWNrRW5kRnJhbWVTYW5pdHlDaGVja3MAQ29tcGxldGlvbiwgSGlzdG9yeSwgRWRpdCBDYWxsYmFja3MAQ29sdW1ucyB3aWR0aHMASW1HdWlUYWJsZUZsYWdzX1ByZWNpc2VXaWR0aHMAZ2x5cGhzAEl0ZXJhdGVHbHlwaHMAQ2xlYXIgc2V0dGluZ3MAV2FudFNhdmVJbmlTZXR0aW5ncwBUYWJsZVNhdmVTZXR0aW5ncwBVcGRhdGVTZXR0aW5ncwBUYWJsZUdldEJvdW5kU2V0dGluZ3MASW1HdWlUYWJsZUZsYWdzX05vU2F2ZWRTZXR0aW5ncwB0YWJsZV9jb2x1bW5zX2ZsYWdzAENvbHVtbnMgZmxhZ3MAVGFiSXRlbUJ1dHRvbiAmIExlYWRpbmcvVHJhaWxpbmcgZmxhZ3MAY2FsbGJhY2tfZGF0YS5GbGFncyA9PSBmbGFncwBDaGVja2JveEZsYWdzAFJhc3Rlcml6ZXJGbGFncwBUYWJsZUdldENvbHVtbkZsYWdzAFRhYmxlU2V0dXBDb2x1bW5GbGFncwBDb25maWdGbGFncwBCYWNrZW5kRmxhZ3MARHJhZy9TbGlkZXIgRmxhZ3MAQmFja2VuZCBGbGFncwBTY3JvbGxiYXJTaXplcwBTY2FsZUFsbFNpemVzAHRhYmxlX2NvbHVtbnNfZmxhZ3NfY2hlY2tib3hlcwBBbGwgcHJpbWl0aXZlcwBQcmltaXRpdmVzACMjdmFsdWVzAFJhdyBIU1YgdmFsdWVzAFNldHRpbmdzIHBhY2tlZCBkYXRhOiBXaW5kb3dzOiAlZCBieXRlcwBTZXR0aW5ncyBwYWNrZWQgZGF0YTogVGFibGVzOiAlZCBieXRlcwBTZXR0aW5ncyB1bnBhY2tlZCBkYXRhICguaW5pKTogJWQgYnl0ZXMAQnVmZmVyIGNvbnRlbnRzOiAlZCBsaW5lcywgJWQgYnl0ZXMAJXM6ICVkIGVudHJpZXMsICVkIGJ5dGVzADEyLDM0NSBieXRlcwAgMiwzNDUgYnl0ZXMAVGV4dHVyZXMARGF0YSBUeXBlcwBOdW1iZXIgb2YgbGluZXMAQnVsbGV0IHBvaW50IDIKT24gbXVsdGlwbGUgbGluZXMAQW50aS1hbGlhc2VkIGxpbmVzAEFkZCAxMDAwIGxpbmVzAFBsb3RMaW5lcwBBbnRpQWxpYXNlZExpbmVzAEZyYW1lIFRpbWVzAE1hbmlwdWxhdGluZyB3aW5kb3cgdGl0bGVzAEV4YW1wbGVzAFNob3cgd2luZG93cyByZWN0YW5nbGVzAFNob3cgdGFibGVzIHJlY3RhbmdsZXMAU2VsZWN0YWJsZXMATmVzdGVkIHRhYmxlcwBTaG93RGVtb1dpbmRvd1RhYmxlcwBTZXR0aW5nc1RhYmxlcwBbRGVidWddIEFkZCA1IGVudHJpZXMAU2l6aW5nIHBvbGljaWVzAEdseXBoUmFuZ2VzAGlvLkNvbmZpZ1dpbmRvd3NSZXNpemVGcm9tRWRnZXMASW1hZ2VzAEJhc2ljIHRyZWVzAFRyZWVzAEFkdmFuY2VkLCB3aXRoIFNlbGVjdGFibGUgbm9kZXMAVHJlZSBub2RlcwBOLWdvbiBzaWRlcwBTeW5jZWQgaW5zdGFuY2VzAE1ldHJpY3NSZW5kZXJWZXJ0aWNlcwBNZXRyaWNzUmVuZGVySW5kaWNlcwBZZXMARGVzACVzOiAnJXMnICVkIHZ0eCwgJWQgaW5kaWNlcywgJWQgY21kcwBJdGVyYXRlRHJhd0NtZHMAVGFibGVHZXRTb3J0U3BlY3MAQ29tcGFyZVdpdGhTb3J0U3BlY3MASW1HdWlUYWJsZVNvcnRTcGVjcwBJbUd1aVRhYmxlU29ydENvbHVtblNwZWNzACMjdGFicwBJbUd1aVRhYkJhckZsYWdzX0F1dG9TZWxlY3ROZXdUYWJzACMjVGFicwBjYW52YXMAQ2FudmFzAEZvbnREYXRhT3duZWRCeUF0bGFzAEltRm9udEF0bGFzAElzAAolKnMlLipzACAlLipzAEtleXMgbW9kczogJXMlcyVzJXMAU2Nyb2xsOiAoJS4yZi8lLjJmLCUuMmYvJS4yZikgU2Nyb2xsYmFyOiVzJXMAUG9wdXBJRDogJTA4eCwgV2luZG93OiAnJXMnJXMlcwBDb2x1bW5zR2l2ZW5XaWR0aDogJS4xZiwgQ29sdW1uc0F1dG9GaXRXaWR0aDogJS4xZiwgSW5uZXJXaWR0aDogJS4xZiVzACUuKnMlJWQlcwBkZWZpbmU6IF9fY2xhbmdfdmVyc2lvbl9fPSVzACVzIDB4JTA4WCAoJWQgdGFicyklcwBUYWJsZSAweCUwOFggKCVkIGNvbHVtbnMsIGluICclcycpJXMAJXMgJyVzJyVzAENvcHkgJXMAJXMgJWRweCAlcwAlcyAlcwBTd2FwICVzAERlYXIgSW1HdWkgJXMATW92ZSAlcwBTYXZlICVzACglNi4xZiwlNi4xZikgKCU2LjFmLCU2LjFmKSBTaXplICglNi4xZiwlNi4xZikgQ29sICVkICVzAE5hdkxhc3RDaGlsZE5hdldpbmRvdzogJXMAJSVzOiAlcwBpby5CYWNrZW5kUmVuZGVyZXJOYW1lOiAlcwBpby5CYWNrZW5kUGxhdGZvcm1OYW1lOiAlcwBOYXZJbnB1dFNvdXJjZTogJXMAQWN0aXZlSWQ6IDB4JTA4WC8weCUwOFggKCUuMmYgc2VjKSwgQWxsb3dPdmVybGFwOiAlZCwgU291cmNlOiAlcwBNb3VzZSBjdXJzb3IgJWQ6ICVzAEN1cnJlbnQgbW91c2UgY3Vyc29yID0gJWQ6ICVzAC0gJXMAKCU2LjFmLCU2LjFmKSAoJTYuMWYsJTYuMWYpIFNpemUgKCU2LjFmLCU2LjFmKSAlcwBGb3VyRm91ckZvdXIASXRlbSBGb3VyAGluZGV4X2Zyb21fcHRyAG9mZnNldF9mcm9tX3B0cgAjI015U3RyAEV4YW1wbGU6IFByb3BlcnR5IGVkaXRvcgBTaG93U3R5bGVFZGl0b3IARGVhciBJbUd1aSBTdHlsZSBFZGl0b3IAdmVjdG9yAFNob3dGb250U2VsZWN0b3IAU2hvd1N0eWxlU2VsZWN0b3IARm9udHMjI1NlbGVjdG9yAENvbG9ycyMjU2VsZWN0b3IAU2VwYXJhdG9yAGlvLk1vdXNlRHJhd0N1cnNvcgBTZXRNb3VzZUN1cnNvcgBHZXRNb3VzZUN1cnNvcgBSZW5kZXJNb3VzZUN1cnNvcgBlcnJvcgBDaXJjbGVTZWdtZW50TWF4RXJyb3IAQ2lyY2xlIFNlZ21lbnQgTWF4IEVycm9yAEFkZCBEZWJ1ZyBFcnJvcgAjI2NvbG9yAEJhY2tncm91bmQgY29sb3IAQWRkUmVjdEZpbGxlZE11bHRpQ29sb3IAVGFibGVTZXRCZ0NvbG9yACMjUmVmQ29sb3IAUG9wU3R5bGVDb2xvcgBQdXNoU3R5bGVDb2xvcgBXaXRoIFJlZiBDb2xvcgBUYWlsb3IAU2FpbG9yAFNsaWRlckJlaGF2aW9yAEJ1dHRvbkJlaGF2aW9yAERyYWdCZWhhdmlvcgBUcmVlTm9kZUJlaGF2aW9yAGRzdF9jb2x1bW4tPkRpc3BsYXlPcmRlciA9PSBkc3Rfb3JkZXIgLSByZW9yZGVyX2RpcgBBaXIAQ29ybmlmbG93ZXIASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlcgBMaXN0Qm94Rm9vdGVyAENlbnRlcgBGaWx0ZXIAQWRkSW5wdXRDaGFyYWN0ZXIAV2F0ZXIAS2V5U3VwZXIAfkltR3VpTGlzdENsaXBwZXIASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lcgBDb25maWdNZW1vcnlDb21wYWN0VGltZXIAbXlwaWNrZXIAIyNwcmV2aWV3aW5nX3BpY2tlcgAjI3BpY2tlcgBEZWFyIEltR3VpIE1ldHJpY3MvRGVidWdnZXIAYnVmZmVyAFZ0eEJ1ZmZlcgBJZHhCdWZmZXIAbG9uZ2VlZXIAX05vUmVvcmRlcgBUYWJCYXJRdWV1ZVJlb3JkZXIAV2luZG93Qm9yZGVyAFBvcHVwQm9yZGVyAEltR3VpQ29sb3JFZGl0RmxhZ3NfTm9Cb3JkZXIARnJhbWVCb3JkZXIAUmVzZXQgb3JkZXIAU2hvdyB3aW5kb3dzIGJlZ2luIG9yZGVyAGNvbHVtbi0+SW5kZXhXaXRoaW5FbmFibGVkU2V0IDw9IGNvbHVtbi0+RGlzcGxheU9yZGVyAFNvcnRPcmRlcgBSZW5kZXIARm9sZGVyAFNob3cgMm5kIGhlYWRlcgBDb2xsYXBzaW5nSGVhZGVyAFRhYmxlSGVhZGVyAG51bWJlcgBDdWN1bWJlcgBJbnB1dFNjYWxhcgBWU2xpZGVyU2NhbGFyAERyYWdTY2FsYXIAdW5zaWduZWQgY2hhcgBFdmVudENoYXIARWxsaXBzaXNDaGFyAFJlbmRlckNoYXIAUGF0aENsZWFyAE9oIGRlYXIAUGVhcgAjI21lbnViYXIASC1zY3JvbGxiYXIATm8gc2Nyb2xsYmFyAE5vIHRpdGxlYmFyAE1haW4gbWVudSBiYXIAVGFiIGJhcgBQb3BTdHlsZVZhcgBQdXNoU3R5bGVWYXIAQmVnaW5NZW51QmFyAEJlZ2luTWFpbk1lbnVCYXIARW5kTWFpbk1lbnVCYXIAIyNNYWluTWVudUJhcgBFbmRNZW51QmFyAHdpbmRvdy0+RmxhZ3MgJiBJbUd1aVdpbmRvd0ZsYWdzX01lbnVCYXIAUHJvZ3Jlc3NCYXIATXlUYWJCYXIAQmVnaW5UYWJCYXIARW5kVGFiQmFyACMjVGFiQmFyAFByb2dyZXNzIEJhcgBEZWZhdWx0OiBVaW50OCArIEhTViArIEh1ZSBCYXIAV2l0aCBBbHBoYSBCYXIAbXlfc2VsZWN0X3BvcHVwAG15X2ZpbGVfcG9wdXAAbXlfdG9nZ2xlX3BvcHVwAGFub3RoZXIgcG9wdXAASSBhbSBhIHRvb2x0aXAgb3ZlciBhIHBvcHVwAE15UG9wdXAAR2V0TW91c2VQb3NPbk9wZW5pbmdDdXJyZW50UG9wdXAAQ2xvc2VDdXJyZW50UG9wdXAARmluZEJlc3RXaW5kb3dQb3NGb3JQb3B1cABCZWdpblBvcHVwAE9wZW5Qb3B1cABFbmRQb3B1cAB3aW5kb3ctPkZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19Qb3B1cABTdGFja2VkIFBvcHVwAEJlZ2luR3JvdXAARW5kR3JvdXAAU3RyZHVwAC4uL2ltZ3VpX2RyYXcuY3BwAC4uL2ltZ3VpX3dpZGdldHMuY3BwAC4uL2ltZ3VpX3RhYmxlcy5jcHAALi4vaW1ndWlfZGVtby5jcHAASGVsbG8uY3BwAC4uL2ltZ3VpLmNwcABjY2MyLmNwcABiYmIyLmNwcABhYWEyLmNwcABDYXB0dXJlTW91c2VGcm9tQXBwAENhcHR1cmVLZXlib2FyZEZyb21BcHAASW1HdWlUYWJsZUZsYWdzX1NpemluZ1N0cmV0Y2hQcm9wAFdpdGggRHJhZyBhbmQgRHJvcABOaW5jb21wb29wAENob3AAVG9wAFRyZWVQb3AASW1HdWlTbGlkZXJGbGFnc19BbHdheXNDbGFtcABEYXRhVHlwZUNsYW1wAEhlbHAASSBhbSBhIGZhbmN5IHRvb2x0aXAASSBhbSBhIHRvb2x0aXAAU2V0VG9vbHRpcABCZWdpblRvb2x0aXAARW5kVG9vbHRpcABHZXRDdXJyZW50V2luZG93UmVhZCgpLT5GbGFncyAmIEltR3VpV2luZG93RmxhZ3NfVG9vbHRpcABSZXNpemVHcmlwAExvbmcgdGV4dCB0aGF0IGlzIGxpa2VseSB0byBjbGlwAEltR3VpVGFibGVGbGFnc19Ob0NsaXAAU3RlcABTd2FwAFNldEl0ZW1BbGxvd092ZXJsYXAAX3NldEF0X0tleU1hcABfZ2V0QXRfS2V5TWFwAERhdGFUeXBlQXBwbHlPcABDYWxsYmFjayAlcCwgdXNlcl9kYXRhICVwAC9wYXRoL3R3bwBUd29Ud29Ud28ASXRlbSBUd28AVG9tYXRvAFNldCB0byB6ZXJvAGZvbwBEZWFyIEltR3VpIERlbW8AVHdvIGl0ZW1zOiBIZWxsbwBNb3JlIHNwYWNpbmc6IEhlbGxvAFNjcm9sbFRhcmdldENlbnRlclJhdGlvAE1hbmdvAG1hbGxpbmZvAERhdGFUeXBlR2V0SW5mbwBHZXRTdHlsZVZhckluZm8AVW5kbwBzdGJfdGV4dGVkaXRfZGlzY2FyZF9yZWRvAFJlZG8AQXZvY2FkbwBPbmx5IG1ha2VzIGEgZGlmZmVyZW5jZSBpZiB0aGUgcG9wdXAgaXMgbGFyZ2VyIHRoYW4gdGhlIGNvbWJvAEJlZ2luQ29tYm8ARW5kQ29tYm8ASVRFTTogQ29tYm8AUGF0aEJlemllclF1YWRyYXRpY0N1cnZlVG8AUGF0aEJlemllckN1YmljQ3VydmVUbwBQYXRoTGluZVRvAFBhdGhBcmNUbwBGb250Tm8AU3RlcE5vAEJyeW4AVW5rbm93bgBJc0tleURvd24AX3NldEF0X0tleXNEb3duAF9nZXRBdF9LZXlzRG93bgBJbUd1aVRhYkJhckZsYWdzX0ZpdHRpbmdQb2xpY3lSZXNpemVEb3duAElzQW55TW91c2VEb3duAElzTW91c2VEb3duAF9zZXRBdF9Nb3VzZURvd24AX2dldEF0X01vdXNlRG93bgAjU291cmNlRXh0ZXJuAHdhcm4ASGVhZGVyIHdpdGggYSBjbG9zZSBidXR0b24AdGhpcyBpcyBhIDMwMC13aWRlIGJ1dHRvbgBJbUd1aUNvbWJvRmxhZ3NfTm9BcnJvd0J1dHRvbgAjI0NvbG9yQnV0dG9uAEltR3VpVGFiQmFyRmxhZ3NfVGFiTGlzdFBvcHVwQnV0dG9uAFRhYkl0ZW1CdXR0b24ARmlsbEJ1dHRvbgBTbWFsbEJ1dHRvbgBJbUd1aVRhYkJhckZsYWdzX05vQ2xvc2VXaXRoTWlkZGxlTW91c2VCdXR0b24AVGFiTWluV2lkdGhGb3JDbG9zZUJ1dHRvbgBJbnZpc2libGVCdXR0b24ASW1hZ2VCdXR0b24AQnV0dG9uOiAlcyMjI0J1dHRvbgBBZHZhbmNlZCAmIENsb3NlIEJ1dHRvbgBJVEVNOiBCdXR0b24AV2F0ZXJtZWxvbgBEYWlrb24ARGVzY3JpcHRpb24Ac3RkOjpleGNlcHRpb24AU29tZU9wdGlvbgBBbGlnbiBsYWJlbCB3aXRoIGN1cnJlbnQgWCBwb3NpdGlvbgBXaW5kb3dNZW51QnV0dG9uUG9zaXRpb24AQ29sb3JCdXR0b25Qb3NpdGlvbgBDb21wbGV0aW9uAFRhYmxlR2V0Q29sdW1uTmV4dFNvcnREaXJlY3Rpb24AVGFibGVTZXRDb2x1bW5Tb3J0RGlyZWN0aW9uAFRhYmxlR2V0Q29sdW1uQXZhaWxTb3J0RGlyZWN0aW9uAEhhc1NlbGVjdGlvbgBTZWxlY3Rpb24gU3RhdGU6IE11bHRpcGxlIFNlbGVjdGlvbgBTZWxlY3Rpb24gU3RhdGU6IFNpbmdsZSBTZWxlY3Rpb24AQWN0aW9uAERpc2FibGUgdHJlZSBpbmRlbnRhdGlvbgBDb25maWd1cmF0aW9uAF9nZXRBdF9LZXlzRG93bkR1cmF0aW9uAF9nZXRBdF9OYXZJbnB1dHNEb3duRHVyYXRpb24AX2dldEF0X01vdXNlRG93bkR1cmF0aW9uAERlY29yYXRpb24AQ29uZmlnL0J1aWxkIEluZm9ybWF0aW9uAEdldFZlcnNpb24AJTA0ZDogc2Nyb2xsYWJsZSByZWdpb24AIyNTY3JvbGxpbmdSZWdpb24AQWRkTmdvbgBUcmVlIGluIGNvbHVtbgBUYWJsZU5leHRDb2x1bW4AVGFibGVTZXR1cENvbHVtbgAjI21pbgAoKGNoYXIqKShzdGF0ZS0+dW5kb19yZWMgKyBzdGF0ZS0+cmVkb19wb2ludCkpID49IGJ1Zl9iZWdpbgBMb2dCZWdpbgBNYWluAEdldENsaXBSZWN0TWluAEdldEl0ZW1SZWN0TWluAEdldFdpbmRvd0NvbnRlbnRSZWdpb25NaW4AcmlnaHQtYWxpZ24AQnV0dG9uVGV4dEFsaWduAFNlbGVjdGFibGVUZXh0QWxpZ24AV2luZG93VGl0bGVBbGlnbgBDb2x1bW5zQ29udGVudFVuZnJvemVuAENvbHVtbnNDb250ZW50RnJvemVuAEl0ZW1zRnJvemVuAElzUG9wdXBPcGVuAFNldE5leHRJdGVtT3BlbgBJc0l0ZW1Ub2dnbGVkT3BlbgBwb3MgPD0gdGV4dF9sZW4AUHVzaENsaXBSZWN0RnVsbFNjcmVlbgBIaWRkZW4AcG9zICsgYnl0ZXNfY291bnQgPD0gQnVmVGV4dExlbgBuYW4AU2V0Q2xpcGJvYXJkVGV4dEZuAEdldENsaXBib2FyZFRleHRGbgBXZWlnaHQ9JWYlbgBPcmRlcj0lZCVuAFdpZHRoPSVkJW4AVmlzaWJsZT0lZCVuAENvbHVtbiAlZCVuAFNvcnQ9JWQlYyVuAFVzZXJJRD0weCUwOFglbgBzbGlkZXIgZW51bQBQbHVtAEFxdWFyaXVtAEJvdHRvbQBDdXN0b20AIyNpdGVtAFNvbWUgbWVudSBpdGVtAE1lbnUgaXRlbQBUZXh0IGFsaWduZWQgdG8gZnJhbWVkIGl0ZW0AU29tZSBmcmFtZWQgaXRlbQBJVEVNOiBNZW51SXRlbQBCZWdpblBvcHVwQ29udGV4dEl0ZW0ATmF2U2NvcmVJdGVtAEJlZ2luVGFiSXRlbQBFbmRUYWJJdGVtAFBsb3RIaXN0b2dyYW0AQnJlYW0AS2V5Q3RybABib29sAEN1cnZlVGVzc2VsbGF0aW9uVG9sAGZpc2hfaGF0LmlubABzbGlkZXIgdTggZnVsbABzbGlkZXIgczggZnVsbABzbGlkZXIgdTE2IGZ1bGwAc2xpZGVyIHMxNiBmdWxsAHNsaWRlciB1NjQgZnVsbABzbGlkZXIgczY0IGZ1bGwAc2xpZGVyIHUzMiBmdWxsAHNsaWRlciBzMzIgZnVsbABTaXplRnVsbABBdXRvLXNjcm9sbABJbUd1aVRhYkJhckZsYWdzX0ZpdHRpbmdQb2xpY3lTY3JvbGwAQW50aS1hbGlhc2VkIGZpbGwAQW50aUFsaWFzZWRGaWxsACMjY2VsbABzbWFsbAAjI2NoZWNrYWxsAE9wZW4gYWxsAFJlbW92ZSBhbGwAQ2xvc2UgYWxsAFJlc2l6ZUFsbABTaXplIGFsbCBjb2x1bW5zIHRvIGRlZmF1bHQjIyNTaXplQWxsAFNpemUgYWxsIGNvbHVtbnMgdG8gZml0IyMjU2l6ZUFsbABXaW5kb3dTZXR0aW5nc0hhbmRsZXJfV3JpdGVBbGwAR2V0Q29udGVudFJlZ2lvbkF2YWlsAGJ5dGVzX3Blcl9waXhlbABHZXRGb250VGV4VXZXaGl0ZVBpeGVsAENsb3NlUG9wdXBUb0xldmVsAE1hY2tlcmVsAFNldEN1cnJlbnRDaGFubmVsAE1vdXNlV2hlZWwARGVmYXVsdDogRmxvYXQgKyBIRFIgKyBIdWUgV2hlZWwARGlzYWJsZSBNb3VzZSBXaGVlbABDYW5jZWwAbGFiZWwAZW1zY3JpcHRlbjo6dmFsAGhvcml6b250YWwAIyNvcmlnaW5hbABPcmlnaW5hbABoZXhhZGVjaW1hbABDb250ZW50SWRlYWwAQ29sdW1uc0NvbnRlbnRIZWFkZXJzSWRlYWwAQ29udGVudFNpemVJZGVhbABCZWdpblBvcHVwTW9kYWwAdmVydGljYWwAU2F2ZSB0byBkaXNrAENoZWNrTWFyawBTdHlsZUNvbG9yc0RhcmsAbmV4dF9jaHVuawBzaHJpbmsAaW8uQ29uZmlnSW5wdXRUZXh0Q3Vyc29yQmxpbmsAUGluawBubyBibGFuawBQb2xsb2NrAEhhZGRvY2sAT3BlblBvcHVwT25JdGVtQ2xpY2sASVRFTTogVHJlZU5vZGUgdy8gSW1HdWlUcmVlTm9kZUZsYWdzX09wZW5PbkRvdWJsZUNsaWNrAFRyYWNrAEZpbmRHbHlwaE5vRmFsbGJhY2sATXlSZXNpemVDYWxsYmFjawBBZGRDYWxsYmFjawBSZXNpemUgQ2FsbGJhY2sAcG9wX2JhY2sAS2l3aQBpbWd1aQBBYm91dCBEZWFyIEltR3VpAEltR3VpVGFibGVGbGFnc19Tb3J0TXVsdGkAZGVza3RvcC5pbmkAaW1ndWkuaW5pACMjSW5pAEJyb2Njb2xpAEJpYmkAUG9zPSVpLCVpAFNpemU9JWksJWkARWFydGgARGVmYXVsdCBEZXB0aABCb3RoAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGJ5dGVMZW5ndGgAaW5uZXJfd2lkdGgAdGFibGVfaXRlbV93aWR0aABXcmFwIHdpZHRoAEl0ZW0gd2lkdGgAVGV4V2lkdGgAR2V0V2luZG93V2lkdGgAX05vSGVhZGVyV2lkdGgAR2V0V2luZG93Q29udGVudFJlZ2lvbldpZHRoAFRhYmxlU2V0Q29sdW1uV2lkdGgAR2V0Q29sdW1uV2lkdGgAVGFibGVVcGRhdGVDb2x1bW5zV2VpZ2h0RnJvbVdpZHRoAFNldE5leHRJdGVtV2lkdGgAUG9wSXRlbVdpZHRoAFB1c2hJdGVtV2lkdGgAQ2FsY0l0ZW1XaWR0aABJbUd1aVRyZWVOb2RlRmxhZ3NfU3BhbkZ1bGxXaWR0aABJbUd1aVRyZWVOb2RlRmxhZ3NfU3BhbkF2YWlsV2lkdGgAV2lkZ2V0cyBXaWR0aABQYXRoACNUcmVlUHVzaABMb2dGaW5pc2gAVGlsZWZpc2gAZ2x5cGgASW1Gb250R2x5cGgAQ3JlYXRlR2x5cGgARmluZEdseXBoAGFhYWFhYWFhIGJiYmJiYmJiLCBjIGNjY2NjY2NjLGRkZGRkZGRkLiBkIGVlZWVlZWVlICAgZmZmZmZmZmYuIGdnZ2dnZ2dnIWhoaGhoaGhoAHNsaWRlciBmbG9hdCBoaWdoAHNsaWRlciBkb3VibGUgaGlnaABzbGlkZXIgdTY0IGhpZ2gAc2xpZGVyIHM2NCBoaWdoAHNsaWRlciB1MzIgaGlnaABzbGlkZXIgczMyIGhpZ2gAUmVzaXphYmxlLCBzdHJldGNoAF9XaWR0aFN0cmV0Y2gAbXkgc2FpbG9yIGlzIHJpY2gAUmljaABLTyBCbGFoYmxhaABPSyBCbGFoYmxhaABUaGlzIGlzIHRoZSBDdWN1bWJlciB0YWIhCmJsYWggYmxhaCBibGFoIGJsYWggYmxhaABUaGlzIGlzIHRoZSBBdm9jYWRvIHRhYiEKYmxhaCBibGFoIGJsYWggYmxhaCBibGFoAFRoaXMgaXMgdGhlIEJyb2Njb2xpIHRhYiEKYmxhaCBibGFoIGJsYWggYmxhaCBibGFoAEJsYWggYmxhaCBibGFoAEJsYWggYmxhaApCbGFoIEJsYWgALi4vaW1zdGJfdGV4dGVkaXQuaABmaXNoX2hhdC5oAEhlbGxvLmgALi4vaW1ndWlfaW50ZXJuYWwuaAAuLlxpbWd1aS5oAC4uL2ltZ3VpLmgAYWJjLmgAc2xpZGVyIGZsb2F0IGxvdyBsb2cAc2xpZGVyIGRvdWJsZSBsb3cgbG9nAGRyYWcgZmxvYXQgbG9nAGRyYWcgZG91YmxlIGxvZwAlaSBUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nAEV4YW1wbGU6IExvZwBDb3B5IG9mIEltYWdlMDAxLnBuZwBDb3B5IG9mIEltYWdlMDAxIChGaW5hbDIpLnBuZwBbZXJyb3JdIHNvbWV0aGluZyB3ZW50IHdyb25nAFRhYmxlQm9yZGVyU3Ryb25nAHVuc2lnbmVkIGxvbmcASG92ZXJlZC9BY3RpdmUgdGVzdHMgYWZ0ZXIgQmVnaW4oKSBmb3IgdGl0bGUgYmFyIHRlc3RpbmcAdGFibGVfc29ydGluZwBTb3J0aW5nAHN0ZDo6d3N0cmluZwBiYXNpY19zdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcARGF0YVR5cGVGb3JtYXRTdHJpbmcAU2hvdyBJbURyYXdDbWQgYm91bmRpbmcgYm94ZXMgd2hlbiBob3ZlcmluZwBTaG93IEltRHJhd0NtZCBtZXNoIHdoZW4gaG92ZXJpbmcARmlsdGVyaW5nAEV4YW1wbGU6IEN1c3RvbSByZW5kZXJpbmcAUmVuZGVyaW5nAElzV2luZG93QXBwZWFyaW5nAFZlcnRpY2FsIHNjcm9sbGluZywgd2l0aCBjbGlwcGluZwBDYWxjTGlzdENsaXBwaW5nAHdvcmQtd3JhcHBpbmcAV29yZC13cmFwcGluZwBXb3JkIFdyYXBwaW5nAEhvcml6b250YWwgc2Nyb2xsaW5nACMjSG9yaXpvbnRhbFNjcm9sbGluZwAjI1ZlcnRpY2FsU2Nyb2xsaW5nAEhvcml6b250YWwgU2Nyb2xsaW5nAExheW91dCAmIFNjcm9sbGluZwBGb250QWxsb3dVc2VyU2NhbGluZwBDYXB0dXJlL0xvZ2dpbmcASXNNb3VzZURyYWdnaW5nAFdpbmRvd1JvdW5kaW5nAFNjcm9sbGJhclJvdW5kaW5nAFBvcHVwUm91bmRpbmcARnJhbWVSb3VuZGluZwBDaGlsZFJvdW5kaW5nAEdyYWJSb3VuZGluZwBUYWJSb3VuZGluZwAhd2luZG93LT5EQy5NZW51QmFyQXBwZW5kaW5nAF9QcmVmZXJTb3J0RGVzY2VuZGluZwBfTm9Tb3J0RGVzY2VuZGluZwBfUHJlZmVyU29ydEFzY2VuZGluZwBfTm9Tb3J0QXNjZW5kaW5nAHRhYmxlX3BhZGRpbmcARGlzcGxheVdpbmRvd1BhZGRpbmcAQ2VsbFBhZGRpbmcAQWxpZ25UZXh0VG9GcmFtZVBhZGRpbmcAVG91Y2hFeHRyYVBhZGRpbmcARGlzcGxheVNhZmVBcmVhUGFkZGluZwBTYWZlIEFyZWEgUGFkZGluZwBJbmRlbnRTcGFjaW5nAEl0ZW1Jbm5lclNwYWNpbmcAQ29sdW1uc01pblNwYWNpbmcASXRlbVNwYWNpbmcAR2V0VHJlZU5vZGVUb0xhYmVsU3BhY2luZwBHZXRUZXh0TGluZUhlaWdodFdpdGhTcGFjaW5nAEdldEZyYW1lSGVpZ2h0V2l0aFNwYWNpbmcAR2x5cGhFeHRyYVNwYWNpbmcAVGFiYmluZwBJbUZvbnRDb25maWcAJS4wZiBkZWcAc2hvd193aWRnZXRfZnJhbWVfYmcASG9sZGluZyBtZSBjbGVhcnMgdGhlCnRoZSBrZXlib2FyZCBjYXB0dXJlIGZsYWcASG92ZXJpbmcgbWUgc2V0cyB0aGUKa2V5Ym9hcmQgY2FwdHVyZSBmbGFnAE5hdlVwZGF0ZUFueVJlcXVlc3RGbGFnAEV2ZW50RmxhZwBQb3BJdGVtRmxhZwBQdXNoSXRlbUZsYWcAV2luZG93QmcAVGFibGVSb3dCZwBJbUd1aVRhYmxlRmxhZ3NfUm93QmcAVGFibGVIZWFkZXJCZwBTY3JvbGxiYXJCZwBNZW51QmFyQmcAUG9wdXBCZwBNb2RhbFdpbmRvd0RpbUJnAE5hdldpbmRvd2luZ0RpbUJnAEZyYW1lQmcAVGl0bGVCZwBDaGlsZEJnAFRleHRTZWxlY3RlZEJnACVkOiAlOC40ZwolZDogJTguNGcAYnVmAG15X3N0ci0+YmVnaW4oKSA9PSBkYXRhLT5CdWYAaW5mAEFsaWduIHRvIHJpZ2h0IGVkZ2UgbWludXMgaGFsZgAlbGYAc2Fucy1zZXJpZgAjI29mZgBSZXZlcnQgUmVmAFNhdmUgUmVmACUuOGYAIFdlaWdodD0lLjRmAFY6JTAuM2YAUzolMC4zZgBSOiUwLjNmAEg6JTAuM2YARzolMC4zZgBCOiUwLjNmAEE6JTAuM2YAcmF0aW8gPSAlLjNmACVzOiAlLjNmAEg6ICUuM2YsIFM6ICUuM2YsIFY6ICUuM2YASDogJS4zZiwgUzogJS4zZiwgVjogJS4zZiwgQTogJS4zZgAlLjAyZgBzdHlsZS5XaW5kb3dQYWRkaW5nOiAlLjJmLCUuMmYAc3R5bGUuRnJhbWVQYWRkaW5nOiAlLjJmLCUuMmYAc3R5bGUuSXRlbUlubmVyU3BhY2luZzogJS4yZiwlLjJmAHN0eWxlLkl0ZW1TcGFjaW5nOiAlLjJmLCUuMmYAaW8uRGlzcGxheVNpemU6ICUuMmYsJS4yZgBpby5EaXNwbGF5RnJhbWVidWZmZXJTY2FsZTogJS4yZiwlLjJmAE9mZnNldCAlLjJmAFNldHRpbmdzRGlydHlUaW1lciAlLjJmAEF2YWlsICUuMmYAV2lkdGggJS4yZgBbJWRdICUuMmYAbWluX3Jvd19oZWlnaHQgPSAlLjJmAHN0eWxlLkZyYW1lUm91bmRpbmc6ICUuMmYAc3R5bGUuV2luZG93Qm9yZGVyU2l6ZTogJS4yZgBzdHlsZS5GcmFtZUJvcmRlclNpemU6ICUuMmYATXlDb2xvciMjMmYAU2Nyb2xsICUuMWYvJS4xZiAlLjFmLyUuMWYAJTAyZCVjIFRhYiAweCUwOFggJyVzJyBPZmZzZXQ6ICUuMWYsIFdpZHRoOiAlLjFmLyUuMWYAaW8uQ29uZmlnTWVtb3J5Q29tcGFjdFRpbWVyID0gJS4xZgBNb3VzZSB3aGVlbDogJS4xZgBDZWxsUGFkZGluZ1g6ICUuMWYsIENlbGxTcGFjaW5nWDogJS4xZi8lLjFmLCBPdXRlclBhZGRpbmdYOiAlLjFmAEFkdmFuY2VYOiAlLjFmAFc6ICUuMWYAJS4xMGYAKihjb25zdCBmbG9hdCopcF9taW4gPj0gLTMuNDAyODIzNDdlKzM4RiAvIDIuMGYgJiYgKihjb25zdCBmbG9hdCopcF9tYXggPD0gMy40MDI4MjM0N2UrMzhGIC8gMi4wZgAqKGNvbnN0IGRvdWJsZSopcF9taW4gPj0gLTEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4IC8gMi4wZiAmJiAqKGNvbnN0IGRvdWJsZSopcF9tYXggPD0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDggLyAyLjBmAGNlbnRlcl95X3JhdGlvID49IDAuMGYgJiYgY2VudGVyX3lfcmF0aW8gPD0gMS4wZgBjZW50ZXJfeF9yYXRpbyA+PSAwLjBmICYmIGNlbnRlcl94X3JhdGlvIDw9IDEuMGYAY29sdW1uLT5TdHJldGNoV2VpZ2h0ID4gMC4wZgBJdGVtc0hlaWdodCA+IDAuMGYAdmlzaWJsZV93ZWlnaHQgPiAwLjBmICYmIHZpc2libGVfd2lkdGggPiAwLjBmAGNvbHVtbl8wX3dpZHRoID4gMC4wZiAmJiBjb2x1bW5fMV93aWR0aCA+IDAuMGYAdGFiLT5Db250ZW50V2lkdGggPiAwLjBmAHRhYmxlLT5NaW5Db2x1bW5XaWR0aCA+IDAuMGYAc2Nyb2xsYmFyX3NpemUgPiAwLjBmAHNjYWxlID4gMC4wZgBmb250LT5TY2FsZSA+IDAuMGYASW1NYXgoc2l6ZV9jb250ZW50c192LCBzaXplX2F2YWlsX3YpID4gMC4wZgBpbm5lcl93aWR0aCA+PSAwLjBmAHRhYmxlLT5Jbm5lcldpbmRvdy0+V2luZG93UGFkZGluZy54ID09IDAuMGYgJiYgdGFibGUtPklubmVyV2luZG93LT5XaW5kb3dQYWRkaW5nLnkgPT0gMC4wZiAmJiB0YWJsZS0+SW5uZXJXaW5kb3ctPldpbmRvd0JvcmRlclNpemUgPT0gMC4wZgBJdGVtc0hlaWdodCA8PSAwLjBmAHNpemVfYXJnLnggIT0gMC4wZiAmJiBzaXplX2FyZy55ICE9IDAuMGYAJS4wZnglLjBmACVzCiUuMGYvJS4wZgBSZWZTY2FsZT0lZgBhdmcgJWYAQXNjZW50OiAlZiwgRGVzY2VudDogJWYsIEhlaWdodDogJWYAVW5kZXJseWluZyBmbG9hdCB2YWx1ZTogJWYAVGFibGVTb3J0U3BlY3NTYW5pdGl6ZQBBdXRvLXJlc2l6ZQBObyByZXNpemUAQWx3YXlzQXV0b1Jlc2l6ZQBfTm9SZXNpemUASW1HdWlUYWJsZUZsYWdzX05vQm9yZGVyc0luQm9keVVudGlsUmVzaXplAEV4YW1wbGU6IENvbnN0cmFpbmVkIFJlc2l6ZQBvdXRlcl9zaXplAGFwcGx5X25ld190ZXh0X2xlbmd0aCA8PSBidWZfc2l6ZQBFeHBsaWNpdCBjb250ZW50IHNpemUAT3V0ZXIgc2l6ZQBJbml0aWFsaXplAERpc3BsYXlTaXplAEltRHJhd0lkeFNpemUAU2V0TmV4dFdpbmRvd1NpemUAU2V0V2luZG93U2l6ZQBHZXRXaW5kb3dTaXplAENhbGNUZXh0U2l6ZQBJbURyYXdWZXJ0U2l6ZQBHZXRGb250U2l6ZQBTZXROZXh0V2luZG93Q29udGVudFNpemUAQ3VycmVudFNpemUAR2V0SXRlbVJlY3RTaXplACMjT3V0ZXJTaXplAFdpbmRvd0JvcmRlclNpemUAUG9wdXBCb3JkZXJTaXplAEZyYW1lQm9yZGVyU2l6ZQBDaGlsZEJvcmRlclNpemUAVGFiQm9yZGVyU2l6ZQBTY3JvbGxiYXJTaXplAFdpbmRvd01pblNpemUAR3JhYk1pblNpemUAQnVmU2l6ZQBTZXRXaW5kb3dOYW1lU2l6ZQBJbUd1aVN0eWxlU2l6ZQBEZXNpcmVkU2l6ZQBJbUd1aUlPU2l6ZQBJbVZlYzRTaXplAEltVmVjMlNpemUAZy5XaW5kb3dzRm9jdXNPcmRlci5TaXplID09IGcuV2luZG93cy5TaXplAGNvbHVtbl9pbmRleCA8IGNvbHVtbnMtPkNvbHVtbnMuU2l6ZQAoaW50KWRyYXdfbGlzdC0+X1Z0eEN1cnJlbnRJZHggPT0gZHJhd19saXN0LT5WdHhCdWZmZXIuU2l6ZQBkcmF3X2xpc3QtPlZ0eEJ1ZmZlci5TaXplID09IDAgfHwgZHJhd19saXN0LT5fVnR4V3JpdGVQdHIgPT0gZHJhd19saXN0LT5WdHhCdWZmZXIuRGF0YSArIGRyYXdfbGlzdC0+VnR4QnVmZmVyLlNpemUAZHJhd19saXN0LT5JZHhCdWZmZXIuU2l6ZSA9PSAwIHx8IGRyYXdfbGlzdC0+X0lkeFdyaXRlUHRyID09IGRyYXdfbGlzdC0+SWR4QnVmZmVyLkRhdGEgKyBkcmF3X2xpc3QtPklkeEJ1ZmZlci5TaXplAGcuV2luZG93cy5TaXplID09IGcuV2luZG93c1RlbXBTb3J0QnVmZmVyLlNpemUAZHN0X3RtcCA9PSBnLkRyYXdDaGFubmVsc1RlbXBNZXJnZUJ1ZmZlci5EYXRhICsgZy5EcmF3Q2hhbm5lbHNUZW1wTWVyZ2VCdWZmZXIuU2l6ZQByZW1haW5pbmcgPj0gMCAmJiByZW1haW5pbmcgPCBnLk9wZW5Qb3B1cFN0YWNrLlNpemUAdGFiLT5OYW1lT2Zmc2V0ICE9IC0xICYmIChpbnQpdGFiLT5OYW1lT2Zmc2V0IDwgVGFic05hbWVzLkJ1Zi5TaXplAG9mZiA+PSA0ICYmIG9mZiA8IEJ1Zi5TaXplAHAgPj0gQnVmLkRhdGEgJiYgcCA8IEJ1Zi5EYXRhICsgQnVmLlNpemUAdGV4dF9sZW4gPCBvYmotPlRleHRXLlNpemUAbmV3X3NpemUgPD0gU2l6ZQBpID49IDAgJiYgaSA8IFNpemUAaXQgPj0gRGF0YSAmJiBpdCA8PSBEYXRhICsgU2l6ZQBpdCA+PSBEYXRhICYmIGl0IDwgRGF0YSArIFNpemUAVGFibGVTZXR1cFNjcm9sbEZyZWV6ZQBDdXJ2ZQBQcmltVW5yZXNlcnZlAFByaW1SZXNlcnZlAE5vIG1vdmUATW92ZQBOYXZBY3RpdmUAV2FzQWN0aXZlAFNlcGFyYXRvckFjdGl2ZQBIZWFkZXJBY3RpdmUAZy5BY3RpdmVJZCA9PSBpZCB8fCBnLkFjdGl2ZUlkID09IDAgfHwgZy5EcmFnRHJvcEFjdGl2ZQBSZXNpemVHcmlwQWN0aXZlAEJ1dHRvbkFjdGl2ZQBJc0FueUl0ZW1BY3RpdmUASXNJdGVtQWN0aXZlAEZyYW1lQmdBY3RpdmUAVGl0bGVCZ0FjdGl2ZQBUYWJVbmZvY3VzZWRBY3RpdmUAU2xpZGVyR3JhYkFjdGl2ZQBTY3JvbGxiYXJHcmFiQWN0aXZlAFRhYkFjdGl2ZQBwYXJlbnRfd2luZG93ICYmIHBhcmVudF93aW5kb3ctPkFjdGl2ZQBJdGVtIEZpdmUAU2F2ZQBnLkN1cnJlbnRXaW5kb3ctPklzRmFsbGJhY2tXaW5kb3cgPT0gdHJ1ZQBPcGFxdWUAYmx1ZQAjI3ZhbHVlACMjVmFsdWUAaHVlACMjcGFsZXR0ZQBQYWxldHRlAFBhc3RlAEltR3VpVGFibGVGbGFnc19Tb3J0VHJpc3RhdGUASW50ZXJuYWwgc3RhdGUAR2V0SW5wdXRUZXh0U3RhdGUASW1HdWlJbnB1dFRleHRTdGF0ZQBDb21wYXJlV2l0aEN1cnJlbnRTdGF0ZQBLZXlib2FyZCwgTW91c2UgJiBOYXZpZ2F0aW9uIFN0YXRlAEZyYW1lcmF0ZQBBbmltYXRlAEFic3F1YXR1bGF0ZQBJdGVyYXRlR2x5cGhUb0NyZWF0ZQBOYXZVcGRhdGUAUGF0aExpbmVUb01lcmdlRHVwbGljYXRlAEtleVJlcGVhdFJhdGUASW5pU2F2aW5nUmF0ZQBpby5Db25maWdGbGFnczogTm9Nb3VzZQBXYW50Q2FwdHVyZU1vdXNlAHNsaWRlciB1OCByZXZlcnNlAHNsaWRlciBzOCByZXZlcnNlAHNsaWRlciB1NjQgcmV2ZXJzZQBzbGlkZXIgczY0IHJldmVyc2UAc2xpZGVyIHUzMiByZXZlcnNlAHNsaWRlciBzMzIgcmV2ZXJzZQBObyBjb2xsYXBzZQBObyBjbG9zZQBDbG9zZQBnLkRyYWdEcm9wV2l0aGluVGFyZ2V0ID09IGZhbHNlAHRhYmxlLT5Jc1VuZnJvemVuUm93cyA9PSBmYWxzZQBnLldpdGhpbkVuZENoaWxkID09IGZhbHNlAHRhYmxlLT5NZW1vcnlDb21wYWN0ZWQgPT0gZmFsc2UAZy5Mb2dFbmFibGVkID09IGZhbHNlAHRhYmxlICE9IDBMICYmIHRhYmxlLT5Jc0xheW91dExvY2tlZCA9PSBmYWxzZQBlcmFzZQB1cHBlcmNhc2UAQXRsYXMgdGV4dHVyZQBBbnRpLWFsaWFzZWQgbGluZXMgdXNlIHRleHR1cmUARmlyZQBlbnRlciB0ZXh0IGhlcmUAVG9vbHRpcCBoZXJlAFNldEtleWJvYXJkRm9jdXNIZXJlAEN1c3RvbTogQWx3YXlzIFNxdWFyZQBEYXRhVHlwZUNvbXBhcmUAIyNvdXRwdXRfdHlwZQAjI3Nob3dfd2luZG93c19yZWN0X3R5cGUAIyNzaG93X3RhYmxlX3JlY3RzX3R5cGUAVGVzdCB0eXBlAHJvdyBiZyB0eXBlAGNlbGwgYmcgdHlwZQBJdGVtIFR5cGUAZy5XaXRoaW5GcmFtZVNjb3BlAExvZ1NsaWRlckRlYWR6b25lAHRhcmdldCAhPSBJbUd1aVRhYmxlQmdUYXJnZXRfTm9uZQBnLk5hdk1vdmVEaXIgIT0gSW1HdWlEaXJfTm9uZSAmJiBnLk5hdk1vdmVDbGlwRGlyICE9IEltR3VpRGlyX05vbmUAc29ydF9kaXJlY3Rpb24gIT0gSW1HdWlTb3J0RGlyZWN0aW9uX05vbmUAZy5OYXZNb3ZlUmVxdWVzdEZvcndhcmQgPT0gSW1HdWlOYXZGb3J3YXJkX05vbmUAL3BhdGgvb25lAExpa2UgdGhpcyBvbmUAUmVtb3ZlIG9uZQBBZGRQb2x5bGluZQBJbnB1dFRleHRNdWx0aWxpbmUAUmVuZGVyaW5nIG1vcmUgdGV4dCBpbnRvIHRoZSBzYW1lIGxpbmUAQnkgZGVmYXVsdCwgU2VsZWN0YWJsZXMgdXNlcyBzdHlsZS5TZWxlY3RhYmxlVGV4dEFsaWduIGJ1dCBpdCBjYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIHBlci1pdGVtIGJhc2lzIHVzaW5nIFB1c2hTdHlsZVZhcigpLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byBhbHdheXMga2VlcCB5b3VyIGRlZmF1bHQgc2l0dWF0aW9uIHRvIGxlZnQtYWxpZ24gb3RoZXJ3aXNlIGl0IGJlY29tZXMgZGlmZmljdWx0IHRvIGxheW91dCBtdWx0aXBsZSBpdGVtcyBvbiBhIHNhbWUgbGluZQBCbGFpbmUASW1HdWlJbnB1dFRleHRGbGFnc19DdHJsRW50ZXJGb3JOZXdMaW5lAFNhbWVMaW5lAEFkZExpbmUAbGVmdCBwYW5lAFNpemUgY29sdW1uIHRvIGZpdCMjI1NpemVPbmUAT25lT25lT25lAEl0ZW0gT25lAERvbid0IGFzayBtZSBuZXh0IHRpbWUAR2V0VGltZQBNb3VzZURvdWJsZUNsaWNrVGltZQBEZWx0YVRpbWUAVXBkYXRlTW91c2VNb3ZpbmdXaW5kb3dOZXdGcmFtZQBHZXRBY3RpdmVJZFByZXZpb3VzRnJhbWUAR2V0SG92ZXJlZElkUHJldmlvdXNGcmFtZQBOYXZFbmRGcmFtZQBCZWdpbkNoaWxkRnJhbWUARW5kQ2hpbGRGcmFtZQBJbmlGaWxlbmFtZQBMb2dGaWxlbmFtZQBJbUd1aVRhYmxlRmxhZ3NfU2l6aW5nU3RyZXRjaFNhbWUASW1HdWlUYWJsZUZsYWdzX1NpemluZ0ZpeGVkU2FtZQBGb250TmFtZQBHZXRTdHlsZUNvbG9yTmFtZQBCYWNrZW5kUmVuZGVyZXJOYW1lAFRhYmxlR2V0Q29sdW1uTmFtZQBCYWNrZW5kUGxhdGZvcm1OYW1lAEdldFRhYk5hbWUALSBvciBtZQBIb3ZlciBvdmVyIG1lAENsaWNrIG1lAEZvbnRTdHlsZQBHZXRTdHlsZQBJbUd1aVN0eWxlAEFuaW1hdGVkIHRpdGxlICVjICVkIyMjQW5pbWF0ZWRUaXRsZQBBIFJhdGhlciBMb25nIFRpdGxlAFBpbmVhcHBsZQBBcHBsZQBDbG9zZSBDb25zb2xlAEV4YW1wbGU6IENvbnNvbGUAQXVkaW8gZmlsZQBTeXN0ZW0gZmlsZQBJbWFnZSBmaWxlAFNob3dFeGFtcGxlTWVudUZpbGUATG9nVG9GaWxlAExvZyBUbyBGaWxlAEFkZFRyaWFuZ2xlAHNsaWRlciBhbmdsZQBTbGlkZXJBbmdsZQBBZGRDaXJjbGUAaW5wdXQgZG91YmxlAGRyYWcgZG91YmxlAElucHV0RG91YmxlACFpc192aXNpYmxlAE5hdlZpc2libGUASW1HdWlUYWJsZUZsYWdzX05vS2VlcENvbHVtbnNWaXNpYmxlAF9Jc1Zpc2libGUASXNJdGVtVmlzaWJsZQB0YWItPkxhc3RGcmFtZVZpc2libGUgPj0gdGFiX2Jhci0+UHJldkZyYW1lVmlzaWJsZQB0YWJsZS0+RmxhZ3MgJiBJbUd1aVRhYmxlRmxhZ3NfUmVzaXphYmxlAHRhYmxlLT5GbGFncyAmIEltR3VpVGFibGVGbGFnc19Tb3J0YWJsZQAjI3NlbGVjdGFibGUAMy4gSSBhbSBub3Qgc2VsZWN0YWJsZQA0LiBJIGFtIHNlbGVjdGFibGUAMi4gSSBhbSBzZWxlY3RhYmxlADEuIEkgYW0gc2VsZWN0YWJsZQBTZWxlY3RhYmxlAGcuQ3VycmVudFdpbmRvdyA9PSBvdXRlcl93aW5kb3cgJiYgZy5DdXJyZW50VGFibGUgPT0gdGFibGUAX0luZGVudERpc2FibGUASW1HdWlUYWJCYXJGbGFnc19SZW9yZGVyYWJsZQB0YWJsZS0+RmxhZ3MgJiBJbUd1aVRhYmxlRmxhZ3NfUmVvcmRlcmFibGUAX0luZGVudEVuYWJsZQA1LiBJIGFtIGRvdWJsZSBjbGlja2FibGUASW1HdWlUYWJsZUZsYWdzX0hpZGVhYmxlAEJlZ2luVGFibGUARW5kVGFibGUAd2luZG93IHNjYWxlAEZvbnQgc2NhbGUAZ2xvYmFsIHNjYWxlAFNldFdpbmRvd0ZvbnRTY2FsZQBNb3VzZUN1cnNvclNjYWxlAERpc3BsYXlGcmFtZWJ1ZmZlclNjYWxlAEZvbnRHbG9iYWxTY2FsZQBQYXRoU3Ryb2tlAEFydGljaG9rZQBDaGFubmVsc01lcmdlAE9yYW5nZQBpby5Db25maWdGbGFnczogTm9Nb3VzZUN1cnNvckNoYW5nZQBBbGlnbiB0byByaWdodCBlZGdlAFNldFN0YXRlU3RvcmFnZQBHZXRTdGF0ZVN0b3JhZ2UAI2ltYWdlAEFkZEltYWdlAHRyZWUAL3BhdGgvdGhyZWUAVGhyZWVUaHJlZVRocmVlAEl0ZW0gVGhyZWUAT25lClR3bwpUaHJlZQBUcmVlAE1lbUZyZWUAU25pY2tlcnNuZWUAdGhpcyBpcyBhIHRyZWUgbm9kZQBUcmVlIG5vZGUAZmlsZW5hbWUgJiYgbW9kZQBGb2N1cyBmcm9tIGNvZGUAU2Nyb2xsIGZyb20gY29kZQBJVEVNOiBUcmVlTm9kZQBNZXJnZU1vZGUARGlzcGxheSBNb2RlAFBpY2tlciBNb2RlAFNob3dVc2VyR3VpZGUAIyNjdXJ2ZXNzZWdtZW50b3ZlcnJpZGUAIyNjaXJjbGVzZWdtZW50b3ZlcnJpZGUAQ3VydmVzIHNlZ21lbnRzIG92ZXJyaWRlAENpcmNsZSBzZWdtZW50cyBvdmVycmlkZQBfRGVmYXVsdEhpZGUAX05vSGlkZQBMZXR0dWNlACMjc291cmNlAFRoaXMgaXMgYSBkcmFnIGFuZCBkcm9wIHNvdXJjZQBUZXN0IHRyZWUgbm9kZSBhcyBkcmFnIHNvdXJjZQBCZWdpbkRyYWdEcm9wU291cmNlAEVuZERyYWdEcm9wU291cmNlAEN1cnZlIFRlc3NlbGxhdGlvbiBUb2xlcmFuY2UAY29uZCA9PSBJbUd1aUNvbmRfQWx3YXlzIHx8IGNvbmQgPT0gSW1HdWlDb25kX09uY2UAQmVhdHJpY2UAc3RiX3RleHRlZGl0X3JlcGxhY2UATWV0cmljc1RvdGFsU3VyZmFjZQBEcmFnIE1lACVlAHBhc3N3b3JkAE5hdk1vdmVSZXF1ZXN0Rm9yd2FyZABOYXZLZXlib2FyZABXYW50Q2FwdHVyZUtleWJvYXJkACBOYXZOb0NhcHR1cmVLZXlib2FyZABpby5Db25maWdGbGFnczogTmF2RW5hYmxlS2V5Ym9hcmQAQ29weSB0byBjbGlwYm9hcmQAQ29weSAiSGVsbG8sIHdvcmxkISIgdG8gY2xpcGJvYXJkAExvZ1RvQ2xpcGJvYXJkAExvZyBUbyBDbGlwYm9hcmQAQmVybmFyZABObyBiYWNrZ3JvdW5kAEJvcmRlcnMsIGJhY2tncm91bmQAVGFiSXRlbUJhY2tncm91bmQAIyNCYWNrZ3JvdW5kACMjRm9yZWdyb3VuZAAoKGNoYXIqKShzdGF0ZS0+dW5kb19yZWMgKyBzdGF0ZS0+cmVkb19wb2ludCArIDEpICsgbW92ZV9zaXplKSA8PSBidWZfZW5kAEhhbmQARGlzcGxheUVuZABTZWxlY3Rpb25FbmQAaXQgPj0gRGF0YSAmJiBpdCA8IERhdGFFbmQAcCA+PSBEYXRhICYmIHAgPCBEYXRhRW5kAEltRHJhd0NtZABBZGREcmF3Q21kAGhlbGxvLCB3b3JsZABIZWxsbwpXb3JsZABJc01vdXNlRHJhZ1Bhc3RUaHJlc2hvbGQATW91c2VEcmFnVGhyZXNob2xkAGJ1dHRvbl9mbGFncyAmIEltR3VpQnV0dG9uRmxhZ3NfUHJlc3NlZE9uRHJhZ0Ryb3BIb2xkACVsbGQAVGFibGVTb3J0U3BlY3NCdWlsZABvdXRlcl9jaGlsZABCZWdpbkNoaWxkAEVuZENoaWxkAEZpZWxkAEVuYWJsZSBncmlkAEdyaWQAdm9pZABCZWdpblBvcHVwQ29udGV4dFZvaWQASXNNb3VzZVBvc1ZhbGlkAGcuQWN0aXZlSWQgPT0gaWQAY29sdW1ucy0+SUQgPT0gaWQAc3RhdGUgJiYgc3RhdGUtPklEID09IGlkAGhibGtoZABnLkluaXRpYWxpemVkAFJlc2l6YWJsZSwgbWl4ZWQAUmVzaXphYmxlLCBmaXhlZABfV2lkdGhGaXhlZABOb3RBbGxvd2VkAGcuTmF2TW92ZVJlcXVlc3RGb3J3YXJkID09IEltR3VpTmF2Rm9yd2FyZF9Gb3J3YXJkUXVldWVkAFRleHRVbmZvcm1hdHRlZABlcmFzZV91bnNvcnRlZABfSXNTb3J0ZWQASW5kZW50ZWQASXNJdGVtRWRpdGVkAE1hcmtJdGVtRWRpdGVkAE5vdCBTZWxlY3RlZABJc0l0ZW1EZWFjdGl2YXRlZABJc0l0ZW1BY3RpdmF0ZWQAQ2xlYXJHbHlwaENyZWF0ZWQAdW51c2VkAFRhYlVuZm9jdXNlZABJc1dpbmRvd0ZvY3VzZWQASXNBbnlJdGVtRm9jdXNlZABJc0l0ZW1Gb2N1c2VkAElzS2V5UHJlc3NlZABTZXROZXh0V2luZG93Q29sbGFwc2VkAFNldFdpbmRvd0NvbGxhcHNlZABJc1dpbmRvd0NvbGxhcHNlZABUaXRsZUJnQ29sbGFwc2VkAFNldFdpbmRvd05hbWVDb2xsYXBzZWQAU2V0VGFiSXRlbUNsb3NlZABJc0tleVJlbGVhc2VkAElzTW91c2VSZWxlYXNlZABDb2x1bW5zQ29udGVudEhlYWRlcnNVc2VkAFRleHRDb2xvcmVkAEZpcnN0IGdyb3VwIGhvdmVyZWQASXNXaW5kb3dIb3ZlcmVkAFBsb3RMaW5lc0hvdmVyZWQAX0lzSG92ZXJlZABTZXBhcmF0b3JIb3ZlcmVkAEhlYWRlckhvdmVyZWQAUmVzaXplR3JpcEhvdmVyZWQAQnV0dG9uSG92ZXJlZABJc0FueUl0ZW1Ib3ZlcmVkAElzSXRlbUhvdmVyZWQAUGxvdEhpc3RvZ3JhbUhvdmVyZWQARnJhbWVCZ0hvdmVyZWQAU2Nyb2xsYmFyR3JhYkhvdmVyZWQAVGFiSG92ZXJlZABPdXRlclJlY3RDbGlwcGVkAFRleHQgd3JhcHBlZABUZXh0V3JhcHBlZABBbGlnbmVkACh3aW5kb3ctPkZsYWdzIHwgZy5OYXZXaW5kb3ctPkZsYWdzKSAmIEltR3VpV2luZG93RmxhZ3NfTmF2RmxhdHRlbmVkAEJ1bWZ1enpsZWQAQWRkQ29udmV4UG9seUZpbGxlZABBZGRSZWN0RmlsbGVkAEFkZE5nb25GaWxsZWQAQWRkVHJpYW5nbGVGaWxsZWQAQWRkQ2lyY2xlRmlsbGVkAEFkZFF1YWRGaWxsZWQAVGV4dERpc2FibGVkAF9Jc0VuYWJsZWQASXNJdGVtQ2xpY2tlZABJc01vdXNlQ2xpY2tlZABJc01vdXNlRG91YmxlQ2xpY2tlZABDaGVja2VkAEFkZEltYWdlUm91bmRlZAAhZy5Jbml0aWFsaXplZCAmJiAhZy5TZXR0aW5nc0xvYWRlZAB0YWJsZV9hZHZhbmNlZABBZHZhbmNlZABSZWQAQWRkSW1hZ2VRdWFkAEFkZFF1YWQATmF2R2FtZXBhZABpby5CYWNrZW5kRmxhZ3M6IEhhc0dhbWVwYWQAaW8uQ29uZmlnRmxhZ3M6IE5hdkVuYWJsZUdhbWVwYWQAQWNjZXB0RHJhZ0Ryb3BQYXlsb2FkAFNldERyYWdEcm9wUGF5bG9hZABHZXREcmFnRHJvcFBheWxvYWQAR2V0SW5wdXRUZXh0SWQAU2V0QWN0aXZlSWQAR2V0QWN0aXZlSWQAZy5OYXZBY3RpdmF0ZURvd25JZCA9PSBnLk5hdkFjdGl2YXRlSWQAZm9udC0+Q29udGFpbmVyQXRsYXMtPlRleElEID09IF9DbWRIZWFkZXIuVGV4dHVyZUlkAEdldEhvdmVyZWRJZAAlSTY0ZAAlMDRkACUwM2QAVjolM2QAUzolM2QAUjolM2QASDolM2QARzolM2QAQjolM2QAQTolM2QAIyNNZW51XyUwMmQAIyNUb29sdGlwXyUwMmQAIyNDb21ib18lMDJkAENvbHVtbiAlLTJkAE5vZGUlZABiJWQARmllbGRfJWQAZGVmaW5lOiBfX2NwbHVzcGx1cz0lZAAgT3JkZXI9JWQAIFdpZHRoPSVkACBWaXNpYmxlPSVkADB4JTA4WCAiJXMiIFBvcyAoJWQsJWQpIFNpemUgKCVkLCVkKSBDb2xsYXBzZWQ9JWQAZGVmaW5lOiBfX0dOVUNfXz0lZAAlZC8lZABOb2RlJWQuJWQAJXMgJWQsJWQASGVsbG8gJWQsJWQAVGhpcyBpcyB0aGUgcG9wdXAgZm9yIEJ1dHRvbigiLi4iKSBpbiBDZWxsICVkLCVkAEhlbGxvIHdvcmxkICVkLCVkAEZpeGVkICVkLCVkAGlvLkZvbnRzOiAlZCBmb250cywgRmxhZ3M6IDB4JTA4WCwgVGV4U2l6ZTogJWQsJWQAMHglMDhYLCVkAFJvdyAlZABTY3JvbGxpbmcgVGV4dCAlZABTb21lIHRlc3QgJWQATW9yZSBjb250ZW50ICVkAFNvbWUgY29udGVudCAlZABNeU9iamVjdCAlZABUaGlzIGlzIGEgY3VzdG9tIHBvcHVwIGZvciBDb2x1bW4gJWQAUm93ICVkIENvbHVtbiAlZABJdGVtICVkAHRoaXMgY2VsbCAlZABTZWxlY3RhYmxlIExlYWYgJWQAJSpzVGhpcyBpcyBsaW5lICVkAExpbmUgJWQAU3luY2VkIFRhYmxlICVkAFNlbGVjdGFibGUgTm9kZSAlZABDaGlsZCAlZABJdGVtID0gJWQARGF0YTogJXAKU2l6ZTogJWQKQ2FwYWNpdHk6ICVkAEFjdGl2ZTogJWQvJWQsIFdyaXRlQWNjZXNzZWQ6ICVkLCBCZWdpbk9yZGVyV2l0aGluQ29udGV4dDogJWQAV2FudFRleHRJbnB1dDogJWQATXlPYmplY3Q6ICVkAEl0ZW0gd2l0aCBmb2N1czogJWQAV2FudFNldE1vdXNlUG9zOiAlZABBcHBlYXJpbmc6ICVkLCBIaWRkZW46ICVkIChDYW5Ta2lwICVkIENhbm5vdCAlZCksIFNraXBJdGVtczogJWQAJXM6ICVkAE5hdklkOiAweCUwOFgsIE5hdkxheWVyOiAlZABOYXZEaXNhYmxlSGlnaGxpZ2h0OiAlZCwgTmF2RGlzYWJsZU1vdXNlSG92ZXI6ICVkAEhvdmVyZWRDb2x1bW5Cb2R5OiAlZCwgSG92ZXJlZENvbHVtbkJvcmRlcjogJWQASG92ZXJlZElkOiAweCUwOFgvMHglMDhYICglLjJmIHNlYyksIEFsbG93T3ZlcmxhcDogJWQASG92ZXJlZCBjb2x1bW46ICVkAFJlc2l6ZWRDb2x1bW46ICVkLCBSZW9yZGVyQ29sdW1uOiAlZCwgSGVsZEhlYWRlckNvbHVtbjogJWQAV2FudENhcHR1cmVNb3VzZTogJWQATmF2QWN0aXZlOiAlZCwgTmF2VmlzaWJsZTogJWQAV2FudENhcHR1cmVLZXlib2FyZDogJWQASXNJdGVtSG92ZXJlZDogJWQAc2l6ZW9mKHNpemVfdCk6ICVkLCBzaXplb2YoSW1EcmF3SWR4KTogJWQsIHNpemVvZihJbURyYXdWZXJ0KTogJWQAQXNjAHN0ZDo6YmFkX2FsbG9jAE1lbUFsbG9jAGZ1bmMAQWRkQmV6aWVyUXVhZHJhdGljAE11c2ljAFN0eWxlQ29sb3JzQ2xhc3NpYwBCYXNpYwBJbUd1aVNsaWRlckZsYWdzX0xvZ2FyaXRobWljAGlucHV0IHNjaWVudGlmaWMAQWRkQmV6aWVyQ3ViaWMAJS4yZgpzZWMAR2V0U3BlYwBhYmMATXlDb2xvciMjM2MAZmlzaF9oYXQuYwBtYWluLmMAY2NjMS5jAGJiYjEuYwBhYWExLmMAIFNvcnQ9JWQlYwAlYyVjJWMAcmFkaW8gYwByYgAjI3JnYgBzaG93X21lc2ggfHwgc2hvd19hYWJiAFNsaWRlckdyYWIAU2Nyb2xsYmFyR3JhYgBUYWJCYXJDbG9zZVRhYgBmbG9hdCAoaW5kZW50ZWQpIyM1YgBmbG9hdCAoaW5kZW50ZWQpIyM0YgBNeUNvbG9yIyMzYgBmbG9hdCAoaW5kZW50ZWQpIyMzYgBmbG9hdCAoaW5kZW50ZWQpIyMyYgBmbG9hdCMjMWIAZmxvYXQgKGluZGVudGVkKSMjMWIAcmFkaW8gYgByd2EAUmVzZXRNb3VzZURyYWdEZWx0YQBHZXRNb3VzZURyYWdEZWx0YQBNb3VzZURlbHRhAEdldERyYXdEYXRhAEFkZERyYXdMaXN0VG9EcmF3RGF0YQBJbURyYXdEYXRhAEZvbnREYXRhAEJhY2tlbmRSZW5kZXJlclVzZXJEYXRhAEJhY2tlbmRQbGF0Zm9ybVVzZXJEYXRhAEJhY2tlbmRMYW5ndWFnZVVzZXJEYXRhAENsaXBib2FyZFVzZXJEYXRhAEltR3VpSW5wdXRUZXh0Q2FsbGJhY2tEYXRhAEltR3VpU2l6ZUNhbGxiYWNrRGF0YQBTZXR0aW5nc0luaURhdGEAQ29uZmlnRGF0YQBHZXREcmF3TGlzdFNoYXJlZERhdGEAQnVmID09IGVkaXRfc3RhdGUtPlRleHRBLkRhdGEAY2FsbGJhY2tfZGF0YS5CdWYgPT0gc3RhdGUtPlRleHRBLkRhdGEAQnJpYW5uYQBhcmVuYQBCYW5hbmEAQWJpYmxpb3Bob2JpYQBhbHBoYQBTZXROZXh0V2luZG93QmdBbHBoYQBHbG9iYWwgQWxwaGEAV2l0aCBBbHBoYQAjI2Zsb2F0NWEAZmxvYXQjIzRhAGZsb2F0IyMzYQBmbG9hdCMjMmEAcmFkaW8gYQBbfl0AW3hdAFtlcnJvcl0AWyVkXQBvcGVyYXRvcltdAFsgXQB8Ly1cAENUUkwrWgAjI1oARm9jdXMgb24gWgBHZXRTY3JvbGxNYXhZAFN0YXJ0UG9zWQBTZXRDdXJzb3JQb3NZAEdldEN1cnNvclBvc1kAU2V0U2Nyb2xsRnJvbVBvc1kAU2Nyb2xsYmFyWQBTZXRTY3JvbGxZAEdldFNjcm9sbFkASW1HdWlUYWJsZUZsYWdzX1Njcm9sbFkAU2V0U2Nyb2xsSGVyZVkASW1HdWlUYWJsZUZsYWdzX05vSG9zdEV4dGVuZFkATG9nVG9UVFkATG9nIFRvIFRUWQBISVNUT1JZACNTQ1JPTExZAENMQVNTSUZZAENUUkwrWQAjI1kARm9jdXMgb24gWQBHZXRTY3JvbGxNYXhYAFNldEN1cnNvclBvc1gAR2V0Q3Vyc29yUG9zWABTZXRTY3JvbGxGcm9tUG9zWABJbUd1aVRhYmxlRmxhZ3NfTm9QYWRPdXRlclgASW1HdWlUYWJsZUZsYWdzX1BhZE91dGVyWABJbUd1aVRhYmxlRmxhZ3NfTm9QYWRJbm5lclgAU2Nyb2xsYmFyWABTZXRTY3JvbGxYAEdldFNjcm9sbFgASW1HdWlUYWJsZUZsYWdzX1Njcm9sbFgAU3RyZXRjaCArIFNjcm9sbFgAU2V0U2Nyb2xsSGVyZVgAR2x5cGhNYXhBZHZhbmNlWABHbHlwaE1pbkFkdmFuY2VYAEltR3VpVGFibGVGbGFnc19Ob0hvc3RFeHRlbmRYACNTQ1JPTExYAEZMVF9NQVgAQ29sdW1uICVkIE9yZGVyICVkIFNvcnRPcmRlciAlZCAlcyBWaXMgJWQgJXMgJTcuM2YgVXNlcklEIDB4JTA4WABOYXZGb2N1c1Njb3BlSWQgPSAweCUwOFgAaW8uQ29uZmlnRmxhZ3M6IDB4JTA4WABTYXZlRmxhZ3M6IDB4JTA4WABpby5CYWNrZW5kRmxhZ3M6IDB4JTA4WABOYXZBY3RpdmF0ZUlkOiAweCUwOFgsIE5hdklucHV0SWQ6IDB4JTA4WABIb3ZlcmVkSWQ6IDB4JTA4WAAlcy8lc18lMDhYACBVc2VySUQ9JTA4WAAlcy8lMDhYAENvbHVtbnMgSWQ6IDB4JTA4WCwgQ291bnQ6ICVkLCBGbGFnczogMHglMDRYAENvZGVwb2ludDogVSslMDRYACMlMDJYJTAyWCUwMlglMDJYACMlMDJYJTAyWCUwMlgAQ1RSTCtYAE5hdkxhc3RJZHM6IDB4JTA4WCwweCUwOFgsIE5hdkxheWVyQWN0aXZlTWFzazogJVgAIyNYAE9mZnNldCBYAEZvY3VzIG9uIFgAUmVzaXplTkVTVwBSZXNpemVFVwBDVFJMK1cAIyNXAEltR3VpVGFibGVGbGFnc19Cb3JkZXJzVgBJbUd1aVRhYmxlRmxhZ3NfQm9yZGVyc091dGVyVgBJbUd1aVRhYmxlRmxhZ3NfQm9yZGVyc0lubmVyVgBPdmVyc2FtcGxlVgBQcmltUmVjdFVWAFByaW1RdWFkVVYAQ29sb3JDb252ZXJ0UkdCdG9IU1YAQ1RSTCtWAFRFU1QAaW1ndWlfa2V5ID49IDAgJiYgaW1ndWlfa2V5IDwgSW1HdWlLZXlfQ09VTlQAbW91c2VfY3Vyc29yID4gSW1HdWlNb3VzZUN1cnNvcl9Ob25lICYmIG1vdXNlX2N1cnNvciA8IEltR3VpTW91c2VDdXJzb3JfQ09VTlQAaWR4ID49IDAgJiYgaWR4IDwgSW1HdWlTdHlsZVZhcl9DT1VOVABtb3VzZV9idXR0b24gPj0gMCAmJiBtb3VzZV9idXR0b24gPCBJbUd1aU1vdXNlQnV0dG9uX0NPVU5UAGRhdGFfdHlwZSA+PSAwICYmIGRhdGFfdHlwZSA8IEltR3VpRGF0YVR5cGVfQ09VTlQAbiA8IEJJVENPVU5UAE5BVixGT0NVUwBTVEJfVEVYVEVESVRfSU5TRVJUQ0hBUlMAUmVzaXplTlMASVRFTVMAQ3RybCtTAENUUkwrUwBDaGlsZFIAV2l0aCBIRFIAQ0xFQVIASEVMUABPT09PT09PAEdldElPAEltR3VpSU8AQ3RybCtPAFJFQUNUSU9OAElNR1VJX1ZFUlNJT04ASU1HVUlfQ0hFQ0tWRVJTSU9OAEZMVF9NSU4AaGFzX2ZyZWV6ZV92ID09IGZhbHNlIHx8IHRhYmxlLT5CZzJEcmF3Q2hhbm5lbFVuZnJvemVuICE9IFRBQkxFX0RSQVdfQ0hBTk5FTF9CRzJfRlJPWkVOAE5BTgBNTU1NAENUUkwrTQBDaGlsZEwAJXM6IE5VTEwATExMTExMTABETkRfREVNT19DRUxMAHdpbmRvdy0+REMuQ3VycmVudENvbHVtbnMgPT0gMEwAY3Vycl9jbWQtPlVzZXJDYWxsYmFjayA9PSAwTABnLkxvZ0ZpbGUgPT0gMEwAZy5OYXZXaW5kb3cgIT0gMEwAd2luZG93ID09IDBMIHx8IHdpbmRvdy0+Um9vdFdpbmRvdyAhPSAwTAB3aW5kb3ctPlJvb3RXaW5kb3dGb3JOYXYtPlBhcmVudFdpbmRvdyAhPSAwTAB0ZXh0ICE9IDBMAGNvbHVtbnMgIT0gMEwAY2FsbGJhY2sgIT0gMEwAR0ltR3VpICE9IDBMAHN0YXRlICE9IDBMAHR5cGUgIT0gMEwAdGFibGUgIT0gMEwAQnVmLkRhdGEgIT0gMEwAT0sAS0tLS0tLSwBKSkpKAExlZ2FjeSBDb2x1bW5zIEFQSQBTZXQgdG8gUEkASUlJSUlJSQBJbUd1aVRhYmxlRmxhZ3NfQm9yZGVyc0gASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnMKID0gSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lclYKIHwgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlclYKIHwgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lclYKIHwgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlckgASW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNJbm5lckgAUGl4ZWxTbmFwSABPdmVyc2FtcGxlSABISEhIAFdJTkRPV0lORwBDVVJSRU5UTFkgQVBQRU5ESU5HAEdHR0cASU5GAEZGRkYAX0NPTDRGAF9DT0wzRgAjUkVTSVpFACNNT1ZFAFJlc2l6ZU5XU0UAI0NPTExBUFNFACNDTE9TRQBFRUVFAF9UUkVFTk9ERQBWYWx1ZV9EAExFVkVSQUdFCkJVWlpXT1JEAFRleElEAFNldE5hdklEAEdldElEAFNldEZvY3VzSUQAQ29sdW1uVXNlcklEAFBvcElEAFB1c2hJRABUYWJsZUdldENvbHVtblJlc2l6ZUlEAFBvcFRleHR1cmVJRABQdXNoVGV4dHVyZUlEAF9PbkNoYW5nZWRUZXh0dXJlSUQAZ3JvdXBfZGF0YS5XaW5kb3dJRCA9PSB3aW5kb3ctPklEAHNldHRpbmdzLT5JRCA9PSB3aW5kb3ctPklEAGVkaXRfc3RhdGUtPklEICE9IDAgJiYgZy5BY3RpdmVJZCA9PSBlZGl0X3N0YXRlLT5JRABzZXR0aW5ncy0+SUQgPT0gdGFibGUtPklEAEREREQAVHJlZU5vZGVFeF9DAFZhbHVlX0MAVHJlZU5vZGVfQwBHZXRDb2xvclUzMl9DAENDQ0NDQ0NDQ0NDQwBDVFJMK0MAQ2F0ZWdvcnkgQwBMaXN0Qm94X0IAVHJlZU5vZGVFeF9CAEFkZFRleHRfQgBMaXN0Qm94SGVhZGVyX0IAQ29sbGFwc2luZ0hlYWRlcl9CAFJhZGlvQnV0dG9uX0IATWVudUl0ZW1fQgBUcmVlUHVzaF9CAFZhbHVlX0IASXNSZWN0VmlzaWJsZV9CAFNlbGVjdGFibGVfQgBUcmVlTm9kZV9CAEdldENvbG9yVTMyX0IAQ29sb3JDb252ZXJ0SFNWdG9SR0IARnJhbWVCQgBCQkJCQkJCQgBDYXRlZ29yeSBCAGNhbGxiYWNrX2RhdGEuQnVmU2l6ZSA9PSBzdGF0ZS0+QnVmQ2FwYWNpdHlBAENhbGNXb3JkV3JhcFBvc2l0aW9uQQBDYWxjVGV4dFNpemVBAExpc3RCb3hfQQBUcmVlTm9kZUV4X0EAQWRkVGV4dF9BAExpc3RCb3hIZWFkZXJfQQBDb2xsYXBzaW5nSGVhZGVyX0EAUmFkaW9CdXR0b25fQQBNZW51SXRlbV9BAFRyZWVQdXNoX0EAVmFsdWVfQQBJc1JlY3RWaXNpYmxlX0EAU2VsZWN0YWJsZV9BAFRyZWVOb2RlX0EAR2V0Q29sb3JVMzJfQQBBQUFBAE4vQQBDYXRlZ29yeSBBAFNhdmUgY2hhbmdlIHRvIHRoZSBmb2xsb3dpbmcgaXRlbXM/AFNhdmU/AERlbGV0ZT8AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+ADxVbmtub3duPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBJdGVtIHdpdGggZm9jdXM6IDxub25lPgBOYXZSZWN0UmVsWzBdOiA8Tm9uZT4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgA8cGFzc3dvcmQ+AE1vdXNlIFBvc2l0aW9uOiA8aW52YWxpZD4APE5VTEw+AE1vdXNlIHBvczogPElOVkFMSUQ+ADw8UFJFU1MgU1BBQ0UgVE8gRElTQUJMRT4+ACMjPgA8PAAjIzwAQ29sb3IgYnV0dG9uIG9ubHk6AENvbG9yIHdpZGdldCB3aXRoIEZsb2F0IERpc3BsYXk6AE11bHRpLWxpbmUgdGV4dDoAVmVydDoAQ29sb3Igd2lkZ2V0OgBIb2xkIHRvIHJlcGVhdDoATGlzdHM6AENlbGwgY29udGVudHM6AEhvdmVyIHRvIHNlZSBtb3VzZSBjdXJzb3JzOgBEZWNvcmF0aW9uczoAQ29sdW1uczoATWlzYyBpdGVtczoARHJhZ3M6AE91dHB1dCBmbGFnczoASW5wdXQgZmxhZ3M6AEZlYXR1cmVzOgBUYWJsZXM6AENvbW1hbmRzOgAlczoAQ29sb3IgcGlja2VyOgBDb2xvciBidXR0b24gd2l0aCBQaWNrZXI6AE90aGVyOgBXaXRob3V0IGJvcmRlcjoAV2l0aCBib3JkZXI6AENvbG9yIGJ1dHRvbiB3aXRoIEN1c3RvbSBQaWNrZXIgUG9wdXA6AEtleXMgZG93bjoATmF2SW5wdXRzIGRvd246AE1vdXNlIGRvd246AE5hdklucHV0cyBkdXJhdGlvbjoATW91c2UgZGJsY2xpY2s6AFNpemluZzoAU29ydGluZzoATWFudWFsbHkgd3JhcHBpbmc6AFNjcm9sbGluZzoAUGFkZGluZzoAVXNpbmcgZXhwbGljaXQgc2l6ZToAQ2hhcnMgcXVldWU6AEtleXMgcmVsZWFzZToAVGV4dCBiYXNlbGluZToARWRpdCBuYW1lOgBTZXQgZGVmYXVsdHMgaW4gY29kZToAS2V5cyBwcmVzc2VkOgBOYXZJbnB1dHMgcHJlc3NlZDoATW91c2UgcmVsZWFzZWQ6AFdpdGgga2V5Ym9hcmQgbmF2aWdhdGlvbiBlbmFibGVkOgBNb3VzZSBjbGlja2VkOgBUZXN0IHBhcmFncmFwaCAlZDoAQ29sb3Igd2lkZ2V0IEhTViB3aXRoIEFscGhhOgBVc2luZyBOb0hvc3RFeHRlbmRYIGFuZCBOb0hvc3RFeHRlbmRZOgBDb2xvciB3aWRnZXQgd2l0aCBJbnB1dEhTVjoAQUJPVVQgVEhJUyBERU1POgBVU0VSIEdVSURFOgBQUk9HUkFNTUVSIEdVSURFOgBJc01vdXNlRHJhZ2dpbmcoJWQpOgBHZXRNb3VzZURyYWdEZWx0YSgwKToAJyVzJzoASUQ6IDAxMjM0NTY3ODkAaW5wdXQgdTgAZHJhZyB1OABpbnB1dCBzOABkcmFnIHM4AEdldFRleERhdGFBc0FscGhhOABVOABTOABBZGRJbnB1dENoYXJhY3RlcnNVVEY4AHJvd3MgPj0gMCAmJiByb3dzIDwgMTI4AHNvcnRfb3JkZXJfY291bnQgPCAoaW50KXNpemVvZihzb3J0X29yZGVyX21hc2spICogOAAxMjM0NTYAMTIzLjQ1NgBpbnB1dCB1MTYAZHJhZyB1MTYAaW5wdXQgczE2AGRyYWcgczE2AFUxNgBTMTYAMC4uMjU1AGlucHV0IGludDQAc2xpZGVyIGludDQAZHJhZyBpbnQ0AElucHV0SW50NABTbGlkZXJJbnQ0AERyYWdJbnQ0AElURU06IENvbG9yRWRpdDQAaW5wdXQgZmxvYXQ0AHNsaWRlciBmbG9hdDQAZHJhZyBmbG9hdDQASW5wdXRGbG9hdDQAU2xpZGVyRmxvYXQ0AENvbG9yQ29udmVydFUzMlRvRmxvYXQ0AERyYWdGbG9hdDQAQ29sb3JQaWNrZXI0AEdldFN0eWxlQ29sb3JWZWM0AEltVmVjNABBbHQrRjQAaW5wdXQgdTY0AGRyYWcgdTY0AGlucHV0IHM2NABkcmFnIHM2NABVNjQAUzY0AGNvbHVtbnMgPj0gMCAmJiBjb2x1bW5zIDwgNjQAMTIzNABNeUNvbG9yIyM0AEJ1dHRvbiMjNABpbnB1dCBpbnQzAHNsaWRlciBpbnQzAGRyYWcgaW50MwBJbnB1dEludDMAU2xpZGVySW50MwBEcmFnSW50MwBDb2xvckVkaXQzAHNldDMAaW5wdXQgZmxvYXQzAHNsaWRlciBmbG9hdDMAZHJhZyBmbG9hdDMASVRFTTogSW5wdXRGbG9hdDMAU2xpZGVyRmxvYXQzAERyYWdGbG9hdDMAbXljb2x1bW5zMwBmbGFnczMAQ29sb3JQaWNrZXIzAHRhYmxlMwBNeUNvbG9yIyMzAEJ1dHRvbiMjMwBJdGVtIyMzAEZvY3VzIG9uIDMAaW5wdXQgaW50MgBzbGlkZXIgaW50MgBkcmFnIGludDIAIyNncmFkaWVudDIASW5wdXRJbnQyAFNsaWRlckludDIARHJhZ0ludDIAc3BsaXQyAHNldDIAaW5wdXQgZmxvYXQyAHNsaWRlciBmbG9hdDIAZHJhZyBmbG9hdDIASW5wdXRGbG9hdDIAU2xpZGVyRmxvYXQyAERyYWdGbG9hdDIAdGFibGUyAERyYWdJbnRSYW5nZTIARHJhZ0Zsb2F0UmFuZ2UyAHRhYmxlX25lc3RlZDIASW1WZWMyAHRhYmxlX2NvbnRleHRfbWVudV8yAHRhYmxlX3BhZGRpbmdfMgBpbnB1dCB1MzIAZHJhZyB1MzIAaW5wdXQgczMyAGRyYWcgczMyAENvbG9yQ29udmVydEZsb2F0NFRvVTMyAFMzMgBTYW1lIHRpdGxlIGFzIGFub3RoZXIgd2luZG93IyMyAE15Q29sb3IjIzIAQnV0dG9uIyMyAENvbmZpZ3VyYXRpb24jIzIASXRlbSMjMgBOb2RlIyMyAFRFU1QjIzIASE9QIyMyAGNvbG9yIDIARm9jdXMgb24gMgBTdGFja2VkIDIAcm93X2JnX3R5cGUgPj0gMCAmJiByb3dfYmdfdHlwZSA8PSAyACooY29uc3QgSW1VNjQqKXBfbWF4IDw9IElNX1U2NF9NQVggLyAyACooY29uc3QgSW1TNjQqKXBfbWluID49IElNX1M2NF9NSU4gLyAyICYmICooY29uc3QgSW1TNjQqKXBfbWF4IDw9IElNX1M2NF9NQVggLyAyACooY29uc3QgSW1VMzIqKXBfbWF4IDw9IElNX1UzMl9NQVggLyAyACooY29uc3QgSW1TMzIqKXBfbWluID49IElNX1MzMl9NSU4gLyAyICYmICooY29uc3QgSW1TMzIqKXBfbWF4IDw9IElNX1MzMl9NQVggLyAyACMjZ3JhZGllbnQxAHNwbGl0MQBzZXQxAGZsb2F0MQB0YWJsZTEAdGFibGVfbmVzdGVkMQBZMQBTcGFjZVgxAFYxAFUxAEIxAEExAG9mZnNldCA+PSAtMQBjb2x1bW5fbiA9PSAtMQBwYXlsb2FkLkRhdGFGcmFtZUNvdW50ICE9IC0xAGNvbHVtbl93aXRoX3NtYWxsZXN0X3NvcnRfb3JkZXIgIT0gLTEAdGFibGUtPkN1cnJlbnRDb2x1bW4gIT0gLTEAdGFibGUtPkxlZnRNb3N0U3RyZXRjaGVkQ29sdW1uICE9IC0xICYmIHRhYmxlLT5SaWdodE1vc3RTdHJldGNoZWRDb2x1bW4gIT0gLTEAcmVvcmRlcl9kaXIgPT0gLTEgfHwgcmVvcmRlcl9kaXIgPT0gKzEAZGlyID09IC0xIHx8IGRpciA9PSArMQBTYW1lIHRpdGxlIGFzIGFub3RoZXIgd2luZG93IyMxAE15Q29sb3IjIzEAQnV0dG9uIyMxAEl0ZW0jIzEATm9kZSMjMQBIU1Ygc2hvd24gYXMgSFNWIyMxAFRFU1QjIzEASE9QIyMxAEhTViBzaG93biBhcyBSR0IjIzEAQnVsbGV0IHBvaW50IDEAY29sb3IgMQBjb21ibyAxAEZvY3VzIG9uIDEAQjEgQ2VsbCAxAEExIENlbGwgMQBCMCBDZWxsIDEAQTAgQ2VsbCAxAFN0YWNrZWQgMQBnLkl0ZW1GbGFnc1N0YWNrLlNpemUgPiAxAHdpbmRvdy0+SURTdGFjay5TaXplID4gMQBjb2x1bW5zX2NvdW50ID49IDEAbmF2X2xheWVyID09IDAgfHwgbmF2X2xheWVyID09IDEAZy5OYXZMYXllciA9PSAwIHx8IGcuTmF2TGF5ZXIgPT0gMQBpZHggPD0gMQByb3dfYmdfdGFyZ2V0ID49IDAgJiYgcm93X2JnX3RhcmdldCA8PSAxAGNlbGxfYmdfdHlwZSA+PSAwICYmIGNlbGxfYmdfdHlwZSA8PSAxADAgPCAlLjEwZiA8IDEAZmxvYXQwAFkwAFNwYWNlWDAAVjAAVTAAQjAAQTAARGVmYXVsdCBmb3IgY29sdW1uID4wADgweDgwADEuODAANTB4NTAAeD0xNTAAQ2xhbXAgaW50ZWdlcnMgdG8gMC4uNTAANTAweDUwMABIZWlnaHQgNDAwLTUwMABXaWR0aCA0MDAtNTAwAHg9MzAwADgwMHgyMDAAMjAweDIwMABkcmFnIGludCAwLi4xMDAAQWxpZ24gdG8gcmlnaHQgZWRnZSBtaW51cyAxMDAAV2lkdGggPiAxMDAsIEhlaWdodCA+IDEwMABNOjAwMABNOjAuMDAwADAuMDAuLjEuMDAARGVmYXVsdCBmb3IgY29sdW1uIDAAQjEgQ2VsbCAwAEExIENlbGwgMABCMCBDZWxsIDAAQTAgQ2VsbCAwAGNvbHVtbl9pbmRleCA+IDAAY29sdW1uLT5Tb3J0RGlyZWN0aW9uc0F2YWlsQ291bnQgPiAwAGcuQ3VycmVudFdpbmRvd1N0YWNrLlNpemUgPiAwAGcuQmVnaW5Qb3B1cFN0YWNrLlNpemUgPiAwAGcuR3JvdXBTdGFjay5TaXplID4gMAB0YWJfYmFyLT5MYXN0VGFiSXRlbUlkeCA+PSAwAHRhYmxlLT5SaWdodE1vc3RFbmFibGVkQ29sdW1uID49IDAAYXBwbHlfbmV3X3RleHRfbGVuZ3RoID49IDAAYnVmICE9IDBMICYmIGJ1Zl9zaXplID49IDAAd2luZG93LT5CZWdpbkNvdW50ID09IDAAd2luZG93LT5EcmF3TGlzdC0+Q21kQnVmZmVyLlNpemUgPT0gMSAmJiB3aW5kb3ctPkRyYXdMaXN0LT5DbWRCdWZmZXJbMF0uRWxlbUNvdW50ID09IDAAc3BsaXR0ZXItPl9DdXJyZW50ID09IDAAY29sdW1ucy0+Q3VycmVudCA9PSAwAGlkID09IDAAdGFiX2Jhci0+UmVvcmRlclJlcXVlc3RUYWJJZCA9PSAwAChmbGFncyAmIEltR3VpSG92ZXJlZEZsYWdzX0FsbG93V2hlbk92ZXJsYXBwZWQpID09IDAAKHRhYmxlLT5GbGFncyAmIEltR3VpVGFibGVGbGFnc19TY3JvbGxYKSA9PSAwAChmbGFncyAmIChJbUd1aUhvdmVyZWRGbGFnc19Sb290V2luZG93IHwgSW1HdWlIb3ZlcmVkRmxhZ3NfQ2hpbGRXaW5kb3dzKSkgPT0gMABtb3ZlX2ZsYWdzICE9IDAAc291cmNlX2lkICE9IDAAcGF5bG9hZC5Tb3VyY2VJZCAhPSAwAGNoaWxkX3dpbmRvdy0+Q2hpbGRJZCAhPSAwAChmbGFncyAmIEltR3VpV2luZG93RmxhZ3NfTm9UaXRsZUJhcikgIT0gMAAocG9wdXAuV2luZG93LT5GbGFncyAmIEltR3VpV2luZG93RmxhZ3NfUG9wdXApICE9IDAAUmVhZCB0aGUgRkFRIGF0IGh0dHA6Ly93d3cuZGVhcmltZ3VpLm9yZy9mYXEvAEluc3RydWN0IGJhY2tlbmQgdG8gbm90IGFsdGVyIG1vdXNlIGN1cnNvciBzaGFwZSBhbmQgdmlzaWJpbGl0eS4AU2VjdGlvbnMgYmVsb3cgYXJlIGRlbW9uc3RyYXRpbmcgbWFueSBhc3BlY3RzIG9mIHRoZSBsaWJyYXJ5LgBVc2luZyBUYWJsZU5leHRSb3coKSArIGNhbGxpbmcgVGFibGVOZXh0Q29sdW1uKCkgX2JlZm9yZV8gZWFjaCBjZWxsLCBtYW51YWxseS4AV2hlbiBkcmF3aW5nIGNpcmNsZSBwcmltaXRpdmVzIHdpdGggIm51bV9zZWdtZW50cyA9PSAwIiB0ZXNzZWxhdGlvbiB3aWxsIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS4AV2UgZG9uJ3QgdXNlIHRoZSBkcmFnIGFuZCBkcm9wIGFwaSBhdCBhbGwgaGVyZSEgSW5zdGVhZCB3ZSBxdWVyeSB3aGVuIHRoZSBpdGVtIGlzIGhlbGQgYnV0IG5vdCBob3ZlcmVkLCBhbmQgb3JkZXIgaXRlbXMgYWNjb3JkaW5nbHkuAEJ5IGRlZmF1bHQsIHJpZ2h0LWNsaWNraW5nIG92ZXIgYSBUYWJsZUhlYWRlcnNSb3coKS9UYWJsZUhlYWRlcigpIGxpbmUgd2lsbCBvcGVuIHRoZSBkZWZhdWx0IGNvbnRleHQtbWVudS4KVXNpbmcgSW1HdWlUYWJsZUZsYWdzX0NvbnRleHRNZW51SW5Cb2R5IHdlIGFsc28gYWxsb3cgcmlnaHQtY2xpY2tpbmcgb3ZlciBjb2x1bW5zIGJvZHkuAFlvdSBjYW4gcGFzcyBhICdtaW5fcm93X2hlaWdodCcgdG8gVGFibGVOZXh0Um93KCkuCgpSb3dzIGFyZSBwYWRkZWQgd2l0aCAnc3R5bGUuQ2VsbFBhZGRpbmcueScgb24gdG9wIGFuZCBib3R0b20sIHNvIGVmZmVjdGl2ZWx5IHRoZSBtaW5pbXVtIHJvdyBoZWlnaHQgd2lsbCBhbHdheXMgYmUgPj0gJ3N0eWxlLkNlbGxQYWRkaW5nLnkgKiAyLjBmJy4KCldlIGNhbm5vdCBob25vciBhIF9tYXhpbXVtXyByb3cgaGVpZ2h0IGFzIHRoYXQgd291bGQgcmVxdWlyZXMgYSB1bmlxdWUgY2xpcHBpbmcgcmVjdGFuZ2xlIHBlciByb3cuAFVzZSBjaGlsZCB3aW5kb3dzIHRvIGJlZ2luIGludG8gYSBzZWxmLWNvbnRhaW5lZCBpbmRlcGVuZGVudCBzY3JvbGxpbmcvY2xpcHBpbmcgcmVnaW9ucyB3aXRoaW4gYSBob3N0IHdpbmRvdy4ARG91YmxlLWNsaWNrIG9uIHRpdGxlIGJhciB0byBjb2xsYXBzZSB3aW5kb3cuAEVzY2FwZSB0byBkZWFjdGl2YXRlIGEgd2lkZ2V0LCBjbG9zZSBwb3B1cCwgZXhpdCBjaGlsZCB3aW5kb3cuAENUUkwrVGFiIHRvIHNlbGVjdCBhIHdpbmRvdy4AQWx0IHRvIGp1bXAgdG8gdGhlIG1lbnUgbGF5ZXIgb2YgYSB3aW5kb3cuAE1vdXNlIExlZnQ6IGRyYWcgdG8gYWRkIGxpbmVzLApNb3VzZSBSaWdodDogZHJhZyB0byBzY3JvbGwsIGNsaWNrIGZvciBjb250ZXh0IG1lbnUuAENsaWNrIGFuZCBkcmFnIGNvbHVtbiBoZWFkZXJzIHRvIHJlb3JkZXIgY29sdW1ucy4KClJpZ2h0LWNsaWNrIG9uIGEgaGVhZGVyIHRvIG9wZW4gYSBjb250ZXh0IG1lbnUuAEluIHRoZSBjb2xvciBsaXN0OgpMZWZ0LWNsaWNrIG9uIGNvbG9yIHNxdWFyZSB0byBvcGVuIGNvbG9yIHBpY2tlciwKUmlnaHQtY2xpY2sgdG8gb3BlbiBlZGl0IG9wdGlvbnMgbWVudS4AQ1RSTCtDbGljayBvbiBhIHNsaWRlciBvciBkcmFnIGJveCB0byBpbnB1dCB2YWx1ZSBhcyB0ZXh0LgBQcmludGluZyB1bnVzdWFsbHkgbG9uZyBhbW91bnQgb2YgdGV4dC4AWW91IGNhbiBhbHNvIGNhbGwgSW1HdWk6OkxvZ1RleHQoKSB0byBvdXRwdXQgZGlyZWN0bHkgdG8gdGhlIGxvZyB3aXRob3V0IGEgdmlzdWFsIG91dHB1dC4AVXNpbmcgVGFibGVTZXR1cENvbHVtbigpIHRvIHNldHVwIGV4cGxpY2l0IHdpZHRoLgoKVW5sZXNzIF9Ob0tlZXBDb2x1bW5zVmlzaWJsZSBpcyBzZXQsIGZpeGVkIGNvbHVtbnMgd2l0aCBzZXQgd2lkdGggbWF5IHN0aWxsIGJlIHNocnVuayBkb3duIGlmIHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBpbiB0aGUgaG9zdC4ARVNDQVBFIHRvIHJldmVydC4AQWxpZ25tZW50IGFwcGxpZXMgd2hlbiBhIGJ1dHRvbiBpcyBsYXJnZXIgdGhhbiBpdHMgdGV4dCBjb250ZW50LgBBbGlnbm1lbnQgYXBwbGllcyB3aGVuIGEgc2VsZWN0YWJsZSBpcyBsYXJnZXIgdGhhbiBpdHMgdGV4dCBjb250ZW50LgBXaGVuIGEgcG9wdXAgaXMgYWN0aXZlLCBpdCBpbmhpYml0cyBpbnRlcmFjdGluZyB3aXRoIHdpbmRvd3MgdGhhdCBhcmUgYmVoaW5kIHRoZSBwb3B1cC4gQ2xpY2tpbmcgb3V0c2lkZSB0aGUgcG9wdXAgY2xvc2VzIGl0LgBZb3VyIGFwcGxpY2F0aW9uIGNhbiByZW5kZXIgYSBkaWZmZXJlbnQgbW91c2UgY3Vyc29yIGJhc2VkIG9uIHdoYXQgSW1HdWk6OkdldE1vdXNlQ3Vyc29yKCkgcmV0dXJucy4gSWYgc29mdHdhcmUgY3Vyc29yIHJlbmRlcmluZyAoaW8uTW91c2VEcmF3Q3Vyc29yKSBpcyBzZXQgSW1HdWkgd2lsbCBkcmF3IHRoZSByaWdodCBjdXJzb3IgZm9yIHlvdSwgb3RoZXJ3aXNlIHlvdXIgYmFja2VuZCBuZWVkcyB0byBoYW5kbGUgaXQuAEhlbGxvIGZyb20gU3RhY2tlZCBUaGUgRmlyc3QKVXNpbmcgc3R5bGUuQ29sb3JzW0ltR3VpQ29sX01vZGFsV2luZG93RGltQmddIGJlaGluZCBpdC4AWW91IGNhbiB1c2UgSW1HdWk6OkdldE1vdXNlRHJhZ0RlbHRhKDApIHRvIHF1ZXJ5IGZvciB0aGUgZHJhZ2dlZCBhbW91bnQgb24gYW55IHdpZGdldC4ARGlzYWJsZSBDVFJMK0NsaWNrIG9yIEVudGVyIGtleSBhbGxvd2luZyB0byBpbnB1dCB0ZXh0IGRpcmVjdGx5IGludG8gdGhlIHdpZGdldC4AUmV0dXJuIHRvIGlucHV0IHRleHQgaW50byBhIHdpZGdldC4AU3BhY2UgdG8gYWN0aXZhdGUgYSB3aWRnZXQuAFlvdSBjYW4gYXBwbHkgYXJpdGhtZXRpYyBvcGVyYXRvcnMgKywqLC8gb24gbnVtZXJpY2FsIHZhbHVlcy4KICBlLmcuIFsgMTAwIF0sIGlucHV0ICcqMicsIHJlc3VsdCBiZWNvbWVzIFsgMjAwIF0KVXNlICstIHRvIHN1YnRyYWN0LgBZb3UgY2FuIGFwcGx5IGFyaXRobWV0aWMgb3BlcmF0b3JzICssKiwvIG9uIG51bWVyaWNhbCB2YWx1ZXMuClVzZSArLSB0byBzdWJ0cmFjdC4AVXNlIFNldFNjcm9sbEhlcmVYKCkgb3IgU2V0U2Nyb2xsRnJvbVBvc1goKSB0byBzY3JvbGwgdG8gYSBnaXZlbiBob3Jpem9udGFsIHBvc2l0aW9uLgoKQmVjYXVzZSB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlIG9mIG1vc3Qgd2luZG93IGhpZGVzIGhhbGYgd29ydGggb2YgV2luZG93UGFkZGluZyBvbiB0aGUgbGVmdC9yaWdodCwgdXNpbmcgU2V0U2Nyb2xsRnJvbVBvc1goKzEpIHdpbGwgdXN1YWxseSByZXN1bHQgaW4gY2xpcHBlZCB0ZXh0IHdoZXJlYXMgdGhlIGVxdWl2YWxlbnQgU2V0U2Nyb2xsRnJvbVBvc1koKzEpIHdvdWxkbid0LgBUaGUgQmFja2dyb3VuZCBkcmF3IGxpc3Qgd2lsbCBiZSByZW5kZXJlZCBiZWxvdyBldmVyeSBEZWFyIEltR3VpIHdpbmRvd3MuAFRoZSBGb3JlZ3JvdW5kIGRyYXcgbGlzdCB3aWxsIGJlIHJlbmRlcmVkIG92ZXIgZXZlcnkgRGVhciBJbUd1aSB3aW5kb3dzLgBDVFJMK01vdXNlIFdoZWVsIHRvIHpvb20gd2luZG93IGNvbnRlbnRzLgBVc2luZyBfUmVzaXphYmxlICsgX1NpemluZ0ZpeGVkRml0IGZsYWdzLgpGaXhlZC13aWR0aCBjb2x1bW5zIGdlbmVyYWxseSBtYWtlcyBtb3JlIHNlbnNlIGlmIHlvdSB3YW50IHRvIHVzZSBob3Jpem9udGFsIHNjcm9sbGluZy4KCkRvdWJsZS1jbGljayBhIGNvbHVtbiBib3JkZXIgdG8gYXV0by1maXQgdGhlIGNvbHVtbiB0byBpdHMgY29udGVudHMuAFRoZSAiRXhhbXBsZXMiIG1lbnUgYWJvdmUgbGVhZHMgdG8gbW9yZSBkZW1vIGNvbnRlbnRzLgBUaG9zZSBhcmUgb2xkIHNldHRpbmdzIHByb3ZpZGVkIGZvciBjb252ZW5pZW5jZS4KSG93ZXZlciwgdGhlIF9jb3JyZWN0XyB3YXkgb2Ygc2NhbGluZyB5b3VyIFVJIGlzIGN1cnJlbnRseSB0byByZWxvYWQgeW91ciBmb250IGF0IHRoZSBkZXNpZ25lZCBzaXplLCByZWJ1aWxkIHRoZSBmb250IGF0bGFzLCBhbmQgY2FsbCBzdHlsZS5TY2FsZUFsbFNpemVzKCkgb24gYSByZWZlcmVuY2UgSW1HdWlTdHlsZSBzdHJ1Y3R1cmUuClVzaW5nIHRob3NlIHNldHRpbmdzIGhlcmUgd2lsbCBnaXZlIHlvdSBwb29yIHF1YWxpdHkgcmVzdWx0cy4ASGVyZSB3ZSB0b2dnbGUgdGhlIGNhc2luZyBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9uIGV2ZXJ5IGVkaXRzICsgY291bnQgZWRpdHMuAENvbHVtbnMgZGVmYXVsdCB0byBfV2lkdGhTdHJldGNoIHdpdGggc2FtZSB3ZWlnaHRzLgBDdXJyZW50bHkgYWxsIHRoaXMgZG9lcyBpcyB0byBsaWZ0IHRoZSAwLi4xIGxpbWl0cyBvbiBkcmFnZ2luZyB3aWRnZXRzLgBUaGlzIGlzIHRlc3RpbmcgdGhlIHZlcnRpY2FsIGFsaWdubWVudCB0aGF0IGdldHMgYXBwbGllZCBvbiB0ZXh0IHRvIGtlZXAgaXQgYWxpZ25lZCB3aXRoIHdpZGdldHMuIExpbmVzIG9ubHkgY29tcG9zZWQgb2YgdGV4dCBvciAic21hbGwiIHdpZGdldHMgdXNlIGxlc3MgdmVydGljYWwgc3BhY2UgdGhhbiBsaW5lcyB3aXRoIGZyYW1lZCB3aWRnZXRzLgBCeSBPbWFyIENvcm51dCBhbmQgYWxsIERlYXIgSW1HdWkgY29udHJpYnV0b3JzLgBJbnN0cnVjdCBuYXZpZ2F0aW9uIHRvIG1vdmUgdGhlIG1vdXNlIGN1cnNvci4gU2VlIGNvbW1lbnQgZm9yIEltR3VpQ29uZmlnRmxhZ3NfTmF2RW5hYmxlU2V0TW91c2VQb3MuAFJpZ2h0LWNsaWNrIG9uIHRoZSBpbmRpdmlkdWFsIGNvbG9yIHdpZGdldCB0byBzaG93IG9wdGlvbnMuAEFsc28gc2VlIFN0eWxlLT5SZW5kZXJpbmcgZm9yIHJlbmRlcmluZyBvcHRpb25zLgBEaXNhYmxlIGNsaXBwaW5nIHJlY3RhbmdsZSBmb3IgZXZlcnkgaW5kaXZpZHVhbCBjb2x1bW5zIChyZWR1Y2UgZHJhdyBjb21tYW5kIGNvdW50LCBpdGVtcyB3aWxsIGJlIGFibGUgdG8gb3ZlcmZsb3cgaW50byBvdGhlciBjb2x1bW5zKS4gR2VuZXJhbGx5IGluY29tcGF0aWJsZSB3aXRoIFNjcm9sbEZyZWV6ZSBvcHRpb25zLgBUaGlzIHNlY3Rpb24gYWxsb3dzIHlvdSB0byBpbnRlcmFjdCBhbmQgc2VlIHRoZSBlZmZlY3Qgb2YgdmFyaW91cyBzaXppbmcgcG9saWNpZXMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgU2Nyb2xsIGlzIGVuYWJsZWQgYW5kIHRoZSBjb250ZW50cyBvZiB5b3VyIGNvbHVtbnMuAEhlcmUgd2UgYWN0aXZhdGUgU2Nyb2xsWSwgd2hpY2ggd2lsbCBjcmVhdGUgYSBjaGlsZCB3aW5kb3cgY29udGFpbmVyIHRvIGFsbG93IGhvc3Rpbmcgc2Nyb2xsYWJsZSBjb250ZW50cy4KCldlIGFsc28gZGVtb25zdHJhdGUgdXNpbmcgSW1HdWlMaXN0Q2xpcHBlciB0byB2aXJ0dWFsaXplIHRoZSBzdWJtaXNzaW9uIG9mIG1hbnkgaXRlbXMuAEhvbGQgQ1RSTCBhbmQgY2xpY2sgdG8gc2VsZWN0IG11bHRpcGxlIGl0ZW1zLgBTZXQgJ2lvLkNvbmZpZ0ZsYWdzIHw9IE5hdkVuYWJsZUtleWJvYXJkJyBmb3Iga2V5Ym9hcmQgY29udHJvbHMuAEVuYWJsZSBrZXlib2FyZCBjb250cm9scy4AU2V0ICdpby5Db25maWdGbGFncyB8PSBOYXZFbmFibGVHYW1lcGFkJyBmb3IgZ2FtZXBhZCBjb250cm9scy4ARW5hYmxlIGdhbWVwYWQgY29udHJvbHMuIFJlcXVpcmUgYmFja2VuZCB0byBzZXQgaW8uQmFja2VuZEZsYWdzIHw9IEltR3VpQmFja2VuZEZsYWdzX0hhc0dhbWVwYWQuCgpSZWFkIGluc3RydWN0aW9ucyBpbiBpbWd1aS5jcHAgZm9yIGRldGFpbHMuAENKSyB0ZXh0IHdpbGwgb25seSBhcHBlYXJzIGlmIHRoZSBmb250IHdhcyBsb2FkZWQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgQ0pLIGNoYXJhY3RlciByYW5nZXMuIENhbGwgaW8uRm9udC0+QWRkRm9udEZyb21GaWxlVFRGKCkgbWFudWFsbHkgdG8gbG9hZCBleHRyYSBjaGFyYWN0ZXIgcmFuZ2VzLiBSZWFkIGRvY3MvRk9OVFMubWQgZm9yIGRldGFpbHMuAFVzaW5nIHRoZSBfUmVzaXphYmxlIGZsYWcgYXV0b21hdGljYWxseSBlbmFibGVzIHRoZSBfQm9yZGVyc0lubmVyViBmbGFnIGFzIHdlbGwsIHRoaXMgaXMgd2h5IHRoZSByZXNpemUgYm9yZGVycyBhcmUgc3RpbGwgc2hvd2luZyB3aGVuIHVuY2hlY2tpbmcgdGhpcy4AQ29sdW1ucyBkZWZhdWx0IHRvIF9XaWR0aFN0cmV0Y2ggd2l0aCB3ZWlnaHRzIHByb3BvcnRpb25hbCB0byB0aGVpciB3aWR0aHMuAFlvdSBjYW4gZHJhZyBmcm9tIHRoZSBjb2xvciBzcXVhcmVzLgBQcmVzc2VkICVkIHRpbWVzLgBUZXN0IG9mIGRpZmZlcmVudCB3aWRnZXRzIHJlYWN0IGFuZCBpbXBhY3QgdGhlIHdvcmsgcmVjdGFuZ2xlIGdyb3dpbmcgd2hlbiBob3Jpem9udGFsIHNjcm9sbGluZyBpcyBlbmFibGVkLgoKVXNlICdNZXRyaWNzLT5Ub29scy0+U2hvdyB3aW5kb3dzIHJlY3RhbmdsZXMnIHRvIHZpc3VhbGl6ZSByZWN0YW5nbGVzLgBUaGlzIHRleHQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgd3JhcCBvbiB0aGUgZWRnZSBvZiB0aGUgd2luZG93LiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBmb3IgdGV4dCB3cmFwcGluZyBmb2xsb3dzIHNpbXBsZSBydWxlcyBzdWl0YWJsZSBmb3IgRW5nbGlzaCBhbmQgcG9zc2libHkgb3RoZXIgbGFuZ3VhZ2VzLgBVc2UgVEFCL1NISUZUK1RBQiB0byBjeWNsZSB0aHJvdWdoIGtleWJvYXJkIGVkaXRhYmxlIGZpZWxkcy4AVXNpbmcgdGhlIGZvcm1hdCBzdHJpbmcgcGFyYW1ldGVyIHRvIGRpc3BsYXkgYSBuYW1lIGluc3RlYWQgb2YgdGhlIHVuZGVybHlpbmcgaW50ZWdlci4AU2VlIGV4YW1wbGUgYXBwbGljYXRpb25zIGluIHRoZSBleGFtcGxlcy8gZm9sZGVyLgBXaXRoIHRoZSBJbUd1aUNvbG9yRWRpdEZsYWdzX05vSW5wdXRzIGZsYWcgeW91IGNhbiBoaWRlIGFsbCB0aGUgc2xpZGVyL3RleHQgaW5wdXRzLgpXaXRoIHRoZSBJbUd1aUNvbG9yRWRpdEZsYWdzX05vTGFiZWwgZmxhZyB5b3UgY2FuIHBhc3MgYSBub24tZW1wdHkgbGFiZWwgd2hpY2ggd2lsbCBvbmx5IGJlIHVzZWQgZm9yIHRoZSB0b29sdGlwIGFuZCBwaWNrZXIgcG9wdXAuAEJlZ2luR3JvdXAoKSBiYXNpY2FsbHkgbG9ja3MgdGhlIGhvcml6b250YWwgcG9zaXRpb24gZm9yIG5ldyBsaW5lLiBFbmRHcm91cCgpIGJ1bmRsZXMgdGhlIHdob2xlIGdyb3VwIHNvIHRoYXQgeW91IGNhbiB1c2UgIml0ZW0iIGZ1bmN0aW9ucyBzdWNoIGFzIElzSXRlbUhvdmVyZWQoKS9Jc0l0ZW1BY3RpdmUoKSBvciBTYW1lTGluZSgpIGV0Yy4gb24gdGhlIHdob2xlIGdyb3VwLgBTZWUgY29tbWVudHMgaW4gaW1ndWkuY3BwLgBXaW5kb3cgd2lsbCByZXNpemUgZXZlcnktZnJhbWUgdG8gdGhlIHNpemUgb2YgaXRzIGNvbnRlbnQuCk5vdGUgdGhhdCB5b3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byBxdWVyeSB0aGUgd2luZG93IHNpemUgdG8Kb3V0cHV0IHlvdXIgY29udGVudCBiZWNhdXNlIHRoYXQgd291bGQgY3JlYXRlIGEgZmVlZGJhY2sgbG9vcC4AVXNpbmcgVGFibGVOZXh0Um93KCkgKyBjYWxsaW5nIFRhYmxlU2V0Q29sdW1uSW5kZXgoKSBfYmVmb3JlXyBlYWNoIGNlbGwsIGluIGEgbG9vcC4AQ1RSTCtMZWZ0L1JpZ2h0IHRvIHdvcmQganVtcC4ARW50ZXIgJ0hFTFAnIGZvciBoZWxwLgBCeSBkZWZhdWx0LCBjb2xvcnMgYXJlIGdpdmVuIHRvIENvbG9yRWRpdCBhbmQgQ29sb3JQaWNrZXIgaW4gUkdCLCBidXQgSW1HdWlDb2xvckVkaXRGbGFnc19JbnB1dEhTVmFsbG93cyB5b3UgdG8gc3RvcmUgY29sb3JzIGFzIEhTViBhbmQgcGFzcyB0aGVtIHRvIENvbG9yRWRpdCBhbmQgQ29sb3JQaWNrZXIgYXMgSFNWLiBUaGlzIGNvbWVzIHdpdGggdGhlYWRkZWQgYmVuZWZpdCB0aGF0IHlvdSBjYW4gbWFuaXB1bGF0ZSBodWUgdmFsdWVzIHdpdGggdGhlIHBpY2tlciBldmVuIHdoZW4gc2F0dXJhdGlvbiBvciB2YWx1ZSBhcmUgemVyby4AQ1RSTCtaLENUUkwrWSB0byB1bmRvL3JlZG8uAFRoZSBsb2dnaW5nIEFQSSByZWRpcmVjdHMgYWxsIHRleHQgb3V0cHV0IHNvIHlvdSBjYW4gZWFzaWx5IGNhcHR1cmUgdGhlIGNvbnRlbnQgb2YgYSB3aW5kb3cgb3IgYSBibG9jay4gVHJlZSBub2RlcyBjYW4gYmUgYXV0b21hdGljYWxseSBleHBhbmRlZC4KVHJ5IG9wZW5pbmcgYW55IG9mIHRoZSBjb250ZW50cyBiZWxvdyBpbiB0aGlzIHdpbmRvdyBhbmQgdGhlbiBjbGljayBvbmUgb2YgdGhlICJMb2cgVG8iIGJ1dHRvbi4AVXNlIFNldFNjcm9sbEhlcmVZKCkgb3IgU2V0U2Nyb2xsRnJvbVBvc1koKSB0byBzY3JvbGwgdG8gYSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbi4AT25seSB1c2luZyBUYWJsZU5leHRDb2x1bW4oKSwgd2hpY2ggdGVuZHMgdG8gYmUgY29udmVuaWVudCBmb3IgdGFibGVzIHdoZXJlIGV2ZXJ5IGNlbGxzIGNvbnRhaW5zIHRoZSBzYW1lIHR5cGUgb2YgY29udGVudHMuClRoaXMgaXMgYWxzbyBtb3JlIHNpbWlsYXIgdG8gdGhlIG9sZCBOZXh0Q29sdW1uKCkgZnVuY3Rpb24gb2YgdGhlIENvbHVtbnMgQVBJLCBhbmQgcHJvdmlkZWQgdG8gZmFjaWxpdGF0ZSB0aGUgQ29sdW1ucy0+VGFibGVzIEFQSSB0cmFuc2l0aW9uLgBUaGUgc2FtZSBjb250ZW50cyBjYW4gYmUgYWNjZXNzZWQgaW4gJ1Rvb2xzLT5TdHlsZSBFZGl0b3InIG9yIGJ5IGNhbGxpbmcgdGhlIFNob3dTdHlsZUVkaXRvcigpIGZ1bmN0aW9uLgBEZWFyIEltR3VpIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSwgc2VlIExJQ0VOU0UgZm9yIG1vcmUgaW5mb3JtYXRpb24uAFRoaXMgaXMgYSBjdXN0b20gcG9wdXAgZm9yIHVudXNlZCBzcGFjZSBhZnRlciB0aGUgbGFzdCBjb2x1bW4uAFRoaXMgaXMgYSBtb3JlIHR5cGljYWwgbG9va2luZyB0cmVlIHdpdGggc2VsZWN0YWJsZSBub2Rlcy4KQ2xpY2sgdG8gc2VsZWN0LCBDVFJMK0NsaWNrIHRvIHRvZ2dsZSwgY2xpY2sgb24gYXJyb3dzIG9yIGRvdWJsZS1jbGljayB0byBvcGVuLgBTcGVjaWZ5IGhlaWdodCBvZiB0aGUgU2VsZWN0YWJsZSBpdGVtLgBUYXJnZXQgUm93QmcwIHRvIG92ZXJyaWRlIHRoZSBhbHRlcm5hdGluZyBvZGQvZXZlbiBjb2xvcnMsClRhcmdldCBSb3dCZzEgdG8gYmxlbmQgd2l0aCB0aGVtLgBXaGVuIGRpc2FibGluZyBhbnRpLWFsaWFzaW5nIGxpbmVzLCB5b3UnbGwgcHJvYmFibHkgd2FudCB0byBkaXNhYmxlIGJvcmRlcnMgaW4geW91ciBzdHlsZSBhcyB3ZWxsLgBUaGlzIGRlbW9uc3RyYXRlIGVtYmVkZGluZyBhIHRhYmxlIGludG8gYW5vdGhlciB0YWJsZSBjZWxsLgBDVFJMK0Egb3IgZG91YmxlLWNsaWNrIHRvIHNlbGVjdCBhbGwuAEluIHRoZSBBZHZhbmNlZCBkZW1vIHdlIG92ZXJyaWRlIHRoZSBwb2xpY3kgb2YgZWFjaCBjb2x1bW4gc28gdGhvc2UgdGFibGUtd2lkZSBzZXR0aW5ncyBoYXZlIGxlc3MgZWZmZWN0IHRoYXQgdHlwaWNhbC4AY2FuIGZpdCB3aXRoaW4gYSB0ZXh0IGJsb2NrLgBBbHdheXMgY2xhbXAgdmFsdWUgdG8gbWluL21heCBib3VuZHMgKGlmIGFueSkgd2hlbiBpbnB1dCBtYW51YWxseSB3aXRoIENUUkwrQ2xpY2suAEhlcmUgd2UgYXBwZW5kICIuLiIgZWFjaCB0aW1lIFRhYiBpcyBwcmVzc2VkLiBTZWUgJ0V4YW1wbGVzPkNvbnNvbGUnIGZvciBhIG1vcmUgbWVhbmluZ2Z1bCBkZW1vbnN0cmF0aW9uIG9mIHVzaW5nIHRoaXMgY2FsbGJhY2suAEhlcmUgd2UgcmVwbGFjZSBhbmQgc2VsZWN0IHRleHQgZWFjaCB0aW1lIFVwL0Rvd24gYXJlIHByZXNzZWQuIFNlZSAnRXhhbXBsZXM+Q29uc29sZScgZm9yIGEgbW9yZSBtZWFuaW5nZnVsIGRlbW9uc3RyYXRpb24gb2YgdXNpbmcgdGhpcyBjYWxsYmFjay4ARW5hYmxlIHJlc2l6aW5nIG9mIHdpbmRvd3MgZnJvbSB0aGVpciBlZGdlcyBhbmQgZnJvbSB0aGUgbG93ZXItbGVmdCBjb3JuZXIuClRoaXMgcmVxdWlyZXMgKGlvLkJhY2tlbmRGbGFncyAmIEltR3VpQmFja2VuZEZsYWdzX0hhc01vdXNlQ3Vyc29ycykgYmVjYXVzZSBpdCBuZWVkcyBtb3VzZSBjdXJzb3IgZmVlZGJhY2suAERpc2FibGUgZGlzdHJpYnV0aW5nIHJlbWFpbmRlciB3aWR0aCB0byBzdHJldGNoZWQgY29sdW1ucyAod2lkdGggYWxsb2NhdGlvbiBvbiBhIDEwMC13aWRlIHRhYmxlIHdpdGggMyBjb2x1bW5zOiBXaXRob3V0IHRoaXMgZmxhZzogMzMsMzMsMzQuIFdpdGggdGhpcyBmbGFnOiAzMywzMywzMykuIFdpdGggbGFyZ2VyIG51bWJlciBvZiBjb2x1bW5zLCByZXNpemluZyB3aWxsIGFwcGVhciB0byBiZSBsZXNzIHNtb290aC4ARGlzYWJsZSB0aGUgaW5kZW50aW5nIG9mIHRyZWUgbm9kZXMgc28gZGVtbyB0YWJsZXMgY2FuIHVzZSB0aGUgZnVsbCB3aW5kb3cgd2lkdGguAFVzaW5nIFRhYmxlU2V0dXBDb2x1bW4oKSB0byBzZXR1cCBkZWZhdWx0IHdpZHRoLgBCZSBtaW5kZnVsIHRoYXQgdXNpbmcgcmlnaHQtYWxpZ25tZW50IChlLmcuIHNpemUueCA9IC1GTFRfTUlOKSBjcmVhdGVzIGEgZmVlZGJhY2sgbG9vcCB3aGVyZSBjb250ZW50cyB3aWR0aCBjYW4gZmVlZCBpbnRvIGF1dG8tY29sdW1uIHdpZHRoIGNhbiBmZWVkIGludG8gY29udGVudHMgd2lkdGguAENvbHVtbnMgZGVmYXVsdCB0byBfV2lkdGhGaXhlZCAoaWYgcmVzaXphYmxlKSBvciBfV2lkdGhBdXRvIChpZiBub3QgcmVzaXphYmxlKSwgbWF0Y2hpbmcgY29udGVudHMgd2lkdGguAEZpeGVkIHdpZHRoLgBXaWxsIGNhbGwgdGhlIElNX0RFQlVHX0JSRUFLKCkgbWFjcm8gdG8gYnJlYWsgaW4gZGVidWdnZXIuCldhcm5pbmc6IElmIHlvdSBkb24ndCBoYXZlIGEgZGVidWdnZXIgYXR0YWNoZWQsIHRoaXMgd2lsbCBwcm9iYWJseSBjcmFzaC4AVXNpbmcgVGFibGVTZXR1cENvbHVtbigpIHRvIGFsdGVyIHJlc2l6aW5nIHBvbGljeSBvbiBhIHBlci1jb2x1bW4gYmFzaXMuCgpXaGVuIGNvbWJpbmluZyBGaXhlZCBhbmQgU3RyZXRjaCBjb2x1bW5zLCBnZW5lcmFsbHkgeW91IG9ubHkgd2FudCBvbmUsIG1heWJlIHR3byB0cmFpbGluZyBjb2x1bW5zIHRvIHVzZSBfV2lkdGhTdHJldGNoLgBUaGUgbGF6eSBkb2cgaXMgYSBnb29kIGRvZy4gVGhpcyBwYXJhZ3JhcGggc2hvdWxkIGZpdCB3aXRoaW4gJS4wZiBwaXhlbHMuIFRlc3RpbmcgYSAxIGNoYXJhY3RlciB3b3JkLiBUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLgBVc2luZyBJbUd1aUlucHV0VGV4dEZsYWdzX0NhbGxiYWNrUmVzaXplIHRvIHdpcmUgeW91ciBjdXN0b20gc3RyaW5nIHR5cGUgdG8gSW5wdXRUZXh0KCkuCgpTZWUgbWlzYy9jcHAvaW1ndWlfc3RkbGliLmggZm9yIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZm9yIHN0ZDo6c3RyaW5nLgBQcmVzcyBFU0MgdG8gYWJvcnQgcGlja2luZy4AV2Ugb2Z0ZW4gd2FudCBvdXRlciBwYWRkaW5nIGFjdGl2YXRlZCB3aGVuIGFueSB1c2luZyBmZWF0dXJlcyB3aGljaCBtYWtlcyB0aGUgZWRnZXMgb2YgYSBjb2x1bW4gdmlzaWJsZToKZS5nLjoKLSBCb3JkZXJPdXRlclYKLSBhbnkgZm9ybSBvZiByb3cgc2VsZWN0aW9uCkJlY2F1c2Ugb2YgdGhpcywgYWN0aXZhdGluZyBCb3JkZXJPdXRlclYgc2V0cyB0aGUgZGVmYXVsdCB0byBQYWRPdXRlclguIFVzaW5nIFBhZE91dGVyWCBvciBOb1BhZE91dGVyWCB5b3UgY2FuIG92ZXJyaWRlIHRoZSBkZWZhdWx0LgoKQWN0dWFsIHBhZGRpbmcgdmFsdWVzIGFyZSB1c2luZyBzdHlsZS5DZWxsUGFkZGluZy4KCkluIHRoaXMgZGVtbyB3ZSBkb24ndCBzaG93IGhvcml6b250YWwgYm9yZGVycyB0byBlbXBoYXNpcyBob3cgdGhleSBkb24ndCBhZmZlY3QgZGVmYXVsdCBob3Jpem9udGFsIHBhZGRpbmcuAFJlYWQgRkFRIGFuZCBkb2NzL0ZPTlRTLm1kIGZvciBkZXRhaWxzIG9uIGZvbnQgbG9hZGluZy4AVGhpcyBpcyBhbm90aGVyIGNoaWxkIHdpbmRvdyBmb3IgdGVzdGluZyB0aGUgX0NoaWxkV2luZG93cyBmbGFnLgBUaGlzIGlzIHdpbmRvdyAxLgpNeSB0aXRsZSBpcyB0aGUgc2FtZSBhcyB3aW5kb3cgMiwgYnV0IG15IGlkZW50aWZpZXIgaXMgdW5pcXVlLgBUaGlzIGlzIHdpbmRvdyAyLgpNeSB0aXRsZSBpcyB0aGUgc2FtZSBhcyB3aW5kb3cgMSwgYnV0IG15IGlkZW50aWZpZXIgaXMgdW5pcXVlLgBDbGljayBhbmQgZHJhZyB0byBlZGl0IHZhbHVlLgpIb2xkIFNISUZUL0FMVCBmb3IgZmFzdGVyL3Nsb3dlciBlZGl0LgpEb3VibGUtY2xpY2sgb3IgQ1RSTCtjbGljayB0byBpbnB1dCB2YWx1ZS4AU2V0dGluZyBzdHlsZS5DZWxsUGFkZGluZyB0byAoMCwwKSBvciBhIGN1c3RvbSB2YWx1ZS4AQXMgd2l0aCBldmVyeSB3aWRnZXRzIGluIGRlYXIgaW1ndWksIHdlIG5ldmVyIG1vZGlmeSB2YWx1ZXMgdW5sZXNzIHRoZXJlIGlzIGEgdXNlciBpbnRlcmFjdGlvbi4KWW91IGNhbiBvdmVycmlkZSB0aGUgY2xhbXBpbmcgbGltaXRzIGJ5IHVzaW5nIENUUkwrQ2xpY2sgdG8gaW5wdXQgYSB2YWx1ZS4AQ1RSTCtYL0MvViB0byB1c2UgY2xpcGJvYXJkIGN1dC9jb3B5L3Bhc3RlLgBBcnJvdyBrZXlzIHRvIG5hdmlnYXRlLgBTaG93Y2FzZSB1c2luZyBQdXNoSXRlbVdpZHRoKCkgYW5kIGhvdyBpdCBpcyBwcmVzZXJ2ZWQgb24gYSBwZXItY29sdW1uIGJhc2lzLgoKTm90ZSB0aGF0IG9uIGF1dG8tcmVzaXppbmcgbm9uLXJlc2l6YWJsZSBmaXhlZCBjb2x1bW5zLCBxdWVyeWluZyB0aGUgY29udGVudCB3aWR0aCBmb3IgZS5nLiByaWdodC1hbGlnbm1lbnQgZG9lc24ndCBtYWtlIHNlbnNlLgBTaG93Y2FzZSB1c2luZyBTdHJldGNoIGNvbHVtbnMgKyBTY3JvbGxYIHRvZ2V0aGVyOiB0aGlzIGlzIHJhdGhlciB1bnVzdWFsIGFuZCBvbmx5IG1ha2VzIHNlbnNlIHdoZW4gc3BlY2lmeWluZyBhbiAnaW5uZXJfd2lkdGgnIGZvciB0aGUgdGFibGUhCldpdGhvdXQgYW4gZXhwbGljaXQgdmFsdWUsIGlubmVyX3dpZHRoIGlzID09IG91dGVyX3NpemUueCBhbmQgdGhlcmVmb3JlIHVzaW5nIFN0cmV0Y2ggY29sdW1ucyArIFNjcm9sbFggdG9nZXRoZXIgZG9lc24ndCBtYWtlIHNlbnNlLgBVc2UgZGVmYXVsdCBzaXppbmcgcG9saWN5OgotIEltR3VpVGFibGVGbGFnc19TaXppbmdGaXhlZEZpdCBpZiBTY3JvbGxYIGlzIG9uIG9yIGlmIGhvc3Qgd2luZG93IGhhcyBJbUd1aVdpbmRvd0ZsYWdzX0Fsd2F5c0F1dG9SZXNpemUuCi0gSW1HdWlUYWJsZUZsYWdzX1NpemluZ1N0cmV0Y2hTYW1lIG90aGVyd2lzZS4AU2F2ZS9SZXZlcnQgaW4gbG9jYWwgbm9uLXBlcnNpc3RlbnQgc3RvcmFnZS4gRGVmYXVsdCBDb2xvcnMgZGVmaW5pdGlvbiBhcmUgbm90IGFmZmVjdGVkLiBVc2UgIkV4cG9ydCIgYmVsb3cgdG8gc2F2ZSB0aGVtIHNvbWV3aGVyZS4ASSBhbSB0aGUgbGFzdCBvbmUgaGVyZS4AQW4gZXh0cmEgbGluZSBoZXJlLgBXZSBhcmUgY29sb3JpemluZyBjZWxscyB0byBCMS0+QzIgaGVyZS4AVGhlIFRleHREaXNhYmxlZCBjb2xvciBpcyBzdG9yZWQgaW4gSW1HdWlTdHlsZS4ASW1HdWlUYWJsZUZsYWdzX1Jvd0JnIGF1dG9tYXRpY2FsbHkgc2V0cyBSb3dCZzAgdG8gYWx0ZXJuYXRpdmUgY29sb3JzIHB1bGxlZCBmcm9tIHRoZSBTdHlsZS4AVGhpcyB3aW5kb3cgaGFzIGEgY2hhbmdpbmcgdGl0bGUuACUqc0hlbGxvLCBzYWlsb3IhIE1ha2luZyB0aGlzIGxpbmUgbG9uZyBlbm91Z2ggZm9yIHRoZSBleGFtcGxlLgBUaGlzIHRleHQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgd3JhcCBvbiB0aGUgZWRnZSBvZiB0aGUgd29yayByZWN0YW5nbGUuAFNldENvbG9yRWRpdE9wdGlvbnMoKSBpcyBkZXNpZ25lZCB0byBhbGxvdyB5b3UgdG8gc2V0IGJvb3QtdGltZSBkZWZhdWx0LgpXZSBkb24ndCBoYXZlIFB1c2gvUG9wIGZ1bmN0aW9ucyBiZWNhdXNlIHlvdSBjYW4gZm9yY2Ugb3B0aW9ucyBvbiBhIHBlci13aWRnZXQgYmFzaXMgaWYgbmVlZGVkLGFuZCB0aGUgdXNlciBjYW4gY2hhbmdlIG5vbi1mb3JjZWQgb25lcyB3aXRoIHRoZSBvcHRpb25zIG1lbnUuCldlIGRvbid0IGhhdmUgYSBnZXR0ZXIgdG8gYXZvaWRlbmNvdXJhZ2luZyB5b3UgdG8gcGVyc2lzdGVudGx5IHNhdmUgdmFsdWVzIHRoYXQgYXJlbid0IGZvcndhcmQtY29tcGF0aWJsZS4ATWFrZSBvdXRlciBoZWlnaHQgc3RvcCBleGFjdGx5IGF0IG91dGVyX3NpemUueSAocHJldmVudCBhdXRvLWV4dGVuZGluZyB0YWJsZSBwYXN0IHRoZSBsaW1pdCkuCgpPbmx5IGF2YWlsYWJsZSB3aGVuIFNjcm9sbFgvU2Nyb2xsWSBhcmUgZGlzYWJsZWQuIERhdGEgYmVsb3cgdGhlIGxpbWl0IHdpbGwgYmUgY2xpcHBlZCBhbmQgbm90IHZpc2libGUuAENvbHVtbnMgYXJlIGFsbCB0aGUgc2FtZSB3aWR0aCwgbWF0Y2hpbmcgdGhlIG1heGltdW0gY29udGVudHMgd2lkdGguCkltcGxpY2l0bHkgZGlzYWJsZSBJbUd1aVRhYmxlRmxhZ3NfUmVzaXphYmxlIGFuZCBlbmFibGUgSW1HdWlUYWJsZUZsYWdzX05vS2VlcENvbHVtbnNWaXNpYmxlLgBFeHRlbmQgaGl0IGFyZWEgdG8gYWxsIGF2YWlsYWJsZSB3aWR0aCBpbnN0ZWFkIG9mIGFsbG93aW5nIG1vcmUgaXRlbXMgdG8gYmUgbGFpZCBvdXQgYWZ0ZXIgdGhlIG5vZGUuAFVzZXIgY2FuIHJpZ2h0LWNsaWNrIHRoZSBwaWNrZXIgdG8gY2hhbmdlIG1vZGUuAE5COiBDdXJzb3IgJiBzZWxlY3Rpb24gYXJlIHByZXNlcnZlZCB3aGVuIHJlZm9jdXNpbmcgbGFzdCB1c2VkIGl0ZW0gaW4gY29kZS4ATW9kYWwgd2luZG93cyBhcmUgbGlrZSBwb3B1cHMgYnV0IHRoZSB1c2VyIGNhbm5vdCBjbG9zZSB0aGVtIGJ5IGNsaWNraW5nIG91dHNpZGUuAFRob3NlIGZsYWdzIGFyZSBzZXQgYnkgdGhlIGJhY2tlbmRzIChpbWd1aV9pbXBsX3h4eCBmaWxlcykgdG8gc3BlY2lmeSB0aGVpciBjYXBhYmlsaXRpZXMuCkhlcmUgd2UgZXhwb3NlIHRoZW4gYXMgcmVhZC1vbmx5IGZpZWxkcyB0byBhdm9pZCBicmVha2luZyBpbnRlcmFjdGlvbnMgd2l0aCB5b3VyIGJhY2tlbmQuAE1ha2Ugb3V0ZXIgd2lkdGggYXV0by1maXQgdG8gY29sdW1ucywgb3ZlcnJpZGluZyBvdXRlcl9zaXplLnggdmFsdWUuCgpPbmx5IGF2YWlsYWJsZSB3aGVuIFNjcm9sbFgvU2Nyb2xsWSBhcmUgZGlzYWJsZWQgYW5kIFN0cmV0Y2ggY29sdW1ucyBhcmUgbm90IHVzZWQuAE9ubHkgYXZhaWxhYmxlIGlmIFNjcm9sbFggaXMgZGlzYWJsZWQuAE5vdGU6IHNvbWUgbWVtb3J5IGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbXBhY3RlZC9mcmVlZC4ATXVsdGlwbGUgdGFibGVzIHdpdGggdGhlIHNhbWUgaWRlbnRpZmllciB3aWxsIHNoYXJlIHRoZWlyIHNldHRpbmdzLCB3aWR0aCwgdmlzaWJpbGl0eSwgb3JkZXIgZXRjLgBUaGlzIGV4YW1wbGUgaW1wbGVtZW50cyBhIGNvbnNvbGUgd2l0aCBiYXNpYyBjb2xvcmluZywgY29tcGxldGlvbiAoVEFCIGtleSkgYW5kIGhpc3RvcnkgKFVwL0Rvd24ga2V5cykuIEEgbW9yZSBlbGFib3JhdGUgaW1wbGVtZW50YXRpb24gbWF5IHdhbnQgdG8gc3RvcmUgZW50cmllcyBhbG9uZyB3aXRoIGV4dHJhIGRhdGEgc3VjaCBhcyB0aW1lc3RhbXAsIGVtaXR0ZXIsIGV0Yy4ASSBhbSBhbiBvZGQgdGFiLgBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4AVGhpcyBleGFtcGxlIHNob3dzIGhvdyB5b3UgbWF5IGltcGxlbWVudCBhIHByb3BlcnR5IGVkaXRvciB1c2luZyB0d28gY29sdW1ucy4KQWxsIG9iamVjdHMvZmllbGRzIGRhdGEgYXJlIGR1bW1pZXMgaGVyZS4KUmVtZW1iZXIgdGhhdCBpbiBtYW55IHNpbXBsZSBjYXNlcywgeW91IGNhbiB1c2UgSW1HdWk6OlNhbWVMaW5lKHh4eCkgdG8gcG9zaXRpb24KeW91ciBjdXJzb3IgaG9yaXpvbnRhbGx5IGluc3RlYWQgb2YgdXNpbmcgdGhlIENvbHVtbnMoKSBBUEkuAEZpbGUgTWVudS4uAEJhc2VsaW5lIG9mIGJ1dHRvbiB3aWxsIGxvb2sgbWlzYWxpZ25lZCB3aXRoIHRleHQuLgBTZWxlY3QuLgBBbmQgbm93IHNvbWUgdGV4dHVyZWQgYnV0dG9ucy4uAFN0YWNrZWQgbW9kYWxzLi4AU29tZSAlcyB0ZXh0ICVkLCVkCk92ZXIgdHdvIGxpbmVzLi4AQ29weSBhcy4uAFNhdmUgQXMuLgBDb2x1bW4gJWQgb3JkZXIgJWQgJyVzJzogb2Zmc2V0ICUrLjJmIHRvICUrLjJmJXMKRW5hYmxlZDogJWQsIFZpc2libGVYL1k6ICVkLyVkLCBSZXF1ZXN0T3V0cHV0OiAlZCwgU2tpcEl0ZW1zOiAlZCwgRHJhd0NoYW5uZWxzOiAlZCwlZApXaWR0aEdpdmVuOiAlLjFmLCBSZXF1ZXN0L0F1dG86ICUuMWYvJS4xZiwgU3RyZXRjaFdlaWdodDogJS4zZiAoJS4xZiUlKQpNaW5YOiAlLjFmLCBNYXhYOiAlLjFmICglKy4xZiksIENsaXBSZWN0OiAlLjFmIHRvICUuMWYgKCslLjFmKQpDb250ZW50V2lkdGg6ICUuMWYsJS4xZiwgSGVhZGVyc1VzZWQvSWRlYWwgJS4xZi8lLjFmClNvcnQ6ICVkJXMsIFVzZXJJRDogMHglMDhYLCBGbGFnczogMHglMDRYOiAlcyVzJXMuLgBJdGVtIFBpY2tlci4uAEFkZCBhbm90aGVyIG1vZGFsLi4ARGVsZXRlLi4AUmVjdXJzZS4uAE1vcmUuLgBUb2dnbGUuLgBJdGVtICVkLi4AYW5vdGhlciBvbmUgb2YgdGhvc2UgdHJlZSBub2RlLi4uAExpbmUgJWQgQ29sdW1uICVkLi4uAERlbW9uc3RyYXRlIG1peGluZyB0YWJsZSBjb250ZXh0IG1lbnUgKG92ZXIgaGVhZGVyKSwgaXRlbSBjb250ZXh0IGJ1dHRvbiAob3ZlciBidXR0b24pIGFuZCBjdXN0b20gcGVyLWNvbHVtIGNvbnRleHQgbWVudSAob3ZlciBjb2x1bW4gYm9keSkuAElmIHNjcm9sbGluZyBpcyBkaXNhYmxlZCAoU2Nyb2xsWCBhbmQgU2Nyb2xsWSBub3Qgc2V0KToKLSBUaGUgdGFibGUgaXMgb3V0cHV0IGRpcmVjdGx5IGluIHRoZSBwYXJlbnQgd2luZG93LgotIE91dGVyU2l6ZS54IDwgMC4wZiB3aWxsIHJpZ2h0LWFsaWduIHRoZSB0YWJsZS4KLSBPdXRlclNpemUueCA9IDAuMGYgd2lsbCBuYXJyb3cgZml0IHRoZSB0YWJsZSB1bmxlc3MgdGhlcmUgYXJlIGFueSBTdHJldGNoIGNvbHVtbi4KLSBPdXRlclNpemUueSB0aGVuIGJlY29tZXMgdGhlIG1pbmltdW0gc2l6ZSBmb3IgdGhlIHRhYmxlLCB3aGljaCB3aWxsIGV4dGVuZCB2ZXJ0aWNhbGx5IGlmIHRoZXJlIGFyZSBtb3JlIHJvd3MgKHVubGVzcyBOb0hvc3RFeHRlbmRZIGlzIHNldCkuAENsaWNrIGFuZCBkcmFnIG9uIGxvd2VyIGNvcm5lciB0byByZXNpemUgd2luZG93Cihkb3VibGUtY2xpY2sgdG8gYXV0byBmaXQgd2luZG93IHRvIGl0cyBjb250ZW50cykuAERpc2FibGUgcm91bmRpbmcgdW5kZXJseWluZyB2YWx1ZSB0byBtYXRjaCBwcmVjaXNpb24gb2YgdGhlIGZvcm1hdCBzdHJpbmcgKGUuZy4gJS4zZiB2YWx1ZXMgYXJlIHJvdW5kZWQgdG8gdGhvc2UgMyBkaWdpdHMpLgBXaGVuIFNjcm9sbFggaXMgZW5hYmxlZCwgdGhlIGRlZmF1bHQgc2l6aW5nIHBvbGljeSBiZWNvbWVzIEltR3VpVGFibGVGbGFnc19TaXppbmdGaXhlZEZpdCwgYXMgYXV0b21hdGljYWxseSBzdHJldGNoaW5nIGNvbHVtbnMgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2Ugd2l0aCBob3Jpem9udGFsIHNjcm9sbGluZy4KCkFsc28gbm90ZSB0aGF0IGFzIG9mIHRoZSBjdXJyZW50IHZlcnNpb24sIHlvdSB3aWxsIGFsbW9zdCBhbHdheXMgd2FudCB0byBlbmFibGUgU2Nyb2xsWSBhbG9uZyB3aXRoIFNjcm9sbFgsYmVjYXVzZSB0aGUgY29udGFpbmVyIHdpbmRvdyB3b24ndCBhdXRvbWF0aWNhbGx5IGV4dGVuZCB2ZXJ0aWNhbGx5IHRvIGZpeCBjb250ZW50cyAodGhpcyBtYXkgYmUgaW1wcm92ZWQgaW4gZnV0dXJlIHZlcnNpb25zKS4ARW5hYmxlIGxvZ2FyaXRobWljIGVkaXRpbmcgKG1vcmUgcHJlY2lzaW9uIGZvciBzbWFsbCB2YWx1ZXMpLgBVU0VSOgpIb2xkIFNISUZUIG9yIHVzZSBtb3VzZSB0byBzZWxlY3QgdGV4dC4KQ1RSTCtMZWZ0L1JpZ2h0IHRvIHdvcmQganVtcC4KQ1RSTCtBIG9yIGRvdWJsZS1jbGljayB0byBzZWxlY3QgYWxsLgpDVFJMK1gsQ1RSTCtDLENUUkwrViBjbGlwYm9hcmQuCkNUUkwrWixDVFJMK1kgdW5kby9yZWRvLgpFU0NBUEUgdG8gcmV2ZXJ0LgoKUFJPR1JBTU1FUjoKWW91IGNhbiB1c2UgdGhlIEltR3VpSW5wdXRUZXh0RmxhZ3NfQ2FsbGJhY2tSZXNpemUgZmFjaWxpdHkgaWYgeW91IG5lZWQgdG8gd2lyZSBJbnB1dFRleHQoKSB0byBhIGR5bmFtaWMgc3RyaW5nIHR5cGUuIFNlZSBtaXNjL2NwcC9pbWd1aV9zdGRsaWIuaCBmb3IgYW4gZXhhbXBsZSAodGhpcyBpcyBub3QgZGVtb25zdHJhdGVkIGluIGltZ3VpX2RlbW8uY3BwKS4AVGhlICJUb29scyIgbWVudSBhYm92ZSBnaXZlcyBhY2Nlc3MgdG86IEFib3V0IEJveCwgU3R5bGUgRWRpdG9yLAphbmQgTWV0cmljcy9EZWJ1Z2dlciAoZ2VuZXJhbCBwdXJwb3NlIERlYXIgSW1HdWkgZGVidWdnaW5nIHRvb2wpLgBFbmFibGUgdHVybmluZyBEcmFnWFhYIHdpZGdldHMgaW50byB0ZXh0IGlucHV0IHdpdGggYSBzaW1wbGUgbW91c2UgY2xpY2stcmVsZWFzZSAod2l0aG91dCBtb3ZpbmcpLgBGYXN0ZXIgbGluZXMgdXNpbmcgdGV4dHVyZSBkYXRhLiBSZXF1aXJlIGJhY2tlbmQgdG8gcmVuZGVyIHdpdGggYmlsaW5lYXIgZmlsdGVyaW5nIChub3QgcG9pbnQvbmVhcmVzdCBmaWx0ZXJpbmcpLgBJbnN0cnVjdCBEZWFyIEltR3VpIHRvIHJlbmRlciBhIG1vdXNlIGN1cnNvciBpdHNlbGYuIE5vdGUgdGhhdCBhIG1vdXNlIGN1cnNvciByZW5kZXJlZCB2aWEgeW91ciBhcHBsaWNhdGlvbiBHUFUgcmVuZGVyaW5nIHBhdGggd2lsbCBmZWVsIG1vcmUgbGFnZ3kgdGhhbiBoYXJkd2FyZSBjdXJzb3IsIGJ1dCB3aWxsIGJlIG1vcmUgaW4gc3luYyB3aXRoIHlvdXIgb3RoZXIgdmlzdWFscy4KClNvbWUgZGVza3RvcCBhcHBsaWNhdGlvbnMgbWF5IHVzZSBib3RoIGtpbmRzIG9mIGN1cnNvcnMgKGUuZy4gZW5hYmxlIHNvZnR3YXJlIGN1cnNvciBvbmx5IHdoZW4gcmVzaXppbmcvZHJhZ2dpbmcgc29tZXRoaW5nKS4AQWRqdXN0IGlmIHlvdSBjYW5ub3Qgc2VlIHRoZSBlZGdlcyBvZiB5b3VyIHNjcmVlbiAoZS5nLiBvbiBhIFRWIHdoZXJlIHNjYWxpbmcgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQpLgBXaGVuIHNvcnRpbmcgaXMgZW5hYmxlZDogaG9sZCBzaGlmdCB3aGVuIGNsaWNraW5nIGhlYWRlcnMgdG8gc29ydCBvbiBtdWx0aXBsZSBjb2x1bW4uIFRhYmxlR2V0U29ydFNwZWNzKCkgbWF5IHJldHVybiBzcGVjcyB3aGVyZSAoU3BlY3NDb3VudCA+IDEpLgBXaGVuIHNvcnRpbmcgaXMgZW5hYmxlZDogYWxsb3cgbm8gc29ydGluZywgZGlzYWJsZSBkZWZhdWx0IHNvcnRpbmcuIFRhYmxlR2V0U29ydFNwZWNzKCkgbWF5IHJldHVybiBzcGVjcyB3aGVyZSAoU3BlY3NDb3VudCA9PSAwKS4AQ29sb3JFZGl0IGRlZmF1bHRzIHRvIGRpc3BsYXlpbmcgUkdCIGlucHV0cyBpZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhIGRpc3BsYXkgbW9kZSwgYnV0IHRoZSB1c2VyIGNhbiBjaGFuZ2UgaXQgd2l0aCBhIHJpZ2h0LWNsaWNrLgoKQ29sb3JQaWNrZXIgZGVmYXVsdHMgdG8gZGlzcGxheWluZyBSR0IrSFNWK0hleCBpZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhIGRpc3BsYXkgbW9kZS4KCllvdSBjYW4gY2hhbmdlIHRoZSBkZWZhdWx0cyB1c2luZyBTZXRDb2xvckVkaXRPcHRpb25zKCkuAEhvcml6b250YWwgc2Nyb2xsaW5nIGZvciBhIHdpbmRvdyBpcyBlbmFibGVkIHZpYSB0aGUgSW1HdWlXaW5kb3dGbGFnc19Ib3Jpem9udGFsU2Nyb2xsYmFyIGZsYWcuCgpZb3UgbWF5IHdhbnQgdG8gYWxzbyBleHBsaWNpdGx5IHNwZWNpZnkgY29udGVudCB3aWR0aCBieSB1c2luZyBTZXROZXh0V2luZG93Q29udGVudFdpZHRoKCkgYmVmb3JlIEJlZ2luKCkuAC0gTG9hZCBhZGRpdGlvbmFsIGZvbnRzIHdpdGggaW8uRm9udHMtPkFkZEZvbnRGcm9tRmlsZVRURigpLgotIFRoZSBmb250IGF0bGFzIGlzIGJ1aWx0IHdoZW4gY2FsbGluZyBpby5Gb250cy0+R2V0VGV4RGF0YUFzWFhYWCgpIG9yIGlvLkZvbnRzLT5CdWlsZCgpLgotIFJlYWQgRkFRIGFuZCBkb2NzL0ZPTlRTLm1kIGZvciBtb3JlIGRldGFpbHMuCi0gSWYgeW91IG5lZWQgdG8gYWRkL3JlbW92ZSBmb250cyBhdCBydW50aW1lIChlLmcuIGZvciBEUEkgY2hhbmdlKSwgZG8gaXQgYmVmb3JlIGNhbGxpbmcgTmV3RnJhbWUoKS4AVGVzdGluZyBob3cgdmFyaW91cyB0eXBlcyBvZiBpdGVtcyBhcmUgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgSXNJdGVtWFhYIGZ1bmN0aW9ucy4gTm90ZSB0aGF0IHRoZSBib29sIHJldHVybiB2YWx1ZSBvZiBtb3N0IEltR3VpIGZ1bmN0aW9uIGlzIGdlbmVyYWxseSBlcXVpdmFsZW50IHRvIGNhbGxpbmcgSW1HdWk6OklzSXRlbUhvdmVyZWQoKS4AWW91IGNhbiBpbnB1dCB2YWx1ZSB1c2luZyB0aGUgc2NpZW50aWZpYyBub3RhdGlvbiwKICBlLmcuICIxZSs4IiBiZWNvbWVzICIxMDAwMDAwMDAiLgAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQAgIHcvIGRlZmF1bHQgdGhyZXNob2xkOiAlZCwAICB3LyB6ZXJvIHRocmVzaG9sZDogJWQsACAgdy8gbGFyZ2UgdGhyZXNob2xkOiAlZCwAKwAqVW5rbm93biBpdGVtKgAgKkluYWN0aXZlKgBjb21ibyAzIChhcnJheSkAQ29sdW1uICUwMmQ6IE9mZnNldE5vcm0gJS4zZiAoPSAlLjFmIHB4KQBnLkFjdGl2ZUlkID09IGNvbHVtbnMtPklEICsgSW1HdWlJRChjb2x1bW5faW5kZXgpACh4KQBTZWxlY3RhYmxlIChzcGFuIHJvdykAOiBEcmF3Q21kOiArJWQgKGluIHNhbWUgd2luZG93KQBwYXJlbnRfd2luZG93ICE9IDBMIHx8ICEoZmxhZ3MgJiBJbUd1aVdpbmRvd0ZsYWdzX0NoaWxkV2luZG93KQAoZmxhZ3MgJiAoSW1HdWlDb21ib0ZsYWdzX05vQXJyb3dCdXR0b24gfCBJbUd1aUNvbWJvRmxhZ3NfTm9QcmV2aWV3KSkgIT0gKEltR3VpQ29tYm9GbGFnc19Ob0Fycm93QnV0dG9uIHwgSW1HdWlDb21ib0ZsYWdzX05vUHJldmlldykAKGRlbW8gbWVudSkAaW5wdXQgdGV4dCAody8gaGludCkAcGFzc3dvcmQgKHcvIGhpbnQpAHBheWxvYWQtPkRhdGFTaXplID09IHNpemVvZihpbnQpAERpc2FibGUgb3V0ZXItbW9zdCBwYWRkaW5nIChkZWZhdWx0IGlmIEltR3VpVGFibGVGbGFnc19Cb3JkZXJzT3V0ZXJWIGlzIG5vdCBzZXQpAEVuYWJsZSBvdXRlci1tb3N0IHBhZGRpbmcgKGRlZmF1bHQgaWYgSW1HdWlUYWJsZUZsYWdzX0JvcmRlcnNPdXRlclYgaXMgc2V0KQBIYWxmIG9mIGF2YWlsYWJsZSB3aWR0aC4KKH4gcmlnaHQtY3Vyc29yX3BvcykKKHdvcmtzIHdpdGhpbiBhIGNvbHVtbiBzZXQpAGxpc3Rib3gKKHNpbmdsZSBzZWxlY3QpAEJ1dHRvbiAody8gcmVwZWF0KQBEaXNhYmxlIHZlcnRpY2FsIGJvcmRlcnMgaW4gY29sdW1ucyBCb2R5IHVudGlsIGhvdmVyZWQgZm9yIHJlc2l6ZSAoYm9yZGVycyB3aWxsIGFsd2F5cyBhcHBlYXJzIGluIEhlYWRlcnMpAFVzaW5nIEltR3VpOjpQdXNoQ2xpcFJlY3QoKToKV2lsbCBhbHRlciBJbUd1aSBoaXQtdGVzdGluZyBsb2dpYyArIEltRHJhd0xpc3QgcmVuZGVyaW5nLgoodXNlIHRoaXMgaWYgeW91IHdhbnQgeW91ciBjbGlwcGluZyByZWN0YW5nbGUgdG8gYWZmZWN0IGludGVyYWN0aW9ucykAU2V0dGluZ3MgMHglMDhYICglZCBjb2x1bW5zKQBVc2luZyBJbURyYXdMaXN0OjpBZGRUZXh0KCkgd2l0aCBhIGZpbmUgQ2xpcFJlY3Q6CldpbGwgYWx0ZXIgb25seSB0aGlzIHNwZWNpZmljIEltRHJhd0xpc3Q6OkFkZFRleHQoKSByZW5kZXJpbmcuCih0aGlzIGlzIG9mdGVuIHVzZWQgaW50ZXJuYWxseSB0byBhdm9pZCBhbHRlcmluZyB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlIGFuZCBtaW5pbWl6ZSBkcmF3IGNhbGxzKQBVc2luZyBJbURyYXdMaXN0OjpQdXNoQ2xpcFJlY3QoKToKV2lsbCBhbHRlciBJbURyYXdMaXN0IHJlbmRlcmluZyBvbmx5LgoodXNlIHRoaXMgYXMgYSBzaG9ydGN1dCBpZiB5b3UgYXJlIG9ubHkgdXNpbmcgSW1EcmF3TGlzdCBjYWxscykAQnVsbGV0IHBvaW50IDMgKHR3byBjYWxscykAQXRsYXMgdGV4dHVyZSAoJWR4JWQgcGl4ZWxzKQBEcmFnRHJvcDogJWQsIFNvdXJjZUlkID0gMHglMDhYLCBQYXlsb2FkICIlcyIgKCVkIGJ5dGVzKQAlZCB2ZXJ0aWNlcywgJWQgaW5kaWNlcyAoJWQgdHJpYW5nbGVzKQAgKERlcykAcmFuZ2UgaW50IChubyBib3VuZHMpAGIlZCAoJS4wMmYgc2VjcykAJWQgKDB4JVgpICglLjAyZiBzZWNzKQBGb250OiAiJXMiCiUuMmYgcHgsICVkIGdseXBocywgJWQgZmlsZShzKQBkZWFyIGltZ3VpIHNheXMgaGVsbG8uICglcykAVSslMDRYLi5VKyUwNFggKCVkICVzKQB3aW5kb3ctPkRDLk5hdkxheWVyQWN0aXZlTWFza05leHQgJiAoMSA8PCBsYXllcikAY29tYm8gMiAob25lLWxpbmVyKQBwYXNzd29yZCAoY2xlYXIpAChNYWluIG1lbnUgYmFyKQAoUG9wdXApADQgKHRhYiBza2lwKQAzICh0YWIgc2tpcCkAIChhdXRvKQBIaXJhZ2FuYTog44GL44GN44GP44GR44GTIChrYWtpa3VrZWtvKQBLYW5qaXM6IOaXpeacrOiqniAobmlob25nbykAIWlzX3RhYl9idXR0b24gfHwgISh0YWJfYmFyLT5TZWxlY3RlZFRhYklkID09IHRhYi0+SUQgJiYgaXNfdGFiX2J1dHRvbikAIXBfb3BlbiB8fCAhKGZsYWdzICYgSW1HdWlUYWJJdGVtRmxhZ3NfQnV0dG9uKQAhKHRhYi0+RmxhZ3MgJiBJbUd1aVRhYkl0ZW1GbGFnc19CdXR0b24pAFNpbXBsZSBvdmVybGF5CmluIHRoZSBjb3JuZXIgb2YgdGhlIHNjcmVlbi4KKHJpZ2h0LWNsaWNrIHRvIGNoYW5nZSBwb3NpdGlvbikAY29tYm8gNCAoZnVuY3Rpb24pAGl0ZW1zX3R5cGUgKGZpcnN0IGNvbHVtbikAIChGcm96ZW4pAChVc2UgSW1HdWk6OlNhbWVMaW5lKCkgdG8ga2VlcCBhZGRpbmcgaXRlbXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwcmVjZWRpbmcgaXRlbSkAKG51bGwpAChDbGljayBhbmQgZHJhZyB0byBzY3JvbGwpAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb2xvckVkaXRGbGFnc19fRGlzcGxheU1hc2spAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb2xvckVkaXRGbGFnc19fSW5wdXRNYXNrKQBJbUlzUG93ZXJPZlR3byhmbGFncyAmIEltR3VpQ29sb3JFZGl0RmxhZ3NfX1BpY2tlck1hc2spAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb2xvckVkaXRGbGFnc19fRGF0YVR5cGVNYXNrKQBUcmVlTm9kZSAody8gZG91YmxlLWNsaWNrKQBzbGlkZXIgZmxvYXQgKGxvZykARW1iZWQgZXZlcnl0aGluZyBpbnNpZGUgYSBjaGlsZCB3aW5kb3cgKGZvciBhZGRpdGlvbmFsIHRlc3RpbmcpAEVuYWJsZSBibGlua2luZyBjdXJzb3IgKG9wdGlvbmFsIGFzIHNvbWUgdXNlcnMgY29uc2lkZXIgaXQgdG8gYmUgZGlzdHJhY3RpbmcpAChmbGFncyAmIChJbUd1aVRhYkl0ZW1GbGFnc19MZWFkaW5nIHwgSW1HdWlUYWJJdGVtRmxhZ3NfVHJhaWxpbmcpKSAhPSAoSW1HdWlUYWJJdGVtRmxhZ3NfTGVhZGluZyB8IEltR3VpVGFiSXRlbUZsYWdzX1RyYWlsaW5nKQBNb3VzZSBwb3M6ICglZywgJWcpAE1vdXNlIGRlbHRhOiAoJWcsICVnKQBjYWxsYmFja19kYXRhLkJ1ZlRleHRMZW4gPT0gKGludClzdHJsZW4oY2FsbGJhY2tfZGF0YS5CdWYpAERyYWdGbG9hdCAoLWluZiAtPiAraW5mKQBEcmFnRmxvYXQgKDAgLT4gK2luZikARGlzYWJsZSBpbm5lciBwYWRkaW5nIGJldHdlZW4gY29sdW1ucyAoZG91YmxlIGlubmVyIHBhZGRpbmcgaWYgQm9yZGVyc091dGVyViBpcyBvbiwgc2luZ2xlIGlubmVyIHBhZGRpbmcgaWYgQm9yZGVyc091dGVyViBpcyBvZmYpACglLjNmZiwgJS4zZmYsICUuM2ZmLCAlLjNmZikAMTcuMC4wIChodHRwczovL2dpdGh1Yi5jb20vbGx2bS9sbHZtLXByb2plY3QgODg0MjFlYTk3MzkxNmU2MGMzNGJlYjI2NTk3YTVmYzMzZjgzZGQ4ZikAU2V0TmV4dEl0ZW1XaWR0aC9QdXNoSXRlbVdpZHRoKC1HZXRDb250ZW50UmVnaW9uQXZhaWwoKS54ICogMC41ZikAU2V0TmV4dEl0ZW1XaWR0aC9QdXNoSXRlbVdpZHRoKEdldENvbnRlbnRSZWdpb25BdmFpbCgpLnggKiAwLjVmKQBVVjogKCUuM2YsJS4zZiktPiglLjNmLCUuM2YpACMlMDJYJTAyWCUwMlgKUjogJWQsIEc6ICVkLCBCOiAlZAooJS4zZiwgJS4zZiwgJS4zZikAIyUwMlglMDJYJTAyWCUwMlgKUjolZCwgRzolZCwgQjolZCwgQTolZAooJS4zZiwgJS4zZiwgJS4zZiwgJS4zZikAUG9zOiAoJS4yZiwlLjJmKS0+KCUuMmYsJS4yZikATWF4OiAoJS4yZiwgJS4yZikATWluOiAoJS4yZiwgJS4yZikAKHc6ICU1LjFmKQBOYXZSZWN0UmVsWzBdOiAoJS4xZiwlLjFmKSglLjFmLCUuMWYpAFBvczogKCUuMWYsJS4xZiksIFNpemU6ICglLjFmLCUuMWYpLCBDb250ZW50U2l6ZSAoJS4xZiwlLjFmKSBJZGVhbCAoJS4xZiwlLjFmKQBJbnB1dCAlZDogJyVzJywgT3ZlcnNhbXBsZTogKCVkLCVkKSwgUGl4ZWxTbmFwSDogJWQsIE9mZnNldDogKCUuMWYsJS4xZikATW91c2UgUG9zaXRpb246ICglLjFmLCUuMWYpAFdpZHRoOiAlLjFmIChNaW5YOiAlLjFmLCBNYXhYOiAlLjFmKQBSZXR1cm4gdmFsdWUgPSAlZApJc0l0ZW1Gb2N1c2VkKCkgPSAlZApJc0l0ZW1Ib3ZlcmVkKCkgPSAlZApJc0l0ZW1Ib3ZlcmVkKF9BbGxvd1doZW5CbG9ja2VkQnlQb3B1cCkgPSAlZApJc0l0ZW1Ib3ZlcmVkKF9BbGxvd1doZW5CbG9ja2VkQnlBY3RpdmVJdGVtKSA9ICVkCklzSXRlbUhvdmVyZWQoX0FsbG93V2hlbk92ZXJsYXBwZWQpID0gJWQKSXNJdGVtSG92ZXJlZChfUmVjdE9ubHkpID0gJWQKSXNJdGVtQWN0aXZlKCkgPSAlZApJc0l0ZW1FZGl0ZWQoKSA9ICVkCklzSXRlbUFjdGl2YXRlZCgpID0gJWQKSXNJdGVtRGVhY3RpdmF0ZWQoKSA9ICVkCklzSXRlbURlYWN0aXZhdGVkQWZ0ZXJFZGl0KCkgPSAlZApJc0l0ZW1WaXNpYmxlKCkgPSAlZApJc0l0ZW1DbGlja2VkKCkgPSAlZApJc0l0ZW1Ub2dnbGVkT3BlbigpID0gJWQKR2V0SXRlbVJlY3RNaW4oKSA9ICglLjFmLCAlLjFmKQpHZXRJdGVtUmVjdE1heCgpID0gKCUuMWYsICUuMWYpCkdldEl0ZW1SZWN0U2l6ZSgpID0gKCUuMWYsICUuMWYpACAgdy8gZGVmYXVsdCB0aHJlc2hvbGQ6ICglLjFmLCAlLjFmKQAgIHcvIHplcm8gdGhyZXNob2xkOiAoJS4xZiwgJS4xZikAaW8uTW91c2VEZWx0YTogKCUuMWYsICUuMWYpAERyYXdDbWQ6JTVkIHRyaXMsIFRleCAweCVwLCBDbGlwUmVjdCAoJTQuMGYsJTQuMGYpLSglNC4wZiwlNC4wZikAUmVjdCBvZiBjaGlsZCB3aW5kb3cgaXM6ICglLjBmLCUuMGYpICglLjBmLCUuMGYpADogRHJhd0NtZDogKyVkIChpbiBjaGlsZCB3aW5kb3cpLCBTY3JvbGw6ICglLmYvJS5mKSAoJS5mLyUuZikAaW5uZXJfd2lkdGggKHdoZW4gU2Nyb2xsWCBhY3RpdmUpAFNsaWRlcnMgKHJldmVyc2UpAFlvdSBjYW4gdXNlIHRoZSBJbUd1aUlucHV0VGV4dEZsYWdzX0NhbGxiYWNrUmVzaXplIGZhY2lsaXR5IGlmIHlvdSBuZWVkIHRvIHdpcmUgSW5wdXRUZXh0TXVsdGlsaW5lKCkgdG8gYSBkeW5hbWljIHN0cmluZyB0eXBlLiBTZWUgbWlzYy9jcHAvaW1ndWlfc3RkbGliLmggZm9yIGFuIGV4YW1wbGUuIChUaGlzIGlzIG5vdCBkZW1vbnN0cmF0ZWQgaW4gaW1ndWlfZGVtby5jcHAgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgPHN0cmluZz4gaW4gaGVyZSkAVmFsdWUgPSAlLjNmICg8LS0gcmlnaHQtY2xpY2sgaGVyZSkAIShmbGFncyAmIEltR3VpSW5wdXRUZXh0RmxhZ3NfTXVsdGlsaW5lKQBEcmFnIHRvIHJlb3JkZXIgaXRlbXMgKHNpbXBsZSkAJWQgYWN0aXZlIHdpbmRvd3MgKCVkIHZpc2libGUpAGNvbmQgPT0gMCB8fCBJbUlzUG93ZXJPZlR3byhjb25kKQAoVW50aXRsZWQpACglZCwlZCwlZCwlZCkAQWN0aXZlIERyYXdMaXN0cyAoJWQpAENvbHVtbnMgc2V0cyAoJWQpAFRhYiBCYXJzICglZCkAUG9wdXBzICglZCkAR2x5cGhzICglZCkAVGFibGVzICglZCkARGVhciBJbUd1aSAlcyAoJWQpAFNldHRpbmdzIGhhbmRsZXJzOiAoJWQpAENvbHVtbnNDb3VudDogJWQgKG1heCAlZCkARmlsdGVyIChpbmMsLWV4YykAIChBc2MpAEltSXNQb3dlck9mVHdvKGZsYWdzICYgSW1HdWlDb21ib0ZsYWdzX0hlaWdodE1hc2tfKQBJbUlzUG93ZXJPZlR3byhmbGFncyAmIEltR3VpVGFibGVDb2x1bW5GbGFnc19XaWR0aE1hc2tfKQAnJWMnICgweCUwNFgpAEVsbGlwc2lzIGNoYXJhY3RlcjogJyVjJyAoVSslMDRYKQBGYWxsYmFjayBjaGFyYWN0ZXI6ICclYycgKFUrJTA0WCkAJWQgKDB4JVgpAEFwcGxpY2F0aW9uIGF2ZXJhZ2UgJS4zZiBtcy9mcmFtZSAoJS4xZiBGUFMpAFNldE5leHRJdGVtV2lkdGgvUHVzaEl0ZW1XaWR0aCgtRkxUX01JTikAKD8pAChJbiBmcm9udC10by1iYWNrIG9yZGVyOikAY2hhbm5lbF9ubyA8ICg0ICsgNjQgKiAyKQBEcmFnRmxvYXQgKC1pbmYgLT4gMSkAU2xpZGVyRmxvYXQgKDAgLT4gMSkARHJhZ0Zsb2F0ICgwIC0+IDEpAFNldE5leHRJdGVtV2lkdGgvUHVzaEl0ZW1XaWR0aCgtMTAwKQBTZXROZXh0SXRlbVdpZHRoL1B1c2hJdGVtV2lkdGgoMTAwKQBDdXN0b206IEZpeGVkIFN0ZXBzICgxMDApAFNsaWRlckludCAoMCAtPiAxMDApAERyYWdJbnQgKDAgLT4gMTAwKQAoZGF0YSAhPSAwTCAmJiBkYXRhX3NpemUgPiAwKSB8fCAoZGF0YSA9PSAwTCAmJiBkYXRhX3NpemUgPT0gMCkAKFlvdSBjYW4gYWxzbyByaWdodC1jbGljayBtZSB0byBvcGVuIHRoZSBzYW1lIHBvcHVwIGFzIGFib3ZlLikATm90ZSB0aGFuIHRoZSBkZWZhdWx0IGVtYmVkZGVkIGZvbnQgaXMgTk9UIG1lYW50IHRvIGJlIHNjYWxlZC4KCkZvbnQgYXJlIGN1cnJlbnRseSByZW5kZXJlZCBpbnRvIGJpdG1hcHMgYXQgYSBnaXZlbiBzaXplIGF0IHRoZSB0aW1lIG9mIGJ1aWxkaW5nIHRoZSBhdGxhcy4gWW91IG1heSBvdmVyc2FtcGxlIHRoZW0gdG8gZ2V0IHNvbWUgZmxleGliaWxpdHkgd2l0aCBzY2FsaW5nLiBZb3UgY2FuIGFsc28gcmVuZGVyIGF0IG11bHRpcGxlIHNpemVzIGFuZCBzZWxlY3Qgd2hpY2ggb25lIHRvIHVzZSBhdCBydW50aW1lLgoKKEdsaW1tZXIgb2YgaG9wZTogdGhlIGF0bGFzIHN5c3RlbSB3aWxsIGJlIHJld3JpdHRlbiBpbiB0aGUgZnV0dXJlIHRvIG1ha2Ugc2NhbGluZyBtb3JlIGZsZXhpYmxlLikAUXVlcnlpbmcgU3RhdHVzIChFZGl0ZWQvQWN0aXZlL0ZvY3VzZWQvSG92ZXJlZCBldGMuKQBGbGFnczogMHglMDhYICglcyVzJXMlcyVzJXMlcyVzJXMuLikAISgoZmxhZ3MgJiBJbUd1aUlucHV0VGV4dEZsYWdzX0NhbGxiYWNrQ29tcGxldGlvbikgJiYgKGZsYWdzICYgSW1HdWlJbnB1dFRleHRGbGFnc19BbGxvd1RhYklucHV0KSkAY2hhbm5lbC0+X0NtZEJ1ZmZlci5TaXplID09IDEgJiYgbWVyZ2VfY2xpcF9yZWN0LkNvbnRhaW5zKEltUmVjdChjaGFubmVsLT5fQ21kQnVmZmVyWzBdLkNsaXBSZWN0KSkASW1Jc1Bvd2VyT2ZUd28oZmxhZ3MgJiAoSW1HdWlTZXBhcmF0b3JGbGFnc19Ib3Jpem9udGFsIHwgSW1HdWlTZXBhcmF0b3JGbGFnc19WZXJ0aWNhbCkpACEoKGZsYWdzICYgSW1HdWlJbnB1dFRleHRGbGFnc19DYWxsYmFja0hpc3RvcnkpICYmIChmbGFncyAmIEltR3VpSW5wdXRUZXh0RmxhZ3NfTXVsdGlsaW5lKSkAY291bnQgPT0gKChpbnQpKHNpemVvZihQb3MpIC8gc2l6ZW9mKCooUG9zKSkpKQB1c2VyX2tleV9pbmRleCA+PSAwICYmIHVzZXJfa2V5X2luZGV4IDwgKChpbnQpKHNpemVvZihnLklPLktleXNEb3duKSAvIHNpemVvZigqKGcuSU8uS2V5c0Rvd24pKSkpAGtleV9pbmRleCA+PSAwICYmIGtleV9pbmRleCA8ICgoaW50KShzaXplb2YoZy5JTy5LZXlzRG93bikgLyBzaXplb2YoKihnLklPLktleXNEb3duKSkpKQBidXR0b24gPj0gMCAmJiBidXR0b24gPCAoKGludCkoc2l6ZW9mKGcuSU8uTW91c2VEb3duKSAvIHNpemVvZigqKGcuSU8uTW91c2VEb3duKSkpKQBnLlNldHRpbmdzV2luZG93cy5lbXB0eSgpAGcuTG9nQnVmZmVyLmVtcHR5KCkAcGFzc3dvcmRfZm9udC0+R2x5cGhzLmVtcHR5KCkgJiYgcGFzc3dvcmRfZm9udC0+SW5kZXhBZHZhbmNlWC5lbXB0eSgpICYmIHBhc3N3b3JkX2ZvbnQtPkluZGV4TG9va3VwLmVtcHR5KCkAU2hvdyBUcmFpbGluZyBUYWJJdGVtQnV0dG9uKCkAU2hvdyBMZWFkaW5nIFRhYkl0ZW1CdXR0b24oKQBTbWFsbEJ1dHRvbigpAGl0ZW1fZmxhZ3MgPT0gZy5JdGVtRmxhZ3NTdGFjay5iYWNrKCkAcCA+PSBiZWdpbigpICYmIHAgPCBlbmQoKQAhZy5OYXZTY29yaW5nUmVjdC5Jc0ludmVydGVkKCkAZm9udCAmJiBmb250LT5Jc0xvYWRlZCgpAFRhYmxlIDB4JTA4WCAoJWQgY29sdW1ucywgaW4gJyVzJykARmlsdGVyICgiaW5jbCwtZXhjbCIpICgiZXJyb3IiKQAoICkATmF2V2luZG93OiAnJXMnAEhvdmVyZWRSb290V2luZG93OiAnJXMnAEhvdmVyZWRXaW5kb3dVbmRlck1vdmluZ1dpbmRvdzogJyVzJwBIb3ZlcmVkV2luZG93OiAnJXMnAEFjdGl2ZUlkV2luZG93OiAnJXMnAE5hdldpbmRvd2luZ1RhcmdldDogJyVzJwBPdXRlclJlY3Q6IFBvczogKCUuMWYsJS4xZikgU2l6ZTogKCUuMWYsJS4xZikgU2l6aW5nOiAnJXMnAG5hbWUgIT0gMEwgJiYgbmFtZVswXSAhPSAnXDAnAG9wID09ICcrJyB8fCBvcCA9PSAnLScANzUlADI1JQAlLjBmJSUAJWQlJQBNYXg6ICUuMWYgJSUATWluOiAlLjFmICUlACMjIwBMaW5lICMARmlsdGVyIHVzYWdlOgogICIiICAgICAgICAgZGlzcGxheSBhbGwgbGluZXMKICAieHh4IiAgICAgIGRpc3BsYXkgbGluZXMgY29udGFpbmluZyAieHh4IgogICJ4eHgseXl5IiAgZGlzcGxheSBsaW5lcyBjb250YWluaW5nICJ4eHgiIG9yICJ5eXkiCiAgIi14eHgiICAgICBoaWRlIGxpbmVzIGNvbnRhaW5pbmcgInh4eCIAKGtleV9tb2RfZmxhZ3MgPT0gMCB8fCBnLklPLktleU1vZHMgPT0ga2V5X21vZF9mbGFncykgJiYgIk1pc21hdGNoaW5nIGlvLktleUN0cmwvaW8uS2V5U2hpZnQvaW8uS2V5QWx0L2lvLktleVN1cGVyIHZzIGlvLktleU1vZHMiAGlvLktleU1vZHMgPT0gR2V0TWVyZ2VkS2V5TW9kRmxhZ3MoKSAmJiAiTWlzbWF0Y2hpbmcgaW8uS2V5Q3RybC9pby5LZXlTaGlmdC9pby5LZXlBbHQvaW8uS2V5U3VwZXIgdnMgaW8uS2V5TW9kcyIARG9jdW1lbnQgIiVzIgBzdHJsZW4odHlwZSkgPCAoKGludCkoc2l6ZW9mKHBheWxvYWQuRGF0YVR5cGUpIC8gc2l6ZW9mKCoocGF5bG9hZC5EYXRhVHlwZSkpKSkgJiYgIlBheWxvYWQgdHlwZSBjYW4gYmUgYXQgbW9zdCAzMiBjaGFyYWN0ZXJzIGxvbmciAGRyYXdfbGlzdC0+X1Z0eEN1cnJlbnRJZHggPCAoMSA8PCAxNikgJiYgIlRvbyBtYW55IHZlcnRpY2VzIGluIEltRHJhd0xpc3QgdXNpbmcgMTYtYml0IGluZGljZXMuIFJlYWQgY29tbWVudCBhYm92ZSIAdGFibGUtPkNvbHVtbnNDb3VudCA9PSBjb2x1bW5zX2NvdW50ICYmICJCZWdpblRhYmxlKCk6IENhbm5vdCBjaGFuZ2UgY29sdW1ucyBjb3VudCBtaWQtZnJhbWUgd2hpbGUgcHJlc2VydmluZyBzYW1lIElEIgAoZy5DdXJyZW50V2luZG93U3RhY2suU2l6ZSA9PSAxKSAmJiAiTWlzbWF0Y2hlZCBCZWdpbi9CZWdpbkNoaWxkIHZzIEVuZC9FbmRDaGlsZCBjYWxsczogZGlkIHlvdSBjYWxsIEVuZC9FbmRDaGlsZCB0b28gbXVjaD8iAEl0ZW1zQ291bnQgPT0gLTEgJiYgIkZvcmdvdCB0byBjYWxsIEVuZCgpLCBvciB0byBTdGVwKCkgdW50aWwgZmFsc2U/IgAoZy5GcmFtZUNvdW50ID09IDAgfHwgZy5GcmFtZUNvdW50RW5kZWQgPT0gZy5GcmFtZUNvdW50KSAmJiAiRm9yZ290IHRvIGNhbGwgUmVuZGVyKCkgb3IgRW5kRnJhbWUoKSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBmcmFtZT8iAChnLkN1cnJlbnRXaW5kb3dTdGFjay5TaXplID09IDEpICYmICJNaXNtYXRjaGVkIEJlZ2luL0JlZ2luQ2hpbGQgdnMgRW5kL0VuZENoaWxkIGNhbGxzOiBkaWQgeW91IGZvcmdldCB0byBjYWxsIEVuZC9FbmRDaGlsZD8iACh3aW5kb3ctPkZsYWdzICYgSW1HdWlXaW5kb3dGbGFnc19DaGlsZFdpbmRvdykgJiYgIk1pc21hdGNoZWQgTGlzdEJveEhlYWRlci9MaXN0Qm94Rm9vdGVyIGNhbGxzLiBEaWQgeW91IHRlc3QgdGhlIHJldHVybiB2YWx1ZSBvZiBMaXN0Qm94SGVhZGVyKCk/IgBnLldpdGhpbkZyYW1lU2NvcGUgJiYgIkZvcmdvdCB0byBjYWxsIEltR3VpOjpOZXdGcmFtZSgpPyIAZy5EcmFnRHJvcFdpdGhpblNvdXJjZSAmJiAiTm90IGFmdGVyIGEgQmVnaW5EcmFnRHJvcFNvdXJjZSgpPyIAZy5JTy5Gb250cy0+Rm9udHMuU2l6ZSA+IDAgJiYgIkZvbnQgQXRsYXMgbm90IGJ1aWx0LiBEaWQgeW91IGNhbGwgaW8uRm9udHMtPkdldFRleERhdGFBc1JHQkEzMigpIC8gR2V0VGV4RGF0YUFzQWxwaGE4KCk/IgBHSW1HdWkgIT0gMEwgJiYgIk5vIGN1cnJlbnQgY29udGV4dC4gRGlkIHlvdSBjYWxsIEltR3VpOjpDcmVhdGVDb250ZXh0KCkgYW5kIEltR3VpOjpTZXRDdXJyZW50Q29udGV4dCgpID8iAF9DdXJyZW50ID09IDAgJiYgX0NvdW50IDw9IDEgJiYgIk5lc3RlZCBjaGFubmVsIHNwbGl0dGluZyBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIHNlcGFyYXRlIGluc3RhbmNlcyBvZiBJbURyYXdMaXN0U3BsaXR0ZXIuIgBnLklPLktleU1hcFtJbUd1aUtleV9TcGFjZV0gIT0gLTEgJiYgIkltR3VpS2V5X1NwYWNlIGlzIG5vdCBtYXBwZWQsIHJlcXVpcmVkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uLiIAaW5pdF93aWR0aF9vcl93ZWlnaHQgPD0gMC4wZiAmJiAiQ2FuIG9ubHkgc3BlY2lmeSB3aWR0aC93ZWlnaHQgaWYgc2l6aW5nIHBvbGljeSBpcyBzZXQgZXhwbGljaXRlbHkgaW4gZWl0aGVyIFRhYmxlIG9yIENvbHVtbi4iADAgJiYgIkNhbm5vdCB1c2UgSXNQb3B1cE9wZW4oKSB3aXRoIGEgc3RyaW5nIGlkIGFuZCBJbUd1aVBvcHVwRmxhZ3NfQW55UG9wdXBMZXZlbC4iAGcuU3R5bGUuV2luZG93TWluU2l6ZS54ID49IDEuMGYgJiYgZy5TdHlsZS5XaW5kb3dNaW5TaXplLnkgPj0gMS4wZiAmJiAiSW52YWxpZCBzdHlsZSBzZXR0aW5nLiIAKGZsYWdzID09IDEgfHwgKGZsYWdzICYgSW1HdWlTbGlkZXJGbGFnc19JbnZhbGlkTWFza18pID09IDApICYmICJJbnZhbGlkIEltR3VpU2xpZGVyRmxhZ3MgZmxhZ3MhIEhhcyB0aGUgJ2Zsb2F0IHBvd2VyJyBhcmd1bWVudCBiZWVuIG1pc3Rha2VubHkgY2FzdCB0byBmbGFncz8gQ2FsbCBmdW5jdGlvbiB3aXRoIEltR3VpU2xpZGVyRmxhZ3NfTG9nYXJpdGhtaWMgZmxhZ3MgaW5zdGVhZC4iAChmbGFncyA9PSAxIHx8IChmbGFncyAmIEltR3VpU2xpZGVyRmxhZ3NfSW52YWxpZE1hc2tfKSA9PSAwKSAmJiAiSW52YWxpZCBJbUd1aVNsaWRlckZsYWdzIGZsYWchICBIYXMgdGhlICdmbG9hdCBwb3dlcicgYXJndW1lbnQgYmVlbiBtaXN0YWtlbmx5IGNhc3QgdG8gZmxhZ3M/IENhbGwgZnVuY3Rpb24gd2l0aCBJbUd1aVNsaWRlckZsYWdzX0xvZ2FyaXRobWljIGZsYWdzIGluc3RlYWQuIgBnLklPLktleU1hcFtuXSA+PSAtMSAmJiBnLklPLktleU1hcFtuXSA8ICgoaW50KShzaXplb2YoZy5JTy5LZXlzRG93bikgLyBzaXplb2YoKihnLklPLktleXNEb3duKSkpKSAmJiAiaW8uS2V5TWFwW10gY29udGFpbnMgYW4gb3V0IG9mIGJvdW5kIHZhbHVlIChuZWVkIHRvIGJlIDAuLjUxMiwgb3IgLTEgZm9yIHVubWFwcGVkIGtleSkiAChmbGFncyAmIEltR3VpVGFibGVDb2x1bW5GbGFnc19TdGF0dXNNYXNrXykgPT0gMCAmJiAiSWxsZWdhbCB0byBwYXNzIFN0YXR1c01hc2sgdmFsdWVzIHRvIFRhYmxlU2V0dXBDb2x1bW4oKSIASXRlbXNIZWlnaHQgPiAwLjBmICYmICJVbmFibGUgdG8gY2FsY3VsYXRlIGl0ZW0gaGVpZ2h0ISBGaXJzdCBpdGVtIGhhc24ndCBtb3ZlZCB0aGUgY3Vyc29yIHZlcnRpY2FsbHkhIgB0YWJsZS0+SXNMYXlvdXRMb2NrZWQgPT0gZmFsc2UgJiYgIk5lZWQgdG8gY2FsbCBUYWJsZVNldHVwQ29sdW1uKCkgYmVmb3JlIGZpcnN0IHJvdyEiAHRhYmxlLT5Jc0xheW91dExvY2tlZCA9PSBmYWxzZSAmJiAiTmVlZCB0byBjYWxsIGNhbGwgVGFibGVTZXR1cENvbHVtbigpIGJlZm9yZSBmaXJzdCByb3chIgBzel9pZHggPT0gc2l6ZW9mKEltRHJhd0lkeCkgJiYgIk1pc21hdGNoZWQgc3RydWN0IGxheW91dCEiAHN6X3ZlcnQgPT0gc2l6ZW9mKEltRHJhd1ZlcnQpICYmICJNaXNtYXRjaGVkIHN0cnVjdCBsYXlvdXQhIgBzel9zdHlsZSA9PSBzaXplb2YoSW1HdWlTdHlsZSkgJiYgIk1pc21hdGNoZWQgc3RydWN0IGxheW91dCEiAHN6X2lvID09IHNpemVvZihJbUd1aUlPKSAmJiAiTWlzbWF0Y2hlZCBzdHJ1Y3QgbGF5b3V0ISIAc3pfdmVjNCA9PSBzaXplb2YoSW1WZWM0KSAmJiAiTWlzbWF0Y2hlZCBzdHJ1Y3QgbGF5b3V0ISIAc3pfdmVjMiA9PSBzaXplb2YoSW1WZWMyKSAmJiAiTWlzbWF0Y2hlZCBzdHJ1Y3QgbGF5b3V0ISIAMCAmJiAiQ2FsbGVkIFB1c2hTdHlsZVZhcigpIGZsb2F0IHZhcmlhbnQgYnV0IHZhcmlhYmxlIGlzIG5vdCBhIGZsb2F0ISIAKHRhYmxlLT5EZWNsQ29sdW1uc0NvdW50IDwgdGFibGUtPkNvbHVtbnNDb3VudCkgJiYgIkNhbGxlZCBUYWJsZVNldHVwQ29sdW1uKCkgdG9vIG1hbnkgdGltZXMhIgAoZy5DdXJyZW50V2luZG93U3RhY2suU2l6ZSA+IDEpICYmICJDYWxsaW5nIEVuZCgpIHRvbyBtYW55IHRpbWVzISIASW1HdWk6OkdldEN1cnJlbnRDb250ZXh0KCkgIT0gMEwgJiYgIk1pc3NpbmcgZGVhciBpbWd1aSBjb250ZXh0LiBSZWZlciB0byBleGFtcGxlcyBhcHAhIgAoZy5Hcm91cFN0YWNrLlNpemUgPT0gMCkgJiYgIk1pc3NpbmcgRW5kR3JvdXAgY2FsbCEiAChvdXRlcl93aW5kb3ctPkRDLkl0ZW1XaWR0aFN0YWNrLlNpemUgPj0gdGFibGUtPkhvc3RCYWNrdXBJdGVtV2lkdGhTdGFja1NpemUpICYmICJUb28gbWFueSBQb3BJdGVtV2lkdGghIgBTaXplT2ZCZWdpblBvcHVwU3RhY2sgPT0gZy5CZWdpblBvcHVwU3RhY2suU2l6ZSAmJiAiQmVnaW5Qb3B1cC9FbmRQb3B1cCBvciBCZWdpbk1lbnUvRW5kTWVudSBNaXNtYXRjaCEiAFNpemVPZkZvbnRTdGFjayA+PSBnLkZvbnRTdGFjay5TaXplICYmICJQdXNoRm9udC9Qb3BGb250IE1pc21hdGNoISIAU2l6ZU9mQ29sb3JTdGFjayA+PSBnLkNvbG9yU3RhY2suU2l6ZSAmJiAiUHVzaFN0eWxlQ29sb3IvUG9wU3R5bGVDb2xvciBNaXNtYXRjaCEiAFNpemVPZlN0eWxlVmFyU3RhY2sgPj0gZy5TdHlsZVZhclN0YWNrLlNpemUgJiYgIlB1c2hTdHlsZVZhci9Qb3BTdHlsZVZhciBNaXNtYXRjaCEiAFNpemVPZkdyb3VwU3RhY2sgPT0gZy5Hcm91cFN0YWNrLlNpemUgJiYgIkJlZ2luR3JvdXAvRW5kR3JvdXAgTWlzbWF0Y2ghIgBTaXplT2ZJRFN0YWNrID09IHdpbmRvdy0+SURTdGFjay5TaXplICYmICJQdXNoSUQvUG9wSUQgb3IgVHJlZU5vZGUvVHJlZVBvcCBNaXNtYXRjaCEiAFNpemVPZkZvY3VzU2NvcGVTdGFjayA9PSBnLkZvY3VzU2NvcGVTdGFjay5TaXplICYmICJQdXNoRm9jdXNTY29wZS9Qb3BGb2N1c1Njb3BlIE1pc21hdGNoISIAZy5TdHlsZS5BbHBoYSA+PSAwLjBmICYmIGcuU3R5bGUuQWxwaGEgPD0gMS4wZiAmJiAiSW52YWxpZCBzdHlsZSBzZXR0aW5nISIAZy5TdHlsZS5DaXJjbGVTZWdtZW50TWF4RXJyb3IgPiAwLjBmICYmICJJbnZhbGlkIHN0eWxlIHNldHRpbmchIgBnLlN0eWxlLkN1cnZlVGVzc2VsbGF0aW9uVG9sID4gMC4wZiAmJiAiSW52YWxpZCBzdHlsZSBzZXR0aW5nISIAc3RyY21wKHZlcnNpb24sICIxLjgwIikgPT0gMCAmJiAiTWlzbWF0Y2hlZCB2ZXJzaW9uIHN0cmluZyEiAHRhYmxlICE9IDBMICYmICJPbmx5IGNhbGwgRW5kVGFibGUoKSBpZiBCZWdpblRhYmxlKCkgcmV0dXJucyB0cnVlISIAZy5JTy5EaXNwbGF5U2l6ZS54ID49IDAuMGYgJiYgZy5JTy5EaXNwbGF5U2l6ZS55ID49IDAuMGYgJiYgIkludmFsaWQgRGlzcGxheVNpemUgdmFsdWUhIgAoZy5JTy5EZWx0YVRpbWUgPiAwLjBmIHx8IGcuRnJhbWVDb3VudCA9PSAwKSAmJiAiTmVlZCBhIHBvc2l0aXZlIERlbHRhVGltZSEiAGNvbHVtbnNfY291bnQgPiAwICYmIGNvbHVtbnNfY291bnQgPD0gNjQgJiYgIk9ubHkgMS4uNjQgY29sdW1ucyBhbGxvd2VkISIAKGlubmVyX3dpbmRvdy0+SURTdGFjay5iYWNrKCkgPT0gdGFibGUtPklEICsgdGFibGUtPkluc3RhbmNlQ3VycmVudCkgJiYgIk1pc21hdGNoaW5nIFB1c2hJRC9Qb3BJRCEiADAgJiYgIkNhbGxlZCBQdXNoU3R5bGVWYXIoKSBJbVZlYzIgdmFyaWFudCBidXQgdmFyaWFibGUgaXMgbm90IGEgSW1WZWMyISIAKHRhYl9iYXIgIT0gMEwpICYmICJNaXNtYXRjaGVkIEJlZ2luVGFiQmFyKCkvRW5kVGFiQmFyKCkhIgAodGFiX2JhcikgJiYgIk5lZWRzIHRvIGJlIGNhbGxlZCBiZXR3ZWVuIEJlZ2luVGFiQmFyKCkgYW5kIEVuZFRhYkJhcigpISIAKHRhYl9iYXIgIT0gMEwpICYmICJOZWVkcyB0byBiZSBjYWxsZWQgYmV0d2VlbiBCZWdpblRhYkJhcigpIGFuZCBFbmRUYWJCYXIoKSEiAHRhYmxlICE9IDBMICYmICJOZWVkIHRvIGNhbGwgVGFibGVIZWFkZXJzUm93KCkgYWZ0ZXIgQmVnaW5UYWJsZSgpISIAdGFibGUgIT0gMEwgJiYgIk5lZWQgdG8gY2FsbCBUYWJsZUhlYWRlcigpIGFmdGVyIEJlZ2luVGFibGUoKSEiAHRhYmxlICE9IDBMICYmICJOZWVkIHRvIGNhbGwgVGFibGVTZXR1cENvbHVtbigpIGFmdGVyIEJlZ2luVGFibGUoKSEiAChnLldpdGhpbkVuZENoaWxkKSAmJiAiTXVzdCBjYWxsIEVuZENoaWxkKCkgYW5kIG5vdCBFbmQoKSEiAEJlbG93IHdlIGFyZSBkaXNwbGF5aW5nIHRoZSBmb250IHRleHR1cmUgKHdoaWNoIGlzIHRoZSBvbmx5IHRleHR1cmUgd2UgaGF2ZSBhY2Nlc3MgdG8gaW4gdGhpcyBkZW1vKS4gVXNlIHRoZSAnSW1UZXh0dXJlSUQnIHR5cGUgYXMgc3RvcmFnZSB0byBwYXNzIHBvaW50ZXJzIG9yIGlkZW50aWZpZXIgdG8geW91ciBvd24gdGV4dHVyZSBkYXRhLiBIb3ZlciB0aGUgdGV4dHVyZSBmb3IgYSB6b29tZWQgdmlldyEAQ2xpY2sgdG8gYnJlYWsgaW4gZGVidWdnZXIhAFByZXNzZWQgVXAhAEhlbGxvIQBQcmVzc2VkIERvd24hAEJlbG93IHdlIGFyZSB0ZXN0aW5nIGFkZGluZyBtZW51IGl0ZW1zIHRvIGEgcmVndWxhciB3aW5kb3cuIEl0J3MgcmF0aGVyIHVudXN1YWwgYnV0IHNob3VsZCB3b3JrIQBXZWxjb21lIHRvIERlYXIgSW1HdWkhAFNlZSB0aGUgU2hvd0RlbW9XaW5kb3coKSBjb2RlIGluIGltZ3VpX2RlbW8uY3BwLiA8LSB5b3UgYXJlIGhlcmUhAGRpc3BsYXkgdmVyeSBpbXBvcnRhbnQgbWVzc2FnZSBoZXJlIQBMaW5lIDEgaGVsbG8KTGluZSAyIGNsaXAgbWUhAFRoYW5rcyBmb3IgY2xpY2tpbmcgbWUhAEhlbGxvIGZyb20gU3RhY2tlZCBUaGUgU2Vjb25kIQBIZWxsbywgd29ybGQhAFdhcm5pbmc6IG93bmluZyBXaW5kb3cgaXMgaW5hY3RpdmUuIFRoaXMgRHJhd0xpc3QgaXMgbm90IGJlaW5nIHJlbmRlcmVkIQBUaGlzIGlzIHRoZSAlcyB0YWIhAENvbHVtbnMoKSBpcyBhbiBvbGQgQVBJISBQcmVmZXIgdXNpbmcgdGhlIG1vcmUgZmxleGlibGUgYW5kIHBvd2VyZnVsIEJlZ2luVGFibGUoKSBBUEkhAE1ZIENVU1RPTSBDT0xPUiBQSUNLRVIgV0lUSCBBTiBBTUFaSU5HIFBBTEVUVEUhAENoaWxkTWVudSAATm9TYXZlZFNldHRpbmdzIABQb3B1cCAAVG9vbHRpcCAATW9kYWwgAFdpZHRoIABXaWR0aFN0cmV0Y2ggAE5vUmVzaXplIABDaGlsZCAAV2lkdGhGaXhlZCAAQUxUIABTSElGVCAAU1VQRVIgAENUUkwgAExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiAAIyAAICAgICAAVE9ETzogRm9udERhdGEgJXp1ICV6dQoAJTNkOiAlcwoAVE9ETzogJXMKAC0gJXMKACMgJXMKACVpIFRoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cKAFJlZlNjYWxlPSVnCgBDb2xsYXBzZWQ9JWQKAFBvcz0lZCwlZAoAU2l6ZT0lZCwlZAoASXNXaW5kb3dGb2N1c2VkKCkgPSAlZApJc1dpbmRvd0ZvY3VzZWQoX0NoaWxkV2luZG93cykgPSAlZApJc1dpbmRvd0ZvY3VzZWQoX0NoaWxkV2luZG93c3xfUm9vdFdpbmRvdykgPSAlZApJc1dpbmRvd0ZvY3VzZWQoX1Jvb3RXaW5kb3cpID0gJWQKSXNXaW5kb3dGb2N1c2VkKF9BbnlXaW5kb3cpID0gJWQKAElzV2luZG93SG92ZXJlZCgpID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9BbGxvd1doZW5CbG9ja2VkQnlQb3B1cCkgPSAlZApJc1dpbmRvd0hvdmVyZWQoX0FsbG93V2hlbkJsb2NrZWRCeUFjdGl2ZUl0ZW0pID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9DaGlsZFdpbmRvd3MpID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9DaGlsZFdpbmRvd3N8X1Jvb3RXaW5kb3cpID0gJWQKSXNXaW5kb3dIb3ZlcmVkKF9DaGlsZFdpbmRvd3N8X0FsbG93V2hlbkJsb2NrZWRCeVBvcHVwKSA9ICVkCklzV2luZG93SG92ZXJlZChfUm9vdFdpbmRvdykgPSAlZApJc1dpbmRvd0hvdmVyZWQoX0FueVdpbmRvdykgPSAlZAoACmBgYAoAWyVzXVslc10KAFslc11bMHglMDhYLCVkXQoAJXMgJTA0ZDogcG9zICglOC4yZiwlOC4yZiksIHV2ICglLjZmLCUuNmYpLCBjb2wgJTA4WAoASW1WZWM0KiBjb2xvcnMgPSBJbUd1aTo6R2V0U3R5bGUoKS5Db2xvcnM7CgBjb2xvcnNbSW1HdWlDb2xfJXNdJSpzPSBJbVZlYzQoJS4yZmYsICUuMmZmLCAlLjJmZiwgJS4yZmYpOwoAV2hpbGUgaW5wdXRpbmcgdGV4dDoKAFBvc3NpYmxlIG1hdGNoZXM6CgBSZWZlciB0byB0aGUgIkNvbWJvIiBzZWN0aW9uIGJlbG93IGZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGUgZnVsbCBCZWdpbkNvbWJvL0VuZENvbWJvIEFQSSwgYW5kIGRlbW9uc3RyYXRpb24gb2YgdmFyaW91cyBmbGFncy4KAERpc3BsYXkgYWxsIGNoYXJhY3RlcnMgYXMgJyonLgpEaXNhYmxlIGNsaXBib2FyZCBjdXQgYW5kIGNvcHkuCkRpc2FibGUg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WC5YWFgtICBYLi4uWCAgLSAgICAgICAgIFguLi5YICAgICAgICAgLVguLi4uWCAgICAgICAgICAgLSAgICAgICAgICAgWC4uLi5YLSAgICBYLi5YICAgICAgICAgWCAgICAgICAgICAgLSAgWC5YICAtIFguLi4uLlggLSAgICAgICAgWC4uLi4uWCAgICAgICAgLVguLi5YICAgICAgICAgICAgLSAgICAgICAgICAgIFguLi5YLSAgICBYLi5YICAgICAgICAgWFggICAgICAgICAgLSAgWC5YICAtWC4uLi4uLi5YLSAgICAgICBYLi4uLi4uLlggICAgICAgLVguLlguWCAgICAgICAgICAgLSAgICAgICAgICAgWC5YLi5YLSAgICBYLi5YICAgICAgICAgWC5YICAgICAgICAgLSAgWC5YICAtWFhYWC5YWFhYLSAgICAgICBYWFhYLlhYWFggICAgICAgLVguWCBYLlggICAgICAgICAgLSAgICAgICAgICBYLlggWC5YLSAgICBYLi5YWFggICAgICAgWC4uWCAgICAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgICAgICAgICBYLlggICAgICAgICAgLVhYICAgWC5YICAgICAgICAgLSAgICAgICAgIFguWCAgIFhYLSAgICBYLi5YLi5YWFggICAgWC4uLlggICAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgICBYWCAgICBYLlggICAgWFggICAgLSAgICAgIFguWCAgICAgICAgLSAgICAgICAgWC5YICAgICAgLSAgICBYLi5YLi5YLi5YWCAgWC4uLi5YICAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgIFguWCAgICBYLlggICAgWC5YICAgLSAgICAgICBYLlggICAgICAgLSAgICAgICBYLlggICAgICAgLSAgICBYLi5YLi5YLi5YLlggWC4uLi4uWCAgICAgLSAgWC5YICAtICAgWC5YICAgLSAgWC4uWCAgICBYLlggICAgWC4uWCAgLSAgICAgICAgWC5YICAgICAgLSAgICAgIFguWCAgICAgICAgLVhYWCBYLi5YLi5YLi5YLi5YWC4uLi4uLlggICAgLSAgWC5YICAtICAgWC5YICAgLSBYLi4uWFhYWFhYLlhYWFhYWC4uLlggLSAgICAgICAgIFguWCAgIFhYLVhYICAgWC5YICAgICAgICAgLVguLlhYLi4uLi4uLi5YLi5YWC4uLi4uLi5YICAgLSAgWC5YICAtICAgWC5YICAgLVguLi4uLi4uLi4uLi4uLi4uLi4uLi5YLSAgICAgICAgICBYLlggWC5YLVguWCBYLlggICAgICAgICAgLVguLi5YLi4uLi4uLi4uLi5YWC4uLi4uLi4uWCAgLSAgWC5YICAtICAgWC5YICAgLSBYLi4uWFhYWFhYLlhYWFhYWC4uLlggLSAgICAgICAgICAgWC5YLi5YLVguLlguWCAgICAgICAgICAgLSBYLi4uLi4uLi4uLi4uLi5YWC4uLi4uLi4uLlggLVhYWC5YWFgtICAgWC5YICAgLSAgWC4uWCAgICBYLlggICAgWC4uWCAgLSAgICAgICAgICAgIFguLi5YLVguLi5YICAgICAgICAgICAgLSAgWC4uLi4uLi4uLi4uLi5YWC4uLi4uLi4uLi5YLVguLi4uLlgtICAgWC5YICAgLSAgIFguWCAgICBYLlggICAgWC5YICAgLSAgICAgICAgICAgWC4uLi5YLVguLi4uWCAgICAgICAgICAgLSAgWC4uLi4uLi4uLi4uLi5YWC4uLi4uLlhYWFhYLVhYWFhYWFgtICAgWC5YICAgLSAgICBYWCAgICBYLlggICAgWFggICAgLSAgICAgICAgICBYLi4uLi5YLVguLi4uLlggICAgICAgICAgLSAgIFguLi4uLi4uLi4uLi5YWC4uLlguLlggICAgLS0tLS0tLS0tICAgWC5YICAgLSAgICAgICAgICBYLlggICAgICAgICAgLSAgICAgICAgICBYWFhYWFhYLVhYWFhYWFggICAgICAgICAgLSAgIFguLi4uLi4uLi4uLlggWC4uWCBYLi5YICAgLSAgICAgICAtWFhYWC5YWFhYLSAgICAgICBYWFhYLlhYWFggICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBYLi4uLi4uLi4uLlggWC5YICBYLi5YICAgLSAgICAgICAtWC4uLi4uLi5YLSAgICAgICBYLi4uLi4uLlggICAgICAgLSAgICBYWCAgICAgICAgICAgWFggICAgLSAgICAgICAgICAgLSAgICBYLi4uLi4uLi4uLlggWFggICAgWC4uWCAgLSAgICAgICAtIFguLi4uLlggLSAgICAgICAgWC4uLi4uWCAgICAgICAgLSAgIFguWCAgICAgICAgICAgWC5YICAgLSAgICAgICAgICAgLSAgICAgWC4uLi4uLi4uWCAgICAgICAgWC4uWCAgICAgICAgICAtICBYLi4uWCAgLSAgICAgICAgIFguLi5YICAgICAgICAgLSAgWC4uWCAgICAgICAgICAgWC4uWCAgLSAgICAgICAgICAgLSAgICAgWC4uLi4uLi4uWCAgICAgICAgIFhYICAgICAgICAgICAtICAgWC5YICAgLSAgICAgICAgICBYLlggICAgICAgICAgLSBYLi4uWFhYWFhYWFhYWFhYWC4uLlggLSAgICAgICAgICAgLSAgICAgWFhYWFhYWFhYWCAgLS0tLS0tLS0tLS0tICAgICAgICAtICAgIFggICAgLSAgICAgICAgICAgWCAgICAgICAgICAgLVguLi4uLi4uLi4uLi4uLi4uLi4uLi5YLSAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBYLi4uWFhYWFhYWFhYWFhYWC4uLlggLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAgWC4uWCAgICAgICAgICAgWC4uWCAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAgIFguWCAgICAgICAgICAgWC5YICAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAgICBYWCAgICAgICAgICAgWFggICAgLSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAAAAAAAAAAAAAx4kBAMCIAQDihwEAp4cBAHOGAQA2hgEALYYBAAqGAQAYhQEA9oQBAO6EAQAAAAAAPl8BAJ9DAQBALwEAmy8BAM5kAQA+fAEAbQABACpDAQD+NgEATmgBAMRkAQB0AAEAAzoBAAAAAAAAAAAAAAAAAMeJAQDAiAEA4ocBAKeHAQBzhgEANoYBAC2GAQAKhgEAG4UBAPaEAQDxhAEAuYMBAJ2DAQDyggEAYWFhYQBiYmJiAGNjY2MAZGRkZABlZWVlAAAAAAAAAAAAAAAAAAAAADZoAQCgEAEA6wABAA46AQBTaW4AU2F3AABBdXRvL0N1cnJlbnQATm9uZQBSR0IgT25seQBIU1YgT25seQBIZXggT25seQAAQXV0by9DdXJyZW50AEh1ZSBiYXIgKyBTViByZWN0AEh1ZSB3aGVlbCArIFNWIHRyaWFuZ2xlAAAA2wwBAPw5AQCo7wEA5wMBAKMaAQA9DAEAhRoBAIuTAQAPkgEAzT4BAGZpAQDA9gEAsTcBAPYDAQAAAAAAAAAAAM5kAQA+fAEAbQABACpDAQDHiQEAwIgBAOKHAQCnhwEAAAAAP83MTD7NzEw/mpkZPwAAgD4AAAAAAAAAAAAAAAAaNQEAmAsCAHsvAQCUCwIAbD4BAAAAAAAAAAAAAAAAAI0XAQCYCwIAey8BAJQLAgAbFwEAAAAAAAAAAAAAAAAAHz8BAIZCAQAkQQEAfkIBADdFAQBTaG93IHdpZHRoAFNob3J0IFRleHQATG9uZyBUZXh0AEJ1dHRvbgBGaWxsIEJ1dHRvbgBJbnB1dFRleHQAAE5vbmUAUmVkAEdyYWRpZW50AABSb3dCZzAAUm93QmcxAABOb25lAEJsdWUAAACpEAEAJDEBAP////8BAAAAAwAAADd5AQAkMQEA/////wQAAAACAAAATCcBACQxAQD/////BgAAAAMAAABgQwEA/mQBAAAEAAD//////////2MKAQDzZAEAeOABAP//////////VwoBAPNkAQBA9QYA//////////8OSAEACmUBAHgZAwD//////////wZIAQAKZQEA+BkDAP//////////G0gBAAplAQD4GgMA//////////8AAAAAAAAAAAAAAAA+fAEAzmQBAG0AAQADOgEADRUBAHQAAQD+NgEAKkMBAE5oAQDEZAEAfwABAF4+AQDeDQEAzzEBAK4QAQAAAAAA2wwBAPw5AQBaOQEATzkBAMlmAQBa7QEAAAAAAAAAAAAAAAAA4xQBANjPAQAAIAAAZxUBAHTGAQAAQAAAzWMBALTUAQAAYAAA1TQBAH61AQAAgAAAq2MBAGiuAQDUYgEAljYBAPFoAQDrYAEAfTYBAMJoAQAAAAAAAAAAAAAAAADUeQEAzXkBAMZ5AQChNAEAmDQBAI80AQB6RwEA6WwBAMsFAQDzDAEAZEABALqCAQDQgAEAxYABAFeGAQCDbAEAXm4BAFllcwBObwBNYXliZQAAAAAINwEAtzgBAAUuAQCTcQEAhhsBAARpAQBFfAEAL10BAAo1AQDxEwEAU2luZ2xlIGNhbGwgdG8gVGV4dFVuZm9ybWF0dGVkKCkATXVsdGlwbGUgY2FsbHMgdG8gVGV4dCgpLCBjbGlwcGVkAE11bHRpcGxlIGNhbGxzIHRvIFRleHQoKSwgbm90IGNsaXBwZWQgKHNsb3cpAAAAAAAnAQEAEAEBAL2aAQBrmgEAXJoBAHVfAQCVAwIATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAGSqAgAMaQIATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAGSqAgBUaQIATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAABkqgIAnGkCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAZKoCAOhpAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAAGSqAgA0agIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAABkqgIAXGoCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXhFRQAAZKoCAIRqAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l5RUUAAGSqAgCsagIA2w9JP9sPSb/kyxZA5MsWwAAAAAAAAACA2w9JQNsPScAAAAAAAAAA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ABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAAZAAoAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkAEQoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAZAAoNGRkZAA0AAAIACQ4AAAAJAA4AAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAEwAAAAATAAAAAAkMAAAAAAAMAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAA8AAAAEDwAAAAAJEAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAARAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAABoaGgAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAABcAAAAAFwAAAAAJFAAAAAAAFAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAAAAAAAAAAAAAAVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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';
            if (!isDataURI(wasmBinaryFile)) {
                wasmBinaryFile = locateFile(wasmBinaryFile);
            }
            function getBinary(file) {
                try {
                    if (file == wasmBinaryFile && wasmBinary) {
                        return new Uint8Array(wasmBinary);
                    }
                    var binary = tryParseAsDataURI(file);
                    if (binary) {
                        return binary;
                    }
                    if (readBinary) ;
                    throw "both async and sync fetching of the wasm failed";
                } catch (err) {
                    abort(err);
                }
            }
            function getBinaryPromise(binaryFile) {
                // If we don't have the binary yet, try to load it asynchronously.
                // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
                // See https://github.com/github/fetch/pull/92#issuecomment-140665932
                // Cordova or Electron apps are typically loaded from a file:// url.
                // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
                if (!wasmBinary && ENVIRONMENT_IS_WEB) {
                    if (typeof fetch == 'function') {
                        return fetch(binaryFile, {
                            credentials: 'same-origin'
                        }).then((response)=>{
                            if (!response['ok']) {
                                throw "failed to load wasm binary file at '" + binaryFile + "'";
                            }
                            return response['arrayBuffer']();
                        }).catch(()=>getBinary(binaryFile));
                    }
                }
                // Otherwise, getBinary should be able to get it synchronously
                return Promise.resolve().then(()=>getBinary(binaryFile));
            }
            function instantiateArrayBuffer(binaryFile, imports, receiver) {
                return getBinaryPromise(binaryFile).then((binary)=>{
                    return WebAssembly.instantiate(binary, imports);
                }).then((instance)=>{
                    return instance;
                }).then(receiver, (reason)=>{
                    err('failed to asynchronously prepare wasm: ' + reason);
                    // Warn on some common problems.
                    if (isFileURI(wasmBinaryFile)) {
                        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');
                    }
                    abort(reason);
                });
            }
            function instantiateAsync(binary, binaryFile, imports, callback) {
                if (!binary && typeof WebAssembly.instantiateStreaming == 'function' && !isDataURI(binaryFile) && typeof fetch == 'function') {
                    return fetch(binaryFile, {
                        credentials: 'same-origin'
                    }).then((response)=>{
                        // Suppress closure warning here since the upstream definition for
                        // instantiateStreaming only allows Promise<Repsponse> rather than
                        // an actual Response.
                        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
                        /** @suppress {checkTypes} */ var result = WebAssembly.instantiateStreaming(response, imports);
                        return result.then(callback, function(reason) {
                            // We expect the most common failure cause to be a bad MIME type for the binary,
                            // in which case falling back to ArrayBuffer instantiation should work.
                            err('wasm streaming compile failed: ' + reason);
                            err('falling back to ArrayBuffer instantiation');
                            return instantiateArrayBuffer(binaryFile, imports, callback);
                        });
                    });
                } else {
                    return instantiateArrayBuffer(binaryFile, imports, callback);
                }
            }
            // Create the wasm instance.
            // Receives the wasm imports, returns the exports.
            function createWasm() {
                // prepare imports
                var info = {
                    'env': wasmImports,
                    'wasi_snapshot_preview1': wasmImports
                };
                // Load the wasm module and create an instance of using native support in the JS engine.
                // handle a generated wasm instance, receiving its exports and
                // performing other necessary setup
                /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {
                    var exports = instance.exports;
                    Module['asm'] = exports;
                    wasmMemory = Module['asm']['memory'];
                    assert(wasmMemory, "memory not found in wasm exports");
                    // This assertion doesn't hold when emscripten is run in --post-link
                    // mode.
                    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
                    //assert(wasmMemory.buffer.byteLength === 16777216);
                    updateMemoryViews();
                    wasmTable = Module['asm']['__indirect_function_table'];
                    assert(wasmTable, "table not found in wasm exports");
                    addOnInit(Module['asm']['__wasm_call_ctors']);
                    removeRunDependency('wasm-instantiate');
                    return exports;
                }
                // wait for the pthread pool (if any)
                addRunDependency('wasm-instantiate');
                // Prefer streaming instantiation if available.
                // Async compilation can be confusing when an error on the page overwrites Module
                // (for example, if the order of elements is wrong, and the one defining Module is
                // later), so we save Module and check it later.
                var trueModule = Module;
                function receiveInstantiationResult(result) {
                    // 'result' is a ResultObject object which has both the module and instance.
                    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
                    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
                    trueModule = null;
                    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
                    // When the regression is fixed, can restore the above PTHREADS-enabled path.
                    receiveInstance(result['instance']);
                }
                // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
                // to manually instantiate the Wasm module themselves. This allows pages to
                // run the instantiation parallel to any other async startup actions they are
                // performing.
                // Also pthreads and wasm workers initialize the wasm instance through this
                // path.
                if (Module['instantiateWasm']) {
                    try {
                        return Module['instantiateWasm'](info, receiveInstance);
                    } catch (e) {
                        err('Module.instantiateWasm callback failed with error: ' + e);
                        // If instantiation fails, reject the module ready promise.
                        readyPromiseReject(e);
                    }
                }
                // If instantiation fails, reject the module ready promise.
                instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
                return {}; // no exports yet; we'll fill them in later
            }
            // include: runtime_debug.js
            function legacyModuleProp(prop, newName) {
                if (!Object.getOwnPropertyDescriptor(Module, prop)) {
                    Object.defineProperty(Module, prop, {
                        configurable: true,
                        get: function() {
                            abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');
                        }
                    });
                }
            }
            function ignoredModuleProp(prop) {
                if (Object.getOwnPropertyDescriptor(Module, prop)) {
                    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');
                }
            }
            // forcing the filesystem exports a few things by default
            function isExportedByForceFilesystem(name) {
                return name === 'FS_createPath' || name === 'FS_createDataFile' || name === 'FS_createPreloadedFile' || name === 'FS_unlink' || name === 'addRunDependency' || // The old FS has some functionality that WasmFS lacks.
                name === 'FS_createLazyFile' || name === 'FS_createDevice' || name === 'removeRunDependency';
            }
            function missingGlobal(sym, msg) {
                if (typeof globalThis !== 'undefined') {
                    Object.defineProperty(globalThis, sym, {
                        configurable: true,
                        get: function() {
                            warnOnce('`' + sym + '` is not longer defined by emscripten. ' + msg);
                            return undefined;
                        }
                    });
                }
            }
            missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
            function missingLibrarySymbol(sym) {
                if (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
                    Object.defineProperty(globalThis, sym, {
                        configurable: true,
                        get: function() {
                            // Can't `abort()` here because it would break code that does runtime
                            // checks.  e.g. `if (typeof SDL === 'undefined')`.
                            var msg = '`' + sym + '` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line';
                            // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
                            // library.js, which means $name for a JS name with no prefix, or name
                            // for a JS name like _name.
                            var librarySymbol = sym;
                            if (!librarySymbol.startsWith('_')) {
                                librarySymbol = '$' + sym;
                            }
                            msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
                            if (isExportedByForceFilesystem(sym)) {
                                msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
                            }
                            warnOnce(msg);
                            return undefined;
                        }
                    });
                }
                // Any symbol that is not included from the JS libary is also (by definition)
                // not exported on the Module object.
                unexportedRuntimeSymbol(sym);
            }
            function unexportedRuntimeSymbol(sym) {
                if (!Object.getOwnPropertyDescriptor(Module, sym)) {
                    Object.defineProperty(Module, sym, {
                        configurable: true,
                        get: function() {
                            var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
                            if (isExportedByForceFilesystem(sym)) {
                                msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
                            }
                            abort(msg);
                        }
                    });
                }
            }
            function callRuntimeCallbacks(callbacks) {
                while(callbacks.length > 0){
                    // Pass the module as the first argument.
                    callbacks.shift()(Module);
                }
            }
            function ptrToString(ptr) {
                assert(typeof ptr === 'number');
                return '0x' + ptr.toString(16).padStart(8, '0');
            }
            function warnOnce(text) {
                if (!warnOnce.shown) warnOnce.shown = {};
                if (!warnOnce.shown[text]) {
                    warnOnce.shown[text] = 1;
                    err(text);
                }
            }
            var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;
            /**
	     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
	     * array that contains uint8 values, returns a copy of that string as a
	     * Javascript String object.
	     * heapOrArray is either a regular array, or a JavaScript typed array view.
	     * @param {number} idx
	     * @param {number=} maxBytesToRead
	     * @return {string}
	     */ function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
                var endIdx = idx + maxBytesToRead;
                var endPtr = idx;
                // TextDecoder needs to know the byte length in advance, it doesn't stop on
                // null terminator by itself.  Also, use the length info to avoid running tiny
                // strings through TextDecoder, since .subarray() allocates garbage.
                // (As a tiny code save trick, compare endPtr against endIdx using a negation,
                // so that undefined means Infinity)
                while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;
                if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
                    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
                }
                var str = '';
                // If building with TextDecoder, we have already computed the string length
                // above, so test loop end condition against that
                while(idx < endPtr){
                    // For UTF8 byte structure, see:
                    // http://en.wikipedia.org/wiki/UTF-8#Description
                    // https://www.ietf.org/rfc/rfc2279.txt
                    // https://tools.ietf.org/html/rfc3629
                    var u0 = heapOrArray[idx++];
                    if (!(u0 & 0x80)) {
                        str += String.fromCharCode(u0);
                        continue;
                    }
                    var u1 = heapOrArray[idx++] & 63;
                    if ((u0 & 0xE0) == 0xC0) {
                        str += String.fromCharCode((u0 & 31) << 6 | u1);
                        continue;
                    }
                    var u2 = heapOrArray[idx++] & 63;
                    if ((u0 & 0xF0) == 0xE0) {
                        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                    } else {
                        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
                        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
                    }
                    if (u0 < 0x10000) {
                        str += String.fromCharCode(u0);
                    } else {
                        var ch = u0 - 0x10000;
                        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
                    }
                }
                return str;
            }
            /**
	     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
	     * emscripten HEAP, returns a copy of that string as a Javascript String object.
	     *
	     * @param {number} ptr
	     * @param {number=} maxBytesToRead - An optional length that specifies the
	     *   maximum number of bytes to read. You can omit this parameter to scan the
	     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
	     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
	     *   string will cut short at that byte index (i.e. maxBytesToRead will not
	     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
	     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
	     *   JS JIT optimizations off, so it is worth to consider consistently using one
	     * @return {string}
	     */ function UTF8ToString(ptr, maxBytesToRead) {
                assert(typeof ptr == 'number');
                return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
            }
            function ___assert_fail(condition, filename, line, func) {
                abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [
                    filename ? UTF8ToString(filename) : 'unknown filename',
                    line,
                    func ? UTF8ToString(func) : 'unknown function'
                ]);
            }
            /** @constructor */ function ExceptionInfo(excPtr) {
                this.excPtr = excPtr;
                this.ptr = excPtr - 24;
                this.set_type = function(type) {
                    HEAPU32[this.ptr + 4 >> 2] = type;
                };
                this.get_type = function() {
                    return HEAPU32[this.ptr + 4 >> 2];
                };
                this.set_destructor = function(destructor) {
                    HEAPU32[this.ptr + 8 >> 2] = destructor;
                };
                this.get_destructor = function() {
                    return HEAPU32[this.ptr + 8 >> 2];
                };
                this.set_caught = function(caught) {
                    caught = caught ? 1 : 0;
                    HEAP8[this.ptr + 12 >> 0] = caught;
                };
                this.get_caught = function() {
                    return HEAP8[this.ptr + 12 >> 0] != 0;
                };
                this.set_rethrown = function(rethrown) {
                    rethrown = rethrown ? 1 : 0;
                    HEAP8[this.ptr + 13 >> 0] = rethrown;
                };
                this.get_rethrown = function() {
                    return HEAP8[this.ptr + 13 >> 0] != 0;
                };
                // Initialize native structure fields. Should be called once after allocated.
                this.init = function(type, destructor) {
                    this.set_adjusted_ptr(0);
                    this.set_type(type);
                    this.set_destructor(destructor);
                };
                this.set_adjusted_ptr = function(adjustedPtr) {
                    HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
                };
                this.get_adjusted_ptr = function() {
                    return HEAPU32[this.ptr + 16 >> 2];
                };
                // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted
                // when the pointer is casted to some of the exception object base classes (e.g. when virtual
                // inheritance is used). When a pointer is thrown this method should return the thrown pointer
                // itself.
                this.get_exception_ptr = function() {
                    // Work around a fastcomp bug, this code is still included for some reason in a build without
                    // exceptions support.
                    var isPointer = ___cxa_is_pointer_type(this.get_type());
                    if (isPointer) {
                        return HEAPU32[this.excPtr >> 2];
                    }
                    var adjusted = this.get_adjusted_ptr();
                    if (adjusted !== 0) return adjusted;
                    return this.excPtr;
                };
            }
            function ___cxa_throw(ptr, type, destructor) {
                var info = new ExceptionInfo(ptr);
                // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.
                info.init(type, destructor);
                assert(false, 'Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.');
            }
            function ___syscall_fcntl64(fd, cmd, varargs) {
                return 0;
            }
            function ___syscall_ioctl(fd, op, varargs) {
                return 0;
            }
            function ___syscall_openat(dirfd, path, flags, varargs) {
                abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');
            }
            function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}
            function getShiftFromSize(size) {
                switch(size){
                    case 1:
                        return 0;
                    case 2:
                        return 1;
                    case 4:
                        return 2;
                    case 8:
                        return 3;
                    default:
                        throw new TypeError(`Unknown type size: ${size}`);
                }
            }
            function embind_init_charCodes() {
                var codes = new Array(256);
                for(var i = 0; i < 256; ++i){
                    codes[i] = String.fromCharCode(i);
                }
                embind_charCodes = codes;
            }
            var embind_charCodes = undefined;
            function readLatin1String(ptr) {
                var ret = "";
                var c = ptr;
                while(HEAPU8[c]){
                    ret += embind_charCodes[HEAPU8[c++]];
                }
                return ret;
            }
            var awaitingDependencies = {};
            var registeredTypes = {};
            var typeDependencies = {};
            var char_0 = 48;
            var char_9 = 57;
            function makeLegalFunctionName(name) {
                if (undefined === name) {
                    return '_unknown';
                }
                name = name.replace(/[^a-zA-Z0-9_]/g, '$');
                var f = name.charCodeAt(0);
                if (f >= char_0 && f <= char_9) {
                    return `_${name}`;
                }
                return name;
            }
            function createNamedFunction(name, body) {
                name = makeLegalFunctionName(name);
                // Use an abject with a computed property name to create a new function with
                // a name specified at runtime, but without using `new Function` or `eval`.
                return ({
                    [name]: function() {
                        return body.apply(this, arguments);
                    }
                })[name];
            }
            function extendError(baseErrorType, errorName) {
                var errorClass = createNamedFunction(errorName, function(message) {
                    this.name = errorName;
                    this.message = message;
                    var stack = new Error(message).stack;
                    if (stack !== undefined) {
                        this.stack = this.toString() + '\n' + stack.replace(/^Error(:[^\n]*)?\n/, '');
                    }
                });
                errorClass.prototype = Object.create(baseErrorType.prototype);
                errorClass.prototype.constructor = errorClass;
                errorClass.prototype.toString = function() {
                    if (this.message === undefined) {
                        return this.name;
                    } else {
                        return `${this.name}: ${this.message}`;
                    }
                };
                return errorClass;
            }
            var BindingError = undefined;
            function throwBindingError(message) {
                throw new BindingError(message);
            }
            var InternalError = undefined;
            function throwInternalError(message) {
                throw new InternalError(message);
            }
            function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
                myTypes.forEach(function(type) {
                    typeDependencies[type] = dependentTypes;
                });
                function onComplete(typeConverters) {
                    var myTypeConverters = getTypeConverters(typeConverters);
                    if (myTypeConverters.length !== myTypes.length) {
                        throwInternalError('Mismatched type converter count');
                    }
                    for(var i = 0; i < myTypes.length; ++i){
                        registerType(myTypes[i], myTypeConverters[i]);
                    }
                }
                var typeConverters = new Array(dependentTypes.length);
                var unregisteredTypes = [];
                var registered = 0;
                dependentTypes.forEach((dt, i)=>{
                    if (registeredTypes.hasOwnProperty(dt)) {
                        typeConverters[i] = registeredTypes[dt];
                    } else {
                        unregisteredTypes.push(dt);
                        if (!awaitingDependencies.hasOwnProperty(dt)) {
                            awaitingDependencies[dt] = [];
                        }
                        awaitingDependencies[dt].push(()=>{
                            typeConverters[i] = registeredTypes[dt];
                            ++registered;
                            if (registered === unregisteredTypes.length) {
                                onComplete(typeConverters);
                            }
                        });
                    }
                });
                if (0 === unregisteredTypes.length) {
                    onComplete(typeConverters);
                }
            }
            /** @param {Object=} options */ function registerType(rawType, registeredInstance, options = {}) {
                if (!('argPackAdvance' in registeredInstance)) {
                    throw new TypeError('registerType registeredInstance requires argPackAdvance');
                }
                var name = registeredInstance.name;
                if (!rawType) {
                    throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
                }
                if (registeredTypes.hasOwnProperty(rawType)) {
                    if (options.ignoreDuplicateRegistrations) {
                        return;
                    } else {
                        throwBindingError(`Cannot register type '${name}' twice`);
                    }
                }
                registeredTypes[rawType] = registeredInstance;
                delete typeDependencies[rawType];
                if (awaitingDependencies.hasOwnProperty(rawType)) {
                    var callbacks = awaitingDependencies[rawType];
                    delete awaitingDependencies[rawType];
                    callbacks.forEach((cb)=>cb());
                }
            }
            function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
                var shift = getShiftFromSize(size);
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(wt) {
                        // ambiguous emscripten ABI: sometimes return values are
                        // true or false, and sometimes integers (0 or 1)
                        return !!wt;
                    },
                    'toWireType': function(destructors, o) {
                        return o ? trueValue : falseValue;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': function(pointer) {
                        // TODO: if heap is fixed (like in asm.js) this could be executed outside
                        var heap;
                        if (size === 1) {
                            heap = HEAP8;
                        } else if (size === 2) {
                            heap = HEAP16;
                        } else if (size === 4) {
                            heap = HEAP32;
                        } else {
                            throw new TypeError("Unknown boolean type size: " + name);
                        }
                        return this['fromWireType'](heap[pointer >> shift]);
                    },
                    destructorFunction: null
                });
            }
            function ClassHandle_isAliasOf(other) {
                if (!(this instanceof ClassHandle)) {
                    return false;
                }
                if (!(other instanceof ClassHandle)) {
                    return false;
                }
                var leftClass = this.$$.ptrType.registeredClass;
                var left = this.$$.ptr;
                var rightClass = other.$$.ptrType.registeredClass;
                var right = other.$$.ptr;
                while(leftClass.baseClass){
                    left = leftClass.upcast(left);
                    leftClass = leftClass.baseClass;
                }
                while(rightClass.baseClass){
                    right = rightClass.upcast(right);
                    rightClass = rightClass.baseClass;
                }
                return leftClass === rightClass && left === right;
            }
            function shallowCopyInternalPointer(o) {
                return {
                    count: o.count,
                    deleteScheduled: o.deleteScheduled,
                    preservePointerOnDelete: o.preservePointerOnDelete,
                    ptr: o.ptr,
                    ptrType: o.ptrType,
                    smartPtr: o.smartPtr,
                    smartPtrType: o.smartPtrType
                };
            }
            function throwInstanceAlreadyDeleted(obj) {
                function getInstanceTypeName(handle) {
                    return handle.$$.ptrType.registeredClass.name;
                }
                throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
            }
            var finalizationRegistry = false;
            function detachFinalizer(handle) {}
            function runDestructor($$) {
                if ($$.smartPtr) {
                    $$.smartPtrType.rawDestructor($$.smartPtr);
                } else {
                    $$.ptrType.registeredClass.rawDestructor($$.ptr);
                }
            }
            function releaseClassHandle($$) {
                $$.count.value -= 1;
                var toDelete = 0 === $$.count.value;
                if (toDelete) {
                    runDestructor($$);
                }
            }
            function downcastPointer(ptr, ptrClass, desiredClass) {
                if (ptrClass === desiredClass) {
                    return ptr;
                }
                if (undefined === desiredClass.baseClass) {
                    return null; // no conversion
                }
                var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
                if (rv === null) {
                    return null;
                }
                return desiredClass.downcast(rv);
            }
            var registeredPointers = {};
            function getInheritedInstanceCount() {
                return Object.keys(registeredInstances).length;
            }
            function getLiveInheritedInstances() {
                var rv = [];
                for(var k in registeredInstances){
                    if (registeredInstances.hasOwnProperty(k)) {
                        rv.push(registeredInstances[k]);
                    }
                }
                return rv;
            }
            var deletionQueue = [];
            function flushPendingDeletes() {
                while(deletionQueue.length){
                    var obj = deletionQueue.pop();
                    obj.$$.deleteScheduled = false;
                    obj['delete']();
                }
            }
            var delayFunction = undefined;
            function setDelayFunction(fn) {
                delayFunction = fn;
                if (deletionQueue.length && delayFunction) {
                    delayFunction(flushPendingDeletes);
                }
            }
            function init_embind() {
                Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
                Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
                Module['flushPendingDeletes'] = flushPendingDeletes;
                Module['setDelayFunction'] = setDelayFunction;
            }
            var registeredInstances = {};
            function getBasestPointer(class_, ptr) {
                if (ptr === undefined) {
                    throwBindingError('ptr should not be undefined');
                }
                while(class_.baseClass){
                    ptr = class_.upcast(ptr);
                    class_ = class_.baseClass;
                }
                return ptr;
            }
            function getInheritedInstance(class_, ptr) {
                ptr = getBasestPointer(class_, ptr);
                return registeredInstances[ptr];
            }
            function makeClassHandle(prototype, record) {
                if (!record.ptrType || !record.ptr) {
                    throwInternalError('makeClassHandle requires ptr and ptrType');
                }
                var hasSmartPtrType = !!record.smartPtrType;
                var hasSmartPtr = !!record.smartPtr;
                if (hasSmartPtrType !== hasSmartPtr) {
                    throwInternalError('Both smartPtrType and smartPtr must be specified');
                }
                record.count = {
                    value: 1
                };
                return attachFinalizer(Object.create(prototype, {
                    $$: {
                        value: record
                    }
                }));
            }
            function RegisteredPointer_fromWireType(ptr) {
                // ptr is a raw pointer (or a raw smartpointer)
                // rawPointer is a maybe-null raw pointer
                var rawPointer = this.getPointee(ptr);
                if (!rawPointer) {
                    this.destructor(ptr);
                    return null;
                }
                var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
                if (undefined !== registeredInstance) {
                    // JS object has been neutered, time to repopulate it
                    if (0 === registeredInstance.$$.count.value) {
                        registeredInstance.$$.ptr = rawPointer;
                        registeredInstance.$$.smartPtr = ptr;
                        return registeredInstance['clone']();
                    } else {
                        // else, just increment reference count on existing object
                        // it already has a reference to the smart pointer
                        var rv = registeredInstance['clone']();
                        this.destructor(ptr);
                        return rv;
                    }
                }
                function makeDefaultHandle() {
                    if (this.isSmartPointer) {
                        return makeClassHandle(this.registeredClass.instancePrototype, {
                            ptrType: this.pointeeType,
                            ptr: rawPointer,
                            smartPtrType: this,
                            smartPtr: ptr
                        });
                    } else {
                        return makeClassHandle(this.registeredClass.instancePrototype, {
                            ptrType: this,
                            ptr: ptr
                        });
                    }
                }
                var actualType = this.registeredClass.getActualType(rawPointer);
                var registeredPointerRecord = registeredPointers[actualType];
                if (!registeredPointerRecord) {
                    return makeDefaultHandle.call(this);
                }
                var toType;
                if (this.isConst) {
                    toType = registeredPointerRecord.constPointerType;
                } else {
                    toType = registeredPointerRecord.pointerType;
                }
                var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
                if (dp === null) {
                    return makeDefaultHandle.call(this);
                }
                if (this.isSmartPointer) {
                    return makeClassHandle(toType.registeredClass.instancePrototype, {
                        ptrType: toType,
                        ptr: dp,
                        smartPtrType: this,
                        smartPtr: ptr
                    });
                } else {
                    return makeClassHandle(toType.registeredClass.instancePrototype, {
                        ptrType: toType,
                        ptr: dp
                    });
                }
            }
            function attachFinalizer(handle) {
                if ('undefined' === typeof FinalizationRegistry) {
                    attachFinalizer = (handle)=>handle;
                    return handle;
                }
                // If the running environment has a FinalizationRegistry (see
                // https://github.com/tc39/proposal-weakrefs), then attach finalizers
                // for class handles.  We check for the presence of FinalizationRegistry
                // at run-time, not build-time.
                finalizationRegistry = new FinalizationRegistry((info)=>{
                    console.warn(info.leakWarning.stack.replace(/^Error: /, ''));
                    releaseClassHandle(info.$$);
                });
                attachFinalizer = (handle)=>{
                    var $$ = handle.$$;
                    var hasSmartPtr = !!$$.smartPtr;
                    if (hasSmartPtr) {
                        // We should not call the destructor on raw pointers in case other code expects the pointee to live
                        var info = {
                            $$: $$
                        };
                        // Create a warning as an Error instance in advance so that we can store
                        // the current stacktrace and point to it when / if a leak is detected.
                        // This is more useful than the empty stacktrace of `FinalizationRegistry`
                        // callback.
                        var cls = $$.ptrType.registeredClass;
                        info.leakWarning = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.\n` + "We'll free it automatically in this case, but this functionality is not reliable across various environments.\n" + "Make sure to invoke .delete() manually once you're done with the instance instead.\n" + "Originally allocated"); // `.stack` will add "at ..." after this sentence
                        if ('captureStackTrace' in Error) {
                            Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);
                        }
                        finalizationRegistry.register(handle, info, handle);
                    }
                    return handle;
                };
                detachFinalizer = (handle)=>finalizationRegistry.unregister(handle);
                return attachFinalizer(handle);
            }
            function ClassHandle_clone() {
                if (!this.$$.ptr) {
                    throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.preservePointerOnDelete) {
                    this.$$.count.value += 1;
                    return this;
                } else {
                    var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                        $$: {
                            value: shallowCopyInternalPointer(this.$$)
                        }
                    }));
                    clone.$$.count.value += 1;
                    clone.$$.deleteScheduled = false;
                    return clone;
                }
            }
            function ClassHandle_delete() {
                if (!this.$$.ptr) {
                    throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                    throwBindingError('Object already scheduled for deletion');
                }
                detachFinalizer(this);
                releaseClassHandle(this.$$);
                if (!this.$$.preservePointerOnDelete) {
                    this.$$.smartPtr = undefined;
                    this.$$.ptr = undefined;
                }
            }
            function ClassHandle_isDeleted() {
                return !this.$$.ptr;
            }
            function ClassHandle_deleteLater() {
                if (!this.$$.ptr) {
                    throwInstanceAlreadyDeleted(this);
                }
                if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                    throwBindingError('Object already scheduled for deletion');
                }
                deletionQueue.push(this);
                if (deletionQueue.length === 1 && delayFunction) {
                    delayFunction(flushPendingDeletes);
                }
                this.$$.deleteScheduled = true;
                return this;
            }
            function init_ClassHandle() {
                ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
                ClassHandle.prototype['clone'] = ClassHandle_clone;
                ClassHandle.prototype['delete'] = ClassHandle_delete;
                ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
                ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
            }
            function ClassHandle() {}
            function ensureOverloadTable(proto, methodName, humanName) {
                if (undefined === proto[methodName].overloadTable) {
                    var prevFunc = proto[methodName];
                    // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
                    proto[methodName] = function() {
                        // TODO This check can be removed in -O3 level "unsafe" optimizations.
                        if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);
                        }
                        return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
                    };
                    // Move the previous function into the overload table.
                    proto[methodName].overloadTable = [];
                    proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
                }
            }
            /** @param {number=} numArguments */ function exposePublicSymbol(name, value, numArguments) {
                if (Module.hasOwnProperty(name)) {
                    if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
                        throwBindingError(`Cannot register public name '${name}' twice`);
                    }
                    // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
                    // that routes between the two.
                    ensureOverloadTable(Module, name, name);
                    if (Module.hasOwnProperty(numArguments)) {
                        throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
                    }
                    // Add the new function into the overload table.
                    Module[name].overloadTable[numArguments] = value;
                } else {
                    Module[name] = value;
                    if (undefined !== numArguments) {
                        Module[name].numArguments = numArguments;
                    }
                }
            }
            /** @constructor */ function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
                this.name = name;
                this.constructor = constructor;
                this.instancePrototype = instancePrototype;
                this.rawDestructor = rawDestructor;
                this.baseClass = baseClass;
                this.getActualType = getActualType;
                this.upcast = upcast;
                this.downcast = downcast;
                this.pureVirtualFunctions = [];
            }
            function upcastPointer(ptr, ptrClass, desiredClass) {
                while(ptrClass !== desiredClass){
                    if (!ptrClass.upcast) {
                        throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
                    }
                    ptr = ptrClass.upcast(ptr);
                    ptrClass = ptrClass.baseClass;
                }
                return ptr;
            }
            function constNoSmartPtrRawPointerToWireType(destructors, handle) {
                if (handle === null) {
                    if (this.isReference) {
                        throwBindingError(`null is not a valid ${this.name}`);
                    }
                    return 0;
                }
                if (!handle.$$) {
                    throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
                }
                if (!handle.$$.ptr) {
                    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
                }
                var handleClass = handle.$$.ptrType.registeredClass;
                var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
                return ptr;
            }
            function genericPointerToWireType(destructors, handle) {
                var ptr;
                if (handle === null) {
                    if (this.isReference) {
                        throwBindingError(`null is not a valid ${this.name}`);
                    }
                    if (this.isSmartPointer) {
                        ptr = this.rawConstructor();
                        if (destructors !== null) {
                            destructors.push(this.rawDestructor, ptr);
                        }
                        return ptr;
                    } else {
                        return 0;
                    }
                }
                if (!handle.$$) {
                    throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
                }
                if (!handle.$$.ptr) {
                    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
                }
                if (!this.isConst && handle.$$.ptrType.isConst) {
                    throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
                }
                var handleClass = handle.$$.ptrType.registeredClass;
                ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
                if (this.isSmartPointer) {
                    // TODO: this is not strictly true
                    // We could support BY_EMVAL conversions from raw pointers to smart pointers
                    // because the smart pointer can hold a reference to the handle
                    if (undefined === handle.$$.smartPtr) {
                        throwBindingError('Passing raw pointer to smart pointer is illegal');
                    }
                    switch(this.sharingPolicy){
                        case 0:
                            // no upcasting
                            if (handle.$$.smartPtrType === this) {
                                ptr = handle.$$.smartPtr;
                            } else {
                                throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
                            }
                            break;
                        case 1:
                            ptr = handle.$$.smartPtr;
                            break;
                        case 2:
                            if (handle.$$.smartPtrType === this) {
                                ptr = handle.$$.smartPtr;
                            } else {
                                var clonedHandle = handle['clone']();
                                ptr = this.rawShare(ptr, Emval.toHandle(function() {
                                    clonedHandle['delete']();
                                }));
                                if (destructors !== null) {
                                    destructors.push(this.rawDestructor, ptr);
                                }
                            }
                            break;
                        default:
                            throwBindingError('Unsupporting sharing policy');
                    }
                }
                return ptr;
            }
            function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
                if (handle === null) {
                    if (this.isReference) {
                        throwBindingError(`null is not a valid ${this.name}`);
                    }
                    return 0;
                }
                if (!handle.$$) {
                    throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
                }
                if (!handle.$$.ptr) {
                    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
                }
                if (handle.$$.ptrType.isConst) {
                    throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
                }
                var handleClass = handle.$$.ptrType.registeredClass;
                var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
                return ptr;
            }
            function simpleReadValueFromPointer(pointer) {
                return this['fromWireType'](HEAP32[pointer >> 2]);
            }
            function RegisteredPointer_getPointee(ptr) {
                if (this.rawGetPointee) {
                    ptr = this.rawGetPointee(ptr);
                }
                return ptr;
            }
            function RegisteredPointer_destructor(ptr) {
                if (this.rawDestructor) {
                    this.rawDestructor(ptr);
                }
            }
            function RegisteredPointer_deleteObject(handle) {
                if (handle !== null) {
                    handle['delete']();
                }
            }
            function init_RegisteredPointer() {
                RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
                RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
                RegisteredPointer.prototype['argPackAdvance'] = 8;
                RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
                RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
                RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
            }
            /** @constructor
	      @param {*=} pointeeType,
	      @param {*=} sharingPolicy,
	      @param {*=} rawGetPointee,
	      @param {*=} rawConstructor,
	      @param {*=} rawShare,
	      @param {*=} rawDestructor,
	       */ function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
                this.name = name;
                this.registeredClass = registeredClass;
                this.isReference = isReference;
                this.isConst = isConst;
                // smart pointer properties
                this.isSmartPointer = isSmartPointer;
                this.pointeeType = pointeeType;
                this.sharingPolicy = sharingPolicy;
                this.rawGetPointee = rawGetPointee;
                this.rawConstructor = rawConstructor;
                this.rawShare = rawShare;
                this.rawDestructor = rawDestructor;
                if (!isSmartPointer && registeredClass.baseClass === undefined) {
                    if (isConst) {
                        this['toWireType'] = constNoSmartPtrRawPointerToWireType;
                        this.destructorFunction = null;
                    } else {
                        this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
                        this.destructorFunction = null;
                    }
                } else {
                    this['toWireType'] = genericPointerToWireType;
                // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
                // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
                // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
                //       craftInvokerFunction altogether.
                }
            }
            /** @param {number=} numArguments */ function replacePublicSymbol(name, value, numArguments) {
                if (!Module.hasOwnProperty(name)) {
                    throwInternalError('Replacing nonexistant public symbol');
                }
                // If there's an overload table for this symbol, replace the symbol in the overload table instead.
                if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
                    Module[name].overloadTable[numArguments] = value;
                } else {
                    Module[name] = value;
                    Module[name].argCount = numArguments;
                }
            }
            function dynCallLegacy(sig, ptr, args) {
                assert('dynCall_' + sig in Module, `bad function pointer type - dynCall function not found for sig '${sig}'`);
                if (args && args.length) {
                    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
                    assert(args.length === sig.substring(1).replace(/j/g, '--').length);
                } else {
                    assert(sig.length == 1);
                }
                var f = Module['dynCall_' + sig];
                return args && args.length ? f.apply(null, [
                    ptr
                ].concat(args)) : f.call(null, ptr);
            }
            var wasmTableMirror = [];
            function getWasmTableEntry(funcPtr) {
                var func = wasmTableMirror[funcPtr];
                if (!func) {
                    if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
                    wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
                }
                assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
                return func;
            }
            /** @param {Object=} args */ function dynCall(sig, ptr, args) {
                // Without WASM_BIGINT support we cannot directly call function with i64 as
                // part of thier signature, so we rely the dynCall functions generated by
                // wasm-emscripten-finalize
                if (sig.includes('j')) {
                    return dynCallLegacy(sig, ptr, args);
                }
                assert(getWasmTableEntry(ptr), `missing table entry in dynCall: ${ptr}`);
                var rtn = getWasmTableEntry(ptr).apply(null, args);
                return rtn;
            }
            function getDynCaller(sig, ptr) {
                assert(sig.includes('j') || sig.includes('p'), 'getDynCaller should only be called with i64 sigs');
                var argCache = [];
                return function() {
                    argCache.length = 0;
                    Object.assign(argCache, arguments);
                    return dynCall(sig, ptr, argCache);
                };
            }
            function embind__requireFunction(signature, rawFunction) {
                signature = readLatin1String(signature);
                function makeDynCaller() {
                    if (signature.includes('j')) {
                        return getDynCaller(signature, rawFunction);
                    }
                    return getWasmTableEntry(rawFunction);
                }
                var fp = makeDynCaller();
                if (typeof fp != "function") {
                    throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
                }
                return fp;
            }
            var UnboundTypeError = undefined;
            function getTypeName(type) {
                var ptr = ___getTypeName(type);
                var rv = readLatin1String(ptr);
                _free(ptr);
                return rv;
            }
            function throwUnboundTypeError(message, types) {
                var unboundTypes = [];
                var seen = {};
                function visit(type) {
                    if (seen[type]) {
                        return;
                    }
                    if (registeredTypes[type]) {
                        return;
                    }
                    if (typeDependencies[type]) {
                        typeDependencies[type].forEach(visit);
                        return;
                    }
                    unboundTypes.push(type);
                    seen[type] = true;
                }
                types.forEach(visit);
                throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([
                    ', '
                ]));
            }
            function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
                name = readLatin1String(name);
                getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
                if (upcast) {
                    upcast = embind__requireFunction(upcastSignature, upcast);
                }
                if (downcast) {
                    downcast = embind__requireFunction(downcastSignature, downcast);
                }
                rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
                var legalFunctionName = makeLegalFunctionName(name);
                exposePublicSymbol(legalFunctionName, function() {
                    // this code cannot run if baseClassRawType is zero
                    throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [
                        baseClassRawType
                    ]);
                });
                whenDependentTypesAreResolved([
                    rawType,
                    rawPointerType,
                    rawConstPointerType
                ], baseClassRawType ? [
                    baseClassRawType
                ] : [], function(base) {
                    base = base[0];
                    var baseClass;
                    var basePrototype;
                    if (baseClassRawType) {
                        baseClass = base.registeredClass;
                        basePrototype = baseClass.instancePrototype;
                    } else {
                        basePrototype = ClassHandle.prototype;
                    }
                    var constructor = createNamedFunction(legalFunctionName, function() {
                        if (Object.getPrototypeOf(this) !== instancePrototype) {
                            throw new BindingError("Use 'new' to construct " + name);
                        }
                        if (undefined === registeredClass.constructor_body) {
                            throw new BindingError(name + " has no accessible constructor");
                        }
                        var body = registeredClass.constructor_body[arguments.length];
                        if (undefined === body) {
                            throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
                        }
                        return body.apply(this, arguments);
                    });
                    var instancePrototype = Object.create(basePrototype, {
                        constructor: {
                            value: constructor
                        }
                    });
                    constructor.prototype = instancePrototype;
                    var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
                    if (registeredClass.baseClass) {
                        // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.
                        if (registeredClass.baseClass.__derivedClasses === undefined) {
                            registeredClass.baseClass.__derivedClasses = [];
                        }
                        registeredClass.baseClass.__derivedClasses.push(registeredClass);
                    }
                    var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
                    var pointerConverter = new RegisteredPointer(name + '*', registeredClass, false, false, false);
                    var constPointerConverter = new RegisteredPointer(name + ' const*', registeredClass, false, true, false);
                    registeredPointers[rawType] = {
                        pointerType: pointerConverter,
                        constPointerType: constPointerConverter
                    };
                    replacePublicSymbol(legalFunctionName, constructor);
                    return [
                        referenceConverter,
                        pointerConverter,
                        constPointerConverter
                    ];
                });
            }
            function heap32VectorToArray(count, firstElement) {
                var array = [];
                for(var i = 0; i < count; i++){
                    // TODO(https://github.com/emscripten-core/emscripten/issues/17310):
                    // Find a way to hoist the `>> 2` or `>> 3` out of this loop.
                    array.push(HEAPU32[firstElement + i * 4 >> 2]);
                }
                return array;
            }
            function runDestructors(destructors) {
                while(destructors.length){
                    var ptr = destructors.pop();
                    var del = destructors.pop();
                    del(ptr);
                }
            }
            function newFunc(constructor, argumentList) {
                if (!(constructor instanceof Function)) {
                    throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
                }
                /*
	       * Previously, the following line was just:
	       *   function dummy() {};
	       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even
	       * though at creation, the 'dummy' has the correct constructor name.  Thus,
	       * objects created with IMVU.new would show up in the debugger as 'dummy',
	       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the
	       * issue.  Doublely-unfortunately, there's no way to write a test for this
	       * behavior.  -NRD 2013.02.22
	       */ var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function() {});
                dummy.prototype = constructor.prototype;
                var obj = new dummy;
                var r = constructor.apply(obj, argumentList);
                return r instanceof Object ? r : obj;
            }
            function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {
                // humanName: a human-readable string name for the function to be generated.
                // argTypes: An array that contains the embind type objects for all types in the function signature.
                //    argTypes[0] is the type object for the function return value.
                //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
                //    argTypes[2...] are the actual function parameters.
                // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
                // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
                // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
                // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.
                var argCount = argTypes.length;
                if (argCount < 2) {
                    throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
                }
                assert(!isAsync, 'Async bindings are only supported with JSPI.');
                var isClassMethodFunc = argTypes[1] !== null && classType !== null;
                // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
                // TODO: This omits argument count check - enable only at -O3 or similar.
                //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
                //       return FUNCTION_TABLE[fn];
                //    }
                // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
                // TODO: Remove this completely once all function invokers are being dynamically generated.
                var needsDestructorStack = false;
                for(var i = 1; i < argTypes.length; ++i){
                    if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
                        needsDestructorStack = true;
                        break;
                    }
                }
                var returns = argTypes[0].name !== "void";
                var argsList = "";
                var argsListWired = "";
                for(var i = 0; i < argCount - 2; ++i){
                    argsList += (i !== 0 ? ", " : "") + "arg" + i;
                    argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
                }
                var invokerFnBody = `
        return function ${makeLegalFunctionName(humanName)}(${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ${humanName} called with ${arguments.length} arguments, expected ${argCount - 2} args!');
        }`;
                if (needsDestructorStack) {
                    invokerFnBody += "var destructors = [];\n";
                }
                var dtorStack = needsDestructorStack ? "destructors" : "null";
                var args1 = [
                    "throwBindingError",
                    "invoker",
                    "fn",
                    "runDestructors",
                    "retType",
                    "classParam"
                ];
                var args2 = [
                    throwBindingError,
                    cppInvokerFunc,
                    cppTargetFunc,
                    runDestructors,
                    argTypes[0],
                    argTypes[1]
                ];
                if (isClassMethodFunc) {
                    invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
                }
                for(var i = 0; i < argCount - 2; ++i){
                    invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
                    args1.push("argType" + i);
                    args2.push(argTypes[i + 2]);
                }
                if (isClassMethodFunc) {
                    argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
                }
                invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
                if (needsDestructorStack) {
                    invokerFnBody += "runDestructors(destructors);\n";
                } else {
                    for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){
                        var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                        if (argTypes[i].destructorFunction !== null) {
                            invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                            args1.push(paramName + "_dtor");
                            args2.push(argTypes[i].destructorFunction);
                        }
                    }
                }
                if (returns) {
                    invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
                }
                invokerFnBody += "}\n";
                args1.push(invokerFnBody);
                return newFunc(Function, args1).apply(null, args2);
            }
            function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
                assert(argCount > 0);
                var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
                invoker = embind__requireFunction(invokerSignature, invoker);
                whenDependentTypesAreResolved([], [
                    rawClassType
                ], function(classType) {
                    classType = classType[0];
                    var humanName = `constructor ${classType.name}`;
                    if (undefined === classType.registeredClass.constructor_body) {
                        classType.registeredClass.constructor_body = [];
                    }
                    if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
                        throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
                    }
                    classType.registeredClass.constructor_body[argCount - 1] = ()=>{
                        throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
                    };
                    whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                        // Insert empty slot for context type (argTypes[1]).
                        argTypes.splice(1, 0, null);
                        classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
                        return [];
                    });
                    return [];
                });
            }
            function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
                var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
                methodName = readLatin1String(methodName);
                rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
                whenDependentTypesAreResolved([], [
                    rawClassType
                ], function(classType) {
                    classType = classType[0];
                    var humanName = `${classType.name}.${methodName}`;
                    if (methodName.startsWith("@@")) {
                        methodName = Symbol[methodName.substring(2)];
                    }
                    if (isPureVirtual) {
                        classType.registeredClass.pureVirtualFunctions.push(methodName);
                    }
                    function unboundTypesHandler() {
                        throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
                    }
                    var proto = classType.registeredClass.instancePrototype;
                    var method = proto[methodName];
                    if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
                        // This is the first overload to be registered, OR we are replacing a
                        // function in the base class with a function in the derived class.
                        unboundTypesHandler.argCount = argCount - 2;
                        unboundTypesHandler.className = classType.name;
                        proto[methodName] = unboundTypesHandler;
                    } else {
                        // There was an existing function with the same name registered. Set up
                        // a function overload routing table.
                        ensureOverloadTable(proto, methodName, humanName);
                        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
                    }
                    whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                        var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
                        // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types
                        // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.
                        if (undefined === proto[methodName].overloadTable) {
                            // Set argCount in case an overload is registered later
                            memberFunction.argCount = argCount - 2;
                            proto[methodName] = memberFunction;
                        } else {
                            proto[methodName].overloadTable[argCount - 2] = memberFunction;
                        }
                        return [];
                    });
                    return [];
                });
            }
            function validateThis(this_, classType, humanName) {
                if (!(this_ instanceof Object)) {
                    throwBindingError(`${humanName} with invalid "this": ${this_}`);
                }
                if (!(this_ instanceof classType.registeredClass.constructor)) {
                    throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
                }
                if (!this_.$$.ptr) {
                    throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
                }
                // todo: kill this
                return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
            }
            function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
                fieldName = readLatin1String(fieldName);
                getter = embind__requireFunction(getterSignature, getter);
                whenDependentTypesAreResolved([], [
                    classType
                ], function(classType) {
                    classType = classType[0];
                    var humanName = `${classType.name}.${fieldName}`;
                    var desc = {
                        get: function() {
                            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [
                                getterReturnType,
                                setterArgumentType
                            ]);
                        },
                        enumerable: true,
                        configurable: true
                    };
                    if (setter) {
                        desc.set = ()=>{
                            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [
                                getterReturnType,
                                setterArgumentType
                            ]);
                        };
                    } else {
                        desc.set = (v)=>{
                            throwBindingError(humanName + ' is a read-only property');
                        };
                    }
                    Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
                    whenDependentTypesAreResolved([], setter ? [
                        getterReturnType,
                        setterArgumentType
                    ] : [
                        getterReturnType
                    ], function(types) {
                        var getterReturnType = types[0];
                        var desc = {
                            get: function() {
                                var ptr = validateThis(this, classType, humanName + ' getter');
                                return getterReturnType['fromWireType'](getter(getterContext, ptr));
                            },
                            enumerable: true
                        };
                        if (setter) {
                            setter = embind__requireFunction(setterSignature, setter);
                            var setterArgumentType = types[1];
                            desc.set = function(v) {
                                var ptr = validateThis(this, classType, humanName + ' setter');
                                var destructors = [];
                                setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));
                                runDestructors(destructors);
                            };
                        }
                        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
                        return [];
                    });
                    return [];
                });
            }
            function __embind_register_constant(name, type, value) {
                name = readLatin1String(name);
                whenDependentTypesAreResolved([], [
                    type
                ], function(type) {
                    type = type[0];
                    Module[name] = type['fromWireType'](value);
                    return [];
                });
            }
            /** @constructor */ function HandleAllocator() {
                // Reserve slot 0 so that 0 is always an invalid handle
                this.allocated = [
                    undefined
                ];
                this.freelist = [];
                this.get = function(id) {
                    assert(this.allocated[id] !== undefined, `invalid handle: ${id}`);
                    return this.allocated[id];
                };
                this.has = function(id) {
                    return this.allocated[id] !== undefined;
                };
                this.allocate = function(handle) {
                    var id = this.freelist.pop() || this.allocated.length;
                    this.allocated[id] = handle;
                    return id;
                };
                this.free = function(id) {
                    assert(this.allocated[id] !== undefined);
                    // Set the slot to `undefined` rather than using `delete` here since
                    // apparently arrays with holes in them can be less efficient.
                    this.allocated[id] = undefined;
                    this.freelist.push(id);
                };
            }
            var emval_handles = new HandleAllocator();
            function __emval_decref(handle) {
                if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {
                    emval_handles.free(handle);
                }
            }
            function count_emval_handles() {
                var count = 0;
                for(var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i){
                    if (emval_handles.allocated[i] !== undefined) {
                        ++count;
                    }
                }
                return count;
            }
            function init_emval() {
                // reserve some special values. These never get de-allocated.
                // The HandleAllocator takes care of reserving zero.
                emval_handles.allocated.push({
                    value: undefined
                }, {
                    value: null
                }, {
                    value: true
                }, {
                    value: false
                });
                emval_handles.reserved = emval_handles.allocated.length;
                Module['count_emval_handles'] = count_emval_handles;
            }
            var Emval = {
                toValue: (handle)=>{
                    if (!handle) {
                        throwBindingError('Cannot use deleted val. handle = ' + handle);
                    }
                    return emval_handles.get(handle).value;
                },
                toHandle: (value)=>{
                    switch(value){
                        case undefined:
                            return 1;
                        case null:
                            return 2;
                        case true:
                            return 3;
                        case false:
                            return 4;
                        default:
                            {
                                return emval_handles.allocate({
                                    refcount: 1,
                                    value: value
                                });
                            }
                    }
                }
            };
            function __embind_register_emval(rawType, name) {
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(handle) {
                        var rv = Emval.toValue(handle);
                        __emval_decref(handle);
                        return rv;
                    },
                    'toWireType': function(destructors, value) {
                        return Emval.toHandle(value);
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': simpleReadValueFromPointer,
                    destructorFunction: null
                });
            }
            function embindRepr(v) {
                if (v === null) {
                    return 'null';
                }
                var t = typeof v;
                if (t === 'object' || t === 'array' || t === 'function') {
                    return v.toString();
                } else {
                    return '' + v;
                }
            }
            function floatReadValueFromPointer(name, shift) {
                switch(shift){
                    case 2:
                        return function(pointer) {
                            return this['fromWireType'](HEAPF32[pointer >> 2]);
                        };
                    case 3:
                        return function(pointer) {
                            return this['fromWireType'](HEAPF64[pointer >> 3]);
                        };
                    default:
                        throw new TypeError("Unknown float type: " + name);
                }
            }
            function __embind_register_float(rawType, name, size) {
                var shift = getShiftFromSize(size);
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(value) {
                        return value;
                    },
                    'toWireType': function(destructors, value) {
                        if (typeof value != "number" && typeof value != "boolean") {
                            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
                        }
                        // The VM will perform JS to Wasm value conversion, according to the spec:
                        // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
                        return value;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': floatReadValueFromPointer(name, shift),
                    destructorFunction: null
                });
            }
            function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
                var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
                name = readLatin1String(name);
                rawInvoker = embind__requireFunction(signature, rawInvoker);
                exposePublicSymbol(name, function() {
                    throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
                }, argCount - 1);
                whenDependentTypesAreResolved([], argTypes, function(argTypes) {
                    var invokerArgsArray = [
                        argTypes[0],
                        null
                    ].concat(argTypes.slice(1));
                    replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
                    return [];
                });
            }
            function integerReadValueFromPointer(name, shift, signed) {
                // integers are quite common, so generate very specialized functions
                switch(shift){
                    case 0:
                        return signed ? function readS8FromPointer(pointer) {
                            return HEAP8[pointer];
                        } : function readU8FromPointer(pointer) {
                            return HEAPU8[pointer];
                        };
                    case 1:
                        return signed ? function readS16FromPointer(pointer) {
                            return HEAP16[pointer >> 1];
                        } : function readU16FromPointer(pointer) {
                            return HEAPU16[pointer >> 1];
                        };
                    case 2:
                        return signed ? function readS32FromPointer(pointer) {
                            return HEAP32[pointer >> 2];
                        } : function readU32FromPointer(pointer) {
                            return HEAPU32[pointer >> 2];
                        };
                    default:
                        throw new TypeError("Unknown integer type: " + name);
                }
            }
            function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
                name = readLatin1String(name);
                // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come
                // out as 'i32 -1'. Always treat those as max u32.
                if (maxRange === -1) {
                    maxRange = 4294967295;
                }
                var shift = getShiftFromSize(size);
                var fromWireType = (value)=>value;
                if (minRange === 0) {
                    var bitshift = 32 - 8 * size;
                    fromWireType = (value)=>value << bitshift >>> bitshift;
                }
                var isUnsignedType = name.includes('unsigned');
                var checkAssertions = (value, toTypeName)=>{
                    if (typeof value != "number" && typeof value != "boolean") {
                        throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${toTypeName}`);
                    }
                    if (value < minRange || value > maxRange) {
                        throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${name}", which is outside the valid range [${minRange}, ${maxRange}]!`);
                    }
                };
                var toWireType;
                if (isUnsignedType) {
                    toWireType = function(destructors, value) {
                        checkAssertions(value, this.name);
                        return value >>> 0;
                    };
                } else {
                    toWireType = function(destructors, value) {
                        checkAssertions(value, this.name);
                        // The VM will perform JS to Wasm value conversion, according to the spec:
                        // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
                        return value;
                    };
                }
                registerType(primitiveType, {
                    name: name,
                    'fromWireType': fromWireType,
                    'toWireType': toWireType,
                    'argPackAdvance': 8,
                    'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
                    destructorFunction: null
                });
            }
            function __embind_register_memory_view(rawType, dataTypeIndex, name) {
                var typeMapping = [
                    Int8Array,
                    Uint8Array,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                ];
                var TA = typeMapping[dataTypeIndex];
                function decodeMemoryView(handle) {
                    handle = handle >> 2;
                    var heap = HEAPU32;
                    var size = heap[handle]; // in elements
                    var data = heap[handle + 1]; // byte offset into emscripten heap
                    return new TA(heap.buffer, data, size);
                }
                name = readLatin1String(name);
                registerType(rawType, {
                    name: name,
                    'fromWireType': decodeMemoryView,
                    'argPackAdvance': 8,
                    'readValueFromPointer': decodeMemoryView
                }, {
                    ignoreDuplicateRegistrations: true
                });
            }
            function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
                assert(typeof str === 'string');
                // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
                // undefined and false each don't write out any bytes.
                if (!(maxBytesToWrite > 0)) return 0;
                var startIdx = outIdx;
                var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                    // unit, not a Unicode code point of the character! So decode
                    // UTF16->UTF32->UTF8.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
                    // and https://www.ietf.org/rfc/rfc2279.txt
                    // and https://tools.ietf.org/html/rfc3629
                    var u = str.charCodeAt(i); // possibly a lead surrogate
                    if (u >= 0xD800 && u <= 0xDFFF) {
                        var u1 = str.charCodeAt(++i);
                        u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;
                    }
                    if (u <= 0x7F) {
                        if (outIdx >= endIdx) break;
                        heap[outIdx++] = u;
                    } else if (u <= 0x7FF) {
                        if (outIdx + 1 >= endIdx) break;
                        heap[outIdx++] = 0xC0 | u >> 6;
                        heap[outIdx++] = 0x80 | u & 63;
                    } else if (u <= 0xFFFF) {
                        if (outIdx + 2 >= endIdx) break;
                        heap[outIdx++] = 0xE0 | u >> 12;
                        heap[outIdx++] = 0x80 | u >> 6 & 63;
                        heap[outIdx++] = 0x80 | u & 63;
                    } else {
                        if (outIdx + 3 >= endIdx) break;
                        if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
                        heap[outIdx++] = 0xF0 | u >> 18;
                        heap[outIdx++] = 0x80 | u >> 12 & 63;
                        heap[outIdx++] = 0x80 | u >> 6 & 63;
                        heap[outIdx++] = 0x80 | u & 63;
                    }
                }
                // Null-terminate the pointer to the buffer.
                heap[outIdx] = 0;
                return outIdx - startIdx;
            }
            function stringToUTF8(str, outPtr, maxBytesToWrite) {
                assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
                return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
            }
            function lengthBytesUTF8(str) {
                var len = 0;
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                    // unit, not a Unicode code point of the character! So decode
                    // UTF16->UTF32->UTF8.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    var c = str.charCodeAt(i); // possibly a lead surrogate
                    if (c <= 0x7F) {
                        len++;
                    } else if (c <= 0x7FF) {
                        len += 2;
                    } else if (c >= 0xD800 && c <= 0xDFFF) {
                        len += 4;
                        ++i;
                    } else {
                        len += 3;
                    }
                }
                return len;
            }
            function __embind_register_std_string(rawType, name) {
                name = readLatin1String(name);
                var stdStringIsUTF8 = name === "std::string";
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(value) {
                        var length = HEAPU32[value >> 2];
                        var payload = value + 4;
                        var str;
                        if (stdStringIsUTF8) {
                            var decodeStartPtr = payload;
                            // Looping here to support possible embedded '0' bytes
                            for(var i = 0; i <= length; ++i){
                                var currentBytePtr = payload + i;
                                if (i == length || HEAPU8[currentBytePtr] == 0) {
                                    var maxRead = currentBytePtr - decodeStartPtr;
                                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                                    if (str === undefined) {
                                        str = stringSegment;
                                    } else {
                                        str += String.fromCharCode(0);
                                        str += stringSegment;
                                    }
                                    decodeStartPtr = currentBytePtr + 1;
                                }
                            }
                        } else {
                            var a = new Array(length);
                            for(var i = 0; i < length; ++i){
                                a[i] = String.fromCharCode(HEAPU8[payload + i]);
                            }
                            str = a.join('');
                        }
                        _free(value);
                        return str;
                    },
                    'toWireType': function(destructors, value) {
                        if (value instanceof ArrayBuffer) {
                            value = new Uint8Array(value);
                        }
                        var length;
                        var valueIsOfTypeString = typeof value == 'string';
                        if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                            throwBindingError('Cannot pass non-string to std::string');
                        }
                        if (stdStringIsUTF8 && valueIsOfTypeString) {
                            length = lengthBytesUTF8(value);
                        } else {
                            length = value.length;
                        }
                        // assumes 4-byte alignment
                        var base = _malloc(4 + length + 1);
                        var ptr = base + 4;
                        HEAPU32[base >> 2] = length;
                        if (stdStringIsUTF8 && valueIsOfTypeString) {
                            stringToUTF8(value, ptr, length + 1);
                        } else {
                            if (valueIsOfTypeString) {
                                for(var i = 0; i < length; ++i){
                                    var charCode = value.charCodeAt(i);
                                    if (charCode > 255) {
                                        _free(ptr);
                                        throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                                    }
                                    HEAPU8[ptr + i] = charCode;
                                }
                            } else {
                                for(var i = 0; i < length; ++i){
                                    HEAPU8[ptr + i] = value[i];
                                }
                            }
                        }
                        if (destructors !== null) {
                            destructors.push(_free, base);
                        }
                        return base;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': simpleReadValueFromPointer,
                    destructorFunction: function(ptr) {
                        _free(ptr);
                    }
                });
            }
            var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;
            function UTF16ToString(ptr, maxBytesToRead) {
                assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
                var endPtr = ptr;
                // TextDecoder needs to know the byte length in advance, it doesn't stop on
                // null terminator by itself.
                // Also, use the length info to avoid running tiny strings through
                // TextDecoder, since .subarray() allocates garbage.
                var idx = endPtr >> 1;
                var maxIdx = idx + maxBytesToRead / 2;
                // If maxBytesToRead is not passed explicitly, it will be undefined, and this
                // will always evaluate to true. This saves on code size.
                while(!(idx >= maxIdx) && HEAPU16[idx])++idx;
                endPtr = idx << 1;
                if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
                // Fallback: decode without UTF16Decoder
                var str = '';
                // If maxBytesToRead is not passed explicitly, it will be undefined, and the
                // for-loop's condition will always evaluate to true. The loop is then
                // terminated on the first null char.
                for(var i = 0; !(i >= maxBytesToRead / 2); ++i){
                    var codeUnit = HEAP16[ptr + i * 2 >> 1];
                    if (codeUnit == 0) break;
                    // fromCharCode constructs a character from a UTF-16 code unit, so we can
                    // pass the UTF16 string right through.
                    str += String.fromCharCode(codeUnit);
                }
                return str;
            }
            function stringToUTF16(str, outPtr, maxBytesToWrite) {
                assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
                assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
                // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
                if (maxBytesToWrite === undefined) {
                    maxBytesToWrite = 0x7FFFFFFF;
                }
                if (maxBytesToWrite < 2) return 0;
                maxBytesToWrite -= 2; // Null terminator.
                var startPtr = outPtr;
                var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
                for(var i = 0; i < numCharsToWrite; ++i){
                    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
                    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
                    HEAP16[outPtr >> 1] = codeUnit;
                    outPtr += 2;
                }
                // Null-terminate the pointer to the HEAP.
                HEAP16[outPtr >> 1] = 0;
                return outPtr - startPtr;
            }
            function lengthBytesUTF16(str) {
                return str.length * 2;
            }
            function UTF32ToString(ptr, maxBytesToRead) {
                assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
                var i = 0;
                var str = '';
                // If maxBytesToRead is not passed explicitly, it will be undefined, and this
                // will always evaluate to true. This saves on code size.
                while(!(i >= maxBytesToRead / 4)){
                    var utf32 = HEAP32[ptr + i * 4 >> 2];
                    if (utf32 == 0) break;
                    ++i;
                    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    if (utf32 >= 0x10000) {
                        var ch = utf32 - 0x10000;
                        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
                    } else {
                        str += String.fromCharCode(utf32);
                    }
                }
                return str;
            }
            function stringToUTF32(str, outPtr, maxBytesToWrite) {
                assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
                assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
                // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
                if (maxBytesToWrite === undefined) {
                    maxBytesToWrite = 0x7FFFFFFF;
                }
                if (maxBytesToWrite < 4) return 0;
                var startPtr = outPtr;
                var endPtr = startPtr + maxBytesToWrite - 4;
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
                    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
                        var trailSurrogate = str.charCodeAt(++i);
                        codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;
                    }
                    HEAP32[outPtr >> 2] = codeUnit;
                    outPtr += 4;
                    if (outPtr + 4 > endPtr) break;
                }
                // Null-terminate the pointer to the HEAP.
                HEAP32[outPtr >> 2] = 0;
                return outPtr - startPtr;
            }
            function lengthBytesUTF32(str) {
                var len = 0;
                for(var i = 0; i < str.length; ++i){
                    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
                    // See http://unicode.org/faq/utf_bom.html#utf16-3
                    var codeUnit = str.charCodeAt(i);
                    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
                    len += 4;
                }
                return len;
            }
            function __embind_register_std_wstring(rawType, charSize, name) {
                name = readLatin1String(name);
                var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
                if (charSize === 2) {
                    decodeString = UTF16ToString;
                    encodeString = stringToUTF16;
                    lengthBytesUTF = lengthBytesUTF16;
                    getHeap = ()=>HEAPU16;
                    shift = 1;
                } else if (charSize === 4) {
                    decodeString = UTF32ToString;
                    encodeString = stringToUTF32;
                    lengthBytesUTF = lengthBytesUTF32;
                    getHeap = ()=>HEAPU32;
                    shift = 2;
                }
                registerType(rawType, {
                    name: name,
                    'fromWireType': function(value) {
                        // Code mostly taken from _embind_register_std_string fromWireType
                        var length = HEAPU32[value >> 2];
                        var HEAP = getHeap();
                        var str;
                        var decodeStartPtr = value + 4;
                        // Looping here to support possible embedded '0' bytes
                        for(var i = 0; i <= length; ++i){
                            var currentBytePtr = value + 4 + i * charSize;
                            if (i == length || HEAP[currentBytePtr >> shift] == 0) {
                                var maxReadBytes = currentBytePtr - decodeStartPtr;
                                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                                if (str === undefined) {
                                    str = stringSegment;
                                } else {
                                    str += String.fromCharCode(0);
                                    str += stringSegment;
                                }
                                decodeStartPtr = currentBytePtr + charSize;
                            }
                        }
                        _free(value);
                        return str;
                    },
                    'toWireType': function(destructors, value) {
                        if (!(typeof value == 'string')) {
                            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
                        }
                        // assumes 4-byte alignment
                        var length = lengthBytesUTF(value);
                        var ptr = _malloc(4 + length + charSize);
                        HEAPU32[ptr >> 2] = length >> shift;
                        encodeString(value, ptr + 4, length + charSize);
                        if (destructors !== null) {
                            destructors.push(_free, ptr);
                        }
                        return ptr;
                    },
                    'argPackAdvance': 8,
                    'readValueFromPointer': simpleReadValueFromPointer,
                    destructorFunction: function(ptr) {
                        _free(ptr);
                    }
                });
            }
            function __embind_register_void(rawType, name) {
                name = readLatin1String(name);
                registerType(rawType, {
                    isVoid: true,
                    name: name,
                    'argPackAdvance': 0,
                    'fromWireType': function() {
                        return undefined;
                    },
                    'toWireType': function(destructors, o) {
                        // TODO: assert if anything else is given?
                        return undefined;
                    }
                });
            }
            function requireRegisteredType(rawType, humanName) {
                var impl = registeredTypes[rawType];
                if (undefined === impl) {
                    throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
                }
                return impl;
            }
            function __emval_as(handle, returnType, destructorsRef) {
                handle = Emval.toValue(handle);
                returnType = requireRegisteredType(returnType, 'emval::as');
                var destructors = [];
                var rd = Emval.toHandle(destructors);
                HEAPU32[destructorsRef >> 2] = rd;
                return returnType['toWireType'](destructors, handle);
            }
            function emval_lookupTypes(argCount, argTypes) {
                var a = new Array(argCount);
                for(var i = 0; i < argCount; ++i){
                    a[i] = requireRegisteredType(HEAPU32[argTypes + i * 4 >> 2], "parameter " + i);
                }
                return a;
            }
            function __emval_call(handle, argCount, argTypes, argv) {
                handle = Emval.toValue(handle);
                var types = emval_lookupTypes(argCount, argTypes);
                var args = new Array(argCount);
                for(var i = 0; i < argCount; ++i){
                    var type = types[i];
                    args[i] = type['readValueFromPointer'](argv);
                    argv += type['argPackAdvance'];
                }
                var rv = handle.apply(undefined, args);
                return Emval.toHandle(rv);
            }
            var emval_symbols = {};
            function getStringOrSymbol(address) {
                var symbol = emval_symbols[address];
                if (symbol === undefined) {
                    return readLatin1String(address);
                }
                return symbol;
            }
            var emval_methodCallers = [];
            function __emval_call_void_method(caller, handle, methodName, args) {
                caller = emval_methodCallers[caller];
                handle = Emval.toValue(handle);
                methodName = getStringOrSymbol(methodName);
                caller(handle, methodName, null, args);
            }
            function emval_addMethodCaller(caller) {
                var id = emval_methodCallers.length;
                emval_methodCallers.push(caller);
                return id;
            }
            var emval_registeredMethods = [];
            function __emval_get_method_caller(argCount, argTypes) {
                var types = emval_lookupTypes(argCount, argTypes);
                var retType = types[0];
                var signatureName = retType.name + "_$" + types.slice(1).map(function(t) {
                    return t.name;
                }).join("_") + "$";
                var returnId = emval_registeredMethods[signatureName];
                if (returnId !== undefined) {
                    return returnId;
                }
                var params = [
                    "retType"
                ];
                var args = [
                    retType
                ];
                var argsList = ""; // 'arg0, arg1, arg2, ... , argN'
                for(var i = 0; i < argCount - 1; ++i){
                    argsList += (i !== 0 ? ", " : "") + "arg" + i;
                    params.push("argType" + i);
                    args.push(types[1 + i]);
                }
                var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
                var functionBody = "return function " + functionName + "(handle, name, destructors, args) {\n";
                var offset = 0;
                for(var i = 0; i < argCount - 1; ++i){
                    functionBody += "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? "+" + offset : "") + ");\n";
                    offset += types[i + 1]['argPackAdvance'];
                }
                functionBody += "    var rv = handle[name](" + argsList + ");\n";
                for(var i = 0; i < argCount - 1; ++i){
                    if (types[i + 1]['deleteObject']) {
                        functionBody += "    argType" + i + ".deleteObject(arg" + i + ");\n";
                    }
                }
                if (!retType.isVoid) {
                    functionBody += "    return retType.toWireType(destructors, rv);\n";
                }
                functionBody += "};\n";
                params.push(functionBody);
                var invokerFunction = newFunc(Function, params).apply(null, args);
                returnId = emval_addMethodCaller(invokerFunction);
                emval_registeredMethods[signatureName] = returnId;
                return returnId;
            }
            function __emval_get_property(handle, key) {
                handle = Emval.toValue(handle);
                key = Emval.toValue(key);
                return Emval.toHandle(handle[key]);
            }
            function __emval_incref(handle) {
                if (handle > 4) {
                    emval_handles.get(handle).refcount += 1;
                }
            }
            function __emval_new_array() {
                return Emval.toHandle([]);
            }
            function __emval_new_cstring(v) {
                return Emval.toHandle(getStringOrSymbol(v));
            }
            function __emval_new_object() {
                return Emval.toHandle({});
            }
            function __emval_run_destructors(handle) {
                var destructors = Emval.toValue(handle);
                runDestructors(destructors);
                __emval_decref(handle);
            }
            function __emval_set_property(handle, key, value) {
                handle = Emval.toValue(handle);
                key = Emval.toValue(key);
                value = Emval.toValue(value);
                handle[key] = value;
            }
            function __emval_strictly_equals(first, second) {
                first = Emval.toValue(first);
                second = Emval.toValue(second);
                return first === second;
            }
            function __emval_take_value(type, arg) {
                type = requireRegisteredType(type, '_emval_take_value');
                var v = type['readValueFromPointer'](arg);
                return Emval.toHandle(v);
            }
            function __emval_typeof(handle) {
                handle = Emval.toValue(handle);
                return Emval.toHandle(typeof handle);
            }
            function _abort() {
                abort('native code called abort()');
            }
            function _emscripten_memcpy_big(dest, src, num) {
                HEAPU8.copyWithin(dest, src, src + num);
            }
            function getHeapMax() {
                // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
                // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
                // for any code that deals with heap sizes, which would require special
                // casing all heap size related code to treat 0 specially.
                return 2147483648;
            }
            function emscripten_realloc_buffer(size) {
                var b = wasmMemory.buffer;
                var pages = size - b.byteLength + 65535 >>> 16;
                try {
                    // round size grow request up to wasm page size (fixed 64KB per spec)
                    wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
                    updateMemoryViews();
                    return 1 /*success*/ ;
                } catch (e) {
                    err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
                }
            // implicit 0 return to save code size (caller will cast "undefined" into 0
            // anyhow)
            }
            function _emscripten_resize_heap(requestedSize) {
                var oldSize = HEAPU8.length;
                requestedSize = requestedSize >>> 0;
                // With multithreaded builds, races can happen (another thread might increase the size
                // in between), so return a failure, and let the caller retry.
                assert(requestedSize > oldSize);
                // Memory resize rules:
                // 1.  Always increase heap size to at least the requested size, rounded up
                //     to next page multiple.
                // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
                //     geometrically: increase the heap size according to
                //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
                //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
                // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
                //     linearly: increase the heap size by at least
                //     MEMORY_GROWTH_LINEAR_STEP bytes.
                // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
                //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
                // 4.  If we were unable to allocate as much memory, it may be due to
                //     over-eager decision to excessively reserve due to (3) above.
                //     Hence if an allocation fails, cut down on the amount of excess
                //     growth, in an attempt to succeed to perform a smaller allocation.
                // A limit is set for how much we can grow. We should not exceed that
                // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
                var maxHeapSize = getHeapMax();
                if (requestedSize > maxHeapSize) {
                    err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
                    return false;
                }
                var alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;
                // Loop through potential heap size increases. If we attempt a too eager
                // reservation that fails, cut down on the attempted size and reserve a
                // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
                for(var cutDown = 1; cutDown <= 4; cutDown *= 2){
                    var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
                    // but limit overreserving (default to capping at +96MB overgrowth at most)
                    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
                    var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
                    var replacement = emscripten_realloc_buffer(newSize);
                    if (replacement) {
                        return true;
                    }
                }
                err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
                return false;
            }
            function _fd_close(fd) {
                abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');
            }
            function _fd_read(fd, iov, iovcnt, pnum) {
                abort('fd_read called without SYSCALLS_REQUIRE_FILESYSTEM');
            }
            function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
                return 70;
            }
            var printCharBuffers = [
                null,
                [],
                []
            ];
            function printChar(stream, curr) {
                var buffer = printCharBuffers[stream];
                assert(buffer);
                if (curr === 0 || curr === 10) {
                    (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
                    buffer.length = 0;
                } else {
                    buffer.push(curr);
                }
            }
            function _fd_write(fd, iov, iovcnt, pnum) {
                // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
                var num = 0;
                for(var i = 0; i < iovcnt; i++){
                    var ptr = HEAPU32[iov >> 2];
                    var len = HEAPU32[iov + 4 >> 2];
                    iov += 8;
                    for(var j = 0; j < len; j++){
                        printChar(fd, HEAPU8[ptr + j]);
                    }
                    num += len;
                }
                HEAPU32[pnum >> 2] = num;
                return 0;
            }
            embind_init_charCodes();
            BindingError = Module['BindingError'] = extendError(Error, 'BindingError');
            InternalError = Module['InternalError'] = extendError(Error, 'InternalError');
            init_ClassHandle();
            init_embind();
            init_RegisteredPointer();
            UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');
            init_emval();
            // include: base64Utils.js
            // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149
            // This code was written by Tyler Akins and has been placed in the
            // public domain.  It would be nice if you left this header intact.
            // Base64 code from Tyler Akins -- http://rumkin.com
            /**
	 * Decodes a base64 string.
	 * @param {string} input The string to decode.
	 */ var decodeBase64 = typeof atob == 'function' ? atob : function(input) {
                var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                var output = '';
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;
                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
                do {
                    enc1 = keyStr.indexOf(input.charAt(i++));
                    enc2 = keyStr.indexOf(input.charAt(i++));
                    enc3 = keyStr.indexOf(input.charAt(i++));
                    enc4 = keyStr.indexOf(input.charAt(i++));
                    chr1 = enc1 << 2 | enc2 >> 4;
                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                    chr3 = (enc3 & 3) << 6 | enc4;
                    output = output + String.fromCharCode(chr1);
                    if (enc3 !== 64) {
                        output = output + String.fromCharCode(chr2);
                    }
                    if (enc4 !== 64) {
                        output = output + String.fromCharCode(chr3);
                    }
                }while (i < input.length)
                return output;
            };
            // Converts a string of base64 into a byte array.
            // Throws error on invalid input.
            function intArrayFromBase64(s) {
                try {
                    var decoded = decodeBase64(s);
                    var bytes = new Uint8Array(decoded.length);
                    for(var i = 0; i < decoded.length; ++i){
                        bytes[i] = decoded.charCodeAt(i);
                    }
                    return bytes;
                } catch (_) {
                    throw new Error('Converting base64 string to bytes failed.');
                }
            }
            // If filename is a base64 data URI, parses and returns data (Buffer on node,
            // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
            function tryParseAsDataURI(filename) {
                if (!isDataURI(filename)) {
                    return;
                }
                return intArrayFromBase64(filename.slice(dataURIPrefix.length));
            }
            // end include: base64Utils.js
            function checkIncomingModuleAPI() {
                ignoredModuleProp('fetchSettings');
            }
            var wasmImports = {
                "__assert_fail": ___assert_fail,
                "__cxa_throw": ___cxa_throw,
                "__syscall_fcntl64": ___syscall_fcntl64,
                "__syscall_ioctl": ___syscall_ioctl,
                "__syscall_openat": ___syscall_openat,
                "_embind_register_bigint": __embind_register_bigint,
                "_embind_register_bool": __embind_register_bool,
                "_embind_register_class": __embind_register_class,
                "_embind_register_class_constructor": __embind_register_class_constructor,
                "_embind_register_class_function": __embind_register_class_function,
                "_embind_register_class_property": __embind_register_class_property,
                "_embind_register_constant": __embind_register_constant,
                "_embind_register_emval": __embind_register_emval,
                "_embind_register_float": __embind_register_float,
                "_embind_register_function": __embind_register_function,
                "_embind_register_integer": __embind_register_integer,
                "_embind_register_memory_view": __embind_register_memory_view,
                "_embind_register_std_string": __embind_register_std_string,
                "_embind_register_std_wstring": __embind_register_std_wstring,
                "_embind_register_void": __embind_register_void,
                "_emval_as": __emval_as,
                "_emval_call": __emval_call,
                "_emval_call_void_method": __emval_call_void_method,
                "_emval_decref": __emval_decref,
                "_emval_get_method_caller": __emval_get_method_caller,
                "_emval_get_property": __emval_get_property,
                "_emval_incref": __emval_incref,
                "_emval_new_array": __emval_new_array,
                "_emval_new_cstring": __emval_new_cstring,
                "_emval_new_object": __emval_new_object,
                "_emval_run_destructors": __emval_run_destructors,
                "_emval_set_property": __emval_set_property,
                "_emval_strictly_equals": __emval_strictly_equals,
                "_emval_take_value": __emval_take_value,
                "_emval_typeof": __emval_typeof,
                "abort": _abort,
                "emscripten_memcpy_big": _emscripten_memcpy_big,
                "emscripten_resize_heap": _emscripten_resize_heap,
                "fd_close": _fd_close,
                "fd_read": _fd_read,
                "fd_seek": _fd_seek,
                "fd_write": _fd_write
            };
            createWasm();
            /** @type {function(...*):?} */ Module["_fflush"] = createExportWrapper("fflush");
            /** @type {function(...*):?} */ var _malloc = createExportWrapper("malloc");
            /** @type {function(...*):?} */ var _free = createExportWrapper("free");
            /** @type {function(...*):?} */ var ___getTypeName = createExportWrapper("__getTypeName");
            /** @type {function(...*):?} */ Module["__embind_initialize_bindings"] = createExportWrapper("_embind_initialize_bindings");
            /** @type {function(...*):?} */ var _emscripten_stack_init = function() {
                return (_emscripten_stack_init = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
            };
            /** @type {function(...*):?} */ var _emscripten_stack_get_end = function() {
                return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
            };
            /** @type {function(...*):?} */ var ___cxa_is_pointer_type = createExportWrapper("__cxa_is_pointer_type");
            /** @type {function(...*):?} */ Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
            // include: postamble.js
            // === Auto-generated postamble setup entry stuff ===
            var missingLibrarySymbols = [
                'zeroMemory',
                'exitJS',
                'isLeapYear',
                'ydayFromDate',
                'arraySum',
                'addDays',
                'inetPton4',
                'inetNtop4',
                'inetPton6',
                'inetNtop6',
                'readSockaddr',
                'writeSockaddr',
                'getHostByName',
                'initRandomFill',
                'randomFill',
                'traverseStack',
                'getCallstack',
                'emscriptenLog',
                'convertPCtoSourceLocation',
                'readEmAsmArgs',
                'jstoi_q',
                'jstoi_s',
                'getExecutableName',
                'listenOnce',
                'autoResumeAudioContext',
                'handleException',
                'runtimeKeepalivePush',
                'runtimeKeepalivePop',
                'callUserCallback',
                'maybeExit',
                'safeSetTimeout',
                'asmjsMangle',
                'asyncLoad',
                'alignMemory',
                'mmapAlloc',
                'getNativeTypeSize',
                'STACK_SIZE',
                'STACK_ALIGN',
                'POINTER_SIZE',
                'ASSERTIONS',
                'writeI53ToI64',
                'writeI53ToI64Clamped',
                'writeI53ToI64Signaling',
                'writeI53ToU64Clamped',
                'writeI53ToU64Signaling',
                'readI53FromI64',
                'readI53FromU64',
                'convertI32PairToI53',
                'convertU32PairToI53',
                'getCFunc',
                'ccall',
                'cwrap',
                'uleb128Encode',
                'sigToWasmTypes',
                'generateFuncType',
                'convertJsFunctionToWasm',
                'getEmptyTableSlot',
                'updateTableMap',
                'getFunctionAddress',
                'addFunction',
                'removeFunction',
                'reallyNegative',
                'unSign',
                'strLen',
                'reSign',
                'formatString',
                'intArrayFromString',
                'AsciiToString',
                'stringToAscii',
                'stringToNewUTF8',
                'stringToUTF8OnStack',
                'writeArrayToMemory',
                'registerKeyEventCallback',
                'maybeCStringToJsString',
                'findEventTarget',
                'findCanvasEventTarget',
                'getBoundingClientRect',
                'fillMouseEventData',
                'registerMouseEventCallback',
                'registerWheelEventCallback',
                'registerUiEventCallback',
                'registerFocusEventCallback',
                'fillDeviceOrientationEventData',
                'registerDeviceOrientationEventCallback',
                'fillDeviceMotionEventData',
                'registerDeviceMotionEventCallback',
                'screenOrientation',
                'fillOrientationChangeEventData',
                'registerOrientationChangeEventCallback',
                'fillFullscreenChangeEventData',
                'registerFullscreenChangeEventCallback',
                'JSEvents_requestFullscreen',
                'JSEvents_resizeCanvasForFullscreen',
                'registerRestoreOldStyle',
                'hideEverythingExceptGivenElement',
                'restoreHiddenElements',
                'setLetterbox',
                'softFullscreenResizeWebGLRenderTarget',
                'doRequestFullscreen',
                'fillPointerlockChangeEventData',
                'registerPointerlockChangeEventCallback',
                'registerPointerlockErrorEventCallback',
                'requestPointerLock',
                'fillVisibilityChangeEventData',
                'registerVisibilityChangeEventCallback',
                'registerTouchEventCallback',
                'fillGamepadEventData',
                'registerGamepadEventCallback',
                'registerBeforeUnloadEventCallback',
                'fillBatteryEventData',
                'battery',
                'registerBatteryEventCallback',
                'setCanvasElementSize',
                'getCanvasElementSize',
                'demangle',
                'demangleAll',
                'jsStackTrace',
                'stackTrace',
                'getEnvStrings',
                'checkWasiClock',
                'wasiRightsToMuslOFlags',
                'wasiOFlagsToMuslOFlags',
                'createDyncallWrapper',
                'setImmediateWrapped',
                'clearImmediateWrapped',
                'polyfillSetImmediate',
                'getPromise',
                'makePromise',
                'idsToPromises',
                'makePromiseCallback',
                'setMainLoop',
                'getSocketFromFD',
                'getSocketAddress',
                'heapObjectForWebGLType',
                'heapAccessShiftForWebGLHeap',
                'webgl_enable_ANGLE_instanced_arrays',
                'webgl_enable_OES_vertex_array_object',
                'webgl_enable_WEBGL_draw_buffers',
                'webgl_enable_WEBGL_multi_draw',
                'emscriptenWebGLGet',
                'computeUnpackAlignedImageSize',
                'colorChannelsInGlTextureFormat',
                'emscriptenWebGLGetTexPixelData',
                '__glGenObject',
                'emscriptenWebGLGetUniform',
                'webglGetUniformLocation',
                'webglPrepareUniformLocationsBeforeFirstUse',
                'webglGetLeftBracePos',
                'emscriptenWebGLGetVertexAttrib',
                '__glGetActiveAttribOrUniform',
                'writeGLArray',
                'registerWebGlEventCallback',
                'runAndAbortIfError',
                'SDL_unicode',
                'SDL_ttfContext',
                'SDL_audio',
                'GLFW_Window',
                'ALLOC_NORMAL',
                'ALLOC_STACK',
                'allocate',
                'writeStringToMemory',
                'writeAsciiToMemory',
                'registerInheritedInstance',
                'unregisterInheritedInstance',
                'enumReadValueFromPointer',
                'craftEmvalAllocator',
                'emval_get_global'
            ];
            missingLibrarySymbols.forEach(missingLibrarySymbol);
            var unexportedSymbols = [
                'run',
                'addOnPreRun',
                'addOnInit',
                'addOnPreMain',
                'addOnExit',
                'addOnPostRun',
                'addRunDependency',
                'removeRunDependency',
                'FS_createFolder',
                'FS_createPath',
                'FS_createDataFile',
                'FS_createLazyFile',
                'FS_createLink',
                'FS_createDevice',
                'FS_unlink',
                'out',
                'err',
                'callMain',
                'abort',
                'keepRuntimeAlive',
                'wasmMemory',
                'stackAlloc',
                'stackSave',
                'stackRestore',
                'getTempRet0',
                'setTempRet0',
                'writeStackCookie',
                'checkStackCookie',
                'intArrayFromBase64',
                'tryParseAsDataURI',
                'ptrToString',
                'getHeapMax',
                'emscripten_realloc_buffer',
                'ENV',
                'MONTH_DAYS_REGULAR',
                'MONTH_DAYS_LEAP',
                'MONTH_DAYS_REGULAR_CUMULATIVE',
                'MONTH_DAYS_LEAP_CUMULATIVE',
                'ERRNO_CODES',
                'ERRNO_MESSAGES',
                'setErrNo',
                'DNS',
                'Protocols',
                'Sockets',
                'timers',
                'warnOnce',
                'UNWIND_CACHE',
                'readEmAsmArgsArray',
                'dynCallLegacy',
                'getDynCaller',
                'dynCall',
                'HandleAllocator',
                'convertI32PairToI53Checked',
                'freeTableIndexes',
                'functionsInTableMap',
                'setValue',
                'getValue',
                'PATH',
                'PATH_FS',
                'UTF8Decoder',
                'UTF8ArrayToString',
                'UTF8ToString',
                'stringToUTF8Array',
                'stringToUTF8',
                'lengthBytesUTF8',
                'intArrayToString',
                'UTF16Decoder',
                'UTF16ToString',
                'stringToUTF16',
                'lengthBytesUTF16',
                'UTF32ToString',
                'stringToUTF32',
                'lengthBytesUTF32',
                'JSEvents',
                'specialHTMLTargets',
                'currentFullscreenStrategy',
                'restoreOldWindowedStyle',
                'ExitStatus',
                'flush_NO_FILESYSTEM',
                'dlopenMissingError',
                'promiseMap',
                'uncaughtExceptionCount',
                'exceptionLast',
                'exceptionCaught',
                'ExceptionInfo',
                'Browser',
                'wget',
                'SYSCALLS',
                'tempFixedLengthArray',
                'miniTempWebGLFloatBuffers',
                'miniTempWebGLIntBuffers',
                'GL',
                'emscripten_webgl_power_preferences',
                'AL',
                'GLUT',
                'EGL',
                'GLEW',
                'IDBStore',
                'SDL',
                'SDL_gfx',
                'GLFW',
                'allocateUTF8',
                'allocateUTF8OnStack',
                'InternalError',
                'BindingError',
                'UnboundTypeError',
                'PureVirtualError',
                'init_embind',
                'throwInternalError',
                'throwBindingError',
                'throwUnboundTypeError',
                'ensureOverloadTable',
                'exposePublicSymbol',
                'replacePublicSymbol',
                'extendError',
                'createNamedFunction',
                'embindRepr',
                'registeredInstances',
                'getBasestPointer',
                'getInheritedInstance',
                'getInheritedInstanceCount',
                'getLiveInheritedInstances',
                'registeredTypes',
                'awaitingDependencies',
                'typeDependencies',
                'registeredPointers',
                'registerType',
                'whenDependentTypesAreResolved',
                'embind_charCodes',
                'embind_init_charCodes',
                'readLatin1String',
                'getTypeName',
                'heap32VectorToArray',
                'requireRegisteredType',
                'getShiftFromSize',
                'integerReadValueFromPointer',
                'floatReadValueFromPointer',
                'simpleReadValueFromPointer',
                'runDestructors',
                'newFunc',
                'craftInvokerFunction',
                'embind__requireFunction',
                'tupleRegistrations',
                'structRegistrations',
                'genericPointerToWireType',
                'constNoSmartPtrRawPointerToWireType',
                'nonConstNoSmartPtrRawPointerToWireType',
                'init_RegisteredPointer',
                'RegisteredPointer',
                'RegisteredPointer_getPointee',
                'RegisteredPointer_destructor',
                'RegisteredPointer_deleteObject',
                'RegisteredPointer_fromWireType',
                'runDestructor',
                'releaseClassHandle',
                'finalizationRegistry',
                'detachFinalizer_deps',
                'detachFinalizer',
                'attachFinalizer',
                'makeClassHandle',
                'init_ClassHandle',
                'ClassHandle',
                'ClassHandle_isAliasOf',
                'throwInstanceAlreadyDeleted',
                'ClassHandle_clone',
                'ClassHandle_delete',
                'deletionQueue',
                'ClassHandle_isDeleted',
                'ClassHandle_deleteLater',
                'flushPendingDeletes',
                'delayFunction',
                'setDelayFunction',
                'RegisteredClass',
                'shallowCopyInternalPointer',
                'downcastPointer',
                'upcastPointer',
                'validateThis',
                'char_0',
                'char_9',
                'makeLegalFunctionName',
                'emval_handles',
                'emval_symbols',
                'init_emval',
                'count_emval_handles',
                'getStringOrSymbol',
                'Emval',
                'emval_newers',
                'emval_lookupTypes',
                'emval_allocateDestructors',
                'emval_methodCallers',
                'emval_addMethodCaller',
                'emval_registeredMethods'
            ];
            unexportedSymbols.forEach(unexportedRuntimeSymbol);
            var calledRun;
            dependenciesFulfilled = function runCaller() {
                // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
                if (!calledRun) run();
                if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
            };
            function stackCheckInit() {
                // This is normally called automatically during __wasm_call_ctors but need to
                // get these values before even running any of the ctors so we call it redundantly
                // here.
                _emscripten_stack_init();
                // TODO(sbc): Move writeStackCookie to native to to avoid this.
                writeStackCookie();
            }
            function run() {
                if (runDependencies > 0) {
                    return;
                }
                stackCheckInit();
                preRun();
                // a preRun added a dependency, run will be called later
                if (runDependencies > 0) {
                    return;
                }
                function doRun() {
                    // run may have just been called through dependencies being fulfilled just in this very frame,
                    // or while the async setStatus time below was happening
                    if (calledRun) return;
                    calledRun = true;
                    Module['calledRun'] = true;
                    if (ABORT) return;
                    initRuntime();
                    readyPromiseResolve(Module);
                    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();
                    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
                    postRun();
                }
                if (Module['setStatus']) {
                    Module['setStatus']('Running...');
                    setTimeout(function() {
                        setTimeout(function() {
                            Module['setStatus']('');
                        }, 1);
                        doRun();
                    }, 1);
                } else {
                    doRun();
                }
                checkStackCookie();
            }
            if (Module['preInit']) {
                if (typeof Module['preInit'] == 'function') Module['preInit'] = [
                    Module['preInit']
                ];
                while(Module['preInit'].length > 0){
                    Module['preInit'].pop()();
                }
            }
            run();
            // end include: postamble.js
            return Module.ready;
        };
    })();
    module.exports = Module;
})(bindImgui$1);
var bindImguiExports = bindImgui$1.exports;
var bindImgui = /*@__PURE__*/ getDefaultExportFromCjs(bindImguiExports);

//export { Bind };
let bind;
async function imgui(value) {
    return new Promise((resolve)=>{
        bindImgui(value).then((value)=>{
            bind = value;
            bind.FLT_MIN;
            bind.FLT_MAX;
            resolve();
        });
    });
}
const IMGUI_VERSION = '1.80'; // bind.IMGUI_VERSION;
function IMGUI_CHECKVERSION() {
    return DebugCheckVersionAndDataLayout(IMGUI_VERSION, bind.ImGuiIOSize, bind.ImGuiStyleSize, bind.ImVec2Size, bind.ImVec4Size, bind.ImDrawVertSize, bind.ImDrawIdxSize);
}
function ASSERT(c) {
    if (!c) {
        throw new Error();
    }
}
function IM_ASSERT(c) {
    if (!c) {
        throw new Error();
    }
}
function IM_ARRAYSIZE(_ARR) {
    if (_ARR instanceof ImStringBuffer) {
        return _ARR.size;
    } else {
        return _ARR.length;
    }
}
class ImStringBuffer {
    size;
    buffer;
    constructor(size, buffer = ''){
        this.size = size;
        this.buffer = buffer;
    }
}
var ImGuiWindowFlags;
(function(ImGuiWindowFlags) {
    ImGuiWindowFlags[ImGuiWindowFlags["None"] = 0] = "None";
    ImGuiWindowFlags[ImGuiWindowFlags["NoTitleBar"] = 1] = "NoTitleBar";
    ImGuiWindowFlags[ImGuiWindowFlags["NoResize"] = 2] = "NoResize";
    ImGuiWindowFlags[ImGuiWindowFlags["NoMove"] = 4] = "NoMove";
    ImGuiWindowFlags[ImGuiWindowFlags["NoScrollbar"] = 8] = "NoScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["NoScrollWithMouse"] = 16] = "NoScrollWithMouse";
    ImGuiWindowFlags[ImGuiWindowFlags["NoCollapse"] = 32] = "NoCollapse";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysAutoResize"] = 64] = "AlwaysAutoResize";
    ImGuiWindowFlags[ImGuiWindowFlags["NoBackground"] = 128] = "NoBackground";
    ImGuiWindowFlags[ImGuiWindowFlags["NoSavedSettings"] = 256] = "NoSavedSettings";
    ImGuiWindowFlags[ImGuiWindowFlags["NoMouseInputs"] = 512] = "NoMouseInputs";
    ImGuiWindowFlags[ImGuiWindowFlags["MenuBar"] = 1024] = "MenuBar";
    ImGuiWindowFlags[ImGuiWindowFlags["HorizontalScrollbar"] = 2048] = "HorizontalScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["NoFocusOnAppearing"] = 4096] = "NoFocusOnAppearing";
    ImGuiWindowFlags[ImGuiWindowFlags["NoBringToFrontOnFocus"] = 8192] = "NoBringToFrontOnFocus";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysVerticalScrollbar"] = 16384] = "AlwaysVerticalScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysHorizontalScrollbar"] = 32768] = "AlwaysHorizontalScrollbar";
    ImGuiWindowFlags[ImGuiWindowFlags["AlwaysUseWindowPadding"] = 65536] = "AlwaysUseWindowPadding";
    ImGuiWindowFlags[ImGuiWindowFlags["NoNavInputs"] = 262144] = "NoNavInputs";
    ImGuiWindowFlags[ImGuiWindowFlags["NoNavFocus"] = 524288] = "NoNavFocus";
    ImGuiWindowFlags[ImGuiWindowFlags["UnsavedDocument"] = 1048576] = "UnsavedDocument";
    ImGuiWindowFlags[ImGuiWindowFlags["NoNav"] = 786432] = "NoNav";
    ImGuiWindowFlags[ImGuiWindowFlags["NoDecoration"] = 43] = "NoDecoration";
    ImGuiWindowFlags[ImGuiWindowFlags["NoInputs"] = 786944] = "NoInputs";
    ImGuiWindowFlags[ImGuiWindowFlags["NavFlattened"] = 8388608] = "NavFlattened";
    ImGuiWindowFlags[ImGuiWindowFlags["ChildWindow"] = 16777216] = "ChildWindow";
    ImGuiWindowFlags[ImGuiWindowFlags["Tooltip"] = 33554432] = "Tooltip";
    ImGuiWindowFlags[ImGuiWindowFlags["Popup"] = 67108864] = "Popup";
    ImGuiWindowFlags[ImGuiWindowFlags["Modal"] = 134217728] = "Modal";
    ImGuiWindowFlags[ImGuiWindowFlags["ChildMenu"] = 268435456] = "ChildMenu";
})(ImGuiWindowFlags || (ImGuiWindowFlags = {}));
var ImGuiInputTextFlags;
(function(ImGuiInputTextFlags) {
    ImGuiInputTextFlags[ImGuiInputTextFlags["None"] = 0] = "None";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsDecimal"] = 1] = "CharsDecimal";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsHexadecimal"] = 2] = "CharsHexadecimal";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsUppercase"] = 4] = "CharsUppercase";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsNoBlank"] = 8] = "CharsNoBlank";
    ImGuiInputTextFlags[ImGuiInputTextFlags["AutoSelectAll"] = 16] = "AutoSelectAll";
    ImGuiInputTextFlags[ImGuiInputTextFlags["EnterReturnsTrue"] = 32] = "EnterReturnsTrue";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackCompletion"] = 64] = "CallbackCompletion";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackHistory"] = 128] = "CallbackHistory";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackAlways"] = 256] = "CallbackAlways";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackCharFilter"] = 512] = "CallbackCharFilter";
    ImGuiInputTextFlags[ImGuiInputTextFlags["AllowTabInput"] = 1024] = "AllowTabInput";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CtrlEnterForNewLine"] = 2048] = "CtrlEnterForNewLine";
    ImGuiInputTextFlags[ImGuiInputTextFlags["NoHorizontalScroll"] = 4096] = "NoHorizontalScroll";
    ImGuiInputTextFlags[ImGuiInputTextFlags["AlwaysInsertMode"] = 8192] = "AlwaysInsertMode";
    ImGuiInputTextFlags[ImGuiInputTextFlags["ReadOnly"] = 16384] = "ReadOnly";
    ImGuiInputTextFlags[ImGuiInputTextFlags["Password"] = 32768] = "Password";
    ImGuiInputTextFlags[ImGuiInputTextFlags["NoUndoRedo"] = 65536] = "NoUndoRedo";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CharsScientific"] = 131072] = "CharsScientific";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackResize"] = 262144] = "CallbackResize";
    ImGuiInputTextFlags[ImGuiInputTextFlags["CallbackEdit"] = 524288] = "CallbackEdit";
    ImGuiInputTextFlags[ImGuiInputTextFlags["Multiline"] = 1048576] = "Multiline";
    ImGuiInputTextFlags[ImGuiInputTextFlags["NoMarkEdited"] = 2097152] = "NoMarkEdited";
})(ImGuiInputTextFlags || (ImGuiInputTextFlags = {}));
var ImGuiTreeNodeFlags;
(function(ImGuiTreeNodeFlags) {
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["None"] = 0] = "None";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Selected"] = 1] = "Selected";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Framed"] = 2] = "Framed";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["AllowItemOverlap"] = 4] = "AllowItemOverlap";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["NoTreePushOnOpen"] = 8] = "NoTreePushOnOpen";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["NoAutoOpenOnLog"] = 16] = "NoAutoOpenOnLog";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["DefaultOpen"] = 32] = "DefaultOpen";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["OpenOnDoubleClick"] = 64] = "OpenOnDoubleClick";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["OpenOnArrow"] = 128] = "OpenOnArrow";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Leaf"] = 256] = "Leaf";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["Bullet"] = 512] = "Bullet";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["FramePadding"] = 1024] = "FramePadding";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["SpanAvailWidth"] = 2048] = "SpanAvailWidth";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["SpanFullWidth"] = 4096] = "SpanFullWidth";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["NavLeftJumpsBackHere"] = 8192] = "NavLeftJumpsBackHere";
    ImGuiTreeNodeFlags[ImGuiTreeNodeFlags["CollapsingHeader"] = 26] = "CollapsingHeader";
})(ImGuiTreeNodeFlags || (ImGuiTreeNodeFlags = {}));
var ImGuiPopupFlags;
(function(ImGuiPopupFlags) {
    ImGuiPopupFlags[ImGuiPopupFlags["None"] = 0] = "None";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonLeft"] = 0] = "MouseButtonLeft";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonRight"] = 1] = "MouseButtonRight";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonMiddle"] = 2] = "MouseButtonMiddle";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonMask_"] = 0x1f] = "MouseButtonMask_";
    ImGuiPopupFlags[ImGuiPopupFlags["MouseButtonDefault_"] = 1] = "MouseButtonDefault_";
    ImGuiPopupFlags[ImGuiPopupFlags["NoOpenOverExistingPopup"] = 32] = "NoOpenOverExistingPopup";
    ImGuiPopupFlags[ImGuiPopupFlags["NoOpenOverItems"] = 64] = "NoOpenOverItems";
    ImGuiPopupFlags[ImGuiPopupFlags["AnyPopupId"] = 128] = "AnyPopupId";
    ImGuiPopupFlags[ImGuiPopupFlags["AnyPopupLevel"] = 256] = "AnyPopupLevel";
    ImGuiPopupFlags[ImGuiPopupFlags["AnyPopup"] = 384] = "AnyPopup";
})(ImGuiPopupFlags || (ImGuiPopupFlags = {}));
var ImGuiSelectableFlags;
(function(ImGuiSelectableFlags) {
    ImGuiSelectableFlags[ImGuiSelectableFlags["None"] = 0] = "None";
    ImGuiSelectableFlags[ImGuiSelectableFlags["DontClosePopups"] = 1] = "DontClosePopups";
    ImGuiSelectableFlags[ImGuiSelectableFlags["SpanAllColumns"] = 2] = "SpanAllColumns";
    ImGuiSelectableFlags[ImGuiSelectableFlags["AllowDoubleClick"] = 4] = "AllowDoubleClick";
    ImGuiSelectableFlags[ImGuiSelectableFlags["Disabled"] = 8] = "Disabled";
    ImGuiSelectableFlags[ImGuiSelectableFlags["AllowItemOverlap"] = 16] = "AllowItemOverlap";
})(ImGuiSelectableFlags || (ImGuiSelectableFlags = {}));
var ImGuiComboFlags;
(function(ImGuiComboFlags) {
    ImGuiComboFlags[ImGuiComboFlags["None"] = 0] = "None";
    ImGuiComboFlags[ImGuiComboFlags["PopupAlignLeft"] = 1] = "PopupAlignLeft";
    ImGuiComboFlags[ImGuiComboFlags["HeightSmall"] = 2] = "HeightSmall";
    ImGuiComboFlags[ImGuiComboFlags["HeightRegular"] = 4] = "HeightRegular";
    ImGuiComboFlags[ImGuiComboFlags["HeightLarge"] = 8] = "HeightLarge";
    ImGuiComboFlags[ImGuiComboFlags["HeightLargest"] = 16] = "HeightLargest";
    ImGuiComboFlags[ImGuiComboFlags["NoArrowButton"] = 32] = "NoArrowButton";
    ImGuiComboFlags[ImGuiComboFlags["NoPreview"] = 64] = "NoPreview";
    ImGuiComboFlags[ImGuiComboFlags["HeightMask_"] = 30] = "HeightMask_";
})(ImGuiComboFlags || (ImGuiComboFlags = {}));
var ImGuiTabBarFlags;
(function(ImGuiTabBarFlags) {
    ImGuiTabBarFlags[ImGuiTabBarFlags["None"] = 0] = "None";
    ImGuiTabBarFlags[ImGuiTabBarFlags["Reorderable"] = 1] = "Reorderable";
    ImGuiTabBarFlags[ImGuiTabBarFlags["AutoSelectNewTabs"] = 2] = "AutoSelectNewTabs";
    ImGuiTabBarFlags[ImGuiTabBarFlags["TabListPopupButton"] = 4] = "TabListPopupButton";
    ImGuiTabBarFlags[ImGuiTabBarFlags["NoCloseWithMiddleMouseButton"] = 8] = "NoCloseWithMiddleMouseButton";
    ImGuiTabBarFlags[ImGuiTabBarFlags["NoTabListScrollingButtons"] = 16] = "NoTabListScrollingButtons";
    ImGuiTabBarFlags[ImGuiTabBarFlags["NoTooltip"] = 32] = "NoTooltip";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyResizeDown"] = 64] = "FittingPolicyResizeDown";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyScroll"] = 128] = "FittingPolicyScroll";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyMask_"] = 192] = "FittingPolicyMask_";
    ImGuiTabBarFlags[ImGuiTabBarFlags["FittingPolicyDefault_"] = 64] = "FittingPolicyDefault_";
})(ImGuiTabBarFlags || (ImGuiTabBarFlags = {}));
var ImGuiTabItemFlags;
(function(ImGuiTabItemFlags) {
    ImGuiTabItemFlags[ImGuiTabItemFlags["None"] = 0] = "None";
    ImGuiTabItemFlags[ImGuiTabItemFlags["UnsavedDocument"] = 1] = "UnsavedDocument";
    ImGuiTabItemFlags[ImGuiTabItemFlags["SetSelected"] = 2] = "SetSelected";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoCloseWithMiddleMouseButton"] = 4] = "NoCloseWithMiddleMouseButton";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoPushId"] = 8] = "NoPushId";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoTooltip"] = 16] = "NoTooltip";
    ImGuiTabItemFlags[ImGuiTabItemFlags["NoReorder"] = 32] = "NoReorder";
    ImGuiTabItemFlags[ImGuiTabItemFlags["Leading"] = 64] = "Leading";
    ImGuiTabItemFlags[ImGuiTabItemFlags["Trailing"] = 128] = "Trailing";
})(ImGuiTabItemFlags || (ImGuiTabItemFlags = {}));
var ImGuiTableFlags;
(function(ImGuiTableFlags) {
    ImGuiTableFlags[ImGuiTableFlags["None"] = 0] = "None";
    ImGuiTableFlags[ImGuiTableFlags["Resizable"] = 1] = "Resizable";
    ImGuiTableFlags[ImGuiTableFlags["Reorderable"] = 2] = "Reorderable";
    ImGuiTableFlags[ImGuiTableFlags["Hideable"] = 4] = "Hideable";
    ImGuiTableFlags[ImGuiTableFlags["Sortable"] = 8] = "Sortable";
    ImGuiTableFlags[ImGuiTableFlags["NoSavedSettings"] = 16] = "NoSavedSettings";
    ImGuiTableFlags[ImGuiTableFlags["ContextMenuInBody"] = 32] = "ContextMenuInBody";
    ImGuiTableFlags[ImGuiTableFlags["RowBg"] = 64] = "RowBg";
    ImGuiTableFlags[ImGuiTableFlags["BordersInnerH"] = 128] = "BordersInnerH";
    ImGuiTableFlags[ImGuiTableFlags["BordersOuterH"] = 256] = "BordersOuterH";
    ImGuiTableFlags[ImGuiTableFlags["BordersInnerV"] = 512] = "BordersInnerV";
    ImGuiTableFlags[ImGuiTableFlags["BordersOuterV"] = 1024] = "BordersOuterV";
    ImGuiTableFlags[ImGuiTableFlags["BordersH"] = 384] = "BordersH";
    ImGuiTableFlags[ImGuiTableFlags["BordersV"] = 1536] = "BordersV";
    ImGuiTableFlags[ImGuiTableFlags["BordersInner"] = 640] = "BordersInner";
    ImGuiTableFlags[ImGuiTableFlags["BordersOuter"] = 1280] = "BordersOuter";
    ImGuiTableFlags[ImGuiTableFlags["Borders"] = 1920] = "Borders";
    ImGuiTableFlags[ImGuiTableFlags["NoBordersInBody"] = 2048] = "NoBordersInBody";
    ImGuiTableFlags[ImGuiTableFlags["NoBordersInBodyUntilResize"] = 4096] = "NoBordersInBodyUntilResize";
    ImGuiTableFlags[ImGuiTableFlags["SizingFixedFit"] = 8192] = "SizingFixedFit";
    ImGuiTableFlags[ImGuiTableFlags["SizingFixedSame"] = 16384] = "SizingFixedSame";
    ImGuiTableFlags[ImGuiTableFlags["SizingStretchProp"] = 24576] = "SizingStretchProp";
    ImGuiTableFlags[ImGuiTableFlags["SizingStretchSame"] = 32768] = "SizingStretchSame";
    ImGuiTableFlags[ImGuiTableFlags["NoHostExtendX"] = 65536] = "NoHostExtendX";
    ImGuiTableFlags[ImGuiTableFlags["NoHostExtendY"] = 131072] = "NoHostExtendY";
    ImGuiTableFlags[ImGuiTableFlags["NoKeepColumnsVisible"] = 262144] = "NoKeepColumnsVisible";
    ImGuiTableFlags[ImGuiTableFlags["PreciseWidths"] = 524288] = "PreciseWidths";
    ImGuiTableFlags[ImGuiTableFlags["NoClip"] = 1048576] = "NoClip";
    ImGuiTableFlags[ImGuiTableFlags["PadOuterX"] = 2097152] = "PadOuterX";
    ImGuiTableFlags[ImGuiTableFlags["NoPadOuterX"] = 4194304] = "NoPadOuterX";
    ImGuiTableFlags[ImGuiTableFlags["NoPadInnerX"] = 8388608] = "NoPadInnerX";
    ImGuiTableFlags[ImGuiTableFlags["ScrollX"] = 16777216] = "ScrollX";
    ImGuiTableFlags[ImGuiTableFlags["ScrollY"] = 33554432] = "ScrollY";
    ImGuiTableFlags[ImGuiTableFlags["SortMulti"] = 67108864] = "SortMulti";
    ImGuiTableFlags[ImGuiTableFlags["SortTristate"] = 134217728] = "SortTristate";
    ImGuiTableFlags[ImGuiTableFlags["SizingMask_"] = 57344] = "SizingMask_";
})(ImGuiTableFlags || (ImGuiTableFlags = {}));
var ImGuiTableColumnFlags;
(function(ImGuiTableColumnFlags) {
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["None"] = 0] = "None";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["DefaultHide"] = 1] = "DefaultHide";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["DefaultSort"] = 2] = "DefaultSort";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["WidthStretch"] = 4] = "WidthStretch";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["WidthFixed"] = 8] = "WidthFixed";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoResize"] = 16] = "NoResize";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoReorder"] = 32] = "NoReorder";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoHide"] = 64] = "NoHide";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoClip"] = 128] = "NoClip";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoSort"] = 256] = "NoSort";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoSortAscending"] = 512] = "NoSortAscending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoSortDescending"] = 1024] = "NoSortDescending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoHeaderWidth"] = 2048] = "NoHeaderWidth";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["PreferSortAscending"] = 4096] = "PreferSortAscending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["PreferSortDescending"] = 8192] = "PreferSortDescending";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IndentEnable"] = 16384] = "IndentEnable";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IndentDisable"] = 32768] = "IndentDisable";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsEnabled"] = 1048576] = "IsEnabled";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsVisible"] = 2097152] = "IsVisible";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsSorted"] = 4194304] = "IsSorted";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IsHovered"] = 8388608] = "IsHovered";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["WidthMask_"] = 12] = "WidthMask_";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["IndentMask_"] = 49152] = "IndentMask_";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["StatusMask_"] = 15728640] = "StatusMask_";
    ImGuiTableColumnFlags[ImGuiTableColumnFlags["NoDirectResize_"] = 1073741824] = "NoDirectResize_";
})(ImGuiTableColumnFlags || (ImGuiTableColumnFlags = {}));
var ImGuiTableRowFlags;
(function(ImGuiTableRowFlags) {
    ImGuiTableRowFlags[ImGuiTableRowFlags["None"] = 0] = "None";
    ImGuiTableRowFlags[ImGuiTableRowFlags["Headers"] = 1] = "Headers";
})(ImGuiTableRowFlags || (ImGuiTableRowFlags = {}));
var ImGuiTableBgTarget;
(function(ImGuiTableBgTarget) {
    ImGuiTableBgTarget[ImGuiTableBgTarget["None"] = 0] = "None";
    ImGuiTableBgTarget[ImGuiTableBgTarget["RowBg0"] = 1] = "RowBg0";
    ImGuiTableBgTarget[ImGuiTableBgTarget["RowBg1"] = 2] = "RowBg1";
    ImGuiTableBgTarget[ImGuiTableBgTarget["CellBg"] = 3 // Set cell background color (top-most color)
    ] = "CellBg";
})(ImGuiTableBgTarget || (ImGuiTableBgTarget = {}));
var ImGuiFocusedFlags;
(function(ImGuiFocusedFlags) {
    ImGuiFocusedFlags[ImGuiFocusedFlags["None"] = 0] = "None";
    ImGuiFocusedFlags[ImGuiFocusedFlags["ChildWindows"] = 1] = "ChildWindows";
    ImGuiFocusedFlags[ImGuiFocusedFlags["RootWindow"] = 2] = "RootWindow";
    ImGuiFocusedFlags[ImGuiFocusedFlags["AnyWindow"] = 4] = "AnyWindow";
    ImGuiFocusedFlags[ImGuiFocusedFlags["RootAndChildWindows"] = 3] = "RootAndChildWindows";
})(ImGuiFocusedFlags || (ImGuiFocusedFlags = {}));
var ImGuiHoveredFlags;
(function(ImGuiHoveredFlags) {
    ImGuiHoveredFlags[ImGuiHoveredFlags["None"] = 0] = "None";
    ImGuiHoveredFlags[ImGuiHoveredFlags["ChildWindows"] = 1] = "ChildWindows";
    ImGuiHoveredFlags[ImGuiHoveredFlags["RootWindow"] = 2] = "RootWindow";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AnyWindow"] = 4] = "AnyWindow";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenBlockedByPopup"] = 8] = "AllowWhenBlockedByPopup";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenBlockedByActiveItem"] = 32] = "AllowWhenBlockedByActiveItem";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenOverlapped"] = 64] = "AllowWhenOverlapped";
    ImGuiHoveredFlags[ImGuiHoveredFlags["AllowWhenDisabled"] = 128] = "AllowWhenDisabled";
    ImGuiHoveredFlags[ImGuiHoveredFlags["RectOnly"] = 104] = "RectOnly";
    ImGuiHoveredFlags[ImGuiHoveredFlags["RootAndChildWindows"] = 3] = "RootAndChildWindows";
})(ImGuiHoveredFlags || (ImGuiHoveredFlags = {}));
var ImGuiDragDropFlags;
(function(ImGuiDragDropFlags) {
    ImGuiDragDropFlags[ImGuiDragDropFlags["None"] = 0] = "None";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceNoPreviewTooltip"] = 1] = "SourceNoPreviewTooltip";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceNoDisableHover"] = 2] = "SourceNoDisableHover";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceNoHoldToOpenOthers"] = 4] = "SourceNoHoldToOpenOthers";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceAllowNullID"] = 8] = "SourceAllowNullID";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceExtern"] = 16] = "SourceExtern";
    ImGuiDragDropFlags[ImGuiDragDropFlags["SourceAutoExpirePayload"] = 32] = "SourceAutoExpirePayload";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptBeforeDelivery"] = 1024] = "AcceptBeforeDelivery";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptNoDrawDefaultRect"] = 2048] = "AcceptNoDrawDefaultRect";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptNoPreviewTooltip"] = 4096] = "AcceptNoPreviewTooltip";
    ImGuiDragDropFlags[ImGuiDragDropFlags["AcceptPeekOnly"] = 3072] = "AcceptPeekOnly";
})(ImGuiDragDropFlags || (ImGuiDragDropFlags = {}));
var ImGuiDataType;
(function(ImGuiDataType) {
    ImGuiDataType[ImGuiDataType["S8"] = 0] = "S8";
    ImGuiDataType[ImGuiDataType["U8"] = 1] = "U8";
    ImGuiDataType[ImGuiDataType["S16"] = 2] = "S16";
    ImGuiDataType[ImGuiDataType["U16"] = 3] = "U16";
    ImGuiDataType[ImGuiDataType["S32"] = 4] = "S32";
    ImGuiDataType[ImGuiDataType["U32"] = 5] = "U32";
    ImGuiDataType[ImGuiDataType["S64"] = 6] = "S64";
    ImGuiDataType[ImGuiDataType["U64"] = 7] = "U64";
    ImGuiDataType[ImGuiDataType["Float"] = 8] = "Float";
    ImGuiDataType[ImGuiDataType["Double"] = 9] = "Double";
    ImGuiDataType[ImGuiDataType["COUNT"] = 10] = "COUNT";
})(ImGuiDataType || (ImGuiDataType = {}));
var ImGuiDir;
(function(ImGuiDir) {
    ImGuiDir[ImGuiDir["None"] = -1] = "None";
    ImGuiDir[ImGuiDir["Left"] = 0] = "Left";
    ImGuiDir[ImGuiDir["Right"] = 1] = "Right";
    ImGuiDir[ImGuiDir["Up"] = 2] = "Up";
    ImGuiDir[ImGuiDir["Down"] = 3] = "Down";
    ImGuiDir[ImGuiDir["COUNT"] = 4] = "COUNT";
})(ImGuiDir || (ImGuiDir = {}));
var ImGuiSortDirection;
(function(ImGuiSortDirection) {
    ImGuiSortDirection[ImGuiSortDirection["None"] = 0] = "None";
    ImGuiSortDirection[ImGuiSortDirection["Ascending"] = 1] = "Ascending";
    ImGuiSortDirection[ImGuiSortDirection["Descending"] = 2 // Descending = 9->0, Z->A etc.
    ] = "Descending";
})(ImGuiSortDirection || (ImGuiSortDirection = {}));
var ImGuiKey;
(function(ImGuiKey) {
    ImGuiKey[ImGuiKey["Tab"] = 0] = "Tab";
    ImGuiKey[ImGuiKey["LeftArrow"] = 1] = "LeftArrow";
    ImGuiKey[ImGuiKey["RightArrow"] = 2] = "RightArrow";
    ImGuiKey[ImGuiKey["UpArrow"] = 3] = "UpArrow";
    ImGuiKey[ImGuiKey["DownArrow"] = 4] = "DownArrow";
    ImGuiKey[ImGuiKey["PageUp"] = 5] = "PageUp";
    ImGuiKey[ImGuiKey["PageDown"] = 6] = "PageDown";
    ImGuiKey[ImGuiKey["Home"] = 7] = "Home";
    ImGuiKey[ImGuiKey["End"] = 8] = "End";
    ImGuiKey[ImGuiKey["Insert"] = 9] = "Insert";
    ImGuiKey[ImGuiKey["Delete"] = 10] = "Delete";
    ImGuiKey[ImGuiKey["Backspace"] = 11] = "Backspace";
    ImGuiKey[ImGuiKey["Space"] = 12] = "Space";
    ImGuiKey[ImGuiKey["Enter"] = 13] = "Enter";
    ImGuiKey[ImGuiKey["Escape"] = 14] = "Escape";
    ImGuiKey[ImGuiKey["KeyPadEnter"] = 15] = "KeyPadEnter";
    ImGuiKey[ImGuiKey["A"] = 16] = "A";
    ImGuiKey[ImGuiKey["C"] = 17] = "C";
    ImGuiKey[ImGuiKey["V"] = 18] = "V";
    ImGuiKey[ImGuiKey["X"] = 19] = "X";
    ImGuiKey[ImGuiKey["Y"] = 20] = "Y";
    ImGuiKey[ImGuiKey["Z"] = 21] = "Z";
    ImGuiKey[ImGuiKey["COUNT"] = 22] = "COUNT";
})(ImGuiKey || (ImGuiKey = {}));
var ImGuiKeyModFlags;
(function(ImGuiKeyModFlags) {
    ImGuiKeyModFlags[ImGuiKeyModFlags["None"] = 0] = "None";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Ctrl"] = 1] = "Ctrl";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Shift"] = 2] = "Shift";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Alt"] = 4] = "Alt";
    ImGuiKeyModFlags[ImGuiKeyModFlags["Super"] = 8] = "Super";
})(ImGuiKeyModFlags || (ImGuiKeyModFlags = {}));
var ImGuiNavInput;
(function(ImGuiNavInput) {
    ImGuiNavInput[ImGuiNavInput["Activate"] = 0] = "Activate";
    ImGuiNavInput[ImGuiNavInput["Cancel"] = 1] = "Cancel";
    ImGuiNavInput[ImGuiNavInput["Input"] = 2] = "Input";
    ImGuiNavInput[ImGuiNavInput["Menu"] = 3] = "Menu";
    ImGuiNavInput[ImGuiNavInput["DpadLeft"] = 4] = "DpadLeft";
    ImGuiNavInput[ImGuiNavInput["DpadRight"] = 5] = "DpadRight";
    ImGuiNavInput[ImGuiNavInput["DpadUp"] = 6] = "DpadUp";
    ImGuiNavInput[ImGuiNavInput["DpadDown"] = 7] = "DpadDown";
    ImGuiNavInput[ImGuiNavInput["LStickLeft"] = 8] = "LStickLeft";
    ImGuiNavInput[ImGuiNavInput["LStickRight"] = 9] = "LStickRight";
    ImGuiNavInput[ImGuiNavInput["LStickUp"] = 10] = "LStickUp";
    ImGuiNavInput[ImGuiNavInput["LStickDown"] = 11] = "LStickDown";
    ImGuiNavInput[ImGuiNavInput["FocusPrev"] = 12] = "FocusPrev";
    ImGuiNavInput[ImGuiNavInput["FocusNext"] = 13] = "FocusNext";
    ImGuiNavInput[ImGuiNavInput["TweakSlow"] = 14] = "TweakSlow";
    ImGuiNavInput[ImGuiNavInput["TweakFast"] = 15] = "TweakFast";
    ImGuiNavInput[ImGuiNavInput[// Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) may be directly reading from io.KeyDown[] instead of io.NavInputs[].
    "KeyMenu_"] = 16] = "KeyMenu_";
    ImGuiNavInput[ImGuiNavInput["KeyLeft_"] = 17] = "KeyLeft_";
    ImGuiNavInput[ImGuiNavInput["KeyRight_"] = 18] = "KeyRight_";
    ImGuiNavInput[ImGuiNavInput["KeyUp_"] = 19] = "KeyUp_";
    ImGuiNavInput[ImGuiNavInput["KeyDown_"] = 20] = "KeyDown_";
    ImGuiNavInput[ImGuiNavInput["COUNT"] = 21] = "COUNT";
    ImGuiNavInput[ImGuiNavInput["InternalStart_"] = 16] = "InternalStart_";
})(ImGuiNavInput || (ImGuiNavInput = {}));
var ImGuiConfigFlags;
(function(ImGuiConfigFlags) {
    ImGuiConfigFlags[ImGuiConfigFlags["None"] = 0] = "None";
    ImGuiConfigFlags[ImGuiConfigFlags["NavEnableKeyboard"] = 1] = "NavEnableKeyboard";
    ImGuiConfigFlags[ImGuiConfigFlags["NavEnableGamepad"] = 2] = "NavEnableGamepad";
    ImGuiConfigFlags[ImGuiConfigFlags["NavEnableSetMousePos"] = 4] = "NavEnableSetMousePos";
    ImGuiConfigFlags[ImGuiConfigFlags["NavNoCaptureKeyboard"] = 8] = "NavNoCaptureKeyboard";
    ImGuiConfigFlags[ImGuiConfigFlags["NoMouse"] = 16] = "NoMouse";
    ImGuiConfigFlags[ImGuiConfigFlags["NoMouseCursorChange"] = 32] = "NoMouseCursorChange";
    ImGuiConfigFlags[ImGuiConfigFlags["IsSRGB"] = 1048576] = "IsSRGB";
    ImGuiConfigFlags[ImGuiConfigFlags["IsTouchScreen"] = 2097152] = "IsTouchScreen";
})(ImGuiConfigFlags || (ImGuiConfigFlags = {}));
var ImGuiCol;
(function(ImGuiCol) {
    ImGuiCol[ImGuiCol["Text"] = 0] = "Text";
    ImGuiCol[ImGuiCol["TextDisabled"] = 1] = "TextDisabled";
    ImGuiCol[ImGuiCol["WindowBg"] = 2] = "WindowBg";
    ImGuiCol[ImGuiCol["ChildBg"] = 3] = "ChildBg";
    ImGuiCol[ImGuiCol["PopupBg"] = 4] = "PopupBg";
    ImGuiCol[ImGuiCol["Border"] = 5] = "Border";
    ImGuiCol[ImGuiCol["BorderShadow"] = 6] = "BorderShadow";
    ImGuiCol[ImGuiCol["FrameBg"] = 7] = "FrameBg";
    ImGuiCol[ImGuiCol["FrameBgHovered"] = 8] = "FrameBgHovered";
    ImGuiCol[ImGuiCol["FrameBgActive"] = 9] = "FrameBgActive";
    ImGuiCol[ImGuiCol["TitleBg"] = 10] = "TitleBg";
    ImGuiCol[ImGuiCol["TitleBgActive"] = 11] = "TitleBgActive";
    ImGuiCol[ImGuiCol["TitleBgCollapsed"] = 12] = "TitleBgCollapsed";
    ImGuiCol[ImGuiCol["MenuBarBg"] = 13] = "MenuBarBg";
    ImGuiCol[ImGuiCol["ScrollbarBg"] = 14] = "ScrollbarBg";
    ImGuiCol[ImGuiCol["ScrollbarGrab"] = 15] = "ScrollbarGrab";
    ImGuiCol[ImGuiCol["ScrollbarGrabHovered"] = 16] = "ScrollbarGrabHovered";
    ImGuiCol[ImGuiCol["ScrollbarGrabActive"] = 17] = "ScrollbarGrabActive";
    ImGuiCol[ImGuiCol["CheckMark"] = 18] = "CheckMark";
    ImGuiCol[ImGuiCol["SliderGrab"] = 19] = "SliderGrab";
    ImGuiCol[ImGuiCol["SliderGrabActive"] = 20] = "SliderGrabActive";
    ImGuiCol[ImGuiCol["Button"] = 21] = "Button";
    ImGuiCol[ImGuiCol["ButtonHovered"] = 22] = "ButtonHovered";
    ImGuiCol[ImGuiCol["ButtonActive"] = 23] = "ButtonActive";
    ImGuiCol[ImGuiCol["Header"] = 24] = "Header";
    ImGuiCol[ImGuiCol["HeaderHovered"] = 25] = "HeaderHovered";
    ImGuiCol[ImGuiCol["HeaderActive"] = 26] = "HeaderActive";
    ImGuiCol[ImGuiCol["Separator"] = 27] = "Separator";
    ImGuiCol[ImGuiCol["SeparatorHovered"] = 28] = "SeparatorHovered";
    ImGuiCol[ImGuiCol["SeparatorActive"] = 29] = "SeparatorActive";
    ImGuiCol[ImGuiCol["ResizeGrip"] = 30] = "ResizeGrip";
    ImGuiCol[ImGuiCol["ResizeGripHovered"] = 31] = "ResizeGripHovered";
    ImGuiCol[ImGuiCol["ResizeGripActive"] = 32] = "ResizeGripActive";
    ImGuiCol[ImGuiCol["Tab"] = 33] = "Tab";
    ImGuiCol[ImGuiCol["TabHovered"] = 34] = "TabHovered";
    ImGuiCol[ImGuiCol["TabActive"] = 35] = "TabActive";
    ImGuiCol[ImGuiCol["TabUnfocused"] = 36] = "TabUnfocused";
    ImGuiCol[ImGuiCol["TabUnfocusedActive"] = 37] = "TabUnfocusedActive";
    ImGuiCol[ImGuiCol["PlotLines"] = 38] = "PlotLines";
    ImGuiCol[ImGuiCol["PlotLinesHovered"] = 39] = "PlotLinesHovered";
    ImGuiCol[ImGuiCol["PlotHistogram"] = 40] = "PlotHistogram";
    ImGuiCol[ImGuiCol["PlotHistogramHovered"] = 41] = "PlotHistogramHovered";
    ImGuiCol[ImGuiCol["TableHeaderBg"] = 42] = "TableHeaderBg";
    ImGuiCol[ImGuiCol["TableBorderStrong"] = 43] = "TableBorderStrong";
    ImGuiCol[ImGuiCol["TableBorderLight"] = 44] = "TableBorderLight";
    ImGuiCol[ImGuiCol["TableRowBg"] = 45] = "TableRowBg";
    ImGuiCol[ImGuiCol["TableRowBgAlt"] = 46] = "TableRowBgAlt";
    ImGuiCol[ImGuiCol["TextSelectedBg"] = 47] = "TextSelectedBg";
    ImGuiCol[ImGuiCol["DragDropTarget"] = 48] = "DragDropTarget";
    ImGuiCol[ImGuiCol["NavHighlight"] = 49] = "NavHighlight";
    ImGuiCol[ImGuiCol["NavWindowingHighlight"] = 50] = "NavWindowingHighlight";
    ImGuiCol[ImGuiCol["NavWindowingDimBg"] = 51] = "NavWindowingDimBg";
    ImGuiCol[ImGuiCol["ModalWindowDimBg"] = 52] = "ModalWindowDimBg";
    ImGuiCol[ImGuiCol["COUNT"] = 53] = "COUNT";
})(ImGuiCol || (ImGuiCol = {}));
var ImGuiStyleVar;
(function(ImGuiStyleVar) {
    ImGuiStyleVar[ImGuiStyleVar["Alpha"] = 0] = "Alpha";
    ImGuiStyleVar[ImGuiStyleVar["WindowPadding"] = 1] = "WindowPadding";
    ImGuiStyleVar[ImGuiStyleVar["WindowRounding"] = 2] = "WindowRounding";
    ImGuiStyleVar[ImGuiStyleVar["WindowBorderSize"] = 3] = "WindowBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["WindowMinSize"] = 4] = "WindowMinSize";
    ImGuiStyleVar[ImGuiStyleVar["WindowTitleAlign"] = 5] = "WindowTitleAlign";
    ImGuiStyleVar[ImGuiStyleVar["ChildRounding"] = 6] = "ChildRounding";
    ImGuiStyleVar[ImGuiStyleVar["ChildBorderSize"] = 7] = "ChildBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["PopupRounding"] = 8] = "PopupRounding";
    ImGuiStyleVar[ImGuiStyleVar["PopupBorderSize"] = 9] = "PopupBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["FramePadding"] = 10] = "FramePadding";
    ImGuiStyleVar[ImGuiStyleVar["FrameRounding"] = 11] = "FrameRounding";
    ImGuiStyleVar[ImGuiStyleVar["FrameBorderSize"] = 12] = "FrameBorderSize";
    ImGuiStyleVar[ImGuiStyleVar["ItemSpacing"] = 13] = "ItemSpacing";
    ImGuiStyleVar[ImGuiStyleVar["ItemInnerSpacing"] = 14] = "ItemInnerSpacing";
    ImGuiStyleVar[ImGuiStyleVar["IndentSpacing"] = 15] = "IndentSpacing";
    ImGuiStyleVar[ImGuiStyleVar["CellPadding"] = 16] = "CellPadding";
    ImGuiStyleVar[ImGuiStyleVar["ScrollbarSize"] = 17] = "ScrollbarSize";
    ImGuiStyleVar[ImGuiStyleVar["ScrollbarRounding"] = 18] = "ScrollbarRounding";
    ImGuiStyleVar[ImGuiStyleVar["GrabMinSize"] = 19] = "GrabMinSize";
    ImGuiStyleVar[ImGuiStyleVar["GrabRounding"] = 20] = "GrabRounding";
    ImGuiStyleVar[ImGuiStyleVar["TabRounding"] = 21] = "TabRounding";
    ImGuiStyleVar[ImGuiStyleVar["ButtonTextAlign"] = 22] = "ButtonTextAlign";
    ImGuiStyleVar[ImGuiStyleVar["SelectableTextAlign"] = 23] = "SelectableTextAlign";
    ImGuiStyleVar[ImGuiStyleVar["COUNT"] = 24] = "COUNT";
})(ImGuiStyleVar || (ImGuiStyleVar = {}));
var ImGuiBackendFlags;
(function(ImGuiBackendFlags) {
    ImGuiBackendFlags[ImGuiBackendFlags["None"] = 0] = "None";
    ImGuiBackendFlags[ImGuiBackendFlags["HasGamepad"] = 1] = "HasGamepad";
    ImGuiBackendFlags[ImGuiBackendFlags["HasMouseCursors"] = 2] = "HasMouseCursors";
    ImGuiBackendFlags[ImGuiBackendFlags["HasSetMousePos"] = 4] = "HasSetMousePos";
    ImGuiBackendFlags[ImGuiBackendFlags["RendererHasVtxOffset"] = 8] = "RendererHasVtxOffset";
})(ImGuiBackendFlags || (ImGuiBackendFlags = {}));
var ImGuiButtonFlags;
(function(ImGuiButtonFlags) {
    ImGuiButtonFlags[ImGuiButtonFlags["None"] = 0] = "None";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonLeft"] = 1] = "MouseButtonLeft";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonRight"] = 2] = "MouseButtonRight";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonMiddle"] = 4] = "MouseButtonMiddle";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonMask_"] = 7] = "MouseButtonMask_";
    ImGuiButtonFlags[ImGuiButtonFlags["MouseButtonDefault_"] = 1] = "MouseButtonDefault_";
})(ImGuiButtonFlags || (ImGuiButtonFlags = {}));
var ImGuiColorEditFlags;
(function(ImGuiColorEditFlags) {
    ImGuiColorEditFlags[ImGuiColorEditFlags["None"] = 0] = "None";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoAlpha"] = 2] = "NoAlpha";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoPicker"] = 4] = "NoPicker";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoOptions"] = 8] = "NoOptions";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoSmallPreview"] = 16] = "NoSmallPreview";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoInputs"] = 32] = "NoInputs";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoTooltip"] = 64] = "NoTooltip";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoLabel"] = 128] = "NoLabel";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoSidePreview"] = 256] = "NoSidePreview";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoDragDrop"] = 512] = "NoDragDrop";
    ImGuiColorEditFlags[ImGuiColorEditFlags["NoBorder"] = 1024] = "NoBorder";
    ImGuiColorEditFlags[ImGuiColorEditFlags["AlphaBar"] = 65536] = "AlphaBar";
    ImGuiColorEditFlags[ImGuiColorEditFlags["AlphaPreview"] = 131072] = "AlphaPreview";
    ImGuiColorEditFlags[ImGuiColorEditFlags["AlphaPreviewHalf"] = 262144] = "AlphaPreviewHalf";
    ImGuiColorEditFlags[ImGuiColorEditFlags["HDR"] = 524288] = "HDR";
    ImGuiColorEditFlags[ImGuiColorEditFlags["DisplayRGB"] = 1048576] = "DisplayRGB";
    ImGuiColorEditFlags[ImGuiColorEditFlags["DisplayHSV"] = 2097152] = "DisplayHSV";
    ImGuiColorEditFlags[ImGuiColorEditFlags["DisplayHex"] = 4194304] = "DisplayHex";
    ImGuiColorEditFlags[ImGuiColorEditFlags["Uint8"] = 8388608] = "Uint8";
    ImGuiColorEditFlags[ImGuiColorEditFlags["Float"] = 16777216] = "Float";
    ImGuiColorEditFlags[ImGuiColorEditFlags["PickerHueBar"] = 33554432] = "PickerHueBar";
    ImGuiColorEditFlags[ImGuiColorEditFlags["PickerHueWheel"] = 67108864] = "PickerHueWheel";
    ImGuiColorEditFlags[ImGuiColorEditFlags["InputRGB"] = 134217728] = "InputRGB";
    ImGuiColorEditFlags[ImGuiColorEditFlags["InputHSV"] = 268435456] = "InputHSV";
    ImGuiColorEditFlags[ImGuiColorEditFlags[// override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
    "_OptionsDefault"] = 177209344] = "_OptionsDefault";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_DisplayMask"] = 7340032] = "_DisplayMask";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_DataTypeMask"] = 25165824] = "_DataTypeMask";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_PickerMask"] = 100663296] = "_PickerMask";
    ImGuiColorEditFlags[ImGuiColorEditFlags["_InputMask"] = 402653184] = "_InputMask";
})(ImGuiColorEditFlags || (ImGuiColorEditFlags = {}));
var ImGuiSliderFlags;
(function(ImGuiSliderFlags) {
    ImGuiSliderFlags[ImGuiSliderFlags["None"] = 0] = "None";
    ImGuiSliderFlags[ImGuiSliderFlags["AlwaysClamp"] = 16] = "AlwaysClamp";
    ImGuiSliderFlags[ImGuiSliderFlags["Logarithmic"] = 32] = "Logarithmic";
    ImGuiSliderFlags[ImGuiSliderFlags["NoRoundToFormat"] = 64] = "NoRoundToFormat";
    ImGuiSliderFlags[ImGuiSliderFlags["NoInput"] = 128] = "NoInput";
    ImGuiSliderFlags[ImGuiSliderFlags["InvalidMask_"] = 0x7000000f // [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.
    ] = "InvalidMask_";
})(ImGuiSliderFlags || (ImGuiSliderFlags = {}));
var ImGuiMouseButton;
(function(ImGuiMouseButton) {
    ImGuiMouseButton[ImGuiMouseButton["Left"] = 0] = "Left";
    ImGuiMouseButton[ImGuiMouseButton["Right"] = 1] = "Right";
    ImGuiMouseButton[ImGuiMouseButton["Middle"] = 2] = "Middle";
    ImGuiMouseButton[ImGuiMouseButton["COUNT"] = 5] = "COUNT";
})(ImGuiMouseButton || (ImGuiMouseButton = {}));
var ImGuiMouseCursor;
(function(ImGuiMouseCursor) {
    ImGuiMouseCursor[ImGuiMouseCursor["None"] = -1] = "None";
    ImGuiMouseCursor[ImGuiMouseCursor["Arrow"] = 0] = "Arrow";
    ImGuiMouseCursor[ImGuiMouseCursor["TextInput"] = 1] = "TextInput";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeAll"] = 2] = "ResizeAll";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeNS"] = 3] = "ResizeNS";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeEW"] = 4] = "ResizeEW";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeNESW"] = 5] = "ResizeNESW";
    ImGuiMouseCursor[ImGuiMouseCursor["ResizeNWSE"] = 6] = "ResizeNWSE";
    ImGuiMouseCursor[ImGuiMouseCursor["Hand"] = 7] = "Hand";
    ImGuiMouseCursor[ImGuiMouseCursor["NotAllowed"] = 8] = "NotAllowed";
    ImGuiMouseCursor[ImGuiMouseCursor["COUNT"] = 9] = "COUNT";
})(ImGuiMouseCursor || (ImGuiMouseCursor = {}));
var ImGuiCond;
(function(ImGuiCond) {
    ImGuiCond[ImGuiCond["None"] = 0] = "None";
    ImGuiCond[ImGuiCond["Always"] = 1] = "Always";
    ImGuiCond[ImGuiCond["Once"] = 2] = "Once";
    ImGuiCond[ImGuiCond["FirstUseEver"] = 4] = "FirstUseEver";
    ImGuiCond[ImGuiCond["Appearing"] = 8] = "Appearing";
})(ImGuiCond || (ImGuiCond = {}));
var ImDrawCornerFlags;
(function(ImDrawCornerFlags) {
    ImDrawCornerFlags[ImDrawCornerFlags["None"] = 0] = "None";
    ImDrawCornerFlags[ImDrawCornerFlags["TopLeft"] = 1] = "TopLeft";
    ImDrawCornerFlags[ImDrawCornerFlags["TopRight"] = 2] = "TopRight";
    ImDrawCornerFlags[ImDrawCornerFlags["BotLeft"] = 4] = "BotLeft";
    ImDrawCornerFlags[ImDrawCornerFlags["BotRight"] = 8] = "BotRight";
    ImDrawCornerFlags[ImDrawCornerFlags["Top"] = 3] = "Top";
    ImDrawCornerFlags[ImDrawCornerFlags["Bot"] = 12] = "Bot";
    ImDrawCornerFlags[ImDrawCornerFlags["Left"] = 5] = "Left";
    ImDrawCornerFlags[ImDrawCornerFlags["Right"] = 10] = "Right";
    ImDrawCornerFlags[ImDrawCornerFlags["All"] = 0xf // In your function calls you may use ~0 (= all bits sets) instead of All, as a convenience
    ] = "All";
})(ImDrawCornerFlags || (ImDrawCornerFlags = {}));
var ImDrawListFlags;
(function(ImDrawListFlags) {
    ImDrawListFlags[ImDrawListFlags["None"] = 0] = "None";
    ImDrawListFlags[ImDrawListFlags["AntiAliasedLines"] = 1] = "AntiAliasedLines";
    ImDrawListFlags[ImDrawListFlags["AntiAliasedLinesUseTex"] = 2] = "AntiAliasedLinesUseTex";
    ImDrawListFlags[ImDrawListFlags["AntiAliasedFill"] = 4] = "AntiAliasedFill";
    ImDrawListFlags[ImDrawListFlags["AllowVtxOffset"] = 8] = "AllowVtxOffset";
})(ImDrawListFlags || (ImDrawListFlags = {}));
class ImVec2 {
    x;
    y;
    static ZERO = new ImVec2(0.0, 0.0);
    static UNIT = new ImVec2(1.0, 1.0);
    static UNIT_X = new ImVec2(1.0, 0.0);
    static UNIT_Y = new ImVec2(0.0, 1.0);
    constructor(x = 0.0, y = 0.0){
        this.x = x;
        this.y = y;
    }
    Set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    Copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }
    Equals(other) {
        if (this.x !== other.x) {
            return false;
        }
        if (this.y !== other.y) {
            return false;
        }
        return true;
    }
}
class ImVec4 {
    x;
    y;
    z;
    w;
    static ZERO = new ImVec4(0.0, 0.0, 0.0, 0.0);
    static UNIT = new ImVec4(1.0, 1.0, 1.0, 1.0);
    static UNIT_X = new ImVec4(1.0, 0.0, 0.0, 0.0);
    static UNIT_Y = new ImVec4(0.0, 1.0, 0.0, 0.0);
    static UNIT_Z = new ImVec4(0.0, 0.0, 1.0, 0.0);
    static UNIT_W = new ImVec4(0.0, 0.0, 0.0, 1.0);
    static BLACK = new ImVec4(0.0, 0.0, 0.0, 1.0);
    static WHITE = new ImVec4(1.0, 1.0, 1.0, 1.0);
    constructor(x = 0.0, y = 0.0, z = 0.0, w = 1.0){
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    Set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    Copy(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.z;
        this.w = other.w;
        return this;
    }
    Equals(other) {
        if (this.x !== other.x) {
            return false;
        }
        if (this.y !== other.y) {
            return false;
        }
        if (this.z !== other.z) {
            return false;
        }
        if (this.w !== other.w) {
            return false;
        }
        return true;
    }
}
class ImVector extends Array {
    get Size() {
        return this.length;
    }
    Data = this;
    empty() {
        return this.length === 0;
    }
    clear() {
        this.length = 0;
    }
    pop_back() {
        return this.pop();
    }
    push_back(value) {
        this.push(value);
    }
    front() {
        IM_ASSERT(this.Size > 0);
        return this.Data[0];
    }
    back() {
        IM_ASSERT(this.Size > 0);
        return this.Data[this.Size - 1];
    }
    size() {
        return this.Size;
    }
    resize(new_size, v) {
        if (v) {
            for(let index = this.length; index < new_size; ++index){
                this[index] = v(index);
            }
        } else {
            this.length = new_size;
        }
    }
    contains(value) {
        return this.includes(value);
    }
    find_erase_unsorted(value) {
        const index = this.indexOf(value);
        if (index !== -1) {
            this.splice(index, 1);
        }
    }
}
class ImDrawCmd {
    native;
    constructor(native){
        this.native = native;
        this.UserCallback = null;
        this.UserCallbackData = null;
    }
    // unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    get ElemCount() {
        return this.native.ElemCount;
    }
    // ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2)
    get ClipRect() {
        return this.native.ClipRect;
    }
    // ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
    get TextureId() {
        return ImGuiContext.getTexture(this.native.TextureId);
    }
    // unsigned int    VtxOffset;              // Start offset in vertex buffer. Pre-1.71 or without ImGuiBackendFlags_RendererHasVtxOffset: always 0. With ImGuiBackendFlags_RendererHasVtxOffset: may be >0 to support meshes larger than 64K vertices with 16-bits indices.
    get VtxOffset() {
        return this.native.VtxOffset;
    }
    // unsigned int    IdxOffset;              // Start offset in index buffer. Always equal to sum of ElemCount drawn so far.
    get IdxOffset() {
        return this.native.IdxOffset;
    }
    // ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    UserCallback;
    // void*           UserCallbackData;       // The draw callback code can access this.
    UserCallbackData;
}
class ImDrawList {
    native;
    constructor(native){
        this.native = native;
    }
    IterateDrawCmds(callback) {
        this.native.IterateDrawCmds((draw_cmd, ElemStart)=>{
            callback(new ImDrawCmd(draw_cmd), ElemStart);
        });
    }
    // This is what you have to render
    // ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    // ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
    get IdxBuffer() {
        return this.native.IdxBuffer;
    }
    // ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
    get VtxBuffer() {
        return this.native.VtxBuffer;
    }
    // ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
    get Flags() {
        return this.native.Flags;
    }
    set Flags(value) {
        this.native.Flags = value;
    }
    // [Internal, used while building lists]
    // unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
    // const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    // const char*             _OwnerName;         // Pointer to owner window's name for debugging
    // ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    // ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    // ImVector<ImVec4>        _ClipRectStack;     // [Internal]
    // ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
    // ImVector<ImVec2>        _Path;              // [Internal] current path building
    // int                     _ChannelsCurrent;   // [Internal] current channel number (0)
    // int                     _ChannelsCount;     // [Internal] number of active channels (1+)
    // ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)
    // ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
    // ~ImDrawList() { ClearFreeMemory(); }
    // IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect = false) {
        this.native.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    }
    // IMGUI_API void  PushClipRectFullScreen();
    PushClipRectFullScreen() {
        this.native.PushClipRectFullScreen();
    }
    // IMGUI_API void  PopClipRect();
    PopClipRect() {
        this.native.PopClipRect();
    }
    // IMGUI_API void  PushTextureID(ImTextureID texture_id);
    PushTextureID(texture_id) {
        this.native.PushTextureID(ImGuiContext.setTexture(texture_id));
    }
    // IMGUI_API void  PopTextureID();
    PopTextureID() {
        this.native.PopTextureID();
    }
    // inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    GetClipRectMin(out = new ImVec2()) {
        return this.native.GetClipRectMin(out);
    }
    // inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }
    GetClipRectMax(out = new ImVec2()) {
        return this.native.GetClipRectMax(out);
    }
    // Primitives
    // IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
    AddLine(a, b, col, thickness = 1.0) {
        this.native.AddLine(a, b, col, thickness);
    }
    // IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round
    AddRect(a, b, col, rounding = 0.0, rounding_corners_flags = ImDrawCornerFlags.All, thickness = 1.0) {
        this.native.AddRect(a, b, col, rounding, rounding_corners_flags, thickness);
    }
    // IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right
    AddRectFilled(a, b, col, rounding = 0.0, rounding_corners_flags = ImDrawCornerFlags.All) {
        this.native.AddRectFilled(a, b, col, rounding, rounding_corners_flags);
    }
    // IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    AddRectFilledMultiColor(a, b, col_upr_left, col_upr_right, col_bot_right, col_bot_left) {
        this.native.AddRectFilledMultiColor(a, b, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
    }
    // IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
    AddQuad(a, b, c, d, col, thickness = 1.0) {
        this.native.AddQuad(a, b, c, d, col, thickness);
    }
    // IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
    AddQuadFilled(a, b, c, d, col) {
        this.native.AddQuadFilled(a, b, c, d, col);
    }
    // IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
    AddTriangle(a, b, c, col, thickness = 1.0) {
        this.native.AddTriangle(a, b, c, col, thickness);
    }
    // IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
    AddTriangleFilled(a, b, c, col) {
        this.native.AddTriangleFilled(a, b, c, col);
    }
    // IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
    AddCircle(centre, radius, col, num_segments = 12, thickness = 1.0) {
        this.native.AddCircle(centre, radius, col, num_segments, thickness);
    }
    // IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
    AddCircleFilled(centre, radius, col, num_segments = 12) {
        this.native.AddCircleFilled(centre, radius, col, num_segments);
    }
    // IMGUI_API void  AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
    AddNgon(centre, radius, col, num_segments, thickness = 1.0) {
        this.native.AddNgon(centre, radius, col, num_segments, thickness);
    }
    // IMGUI_API void  AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
    AddNgonFilled(centre, radius, col, num_segments) {
        this.native.AddNgonFilled(centre, radius, col, num_segments);
    }
    AddText(...args) {
        if (args[0] instanceof ImFont) {
            const font = args[0];
            const font_size = args[1];
            const pos = args[2];
            const col = args[3];
            const text_begin = args[4];
            const text_end = args[5] || null;
            const wrap_width = args[6] ? args[6] : 0.0;
            const cpu_fine_clip_rect = args[7] || null;
            this.native.AddText_B(font.native, font_size, pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin, wrap_width, cpu_fine_clip_rect);
        } else {
            const pos = args[0];
            const col = args[1];
            const text_begin = args[2];
            const text_end = args[3] || null;
            this.native.AddText_A(pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin);
        }
    }
    // IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
    AddPolyline(points, num_points, col, closed, thickness) {
        this.native.AddPolyline(points, num_points, col, closed, thickness);
    }
    // IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);
    AddConvexPolyFilled(points, num_points, col) {
        this.native.AddConvexPolyFilled(points, num_points, col);
    }
    // IMGUI_API void  AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0); // Cubic Bezier (4 control points)
    AddBezierCubic(p1, p2, p3, p4, col, thickness = 1.0, num_segments = 0) {
        this.native.AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments);
    }
    // IMGUI_API void  AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);               // Quadratic Bezier (3 control points)
    AddBezierQuadratic(p1, p2, p3, col, thickness = 1.0, num_segments = 0) {
        this.native.AddBezierQuadratic(p1, p2, p3, col, thickness, num_segments);
    }
    // IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);
    AddImage(user_texture_id, a, b, uv_a = ImVec2.ZERO, uv_b = ImVec2.UNIT, col = 0xffffffff) {
        this.native.AddImage(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col);
    }
    // IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);
    AddImageQuad(user_texture_id, a, b, c, d, uv_a = ImVec2.ZERO, uv_b = ImVec2.UNIT_X, uv_c = ImVec2.UNIT, uv_d = ImVec2.UNIT_Y, col = 0xffffffff) {
        this.native.AddImageQuad(ImGuiContext.setTexture(user_texture_id), a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
    }
    // IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
    AddImageRounded(user_texture_id, a, b, uv_a, uv_b, col, rounding, rounding_corners = ImDrawCornerFlags.All) {
        this.native.AddImageRounded(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col, rounding, rounding_corners);
    }
    // Stateful path API, add points then finish with PathFill() or PathStroke()
    // inline    void  PathClear()                                                 { _Path.resize(0); }
    PathClear() {
        this.native.PathClear();
    }
    // inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    PathLineTo(pos) {
        this.native.PathLineTo(pos);
    }
    // inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
    PathLineToMergeDuplicate(pos) {
        this.native.PathLineToMergeDuplicate(pos);
    }
    // inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }
    PathFillConvex(col) {
        this.native.PathFillConvex(col);
    }
    // inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }
    PathStroke(col, closed, thickness = 1.0) {
        this.native.PathStroke(col, closed, thickness);
    }
    // IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
    PathArcTo(centre, radius, a_min, a_max, num_segments = 10) {
        this.native.PathArcTo(centre, radius, a_min, a_max, num_segments);
    }
    // IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                // Use precomputed angles for a 12 steps circle
    PathArcToFast(centre, radius, a_min_of_12, a_max_of_12) {
        this.native.PathArcToFast(centre, radius, a_min_of_12, a_max_of_12);
    }
    // IMGUI_API void  PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0);  // Cubic Bezier (4 control points)
    PathBezierCubicCurveTo(p2, p3, p4, num_segments = 0) {
        this.native.PathBezierCubicCurveTo(p2, p3, p4, num_segments);
    }
    // IMGUI_API void  PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);                // Quadratic Bezier (3 control points)
    PathBezierQuadraticCurveTo(p2, p3, num_segments = 0) {
        this.native.PathBezierQuadraticCurveTo(p2, p3, num_segments);
    }
    // IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);
    PathRect(rect_min, rect_max, rounding = 0.0, rounding_corners_flags = ImDrawCornerFlags.All) {
        this.native.PathRect(rect_min, rect_max, rounding, rounding_corners_flags);
    }
    // Channels
    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
    // IMGUI_API void  ChannelsSplit(int channels_count);
    ChannelsSplit(channels_count) {
        this.native.ChannelsSplit(channels_count);
    }
    // IMGUI_API void  ChannelsMerge();
    ChannelsMerge() {
        this.native.ChannelsMerge();
    }
    // IMGUI_API void  ChannelsSetCurrent(int channel_index);
    ChannelsSetCurrent(channel_index) {
        this.native.ChannelsSetCurrent(channel_index);
    }
    // Advanced
    // IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
    AddCallback(callback, callback_data) {
        const _callback = (parent_list, draw_cmd)=>{
            callback(new ImDrawList(parent_list), new ImDrawCmd(draw_cmd));
        };
        this.native.AddCallback(_callback, callback_data);
    }
    // IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
    AddDrawCmd() {
        this.native.AddDrawCmd();
    }
    // Internal helpers
    // NB: all primitives needs to be reserved via PrimReserve() beforehand!
    // IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
    PrimReserve(idx_count, vtx_count) {
        this.native.PrimReserve(idx_count, vtx_count);
    }
    // IMGUI_API void  PrimUnreserve(int idx_count, int vtx_count);
    PrimUnreserve(idx_count, vtx_count) {
        this.native.PrimUnreserve(idx_count, vtx_count);
    }
    // IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
    PrimRect(a, b, col) {
        this.native.PrimRect(a, b, col);
    }
    // IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    PrimRectUV(a, b, uv_a, uv_b, col) {
        this.native.PrimRectUV(a, b, uv_a, uv_b, col);
    }
    // IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col) {
        this.native.PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
    }
    // inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    PrimWriteVtx(pos, uv, col) {
        this.native.PrimWriteVtx(pos, uv, col);
    }
    // inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
    PrimWriteIdx(idx) {
        this.native.PrimWriteIdx(idx);
    }
    // inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
    PrimVtx(pos, uv, col) {
        this.native.PrimVtx(pos, uv, col);
    }
}
class ImDrawData {
    native;
    constructor(native){
        this.native = native;
    }
    IterateDrawLists(callback) {
        this.native.IterateDrawLists((draw_list)=>{
            callback(new ImDrawList(draw_list));
        });
    }
    // bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
    get Valid() {
        return this.native.Valid;
    }
    // ImDrawList**    CmdLists;
    // int             CmdListsCount;
    get CmdListsCount() {
        return this.native.CmdListsCount;
    }
    // int             TotalIdxCount;          // For convenience, sum of all cmd_lists idx_buffer.Size
    get TotalIdxCount() {
        return this.native.TotalIdxCount;
    }
    // int             TotalVtxCount;          // For convenience, sum of all cmd_lists vtx_buffer.Size
    get TotalVtxCount() {
        return this.native.TotalVtxCount;
    }
    // ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
    get DisplayPos() {
        return this.native.DisplayPos;
    }
    // ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
    get DisplaySize() {
        return this.native.DisplaySize;
    }
    // ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
    get FramebufferScale() {
        return this.native.FramebufferScale;
    }
    // Functions
    // ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }
    // IMGUI_API void DeIndexAllBuffers();               // For backward compatibility or convenience: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
    DeIndexAllBuffers() {
        this.native.DeIndexAllBuffers();
    }
    // IMGUI_API void ScaleClipRects(const ImVec2& fb_scale);  // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
    ScaleClipRects(fb_scale) {
        this.native.ScaleClipRects(fb_scale);
    }
}
class script_ImFontConfig {
    // void*           FontData;                   //          // TTF/OTF data
    // int             FontDataSize;               //          // TTF/OTF data size
    FontData = null;
    // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    FontDataOwnedByAtlas = true;
    // int             FontNo;                     // 0        // Index of font within TTF/OTF file
    FontNo = 0;
    // float           SizePixels;                 //          // Size in pixels for rasterizer.
    SizePixels = 0;
    // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    OversampleH = 3;
    OversampleV = 1;
    // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    PixelSnapH = false;
    // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    GlyphExtraSpacing = new ImVec2(0, 0);
    // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
    GlyphOffset = new ImVec2(0, 0);
    // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    GlyphRanges = null;
    // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    GlyphMinAdvanceX = 0;
    // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
    GlyphMaxAdvanceX = Number.MAX_VALUE;
    // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    MergeMode = false;
    // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    RasterizerFlags = 0;
    // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
    RasterizerMultiply = 1.0;
    // ImWchar         EllipsisChar;           // -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
    EllipsisChar = -1;
    // [Internal]
    // char            Name[32];                               // Name (strictly to ease debugging)
    Name = '';
    // ImFont*         DstFont;
    DstFont = null;
}
class ImFontConfig {
    internal;
    constructor(internal = new script_ImFontConfig()){
        this.internal = internal;
    }
    // void*           FontData;                   //          // TTF/OTF data
    // int             FontDataSize;               //          // TTF/OTF data size
    get FontData() {
        return this.internal.FontData;
    }
    // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    get FontDataOwnedByAtlas() {
        return this.internal.FontDataOwnedByAtlas;
    }
    // int             FontNo;                     // 0        // Index of font within TTF/OTF file
    get FontNo() {
        return this.internal.FontNo;
    }
    // float           SizePixels;                 //          // Size in pixels for rasterizer.
    get SizePixels() {
        return this.internal.SizePixels;
    }
    // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    get OversampleH() {
        return this.internal.OversampleH;
    }
    get OversampleV() {
        return this.internal.OversampleV;
    }
    // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    get PixelSnapH() {
        return this.internal.PixelSnapH;
    }
    // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    get GlyphExtraSpacing() {
        return this.internal.GlyphExtraSpacing;
    }
    // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
    get GlyphOffset() {
        return this.internal.GlyphOffset;
    }
    // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    get GlyphRanges() {
        return this.internal.GlyphRanges;
    }
    // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    get GlyphMinAdvanceX() {
        return this.internal.GlyphMinAdvanceX;
    }
    // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
    get GlyphMaxAdvanceX() {
        return this.internal.GlyphMaxAdvanceX;
    }
    // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    get MergeMode() {
        return this.internal.MergeMode;
    }
    // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    get RasterizerFlags() {
        return this.internal.RasterizerFlags;
    }
    // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
    get RasterizerMultiply() {
        return this.internal.RasterizerMultiply;
    }
    // [Internal]
    // char            Name[32];                               // Name (strictly to ease debugging)
    get Name() {
        return this.internal.Name;
    }
    set Name(value) {
        this.internal.Name = value;
    }
    // ImFont*         DstFont;
    get DstFont() {
        const font = this.internal.DstFont;
        return font && new ImFont(font);
    }
}
// struct ImFontGlyph
class script_ImFontGlyph {
    // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
    Codepoint = 0;
    // unsigned int    Visible : 1;        // Flag to allow early out when rendering
    Visible = false;
    // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    AdvanceX = 0.0;
    // float           X0, Y0, X1, Y1;     // Glyph corners
    X0 = 0.0;
    Y0 = 0.0;
    X1 = 1.0;
    Y1 = 1.0;
    // float           U0, V0, U1, V1;     // Texture coordinates
    U0 = 0.0;
    V0 = 0.0;
    U1 = 1.0;
    V1 = 1.0;
    TexID = null;
    Char = 0;
}
class ImFontGlyph {
    internal;
    constructor(internal = new script_ImFontGlyph()){
        this.internal = internal;
    }
    // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
    get Codepoint() {
        return this.internal.Codepoint;
    }
    // unsigned int    Visible : 1;        // Flag to allow early out when rendering
    get Visible() {
        return this.internal.Visible;
    }
    // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    get AdvanceX() {
        return this.internal.AdvanceX;
    }
    set AdvanceX(v) {
        this.internal.AdvanceX = v;
    }
    // float           X0, Y0, X1, Y1;     // Glyph corners
    get X0() {
        return this.internal.X0;
    }
    set X0(v) {
        this.internal.X0 = v;
    }
    get Y0() {
        return this.internal.Y0;
    }
    set Y0(v) {
        this.internal.Y0 = v;
    }
    get X1() {
        return this.internal.X1;
    }
    set X1(v) {
        this.internal.X1 = v;
    }
    get Y1() {
        return this.internal.Y1;
    }
    set Y1(v) {
        this.internal.Y1 = v;
    }
    // float           U0, V0, U1, V1;     // Texture coordinates
    get U0() {
        return this.internal.U0;
    }
    set U0(v) {
        this.internal.U0 = v;
    }
    get V0() {
        return this.internal.V0;
    }
    set V0(v) {
        this.internal.V0 = v;
    }
    get U1() {
        return this.internal.U1;
    }
    set U1(v) {
        this.internal.U1 = v;
    }
    get V1() {
        return this.internal.V1;
    }
    set V1(v) {
        this.internal.V1 = v;
    }
    get TexID() {
        return this.internal.TexID;
    }
    get TextureID() {
        return ImGuiContext.getTexture(this.internal.TexID);
    }
    set TextureID(v) {
        this.internal.TexID = ImGuiContext.setTexture(v);
    }
    get Char() {
        return this.internal.Char;
    }
}
var ImFontAtlasFlags;
(function(ImFontAtlasFlags) {
    ImFontAtlasFlags[ImFontAtlasFlags["None"] = 0] = "None";
    ImFontAtlasFlags[ImFontAtlasFlags["NoPowerOfTwoHeight"] = 1] = "NoPowerOfTwoHeight";
    ImFontAtlasFlags[ImFontAtlasFlags["NoMouseCursors"] = 2] = "NoMouseCursors";
    ImFontAtlasFlags[ImFontAtlasFlags["NoBakedLines"] = 4] = "NoBakedLines";
})(ImFontAtlasFlags || (ImFontAtlasFlags = {}));
class ImFontAtlas {
    native;
    constructor(native){
        this.native = native;
        this._Fonts = null;
    }
    // IMGUI_API ImFontAtlas();
    // IMGUI_API ~ImFontAtlas();
    // IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
    // IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
    AddFontDefault(font_cfg = null) {
        return new ImFont(this.native.AddFontDefault(font_cfg));
    }
    // IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
    // IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after Build(). Set font_cfg->FontDataOwnedByAtlas to false to keep ownership.
    AddFontFromMemoryTTF(data, size_pixels, font_cfg = null, glyph_ranges = null) {
        return new ImFont(this.native.AddFontFromMemoryTTF(new Uint8Array(data), size_pixels, font_cfg && font_cfg.internal, glyph_ranges));
    }
    // IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    // IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    // IMGUI_API void              ClearTexData();             // Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.
    ClearTexData() {
        this.native.ClearTexData();
    }
    // IMGUI_API void              ClearInputData();           // Clear the input TTF data (inc sizes, glyph ranges)
    ClearInputData() {
        this.native.ClearInputData();
    }
    // IMGUI_API void              ClearFonts();               // Clear the ImGui-side font data (glyphs storage, UV coordinates)
    ClearFonts() {
        this.native.ClearFonts();
    }
    // IMGUI_API void              Clear();                    // Clear all
    Clear() {
        this.native.Clear();
    }
    // Build atlas, retrieve pixel data.
    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
    // RGBA32 format is provided for convenience and compatibility, but note that unless you use CustomRect to draw color data, the RGB pixels emitted from Fonts will all be white (~75% of waste).
    // Pitch = Width * BytesPerPixels
    // IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
    Build() {
        return this.native.Build();
    }
    // IMGUI_API bool              IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
    IsBuilt() {
        return this.native.IsBuilt();
    }
    // IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
    GetTexDataAsAlpha8() {
        return this.native.GetTexDataAsAlpha8();
    }
    // IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
    GetTexDataAsRGBA32() {
        return this.native.GetTexDataAsRGBA32();
    }
    // void                        SetTexID(ImTextureID id)    { TexID = id; }
    SetTexID(id) {
        this.TexID = id;
    }
    //-------------------------------------------
    // Glyph Ranges
    //-------------------------------------------
    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
    // IMGUI_API const ImWchar*    GetGlyphRangesDefault();    // Basic Latin, Extended Latin
    GetGlyphRangesDefault() {
        return this.native.GetGlyphRangesDefault();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesKorean();     // Default + Korean characters
    GetGlyphRangesKorean() {
        return this.native.GetGlyphRangesKorean();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
    GetGlyphRangesJapanese() {
        return this.native.GetGlyphRangesJapanese();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
    GetGlyphRangesChineseFull() {
        return this.native.GetGlyphRangesChineseFull();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
    GetGlyphRangesChineseSimplifiedCommon() {
        return this.native.GetGlyphRangesChineseSimplifiedCommon();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   // Default + about 400 Cyrillic characters
    GetGlyphRangesCyrillic() {
        return this.native.GetGlyphRangesCyrillic();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesThai();       // Default + Thai characters
    GetGlyphRangesThai() {
        return this.native.GetGlyphRangesThai();
    }
    // IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();       // Default + Vietnamese characters
    GetGlyphRangesVietnamese() {
        return this.native.GetGlyphRangesVietnamese();
    }
    // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().
    // struct GlyphRangesBuilder
    // {
    //     ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)
    //     GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }
    //     bool           GetBit(int n) const  { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }
    //     void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array
    //     void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character
    //     IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)
    //     IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault) to force add all of ASCII/Latin+Ext
    //     IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges
    // };
    //-------------------------------------------
    // Custom Rectangles/Glyphs API
    //-------------------------------------------
    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
    // struct CustomRect
    // {
    //     unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
    //     unsigned short  Width, Height;  // Input    // Desired rectangle dimension
    //     unsigned short  X, Y;           // Output   // Packed position in Atlas
    //     float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
    //     ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
    //     ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
    //     CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
    //     bool IsPacked() const   { return X != 0xFFFF; }
    // };
    // IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
    // IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
    // IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
    // const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }
    //-------------------------------------------
    // Members
    //-------------------------------------------
    // bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
    get Locked() {
        return this.native.Locked;
    }
    set Locked(value) {
        this.native.Locked = value;
    }
    // ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
    get Flags() {
        return this.native.Flags;
    }
    set Flags(value) {
        this.native.Flags = value;
    }
    // ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
    get TexID() {
        return ImGuiContext.getTexture(this.native.TexID);
    }
    set TexID(value) {
        this.native.TexID = ImGuiContext.setTexture(value);
    }
    // int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
    get TexDesiredWidth() {
        return this.native.TexDesiredWidth;
    }
    set TexDesiredWidth(value) {
        this.native.TexDesiredWidth = value;
    }
    // int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.
    get TexGlyphPadding() {
        return this.native.TexGlyphPadding;
    }
    set TexGlyphPadding(value) {
        this.native.TexGlyphPadding = value;
    }
    // [Internal]
    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
    // unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
    // unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
    // int                         TexWidth;           // Texture width calculated during Build().
    get TexWidth() {
        return this.native.TexWidth;
    }
    // int                         TexHeight;          // Texture height calculated during Build().
    get TexHeight() {
        return this.native.TexHeight;
    }
    // ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
    get TexUvScale() {
        return this.native.TexUvScale;
    }
    // ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
    get TexUvWhitePixel() {
        return this.native.TexUvWhitePixel;
    }
    // ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    get Fonts_() {
        const fonts = new ImVector();
        this.native.IterateFonts((font)=>{
            fonts.push(new ImFont(font));
        });
        return fonts;
    }
    get Fonts() {
        if (this._Fonts == null) {
            this._Fonts = this.Fonts_;
        }
        return this._Fonts;
    }
    _Fonts;
    // ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
    // ImVector<ImFontConfig>      ConfigData;         // Internal data
    // int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList
    get CurrentFont() {
        return new ImFont(this.native.CurrentFont);
    }
}
class ImFont {
    native;
    constructor(native){
        this.native = native;
    }
    setFont(config) {
        this.native.FontName = config.name;
        this.native.FontSize = config.fontsize;
        this.native.Ascent = config.ascent ? config.ascent : 0;
        this.native.Descent = config.descent ? config.descent : 0;
    }
    // Members: Hot ~62/78 bytes
    // float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)
    get FontStyle() {
        return this.native.FontStyle;
    }
    set FontStyle(v) {
        this.native.FontStyle = v;
    }
    get FontName() {
        return this.native.FontName;
    }
    set FontName(v) {
        this.native.FontName = v;
    }
    get FontSize() {
        return this.native.FontSize;
    }
    set FontSize(v) {
        this.native.FontSize = v;
    }
    get SpaceX() {
        return [
            this.native.SpaceX0,
            this.native.SpaceX1
        ];
    }
    set SpaceX(v) {
        this.native.SpaceX0 = v[0];
        this.native.SpaceX1 = v[1];
    }
    // float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()
    get Scale() {
        return this.native.Scale;
    }
    set Scale(value) {
        this.native.Scale = value;
    }
    // ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.
    get Glyphs() {
        const glyphs = new ImVector();
        this.native.IterateGlyphs((glyph)=>{
            glyphs.push(new ImFontGlyph(glyph)); // TODO: wrap native
        });
        return glyphs;
    }
    // ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).
    // get IndexAdvanceX(): any { return this.native.IndexAdvanceX; }
    // ImVector<unsigned short>    IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.
    // get IndexLookup(): any { return this.native.IndexLookup; }
    // const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)
    get FallbackGlyph() {
        const glyph = this.native.FallbackGlyph;
        return glyph && new ImFontGlyph(glyph);
    }
    set FallbackGlyph(value) {
        this.native.FallbackGlyph = value && value.internal;
    }
    // float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX
    get FallbackAdvanceX() {
        return this.native.FallbackAdvanceX;
    }
    // ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()
    get FallbackChar() {
        return this.native.FallbackChar;
    }
    // ImWchar                     EllipsisChar;       // 2     // out // = -1       // Character used for ellipsis rendering.
    get EllipsisChar() {
        return this.native.EllipsisChar;
    }
    // Members: Cold ~18/26 bytes
    // short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
    get ConfigDataCount() {
        return this.native.ConfigDataCount;
    }
    // ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData
    get ConfigData() {
        return new ImFontConfig(this.native.ConfigData);
    }
    // ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into
    get ContainerAtlas() {
        return null;
    }
    // float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
    get Ascent() {
        return this.native.Ascent;
    }
    set Ascent(v) {
        this.native.Ascent = v;
    }
    get Descent() {
        return this.native.Descent;
    }
    set Descent(v) {
        this.native.Descent = v;
    }
    // int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
    get MetricsTotalSurface() {
        return this.native.MetricsTotalSurface;
    }
    // Methods
    // IMGUI_API ImFont();
    // IMGUI_API ~ImFont();
    // IMGUI_API void              ClearOutputData();
    ClearOutputData() {
        return this.native.ClearOutputData();
    }
    // IMGUI_API void              BuildLookupTable();
    BuildLookupTable() {
        return this.native.BuildLookupTable();
    }
    // IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
    FindGlyph(c) {
        const glyph = this.native.FindGlyph(c);
        return glyph && new ImFontGlyph(glyph);
    }
    // IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    FindGlyphNoFallback(c) {
        const glyph = this.native.FindGlyphNoFallback(c);
        return glyph && new ImFontGlyph(glyph);
    }
    // IMGUI_API void              SetFallbackChar(ImWchar c);
    SetFallbackChar(c) {
        return this.native.SetFallbackChar(c);
    }
    // float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    GetCharAdvance(c) {
        return this.native.GetCharAdvance(c);
    }
    // bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
    IsLoaded() {
        return this.native.IsLoaded();
    }
    // const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }
    GetDebugName() {
        return this.native.GetDebugName();
    }
    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
    // IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
    CalcTextSizeA(size, max_width, wrap_width, text_begin, text_end = null, remaining = null, isready = null) {
        return this.native.CalcTextSizeA(size, max_width, wrap_width, text_end !== null ? text_begin.substring(0, text_end) : text_begin, remaining, isready, new ImVec2());
    }
    // IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    CalcWordWrapPositionA(scale, text, text_end = null, wrap_width) {
        return this.native.CalcWordWrapPositionA(scale, text_end !== null ? text.substring(0, text_end) : text, wrap_width);
    }
    // IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;
    RenderChar(draw_list, size, pos, col, c) {
        this.native.RenderChar(draw_list.native, size, pos, col, c);
    }
    // IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;
    RenderText(draw_list, size, pos, col, clip_rect, text_begin, text_end = null, wrap_width = 0.0, cpu_fine_clip = false) {}
    // [Internal]
    // IMGUI_API void              GrowIndex(int new_size);
    // IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    // IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
    // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
    // #endif
    // IMGUI_API bool              IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);
    IsGlyphRangeUnused(c_begin, c_last) {
        return false;
    }
    get GlyphToCreate() {
        const glyph = this.native.GlyphToCreate();
        return glyph ? new ImFontGlyph(glyph) : null;
    }
    get IterateGlyphToCreate() {
        const glyphs = [];
        this.native.IterateGlyphToCreate((glyph)=>{
            glyphs.push(new ImFontGlyph(glyph));
        });
        return glyphs;
    }
    GlyphCreated(glyph) {
        this.native.GlyphCreated(glyph.internal);
    }
    ClearGlyphCreated() {
        this.native.ClearGlyphCreated();
    }
    CreateGlyph(text) {
        this.native.CreateGlyph(text);
    }
}
// a script version of Bind.ImGuiStyle with matching interface
class script_ImGuiStyle {
    Alpha = 1.0;
    WindowPadding = new ImVec2(8, 8);
    WindowRounding = 7.0;
    WindowBorderSize = 0.0;
    WindowMinSize = new ImVec2(32, 32);
    WindowTitleAlign = new ImVec2(0.0, 0.5);
    WindowMenuButtonPosition = ImGuiDir.Left;
    ChildRounding = 0.0;
    ChildBorderSize = 1.0;
    PopupRounding = 0.0;
    PopupBorderSize = 1.0;
    FramePadding = new ImVec2(4, 3);
    FrameRounding = 0.0;
    FrameBorderSize = 0.0;
    ItemSpacing = new ImVec2(8, 4);
    ItemInnerSpacing = new ImVec2(4, 4);
    CellPadding = new ImVec2(4, 2);
    TouchExtraPadding = new ImVec2(0, 0);
    IndentSpacing = 21.0;
    ColumnsMinSpacing = 6.0;
    ScrollbarSize = 16.0;
    ScrollbarRounding = 9.0;
    GrabMinSize = 10.0;
    GrabRounding = 0.0;
    LogSliderDeadzone = 4.0;
    TabRounding = 0.0;
    TabBorderSize = 0.0;
    TabMinWidthForCloseButton = 0.0;
    ColorButtonPosition = ImGuiDir.Right;
    ButtonTextAlign = new ImVec2(0.5, 0.5);
    SelectableTextAlign = new ImVec2(0.0, 0.0);
    DisplayWindowPadding = new ImVec2(22, 22);
    DisplaySafeAreaPadding = new ImVec2(4, 4);
    MouseCursorScale = 1;
    AntiAliasedLines = true;
    AntiAliasedLinesUseTex = true;
    AntiAliasedFill = true;
    CurveTessellationTol = 1.25;
    CircleSegmentMaxError = 1.6;
    Colors = [];
    _getAt_Colors(index) {
        return this.Colors[index];
    }
    _setAt_Colors(index, color) {
        this.Colors[index].Copy(color);
        return true;
    }
    constructor(){
        for(let i = 0; i < ImGuiCol.COUNT; ++i){
            this.Colors[i] = new ImVec4();
        }
        const _this = new ImGuiStyle(this);
        const native = new bind.ImGuiStyle();
        const _that = new ImGuiStyle(native);
        _that.Copy(_this);
        bind.StyleColorsClassic(native);
        _this.Copy(_that);
        native.delete();
    }
    ScaleAllSizes(scale_factor) {
        const _this = new ImGuiStyle(this);
        const native = new bind.ImGuiStyle();
        const _that = new ImGuiStyle(native);
        _that.Copy(_this);
        native.ScaleAllSizes(scale_factor);
        _this.Copy(_that);
        native.delete();
    }
}
class ImGuiStyle {
    internal;
    constructor(internal = new script_ImGuiStyle()){
        this.internal = internal;
        this.Colors = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return ImGuiCol.COUNT;
                }
                return this.internal._getAt_Colors(Number(key));
            },
            set: (target, key, value)=>{
                return this.internal._setAt_Colors(Number(key), value);
            }
        });
    }
    get Alpha() {
        return this.internal.Alpha;
    }
    set Alpha(value) {
        this.internal.Alpha = value;
    }
    get WindowPadding() {
        return this.internal.WindowPadding;
    }
    get WindowRounding() {
        return this.internal.WindowRounding;
    }
    set WindowRounding(value) {
        this.internal.WindowRounding = value;
    }
    get WindowBorderSize() {
        return this.internal.WindowBorderSize;
    }
    set WindowBorderSize(value) {
        this.internal.WindowBorderSize = value;
    }
    get WindowMinSize() {
        return this.internal.WindowMinSize;
    }
    get WindowTitleAlign() {
        return this.internal.WindowTitleAlign;
    }
    get WindowMenuButtonPosition() {
        return this.internal.WindowMenuButtonPosition;
    }
    set WindowMenuButtonPosition(value) {
        this.internal.WindowMenuButtonPosition = value;
    }
    get ChildRounding() {
        return this.internal.ChildRounding;
    }
    set ChildRounding(value) {
        this.internal.ChildRounding = value;
    }
    get ChildBorderSize() {
        return this.internal.ChildBorderSize;
    }
    set ChildBorderSize(value) {
        this.internal.ChildBorderSize = value;
    }
    get PopupRounding() {
        return this.internal.PopupRounding;
    }
    set PopupRounding(value) {
        this.internal.PopupRounding = value;
    }
    get PopupBorderSize() {
        return this.internal.PopupBorderSize;
    }
    set PopupBorderSize(value) {
        this.internal.PopupBorderSize = value;
    }
    get FramePadding() {
        return this.internal.FramePadding;
    }
    get FrameRounding() {
        return this.internal.FrameRounding;
    }
    set FrameRounding(value) {
        this.internal.FrameRounding = value;
    }
    get FrameBorderSize() {
        return this.internal.FrameBorderSize;
    }
    set FrameBorderSize(value) {
        this.internal.FrameBorderSize = value;
    }
    get ItemSpacing() {
        return this.internal.ItemSpacing;
    }
    get ItemInnerSpacing() {
        return this.internal.ItemInnerSpacing;
    }
    get CellPadding() {
        return this.internal.CellPadding;
    }
    get TouchExtraPadding() {
        return this.internal.TouchExtraPadding;
    }
    get IndentSpacing() {
        return this.internal.IndentSpacing;
    }
    set IndentSpacing(value) {
        this.internal.IndentSpacing = value;
    }
    get ColumnsMinSpacing() {
        return this.internal.ColumnsMinSpacing;
    }
    set ColumnsMinSpacing(value) {
        this.internal.ColumnsMinSpacing = value;
    }
    get ScrollbarSize() {
        return this.internal.ScrollbarSize;
    }
    set ScrollbarSize(value) {
        this.internal.ScrollbarSize = value;
    }
    get ScrollbarRounding() {
        return this.internal.ScrollbarRounding;
    }
    set ScrollbarRounding(value) {
        this.internal.ScrollbarRounding = value;
    }
    get GrabMinSize() {
        return this.internal.GrabMinSize;
    }
    set GrabMinSize(value) {
        this.internal.GrabMinSize = value;
    }
    get GrabRounding() {
        return this.internal.GrabRounding;
    }
    set GrabRounding(value) {
        this.internal.GrabRounding = value;
    }
    get LogSliderDeadzone() {
        return this.internal.LogSliderDeadzone;
    }
    set LogSliderDeadzone(value) {
        this.internal.LogSliderDeadzone = value;
    }
    get TabRounding() {
        return this.internal.TabRounding;
    }
    set TabRounding(value) {
        this.internal.TabRounding = value;
    }
    get TabBorderSize() {
        return this.internal.TabBorderSize;
    }
    set TabBorderSize(value) {
        this.internal.TabBorderSize = value;
    }
    get TabMinWidthForCloseButton() {
        return this.internal.TabMinWidthForCloseButton;
    }
    set TabMinWidthForCloseButton(value) {
        this.internal.TabMinWidthForCloseButton = value;
    }
    get ColorButtonPosition() {
        return this.internal.ColorButtonPosition;
    }
    set ColorButtonPosition(value) {
        this.internal.ColorButtonPosition = value;
    }
    get ButtonTextAlign() {
        return this.internal.ButtonTextAlign;
    }
    get SelectableTextAlign() {
        return this.internal.SelectableTextAlign;
    }
    get DisplayWindowPadding() {
        return this.internal.DisplayWindowPadding;
    }
    get DisplaySafeAreaPadding() {
        return this.internal.DisplaySafeAreaPadding;
    }
    get MouseCursorScale() {
        return this.internal.MouseCursorScale;
    }
    set MouseCursorScale(value) {
        this.internal.MouseCursorScale = value;
    }
    get AntiAliasedLines() {
        return this.internal.AntiAliasedLines;
    }
    set AntiAliasedLines(value) {
        this.internal.AntiAliasedLines = value;
    }
    get AntiAliasedLinesUseTex() {
        return this.internal.AntiAliasedLinesUseTex;
    }
    set AntiAliasedLinesUseTex(value) {
        this.internal.AntiAliasedLinesUseTex = value;
    }
    get AntiAliasedFill() {
        return this.internal.AntiAliasedFill;
    }
    set AntiAliasedFill(value) {
        this.internal.AntiAliasedFill = value;
    }
    get CurveTessellationTol() {
        return this.internal.CurveTessellationTol;
    }
    set CurveTessellationTol(value) {
        this.internal.CurveTessellationTol = value;
    }
    get CircleSegmentMaxError() {
        return this.internal.CircleSegmentMaxError;
    }
    set CircleSegmentMaxError(value) {
        this.internal.CircleSegmentMaxError = value;
    }
    Colors;
    Copy(other) {
        this.Alpha = other.Alpha;
        this.WindowPadding.Copy(other.WindowPadding);
        this.WindowRounding = other.WindowRounding;
        this.WindowBorderSize = other.WindowBorderSize;
        this.WindowMinSize.Copy(other.WindowMinSize);
        this.WindowTitleAlign.Copy(other.WindowTitleAlign);
        this.WindowMenuButtonPosition = other.WindowMenuButtonPosition;
        this.ChildRounding = other.ChildRounding;
        this.ChildBorderSize = other.ChildBorderSize;
        this.PopupRounding = other.PopupRounding;
        this.PopupBorderSize = other.PopupBorderSize;
        this.FramePadding.Copy(other.FramePadding);
        this.FrameRounding = other.FrameRounding;
        this.FrameBorderSize = other.FrameBorderSize;
        this.ItemSpacing.Copy(other.ItemSpacing);
        this.ItemInnerSpacing.Copy(other.ItemInnerSpacing);
        this.CellPadding.Copy(other.CellPadding);
        this.TouchExtraPadding.Copy(other.TouchExtraPadding);
        this.IndentSpacing = other.IndentSpacing;
        this.ColumnsMinSpacing = other.ColumnsMinSpacing;
        this.ScrollbarSize = other.ScrollbarSize;
        this.ScrollbarRounding = other.ScrollbarRounding;
        this.GrabMinSize = other.GrabMinSize;
        this.GrabRounding = other.GrabRounding;
        this.LogSliderDeadzone = other.LogSliderDeadzone;
        this.TabRounding = other.TabRounding;
        this.TabBorderSize = other.TabBorderSize;
        this.TabMinWidthForCloseButton = other.TabMinWidthForCloseButton;
        this.ColorButtonPosition = other.ColorButtonPosition;
        this.ButtonTextAlign.Copy(other.ButtonTextAlign);
        this.DisplayWindowPadding.Copy(other.DisplayWindowPadding);
        this.DisplaySafeAreaPadding.Copy(other.DisplaySafeAreaPadding);
        this.MouseCursorScale = other.MouseCursorScale;
        this.AntiAliasedLines = other.AntiAliasedLines;
        this.AntiAliasedLinesUseTex = other.AntiAliasedLinesUseTex;
        this.AntiAliasedFill = other.AntiAliasedFill;
        this.CurveTessellationTol = other.CurveTessellationTol;
        this.CircleSegmentMaxError = other.CircleSegmentMaxError;
        for(let i = 0; i < ImGuiCol.COUNT; ++i){
            this.Colors[i].Copy(other.Colors[i]);
        }
        return this;
    }
    ScaleAllSizes(scale_factor) {
        this.internal.ScaleAllSizes(scale_factor);
    }
}
class ImGuiIO {
    native;
    constructor(native){
        this.native = native;
        this.KeyMap = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return ImGuiKey.COUNT;
                }
                return this.native._getAt_KeyMap(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_KeyMap(Number(key), value);
            }
        });
        this.MouseDown = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return 5;
                }
                return this.native._getAt_MouseDown(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_MouseDown(Number(key), value);
            }
        });
        this.KeysDown = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return 512;
                }
                return this.native._getAt_KeysDown(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_KeysDown(Number(key), value);
            }
        });
        this.NavInputs = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return ImGuiNavInput.COUNT;
                }
                return this.native._getAt_NavInputs(Number(key));
            },
            set: (target, key, value)=>{
                return this.native._setAt_NavInputs(Number(key), value);
            }
        });
        this.MouseClickedPos = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return 5;
                }
                return this.native._getAt_MouseClickedPos(Number(key));
            }
        });
        this.MouseDownDuration = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return 5;
                }
                return this.native._getAt_MouseDownDuration(Number(key));
            }
        });
        this.KeysDownDuration = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return 512;
                }
                return this.native._getAt_KeysDownDuration(Number(key));
            }
        });
        this.NavInputsDownDuration = new Proxy([], {
            get: (target, key)=>{
                if (key === 'length') {
                    return ImGuiNavInput.COUNT;
                }
                return this.native._getAt_NavInputsDownDuration(Number(key));
            }
        });
    }
    //------------------------------------------------------------------
    // Settings (fill once)                 // Default value:
    //------------------------------------------------------------------
    // ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
    get ConfigFlags() {
        return this.native.ConfigFlags;
    }
    set ConfigFlags(value) {
        this.native.ConfigFlags = value;
    }
    // ImGuiBackendFlags  BackendFlags;        // = 0                  // Set ImGuiBackendFlags_ enum. Set by imgui_impl_xxx files or custom back-end to communicate features supported by the back-end.
    get BackendFlags() {
        return this.native.BackendFlags;
    }
    set BackendFlags(value) {
        this.native.BackendFlags = value;
    }
    // ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.
    get DisplaySize() {
        return this.native.DisplaySize;
    }
    // float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.
    get DeltaTime() {
        return this.native.DeltaTime;
    }
    set DeltaTime(value) {
        this.native.DeltaTime = value;
    }
    // float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.
    get IniSavingRate() {
        return this.native.IniSavingRate;
    }
    set IniSavingRate(value) {
        this.native.IniSavingRate = value;
    }
    // const char*   IniFilename;              // = "imgui.ini"        // Path to .ini file. NULL to disable .ini saving.
    get IniFilename() {
        return this.native.IniFilename;
    }
    set IniFilename(value) {
        this.native.IniFilename = value;
    }
    // const char*   LogFilename;              // = "imgui_log.txt"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    get LogFilename() {
        return this.native.LogFilename;
    }
    set LogFilename(value) {
        this.native.LogFilename = value;
    }
    // float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.
    get MouseDoubleClickTime() {
        return this.native.MouseDoubleClickTime;
    }
    set MouseDoubleClickTime(value) {
        this.native.MouseDoubleClickTime = value;
    }
    // float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.
    get MouseDoubleClickMaxDist() {
        return this.native.MouseDoubleClickMaxDist;
    }
    set MouseDoubleClickMaxDist(value) {
        this.native.MouseDoubleClickMaxDist = value;
    }
    // float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging
    get MouseDragThreshold() {
        return this.native.MouseDragThreshold;
    }
    set MouseDragThreshold(value) {
        this.native.MouseDragThreshold = value;
    }
    // int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array
    KeyMap;
    // float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    get KeyRepeatDelay() {
        return this.native.KeyRepeatDelay;
    }
    set KeyRepeatDelay(value) {
        this.native.KeyRepeatDelay = value;
    }
    // float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.
    get KeyRepeatRate() {
        return this.native.KeyRepeatRate;
    }
    set KeyRepeatRate(value) {
        this.native.KeyRepeatRate = value;
    }
    // void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.
    get UserData() {
        return this.native.UserData;
    }
    set UserData(value) {
        this.native.UserData = value;
    }
    // ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
    get Fonts() {
        return new ImFontAtlas(this.native.Fonts);
    }
    // float         FontGlobalScale;          // = 1.0f               // Global scale all fonts
    get FontGlobalScale() {
        return this.native.FontGlobalScale;
    }
    set FontGlobalScale(value) {
        this.native.FontGlobalScale = value;
    }
    // bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.
    get FontAllowUserScaling() {
        return this.native.FontAllowUserScaling;
    }
    set FontAllowUserScaling(value) {
        this.native.FontAllowUserScaling = value;
    }
    // ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
    get FontDefault() {
        const font = this.native.FontDefault;
        return font === null ? null : new ImFont(font);
    }
    set FontDefault(value) {
        this.native.FontDefault = value && value.native;
    }
    // ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.
    get DisplayFramebufferScale() {
        return this.native.DisplayFramebufferScale;
    }
    // Miscellaneous configuration options
    // bool          OptMacOSXBehaviors;       // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl
    get ConfigMacOSXBehaviors() {
        return this.native.ConfigMacOSXBehaviors;
    }
    set ConfigMacOSXBehaviors(value) {
        this.native.ConfigMacOSXBehaviors = value;
    }
    // bool          ConfigInputTextCursorBlink;   // = true               // Enable blinking cursor, for users who consider it annoying.
    get ConfigInputTextCursorBlink() {
        return this.native.ConfigInputTextCursorBlink;
    }
    set ConfigInputTextCursorBlink(value) {
        this.native.ConfigInputTextCursorBlink = value;
    }
    // bool        ConfigDragClickToInputText;     // = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
    get ConfigDragClickToInputText() {
        return this.native.ConfigDragClickToInputText;
    }
    set ConfigDragClickToInputText(value) {
        this.native.ConfigDragClickToInputText = value;
    }
    // bool          ConfigWindowsResizeFromEdges; // = false          // [BETA] Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the ImGuiWindowFlags_ResizeFromAnySide flag)
    get ConfigWindowsResizeFromEdges() {
        return this.native.ConfigWindowsResizeFromEdges;
    }
    set ConfigWindowsResizeFromEdges(value) {
        this.native.ConfigWindowsResizeFromEdges = value;
    }
    // bool        ConfigWindowsMoveFromTitleBarOnly;// = false        // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.
    get ConfigWindowsMoveFromTitleBarOnly() {
        return this.native.ConfigWindowsMoveFromTitleBarOnly;
    }
    set ConfigWindowsMoveFromTitleBarOnly(value) {
        this.native.ConfigWindowsMoveFromTitleBarOnly = value;
    }
    // float       ConfigMemoryCompactTimer;       // = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
    get ConfigMemoryCompactTimer() {
        return this.native.ConfigMemoryCompactTimer;
    }
    set ConfigMemoryCompactTimer(value) {
        this.native.ConfigMemoryCompactTimer = value;
    }
    //------------------------------------------------------------------
    // Settings (User Functions)
    //------------------------------------------------------------------
    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
    // const char* BackendPlatformName;            // = NULL
    get BackendPlatformName() {
        return this.native.BackendPlatformName;
    }
    set BackendPlatformName(value) {
        this.native.BackendPlatformName = value;
    }
    // const char* BackendRendererName;            // = NULL
    get BackendRendererName() {
        return this.native.BackendRendererName;
    }
    set BackendRendererName(value) {
        this.native.BackendRendererName = value;
    }
    // void*       BackendPlatformUserData;        // = NULL
    get BackendPlatformUserData() {
        return this.native.BackendPlatformUserData;
    }
    set BackendPlatformUserData(value) {
        this.native.BackendPlatformUserData = value;
    }
    // void*       BackendRendererUserData;        // = NULL
    get BackendRendererUserData() {
        return this.native.BackendRendererUserData;
    }
    set BackendRendererUserData(value) {
        this.native.BackendRendererUserData = value;
    }
    // void*       BackendLanguageUserData;        // = NULL
    get BackendLanguageUserData() {
        return this.native.BackendLanguageUserData;
    }
    set BackendLanguageUserData(value) {
        this.native.BackendLanguageUserData = value;
    }
    // Optional: access OS clipboard
    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
    // const char* (*GetClipboardTextFn)(void* user_data);
    get GetClipboardTextFn() {
        return this.native.GetClipboardTextFn;
    }
    set GetClipboardTextFn(value) {
        this.native.GetClipboardTextFn = value;
    }
    // void        (*SetClipboardTextFn)(void* user_data, const char* text);
    get SetClipboardTextFn() {
        return this.native.SetClipboardTextFn;
    }
    set SetClipboardTextFn(value) {
        this.native.SetClipboardTextFn = value;
    }
    // void*       ClipboardUserData;
    get ClipboardUserData() {
        return this.native.ClipboardUserData;
    }
    set ClipboardUserData(value) {
        this.native.ClipboardUserData = value;
    }
    // Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.
    // (default to posix malloc/free)
    // void*       (*MemAllocFn)(size_t sz);
    // void        (*MemFreeFn)(void* ptr);
    // Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)
    // (default to use native imm32 api on Windows)
    // void        (*ImeSetInputScreenPosFn)(int x, int y);
    // void*       ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.
    //------------------------------------------------------------------
    // Input - Fill before calling NewFrame()
    //------------------------------------------------------------------
    // ImVec2      MousePos;                   // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
    get MousePos() {
        return this.native.MousePos;
    }
    // bool        MouseDown[5];               // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    MouseDown;
    // float       MouseWheel;                 // Mouse wheel: 1 unit scrolls about 5 lines text.
    get MouseWheel() {
        return this.native.MouseWheel;
    }
    set MouseWheel(value) {
        this.native.MouseWheel = value;
    }
    // float       MouseWheelH;                    // Mouse wheel (Horizontal). Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
    get MouseWheelH() {
        return this.native.MouseWheelH;
    }
    set MouseWheelH(value) {
        this.native.MouseWheelH = value;
    }
    // bool        MouseDrawCursor;            // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).
    get MouseDrawCursor() {
        return this.native.MouseDrawCursor;
    }
    set MouseDrawCursor(value) {
        this.native.MouseDrawCursor = value;
    }
    // bool        KeyCtrl;                    // Keyboard modifier pressed: Control
    get KeyCtrl() {
        return this.native.KeyCtrl;
    }
    set KeyCtrl(value) {
        this.native.KeyCtrl = value;
    }
    // bool        KeyShift;                   // Keyboard modifier pressed: Shift
    get KeyShift() {
        return this.native.KeyShift;
    }
    set KeyShift(value) {
        this.native.KeyShift = value;
    }
    // bool        KeyAlt;                     // Keyboard modifier pressed: Alt
    get KeyAlt() {
        return this.native.KeyAlt;
    }
    set KeyAlt(value) {
        this.native.KeyAlt = value;
    }
    // bool        KeySuper;                   // Keyboard modifier pressed: Cmd/Super/Windows
    get KeySuper() {
        return this.native.KeySuper;
    }
    set KeySuper(value) {
        this.native.KeySuper = value;
    }
    // bool        KeysDown[512];              // Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)
    KeysDown;
    // float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame)
    NavInputs;
    // Functions
    // IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]
    AddInputCharacter(c) {
        this.native.AddInputCharacter(c);
    }
    // IMGUI_API void  AddInputCharacterUTF16(ImWchar16 c);        // Queue new character input from an UTF-16 character, it can be a surrogate
    AddInputCharacterUTF16(c) {
        this.native.AddInputCharacterUTF16(c);
    }
    // IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string
    AddInputCharactersUTF8(utf8_chars) {
        this.native.AddInputCharactersUTF8(utf8_chars);
    }
    // inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually
    ClearInputCharacters() {
        this.native.ClearInputCharacters();
    }
    //------------------------------------------------------------------
    // Output - Retrieve after calling NewFrame()
    //------------------------------------------------------------------
    // bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application. This is set by ImGui when it wants to use your mouse (e.g. unclicked mouse is hovering a window, or a widget is active).
    get WantCaptureMouse() {
        return this.native.WantCaptureMouse;
    }
    set WantCaptureMouse(value) {
        this.native.WantCaptureMouse = value;
    }
    // bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application. This is set by ImGui when it wants to use your keyboard inputs.
    get WantCaptureKeyboard() {
        return this.native.WantCaptureKeyboard;
    }
    set WantCaptureKeyboard(value) {
        this.native.WantCaptureKeyboard = value;
    }
    // bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    get WantTextInput() {
        return this.native.WantTextInput;
    }
    set WantTextInput(value) {
        this.native.WantTextInput = value;
    }
    // bool        WantSetMousePos;              // [BETA-NAV] MousePos has been altered, back-end should reposition mouse on next frame. Set only when 'NavMovesMouse=true'.
    get WantSetMousePos() {
        return this.native.WantSetMousePos;
    }
    set WantSetMousePos(value) {
        this.native.WantSetMousePos = value;
    }
    // bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
    get WantSaveIniSettings() {
        return this.native.WantSaveIniSettings;
    }
    set WantSaveIniSettings(value) {
        this.native.WantSaveIniSettings = value;
    }
    // bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    get NavActive() {
        return this.native.NavActive;
    }
    set NavActive(value) {
        this.native.NavActive = value;
    }
    // bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
    get NavVisible() {
        return this.native.NavVisible;
    }
    set NavVisible(value) {
        this.native.NavVisible = value;
    }
    // float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
    get Framerate() {
        return this.native.Framerate;
    }
    // int         MetricsRenderVertices;      // Vertices output during last call to Render()
    get MetricsRenderVertices() {
        return this.native.MetricsRenderVertices;
    }
    // int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3
    get MetricsRenderIndices() {
        return this.native.MetricsRenderIndices;
    }
    // int         MetricsRenderWindows;       // Number of visible windows
    get MetricsRenderWindows() {
        return this.native.MetricsRenderWindows;
    }
    // int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)
    get MetricsActiveWindows() {
        return this.native.MetricsActiveWindows;
    }
    // int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
    get MetricsActiveAllocations() {
        return this.native.MetricsActiveAllocations;
    }
    // ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
    get MouseDelta() {
        return this.native.MouseDelta;
    }
    //------------------------------------------------------------------
    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
    //------------------------------------------------------------------
    // ImGuiKeyModFlags KeyMods;                   // Key mods flags (same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags), updated by NewFrame()
    // ImVec2      MousePosPrev;               // Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())
    // ImVec2      MouseClickedPos[5];         // Position at time of clicking
    MouseClickedPos;
    // float       MouseClickedTime[5];        // Time of last click (used to figure out double-click)
    // bool        MouseClicked[5];            // Mouse button went from !Down to Down
    // bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?
    // bool        MouseReleased[5];           // Mouse button went from Down to !Down
    // bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.
    // float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)
    MouseDownDuration;
    // float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down
    // ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
    // float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point
    // float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)
    KeysDownDuration;
    // float       KeysDownDurationPrev[512];  // Previous duration the key has been down
    // float       NavInputsDownDuration[ImGuiNavInput_COUNT];
    NavInputsDownDuration;
}
// Context creation and access
// Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.
// None of those functions is reliant on the current context.
// IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
// IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
// IMGUI_API ImGuiContext* GetCurrentContext();
// IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
class ImGuiContext {
    native;
    static current_ctx = null;
    static getTexture(index) {
        if (ImGuiContext.current_ctx === null) {
            throw new Error();
        }
        return ImGuiContext.current_ctx._getTexture(index);
    }
    static setTexture(texture) {
        if (ImGuiContext.current_ctx === null) {
            throw new Error();
        }
        return ImGuiContext.current_ctx._setTexture(texture);
    }
    static textures = [];
    constructor(native){
        this.native = native;
    }
    _getTexture(index) {
        return ImGuiContext.textures[index] || null;
    }
    _setTexture(texture) {
        let index = ImGuiContext.textures.indexOf(texture);
        if (index === -1) {
            for(let i = 0; i < ImGuiContext.textures.length; ++i){
                if (ImGuiContext.textures[i] === null) {
                    ImGuiContext.textures[i] = texture;
                    return i;
                }
            }
            index = ImGuiContext.textures.length;
            ImGuiContext.textures.push(texture);
        }
        return index;
    }
}
function CreateContext(shared_font_atlas = null) {
    const ctx = new ImGuiContext(bind.CreateContext(shared_font_atlas !== null ? shared_font_atlas.native : null));
    if (ImGuiContext.current_ctx === null) {
        ImGuiContext.current_ctx = ctx;
    }
    return ctx;
}
// Main
// IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
// IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame!
// IMGUI_API void          NewFrame();                                 // start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
// IMGUI_API void          EndFrame();                                 // ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
// IMGUI_API void          Render();                                   // ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
// IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render.
function GetIO() {
    return new ImGuiIO(bind.GetIO());
}
function GetStyle() {
    return new ImGuiStyle(bind.GetStyle());
}
function NewFrame$1() {
    bind.NewFrame();
}
function EndFrame() {
    bind.EndFrame();
}
function Render() {
    bind.Render();
}
function GetDrawData() {
    const draw_data = bind.GetDrawData();
    return draw_data === null ? null : new ImDrawData(draw_data);
}
// Styles
// IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)
// IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font
// IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
function StyleColorsDark(dst = null) {
    if (dst === null) {
        bind.StyleColorsDark(null);
    } else if (dst.internal instanceof bind.ImGuiStyle) {
        bind.StyleColorsDark(dst.internal);
    } else {
        const native = new bind.ImGuiStyle();
        const wrap = new ImGuiStyle(native);
        wrap.Copy(dst);
        bind.StyleColorsDark(native);
        dst.Copy(wrap);
        native.delete();
    }
}
// Windows
// - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
// - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
//   which clicking will set the boolean to false when clicked.
// - You may append multiple times to the same window during the same frame by calling Begin()/End() pairs multiple times.
//   Some information such as 'flags' or 'p_open' will only be considered by the first call to Begin().
// - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
//   [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu/EndMenu,
//    BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function
//    returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// - Note that the bottom of window stack always contains a window called "Debug".
// IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
// IMGUI_API void          End();
function Begin(name, open = null, flags = 0) {
    if (open === null) {
        return bind.Begin(name, null, flags);
    } else if (Array.isArray(open)) {
        return bind.Begin(name, open, flags);
    } else {
        const ref_open = [
            open()
        ];
        const opened = bind.Begin(name, ref_open, flags);
        open(ref_open[0]);
        return opened;
    }
}
function End() {
    bind.End();
}
// Child Windows
// - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
// - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).
// - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.
//   Always call a matching EndChild() for each BeginChild() call, regardless of its return value.
//   [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu/EndMenu,
//    BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function
//    returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0, 0), bool border = false, ImGuiWindowFlags flags = 0);
// IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0, 0), bool border = false, ImGuiWindowFlags flags = 0);
// IMGUI_API void          EndChild();
function BeginChild(id, size = ImVec2.ZERO, border = false, flags = 0) {
    return bind.BeginChild(id, size, border, flags);
}
function EndChild() {
    bind.EndChild();
}
function calculateSecionBoundsX(padding) {
    const window1 = GetCurrentWindow();
    const start = GetWindowPos().x;
    return [
        start + window1.WindowPadding.x + padding,
        start + GetWindowWidth() - window1.WindowPadding.x - padding
    ];
}
function BeginStatusBar() {
    SetNextWindowPos(new ImVec2(0, GetIO().DisplaySize.y - GetFrameHeight()));
    SetNextWindowSize(new ImVec2(GetIO().DisplaySize.x, GetFrameHeight()));
    const flags = ImGuiWindowFlags.NoDecoration | ImGuiWindowFlags.NoInputs | ImGuiWindowFlags.NoMove | ImGuiWindowFlags.NoScrollWithMouse | ImGuiWindowFlags.NoScrollbar | ImGuiWindowFlags.NoSavedSettings | ImGuiWindowFlags.NoBringToFrontOnFocus | ImGuiWindowFlags.NoBackground | ImGuiWindowFlags.MenuBar;
    Begin('##StatusBar', null, flags);
    BeginMenuBar();
    return true;
}
function EndStatusBar() {
    EndMenuBar();
    End();
}
function BeginSection(title) {
    GetWindowDrawList().ChannelsSplit(2);
    // Draw content above the rectangle
    GetWindowDrawList().ChannelsSetCurrent(1);
    const padding = GetStyle().WindowPadding;
    const window1 = GetCurrentWindow();
    //const windowWidth = GetWindowWidth();
    const boundsX = calculateSecionBoundsX(padding.x);
    // Title will be clipped till the middle
    // because I am going to have a collapsing
    // header there
    const midPoint = boundsX[0] + (boundsX[1] - boundsX[0]) / 2.0;
    // Start from padding position
    SetCursorPosY(GetCursorPosY() + padding.y);
    BeginGroup();
    if (padding.x > 0) {
        Indent(padding.x);
    }
    PushClipRect(new ImVec2(boundsX[0], window1.ClipRect.Min.y), new ImVec2(midPoint, window1.ClipRect.Max.y), false);
    Text(title);
    PopClipRect();
    // Setting clip rectangle for the group contents;
    // so, that text does not overflow outside this widget
    // the parent window is resized
    PushClipRect(new ImVec2(boundsX[0], window1.ClipRect.Min.y), new ImVec2(boundsX[1], window1.ClipRect.Max.y), false);
    return true;
}
function EndSection(borderSize, rounding) {
    borderSize = borderSize ?? 0;
    rounding = rounding ?? 0;
    const padding = GetStyle().WindowPadding;
    PopClipRect();
    if (padding.x > 0) {
        Unindent(padding.x);
    }
    EndGroup();
    // Essentially, the content is drawn with padding
    // while the rectangle is drawn without padding
    const boundsX = calculateSecionBoundsX(0.0);
    // GetItemRectMin is going to include the padding
    // as well; so, remove it
    const panelMin = new ImVec2(boundsX[0], GetItemRectMin().y - padding.y);
    const panelMax = new ImVec2(boundsX[1], GetItemRectMax().y + padding.y);
    // Draw rectangle below
    GetWindowDrawList().ChannelsSetCurrent(0);
    GetWindowDrawList().AddRectFilled(panelMin, panelMax, GetColorU32(GetStyleColorVec4(ImGuiCol.ChildBg)), rounding);
    if (borderSize > 0) {
        GetWindowDrawList().AddRect(panelMin, panelMax, GetColorU32(GetStyleColorVec4(ImGuiCol.Border)), rounding, ImDrawCornerFlags.All, borderSize);
    }
    GetWindowDrawList().ChannelsMerge();
    // Since rectangle is bigger than the box, move the cursor;
    // so, it starts outside the box
    SetCursorPosY(GetCursorPosY() + padding.y);
    // Then, add default spacing
    Spacing();
}
function GetWindowDrawList() {
    return new ImDrawList(bind.GetWindowDrawList());
}
function GetWindowPos(out = new ImVec2()) {
    return bind.GetWindowPos(out);
}
function GetWindowWidth() {
    return bind.GetWindowWidth();
}
// Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).
// IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0, 0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
// IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
// IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints.
// IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
// IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()
// IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / top-most. call before Begin()
// IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
// IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
// IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
// IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.
// IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
// IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state
// IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / top-most. use NULL to remove focus.
function SetNextWindowPos(pos, cond = 0, pivot = ImVec2.ZERO) {
    bind.SetNextWindowPos(pos, cond, pivot);
}
function SetNextWindowSize(pos, cond = 0) {
    bind.SetNextWindowSize(pos, cond);
}
function SetNextItemWidth(item_width) {
    bind.SetNextItemWidth(item_width);
} // set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
function GetColorU32(...args) {
    if (args.length === 1) {
        if (typeof args[0] === 'number') {
            if (0 <= args[0] && args[0] < ImGuiCol.COUNT) {
                const idx = args[0];
                return bind.GetColorU32_A(idx, 1.0);
            } else {
                const col = args[0];
                return bind.GetColorU32_C(col);
            }
        } else {
            const col = args[0];
            return bind.GetColorU32_B(col);
        }
    } else {
        const idx = args[0];
        const alpha_mul = args[1];
        return bind.GetColorU32_A(idx, alpha_mul);
    }
}
function GetStyleColorVec4(idx) {
    return bind.GetStyleColorVec4(idx);
}
function Spacing() {
    bind.Spacing();
}
function Indent(indent_w = 0.0) {
    bind.Indent(indent_w);
}
function Unindent(indent_w = 0.0) {
    bind.Unindent(indent_w);
}
function BeginGroup() {
    bind.BeginGroup();
}
function EndGroup() {
    bind.EndGroup();
}
function GetCursorPosY() {
    return bind.GetCursorPosY();
}
function SetCursorPosY(y) {
    bind.SetCursorPosY(y);
}
function GetFrameHeight() {
    return bind.GetFrameHeight();
}
function Text(text) {
    bind.Text(text);
}
function TextWrapped(text) {
    bind.TextWrapped(text);
}
function Combo(label, current_item, ...args) {
    let ret = false;
    const _current_item = Array.isArray(current_item) ? current_item : [
        current_item()
    ];
    if (Array.isArray(args[0])) {
        const items = args[0];
        const items_count = typeof args[1] === 'number' ? args[1] : items.length;
        const popup_max_height_in_items = typeof args[2] === 'number' ? args[2] : -1;
        const items_getter = (data, idx, out_text)=>{
            out_text[0] = items[idx];
            return true;
        };
        ret = bind.Combo(label, _current_item, items_getter, null, items_count, popup_max_height_in_items);
    } else if (typeof args[0] === 'string') {
        const items_separated_by_zeros = args[0];
        const popup_max_height_in_items = typeof args[1] === 'number' ? args[1] : -1;
        const items = items_separated_by_zeros.replace(/^\0+|\0+$/g, '').split('\0');
        const items_count = items.length;
        const items_getter = (data, idx, out_text)=>{
            out_text[0] = items[idx];
            return true;
        };
        ret = bind.Combo(label, _current_item, items_getter, null, items_count, popup_max_height_in_items);
    } else {
        const items_getter = args[0];
        const data = args[1];
        const items_count = args[2];
        const popup_max_height_in_items = typeof args[3] === 'number' ? args[3] : -1;
        ret = bind.Combo(label, _current_item, items_getter, data, items_count, popup_max_height_in_items);
    }
    if (!Array.isArray(current_item)) {
        current_item(_current_item[0]);
    }
    return ret;
}
// Widgets: Menus
// - Use BeginMenuBar() on a window ImGuiWindowFlags_MenuBar to append to its menu bar.
// - Use BeginMainMenuBar() to create a menu bar at the top of the screen and append to it.
// - Use BeginMenu() to create a menu. You can call BeginMenu() multiple time with the same identifier to append more items to it.
// IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
// IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!
// IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.
// IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!
// IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!
// IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!
// IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
// IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL
function BeginMenuBar() {
    return bind.BeginMenuBar();
}
function EndMenuBar() {
    bind.EndMenuBar();
}
// Clipping
// - Mouse hovering is affected by ImGui::PushClipRect() calls, unlike direct calls to ImDrawList::PushClipRect() which are render only.
// IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
// IMGUI_API void          PopClipRect();
function PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect) {
    bind.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
}
function PopClipRect() {
    bind.PopClipRect();
}
function GetItemRectMin(out = new ImVec2()) {
    return bind.GetItemRectMin(out);
}
function GetItemRectMax(out = new ImVec2()) {
    return bind.GetItemRectMax(out);
}
function GetMouseCursor() {
    return bind.GetMouseCursor();
}
function LoadIniSettingsFromMemory(ini_data, ini_size = 0) {
    bind.LoadIniSettingsFromMemory(ini_data);
}
function SaveIniSettingsToMemory(out_ini_size = null) {
    return bind.SaveIniSettingsToMemory();
}
// Debug Utilities
// IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx); // This is called by IMGUI_CHECKVERSION() macro.
function DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_draw_vert, sz_draw_idx) {
    return bind.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_draw_vert, sz_draw_idx);
}
class ImGuiWindow {
    native;
    constructor(native){
        this.native = native;
    }
    get ID() {
        return this.native.ID;
    }
    get Flags() {
        return this.native.Flags;
    }
    set Flags(f) {
        this.native.Flags = f;
    }
    get Pos() {
        return this.native.Pos;
    }
    set Pos(v) {
        this.native.Pos.Set(v.x, v.y);
    }
    get Size() {
        return this.native.Size;
    }
    set Size(v) {
        this.native.Size.Set(v.x, v.y);
    }
    get SizeFull() {
        return this.native.SizeFull;
    }
    set SizeFull(v) {
        this.native.SizeFull.Set(v.x, v.y);
    }
    get ContentSize() {
        return this.native.ContentSize;
    }
    set ContentSize(v) {
        this.native.ContentSize.Set(v.x, v.y);
    }
    get ContentSizeIdeal() {
        return this.native.ContentSizeIdeal;
    }
    set ContentSizeIdeal(v) {
        this.native.ContentSizeIdeal.Set(v.x, v.y);
    }
    get ContentSizeExplicit() {
        return this.native.ContentSizeExplicit;
    }
    set ContentSizeExplicit(v) {
        this.native.ContentSizeExplicit.Set(v.x, v.y);
    }
    get WindowPadding() {
        return this.native.WindowPadding;
    }
    set WindowPadding(v) {
        this.native.WindowPadding.Set(v.x, v.y);
    }
    get WindowRounding() {
        return this.native.WindowRounding;
    }
    set WindowRounding(v) {
        this.native.WindowRounding = v;
    }
    get WindowBorderSize() {
        return this.native.WindowBorderSize;
    }
    set WindowBorderSize(v) {
        this.native.WindowBorderSize = v;
    }
    get ClipRect() {
        return this.native.ClipRect;
    }
    set ClipRect(v) {
        this.native.ClipRect.Min.Set(v.Min.x, v.Min.y);
        this.native.ClipRect.Max.Set(v.Max.x, v.Max.y);
    }
    get WorkRect() {
        return this.native.WorkRect;
    }
    set WorkRect(v) {
        this.native.WorkRect.Min.Set(v.Min.x, v.Min.y);
        this.native.WorkRect.Max.Set(v.Max.x, v.Max.y);
    }
    get InnerRect() {
        return this.native.InnerRect;
    }
    set InnerRect(v) {
        this.native.InnerRect.Min.Set(v.Min.x, v.Min.y);
        this.native.InnerRect.Max.Set(v.Max.x, v.Max.y);
    }
    get Scroll() {
        return this.native.Scroll;
    }
    set Scroll(v) {
        this.native.Scroll.Set(v.x, v.y);
    }
    get ScrollMax() {
        return this.native.ScrollMax;
    }
    set ScrollMax(v) {
        this.native.ScrollMax.Set(v.x, v.y);
    }
    get ScrollTarget() {
        return this.native.ScrollTarget;
    }
    set ScrollTarget(v) {
        this.native.ScrollTarget.Set(v.x, v.y);
    }
    get ScrollTargetCenterRatio() {
        return this.native.ScrollTargetCenterRatio;
    }
    set ScrollTargetCenterRatio(v) {
        this.native.ScrollTargetCenterRatio.Set(v.x, v.y);
    }
    get ScrollTargetEdgeSnapDist() {
        return this.native.ScrollTargetEdgeSnapDist;
    }
    set ScrollTargetEdgeSnapDist(v) {
        this.native.ScrollTargetEdgeSnapDist.Set(v.x, v.y);
    }
    get ScrollbarSizes() {
        return this.native.ScrollbarSizes;
    }
    set ScrollbarSizes(v) {
        this.native.ScrollbarSizes.Set(v.x, v.y);
    }
    get ScrollbarX() {
        return this.native.ScrollbarX;
    }
    get ScrollbarY() {
        return this.native.ScrollbarY;
    }
    get Active() {
        return this.native.Active;
    }
    get WasActive() {
        return this.native.WasActive;
    }
    get ItemWidthDefault() {
        return this.native.ItemWidthDefault;
    }
    set ItemWidthDefault(v) {
        this.native.ItemWidthDefault = v;
    }
    get ParentWindow() {
        return this.native.ParentWindow ? new ImGuiWindow(this.native.ParentWindow) : null;
    }
    get RootWindow() {
        return this.native.RootWindow ? new ImGuiWindow(this.native.RootWindow) : null;
    }
    get RootWindowForTitleBarHighlight() {
        return this.native.RootWindowForTitleBarHighlight ? new ImGuiWindow(this.native.RootWindowForTitleBarHighlight) : null;
    }
    get RootWindowForNav() {
        return this.native.RootWindowForNav ? new ImGuiWindow(this.native.RootWindowForNav) : null;
    }
}
function GetCurrentWindow() {
    return new ImGuiWindow(bind.GetCurrentWindow());
}
function GetHoveredWindow() {
    return bind.GetHoveredWindow() ? new ImGuiWindow(bind.GetHoveredWindow()) : null;
}
function GetHoveredId() {
    return bind.GetHoveredId();
}
function GetActiveId() {
    return bind.GetActiveId();
}
function GetInputTextId() {
    return bind.GetInputTextId();
}

class Renderer {
    /** @internal */ static VERTEX_BUFFER_SIZE = 8192;
    /** @internal */ static INDEX_BUFFER_SIZE = 16384;
    /** @internal */ _device;
    /** @internal */ _primitiveBuffer;
    /** @internal */ _activeBuffer;
    /** @internal */ _drawPosition;
    /** @internal */ _indexPosition;
    /** @internal */ _drawCount;
    /** @internal */ _indexCount;
    /** @internal */ _currentTexture;
    /** @internal */ _program;
    /** @internal */ _textureSampler;
    /** @internal */ _programTexture;
    /** @internal */ _bindGroup;
    /** @internal */ _bindGroupTexture;
    /** @internal */ _renderStateSet;
    /** @internal */ _vertexCache;
    /** @internal */ _indexCache;
    /** @internal */ _projectionMatrix;
    /** @internal */ _flipMatrix;
    /** @internal */ _scissor;
    /** @internal */ _clearBeforeRender;
    /**
   * Creates a renderer instance
   * @param device - The render device
   */ constructor(device){
        this._device = device;
        this._projectionMatrix = new Matrix4x4();
        this._flipMatrix = new Matrix4x4();
        this._program = this.createProgram(false);
        this._programTexture = this.createProgram(true);
        this._bindGroup = this._device.createBindGroup(this._program.bindGroupLayouts[0]);
        this._bindGroupTexture = this._device.createBindGroup(this._programTexture.bindGroupLayouts[0]);
        this._textureSampler = this._device.createSampler({
            magFilter: 'nearest',
            minFilter: 'nearest',
            mipFilter: 'none'
        });
        this._renderStateSet = this.createStateSet();
        this._primitiveBuffer = [];
        this._activeBuffer = 0;
        this._vertexCache = new Uint8Array(Renderer.VERTEX_BUFFER_SIZE * 20);
        this._indexCache = new Uint16Array(Renderer.INDEX_BUFFER_SIZE);
        for(let i = 0; i < 2; i++){
            const opt = {
                vertexBuffers: [
                    {
                        buffer: this._device.createInterleavedVertexBuffer([
                            'position_f32x2',
                            'tex0_f32x2',
                            'diffuse_u8normx4'
                        ], this._vertexCache, {
                            dynamic: true
                        })
                    }
                ],
                indexBuffer: this._device.createIndexBuffer(this._indexCache, {
                    dynamic: true
                })
            };
            this._primitiveBuffer.push(this._device.createVertexLayout(opt));
        }
        this._drawPosition = 0;
        this._indexPosition = 0;
        this._drawCount = 0;
        this._indexCount = 0;
        this._scissor = [
            0,
            0,
            0,
            0
        ];
        this._currentTexture = null;
        this._clearBeforeRender = false;
    }
    /** Gets the render device */ get device() {
        return this._device;
    }
    get clearBeforeRender() {
        return this._clearBeforeRender;
    }
    set clearBeforeRender(val) {
        this._clearBeforeRender = val;
    }
    /** Disposes this renderer */ dispose() {
        this._primitiveBuffer = null;
        this._vertexCache = null;
        this._device = null;
    }
    /** @internal */ getCanvas() {
        return this._device.canvas;
    }
    /** @internal */ getDrawingBufferWidth() {
        return this._device.deviceToScreen(this._device.getDrawingBufferWidth());
    }
    /** @internal */ getDrawingBufferHeight() {
        return this._device.deviceToScreen(this._device.getDrawingBufferHeight());
    }
    /** @internal */ screenToDevice(val) {
        return this._device.screenToDevice(val);
    }
    /** @internal */ deviceToScreen(val) {
        return this._device.deviceToScreen(val);
    }
    /** @internal */ createTexture(width, height, color, linear) {
        const tex = this._device.createTexture2D(linear ? 'rgba8unorm' : 'rgba8unorm-srgb', width, height, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        if (color) {
            this.clearTexture(tex, color);
        }
        return tex;
    }
    /** @internal */ clearTexture(tex, color) {
        const pixels = new Uint8Array(tex.width * tex.height * 4);
        const r = Math.round(color.r * 255);
        const g = Math.round(color.g * 255);
        const b = Math.round(color.b * 255);
        const a = Math.round(color.a * 255);
        for(let i = 0; i < tex.width * tex.height; i++){
            pixels[i * 4 + 0] = r;
            pixels[i * 4 + 1] = g;
            pixels[i * 4 + 2] = b;
            pixels[i * 4 + 3] = a;
        }
        tex.update(pixels, 0, 0, tex.width, tex.height);
    }
    /** @internal */ updateTextureWithImage(texture, bitmap, x, y) {
        const originValues = new Uint8Array(bitmap.data.buffer);
        console.assert(texture.format === 'rgba8unorm');
        texture.update(originValues, x, y, bitmap.width, bitmap.height);
    }
    /** @internal */ updateTextureWithCanvas(texture, ctx, cvsOffsetX, cvsOffsetY, w, h, x, y) {
        texture.updateFromElement(ctx.canvas, x, y, cvsOffsetX, cvsOffsetY, w, h);
    }
    /** @internal */ getTextureWidth(texture) {
        return texture.width;
    }
    /** @internal */ getTextureHeight(texture) {
        return texture.height;
    }
    /** @internal */ disposeTexture(texture) {
        texture?.dispose();
    }
    /** @internal */ setCursorStyle(style) {
        this.getCanvas().style.cursor = style;
    }
    /** @internal */ getCursorStyle() {
        return this.getCanvas().style.cursor;
    }
    /** @internal */ stream(vertexData, indexData, indexOffset, indexCount, texture, scissor) {
        let tex = texture || null;
        if (tex?.disposed) {
            tex = null;
        }
        const vertexCount = vertexData.length / 20;
        const overflow = this._drawPosition + vertexCount > Renderer.VERTEX_BUFFER_SIZE || this._indexPosition + indexCount > Renderer.INDEX_BUFFER_SIZE;
        if (overflow) {
            this._drawPosition = 0;
            this._indexPosition = 0;
            this._activeBuffer = 1 - this._activeBuffer;
        }
        const vertexLayout = this._primitiveBuffer[this._activeBuffer];
        const alignedIndexCount = indexCount + 1 & ~1;
        if (indexData.length < indexOffset + alignedIndexCount) {
            const alignedIndexData = new Uint16Array(alignedIndexCount);
            alignedIndexData.set(indexData.subarray(indexOffset));
            indexData = alignedIndexData;
            indexOffset = 0;
        }
        const vertexBuffer = vertexLayout.getVertexBuffer('position');
        vertexBuffer.bufferSubData(this._drawPosition * 20, vertexData, 0, vertexCount * 20);
        vertexLayout.getIndexBuffer().bufferSubData(this._indexPosition * 2, indexData, indexOffset, alignedIndexCount);
        vertexLayout.setDrawOffset(vertexBuffer, this._drawPosition * 20);
        if (texture) {
            this._device.setProgram(this._programTexture);
            this._bindGroupTexture.setTexture('tex', texture, this._textureSampler);
            this._device.setBindGroup(0, this._bindGroupTexture);
        } else {
            this._device.setProgram(this._program);
            this._device.setBindGroup(0, this._bindGroup);
        }
        this._device.setRenderStates(this._renderStateSet);
        this._device.setVertexLayout(vertexLayout);
        this._device.setScissor(scissor);
        vertexLayout.draw('triangle-list', this._indexPosition, indexCount);
        this._drawPosition += vertexCount;
        this._indexPosition += alignedIndexCount;
    }
    /** @internal */ beginRender() {
        const vp = this._device.getViewport();
        //this._device.setViewport();
        //this._device.setScissor();
        this._projectionMatrix.ortho(0, vp.width, 0, vp.height, -1, 1);
        this._flipMatrix = Matrix4x4.translation(new Vector3(0, vp.height, 0)).scaleRight(new Vector3(1, -1, 1));
        const mvpMatrix = Matrix4x4.multiply(this._projectionMatrix, this._flipMatrix);
        this._bindGroup.setValue('mvpMatrix', mvpMatrix);
        this._bindGroupTexture.setValue('mvpMatrix', mvpMatrix);
        if (this._clearBeforeRender) {
            this._device.clearFrameBuffer(new Vector4(0, 0, 0, 1), 1, 0);
        }
    }
    /** @internal */ endRender() {}
    /** @internal */ createStateSet() {
        const rs = this._device.createRenderStateSet();
        rs.useBlendingState().enable(true).setBlendFunc('one', 'inv-src-alpha');
        rs.useDepthState().enableTest(false).enableWrite(false);
        rs.useRasterizerState().setCullMode('none');
        return rs;
    }
    /** @internal */ createProgram(diffuseMap) {
        return this._device.buildRenderProgram({
            label: 'UI',
            vertex (pb) {
                this.$inputs.pos = pb.vec2().attrib('position');
                this.$inputs.uv = pb.vec2().attrib('texCoord0');
                this.$inputs.diffuse = pb.vec4().attrib('diffuse');
                this.$outputs.outDiffuse = pb.vec4();
                if (diffuseMap) {
                    this.$outputs.outUV = pb.vec2();
                }
                this.mvpMatrix = pb.mat4().uniform(0);
                pb.main(function() {
                    this.$builtins.position = pb.mul(this.mvpMatrix, pb.vec4(this.$inputs.pos, 0, 1));
                    this.$outputs.outDiffuse = this.$inputs.diffuse;
                    if (diffuseMap) {
                        this.$outputs.outUV = this.$inputs.uv;
                    }
                });
            },
            fragment (pb) {
                this.$outputs.outColor = pb.vec4();
                if (diffuseMap) {
                    this.tex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                }
                pb.main(function() {
                    if (diffuseMap) {
                        this.$l.color = pb.mul(pb.textureSample(this.tex, this.$inputs.outUV), this.$inputs.outDiffuse);
                    } else {
                        this.$l.color = this.$inputs.outDiffuse;
                    }
                    this.$outputs.outColor = pb.vec4(pb.mul(this.color.rgb, this.color.a), this.color.a);
                });
            }
        });
    }
}

class Input {
    _dom_input;
    constructor(){
        this._dom_input = document.createElement('input');
        this._dom_input.style.position = 'fixed';
        this._dom_input.style.top = -10000 + 'px';
        this._dom_input.style.left = -10000 + 'px';
        this._dom_input.addEventListener('keydown', (e)=>{
            this.onKeydown(e);
        });
        this._dom_input.addEventListener('keyup', (e)=>{
            this.onKeyup(e);
        });
        this._dom_input.addEventListener('keypress', (e)=>{
            this.onKeypress(e);
        });
        this._dom_input.addEventListener('compositionend', (e)=>{
            this.onCompositionEnd(e);
        });
        document.body.appendChild(this._dom_input);
    }
    onKeydown(e) {
        canvas_on_keydown(e);
    }
    onKeyup(e) {
        canvas_on_keyup(e);
    }
    onKeypress(e) {
        e.preventDefault();
        console.log(`key pressed: `);
        console.log(e);
        canvas_on_keypress(e);
    }
    onCompositionEnd(e) {
        e.preventDefault();
        for(let i = 0; i < e.data.length; i++){
            const io = GetIO();
            io.AddInputCharacter(e.data.charCodeAt(i));
        }
    }
    blur() {
        this._dom_input.blur();
    }
    focus() {
        this._dom_input.focus();
    }
}

let clipboard_text = '';
let renderer = null;
let prev_time = 0;
let g_FontTexture = null;
let glyphManager = null;
const fonts = {};
/*
function document_on_copy(event: ClipboardEvent): void {
    if (event.clipboardData) {
        event.clipboardData.setData("text/plain", clipboard_text);
    }
    // console.log(`${event.type}: "${clipboard_text}"`);
    event.preventDefault();
}

function document_on_cut(event: ClipboardEvent): void {
    if (event.clipboardData) {
        event.clipboardData.setData("text/plain", clipboard_text);
    }
    // console.log(`${event.type}: "${clipboard_text}"`);
    event.preventDefault();
}

function document_on_paste(event: ClipboardEvent): void {
    if (event.clipboardData) {
        clipboard_text = event.clipboardData.getData("text/plain");
    }
    // console.log(`${event.type}: "${clipboard_text}"`);
    event.preventDefault();
}
*/ function window_on_resize() {}
function window_on_gamepadconnected(event /* GamepadEvent */ ) {
    console.log('Gamepad connected at index %d: %s. %d buttons, %d axes.', event.gamepad.index, event.gamepad.id, event.gamepad.buttons.length, event.gamepad.axes.length);
}
function window_on_gamepaddisconnected(event /* GamepadEvent */ ) {
    console.log('Gamepad disconnected at index %d: %s.', event.gamepad.index, event.gamepad.id);
}
function canvas_on_blur(event) {
    const io = GetIO();
    io.KeyCtrl = false;
    io.KeyShift = false;
    io.KeyAlt = false;
    io.KeySuper = false;
    for(let i = 0; i < io.KeysDown.length; ++i){
        io.KeysDown[i] = false;
    }
    for(let i = 0; i < io.MouseDown.length; ++i){
        io.MouseDown[i] = false;
    }
    console.log('canvas_on_blur');
}
const key_code_to_index = {
    Tab: 9,
    Backspace: 8,
    Space: 32,
    Insert: 45,
    Delete: 46,
    Home: 36,
    End: 35,
    PageUp: 33,
    PageDown: 34,
    Enter: 13,
    Escape: 27,
    ArrowLeft: 37,
    ArrowUp: 38,
    ArrowRight: 39,
    ArrowDown: 40,
    NumpadEnter: 176,
    KeyA: 65,
    KeyC: 67,
    KeyV: 86,
    KeyX: 88,
    KeyY: 89,
    KeyZ: 90
};
function canvas_on_keydown(event) {
    const key_index = key_code_to_index[event.code];
    if (key_index) {
        //console.log(event.type, event.key, event.code, key_index);
        const io = GetIO();
        io.KeyCtrl = event.ctrlKey;
        io.KeyShift = event.shiftKey;
        io.KeyAlt = event.altKey;
        io.KeySuper = event.metaKey;
        ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(io.KeysDown));
        io.KeysDown[key_index] = true;
        // forward to the keypress event
        if (key_index == 9 || io.WantCaptureKeyboard || io.WantTextInput) {
            return true;
        }
    }
    return false;
}
function canvas_on_keyup(event) {
    const key_index = key_code_to_index[event.code];
    if (key_index) {
        //console.log(event.type, event.key, event.code, key_index);
        const io = GetIO();
        io.KeyCtrl = event.ctrlKey;
        io.KeyShift = event.shiftKey;
        io.KeyAlt = event.altKey;
        io.KeySuper = event.metaKey;
        ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(io.KeysDown));
        io.KeysDown[key_index] = false;
        if (io.WantCaptureKeyboard || io.WantTextInput || key_index == 9) {
            return true;
        }
    }
    return false;
}
function canvas_on_keypress(event) {
    //console.log(event);
    const io = GetIO();
    io.AddInputCharacter(event.charCode);
    if (io.WantCaptureKeyboard || io.WantTextInput) {
        return true;
    }
    return false;
}
function canvas_on_pointermove(event) {
    const io = GetIO();
    io.MousePos.x = event.offsetX;
    io.MousePos.y = event.offsetY;
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
// MouseEvent.button
// A number representing a given button:
// 0: Main button pressed, usually the left button or the un-initialized state
// 1: Auxiliary button pressed, usually the wheel button or the middle button (if present)
// 2: Secondary button pressed, usually the right button
// 3: Fourth button, typically the Browser Back button
// 4: Fifth button, typically the Browser Forward button
const mouse_button_map = [
    0,
    2,
    1,
    3,
    4
];
function canvas_on_pointerdown(event) {
    const io = GetIO();
    io.MousePos.x = event.offsetX;
    io.MousePos.y = event.offsetY;
    io.MouseDown[mouse_button_map[event.button]] = true;
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function canvas_on_contextmenu(event) {
    const io = GetIO();
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function canvas_on_pointerup(event) {
    const io = GetIO();
    io.MouseDown[mouse_button_map[event.button]] = false;
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function canvas_on_wheel(event) {
    const io = GetIO();
    let scale = 1.0;
    switch(event.deltaMode){
        case event.DOM_DELTA_PIXEL:
            scale = 0.01;
            break;
        case event.DOM_DELTA_LINE:
            scale = 0.2;
            break;
        case event.DOM_DELTA_PAGE:
            scale = 1.0;
            break;
    }
    io.MouseWheelH = event.deltaX * scale;
    io.MouseWheel = -event.deltaY * scale; // Mouse wheel: 1 unit scrolls about 5 lines text.
    if (io.WantCaptureMouse) {
        return true;
    }
    return false;
}
function injectKeyEvent(ev) {
    if (ev.type === 'keydown') {
        return canvas_on_keydown(ev);
    } else if (ev.type === 'keyup') {
        return canvas_on_keyup(ev);
    } else if (ev.type === 'keypress') {
        return canvas_on_keypress(ev);
    }
    return false;
}
function injectWheelEvent(ev) {
    return canvas_on_wheel(ev);
}
function injectPointerEvent(ev) {
    if (ev.type === 'pointermove') {
        return canvas_on_pointermove(ev);
    } else if (ev.type === 'pointerdown') {
        return canvas_on_pointerdown(ev);
    } else if (ev.type === 'pointerup') {
        return canvas_on_pointerup(ev);
    }
    return false;
}
/*
function canvas_on_contextlost(e:Event):void {
    e.preventDefault();
    console.log("canvas_on_contextlost");
    is_contextlost=true;
}

function canvas_on_contextrestored(e:Event):void {
    console.log("canvas_on_contextrestored");
    is_contextlost=false;
}
*/ function Init(device) {
    const io = GetIO();
    if (typeof window !== 'undefined') {
        io.BackendPlatformName = 'imgui_impl_browser';
        LoadIniSettingsFromMemory(window.localStorage.getItem('imgui.ini') || '');
    } else {
        io.BackendPlatformName = 'imgui_impl_console';
    }
    if (typeof navigator !== 'undefined') {
        io.ConfigMacOSXBehaviors = navigator.platform.match(/Mac/) !== null;
    }
    /*
    if (typeof(document) !== "undefined") {
        document.body.addEventListener("copy", document_on_copy);
        document.body.addEventListener("cut", document_on_cut);
        document.body.addEventListener("paste", document_on_paste);
    }
    */ io.SetClipboardTextFn = (user_data, text)=>{
        clipboard_text = text;
        // console.log(`set clipboard_text: "${clipboard_text}"`);
        if (typeof navigator !== 'undefined' && typeof navigator.clipboard !== 'undefined') {
            // console.log(`clipboard.writeText: "${clipboard_text}"`);
            navigator.clipboard.writeText(clipboard_text).then(()=>{
            // console.log(`clipboard.writeText: "${clipboard_text}" done.`);
            });
        }
    };
    io.GetClipboardTextFn = (user_data)=>{
        // if (typeof navigator !== "undefined" && typeof (navigator as any).clipboard !== "undefined") {
        //     console.log(`clipboard.readText: "${clipboard_text}"`);
        //     (navigator as any).clipboard.readText().then((text: string): void => {
        //         clipboard_text = text;
        //         console.log(`clipboard.readText: "${clipboard_text}" done.`);
        //     });
        // }
        // console.log(`get clipboard_text: "${clipboard_text}"`);
        return clipboard_text;
    };
    io.ClipboardUserData = null;
    if (typeof window !== 'undefined') {
        window.addEventListener('resize', window_on_resize);
        window.addEventListener('gamepadconnected', window_on_gamepadconnected);
        window.addEventListener('gamepaddisconnected', window_on_gamepaddisconnected);
    }
    renderer = new Renderer(device);
    glyphManager = new GlyphManager(device, 1024, 1024, 1);
    renderer.device.canvas.style.touchAction = 'none'; // Disable browser handling of all panning and zooming gestures.
    renderer.device.canvas.addEventListener('blur', canvas_on_blur);
    renderer.device.canvas.addEventListener('contextmenu', canvas_on_contextmenu);
    // Setup back-end capabilities flags
    io.BackendFlags |= ImGuiBackendFlags.HasMouseCursors; // We can honor GetMouseCursor() values (optional)
    // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array.
    io.KeyMap[ImGuiKey.Tab] = 9;
    io.KeyMap[ImGuiKey.LeftArrow] = 37;
    io.KeyMap[ImGuiKey.RightArrow] = 39;
    io.KeyMap[ImGuiKey.UpArrow] = 38;
    io.KeyMap[ImGuiKey.DownArrow] = 40;
    io.KeyMap[ImGuiKey.PageUp] = 33;
    io.KeyMap[ImGuiKey.PageDown] = 34;
    io.KeyMap[ImGuiKey.Home] = 36;
    io.KeyMap[ImGuiKey.End] = 35;
    io.KeyMap[ImGuiKey.Insert] = 45;
    io.KeyMap[ImGuiKey.Delete] = 46;
    io.KeyMap[ImGuiKey.Backspace] = 8;
    io.KeyMap[ImGuiKey.Space] = 32;
    io.KeyMap[ImGuiKey.Enter] = 13;
    io.KeyMap[ImGuiKey.Escape] = 27;
    io.KeyMap[ImGuiKey.KeyPadEnter] = key_code_to_index['NumpadEnter'];
    io.KeyMap[ImGuiKey.A] = 65;
    io.KeyMap[ImGuiKey.C] = 67;
    io.KeyMap[ImGuiKey.V] = 86;
    io.KeyMap[ImGuiKey.X] = 88;
    io.KeyMap[ImGuiKey.Y] = 89;
    io.KeyMap[ImGuiKey.Z] = 90;
    CreateDeviceObjects();
}
function NewFrame(time) {
    const io = GetIO();
    if (io.WantSaveIniSettings) {
        io.WantSaveIniSettings = false;
        if (typeof window !== 'undefined') {
            window.localStorage.setItem('imgui.ini', SaveIniSettingsToMemory());
        }
    }
    const viewport = renderer.device.getViewport();
    const w = viewport.width;
    const h = viewport.height;
    const display_w = w * renderer.device.getScale();
    const display_h = h * renderer.device.getScale();
    io.DisplaySize.x = w;
    io.DisplaySize.y = h;
    io.DisplayFramebufferScale.x = w > 0 ? display_w / w : 0;
    io.DisplayFramebufferScale.y = h > 0 ? display_h / h : 0;
    const dt = prev_time === 0 ? 0 : time - prev_time;
    prev_time = time;
    io.DeltaTime = dt / 1000;
    if (io.WantSetMousePos) {
        console.log('TODO: MousePos', io.MousePos.x, io.MousePos.y);
    }
    if (typeof document !== 'undefined') {
        if (io.MouseDrawCursor) {
            document.body.style.cursor = 'none';
        } else {
            switch(GetMouseCursor()){
                case ImGuiMouseCursor.None:
                    document.body.style.cursor = 'none';
                    break;
                default:
                case ImGuiMouseCursor.Arrow:
                    document.body.style.cursor = 'default';
                    break;
                case ImGuiMouseCursor.TextInput:
                    document.body.style.cursor = 'text';
                    break; // When hovering over InputText, etc.
                case ImGuiMouseCursor.ResizeAll:
                    document.body.style.cursor = 'all-scroll';
                    break; // Unused
                case ImGuiMouseCursor.ResizeNS:
                    document.body.style.cursor = 'ns-resize';
                    break; // When hovering over an horizontal border
                case ImGuiMouseCursor.ResizeEW:
                    document.body.style.cursor = 'ew-resize';
                    break; // When hovering over a vertical border or a column
                case ImGuiMouseCursor.ResizeNESW:
                    document.body.style.cursor = 'nesw-resize';
                    break; // When hovering over the bottom-left corner of a window
                case ImGuiMouseCursor.ResizeNWSE:
                    document.body.style.cursor = 'nwse-resize';
                    break; // When hovering over the bottom-right corner of a window
                case ImGuiMouseCursor.Hand:
                    document.body.style.cursor = 'move';
                    break;
                case ImGuiMouseCursor.NotAllowed:
                    document.body.style.cursor = 'not-allowed';
                    break;
            }
        }
    }
    // Gamepad navigation mapping [BETA]
    for(let i = 0; i < io.NavInputs.length; ++i){
    // TODO: This is currently causing an issue and I have no gamepad to test with.
    //       The error is: ''set' on proxy: trap returned falsish for property '21'
    //       I think that the NavInputs are zeroed out by ImGui at the start of each frame anyway
    //       so I am not sure if the following is even necessary.
    //io.NavInputs[i] = 0.0;
    }
    if (io.ConfigFlags & ImGuiConfigFlags.NavEnableGamepad) {
        // Update gamepad inputs
        const gamepads = typeof navigator !== 'undefined' && typeof navigator.getGamepads === 'function' ? navigator.getGamepads() : [];
        for(let i = 0; i < gamepads.length; ++i){
            const gamepad = gamepads[i];
            if (!gamepad) {
                continue;
            }
            io.BackendFlags |= ImGuiBackendFlags.HasGamepad;
            const buttons_count = gamepad.buttons.length;
            const axes_count = gamepad.axes.length;
            const MAP_BUTTON = function MAP_BUTTON(NAV_NO, BUTTON_NO) {
                if (!gamepad) {
                    return;
                }
                if (buttons_count > BUTTON_NO && gamepad.buttons[BUTTON_NO].pressed) io.NavInputs[NAV_NO] = 1.0;
            };
            const MAP_ANALOG = function MAP_ANALOG(NAV_NO, AXIS_NO, V0, V1) {
                if (!gamepad) {
                    return;
                }
                let v = axes_count > AXIS_NO ? gamepad.axes[AXIS_NO] : V0;
                v = (v - V0) / (V1 - V0);
                if (v > 1.0) v = 1.0;
                if (io.NavInputs[NAV_NO] < v) io.NavInputs[NAV_NO] = v;
            };
            // TODO: map input based on vendor and product id
            // https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/id
            const match = gamepad.id.match(/^([0-9a-f]{4})-([0-9a-f]{4})-.*$/);
            const match_chrome = gamepad.id.match(/^.*\(.*Vendor: ([0-9a-f]{4}) Product: ([0-9a-f]{4})\).*$/);
            const vendor = match && match[1] || match_chrome && match_chrome[1] || '0000';
            const product = match && match[2] || match_chrome && match_chrome[2] || '0000';
            switch(vendor + product){
                case '046dc216':
                    MAP_BUTTON(ImGuiNavInput.Activate, 1); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 2); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 0); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_ANALOG(ImGuiNavInput.DpadLeft, 4, -0.3, -0.9); // D-Pad Left
                    MAP_ANALOG(ImGuiNavInput.DpadRight, 4, +0.3, +0.9); // D-Pad Right
                    MAP_ANALOG(ImGuiNavInput.DpadUp, 5, -0.3, -0.9); // D-Pad Up
                    MAP_ANALOG(ImGuiNavInput.DpadDown, 5, +0.3, +0.9); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 4); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 5); // R1 / RB
                    MAP_BUTTON(ImGuiNavInput.TweakSlow, 6); // L2 / LT
                    MAP_BUTTON(ImGuiNavInput.TweakFast, 7); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
                case '046dc21d':
                    MAP_BUTTON(ImGuiNavInput.Activate, 0); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 1); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 2); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_BUTTON(ImGuiNavInput.DpadLeft, 14); // D-Pad Left
                    MAP_BUTTON(ImGuiNavInput.DpadRight, 15); // D-Pad Right
                    MAP_BUTTON(ImGuiNavInput.DpadUp, 12); // D-Pad Up
                    MAP_BUTTON(ImGuiNavInput.DpadDown, 13); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 4); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 5); // R1 / RB
                    MAP_ANALOG(ImGuiNavInput.TweakSlow, 6, +0.3, +0.9); // L2 / LT
                    MAP_ANALOG(ImGuiNavInput.TweakFast, 7, +0.3, +0.9); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
                case '2dc86001':
                case '2dc86101':
                    MAP_BUTTON(ImGuiNavInput.Activate, 1); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 0); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 4); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_ANALOG(ImGuiNavInput.DpadLeft, 6, -0.3, -0.9); // D-Pad Left
                    MAP_ANALOG(ImGuiNavInput.DpadRight, 6, +0.3, +0.9); // D-Pad Right
                    MAP_ANALOG(ImGuiNavInput.DpadUp, 7, -0.3, -0.9); // D-Pad Up
                    MAP_ANALOG(ImGuiNavInput.DpadDown, 7, +0.3, +0.9); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 6); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 7); // R1 / RB
                    MAP_BUTTON(ImGuiNavInput.TweakSlow, 8); // L2 / LT
                    MAP_BUTTON(ImGuiNavInput.TweakFast, 9); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
                default:
                    MAP_BUTTON(ImGuiNavInput.Activate, 0); // Cross / A
                    MAP_BUTTON(ImGuiNavInput.Cancel, 1); // Circle / B
                    MAP_BUTTON(ImGuiNavInput.Menu, 2); // Square / X
                    MAP_BUTTON(ImGuiNavInput.Input, 3); // Triangle / Y
                    MAP_BUTTON(ImGuiNavInput.DpadLeft, 14); // D-Pad Left
                    MAP_BUTTON(ImGuiNavInput.DpadRight, 15); // D-Pad Right
                    MAP_BUTTON(ImGuiNavInput.DpadUp, 12); // D-Pad Up
                    MAP_BUTTON(ImGuiNavInput.DpadDown, 13); // D-Pad Down
                    MAP_BUTTON(ImGuiNavInput.FocusPrev, 4); // L1 / LB
                    MAP_BUTTON(ImGuiNavInput.FocusNext, 5); // R1 / RB
                    MAP_BUTTON(ImGuiNavInput.TweakSlow, 6); // L2 / LT
                    MAP_BUTTON(ImGuiNavInput.TweakFast, 7); // R2 / RT
                    MAP_ANALOG(ImGuiNavInput.LStickLeft, 0, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickRight, 0, +0.3, +0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickUp, 1, -0.3, -0.9);
                    MAP_ANALOG(ImGuiNavInput.LStickDown, 1, +0.3, +0.9);
                    break;
            }
        }
    }
}
async function font_update(io) {
    io.Fonts.Fonts.forEach((font)=>{
        const fontName = font.FontSize + 'px ' + font.FontName;
        let deviceFont = fonts[fontName];
        if (!deviceFont) {
            deviceFont = new Font(fontName, renderer.device.getScale());
            fonts[fontName] = deviceFont;
        }
        let glyph = font.GlyphToCreate;
        while(glyph){
            const glyphInfo = glyphManager.getGlyphInfo(String.fromCharCode(glyph.Char), deviceFont);
            glyph.X0 = 0;
            glyph.X1 = glyphInfo.width;
            glyph.Y0 = 0;
            glyph.Y1 = glyphInfo.height;
            glyph.AdvanceX = glyphInfo.width + (glyph.Char < 256 ? font.SpaceX[0] : font.SpaceX[1]);
            glyph.U0 = glyphInfo.uMin;
            glyph.U1 = glyphInfo.uMax;
            glyph.V0 = glyphInfo.vMin;
            glyph.V1 = glyphInfo.vMax;
            glyph.TextureID = glyphManager.getAtlasTexture(glyphInfo.atlasIndex);
            font.GlyphCreated(glyph);
            glyph = font.GlyphToCreate;
        }
    });
}
let current_window_id = 0;
const scroll_acc = new ImVec2(0, 0);
let mouse_first_down = false;
function scroll_update(io) {
    const hoveredWin = GetHoveredWindow();
    const hoveredId = GetHoveredId();
    if (hoveredWin && hoveredId == 0) {
        if (current_window_id != hoveredWin.ID) {
            current_window_id = hoveredWin.ID;
            scroll_acc.Set(0, 0);
            mouse_first_down = true;
        }
        if (hoveredWin.Flags & ImGuiWindowFlags.NoMove) {
            let first_down = false;
            if (io.MouseDown[0]) {
                first_down = mouse_first_down;
                mouse_first_down = false;
            } else {
                mouse_first_down = true;
            }
            const scroll = new ImVec2(hoveredWin.Scroll.x, hoveredWin.Scroll.y);
            if (hoveredWin.ScrollbarY) {
                if (io.MouseDown[0] && !first_down) {
                    scroll.y -= io.MouseDelta.y;
                    scroll_acc.y = io.MouseDelta.y;
                } else if (Math.abs(scroll_acc.y) > 1) {
                    scroll.y -= scroll_acc.y;
                    scroll_acc.y *= 0.8;
                }
                if (scroll.y < 0) scroll.y = 0;
                else if (scroll.y > hoveredWin.ScrollMax.y) {
                    scroll.y = hoveredWin.ScrollMax.y;
                }
                hoveredWin.Scroll = scroll;
            }
            if (hoveredWin.ScrollbarX) {
                if (io.MouseDown[0]) {
                    scroll.x -= io.MouseDelta.x;
                    scroll_acc.x = io.MouseDelta.x;
                }
                if (scroll.x < 0) scroll.x = 0;
                else if (scroll.x > hoveredWin.ScrollMax.x) {
                    scroll.x = hoveredWin.ScrollMax.x;
                }
                hoveredWin.Scroll = scroll;
            }
        }
    }
}
let dom_input;
function input_text_update(io) {
    const activeId = GetActiveId();
    const inpId = GetInputTextId();
    if (!activeId || activeId != inpId) {
        dom_input?.blur();
    } else {
        if (!dom_input) {
            dom_input = new Input();
        }
        dom_input.focus();
    }
}
function RenderDrawData(draw_data = GetDrawData()) {
    const io = GetIO();
    font_update(io);
    scroll_update(io);
    input_text_update();
    if (draw_data === null) {
        throw new Error();
    }
    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
    const fb_width = io.DisplaySize.x * io.DisplayFramebufferScale.x;
    const fb_height = io.DisplaySize.y * io.DisplayFramebufferScale.y;
    if (fb_width === 0 || fb_height === 0) {
        return;
    }
    draw_data.ScaleClipRects(io.DisplayFramebufferScale);
    // Draw
    const pos = draw_data.DisplayPos;
    const scissorOld = renderer.device.getScissor();
    renderer.beginRender();
    draw_data.IterateDrawLists((draw_list)=>{
        const vx = draw_list.VtxBuffer;
        const ix = draw_list.IdxBuffer;
        const ixU16 = new Uint16Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset + ix.byteLength));
        let indexOffset = 0;
        draw_list.IterateDrawCmds((draw_cmd)=>{
            if (draw_cmd.UserCallback !== null) {
                // User callback (registered via ImDrawList::AddCallback)
                draw_cmd.UserCallback(draw_list, draw_cmd);
            } else {
                const clip_rect = new ImVec4(draw_cmd.ClipRect.x - pos.x, draw_cmd.ClipRect.y - pos.y, draw_cmd.ClipRect.z - pos.x, draw_cmd.ClipRect.w - pos.y);
                if (clip_rect.x < fb_width && clip_rect.y < fb_height && clip_rect.z >= 0.0 && clip_rect.w >= 0.0) {
                    // Apply scissor/clipping rectangle
                    // renderer.device.setScissor([clip_rect.x, fb_height - clip_rect.w, clip_rect.z - clip_rect.x, clip_rect.w - clip_rect.y]);
                    const scissorX = renderer.device.deviceToScreen(clip_rect.x);
                    const scissorY = renderer.device.deviceToScreen(fb_height - clip_rect.w);
                    const scissorW = renderer.device.deviceToScreen(clip_rect.z - clip_rect.x);
                    const scissorH = renderer.device.deviceToScreen(clip_rect.w - clip_rect.y);
                    renderer.stream(vx, ixU16, indexOffset, draw_cmd.ElemCount, draw_cmd.TextureId, [
                        scissorX,
                        scissorY,
                        scissorW,
                        scissorH
                    ]);
                }
            }
            indexOffset += draw_cmd.ElemCount;
        });
    });
    renderer.device.setScissor(scissorOld);
}
function CreateFontsTexture() {
    const io = GetIO();
    // Backup GL state
    // const last_texture: WebGLTexture | null = gl && gl.getParameter(gl.TEXTURE_BINDING_2D);
    // Build texture atlas
    // const width: number = 256;
    // const height: number = 256;
    // const pixels: Uint8Array = new Uint8Array(4 * width * height).fill(0xff);
    //const { width, height, pixels } = io.Fonts.GetTexDataAsRGBA32();   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
    const { width, height, pixels } = io.Fonts.GetTexDataAsAlpha8();
    if (width && height && pixels) {
        const rgba8 = new Uint8Array(width * height * 4);
        let i = 0;
        pixels.forEach((p)=>{
            rgba8[i++] = 0xff;
            rgba8[i++] = 0xff;
            rgba8[i++] = 0xff;
            rgba8[i++] = p;
        });
        // Upload texture to graphics system
        g_FontTexture = renderer.device.createTexture2D('rgba8unorm', width, height, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        g_FontTexture.update(rgba8, 0, 0, width, height);
        //gl && gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        // Store our identifier
        io.Fonts.TexID = g_FontTexture || null;
    // console.log("font texture id", g_FontTexture);
    }
}
function CreateDeviceObjects() {
    CreateFontsTexture();
}

/**
 * Initialize the ImGUI bindings
 *
 * @param device - The device object
 * @param fontFamily - Font family, default to arial
 * @param fontSize - Default font size, default to 16
 * @public
 */ async function imGuiInit(device, fontFamily, fontSize) {
    await imgui();
    IMGUI_CHECKVERSION();
    console.log('ImGui.CreateContext() VERSION=', IMGUI_VERSION);
    CreateContext();
    StyleColorsDark();
    const io = GetIO();
    const font = io.Fonts.AddFontDefault();
    font.FontName = fontFamily || 'arial';
    font.FontSize = fontSize || 16;
    Init(device);
}
/**
 * Starts a new frame
 * @public
 */ function imGuiNewFrame() {
    NewFrame(Date.now());
    NewFrame$1();
}
/**
 * Ends current frame
 * @public
 */ function imGuiEndFrame() {
    EndFrame();
    Render();
    RenderDrawData(GetDrawData());
}
/**
 * Injects a browser event into the GUI system
 * @param ev - The event object
 * @param type - Event type, default to ev.type if not specified.
 * @returns A boolean value indices if the event was processed by GUI system
 * @public
 */ function imGuiInjectEvent(ev, type) {
    type = type ?? ev.type;
    if (type === 'pointermove' || type === 'pointerdown' || type === 'pointerup') {
        return injectPointerEvent(ev);
    } else if (type === 'keydown' || type === 'keyup' || type === 'keypress') {
        return injectKeyEvent(ev);
    } else if (type === 'wheel') {
        return injectWheelEvent(ev);
    } else {
        return false;
    }
}

class UI {
    _deviceList;
    _deviceIndex;
    constructor(){
        this._deviceList = [
            'WebGL',
            'WebGL2',
            'WebGPU'
        ];
        this._deviceIndex = [
            this._deviceList.findIndex((val)=>val.toLowerCase() === Application.instance.device.type)
        ];
    }
    render() {
        imGuiNewFrame();
        this.renderSettings();
        this.renderStatusBar();
        imGuiEndFrame();
    }
    renderSettings() {
        SetNextWindowPos(new ImVec2(0, 0), ImGuiCond.Always);
        SetNextWindowSize(new ImVec2(300, Math.min(500, Application.instance.device.getViewport().height)), ImGuiCond.Always);
        if (Begin('Settings')) {
            BeginSection('System');
            SetNextItemWidth(150);
            if (Combo('Select device', this._deviceIndex, this._deviceList)) {
                const url = new URL(window.location.href);
                url.searchParams.set('dev', this._deviceList[this._deviceIndex[0]].toLowerCase());
                window.location.href = url.href;
            }
            EndSection(1);
            if (BeginChild('')) {
                TextWrapped('Rotate with left mouse button.');
                TextWrapped('Zoom with mouse wheel.');
                TextWrapped('Move with right mouse button.');
            }
            EndChild();
        }
        End();
    }
    renderStatusBar() {
        if (BeginStatusBar()) {
            Text(`Device: ${Application.instance.device.type}`);
            Text(`FPS: ${Application.instance.device.frameInfo.FPS.toFixed(2)}`);
            Text(`DrawCall: ${Application.instance.device.frameInfo.drawCalls}`);
            EndStatusBar();
        }
    }
}

class Demo {
    _assetManager;
    _scene;
    _terrain;
    _camera;
    _character;
    _compositor;
    _axisPZ;
    _actorTarget;
    _actorDirection;
    _actorSpeed;
    _actorRunning;
    _loaded;
    _loadPercent;
    _ui;
    constructor(){
        this._terrain = null;
        this._axisPZ = Vector3.axisPZ();
        this._actorTarget = new Vector3();
        this._actorDirection = new Vector3();
        this._actorSpeed = 6;
        this._actorRunning = false;
        this._assetManager = new AssetManager();
        this._scene = this.createScene();
        this._camera = this.createCamera(this._scene);
        this._compositor = new Compositor();
        this._compositor.appendPostEffect(new Tonemap());
        this._compositor.appendPostEffect(new Bloom());
        this._compositor.appendPostEffect(new FXAA());
        Application.instance.device.setFont('24px arial');
        this.render();
        this._loaded = false;
        this._loadPercent = 0;
        this._ui = new UI();
    }
    async fetchAssetArchive(url, progressCallback) {
        progressCallback(0);
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Download failed');
        }
        const contentLength = response.headers.get('content-length');
        const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;
        let receivedBytes = 0;
        let data = new Uint8Array(totalBytes || 1024 * 1024);
        const reader = response.body.getReader();
        if (!reader) {
            throw new Error('Download data is empty');
        }
        const read = async ()=>{
            const { done, value } = await reader.read();
            if (done) {
                return;
            }
            if (data.length < receivedBytes + value.length) {
                const newData = new Uint8Array(Math.max(2 * data.length, receivedBytes + value.length));
                newData.set(data);
                data = newData;
            }
            data.set(value, receivedBytes);
            receivedBytes += value.length;
            progressCallback(Math.floor(receivedBytes / totalBytes * 100));
            return read();
        };
        await read();
        return new Blob([
            data
        ]);
    }
    async readZip(blob) {
        const reader = new ZipReader(new BlobReader(blob));
        const entries = await reader.getEntries();
        const fileMap = new Map();
        for (const entry of entries){
            if (!entry.directory) {
                const blob = await entry.getData(new BlobWriter());
                const fileURL = URL.createObjectURL(blob);
                fileMap.set(`/${entry.filename}`, fileURL);
            }
        }
        await reader.close();
        return fileMap;
    }
    get camera() {
        return this._camera;
    }
    createScene() {
        const scene = new Scene();
        scene.env.light.type = 'ibl';
        scene.env.light.strength = 1;
        scene.env.light.radianceMap = scene.env.sky.radianceMap;
        scene.env.light.irradianceMap = scene.env.sky.irradianceMap;
        scene.env.sky.skyType = 'scatter';
        scene.env.sky.fogType = 'scatter';
        scene.env.sky.aerialPerspectiveDensity = 10;
        scene.env.sky.cloudy = 0.6;
        const light = new DirectionalLight(scene).setColor(new Vector4(1, 1, 1, 1));
        light.lookAt(new Vector3(1, 1, 1), new Vector3(0, 0, 0), Vector3.axisPY());
        light.intensity = 4;
        light.shadow.shadowMapSize = 2048;
        light.shadow.numShadowCascades = 4;
        light.shadow.shadowDistance = 300;
        light.castShadow = true;
        light.shadow.mode = 'pcf-opt';
        return scene;
    }
    createCamera(scene) {
        const camera = new PerspectiveCamera(scene, Math.PI / 3, Application.instance.device.getDrawingBufferWidth() / Application.instance.device.getDrawingBufferHeight(), 1, 1500);
        return camera;
    }
    async load() {
        this._loaded = false;
        this._loadPercent = 0;
        const zipContent = await this.fetchAssetArchive('./assets/terrain_assets.zip', (percent)=>{
            this._loadPercent = percent;
        });
        Application.instance.device.runNextFrame(async ()=>{
            const fileMap = await this.readZip(zipContent);
            this._assetManager.httpRequest.urlResolver = (url)=>fileMap.get(url) || url;
            // load world
            this._terrain = await this.loadTerrain(this._scene, this._assetManager);
            this._character = await this.loadCharacter(this._scene, this._assetManager);
            // initialize
            this._camera.parent = this._terrain;
            this._character.group.parent = this._terrain;
            const x = this._terrain.scaledWidth * 0.37;
            const z = this._terrain.scaledHeight * 0.19;
            const y = this._terrain.getElevation(x, z);
            this._character.group.position.setXYZ(x, y, z);
            this._character.animationSet.playAnimation('idle01_yindao', 0);
            const eyePos = new Vector3(x + 1, y + 5, z - 21);
            const destPos = new Vector3(x, y, z);
            this._camera.lookAt(eyePos, destPos, Vector3.axisPY());
            this._camera.controller = new OrbitCameraController({
                center: destPos
            });
            // loaded
            this._terrain.showState = GraphNode.SHOW_DEFAULT;
            this._scene.env.sky.wind.setXY(700, 350);
            this._loaded = true;
        });
    }
    async loadCharacter(scene, assetManager) {
        const character = await assetManager.fetchModel(scene, '/assets/models/alice_shellfire/scene.gltf');
        character.group.scale.setXYZ(2, 2, 2);
        return character;
    }
    async loadTerrain(scene, assetManager) {
        const mapWidth = 1025;
        const mapHeight = 1025;
        const heightMap = await assetManager.fetchBinaryData('/assets/maps/map3/heightmap.raw');
        const heightsInt16 = new Uint16Array(heightMap);
        const heightsF32 = new Float32Array(mapWidth * mapHeight);
        for(let i = 0; i < mapWidth * mapHeight; i++){
            heightsF32[i] = heightsInt16[i] / 65535;
        }
        const grassMap1 = await assetManager.fetchTexture('/assets/maps/map3/857caeb1.dds');
        const grassMap2 = await assetManager.fetchTexture('/assets/maps/map3/grass1x.dds');
        const grassMap3 = await assetManager.fetchTexture('/assets/maps/map3/gj02.dds');
        const splatMap = await assetManager.fetchTexture('/assets/maps/map3/splatmap.tga', {
            linearColorSpace: true
        });
        const detailAlbedo0 = await assetManager.fetchTexture('/assets/maps/map3/grass_color.png', {
            linearColorSpace: false
        });
        const detailNormal0 = await assetManager.fetchTexture('/assets/maps/map3/grass_norm.png', {
            linearColorSpace: true
        });
        const detailAlbedo1 = await assetManager.fetchTexture('/assets/maps/map3/28.png', {
            linearColorSpace: false
        });
        const detailNormal1 = await assetManager.fetchTexture('/assets/maps/map3/29.png', {
            linearColorSpace: true
        });
        const detailAlbedo2 = await assetManager.fetchTexture('/assets/maps/map3/174.jpg', {
            linearColorSpace: false
        });
        const detailNormal2 = await assetManager.fetchTexture('/assets/maps/map3/174_norm.jpg', {
            linearColorSpace: true
        });
        const terrain = new Terrain(scene);
        terrain.showState = GraphNode.SHOW_HIDE;
        terrain.create(mapWidth, mapHeight, heightsF32, new Vector3(1, 100, 1), 33, {
            splatMap,
            detailMaps: {
                albedoTextures: [
                    detailAlbedo0,
                    detailAlbedo1,
                    detailAlbedo2
                ],
                normalTextures: [
                    detailNormal0,
                    detailNormal1,
                    detailNormal2
                ],
                uvScale: [
                    120,
                    120,
                    120
                ],
                normalScale: [
                    2,
                    5,
                    0.5
                ],
                metallic: [
                    0,
                    0,
                    0
                ],
                roughness: [
                    0.95,
                    0.9,
                    0.7
                ],
                grass: [
                    [
                        {
                            bladeWidth: 2,
                            bladeHeigh: 2,
                            density: 1.2,
                            offset: -0.1,
                            texture: grassMap1
                        },
                        {
                            bladeWidth: 2,
                            bladeHeigh: 3,
                            density: 0.06,
                            offset: -0.02,
                            texture: grassMap2
                        }
                    ],
                    [
                        {
                            bladeWidth: 2,
                            bladeHeigh: 2,
                            density: 0.6,
                            offset: 0,
                            texture: grassMap3
                        }
                    ]
                ]
            }
        });
        terrain.maxPixelError = 6;
        terrain.castShadow = true;
        terrain.pickMode = GraphNode.PICK_ENABLED;
        // Distribute some trees
        const PY = Vector3.axisPY();
        const trees = [
            {
                url: '/assets/models/stylized_tree.glb',
                scale: 1.5
            }
        ];
        const f = 1 / trees.length;
        const seed = 0;
        const prng = new PRNG(seed);
        for(let i = 0; i < 500; i++){
            const x = prng.get() * terrain.scaledWidth;
            const z = prng.get() * terrain.scaledHeight;
            const y = terrain.getElevation(x, z);
            const index = Math.min(Math.floor(prng.get() / f), trees.length - 1);
            const tree = await assetManager.fetchModel(scene, trees[index].url, null, this.replaceMaterials);
            tree.group.parent = terrain;
            tree.group.pickMode = SceneNode.PICK_DISABLED;
            tree.group.position.setXYZ(x, y, z);
            tree.group.scale.setXYZ(trees[index].scale, trees[index].scale, trees[index].scale);
            tree.group.rotation = Quaternion.fromAxisAngle(PY, prng.get() * 2 * Math.PI);
        }
        return terrain;
    }
    replaceMaterials(model) {
        function recusivelyReplaceMaterial(node) {
            if (node.mesh) {
                for (const subMesh of node.mesh.subMeshes){
                    const material = subMesh.material;
                    const needChange = material.blendMode === 'blend' || material.alphaCutoff > 0;
                    if (material instanceof PBRMetallicRoughnessMaterial && material.albedoTexture && needChange) {
                        const newMaterial = new TreeMaterialMetallicRoughness();
                        newMaterial.textureWidth = material.albedoTexture.width;
                        newMaterial.textureHeight = material.albedoTexture.height;
                        newMaterial.blendMode = 'none';
                        newMaterial.alphaCutoff = 0.8;
                        newMaterial.stateSet.useRasterizerState().setCullMode('none');
                        newMaterial.ior = material.ior;
                        newMaterial.specularFactor = material.specularFactor;
                        newMaterial.albedoColor = material.albedoColor;
                        newMaterial.albedoTexCoordIndex = material.albedoTexCoordIndex;
                        newMaterial.albedoTexCoordMatrix = material.albedoTexCoordMatrix;
                        newMaterial.albedoTexture = material.albedoTexture;
                        newMaterial.albedoTextureSampler = material.albedoTextureSampler;
                        newMaterial.normalTexture = material.normalTexture;
                        newMaterial.normalTexCoordIndex = material.normalTexCoordIndex;
                        newMaterial.normalTexCoordMatrix = material.normalTexCoordMatrix;
                        newMaterial.normalTextureSampler = material.normalTextureSampler;
                        newMaterial.normalScale = material.normalScale;
                        newMaterial.occlusionTexture = material.occlusionTexture;
                        newMaterial.occlusionTexCoordIndex = material.occlusionTexCoordIndex;
                        newMaterial.occlusionTexCoordMatrix = material.occlusionTexCoordMatrix;
                        newMaterial.occlusionTextureSampler = material.occlusionTextureSampler;
                        newMaterial.metallicRoughnessTexture = material.metallicRoughnessTexture;
                        newMaterial.metallicRoughnessTexCoordIndex = material.metallicRoughnessTexCoordIndex;
                        newMaterial.metallicRoughnessTexCoordMatrix = material.metallicRoughnessTexCoordMatrix;
                        newMaterial.metallicRoughnessTextureSampler = material.metallicRoughnessTextureSampler;
                        newMaterial.specularTexture = material.specularTexture;
                        newMaterial.specularTexCoordIndex = material.specularTexCoordIndex;
                        newMaterial.specularTexCoordMatrix = material.specularTexCoordMatrix;
                        newMaterial.specularTextureSampler = material.specularTextureSampler;
                        newMaterial.specularColorTexture = material.specularColorTexture;
                        newMaterial.specularColorTexCoordIndex = material.specularColorTexCoordIndex;
                        newMaterial.specularColorTexCoordMatrix = material.specularColorTexCoordMatrix;
                        newMaterial.specularColorTextureSampler = material.specularColorTextureSampler;
                        newMaterial.metallic = 0;
                        newMaterial.roughness = 1;
                        subMesh.material = newMaterial;
                    } else if (material instanceof PBRSpecularGlossinessMaterial && material.albedoTexture && needChange) {
                        const newMaterial = new TreeMaterialMetallicRoughness();
                        newMaterial.textureWidth = material.albedoTexture.width;
                        newMaterial.textureHeight = material.albedoTexture.height;
                        newMaterial.blendMode = 'none';
                        newMaterial.alphaCutoff = 0.8;
                        newMaterial.stateSet.useRasterizerState().setCullMode('none');
                        newMaterial.ior = material.ior;
                        newMaterial.specularFactor = material.specularFactor;
                        newMaterial.albedoColor = material.albedoColor;
                        newMaterial.albedoTexCoordIndex = material.albedoTexCoordIndex;
                        newMaterial.albedoTexCoordMatrix = material.albedoTexCoordMatrix;
                        newMaterial.albedoTexture = material.albedoTexture;
                        newMaterial.albedoTextureSampler = material.albedoTextureSampler;
                        newMaterial.normalTexture = material.normalTexture;
                        newMaterial.normalTexCoordIndex = material.normalTexCoordIndex;
                        newMaterial.normalTexCoordMatrix = material.normalTexCoordMatrix;
                        newMaterial.normalTextureSampler = material.normalTextureSampler;
                        newMaterial.normalScale = material.normalScale;
                        newMaterial.occlusionTexture = material.occlusionTexture;
                        newMaterial.occlusionTexCoordIndex = material.occlusionTexCoordIndex;
                        newMaterial.occlusionTexCoordMatrix = material.occlusionTexCoordMatrix;
                        newMaterial.occlusionTextureSampler = material.occlusionTextureSampler;
                        newMaterial.specularTexture = material.specularTexture;
                        newMaterial.specularTexCoordIndex = material.specularTexCoordIndex;
                        newMaterial.specularTexCoordMatrix = material.specularTexCoordMatrix;
                        newMaterial.specularTextureSampler = material.specularTextureSampler;
                        newMaterial.metallic = 0;
                        newMaterial.roughness = 1;
                        subMesh.material = newMaterial;
                    }
                }
            }
            for (const child of node.children){
                recusivelyReplaceMaterial(child);
            }
        }
        for (const node of model.nodes){
            recusivelyReplaceMaterial(node);
        }
        return model;
    }
    handlePointerUp(button, x, y) {
        if (!this._loaded) {
            return;
        }
        const obj = this._scene.raycast(this._camera, x, y);
        if (obj && obj.node.isTerrain()) {
            this._terrain.invWorldMatrix.transformPointAffine(obj.point, this._actorTarget);
            if (button === 2) {
                this._actorDirection.set(Vector3.mul(Vector3.sub(this._actorTarget, this._character.group.position), new Vector3(1, 0, 1)).inplaceNormalize());
                this._character.group.rotation = Quaternion.unitVectorToUnitVector(this._axisPZ, this._actorDirection);
                this._character.animationSet.playAnimation('run_front', 0);
                this._actorRunning = true;
            }
        }
    }
    updateCharacter() {
        if (this._loaded && this._actorRunning) {
            const distance = Vector3.distance(Vector3.mul(this._character.group.position, new Vector3(1, 0, 1)), Vector3.mul(this._actorTarget, new Vector3(1, 0, 1)));
            let movement = Application.instance.device.frameInfo.elapsedFrame * this._actorSpeed / 1000;
            if (movement >= distance) {
                this._actorRunning = false;
                movement = distance;
                this._character.animationSet.playAnimation('idle01_yindao', 0);
            }
            const newPos = Vector3.add(this._character.group.position, Vector3.scale(this._actorDirection, movement));
            newPos.y = this._terrain.getElevation(newPos.x, newPos.z);
            this._character.group.position.set(newPos);
            this._camera.controller.center = newPos;
        }
    }
    updateCamera() {
        this._camera.updateController();
        const height = this._terrain.getElevation(this._camera.position.x, this._camera.position.z);
        if (this._camera.position.y < height + 2) {
            this._camera.position.y = height + 2;
        }
    }
    render() {
        if (this._loaded) {
            this.updateCharacter();
            this.updateCamera();
        }
        this._camera.render(this._scene, this._compositor);
        if (!this._loaded) {
            Application.instance.device.drawText(`Loading: %${this._loadPercent}`, 20, 20, '#a00000');
        } else {
            this._ui.render();
        }
    }
}

function getQueryString(name) {
    return new URL(window.location.toString()).searchParams.get(name) || null;
}
function getBackend() {
    const type = getQueryString('dev') || 'webgl';
    if (type === 'webgpu') {
        if (backendWebGPU.supported()) {
            return backendWebGPU;
        } else {
            console.warn('No WebGPU support, fall back to WebGL2');
        }
    }
    if (type === 'webgl2') {
        if (backendWebGL2.supported()) {
            return backendWebGL2;
        } else {
            console.warn('No WebGL2 support, fall back to WebGL1');
        }
    }
    return backendWebGL1;
}
const terrainApp = new Application({
    backend: getBackend(),
    canvas: document.querySelector('#canvas'),
    enableMSAA: false
});
terrainApp.ready().then(async ()=>{
    await imGuiInit(terrainApp.device);
    const demo = new Demo();
    const device = terrainApp.device;
    device.canvas.addEventListener('contextmenu', function(ev) {
        ev.preventDefault();
        return false;
    });
    terrainApp.inputManager.use(imGuiInjectEvent);
    terrainApp.inputManager.use(demo.camera.handleEvent.bind(demo.camera));
    terrainApp.on('pointerup', (ev)=>{
        demo.handlePointerUp(ev.button, ev.offsetX, ev.offsetY);
    });
    Application.instance.device.canvas.addEventListener('contextmenu', function(ev) {
        ev.preventDefault();
        return false;
    });
    terrainApp.on('resize', (ev)=>{
        demo.camera.aspect = ev.width / ev.height;
    });
    terrainApp.on('tick', (ev)=>{
        demo.render();
    });
    demo.load();
    terrainApp.run();
});
//# sourceMappingURL=demo-3.js.map
