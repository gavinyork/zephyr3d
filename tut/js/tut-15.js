const colorNames = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32',
    transparent: 'rgba(0,0,0,0)'
};
/**
 * parse a css color value to RGBA color type.
 * @param input - The css color value.
 * @returns The RGBA color value.
 * @public
 */ function parseColor(input) {
    input = input.trim().toLowerCase();
    input = colorNames[input] || input;
    let v = null;
    if (input[0] === '#') {
        const collen = (input.length - 1) / 3;
        const fact = [
            17,
            1,
            0.062272
        ][collen - 1];
        v = {
            r: parseInt(input.substring(1, 1 + collen), 16) * fact / 255,
            g: parseInt(input.substring(1 + collen, 1 + 2 * collen), 16) * fact / 255,
            b: parseInt(input.substring(1 + 2 * collen, 1 + 3 * collen), 16) * fact / 255,
            a: 1
        };
    } else {
        let m;
        if (m = input.match(/^\s*rgb\s*\(\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\s*,\s*(\d\.?\d*)\s*\)\s*$/i)) {
            v = {
                r: Number(m[1]) / 255,
                g: Number(m[2]) / 255,
                b: Number(m[3]) / 255,
                a: 1
            };
        } else if (m = input.match(/^\s*rgba\s*\(\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\s*,\s*([\d*.?\d*]+)\s*,\s*(\d*\.?\d*)\s*\)\s*$/i)) {
            v = {
                r: Number(m[1]) / 255,
                g: Number(m[2]) / 255,
                b: Number(m[3]) / 255,
                a: Number(m[4])
            };
        }
    }
    if (!v || Number.isNaN(v.r) || Number.isNaN(v.g) || Number.isNaN(v.b) || Number.isNaN(v.a)) {
        throw new Error(`parseColor(): invalid color '${input}'`);
    }
    // the RGB color values in CSS are in sRGB color space, convert them to linear color space
    v.r = Math.pow(Math.min(1, v.r), 2.2);
    v.g = Math.pow(Math.min(1, v.g), 2.2);
    v.b = Math.pow(Math.min(1, v.b), 2.2);
    v.a = Math.min(1, v.a);
    return v;
}
/**
 * Applies mixins to a constructor function.
 *
 * @param target - The constructor function of the class that will receive the mixins.
 * @param mixins - mixins
 * @returns Mixed class
 *
 * @public
 */ function applyMixins(target, ...mixins) {
    let r = target;
    for (const m of mixins){
        r = m(r);
    }
    return r;
}

/**
 * This mixin make a class an event target
 * @param cls - the class to make
 * @returns - The event target class
 * @public
 */ function makeEventTarget(cls) {
    return function _() {
        return class E extends cls {
            /** @internal */ _listeners;
            constructor(...args){
                super(...args);
                this._listeners = null;
            }
            /**
       * {@inheritDoc IEventTarget.on}
       */ on(type, listener, context) {
                this._listeners = this._internalAddEventListener(this._listeners, type, listener, {
                    context
                });
            }
            /**
       * {@inheritDoc IEventTarget.once}
       */ once(type, listener, context) {
                this._listeners = this._internalAddEventListener(this._listeners, type, listener, {
                    context,
                    once: true
                });
            }
            /**
       * {@inheritDoc IEventTarget.off}
       */ off(type, listener) {
                this._internalRemoveEventListener(this._listeners, type, listener);
            }
            /**
       * {@inheritDoc IEventTarget.dispatchEvent}
       */ dispatchEvent(evt, type) {
                this._invokeLocalListeners(evt, type);
            }
            /** @internal */ _internalAddEventListener(listenerMap, type, listener, options) {
                if (typeof type !== 'string') {
                    return;
                }
                if (!listenerMap) {
                    listenerMap = {};
                }
                const l = listener;
                const o = {
                    once: !!options?.once,
                    context: options?.context
                };
                let handlers = listenerMap[type];
                if (!handlers) {
                    listenerMap[type] = handlers = [];
                }
                handlers.push({
                    handler: l,
                    options: o,
                    removed: false
                });
                return listenerMap;
            }
            /** @internal */ _internalRemoveEventListener(listenerMap, type, listener) {
                if (typeof type !== 'string' || !listenerMap) {
                    return;
                }
                const l = listener;
                const handlers = listenerMap[type];
                if (handlers) {
                    for(let i = 0; i < handlers.length; i++){
                        const handler = handlers[i];
                        if (handler.handler === l) {
                            handlers.splice(i, 1);
                            break;
                        }
                    }
                }
                if (handlers.length === 0) {
                    delete listenerMap[type];
                }
            }
            /** @internal */ _invokeLocalListeners(evt, type) {
                if (!this._listeners) {
                    return;
                }
                const handlers = this._listeners[type ?? evt?.type];
                if (handlers && handlers.length > 0) {
                    const handlersCopy = handlers.slice();
                    for (const handler of handlersCopy){
                        handler.handler.call(handler.options?.context || this, evt);
                        if (handler.options.once) {
                            handler.removed = true;
                        }
                    }
                    for(let i = handlers.length - 1; i >= 0; i--){
                        if (handlers[i].removed) {
                            handlers.splice(i, 1);
                        }
                    }
                }
            }
        };
    };
}

const tmpArrayBuffer = new ArrayBuffer(4);
const tmpFloatArray = new Float32Array(tmpArrayBuffer);
/**
 * Convert a number to 32 bit float value
 * @param val - The number to be converted
 * @returns 32bit float value
 *
 * @public
 */ function toFloat(val) {
    tmpFloatArray[0] = val;
    return tmpFloatArray[0];
}
/**
 * Check if a number is a power of 2.
 *
 * @param value - The number to be checked.
 * @returns true if the number is a power of 2, otherwise false.
 *
 * @public
 */ function isPowerOf2(value) {
    return value % 1 === 0 && value >= 0 && (value & value - 1) === 0;
}
/**
 * Given a number, find the next number power of 2.
 *
 * @param value - The given number.
 * @returns The next number power of 2.
 *
 * @public
 */ function nextPowerOf2(value) {
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;
    return value;
}

/**
 * Enumerator used to refer to a box side
 * @public
 */ var BoxSide;
(function(BoxSide) {
    BoxSide[BoxSide[/** Left side (-x) */ "LEFT"] = 0] = "LEFT";
    BoxSide[BoxSide[/** Right side (+x) */ "RIGHT"] = 1] = "RIGHT";
    BoxSide[BoxSide[/** Bottom side (-y) */ "BOTTOM"] = 2] = "BOTTOM";
    BoxSide[BoxSide[/** Top side (+y) */ "TOP"] = 3] = "TOP";
    BoxSide[BoxSide[/** Front side (+z) */ "FRONT"] = 4] = "FRONT";
    BoxSide[BoxSide[/** Back side (-z) */ "BACK"] = 5] = "BACK";
})(BoxSide || (BoxSide = {}));
var ClipState;
(function(ClipState) {
    ClipState[ClipState[/** A does not intersect with B */ "NOT_CLIPPED"] = 0] = "NOT_CLIPPED";
    ClipState[ClipState[/** A is inside B */ "A_INSIDE_B"] = 1] = "A_INSIDE_B";
    ClipState[ClipState[/** B is inside A */ "B_INSIDE_A"] = 2] = "B_INSIDE_A";
    ClipState[ClipState[/** A and B partially overlap */ "CLIPPED"] = 2] = "CLIPPED";
})(ClipState || (ClipState = {}));
var CubeFace;
(function(CubeFace) {
    CubeFace[CubeFace["PX"] = 0] = "PX";
    CubeFace[CubeFace["NX"] = 1] = "NX";
    CubeFace[CubeFace["PY"] = 2] = "PY";
    CubeFace[CubeFace["NY"] = 3] = "NY";
    CubeFace[CubeFace["PZ"] = 4] = "PZ";
    CubeFace[CubeFace["NZ"] = 5] = "NZ";
})(CubeFace || (CubeFace = {}));

const IDENT_MATRIX3x3 = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
]);
const IDENT_MATRIX4x4 = new Float32Array([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
]);
/**
 * Base class for vector and matrix types.
 *
 * @public
 */ class VectorBase extends Float32Array {
    /**
   * Check if all data is close enough to another
   * @param other - The data to be compared with.
   * @param epsilon - The minimal error allowd.
   * @returns true if close enough, otherwise false.
   */ equalsTo(other, epsl) {
        if (!other || this.length !== other.length) {
            return false;
        }
        if (this === other) {
            return true;
        }
        for(let i = 0; i < this.length; i++){
            const a = this[i];
            const b = other[i];
            const e = epsl ?? 0.0001 * Math.max(1, Math.abs(a), Math.abs(b));
            if (Math.abs(a - b) > e) {
                return false;
            }
        }
        return true;
    }
    /**
   * Convert this to string object.
   */ toString() {
        const elements = [
            ...this
        ].map((val)=>val.toFixed(3));
        return `${this.constructor.name}{${elements.join(',')}}`;
    }
    /**
   * Check the data for the presence of NaN.
   *
   * @returns true if NaN is present, otherwise false.
   */ isNaN() {
        for(let i = 0; i < this.length; i++){
            if (Number.isNaN(this[i])) {
                return true;
            }
        }
        return false;
    }
}
/**
 * 2 dimentional vector
 * @public
 */ class Vector2 extends VectorBase {
    constructor(arg0, arg1){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 2);
        } else {
            super(2);
            if (typeof arg0 === 'number' && typeof arg1 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 2) {
                this[0] = arg0[0];
                this[1] = arg0[1];
            } else if (arg0 !== void 0) {
                throw new Error(`Vector2.constructor(): invalid arguments`);
            }
        }
    }
    /**
   * Creates a new Vector2 initialized with values from this vector.
   * @returns The new Vector2.
   */ clone() {
        return new Vector2(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1];
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @returns self
   */ setXY(x, y) {
        this[0] = x;
        this[1] = y;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @returns self
   */ setAndNormalize(x, y) {
        const mag = Math.sqrt(x * x + y * y);
        return this.setXY(x / mag, y / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector2.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector2.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector2.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector2.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector2.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector2.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector2.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector2.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector2.max(this, other, this);
    }
    /**
   * Creates a new Vector2 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector2(0, 0);
    }
    /**
   * Creates a new Vector2 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector2(1, 1);
    }
    /**
   * Creates a new Vector2 pointing in the positive direction of the X axis, i.e. vec2(1, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector2(1, 0);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the X axis, i.e. vec2(-1, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector2(-1, 0);
    }
    /**
   * Creates a new Vector2 pointing in the positive direction of the Y axis, i.e. vec2(0, 1)
   * @returns The new vector
   */ static axisPY() {
        return new Vector2(0, 1);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the Y axis, i.e. vec2(0, -1)
   * @returns The new vector
   */ static axisNY() {
        return new Vector2(0, -1);
    }
    /**
   * Calculates the distance between two Vector2's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns distance between v1 and v2
   */ static distance(v1, v2) {
        return Math.sqrt(this.distanceSq(v1, v2));
    }
    /**
   * Calculates the squared distance between two Vector2's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns squared distance between v1 and v2
   */ static distanceSq(v1, v2) {
        const dx = v1.x - v2.x;
        const dy = v1.y - v2.y;
        return dx * dx + dy * dy;
    }
    /**
   * Normalize a Vector2
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Inverse a Vector2
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Subtract two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Add two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Multiply two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Divide two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Scale a Vector2 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the minimum of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the maximum of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the absolute values of a Vector2.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        return (result || new Vector2()).setXY(x, y);
    }
    /**
   * Calculates the dot product of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y;
    }
    /**
   * Calculates the cross product of two Vector2's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns z component of the cross product of the two vectors.
   */ static cross(a, b) {
        return a.x * b.y - a.y * b.x;
    }
}
/**
 * 3 dimentional vector
 * @public
 */ class Vector3 extends VectorBase {
    constructor(arg0, arg1, arg2){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 3);
        } else {
            super(3);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 3) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
            } else if (arg0 !== void 0) {
                throw new Error('Vector3.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Vector3 initialized with values from this vector.
   * @returns The new vector.
   */ clone() {
        return new Vector3(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2];
    }
    /**
   * Creates a new Vector2 initialized with x, y component of this vector.
   * @returns The new vector
   */ xy() {
        return new Vector2(this.x, this.y);
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @returns self
   */ setXYZ(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @returns self
   */ setAndNormalize(x, y, z) {
        const mag = Math.sqrt(x * x + y * y + z * z);
        return this.setXYZ(x / mag, y / mag, z / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector3.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector3.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector3.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector3.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector3.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector3.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector3.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector3.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector3.max(this, other, this);
    }
    /**
   * Creates a new Vector3 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector3(0, 0, 0);
    }
    /**
   * Creates a new Vector3 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector3(1, 1, 1);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the X axis, i.e. vec3(1, 0, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector3(1, 0, 0);
    }
    /**
   * Creates a new Vector3 pointing in the negative direction of the X axis, i.e. vec3(-1, 0, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector3(-1, 0, 0);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the Y axis, i.e. vec3(0, 1, 0)
   * @returns The new vector
   */ static axisPY() {
        return new Vector3(0, 1, 0);
    }
    /**
   * Creates a new Vector3 pointing in the negative direction of the Y axis, i.e. vec3(0, -1, 0)
   * @returns The new vector
   */ static axisNY() {
        return new Vector3(0, -1, 0);
    }
    /**
   * Creates a new Vector3 pointing in the positive direction of the Z axis, i.e. vec3(0, 0, 1)
   * @returns The new vector
   */ static axisPZ() {
        return new Vector3(0, 0, 1);
    }
    /**
   * Creates a new Vector2 pointing in the negative direction of the Z axis, i.e. vec3(0, 0, -1)
   * @returns The new vector
   */ static axisNZ() {
        return new Vector3(0, 0, -1);
    }
    /**
   * Calculates the distance between two Vector3's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns distance between v1 and v2
   */ static distance(v1, v2) {
        return Math.sqrt(this.distanceSq(v1, v2));
    }
    /**
   * Calculates the squared distance between two Vector3's.
   * @param v1 - The first vector.
   * @param v2 - The second vector.
   * @returns squared distance between v1 and v2
   */ static distanceSq(v1, v2) {
        const dx = v1.x - v2.x;
        const dy = v1.y - v2.y;
        const dz = v1.z - v2.z;
        return dx * dx + dy * dy + dz * dz;
    }
    /**
   * Normalize a Vector3
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        const z = v.z / len;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Inverse a Vector3
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        const z = 1 / v.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Subtract two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = a.z - b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Add two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        const z = a.z + b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Multiply two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        const z = a.z * b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Divide two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        const z = a.z / b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Scale a Vector3 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        const z = a.z * b;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the minimum of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        const z = a.z < b.z ? a.z : b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the maximum of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        const z = a.z > b.z ? a.z : b.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the absolute values of a Vector3.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        const z = a.z < 0 ? -a.z : a.z;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
    /**
   * Calculates the dot product of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }
    /**
   * Calculates the cross product of two Vector3's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns the cross product of the two vectors.
   */ static cross(a, b, result) {
        const x = a.y * b.z - a.z * b.y;
        const y = a.z * b.x - a.x * b.z;
        const z = a.x * b.y - a.y * b.x;
        return (result || new Vector3()).setXYZ(x, y, z);
    }
}
/**
 * Observable 3 dimentional vector
 *
 * @public
 */ class ObservableVector3 extends Vector3 {
    /** @internal */ _callback;
    /** The callback function which will be executed when the value changed */ get callback() {
        return this._callback;
    }
    set callback(cb) {
        this._callback = cb;
    }
    /**
   * {@inheritDoc Vector3.x}
   */ get x() {
        return super.x;
    }
    set x(val) {
        val = toFloat(val);
        if (val !== super.x) {
            super.x = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Vector3.y}
   */ get y() {
        return super.y;
    }
    set y(val) {
        val = toFloat(val);
        if (val !== super.y) {
            super.y = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Vector3.z}
   */ get z() {
        return super.z;
    }
    set z(val) {
        val = toFloat(val);
        if (val !== super.z) {
            super.z = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Vector3.setXYZ}
   */ setXYZ(x, y, z) {
        x = toFloat(x);
        y = toFloat(y);
        z = toFloat(z);
        if (x !== super.x || y !== super.y || z !== super.z) {
            super.setXYZ(x, y, z);
            this._callback && this._callback();
        }
        return this;
    }
    /**
   * Inherited from Float32Array.copyWithin
   */ copyWithin(target, start, end) {
        super.copyWithin(target, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.fill
   */ fill(value, start, end) {
        super.fill(value, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.reverse
   */ reverse() {
        super.reverse();
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.set
   */ set(array, offset) {
        super.set(array, offset);
        this._callback && this._callback();
    }
    /**
   * Inherited from Float32Array.sort
   */ sort(compareFn) {
        super.sort(compareFn);
        this._callback && this._callback();
        return this;
    }
}
/**
 * 4 dimentional vector
 * @public
 */ class Vector4 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 4);
        } else {
            super(4);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[3];
            } else if (arg0 !== void 0) {
                throw new Error('Vector4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Vector4 initialized with values from this vector.
   * @returns The new vector.
   */ clone() {
        return new Vector4(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the w component value. */ get w() {
        return this[3];
    }
    set w(v) {
        this[3] = v;
    }
    /** Get the length of the vector. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3]);
    }
    /** Get the squared length of the vector. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3];
    }
    /**
   * Creates a new Vector2 initialized with x, y component of this vector.
   * @returns The new vector
   */ xy() {
        return new Vector2(this.x, this.y);
    }
    /**
   * Creates a new Vector3 initialized with x, y, z component of this vector.
   * @returns The new vector
   */ xyz() {
        return new Vector3(this.x, this.y, this.z);
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setXYZW(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this;
    }
    /**
   * Set component values and then normalize the vector.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setAndNormalize(x, y, z, w) {
        const mag = Math.sqrt(x * x + y * y + z * z + w * w);
        return this.setXYZW(x / mag, y / mag, z / mag, w / mag);
    }
    /**
   * Subtract a vector from this vector.
   * @param other - The vector that will be subtract.
   * @returns self
   */ subBy(other) {
        return Vector4.sub(this, other, this);
    }
    /**
   * Add a vector to this vector.
   * @param other - The vector that will be added.
   * @returns self
   */ addBy(other) {
        return Vector4.add(this, other, this);
    }
    /**
   * Multiply this vector by a vector.
   * @param other - The vector that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Vector4.mul(this, other, this);
    }
    /**
   * Divide this vector by a vector.
   * @param other - The vector that will be divide by.
   * @returns self
   */ divBy(other) {
        return Vector4.div(this, other, this);
    }
    /**
   * Scale this vector by a scalar number.
   * @param f - amount to scale this vector by.
   * @returns self
   */ scaleBy(f) {
        return Vector4.scale(this, f, this);
    }
    /**
   * Normalize this vector inplace.
   * @returns self
   */ inplaceNormalize() {
        return Vector4.normalize(this, this);
    }
    /**
   * Inverse this vector inplace.
   * @returns self
   */ inplaceInverse() {
        return Vector4.inverse(this, this);
    }
    /**
   * Set the component values to the minimum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMin(other) {
        return Vector4.min(this, other, this);
    }
    /**
   * Set the component values to the maximum of this vector and another vector.
   * @param other - The vector that to be compared with.
   * @returns self
   */ inplaceMax(other) {
        return Vector4.max(this, other, this);
    }
    /**
   * Creates a new Vector4 initialized with zero values.
   * @returns The new vector
   */ static zero() {
        return new Vector4(0, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 initialized with one.
   * @returns The new vector
   */ static one() {
        return new Vector4(1, 1, 1, 1);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the X axis, i.e. vec4(1, 0, 0, 0)
   * @returns The new vector
   */ static axisPX() {
        return new Vector4(1, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the X axis, i.e. vec4(-1, 0, 0, 0)
   * @returns The new vector
   */ static axisNX() {
        return new Vector4(-1, 0, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the Y axis, i.e. vec4(0, 1, 0, 0)
   * @returns The new vector
   */ static axisPY() {
        return new Vector4(0, 1, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the Y axis, i.e. vec4(0, -1, 0, 0)
   * @returns The new vector
   */ static axisNY() {
        return new Vector4(0, -1, 0, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the Z axis, i.e. vec4(0, 0, 1, 0)
   * @returns The new vector
   */ static axisPZ() {
        return new Vector4(0, 0, 1, 0);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the Z axis, i.e. vec4(0, 0, -1, 0)
   * @returns The new vector
   */ static axisNZ() {
        return new Vector4(0, 0, -1, 0);
    }
    /**
   * Creates a new Vector4 pointing in the positive direction of the W axis, i.e. vec4(0, 0, 0, 1)
   * @returns The new vector
   */ static axisPW() {
        return new Vector4(0, 0, 0, 1);
    }
    /**
   * Creates a new Vector4 pointing in the negative direction of the W axis, i.e. vec4(0, 0, 0, -1)
   * @returns The new vector
   */ static axisNW() {
        return new Vector4(0, 0, 0, -1);
    }
    /**
   * Normalize a Vector4
   * @param v - The input vector
   * @param result - The output vector (can be the same as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static normalize(v, result) {
        const len = v.magnitude;
        const x = v.x / len;
        const y = v.y / len;
        const z = v.z / len;
        const w = v.w / len;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Inverse a Vector4
   * @param v - The input vector
   * @param result - The output vector (can be the same vector as v). if not specified, a new vector will be created.
   * @returns The output vector
   */ static inverse(v, result) {
        const x = 1 / v.x;
        const y = 1 / v.y;
        const z = 1 / v.z;
        const w = 1 / v.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Subtract two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static sub(a, b, result) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = a.z - b.z;
        const w = a.w - b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Add two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static add(a, b, result) {
        const x = a.x + b.x;
        const y = a.y + b.y;
        const z = a.z + b.z;
        const w = a.w + b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Multiply two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static mul(a, b, result) {
        const x = a.x * b.x;
        const y = a.y * b.y;
        const z = a.z * b.z;
        const w = a.w * b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Divide two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static div(a, b, result) {
        const x = a.x / b.x;
        const y = a.y / b.y;
        const z = a.z / b.z;
        const w = a.w / b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Scale a Vector4 by a scalar number.
   * @param a - The vector to be scaled.
   * @param b - The scalar number.
   * @param result - The output vector (can be the same vector as a). if not specified, a new vector will be created.
   * @returns The output vector
   */ static scale(a, b, result) {
        const x = a.x * b;
        const y = a.y * b;
        const z = a.z * b;
        const w = a.w * b;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the minimum of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static min(a, b, result) {
        const x = a.x < b.x ? a.x : b.x;
        const y = a.y < b.y ? a.y : b.y;
        const z = a.z < b.z ? a.z : b.z;
        const w = a.w < b.w ? a.w : b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the maximum of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static max(a, b, result) {
        const x = a.x > b.x ? a.x : b.x;
        const y = a.y > b.y ? a.y : b.y;
        const z = a.z > b.z ? a.z : b.z;
        const w = a.w > b.w ? a.w : b.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the absolute values of a Vector4.
   * @param a - The input vector.
   * @param result - The output vector (can be the same vector as a or b). if not specified, a new vector will be created.
   * @returns The output vector
   */ static abs(a, result) {
        const x = a.x < 0 ? -a.x : a.x;
        const y = a.y < 0 ? -a.y : a.y;
        const z = a.z < 0 ? -a.z : a.z;
        const w = a.w < 0 ? -a.w : a.w;
        return (result || new Vector4()).setXYZW(x, y, z, w);
    }
    /**
   * Calculates the dot product of two Vector4's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
    }
}
/**
 * Quaternion
 * @public
 */ class Quaternion extends VectorBase {
    constructor(arg0, arg1, arg2, arg3){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 4);
        } else {
            super(4);
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
            } else if (arg0 instanceof Matrix3x3 || arg0 instanceof Matrix4x4) {
                this.fromRotationMatrix(arg0);
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[3];
            } else if (arg0 === void 0) {
                this[0] = 0;
                this[1] = 0;
                this[2] = 0;
                this[3] = 1;
            } else {
                throw new Error('Quaternion.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Quaternion initialized with values from this quaternion.
   * @returns The new quaternion.
   */ clone() {
        return new Quaternion(this);
    }
    /** Get the x component value. */ get x() {
        return this[0];
    }
    set x(v) {
        this[0] = v;
    }
    /** Get the y component value. */ get y() {
        return this[1];
    }
    set y(v) {
        this[1] = v;
    }
    /** Get the z component value. */ get z() {
        return this[2];
    }
    set z(v) {
        this[2] = v;
    }
    /** Get the w component value. */ get w() {
        return this[3];
    }
    set w(v) {
        this[3] = v;
    }
    /**
   * Set component values.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setXYZW(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this;
    }
    /**
   * Scale this quaternion by a scalar number.
   * @param f - amount to scale this quaternion by.
   * @returns self
   */ scaleBy(f) {
        return Quaternion.scale(this, f, this);
    }
    /**
   * Set component values and then normalize the quaternion.
   * @param x - The x component value.
   * @param y - The y component value.
   * @param z - The z component value.
   * @param w - The w component value.
   * @returns self
   */ setAndNormalize(x, y, z, w) {
        const mag = Math.sqrt(x * x + y * y + z * z + w * w);
        return this.setXYZW(x / mag, y / mag, z / mag, w / mag);
    }
    /** Get the length of the quaternion. */ get magnitude() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3]);
    }
    /** Get the squared length of the quaternion. */ get magnitudeSq() {
        return this[0] * this[0] + this[1] * this[1] + this[2] * this[2] + this[3] * this[3];
    }
    /** Make this quaternion an identity quaternion */ identity() {
        return Quaternion.identity(this);
    }
    /**
   * Normalize this quaternion inplace.
   * @returns self
   */ inplaceNormalize() {
        return Quaternion.normalize(this, this);
    }
    /**
   * Calculates the conjugate of this quaternion inplace.
   * @returns self
   */ inplaceConjugate() {
        return Quaternion.conjugate(this, this);
    }
    /**
   * Multiply this quaternion by another quaternion at the right side inplace.
   * @param other - The quaternion that to be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Quaternion.multiply(this, other, this);
    }
    /**
   * Multiply this quaternion by another quaternion at the left side inplace.
   * @param other - The quaternion that to be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Quaternion.multiply(other, this, this);
    }
    /**
   * Make a quaternion used to rotate a unit vector to another inplace.
   * @param from - The unit vector to be rotated.
   * @param to - The destination unit vector.
   * @returns self
   */ unitVectorToUnitVector(from, to) {
        return Quaternion.unitVectorToUnitVector(from, to, this);
    }
    /**
   * Calculates the quaternion from an euler angle in specific order inplace.
   * @param x - Angle to rotate around X axis in radians.
   * @param y - Angle to rotate around Y axis in radians.
   * @param z - Angle to rotate around Z axis in radians.
   * @param order - Intrinsic order for conversion.
   * @returns self
   */ fromEulerAngle(x, y, z, order) {
        return Quaternion.fromEulerAngle(x, y, z, order, this);
    }
    /**
   * Calculates the quaternion from the given angle and rotation axis inplace.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle.
   * @returns self
   */ fromAxisAngle(axis, angle) {
        return Quaternion.fromAxisAngle(axis, angle, this);
    }
    /**
   * Calculates the rotation axis and angle for this quaternion
   * @param axis - A vector that receives the rotation axis.
   * @returns - The rotation angle
   */ toAxisAngle(axis) {
        const rad = Math.acos(this[3]) * 2;
        const s = Math.sin(rad / 2);
        if (s > 0.000001) {
            axis.setXYZ(this[0] / s, this[1] / 2, this[2] / s);
        } else {
            axis.setXYZ(1, 0, 0);
        }
        return rad;
    }
    /**
   * Convert this rotation to euler angles in ZYX order
   * @param angles - A vector that receives the euler angles. If not given, a new vector will be created.
   * @returns The vector that holds the euler angles.
   */ toEulerAngles(angles) {
        angles = angles ?? new Vector3();
        const t0 = 2 * (this.w * this.x + this.y * this.z);
        const t1 = 1 - 2 * (this.x * this.x + this.y * this.y);
        const roll = Math.atan2(t0, t1);
        const t2 = Math.max(-1, Math.min(1, 2 * (this.w * this.y - this.z * this.x)));
        const pitch = Math.asin(t2);
        const t3 = 2 * (this.w * this.z + this.x * this.y);
        const t4 = 1 - 2 * (this.y * this.y + this.z * this.z);
        const yaw = Math.atan2(t3, t4);
        return angles.setXYZ(roll, pitch, yaw);
    }
    /**
   * Calculates the quaternion from a rotation matrix inplace.
   * @param matrix - The rotation matrix.
   * @returns self
   */ fromRotationMatrix(matrix) {
        return Quaternion.fromRotationMatrix(matrix, this);
    }
    /**
   * Convert this quaternion to a 3x3 rotation matrix.
   * @param matrix - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix.
   */ toMatrix3x3(matrix) {
        const m = matrix || new Matrix3x3();
        this.toMatrix(m);
        return m;
    }
    /**
   * Convert this quaternion to a 4x4 rotation matrix.
   *
   * @remarks
   * Only left top 3x3 part of the matrix will be changed.
   *
   * @param matrix - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix.
   */ toMatrix4x4(matrix) {
        const m = matrix || Matrix4x4.identity();
        this.toMatrix(m);
        return m;
    }
    /**
   * Get the direction of axis x
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis x
   */ getDirectionX(result) {
        result = result ?? new Vector3();
        return result.setXYZ(1 - 2 * (this.y * this.y + this.z * this.z), 2 * (this.x * this.y + this.z * this.w), 2 * (this.z * this.x - this.y * this.w));
    }
    /**
   * Get the direction of axis y
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis y
   */ getDirectionY(result) {
        result = result ?? new Vector3();
        return result.setXYZ(2 * (this.x * this.y - this.z * this.w), 1 - 2 * (this.z * this.z + this.x * this.x), 2 * (this.y * this.z + this.x * this.w));
    }
    /**
   * Get the direction of axis z
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The direction of axis z
   */ getDirectionZ(result) {
        result = result ?? new Vector3();
        return result.setXYZ(2 * (this.z * this.x + this.y * this.w), 2 * (this.y * this.z - this.x * this.w), 1 - 2 * (this.y * this.y + this.x * this.x));
    }
    /**
   * Get the rotate angle and the rotation axis for this quaternion.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns An vector4 that the x, y, z component presents the axis and the w component presents the angle.
   */ getAxisAngle(result) {
        result = result ?? new Vector4();
        const sign = this.w < 0 ? -1 : 1;
        const x = this.x * sign;
        const y = this.y * sign;
        const z = this.z * sign;
        const w = this.w * sign;
        const halfAngle = Math.acos(w);
        const sinHalf = Math.sin(halfAngle);
        return result.setXYZW(x / sinHalf, y / sinHalf, z / sinHalf, 2 * halfAngle);
    }
    /**
   * Rotate a vector
   * @param v - The vector to be rotated.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The rotation result.
   */ transform(v, result) {
        result = result || new Vector3();
        const x = this.x * 2;
        const y = this.y * 2;
        const z = this.z * 2;
        const xx = this.x * x;
        const yy = this.y * y;
        const zz = this.z * z;
        const xy = this.x * y;
        const xz = this.x * z;
        const yz = this.y * z;
        const wx = this.w * x;
        const wy = this.w * y;
        const wz = this.w * z;
        return result.setXYZ((1 - yy - zz) * v.x + (xy - wz) * v.y + (xz + wy) * v.z, (xy + wz) * v.x + (1 - xx - zz) * v.y + (yz - wx) * v.z, (xz - wy) * v.x + (yz + wx) * v.y + (1 - xx - yy) * v.z);
    }
    /**
   * Scale a Quaternion by a scalar number.
   * @param a - The quaternion to be scaled.
   * @param b - The scalar number.
   * @param result - The output quaternion (can be the same quaternion as a). if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static scale(q, t, result) {
        result = result || q;
        return result.setXYZW(q.x * t, q.y * t, q.z * t, q.w * t);
    }
    /**
   * Calculates the dot product of two Quaternion's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @returns dot product of a and b
   */ static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
    }
    /**
   * Create an identity quaternion
   * @param q - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static identity(q) {
        return (q || new Quaternion()).setXYZW(0, 0, 0, 1);
    }
    /**
   * Normalize a quaternion
   * @param q - The input quaternion
   * @param result - The output quaternion (can be the same as q), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static normalize(q, result) {
        const mag = q.magnitude;
        return (result || new Quaternion()).setXYZW(q.x / mag, q.y / mag, q.z / mag, q.w / mag);
    }
    /**
   * Gets the conjugate of a quaternion
   * @param q - The input quaternion
   * @param result - The output quaternion (can be the same as q), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static conjugate(q, result) {
        return (result || new Quaternion()).setXYZW(-q.x, -q.y, -q.z, q.w);
    }
    /**
   * Multiply two Quaternion's.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output quaternion (can be the same as a or b). if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static multiply(a, b, result) {
        result = result || new Quaternion();
        const x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
        const y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
        const z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
        const w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        return result.setXYZW(x, y, z, w);
    }
    /**
   * Performs a spherical linear interpolation between two quat.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param t - The interpolation amount, in the range [0-1].
   * @param result - The output quaternion (can be the same as a or b), if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static slerp(a, b, t, result) {
        result = result || new Quaternion();
        if (t <= 0) {
            return result.setXYZW(a.x, a.y, a.z, a.w);
        }
        if (t >= 1) {
            return result.setXYZW(b.x, b.y, b.z, b.w);
        }
        const halfCos1 = this.dot(a, b);
        const inv = halfCos1 < 0 ? -1 : 1;
        const ax = a.x;
        const ay = a.y;
        const az = a.z;
        const aw = a.w;
        const bx = b.x * inv;
        const by = b.y * inv;
        const bz = b.z * inv;
        const bw = b.w * inv;
        const halfCos = halfCos1 * inv;
        if (halfCos >= 1) {
            return result.setXYZW(ax, ay, az, aw);
        }
        const halfSinSqr = 1 - halfCos * halfCos;
        if (halfSinSqr <= Number.EPSILON) {
            const s = 1 - t;
            return result.setAndNormalize(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t, a.w * s + b.w * t);
        }
        const halfSin = Math.sqrt(halfSinSqr);
        const halfTheta = Math.atan2(halfSin, halfCos);
        const ratioA = Math.sin((1 - t) * halfTheta) / halfSin;
        const ratioB = Math.sin(t * halfTheta) / halfSin;
        return result.setXYZW(ax * ratioA + bx * ratioB, ay * ratioA + by * ratioB, az * ratioA + bz * ratioB, aw * ratioA + bw * ratioB);
    }
    /**
   * Gets the angular distance between two unit quaternions.
   * @param a - The origin quaternion
   * @param b - The destination quaternion
   * @returns - The angle in radians
   */ static angleBetween(a, b) {
        const x = this.dot(a, b);
        const clamped = x < -1 ? -1 : x > 1 ? 1 : x;
        return 2 * Math.acos(Math.abs(clamped));
    }
    /**
   * Creates a quaternion used to rotate a unit vector to another.
   * @param from - The unit vector to be rotated.
   * @param to - The destination unit vector.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static unitVectorToUnitVector(from, to, result) {
        // assume from and to are unit vectors
        result = result || new Quaternion();
        let r = Vector3.dot(from, to) + 1;
        if (r < 0.000001) {
            r = 0;
            if (Math.abs(from.x) > Math.abs(from.z)) {
                return result.setAndNormalize(-from.y, from.x, 0, r);
            } else {
                return result.setAndNormalize(0, -from.z, from.y, r);
            }
        } else {
            return result.setAndNormalize(from.y * to.z - from.z * to.y, from.z * to.x - from.x * to.z, from.x * to.y - from.y * to.x, r);
        }
    }
    /**
   * Creates a quaternion from an euler angle in specific order.
   * @param x - Angle to rotate around X axis in radians.
   * @param y - Angle to rotate around Y axis in radians.
   * @param z - Angle to rotate around Z axis in radians.
   * @param order - Intrinsic order for conversion.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static fromEulerAngle(a, b, c, order, result) {
        result = result || new Quaternion();
        const c1 = Math.cos(a / 2);
        const c2 = Math.cos(b / 2);
        const c3 = Math.cos(c / 2);
        const s1 = Math.sin(a / 2);
        const s2 = Math.sin(b / 2);
        const s3 = Math.sin(c / 2);
        switch(order){
            case 'XYZ':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'YXZ':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
            case 'ZXY':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'ZYX':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
            case 'YZX':
                return result.setXYZW(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
            case 'XZY':
                return result.setXYZW(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
        }
    }
    /**
   * Creates a quaternion from the given angle and rotation axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns The output quaternion
   */ static fromAxisAngle(axis, angle, result) {
        // assume axis is normalized
        result = result || new Quaternion();
        const halfAngle = angle / 2;
        const s = Math.sin(halfAngle);
        return result.setXYZW(axis.x * s, axis.y * s, axis.z * s, Math.cos(halfAngle));
    }
    /**
   * Creates a quaternion from a rotation matrix.
   * @param matrix - The rotation matrix.
   * @param result - The output quaternion, if not specified, a new quaternion will be created.
   * @returns self
   */ static fromRotationMatrix(matrix, result) {
        // assume matrix contains rotation without scaling
        result = result || new Quaternion();
        const trace = matrix.m00 + matrix.m11 + matrix.m22;
        let s;
        if (trace > 0) {
            s = 0.5 / Math.sqrt(trace + 1);
            result.setXYZW((matrix.m21 - matrix.m12) * s, (matrix.m02 - matrix.m20) * s, (matrix.m10 - matrix.m01) * s, 0.25 / s);
        } else if (matrix.m00 > matrix.m11 && matrix.m00 > matrix.m22) {
            s = 2 * Math.sqrt(1 + matrix.m00 - matrix.m11 - matrix.m22);
            result.setXYZW(0.25 * s, (matrix.m01 + matrix.m10) / s, (matrix.m02 + matrix.m20) / s, (matrix.m21 - matrix.m12) / s);
        } else if (matrix.m11 > matrix.m22) {
            s = 2 * Math.sqrt(1 - matrix.m00 + matrix.m11 - matrix.m22);
            result.setXYZW((matrix.m10 + matrix.m01) / s, 0.25 * s, (matrix.m21 + matrix.m12) / s, (matrix.m02 - matrix.m20) / s);
        } else {
            s = 2 * Math.sqrt(1 - matrix.m00 - matrix.m11 + matrix.m22);
            result.setXYZW((matrix.m02 + matrix.m20) / s, (matrix.m12 + matrix.m21) / s, 0.25 * s, (matrix.m10 - matrix.m01) / s);
        }
        return result;
    }
    /** @internal */ toMatrix(matrix) {
        const xx = this.x * this.x;
        const yy = this.y * this.y;
        const zz = this.z * this.z;
        const xy = this.x * this.y;
        const zw = this.z * this.w;
        const zx = this.z * this.x;
        const yw = this.y * this.w;
        const yz = this.y * this.z;
        const xw = this.x * this.w;
        matrix.m00 = 1 - 2 * (yy + zz);
        matrix.m10 = 2 * (xy + zw);
        matrix.m20 = 2 * (zx - yw);
        matrix.m01 = 2 * (xy - zw);
        matrix.m11 = 1 - 2 * (zz + xx);
        matrix.m21 = 2 * (yz + xw);
        matrix.m02 = 2 * (zx + yw);
        matrix.m12 = 2 * (yz - xw);
        matrix.m22 = 1 - 2 * (yy + xx);
    }
}
/**
 * Observable 4 dimentional vector
 *
 * @public
 */ class ObservableQuaternion extends Quaternion {
    /** @internal */ _callback;
    /** The callback function which will be executed when the value changed */ get callback() {
        return this._callback;
    }
    set callback(cb) {
        this._callback = cb;
    }
    /**
   * {@inheritDoc Quaternion.x}
   */ get x() {
        return super.x;
    }
    set x(val) {
        val = toFloat(val);
        if (val !== super.x) {
            super.x = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.y}
   */ get y() {
        return super.y;
    }
    set y(val) {
        val = toFloat(val);
        if (val !== super.y) {
            super.y = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.z}
   */ get z() {
        return super.z;
    }
    set z(val) {
        val = toFloat(val);
        if (val !== super.z) {
            super.z = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.w}
   */ get w() {
        return super.w;
    }
    set w(val) {
        val = toFloat(val);
        if (val !== super.w) {
            super.w = val;
            this._callback && this._callback();
        }
    }
    /**
   * {@inheritDoc Quaternion.setXYZW}
   */ setXYZW(x, y, z, w) {
        x = toFloat(x);
        y = toFloat(y);
        z = toFloat(z);
        w = toFloat(w);
        if (x !== super.x || y !== super.y || z !== super.z || w !== super.w) {
            super.setXYZW(x, y, z, w);
            this._callback && this._callback();
        }
        return this;
    }
    /**
   * Inherited from Float32Array.copyWithin
   */ copyWithin(target, start, end) {
        super.copyWithin(target, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.fill
   */ fill(value, start, end) {
        super.fill(value, start, end);
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.reverse
   */ reverse() {
        super.reverse();
        this._callback && this._callback();
        return this;
    }
    /**
   * Inherited from Float32Array.set
   */ set(array, offset) {
        super.set(array, offset);
        this._callback && this._callback();
    }
    /**
   * Inherited from Float32Array.sort
   */ sort(compareFn) {
        super.sort(compareFn);
        this._callback && this._callback();
        return this;
    }
}
/**
 * 3x3 Matrix
 *
 * @remarks
 * The matrix is column-major:
 * | m00, m10, m20 |
 * | m01, m11, m21 |
 * | m02, m12, m22 |
 *
 * @public
 */ class Matrix3x3 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 9);
        } else {
            super(9);
            if (typeof arg0 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
                this[4] = arg4;
                this[5] = arg5;
                this[6] = arg6;
                this[7] = arg7;
                this[8] = arg8;
            } else if (arg0 instanceof Quaternion) {
                arg0.toMatrix3x3(this);
            } else if (arg0 instanceof Matrix4x4) {
                this[0] = arg0[0];
                this[1] = arg0[1];
                this[2] = arg0[2];
                this[3] = arg0[4];
                this[4] = arg0[5];
                this[5] = arg0[6];
                this[6] = arg0[8];
                this[7] = arg0[9];
                this[8] = arg0[10];
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 9) {
                this.set(arg0);
            } else if (arg0 === void 0) {
                this.identity();
            } else {
                throw new Error('Matrix3x4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Matrix3x3 initialized with values from this matrix.
   * @returns The new matrix.
   */ clone() {
        return new Matrix3x3(this);
    }
    /** Get the element at row 0, column 0 */ get m00() {
        return this[0];
    }
    set m00(v) {
        this[0] = v;
    }
    /** Get the element at row 0, column 1 */ get m10() {
        return this[1];
    }
    set m10(v) {
        this[1] = v;
    }
    /** Get the element at row 0, column 2 */ get m20() {
        return this[2];
    }
    set m20(v) {
        this[2] = v;
    }
    /** Get the element at row 1, column 0 */ get m01() {
        return this[3];
    }
    set m01(v) {
        this[3] = v;
    }
    /** Get the element at row 1, column 1 */ get m11() {
        return this[4];
    }
    set m11(v) {
        this[4] = v;
    }
    /** Get the element at row 1, column 2 */ get m21() {
        return this[5];
    }
    set m21(v) {
        this[5] = v;
    }
    /** Get the element at row 2, column 0 */ get m02() {
        return this[6];
    }
    set m02(v) {
        this[6] = v;
    }
    /** Get the element at row 2, column 1 */ get m12() {
        return this[7];
    }
    set m12(v) {
        this[7] = v;
    }
    /** Get the element at row 2, column 2 */ get m22() {
        return this[8];
    }
    set m22(v) {
        this[8] = v;
    }
    /**
   * Get the values in a row as a Vector3
   * @param row - The row index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getRow(row, result) {
        return (result || new Vector3()).setXYZ(this[row * 3], this[row * 3 + 1], this[row * 3 + 2]);
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param v - The values to be set
   * @returns - self
   */ setRow(row, v) {
        this[row * 3] = v.x;
        this[row * 3 + 1] = v.y;
        this[row * 3 + 2] = v.z;
        return this;
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param x - The first value of the row to be set
   * @param y - The second value of the row to be set
   * @param z - The third value of the row to be set
   * @returns - self
   */ setRowXYZ(row, x, y, z) {
        this[row * 3] = x;
        this[row * 3 + 1] = y;
        this[row * 3 + 2] = z;
        return this;
    }
    /**
   * Get the values in a column as a Vector3
   * @param col - The column index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getCol(col, result) {
        return (result || new Vector3()).setXYZ(this[col], this[3 + col], this[6 + col]);
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param v - The values to be set.
   * @returns self
   */ setCol(col, v) {
        this[col] = v.x;
        this[3 + col] = v.y;
        this[6 + col] = v.z;
        return this;
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param x - The first value of the column to be set.
   * @param y - The second value of the column to be set.
   * @param z - The third value of the column to be set.
   * @returns self
   */ setColXYZ(col, x, y, z) {
        this[col] = x;
        this[3 + col] = y;
        this[6 + col] = z;
        return this;
    }
    /**
   * Adds two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static add(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] + b[i];
        }
        return result;
    }
    /**
   * Subtracts two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns
   */ static sub(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] - b[i];
        }
        return result;
    }
    /**
   * Multiplys two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static mul(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] * b[i];
        }
        return result;
    }
    /**
   * Divides two Matrix3x3's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static div(a, b, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] / b[i];
        }
        return result;
    }
    /**
   * Scales a Matrix3x3 by a scalar number component-wise.
   * @param a - The matrix to be scaled.
   * @param f - The scalar number.
   * @param result - The output matrix (can be the same as a), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scale(a, f, result) {
        result = result || new Matrix3x3();
        for(let i = 0; i < 9; i++){
            result[i] = a[i] * f;
        }
        return result;
    }
    /**
   * Creates an identity Matrix3x3.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static identity(result) {
        result = result || new Matrix3x3();
        result.set(IDENT_MATRIX3x3);
        return result;
    }
    /**
   * Transpose a Matrix3x3.
   * @param matrix - The matrix to be transposed.
   * @param result - The output matrix (can be the same as matrix), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static transpose(matrix, result) {
        result = result || new Matrix3x3();
        if (matrix === result) {
            [result[1], result[3]] = [
                result[3],
                result[1]
            ];
            [result[2], result[6]] = [
                result[6],
                result[2]
            ];
            [result[5], result[7]] = [
                result[7],
                result[5]
            ];
        } else {
            result[0] = matrix[0];
            result[1] = matrix[3];
            result[2] = matrix[6];
            result[3] = matrix[1];
            result[4] = matrix[4];
            result[5] = matrix[7];
            result[6] = matrix[2];
            result[7] = matrix[5];
            result[8] = matrix[8];
        }
        return result;
    }
    /**
   * Inverts a Matrix3x3
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invert(matrix, result) {
        result = result || new Matrix3x3();
        const m00 = matrix[0];
        const m01 = matrix[1];
        const m02 = matrix[2];
        const m10 = matrix[3];
        const m11 = matrix[4];
        const m12 = matrix[5];
        const m20 = matrix[6];
        const m21 = matrix[7];
        const m22 = matrix[8];
        const tmp_0 = m22 * m11 - m12 * m21;
        const tmp_1 = m12 * m20 - m22 * m10;
        const tmp_2 = m21 * m10 - m20 * m11;
        const d = 1 / (m00 * tmp_0 + m01 * tmp_1 + m02 * tmp_2);
        result[0] = tmp_0 * d;
        result[1] = (m02 * m21 - m22 * m01) * d;
        result[2] = (m12 * m01 - m02 * m11) * d;
        result[3] = tmp_1 * d;
        result[4] = (m22 * m00 - m02 * m20) * d;
        result[5] = (m02 * m10 - m12 * m00) * d;
        result[6] = tmp_2 * d;
        result[7] = (m01 * m20 - m21 * m00) * d;
        result[8] = (m11 * m00 - m01 * m10) * d;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around x axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationX(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = c;
        result[5] = s;
        result[6] = 0;
        result[7] = -s;
        result[8] = c;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around y axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationY(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = 0;
        result[2] = -s;
        result[3] = 0;
        result[4] = 1;
        result[5] = 0;
        result[6] = s;
        result[7] = 0;
        result[8] = c;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around z axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationZ(angle, result) {
        result = result || new Matrix3x3();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = s;
        result[2] = 0;
        result[3] = -s;
        result[4] = c;
        result[5] = 0;
        result[6] = 0;
        result[7] = 0;
        result[8] = 1;
        return result;
    }
    /**
   * Creates a Matrix3x3 that presents a rotation around a given axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotation(axis, angle, result) {
        result = result || new Matrix3x3();
        let x = axis.x;
        let y = axis.y;
        let z = axis.z;
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const oneMinusCosine = 1 - c;
        result[0] = xx + (1 - xx) * c;
        result[1] = x * y * oneMinusCosine + z * s;
        result[2] = x * z * oneMinusCosine - y * s;
        result[3] = x * y * oneMinusCosine - z * s;
        result[4] = yy + (1 - yy) * c;
        result[5] = y * z * oneMinusCosine + x * s;
        result[6] = x * z * oneMinusCosine + y * s;
        result[7] = y * z * oneMinusCosine - x * s;
        result[8] = zz + (1 - zz) * c;
        return result;
    }
    /**
   * Multiplies two Matrix3x3's
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiply(m1, m2, result) {
        result = result || new Matrix3x3();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a10 = m1[3];
        const a11 = m1[4];
        const a12 = m1[5];
        const a20 = m1[6];
        const a21 = m1[7];
        const a22 = m1[8];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b10 = m2[3];
        const b11 = m2[4];
        const b12 = m2[5];
        const b20 = m2[6];
        const b21 = m2[7];
        const b22 = m2[8];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = a00 * b10 + a10 * b11 + a20 * b12;
        result[4] = a01 * b10 + a11 * b11 + a21 * b12;
        result[5] = a02 * b10 + a12 * b11 + a22 * b12;
        result[6] = a00 * b20 + a10 * b21 + a20 * b22;
        result[7] = a01 * b20 + a11 * b21 + a21 * b22;
        result[8] = a02 * b20 + a12 * b21 + a22 * b22;
        return result;
    }
    /**
   * Subtract a matrix from this matrix component-wise.
   * @param other - The matrix that will be subtract.
   * @returns self
   */ subBy(other) {
        return Matrix3x3.sub(this, other, this);
    }
    /**
   * Add a matrix to this matrix component-wise.
   * @param other - The matrix that will be added.
   * @returns self
   */ addBy(other) {
        return Matrix3x3.add(this, other, this);
    }
    /**
   * Multiplies this matrix by a matrix component-wise.
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Matrix3x3.mul(this, other, this);
    }
    /**
   * Divide this matrix by a matrix component-wise.
   * @param other - The matrix that will be divide by.
   * @returns self
   */ divBy(other) {
        return Matrix3x3.div(this, other, this);
    }
    /**
   * Scale this matrix by a scalar number component-wise.
   * @param f - amount to scale this matrix by.
   * @returns self
   */ scaleBy(f) {
        return Matrix3x3.scale(this, f, this);
    }
    /**
   * Make this matrix identity.
   * @returns self
   */ identity() {
        return Matrix3x3.identity(this);
    }
    /**
   * Calculate the inverse of this matrix inplace.
   * @returns self
   */ inplaceInvert() {
        return Matrix3x3.invert(this, this);
    }
    /**
   * Calculate the transpose of this matrix inplace.
   * @returns self
   */ transpose() {
        return Matrix3x3.transpose(this, this);
    }
    /**
   * Post-multiply by a matrix inplace.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Matrix3x3.multiply(this, other, this);
    }
    /**
   * Pre-multiply by a matrix inplace.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Matrix3x3.multiply(other, this, this);
    }
    /**
   * Calculates a rotation around x axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationX(angle) {
        return Matrix3x3.rotationX(angle, this);
    }
    /**
   * Calculates a rotation around y axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationY(angle) {
        return Matrix3x3.rotationY(angle, this);
    }
    /**
   * Calculates a rotation around z axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationZ(angle) {
        return Matrix3x3.rotationZ(angle, this);
    }
    /**
   * Calculates a rotation around a given axis.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotation(axis, angle) {
        return Matrix3x3.rotation(axis, angle, this);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transform(vec, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * vec[0] + this[3] * vec[1] + this[6] * vec[2], this[1] * vec[0] + this[4] * vec[1] + this[7] * vec[2], this[2] * vec[0] + this[5] * vec[1] + this[8] * vec[2]);
    }
    /**
   * {@inheritDoc Matrix3x3.transform}
   */ transformPoint(vec, result) {
        return this.transform(vec, result);
    }
    /**
   * {@inheritDoc Matrix3x3.transform}
   */ transformVector(vec, result) {
        return this.transform(vec, result);
    }
}
/**
 * 4x4 Matrix
 *
 * @remarks
 * The matrix is column-major:
 * | m00, m10, m20, m30 |
 * | m01, m11, m21, m31 |
 * | m02, m12, m22, m32 |
 * | m03, m13, m23, m33 |
 *
 * @public
 */ class Matrix4x4 extends VectorBase {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15){
        if (arg0 instanceof ArrayBuffer && typeof arg1 === 'number') {
            super(arg0, arg1, 16);
        } else {
            super(16);
            if (typeof arg0 === 'number') {
                this[0] = arg0;
                this[1] = arg1;
                this[2] = arg2;
                this[3] = arg3;
                this[4] = arg4;
                this[5] = arg5;
                this[6] = arg6;
                this[7] = arg7;
                this[8] = arg8;
                this[9] = arg9;
                this[10] = arg10;
                this[11] = arg11;
                this[12] = arg12;
                this[13] = arg13;
                this[14] = arg14;
                this[15] = arg15;
            } else if (arg0 instanceof Quaternion) {
                arg0.toMatrix4x4(this);
                this.m03 = 0;
                this.m13 = 0;
                this.m23 = 0;
                this.m30 = 0;
                this.m31 = 0;
                this.m32 = 0;
                this.m33 = 1;
            } else if (arg0 instanceof Matrix3x3) {
                this.m00 = arg0.m00;
                this.m01 = arg0.m01;
                this.m02 = arg0.m02;
                this.m03 = 0;
                this.m10 = arg0.m10;
                this.m11 = arg0.m11;
                this.m12 = arg0.m12;
                this.m13 = 0;
                this.m20 = arg0.m20;
                this.m21 = arg0.m21;
                this.m22 = arg0.m22;
                this.m23 = 0;
                this.m30 = 0;
                this.m31 = 0;
                this.m32 = 0;
                this.m33 = 1;
            } else if ((arg0 instanceof Float32Array || Array.isArray(arg0)) && arg0.length >= 16) {
                this.set(arg0);
            } else if (arg0 === void 0) {
                this.identity();
            } else {
                throw new Error('Matrix4x4.constructor(): invalid arguments');
            }
        }
    }
    /**
   * Creates a new Matrix4x4 initialized with values from this matrix.
   * @returns The new matrix.
   */ clone() {
        return new Matrix4x4(this);
    }
    /** Get the element at row 0, column 0 */ get m00() {
        return this[0];
    }
    set m00(v) {
        this[0] = v;
    }
    /** Get the element at row 0, column 1 */ get m10() {
        return this[1];
    }
    set m10(v) {
        this[1] = v;
    }
    /** Get the element at row 0, column 2 */ get m20() {
        return this[2];
    }
    set m20(v) {
        this[2] = v;
    }
    /** Get the element at row 0, column 3 */ get m30() {
        return this[3];
    }
    set m30(v) {
        this[3] = v;
    }
    /** Get the element at row 1, column 0 */ get m01() {
        return this[4];
    }
    set m01(v) {
        this[4] = v;
    }
    /** Get the element at row 1, column 1 */ get m11() {
        return this[5];
    }
    set m11(v) {
        this[5] = v;
    }
    /** Get the element at row 1, column 2 */ get m21() {
        return this[6];
    }
    set m21(v) {
        this[6] = v;
    }
    /** Get the element at row 1, column 3 */ get m31() {
        return this[7];
    }
    set m31(v) {
        this[7] = v;
    }
    /** Get the element at row 2, column 0 */ get m02() {
        return this[8];
    }
    set m02(v) {
        this[8] = v;
    }
    /** Get the element at row 2, column 1 */ get m12() {
        return this[9];
    }
    set m12(v) {
        this[9] = v;
    }
    /** Get the element at row 2, column 2 */ get m22() {
        return this[10];
    }
    set m22(v) {
        this[10] = v;
    }
    /** Get the element at row 2, column 3 */ get m32() {
        return this[11];
    }
    set m32(v) {
        this[11] = v;
    }
    /** Get the element at row 3, column 0 */ get m03() {
        return this[12];
    }
    set m03(v) {
        this[12] = v;
    }
    /** Get the element at row 3, column 1 */ get m13() {
        return this[13];
    }
    set m13(v) {
        this[13] = v;
    }
    /** Get the element at row 3, column 2 */ get m23() {
        return this[14];
    }
    set m23(v) {
        this[14] = v;
    }
    /** Get the element at row 3, column 3 */ get m33() {
        return this[15];
    }
    set m33(v) {
        this[15] = v;
    }
    /**
   * Get the values in a row as a Vector4
   * @param row - The row index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getRow(row, result) {
        return (result || new Vector4()).setXYZW(this[row * 4], this[row * 4 + 1], this[row * 4 + 2], this[row * 4 + 3]);
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param v - The values to be set
   * @returns - self
   */ setRow(row, v) {
        this[row * 4] = v.x;
        this[row * 4 + 1] = v.y;
        this[row * 4 + 2] = v.z;
        this[row * 4 + 3] = v.w;
        return this;
    }
    /**
   * Set values to a row in the matrix.
   * @param row - The row index
   * @param x - The first value of the row to be set
   * @param y - The second value of the row to be set
   * @param z - The third value of the row to be set
   * @param w - The fourth value of the row to be set
   * @returns - self
   */ setRowXYZW(row, x, y, z, w) {
        this[row * 4] = x;
        this[row * 4 + 1] = y;
        this[row * 4 + 2] = z;
        this[row * 4 + 3] = w;
        return this;
    }
    /**
   * Get the values in a column as a Vector4
   * @param col - The column index
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ getCol(col, result) {
        return (result || new Vector4()).setXYZW(this[col], this[4 + col], this[8 + col], this[12 + col]);
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param v - The values to be set.
   * @returns self
   */ setCol(col, v) {
        this[col] = v.x;
        this[4 + col] = v.y;
        this[8 + col] = v.z;
        this[12 + col] = v.w;
        return this;
    }
    /**
   * Set values to a column in the matrix.
   * @param col - The column index.
   * @param x - The first value of the column to be set.
   * @param y - The second value of the column to be set.
   * @param z - The third value of the column to be set.
   * @param w - The fourth value of the column to be set.
   * @returns self
   */ setColXYZW(col, x, y, z, w) {
        this[col] = x;
        this[4 + col] = y;
        this[8 + col] = z;
        this[12 + col] = w;
        return this;
    }
    /**
   * Adds two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static add(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] + b[i];
        }
        return result;
    }
    /**
   * Subtracts two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns
   */ static sub(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] - b[i];
        }
        return result;
    }
    /**
   * Multiplys two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static mul(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] * b[i];
        }
        return result;
    }
    /**
   * Divides two Matrix4x4's component-wise.
   * @param a - The first operand.
   * @param b - The second operand.
   * @param result - The output matrix (can be the same as a or b), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static div(a, b, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] / b[i];
        }
        return result;
    }
    /**
   * Scales a Matrix4x4 by a scalar number component-wise.
   * @param a - The matrix to be scaled.
   * @param f - The scalar number.
   * @param result - The output matrix (can be the same as a), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scale(a, f, result) {
        result = result || new Matrix4x4();
        for(let i = 0; i < 16; i++){
            result[i] = a[i] * f;
        }
        return result;
    }
    /**
   * Creates an identity Matrix4x4.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static identity(result) {
        result = result || new Matrix4x4();
        result.set(IDENT_MATRIX4x4);
        return result;
    }
    /**
   * Creates an orthogonal projection matrix from a given frustum.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static ortho(left, right, bottom, top, near, far, result) {
        result = result || new Matrix4x4();
        result[0] = 2 / (right - left);
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 2 / (top - bottom);
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 2 / (near - far);
        result[11] = 0;
        result[12] = (left + right) / (left - right);
        result[13] = (bottom + top) / (bottom - top);
        result[14] = (near + far) / (near - far);
        result[15] = 1;
        return result;
    }
    /**
   * Creates a reflection matrix from a plane.
   * @param nx - The x component of the plane normal.
   * @param ny - The y component of the plane normal.
   * @param nz - The z component of the plane normal.
   * @param d - The plane distance.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static reflection(nx, ny, nz, d, result) {
        result = result || new Matrix4x4();
        result.m00 = 1 - 2 * nx * nx;
        result.m01 = -2 * nx * ny;
        result.m02 = -2 * nx * nz;
        result.m03 = -2 * nx * d;
        result.m10 = -2 * nx * ny;
        result.m11 = 1 - 2 * ny * ny;
        result.m12 = -2 * ny * nz;
        result.m13 = -2 * ny * d;
        result.m20 = -2 * nx * nz;
        result.m21 = -2 * ny * nz;
        result.m22 = 1 - 2 * nz * nz;
        result.m23 = -2 * nz * d;
        result.m30 = 0;
        result.m31 = 0;
        result.m32 = 0;
        result.m33 = 1;
        return result;
    }
    /**
   * Creates a right-handed perspective projection matrix.
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio.
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static perspective(fovY, aspect, znear, zfar, result) {
        const h = znear * Math.tan(fovY * 0.5);
        const w = h * aspect;
        return this.frustum(-w, w, -h, h, znear, zfar, result);
    }
    static obliqueProjection(projectionMatrix, clipPlane) {
        const result = new Matrix4x4(projectionMatrix);
        const q = Matrix4x4.invert(projectionMatrix).transform(new Vector4(clipPlane.a > 0 ? 1 : -1, clipPlane.b > 0 ? 1 : -1, 1, 1));
        const s = 2 / (q.x * clipPlane.a + q.y * clipPlane.b + q.z * clipPlane.c + q.w * clipPlane.d);
        result[2] = clipPlane.a * s - result[3];
        result[6] = clipPlane.b * s - result[7];
        result[10] = clipPlane.c * s - result[11];
        result[14] = clipPlane.d * s - result[15];
        return result;
    }
    static obliquePerspective(perspectiveMatrix, nearPlane) {
        const result = new Matrix4x4(perspectiveMatrix);
        const q = new Vector4(((nearPlane.x > 0 ? 1 : nearPlane.x < 0 ? -1 : 0) + perspectiveMatrix.m02) / perspectiveMatrix.m00, ((nearPlane.y > 0 ? 1 : nearPlane.y < 0 ? -1 : 0) + perspectiveMatrix.m12) / perspectiveMatrix.m11, -1, (1 + perspectiveMatrix.m22) / perspectiveMatrix.m23);
        const c = Vector4.scale(nearPlane, 2 / Vector4.dot(nearPlane, q));
        result.m20 = c.x;
        result.m21 = c.y;
        result.m22 = c.z + 1;
        result.m23 = c.w;
        return result;
    /*
        float       matrix[16];
        Vector4D    q;

        // Grab the current projection matrix from OpenGL
        glGetFloatv(GL_PROJECTION_MATRIX, matrix);

        // Calculate the clip-space corner point opposite the clipping plane
        // as (sgn(clipPlane.x), sgn(clipPlane.y), 1, 1) and
        // transform it into camera space by multiplying it
        // by the inverse of the projection matrix

        q.x = (sgn(clipPlane.x) + matrix[8]) / matrix[0];
        q.y = (sgn(clipPlane.y) + matrix[9]) / matrix[5];
        q.z = -1.0F;
        q.w = (1.0F + matrix[10]) / matrix[14];

        // Calculate the scaled plane vector
        Vector4D c = clipPlane * (2.0F / Dot(clipPlane, q));

        // Replace the third row of the projection matrix
        matrix[2] = c.x;
        matrix[6] = c.y;
        matrix[10] = c.z + 1.0F;
        matrix[14] = c.w;

        // Load it back into OpenGL
        glMatrixMode(GL_PROJECTION);
        glLoadMatrix(matrix);
    }
    */ }
    /**
   * Creates a perspective projection matrix from a frustum.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param znear - Near bound of the frustum.
   * @param zfar - Far bound of the frustum.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static frustum(left, right, bottom, top, znear, zfar, result) {
        result = result || new Matrix4x4();
        const dx = right - left;
        const dy = top - bottom;
        const dz = znear - zfar;
        result[0] = 2 * znear / dx;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 2 * znear / dy;
        result[6] = 0;
        result[7] = 0;
        result[8] = (left + right) / dx;
        result[9] = (top + bottom) / dy;
        result[10] = (znear + zfar) / dz;
        result[11] = -1;
        result[12] = 0;
        result[13] = 0;
        result[14] = 2 * znear * zfar / dz;
        result[15] = 0;
        return result;
    }
    /**
   * Transpose a Matrix4x4.
   * @param matrix - The matrix to be transposed.
   * @param result - The output matrix (can be the same as matrix), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static transpose(matrix, result) {
        result = result || new Matrix4x4();
        if (matrix === result) {
            [result[1], result[4]] = [
                result[4],
                result[1]
            ];
            [result[2], result[8]] = [
                result[8],
                result[2]
            ];
            [result[3], result[12]] = [
                result[12],
                result[3]
            ];
            [result[6], result[9]] = [
                result[9],
                result[6]
            ];
            [result[7], result[13]] = [
                result[13],
                result[7]
            ];
            [result[11], result[14]] = [
                result[14],
                result[11]
            ];
        } else {
            result[0] = matrix[0];
            result[1] = matrix[4];
            result[2] = matrix[8];
            result[3] = matrix[12];
            result[4] = matrix[1];
            result[5] = matrix[5];
            result[6] = matrix[9];
            result[7] = matrix[13];
            result[8] = matrix[2];
            result[9] = matrix[6];
            result[10] = matrix[10];
            result[11] = matrix[14];
            result[12] = matrix[3];
            result[13] = matrix[7];
            result[14] = matrix[11];
            result[15] = matrix[15];
        }
        return result;
    }
    /**
   * Inverts a Matrix4x4
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invert(matrix, result) {
        result = result || new Matrix4x4();
        const m00 = matrix[0 * 4 + 0];
        const m01 = matrix[0 * 4 + 1];
        const m02 = matrix[0 * 4 + 2];
        const m03 = matrix[0 * 4 + 3];
        const m10 = matrix[1 * 4 + 0];
        const m11 = matrix[1 * 4 + 1];
        const m12 = matrix[1 * 4 + 2];
        const m13 = matrix[1 * 4 + 3];
        const m20 = matrix[2 * 4 + 0];
        const m21 = matrix[2 * 4 + 1];
        const m22 = matrix[2 * 4 + 2];
        const m23 = matrix[2 * 4 + 3];
        const m30 = matrix[3 * 4 + 0];
        const m31 = matrix[3 * 4 + 1];
        const m32 = matrix[3 * 4 + 2];
        const m33 = matrix[3 * 4 + 3];
        const tmp_0 = m22 * m33;
        const tmp_1 = m32 * m23;
        const tmp_2 = m12 * m33;
        const tmp_3 = m32 * m13;
        const tmp_4 = m12 * m23;
        const tmp_5 = m22 * m13;
        const tmp_6 = m02 * m33;
        const tmp_7 = m32 * m03;
        const tmp_8 = m02 * m23;
        const tmp_9 = m22 * m03;
        const tmp_10 = m02 * m13;
        const tmp_11 = m12 * m03;
        const tmp_12 = m20 * m31;
        const tmp_13 = m30 * m21;
        const tmp_14 = m10 * m31;
        const tmp_15 = m30 * m11;
        const tmp_16 = m10 * m21;
        const tmp_17 = m20 * m11;
        const tmp_18 = m00 * m31;
        const tmp_19 = m30 * m01;
        const tmp_20 = m00 * m21;
        const tmp_21 = m20 * m01;
        const tmp_22 = m00 * m11;
        const tmp_23 = m10 * m01;
        const t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
        const t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
        const t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
        const t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
        const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        result[0] = d * t0;
        result[1] = d * t1;
        result[2] = d * t2;
        result[3] = d * t3;
        result[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
        result[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
        result[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
        result[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
        result[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
        result[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
        result[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
        result[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
        result[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
        result[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
        result[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
        result[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));
        return result;
    }
    /**
   * Inverts a Matrix4x4 which presents an affine transformation.
   * @param matrix - The matrix to be inverted.
   * @param result - The output matrix (can be the same as matrix). if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static invertAffine(matrix, result) {
        result = result || new Matrix4x4();
        const m00 = matrix[0 * 4 + 0];
        const m01 = matrix[0 * 4 + 1];
        const m02 = matrix[0 * 4 + 2];
        const m10 = matrix[1 * 4 + 0];
        const m11 = matrix[1 * 4 + 1];
        const m12 = matrix[1 * 4 + 2];
        const m20 = matrix[2 * 4 + 0];
        const m21 = matrix[2 * 4 + 1];
        const m22 = matrix[2 * 4 + 2];
        const m30 = matrix[3 * 4 + 0];
        const m31 = matrix[3 * 4 + 1];
        const m32 = matrix[3 * 4 + 2];
        const t0 = m22 * m11 - m12 * m21;
        const t1 = m02 * m21 - m22 * m01;
        const t2 = m12 * m01 - m02 * m11;
        const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2);
        result[0] = d * t0;
        result[1] = d * t1;
        result[2] = d * t2;
        result[3] = 0;
        result[4] = d * (m12 * m20 - m22 * m10);
        result[5] = d * (m22 * m00 - m02 * m20);
        result[6] = d * (m02 * m10 - m12 * m00);
        result[7] = 0;
        result[8] = d * (m10 * m21 - m20 * m11);
        result[9] = d * (m20 * m01 - m00 * m21);
        result[10] = d * (m00 * m11 - m10 * m01);
        result[11] = 0;
        result[12] = d * (m10 * m31 * m22 + m20 * m11 * m32 + m30 * m21 * m12 - (m10 * m21 * m32 + m20 * m31 * m12 + m30 * m11 * m22));
        result[13] = d * (m00 * m21 * m32 + m20 * m31 * m02 + m30 * m01 * m22 - (m00 * m31 * m22 + m20 * m01 * m32 + m30 * m21 * m02));
        result[14] = d * (m00 * m31 * m12 + m10 * m01 * m32 + m30 * m11 * m02 - (m00 * m11 * m32 + m10 * m31 * m02 + m30 * m01 * m12));
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a translation.
   * @param t - The translate vector.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translation(t, result) {
        result = result || new Matrix4x4();
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 1;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 1;
        result[11] = 0;
        result[12] = t.x;
        result[13] = t.y;
        result[14] = t.z;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a scaling.
   * @param s - The scale vector.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaling(s, result) {
        result = result || new Matrix4x4();
        result[0] = s.x;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = s.y;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = s.z;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the x axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationX(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = 1;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = c;
        result[6] = s;
        result[7] = 0;
        result[8] = 0;
        result[9] = -s;
        result[10] = c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the y axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationY(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = 0;
        result[2] = -s;
        result[3] = 0;
        result[4] = 0;
        result[5] = 1;
        result[6] = 0;
        result[7] = 0;
        result[8] = s;
        result[9] = 0;
        result[10] = c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around the z axis.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotationZ(angle, result) {
        result = result || new Matrix4x4();
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        result[0] = c;
        result[1] = s;
        result[2] = 0;
        result[3] = 0;
        result[4] = -s;
        result[5] = c;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 1;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a Matrix4x4 which presents a rotation around a given axis.
   * @param axis - The axis vector.
   * @param angle - The rotate angle in radians.
   * @param result - The output matrix. if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotation(axis, angle, result) {
        result = result || new Matrix4x4();
        let x = axis.x;
        let y = axis.y;
        let z = axis.z;
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const oneMinusCosine = 1 - c;
        result[0] = xx + (1 - xx) * c;
        result[1] = x * y * oneMinusCosine + z * s;
        result[2] = x * z * oneMinusCosine - y * s;
        result[3] = 0;
        result[4] = x * y * oneMinusCosine - z * s;
        result[5] = yy + (1 - yy) * c;
        result[6] = y * z * oneMinusCosine + x * s;
        result[7] = 0;
        result[8] = x * z * oneMinusCosine + y * s;
        result[9] = y * z * oneMinusCosine - x * s;
        result[10] = zz + (1 - zz) * c;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a look-at matrix.
   * @param eye - Position of the eye.
   * @param target - The point that the eye is looking at.
   * @param up - The up vector.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static lookAt(eye, target, up, result) {
        result = result || new Matrix4x4();
        const zAxis = Vector3.normalize(Vector3.sub(eye, target));
        const xAxis = Vector3.normalize(Vector3.cross(up, zAxis));
        const yAxis = Vector3.normalize(Vector3.cross(zAxis, xAxis));
        result[0] = xAxis.x;
        result[1] = xAxis.y;
        result[2] = xAxis.z;
        result[3] = 0;
        result[4] = yAxis.x;
        result[5] = yAxis.y;
        result[6] = yAxis.z;
        result[7] = 0;
        result[8] = zAxis.x;
        result[9] = zAxis.y;
        result[10] = zAxis.z;
        result[11] = 0;
        result[12] = eye.x;
        result[13] = eye.y;
        result[14] = eye.z;
        result[15] = 1;
        return result;
    }
    /**
   * Creates a matrix, which presents a transform of looking at given cube face.
   * @param face - The cube face to be looked at.
   * @param result - The output matrix, if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static lookAtCubeFace(face, pos, result) {
        switch(face){
            case CubeFace.PX:
                return this.lookAt(pos, new Vector3(pos.x + 1, pos.y, pos.z), new Vector3(0, -1, 0), result);
            case CubeFace.NX:
                return this.lookAt(pos, new Vector3(pos.x - 1, pos.y, pos.z), new Vector3(0, -1, 0), result);
            case CubeFace.PY:
                return this.lookAt(pos, new Vector3(pos.x, pos.y + 1, pos.z), new Vector3(0, 0, 1), result);
            case CubeFace.NY:
                return this.lookAt(pos, new Vector3(pos.x, pos.y - 1, pos.z), new Vector3(0, 0, -1), result);
            case CubeFace.PZ:
                return this.lookAt(pos, new Vector3(pos.x, pos.y, pos.z + 1), new Vector3(0, -1, 0), result);
            case CubeFace.NZ:
                return this.lookAt(pos, new Vector3(pos.x, pos.y, pos.z - 1), new Vector3(0, -1, 0), result);
            default:
                return null;
        }
    }
    /**
   * Multiplies two Matrix4x4's
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiply(m1, m2, result) {
        result = result || new Matrix4x4();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a03 = m1[3];
        const a10 = m1[4];
        const a11 = m1[5];
        const a12 = m1[6];
        const a13 = m1[7];
        const a20 = m1[8];
        const a21 = m1[9];
        const a22 = m1[10];
        const a23 = m1[11];
        const a30 = m1[12];
        const a31 = m1[13];
        const a32 = m1[14];
        const a33 = m1[15];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b03 = m2[3];
        const b10 = m2[4];
        const b11 = m2[5];
        const b12 = m2[6];
        const b13 = m2[7];
        const b20 = m2[8];
        const b21 = m2[9];
        const b22 = m2[10];
        const b23 = m2[11];
        const b30 = m2[12];
        const b31 = m2[13];
        const b32 = m2[14];
        const b33 = m2[15];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
        result[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
        result[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
        result[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
        result[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
        return result;
    }
    /**
   * Multiplies two Matrix4x4's which present affine transformations.
   * @param m1 - The first operand.
   * @param m2 - The second operand.
   * @param result - The output matrix (can be the same as m1 or m2), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static multiplyAffine(m1, m2, result) {
        result = result || new Matrix4x4();
        const a00 = m1[0];
        const a01 = m1[1];
        const a02 = m1[2];
        const a10 = m1[4];
        const a11 = m1[5];
        const a12 = m1[6];
        const a20 = m1[8];
        const a21 = m1[9];
        const a22 = m1[10];
        const a30 = m1[12];
        const a31 = m1[13];
        const a32 = m1[14];
        const b00 = m2[0];
        const b01 = m2[1];
        const b02 = m2[2];
        const b10 = m2[4];
        const b11 = m2[5];
        const b12 = m2[6];
        const b20 = m2[8];
        const b21 = m2[9];
        const b22 = m2[10];
        const b30 = m2[12];
        const b31 = m2[13];
        const b32 = m2[14];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = 0;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = 0;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = 0;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32;
        result[15] = 1;
        return result;
    }
    /**
   * Post-translate a Matrix4x4 by a vector.
   *
   * @remarks
   * result = m * (translate matrix for t)
   *
   * @param m - The matrix that will be translated.
   * @param t - The translate vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translateRight(m, t, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0];
            result[1] = m[1];
            result[2] = m[2];
            result[3] = m[3];
            result[4] = m[4];
            result[5] = m[5];
            result[6] = m[6];
            result[7] = m[7];
            result[8] = m[8];
            result[9] = m[9];
            result[10] = m[10];
            result[11] = m[11];
            result[12] = m[0] * t.x + m[4] * t.y + m[8] * t.z + m[12];
            result[13] = m[1] * t.x + m[5] * t.y + m[9] * t.z + m[13];
            result[14] = m[2] * t.x + m[6] * t.y + m[10] * t.z + m[14];
            result[15] = m[15];
        } else {
            const x = m[0] * t.x + m[4] * t.y + m[8] * t.z + m[12];
            const y = m[1] * t.x + m[5] * t.y + m[9] * t.z + m[13];
            const z = m[2] * t.x + m[6] * t.y + m[10] * t.z + m[14];
            result[12] = x;
            result[13] = y;
            result[14] = z;
        }
        return result;
    }
    /**
   * Pre-translate a Matrix4x4 by a vector.
   *
   * @remarks
   * result = (translate matrix for t) * m
   *
   * @param m - The matrix that will be translated.
   * @param t - The translate vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static translateLeft(m, t, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0];
            result[1] = m[1];
            result[2] = m[2];
            result[3] = m[3];
            result[4] = m[4];
            result[5] = m[5];
            result[6] = m[6];
            result[7] = m[7];
            result[8] = m[8];
            result[9] = m[9];
            result[10] = m[10];
            result[11] = m[11];
            result[12] = m[12] + t.x;
            result[13] = m[13] + t.y;
            result[14] = m[14] + t.z;
            result[15] = m[15];
        } else {
            result[12] += t.x;
            result[13] += t.y;
            result[14] += t.z;
        }
        return result;
    }
    /**
   * Post-scale a Matrix4x4 by a vector.
   *
   * @remarks
   * result = m * (scale matrix for s)
   *
   * @param m - The matrix that will be scaled.
   * @param s - The scale vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaleRight(m, s, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0] * s.x;
            result[1] = m[1] * s.x;
            result[2] = m[2] * s.x;
            result[3] = m[3] * s.x;
            result[4] = m[4] * s.y;
            result[5] = m[5] * s.y;
            result[6] = m[6] * s.y;
            result[7] = m[7] * s.y;
            result[8] = m[8] * s.z;
            result[9] = m[9] * s.z;
            result[10] = m[10] * s.z;
            result[11] = m[11] * s.z;
            result[12] = m[12];
            result[13] = m[13];
            result[14] = m[14];
            result[15] = m[15];
        } else {
            result[0] *= s.x;
            result[1] *= s.x;
            result[2] *= s.x;
            result[3] *= s.x;
            result[4] *= s.y;
            result[5] *= s.y;
            result[6] *= s.y;
            result[7] *= s.y;
            result[8] *= s.z;
            result[9] *= s.z;
            result[10] *= s.z;
            result[11] *= s.z;
        }
        return result;
    }
    /**
   * Pre-scale a Matrix4x4 by a vector.
   *
   * @remarks
   * result = (scale matrix for s) * m
   *
   * @param m - The matrix that will be translated.
   * @param s - The scale vector.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static scaleLeft(m, s, result) {
        result = result || new Matrix4x4();
        if (result !== m) {
            result[0] = m[0] * s.x;
            result[1] = m[1] * s.y;
            result[2] = m[2] * s.z;
            result[3] = m[3];
            result[4] = m[4] * s.x;
            result[5] = m[5] * s.y;
            result[6] = m[6] * s.z;
            result[7] = m[7];
            result[8] = m[8] * s.x;
            result[9] = m[9] * s.y;
            result[10] = m[10] * s.z;
            result[11] = m[11];
            result[12] = m[12] * s.x;
            result[13] = m[13] * s.y;
            result[14] = m[14] * s.z;
            result[15] = m[15];
        } else {
            result[0] *= s.x;
            result[1] *= s.y;
            result[2] *= s.z;
            result[4] *= s.x;
            result[5] *= s.y;
            result[6] *= s.z;
            result[8] *= s.x;
            result[9] *= s.y;
            result[10] *= s.z;
            result[12] *= s.x;
            result[13] *= s.y;
            result[14] *= s.z;
        }
        return result;
    }
    /**
   * Post-rotate a Matrix4x4 by a rotation matrix or quaternion.
   *
   * @remarks
   * result = m * r
   *
   * @param m - The matrix that will be translated.
   * @param r - The rotate matrix or quaternion.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotateRight(m, r, result) {
        result = result || new Matrix4x4();
        const b = r instanceof Quaternion ? new Matrix3x3(r) : r;
        const a00 = m[0];
        const a01 = m[1];
        const a02 = m[2];
        const a03 = m[3];
        const a10 = m[4];
        const a11 = m[5];
        const a12 = m[6];
        const a13 = m[7];
        const a20 = m[8];
        const a21 = m[9];
        const a22 = m[10];
        const a23 = m[11];
        const a30 = m[12];
        const a31 = m[13];
        const a32 = m[14];
        const a33 = m[15];
        const b00 = b.m00;
        const b01 = b.m10;
        const b02 = b.m20;
        const b10 = b.m01;
        const b11 = b.m11;
        const b12 = b.m21;
        const b20 = b.m02;
        const b21 = b.m12;
        const b22 = b.m22;
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = a03 * b00 + a13 * b01 + a23 * b02;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = a03 * b10 + a13 * b11 + a23 * b12;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = a03 * b20 + a13 * b21 + a23 * b22;
        result[12] = a30;
        result[13] = a31;
        result[14] = a32;
        result[15] = a33;
        return result;
    }
    /**
   * Pre-rotate a Matrix4x4 by a rotation matrix or quaternion.
   *
   * @remarks
   * result = r * m
   *
   * @param m - The matrix that will be translated.
   * @param r - The rotate matrix or quaternion.
   * @param result - The output matrix (can be the same as m), if not specified, a new matrix will be created.
   * @returns The output matrix
   */ static rotateLeft(m, r, result) {
        result = result || new Matrix4x4();
        const a = r instanceof Quaternion ? new Matrix3x3(r) : r;
        const a00 = a.m00;
        const a01 = a.m10;
        const a02 = a.m20;
        const a10 = a.m01;
        const a11 = a.m11;
        const a12 = a.m21;
        const a20 = a.m02;
        const a21 = a.m12;
        const a22 = a.m22;
        const b00 = m[0];
        const b01 = m[1];
        const b02 = m[2];
        const b03 = m[3];
        const b10 = m[4];
        const b11 = m[5];
        const b12 = m[6];
        const b13 = m[7];
        const b20 = m[8];
        const b21 = m[9];
        const b22 = m[10];
        const b23 = m[11];
        const b30 = m[12];
        const b31 = m[13];
        const b32 = m[14];
        const b33 = m[15];
        result[0] = a00 * b00 + a10 * b01 + a20 * b02;
        result[1] = a01 * b00 + a11 * b01 + a21 * b02;
        result[2] = a02 * b00 + a12 * b01 + a22 * b02;
        result[3] = b03;
        result[4] = a00 * b10 + a10 * b11 + a20 * b12;
        result[5] = a01 * b10 + a11 * b11 + a21 * b12;
        result[6] = a02 * b10 + a12 * b11 + a22 * b12;
        result[7] = b13;
        result[8] = a00 * b20 + a10 * b21 + a20 * b22;
        result[9] = a01 * b20 + a11 * b21 + a21 * b22;
        result[10] = a02 * b20 + a12 * b21 + a22 * b22;
        result[11] = b23;
        result[12] = a00 * b30 + a10 * b31 + a20 * b32;
        result[13] = a01 * b30 + a11 * b31 + a21 * b32;
        result[14] = a02 * b30 + a12 * b31 + a22 * b32;
        result[15] = b33;
        return result;
    }
    /**
   * Subtract a matrix from this matrix component-wise.
   * @param other - The matrix that will be subtract.
   * @returns self
   */ subBy(other) {
        return Matrix4x4.sub(this, other, this);
    }
    /**
   * Add a matrix to this matrix component-wise.
   * @param other - The matrix that will be added.
   * @returns self
   */ addBy(other) {
        return Matrix4x4.add(this, other, this);
    }
    /**
   * Multiplies this matrix by a matrix component-wise.
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ mulBy(other) {
        return Matrix4x4.mul(this, other, this);
    }
    /**
   * Divide this matrix by a matrix component-wise.
   * @param other - The matrix that will be divide by.
   * @returns self
   */ divBy(other) {
        return Matrix4x4.div(this, other, this);
    }
    /**
   * Scale this matrix by a scalar number component-wise.
   * @param f - amount to scale this matrix by.
   * @returns self
   */ scaleBy(f) {
        return Matrix4x4.scale(this, f, this);
    }
    /**
   * Make this matrix identity.
   * @returns self
   */ identity() {
        return Matrix4x4.identity(this);
    }
    /**
   * Calculates a right-handed perspective projection matrix inplace.
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio.
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @returns self
   */ perspective(fovY, aspect, znear, zfar) {
        return Matrix4x4.perspective(fovY, aspect, znear, zfar, this);
    }
    /**
   * Calculates a perspective projection matrix from a frustum inplace.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param znear - Near bound of the frustum.
   * @param zfar - Far bound of the frustum.
   * @returns self
   */ frustum(left, right, bottom, top, znear, zfar) {
        return Matrix4x4.frustum(left, right, bottom, top, znear, zfar, this);
    }
    /**
   * Calculates an orthogonal projection matrix inplace.
   * @param left - Left bound of the frustum.
   * @param right - Right bound of the frustum.
   * @param bottom - Bottom bound of the frustum.
   * @param top - Top bound of the frustum.
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @returns self
   */ ortho(left, right, bottom, top, near, far) {
        return Matrix4x4.ortho(left, right, bottom, top, near, far, this);
    }
    /**
   * Check if this matrix is orthogonal projection matrix.
   *
   * @remarks
   * This method assumes that this is an affine transform matrix or a projection matrix (perspective or orthogonal).
   *
   * @returns true if this is an orthogonal projection matrix, otherwise false
   */ isOrtho() {
        // assum this is a projection matrix
        return this[15] === 1;
    }
    /**
   * Check if this matrix is perspective projection matrix.
   *
   * @remarks
   * This method assumes that this is an affine transform matrix or a projection matrix (perspective or orthogonal).
   *
   * @returns true if this is a perspective projection matrix, otherwise false
   */ isPerspective() {
        // assum this is a projection matrix
        return this[15] === 0;
    }
    /**
   * Get width of the near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Width of the near clip plane
   */ getNearPlaneWidth() {
        if (this.isPerspective()) {
            return 2 * this.getNearPlane() / this[0];
        } else {
            return 2 / this[0];
        }
    }
    /**
   * Get height of the near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Height of the near clip plane
   */ getNearPlaneHeight() {
        if (this.isPerspective()) {
            return 2 * this.getNearPlane() / this[5];
        } else {
            return 2 / this[5];
        }
    }
    /**
   * Get near clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns The near clip plane
   */ getNearPlane() {
        if (this.isPerspective()) {
            return this[14] / (this[10] - 1);
        } else {
            return (this[14] + 1) / this[10];
        }
    }
    /**
   * Get width of the far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Width of the far clip plane
   */ getFarPlaneWidth() {
        if (this.isPerspective()) {
            return this.getNearPlaneWidth() * this.getFarPlane() / this.getNearPlane();
        } else {
            return this.getNearPlaneWidth();
        }
    }
    /**
   * Get height of the far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns Height of the far clip plane
   */ getFarPlaneHeight() {
        if (this.isPerspective()) {
            return this.getNearPlaneHeight() * this.getFarPlane() / this.getNearPlane();
        } else {
            return this.getNearPlaneHeight();
        }
    }
    /**
   * Get far clip plane.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns The far clip plane
   */ getFarPlane() {
        if (this.isPerspective()) {
            return this[14] / (this[10] + 1);
        } else {
            return (this[14] - 1) / this[10];
        }
    }
    /**
   * Get the vertical field of view in radians.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   *
   * @returns 0 if this is an orthogonal projection matrix, otherwise the vertical field of view
   */ getFov() {
        // assum this is a projection matrix
        return this.isOrtho() ? 0 : Math.atan(1 / this[5]) * 2;
    }
    /**
   * Get tangent value of half of the vertical field of view.
   *
   * @remarks
   * This method assumes that this is a projection matrix (perspective or orthogonal).
   * If the matrix is orthogonal, 0 is returned.
   *
   * @returns 0 if this is an orthogonal projection matrix, otherwise the tangent value of half of the vertical field of view
   */ getTanHalfFov() {
        // assum this is a projection matrix
        return this.isOrtho() ? 0 : 1 / this[5];
    }
    /**
   * Get the aspect ratio.
   *
   * @remarks
   * This method assumes that the matrix is a perspective projection matrix.
   *
   * @returns The aspect ratio
   */ getAspect() {
        // assum this is a projection matrix
        return this[5] / this[0];
    }
    /**
   * Get the left clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The left clip plane
   */ getLeftPlane() {
        // assum this is an orthogonal projection matrix
        return (-1 - this[12]) / this[0];
    }
    /**
   * Get the right clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The right clip plane
   */ getRightPlane() {
        // assum this is an orthogonal projection matrix
        return (1 - this[12]) / this[0];
    }
    /**
   * Get the top clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The top clip plane
   */ getTopPlane() {
        // assum this is an orthogonal projection matrix
        return (1 - this[13]) / this[5];
    }
    /**
   * Get the bottom clip plane.
   *
   * @remarks
   * This method assumes that the matrix is an orthogonal projection matrix.
   *
   * @returns The bottom clip plane
   */ getBottomPlane() {
        // assum this is an orthogonal projection matrix
        return (-1 - this[13]) / this[5];
    }
    /**
   * Set the near clip plane and far clip plane.
   *
   * @remarks
   * This method assumes that the matrix is a projection matrix (perspective or orthogonal).
   *
   * @param znear - The near clip plane.
   * @param zfar - The far clip plane.
   * @returns self
   */ setNearFar(znear, zfar) {
        if (this.isPerspective()) {
            this.perspective(this.getFov(), this.getAspect(), znear, zfar);
        } else {
            this[10] = 2 / (znear - zfar);
            this[14] = (znear + zfar) / (znear - zfar);
        }
        return this;
    }
    /**
   * Calculate a translation matrix inplace.
   * @param t - The translate vector.
   * @returns self
   */ translation(t) {
        return Matrix4x4.translation(t, this);
    }
    /**
   * Calculates a scale matrix inplace.
   * @param s - The scale vector.
   * @returns self
   */ scaling(s) {
        return Matrix4x4.scaling(s, this);
    }
    /**
   * Invert this matrix inplace.
   * @returns self
   */ inplaceInvert() {
        return Matrix4x4.invert(this, this);
    }
    /**
   * Invert this matrix inplace, assuming this matrix presents an affine transformation.
   * @returns self
   */ inplaceInvertAffine() {
        return Matrix4x4.invertAffine(this, this);
    }
    /**
   * Calculates the transpose of this matrix inplace.
   * @returns self
   */ transpose() {
        return Matrix4x4.transpose(this, this);
    }
    /**
   * Post-multiply by a matrix inplace.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRight(other) {
        return Matrix4x4.multiply(this, other, this);
    }
    /**
   * Post-multiply by a matrix inplace, assuming both matrices present affine transformations.
   *
   * @remarks
   * this = this * other
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyRightAffine(other) {
        return Matrix4x4.multiplyAffine(this, other, this);
    }
    /**
   * Pre-multiply by a matrix inplace.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeft(other) {
        return Matrix4x4.multiply(other, this, this);
    }
    /**
   * Pre-multiply by a matrix inplace, assuming both matrices present affine transformations.
   *
   * @remarks
   * this = other * this
   *
   * @param other - The matrix that will be multiplied by.
   * @returns self
   */ multiplyLeftAffine(other) {
        return Matrix4x4.multiplyAffine(other, this, this);
    }
    /**
   * Calculates a rotation around x axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationX(angle) {
        return Matrix4x4.rotationX(angle, this);
    }
    /**
   * Calculates a rotation around y axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationY(angle) {
        return Matrix4x4.rotationY(angle, this);
    }
    /**
   * Calculates a rotation around z axis inplace.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotationZ(angle) {
        return Matrix4x4.rotationZ(angle, this);
    }
    /**
   * Calculates a rotation around a given axis inplace.
   * @param axis - The rotation axis.
   * @param angle - The rotate angle in radians.
   * @returns self
   */ rotation(axis, angle) {
        return Matrix4x4.rotation(axis, angle, this);
    }
    /**
   * Post-translate by a vector inplace.
   *
   * @remarks
   * this = this * (translate matrix for t)
   *
   * @param t - The translate vector.
   * @returns self
   */ translateRight(t) {
        return Matrix4x4.translateRight(this, t, this);
    }
    /**
   * Pre-translate by a vector inplace.
   *
   * @remarks
   * this = (translate matrix for t) * this
   *
   * @param t - The translate vector.
   * @returns self
   */ translateLeft(t) {
        return Matrix4x4.translateLeft(this, t, this);
    }
    /**
   * Post-scale by a vector inplace.
   *
   * @remarks
   * this = this * (scale matrix for s)
   *
   * @param s - The scale vector.
   * @returns self
   */ scaleRight(s) {
        return Matrix4x4.scaleRight(this, s, this);
    }
    /**
   * Pre-scale by a vector inplace.
   *
   * @remarks
   * this = (scale matrix for s) * this
   *
   * @param s - The scale vector.
   * @returns self
   */ scaleLeft(s) {
        return Matrix4x4.scaleLeft(this, s, this);
    }
    /**
   * Post-rotate by a rotation matrix or quaternion inplace.
   *
   * @remarks
   * this = this * r
   *
   * @param r - The rotation matrix or quaternion.
   * @returns self
   */ rotateRight(r) {
        return Matrix4x4.rotateRight(this, r, this);
    }
    /**
   * Pre-rotate by a rotation matrix or quaternion inplace.
   *
   * @remarks
   * this = r * this
   *
   * @param r - The rotation matrix or quaternion.
   * @returns self
   */ rotateLeft(r) {
        return Matrix4x4.rotateLeft(this, r, this);
    }
    /**
   * Calculates a look-at matrix inplace.
   * @param eye - Position of the eye.
   * @param target - The point that the eye is looking at.
   * @param up - The up vector.
   * @returns self
   */ lookAt(eye, target, up) {
        return Matrix4x4.lookAt(eye, target, up, this);
    }
    /**
   * Transform a point by this matrix.
   * @param point - The point to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPoint(point, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12], this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13], this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14], this[3] * point[0] + this[7] * point[1] + this[11] * point[2] + this[15]);
    }
    /**
   * Transform a point by this matrix and then do a perspective divide.
   * @param point - The point to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPointP(point, result) {
        result = result || new Vector3();
        const x = this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12];
        const y = this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13];
        const z = this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14];
        const w = this[3] * point[0] + this[7] * point[1] + this[11] * point[2] + this[15];
        return result.setXYZ(x / w, y / w, z / w);
    }
    /**
   * Transform a point by this matrix, assuming this matrix presents an affine transformation.
   * @param point - The point to be transformed.
   * @param result - The output vector (can be the same as point), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformPointAffine(point, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * point[0] + this[4] * point[1] + this[8] * point[2] + this[12], this[1] * point[0] + this[5] * point[1] + this[9] * point[2] + this[13], this[2] * point[0] + this[6] * point[1] + this[10] * point[2] + this[14]);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector, if not specified, a new vector will be created.
   * @returns The output vector
   */ transformVector(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2], this[3] * vec[0] + this[7] * vec[1] + this[11] * vec[2]);
    }
    /**
   * Transform a vector by this matrix assuming this matrix presents an affine transformation.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformVectorAffine(vec, result) {
        result = result || new Vector3();
        return result.setXYZ(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2]);
    }
    /**
   * Transform a vector by this matrix.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transform(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2] + this[12] * vec[3], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2] + this[13] * vec[3], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2] + this[14] * vec[3], this[3] * vec[0] + this[7] * vec[1] + this[11] * vec[2] + this[15] * vec[3]);
    }
    /**
   * Transform a vector by this matrix, assuming this matrix presents an affine transformation.
   * @param vec - The vector to be transformed.
   * @param result - The output vector (can be the same as vec), if not specified, a new vector will be created.
   * @returns The output vector
   */ transformAffine(vec, result) {
        result = result || new Vector4();
        return result.setXYZW(this[0] * vec[0] + this[4] * vec[1] + this[8] * vec[2] + this[12] * vec[3], this[1] * vec[0] + this[5] * vec[1] + this[9] * vec[2] + this[13] * vec[3], this[2] * vec[0] + this[6] * vec[1] + this[10] * vec[2] + this[14] * vec[3], vec.w);
    }
    /**
   * Calculates the determinant of this matrix.
   * @returns The determinant
   */ det() {
        const m00 = this[0], m01 = this[1], m02 = this[2], m03 = this[3];
        const m10 = this[4], m11 = this[5], m12 = this[6], m13 = this[7];
        const m20 = this[8], m21 = this[9], m22 = this[10], m23 = this[11];
        const m30 = this[12], m31 = this[13], m32 = this[14], m33 = this[15];
        const det_22_33 = m22 * m33 - m32 * m23;
        const det_21_33 = m21 * m33 - m31 * m23;
        const det_21_32 = m21 * m32 - m31 * m22;
        const det_20_33 = m20 * m33 - m30 * m23;
        const det_20_32 = m20 * m32 - m22 * m30;
        const det_20_31 = m20 * m31 - m30 * m21;
        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    }
    /**
   * Decompose this matrix into its rotation, translation and scale components.
   * @param scale - The output scale vector.
   * @param rotation - The output rotation matrix or quaternion.
   * @param translation - The output translation vector.
   * @returns self
   */ decompose(scale, rotation, translation) {
        if (translation) {
            translation.setXYZ(this[12], this[13], this[14]);
        }
        const sign = this.det() <= 0 ? -1 : 1;
        const sx = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        const sy = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]) * sign;
        const sz = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        if (scale) {
            scale.setXYZ(sx, sy, sz);
        }
        if (rotation instanceof Quaternion) {
            const rotationMatrix = new Matrix3x3(this);
            rotationMatrix[0] /= sx;
            rotationMatrix[1] /= sx;
            rotationMatrix[2] /= sx;
            rotationMatrix[3] /= sy;
            rotationMatrix[4] /= sy;
            rotationMatrix[5] /= sy;
            rotationMatrix[6] /= sz;
            rotationMatrix[7] /= sz;
            rotationMatrix[8] /= sz;
            rotation.fromRotationMatrix(rotationMatrix);
        } else if (rotation instanceof Matrix3x3) {
            rotation[0] = this[0] / sx;
            rotation[1] = this[1] / sx;
            rotation[2] = this[2] / sx;
            rotation[3] = this[4] / sy;
            rotation[4] = this[5] / sy;
            rotation[5] = this[6] / sy;
            rotation[6] = this[8] / sz;
            rotation[7] = this[9] / sz;
            rotation[8] = this[10] / sz;
        } else if (rotation instanceof Matrix4x4) {
            rotation[0] = this[0] / sx;
            rotation[1] = this[1] / sx;
            rotation[2] = this[2] / sx;
            rotation[3] = 0;
            rotation[4] = this[4] / sy;
            rotation[5] = this[5] / sy;
            rotation[6] = this[6] / sy;
            rotation[7] = 0;
            rotation[8] = this[8] / sz;
            rotation[9] = this[9] / sz;
            rotation[10] = this[10] / sz;
            rotation[11] = 0;
            rotation[12] = 0;
            rotation[13] = 0;
            rotation[14] = 0;
            rotation[15] = 1;
        }
        return this;
    }
    /**
   * Decompose this matrix into a look-at form.
   * @param eye - The output eye vector.
   * @param target - The output target vector.
   * @param up - The output up vector.
   * @returns self
   */ decomposeLookAt(eye, target, up) {
        eye && eye.setXYZ(this[12], this[13], this[14]);
        up && up.setXYZ(this[4], this[5], this[6]);
        target && target.setXYZ(this[12] - this[8], this[13] - this[9], this[14] - this[10]);
        return this;
    }
    /** @internal */ toDualQuaternion() {
        const t = new Vector3();
        const r = new Quaternion();
        const s = new Vector3();
        this.decompose(s, r, t);
        const translation = new Quaternion(this.m03 * 0.5, this.m13 * 0.5, this.m23 * 0.5, 0);
        const dual = Quaternion.multiply(translation, r);
        return {
            real: r,
            dual: dual,
            scale: s
        };
    }
}

/**
 * The plane class
 * @public
 */ class Plane extends VectorBase {
    /** @internal */ _px;
    /** @internal */ _py;
    /** @internal */ _pz;
    /** @internal */ _nx;
    /** @internal */ _ny;
    /** @internal */ _nz;
    /** @internal */ _npDirty;
    constructor(arg0, arg1, arg2, arg3){
        super(4);
        switch(arguments.length){
            case 0:
                {
                    this[0] = 0;
                    this[1] = 1;
                    this[2] = 0;
                    this[3] = 0;
                    this._npDirty = true;
                    break;
                }
            case 1:
                {
                    this.set(arg0);
                    break;
                }
            case 2:
                {
                    this.initWithOriginNormal(arg0, arg1);
                    break;
                }
            case 3:
                {
                    this.initWithPoints(arg0, arg1, arg2);
                    break;
                }
            case 4:
                {
                    this.setEquation(arg0, arg1, arg2, arg3);
                    break;
                }
            default:
                {
                    console.log('ERROR: Plane constructor must have 0/2/3/4 arguments');
                }
        }
    }
    /** Get the coefficient A of the plane equation */ get a() {
        return this[0];
    }
    set a(val) {
        this[0] = val;
        this._npDirty = true;
    }
    /** Get the coefficient B of the plane equation */ get b() {
        return this[1];
    }
    set b(val) {
        this[1] = val;
        this._npDirty = true;
    }
    /** Get the coefficient C of the plane equation */ get c() {
        return this[2];
    }
    set c(val) {
        this[2] = val;
        this._npDirty = true;
    }
    /** Get the coefficient D of the plane equation */ get d() {
        return this[3];
    }
    set d(val) {
        this[3] = val;
        this._npDirty = true;
    }
    /** @internal */ get px() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._px;
    }
    /** @internal */ get py() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._py;
    }
    /** @internal */ get pz() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._pz;
    }
    /** @internal */ get nx() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._nx;
    }
    /** @internal */ get ny() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._ny;
    }
    /** @internal */ get nz() {
        if (this._npDirty) {
            this._npDirty = false;
            this._calcNP();
        }
        return this._nz;
    }
    /**
   * Set coefficients of the plane equation.
   * @param other - An array holding the coefficients.
   * @returns self
   */ assign(other) {
        this._npDirty = true;
        super.set(other);
        return this;
    }
    /**
   * Set coefficients of the plane equation.
   * @param a - The coefficient A of the equation
   * @param b - The coefficient B of the equation
   * @param c - The coefficient C of the equation
   * @param d - The coefficient D of the equation
   * @returns self
   */ setEquation(a, b, c, d) {
        this[0] = a;
        this[1] = b;
        this[2] = c;
        this[3] = d;
        this._npDirty = true;
        return this;
    }
    /**
   * Initialize the plane by normal vector and a point on the plane.
   * @param origin - A point on the plane.
   * @param normal - Normal of the plane.
   * @returns self
   */ initWithOriginNormal(origin, normal) {
        // assume normal is normalized
        return this.setEquation(normal.x, normal.y, normal.z, -Vector3.dot(origin, normal));
    }
    /**
   * Initialize the plane by three points on the plane.
   * @param p0 - The first point.
   * @param p1 - The second point.
   * @param p2 - The third point.
   * @returns self
   */ initWithPoints(p0, p1, p2) {
        const normal = Vector3.cross(Vector3.sub(p1, p0), Vector3.sub(p2, p0)).inplaceNormalize();
        return this.initWithOriginNormal(p0, normal);
    }
    /**
   * Calculate the distance from a point to the plane.
   * @param p - The point
   * @returns The distance value.
   */ distanceToPoint(p) {
        return p.x * this[0] + p.y * this[1] + p.z * this[2] + this[3];
    }
    /**
   * Given a point, calucate the closest point on the plane to that point.
   * @param p - The given point.
   * @param result - A point object to which the result will be written, if not specified, a new point object will be returned.
   * @returns The result value.
   */ nearestPointToPoint(p, result) {
        const d = this.distanceToPoint(p);
        return (result || new Vector3()).setXYZ(p.x - this[0] * d, p.y - this[1] * d, p.z - this[2] * d);
    }
    /**
   * Get normal vector of the plane.
   * @param result - A vector object to which the result will be written, if not specified, a new vector will be returned.
   * @returns The result vector.
   */ getNormal(result) {
        return (result || new Vector3()).setXYZ(this[0], this[1], this[2]);
    }
    /** Inplace flip the normal vector . */ inplaceFlip() {
        return Plane.flip(this, this);
    }
    /** Inplace normalize the plane equation. */ inplaceNormalize() {
        return Plane.normalize(this, this);
    }
    /**
   * Create a new plane object by flipping another plane's normal.
   * @param plane - The plane to which the normal will be flipped.
   * @param result - A plane object to which the result will be written, if not specified, a new plane object will be returned.
   * @returns The result plane.
   */ static flip(plane, result) {
        return (result || new Plane()).setEquation(-plane[0], -plane[1], -plane[2], -plane[3]);
    }
    /**
   * Create a new plane object by normalizing another plane.
   * @param plane - The plane that will be normalized.
   * @param result - A plane object to which the result will be written, if not specified, a new plane object will be returned.
   * @returns The result plane.
   */ static normalize(plane, result) {
        const len = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
        return (result || new Plane()).setEquation(plane[0] / len, plane[1] / len, plane[2] / len, plane[3] / len);
    }
    /**
   * Create a new plane object by transforming another plane.
   * @param plane - The plane that will be transformed.
   * @param matrix - The transform matrix.
   * @param result - A plane object to which the result will be written, if not specified, a new plane object will be returned.
   * @returns The result plane.
   */ static transform(plane, matrix, result) {
        const adjMatrix = Matrix4x4.transpose(Matrix4x4.invertAffine(matrix));
        const p = adjMatrix.transform(new Vector4(plane[0], plane[1], plane[2], plane[3]));
        const ret = result || plane;
        ret.setEquation(p.x, p.y, p.z, p.w);
        return ret.inplaceNormalize();
    }
    /** @internal */ _calcNP() {
        this._px = this[0] > 0 ? 1 : -1;
        this._py = this[1] > 0 ? 1 : -1;
        this._pz = this[2] > 0 ? 1 : -1;
        this._nx = -this._px;
        this._ny = -this._py;
        this._nz = -this._pz;
    }
}

const nnn = [
    -1,
    -1,
    -1
];
const nnp = [
    -1,
    -1,
    1
];
const npn = [
    -1,
    1,
    -1
];
const npp = [
    -1,
    1,
    1
];
const pnn = [
    1,
    -1,
    -1
];
const pnp = [
    1,
    -1,
    1
];
const ppn = [
    1,
    1,
    -1
];
const ppp = [
    1,
    1,
    1
];
const ndcVertices = [
    nnn,
    nnp,
    npn,
    npp,
    pnn,
    pnp,
    ppn,
    ppp
];
/**
 * The frustum class
 *
 * @public
 */ class Frustum {
    static CORNER_LEFT_TOP_NEAR = 0b000;
    static CORNER_LEFT_TOP_FAR = 0b001;
    static CORNER_LEFT_BOTTOM_NEAR = 0b010;
    static CORNER_LEFT_BOTTOM_FAR = 0b011;
    static CORNER_RIGHT_TOP_NEAR = 0b100;
    static CORNER_RIGHT_TOP_FAR = 0b101;
    static CORNER_RIGHT_BOTTOM_NEAR = 0b110;
    static CORNER_RIGHT_BOTTOM_FAR = 0b111;
    /** @internal */ _planes;
    /** @internal */ _corners;
    constructor(arg0){
        this._planes = null;
        this._corners = null;
        if (arg0 instanceof Frustum) {
            this._planes = arg0._planes.map((plane)=>new Plane(plane));
            this._corners = arg0._corners.map((vec)=>new Vector3(vec));
        } else {
            this.initWithMatrix(arg0);
        }
    }
    /**
   * Get the frustum planes.
   */ get planes() {
        return this._planes;
    }
    /**
   * Get the corner points.
   */ get corners() {
        return this._corners;
    }
    /**
   * Get the point of a given corner.
   *
   * @remarks
   * The possible values of argument 'pos' are:
   * <ul>
   * <li>{@link Frustum.CORNER_LEFT_TOP_NEAR}</li>
   * <li>{@link Frustum.CORNER_LEFT_TOP_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_NEAR}</li>
   * <li>{@link Frustum.CORNER_LEFT_BOTTOM_NEAR}</li>
   * <li>{@link Frustum.CORNER_LEFT_BOTTOM_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_FAR}</li>
   * <li>{@link Frustum.CORNER_RIGHT_BOTTOM_NEAR}</li>
   * </ul>
   *
   * @param pos - The corner index.
   *
   * @returns The point of given corner
   */ getCorner(pos) {
        return this.corners[pos];
    }
    /**
   * Tests if a point is inside the frustum.
   *
   * @param pt - The point to test.
   * @returns true if the point is inside the frustum, otherwise false
   */ containsPoint(pt, epsl = 1e-6) {
        for (const p of this.planes){
            if (p.distanceToPoint(pt) < -epsl) {
                return false;
            }
        }
        return true;
    }
    /**
   * Initialize the frustum by given model-view matrix
   * @param transform - Model-view matrix used to initialize the frustum
   * @returns self
   */ initWithMatrix(transform) {
        this._planes = this._planes || Array.from({
            length: 6
        }).map(()=>new Plane());
        this._planes[BoxSide.LEFT].setEquation(transform.m30 + transform.m00, transform.m31 + transform.m01, transform.m32 + transform.m02, transform.m33 + transform.m03).inplaceNormalize();
        this._planes[BoxSide.RIGHT].setEquation(transform.m30 - transform.m00, transform.m31 - transform.m01, transform.m32 - transform.m02, transform.m33 - transform.m03).inplaceNormalize();
        this._planes[BoxSide.BOTTOM].setEquation(transform.m30 + transform.m10, transform.m31 + transform.m11, transform.m32 + transform.m12, transform.m33 + transform.m13).inplaceNormalize();
        this._planes[BoxSide.TOP].setEquation(transform.m30 - transform.m10, transform.m31 - transform.m11, transform.m32 - transform.m12, transform.m33 - transform.m13).inplaceNormalize();
        this._planes[BoxSide.FRONT].setEquation(transform.m30 + transform.m20, transform.m31 + transform.m21, transform.m32 + transform.m22, transform.m33 + transform.m23).inplaceNormalize();
        this._planes[BoxSide.BACK].setEquation(transform.m30 - transform.m20, transform.m31 - transform.m21, transform.m32 - transform.m22, transform.m33 - transform.m23).inplaceNormalize();
        const invMatrix = Matrix4x4.invert(transform);
        const vertices = ndcVertices.map((v)=>new Vector3(v[0], v[1], v[2]));
        this._corners = this._corners || [];
        for(let i = 0; i < 8; i++){
            const v = invMatrix.transformPoint(vertices[i]);
            this._corners[i] = v.scaleBy(1 / v.w).xyz();
        }
        return this;
    }
}

/**
 * Axis aligned bounding box
 * @public
 */ class AABB {
    /** Clip to the left side */ static ClipLeft = 1 << BoxSide.LEFT;
    /** Clip to the right side */ static ClipRight = 1 << BoxSide.RIGHT;
    /** Clip to the bottom side */ static ClipBottom = 1 << BoxSide.BOTTOM;
    /** Clip to the top side */ static ClipTop = 1 << BoxSide.TOP;
    /** Clip to the front side */ static ClipFront = 1 << BoxSide.FRONT;
    /** Clip to the back side */ static ClipBack = 1 << BoxSide.BACK;
    /** @internal */ _minPoint;
    /** @internal */ _maxPoint;
    constructor(arg0, arg1){
        if (arg0 instanceof AABB) {
            this._minPoint = new Vector3(arg0.minPoint);
            this._maxPoint = new Vector3(arg0.maxPoint);
        } else if (arg0 instanceof Vector3) {
            this._minPoint = new Vector3(arg0);
            this._maxPoint = new Vector3(arg1);
        } else {
            this._minPoint = new Vector3(0, 0, 0);
            this._maxPoint = new Vector3(0, 0, 0);
        }
    }
    /** Get the min point of the AABB. */ get minPoint() {
        return this._minPoint;
    }
    set minPoint(p) {
        this._minPoint.set(p);
    }
    /** Get the max point of the AABB. */ get maxPoint() {
        return this._maxPoint;
    }
    set maxPoint(p) {
        this._maxPoint.set(p);
    }
    /** Get half size of the AABB. */ get extents() {
        return Vector3.sub(this._maxPoint, this._minPoint).scaleBy(0.5);
    }
    /** Get center point of the AABB. */ get center() {
        return Vector3.add(this._maxPoint, this._minPoint).scaleBy(0.5);
    }
    /** Get size of the AABB. */ get size() {
        return Vector3.sub(this._maxPoint, this._minPoint);
    }
    /** Get the diagonal length of the AABB. */ get diagonalLength() {
        return Vector3.sub(this._maxPoint, this._minPoint).magnitude;
    }
    /**
   * Calculate the coordinates of the eight corners of the AABB.
   * @returns the coordinates of the eight corners of the AABB.
   */ computePoints() {
        const { x: minx, y: miny, z: minz } = this._minPoint;
        const { x: maxx, y: maxy, z: maxz } = this._maxPoint;
        return [
            new Vector3(minx, miny, minz),
            new Vector3(minx, maxy, minz),
            new Vector3(maxx, miny, minz),
            new Vector3(maxx, maxy, minz),
            new Vector3(minx, miny, maxz),
            new Vector3(minx, maxy, maxz),
            new Vector3(maxx, miny, maxz),
            new Vector3(maxx, maxy, maxz)
        ];
    }
    /**
   * Inplace transform the AABB.
   * @param matrix - The transform matrix.
   * @returns self
   */ inplaceTransform(matrix) {
        return AABB.transform(this, matrix, this);
    }
    /** Invalidate the min/max point so that we can start extending the AABB. */ beginExtend() {
        this._minPoint.setXYZ(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        this._maxPoint.setXYZ(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    }
    /**
   * Extend the AABB so that it can contain specified point.
   * @param v - The point used to extend the AABB.
   */ extend(v) {
        this._minPoint.inplaceMin(v);
        this._maxPoint.inplaceMax(v);
    }
    /**
   * Extend the AABB so that it can contain specified point.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   */ extend3(x, y, z) {
        if (x < this._minPoint.x) this._minPoint.x = x;
        if (x > this._maxPoint.x) this._maxPoint.x = x;
        if (y < this._minPoint.y) this._minPoint.y = y;
        if (y > this._maxPoint.y) this._maxPoint.y = y;
        if (z < this._minPoint.z) this._minPoint.z = z;
        if (z > this._maxPoint.z) this._maxPoint.z = z;
    }
    /**
   * Merge the AABB with another AABB.
   * @param other - The AABB to be merged with.
   * @returns self
   */ union(other) {
        if (other && other.isValid()) {
            this.extend(other._minPoint);
            this.extend(other._maxPoint);
        }
        return this;
    }
    /**
   * Check if the AABB is valid.
   * @returns true if the AABB is valid, otherwise false.
   */ isValid() {
        return this._minPoint.x <= this._maxPoint.x && this._minPoint.y <= this._maxPoint.y && this._minPoint.z <= this._maxPoint.z;
    }
    /**
   * Check if the AABB is close enough to another AABB.
   * @param other - The AABB to be compared with.
   * @param epsl - The epsilon for comparison.
   * @returns true if the comparison error is less than epsl, otherwise false.
   */ equalsTo(other, epsl) {
        return this._minPoint.equalsTo(other._minPoint, epsl) && this._maxPoint.equalsTo(other._maxPoint, epsl);
    }
    /**
   * Check if the AABB intersects with another AABB.
   * @param other - The destination AABB.
   * @returns true if the AABB intersects with other, otherwise false.
   */ intersectedWithBox(other) {
        return !(this._maxPoint.x <= other._minPoint.x || this._minPoint.x >= other._maxPoint.x || this._maxPoint.y <= other._minPoint.y || this._minPoint.y >= other._maxPoint.y || this._maxPoint.z <= other._minPoint.z || this._minPoint.z >= other._maxPoint.z);
    }
    /**
   * Check if the box contains specified point.
   * @param pt - The point to be checked.
   * @returns true if the box contains the point, otherwise false.s
   */ containsPoint(pt) {
        return this._minPoint.x <= pt.x && this._maxPoint.x >= pt.x && this._minPoint.y <= pt.y && this._maxPoint.y >= pt.y && this._minPoint.z <= pt.z && this._maxPoint.z >= pt.z;
    }
    /**
   * Check if the AABB contains all of the eight corner point of another AABB
   * @param other - The AABB to be checked.
   * @returns true if all contains, otherwise false.
   */ containsBox(other) {
        return this._minPoint.x <= other._minPoint.x && this._maxPoint.x >= other._maxPoint.x && this._minPoint.y <= other._minPoint.y && this._maxPoint.y >= other._maxPoint.y && this._minPoint.z <= other._minPoint.z && this._maxPoint.z >= other._maxPoint.z;
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param viewProjMatrix - The view projection matrix of the frustum.
   * @param mask - The frustum planes that needs to be tested.
   * @returns The clip test result.
   */ getClipStateMask(viewProjMatrix, mask) {
        let andFlags = 0xffff;
        let orFlags = 0;
        const v0 = new Vector3();
        const v1 = new Vector4();
        const clipLeft = mask & AABB.ClipLeft;
        const clipRight = mask & AABB.ClipRight;
        const clipTop = mask & AABB.ClipTop;
        const clipBottom = mask & AABB.ClipBottom;
        const clipNear = mask & AABB.ClipFront;
        const clipFar = mask & AABB.ClipBack;
        const minPoint = this._minPoint;
        const maxPoint = this._maxPoint;
        for(let i = 0; i < 8; i++){
            let clip = 0;
            v0.setXYZ(i & 1 ? minPoint.x : maxPoint.x, i & 2 ? minPoint.y : maxPoint.y, i & 3 ? minPoint.z : maxPoint.z);
            viewProjMatrix.transformPoint(v0, v1);
            if (clipLeft && v1.x < -v1.w) {
                clip |= AABB.ClipLeft;
            } else if (clipRight && v1.x > v1.w) {
                clip |= AABB.ClipRight;
            }
            if (clipBottom && v1.y < -v1.w) {
                clip |= AABB.ClipBottom;
            } else if (clipTop && v1.y > v1.w) {
                clip |= AABB.ClipTop;
            }
            if (clipFar && v1.z < -v1.w) {
                clip |= AABB.ClipBack;
            } else if (clipNear && v1.z > v1.w) {
                clip |= AABB.ClipFront;
            }
            andFlags &= clip;
            orFlags |= clip;
        }
        if (orFlags === 0) {
            return ClipState.A_INSIDE_B;
        } else if (andFlags !== 0) {
            return ClipState.NOT_CLIPPED;
        } else {
            return ClipState.CLIPPED;
        }
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param viewProjMatrix - The view projection matrix of the frustum.
   * @returns The clip test result.
   */ getClipState(viewProjMatrix) {
        let andFlags = 0xffff;
        let orFlags = 0;
        const v0 = new Vector3();
        const v1 = new Vector4();
        const minPoint = this._minPoint;
        const maxPoint = this._maxPoint;
        for(let i = 0; i < 8; i++){
            let clip = 0;
            v0.setXYZ(i & 1 ? minPoint.x : maxPoint.x, i & 2 ? minPoint.y : maxPoint.y, i & 3 ? minPoint.z : maxPoint.z);
            viewProjMatrix.transformPoint(v0, v1);
            if (v1.x < -v1.w) {
                clip |= AABB.ClipLeft;
            } else if (v1.x > v1.w) {
                clip |= AABB.ClipRight;
            }
            if (v1.y < -v1.w) {
                clip |= AABB.ClipBottom;
            } else if (v1.y > v1.w) {
                clip |= AABB.ClipTop;
            }
            if (v1.z < -v1.w) {
                clip |= AABB.ClipBack;
            } else if (v1.z > v1.w) {
                clip |= AABB.ClipFront;
            }
            andFlags &= clip;
            orFlags |= clip;
        }
        if (orFlags === 0) {
            return ClipState.A_INSIDE_B;
        } else if (andFlags !== 0) {
            return ClipState.NOT_CLIPPED;
        } else {
            return ClipState.CLIPPED;
        }
    }
    /**
   * Check if the box is behind a plane.
   * @param p - The plane to be tested.
   * @returns true if the box is behind the plane, otherwise false.
   */ behindPlane(p) {
        const cx = (this._maxPoint.x + this._minPoint.x) * 0.5;
        const cy = (this._maxPoint.y + this._minPoint.y) * 0.5;
        const cz = (this._maxPoint.z + this._minPoint.z) * 0.5;
        const ex = this._maxPoint.x - cx;
        const ey = this._maxPoint.y - cy;
        const ez = this._maxPoint.z - cz;
        return p.a * (cx + p.px * ex) + p.b * (cy + p.py * ey) + p.c * (cz + p.pz * ez) + p.d < 0;
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param frustum - The frustum object.
   * @returns The clip test result.
   */ getClipStateWithFrustum(frustum) {
        let badIntersect = false;
        const cx = (this._maxPoint.x + this._minPoint.x) * 0.5;
        const cy = (this._maxPoint.y + this._minPoint.y) * 0.5;
        const cz = (this._maxPoint.z + this._minPoint.z) * 0.5;
        const ex = this._maxPoint.x - cx;
        const ey = this._maxPoint.y - cy;
        const ez = this._maxPoint.z - cz;
        for(let i = 0; i < 6; i++){
            const p = frustum.planes[i];
            if (p.a * (cx + p.px * ex) + p.b * (cy + p.py * ey) + p.c * (cz + p.pz * ez) + p.d < 0) {
                return ClipState.NOT_CLIPPED;
            }
            if (p.a * (cx + p.nx * ex) + p.b * (cy + p.ny * ey) + p.c * (cz + p.nz * ez) + p.d < 0) {
                badIntersect = true;
            }
        }
        return badIntersect ? ClipState.CLIPPED : ClipState.A_INSIDE_B;
    }
    /**
   * Do a clip test at the AABB and a frustum.
   * @param frustum - The frustum object.
   * @param mask - The frustum planes that needs to be tested.
   * @returns The clip test result.
   */ getClipStateWithFrustumMask(frustum, mask) {
        let badIntersect = false;
        const cx = (this._maxPoint.x + this._minPoint.x) * 0.5;
        const cy = (this._maxPoint.y + this._minPoint.y) * 0.5;
        const cz = (this._maxPoint.z + this._minPoint.z) * 0.5;
        const ex = this._maxPoint.x - cx;
        const ey = this._maxPoint.y - cy;
        const ez = this._maxPoint.z - cz;
        for(let i = 0; i < 6; i++){
            if (mask & 1 << i) {
                const p = frustum.planes[i];
                if (p.a * (cx + p.px * ex) + p.b * (cy + p.py * ey) + p.c * (cz + p.pz * ez) + p.d < 0) {
                    return ClipState.NOT_CLIPPED;
                }
                if (p.a * (cx + p.nx * ex) + p.b * (cy + p.ny * ey) + p.c * (cz + p.nz * ez) + p.d < 0) {
                    badIntersect = true;
                }
            }
        }
        return badIntersect ? ClipState.CLIPPED : ClipState.A_INSIDE_B;
    }
    /**
   * Get an AABB by transforming another AABB
   * @param bbox - The AABB to be transformed.
   * @param matrix - The transform matrix.
   * @param result - The out AABB to be write to.
   * @returns The out AABB.
   */ static transform(bbox, matrix, result) {
        const ret = result || new AABB();
        const minp = [
            0,
            0,
            0
        ];
        const maxp = [
            0,
            0,
            0
        ];
        const v1 = bbox.minPoint;
        const v2 = bbox.maxPoint;
        let r;
        for(let col = 0; col < 3; ++col){
            r = col;
            minp[col] = maxp[col] = matrix[12 + col];
            for(let row = 0; row < 3; ++row){
                const e = matrix[r] * v1[row];
                const f = matrix[r] * v2[row];
                if (e < f) {
                    minp[col] += e;
                    maxp[col] += f;
                } else {
                    minp[col] += f;
                    maxp[col] += e;
                }
                r += 4;
            }
        }
        ret.minPoint.set(minp);
        ret.maxPoint.set(maxp);
        return ret;
    }
}

// reduce GC
const tmpV0 = new Vector3();
const tmpV1 = new Vector3();
const tmpV2 = new Vector3();
const tmpV3 = new Vector3();
const tmpV4 = new Vector3();
/**
 * The ray class
 * @public
 */ class Ray {
    /** @internal */ _origin;
    /** @internal */ _direction;
    /** @internal */ _ii;
    /** @internal */ _ij;
    /** @internal */ _ik;
    /** @internal */ _ibyj;
    /** @internal */ _jbyi;
    /** @internal */ _kbyj;
    /** @internal */ _jbyk;
    /** @internal */ _ibyk;
    /** @internal */ _kbyi;
    /** @internal */ _c_xy;
    /** @internal */ _c_xz;
    /** @internal */ _c_yx;
    /** @internal */ _c_yz;
    /** @internal */ _c_zx;
    /** @internal */ _c_zy;
    /**
   * Do a intersection test with an AABB.
   * @param bbox - The box to be test.
   * @returns true if the ray intersect with the box, otherwise false.
   */ bboxIntersectionTest;
    /**
   * Do a intersection test with an AABB.
   * @param bbox - The box to be test.
   * @returns The distance from the origin to intersected point if the ray intersect with the box, otherwise null.
   */ bboxIntersectionTestEx;
    /**
   * Construct a ray from origin and normalized direction vector.
   * @param origin - The ray origin if not specified, zero vector will be used.
   * @param directionNormalized - The normalized direction vector. if not specified, (0, 0, 1) will be used.
   */ constructor(origin, directionNormalized){
        this._origin = origin ? new Vector3(origin) : Vector3.zero();
        this._direction = directionNormalized ? new Vector3(directionNormalized) : Vector3.axisPZ();
        this.prepare();
    }
    /** Get the ray origin point */ get origin() {
        return this._origin;
    }
    /** Get the ray direction vector */ get direction() {
        return this._direction;
    }
    /**
   * Set the ray origin and normalized direction vector.
   * @param origin - The ray origin point.
   * @param directionNormalized - The normalized direction vector.
   */ set(origin, directionNormalized) {
        this._origin.set(origin);
        this._direction.set(directionNormalized);
        this.prepare();
    }
    /**
   * Transform the ray.
   * @param matrix - The transform matrix.
   * @param other - A ray object to which the result will be written, if not specified, a new ray object will be returned.
   * @returns The transform result.
   */ transform(matrix, other) {
        if (other) {
            matrix.transformPointAffine(this._origin, other._origin);
            matrix.transformPointAffine(Vector3.add(this._origin, this._direction), other._direction).subBy(other._origin).inplaceNormalize();
            other.prepare();
        } else {
            const origin = matrix.transformPointAffine(this._origin);
            const direction = matrix.transformPointAffine(Vector3.add(this._origin, this._direction)).subBy(origin).inplaceNormalize();
            other = new Ray(origin, direction);
        }
        return other;
    }
    /**
   * Do a ray triangle intersection test.
   * @param v1 - The first triangle vertex.
   * @param v2 - The second triangle vertex.
   * @param v3 - The third triangle vertex.
   * @param cull - Allow back side intersection if true.
   * @returns Distance from origin to the intersected point if the ray intersects with the triangle, otherwise null.
   */ intersectionTestTriangle(v1, v2, v3, cull) {
        const start = this._origin;
        const normal = this._direction;
        const edge1 = Vector3.sub(v2, v1, tmpV0);
        const edge2 = Vector3.sub(v3, v1, tmpV1);
        const pvec = Vector3.cross(normal, edge2, tmpV2);
        const det = Vector3.dot(edge1, pvec);
        if (!cull) {
            if (det > -0.0001 && det < 0.0001) {
                return null;
            }
            const inv_det = 1.0 / det;
            const tvec = Vector3.sub(start, v1, tmpV3);
            const u = inv_det * Vector3.dot(tvec, pvec);
            if (u < 0 || u > 1) {
                return null;
            }
            const qvec = Vector3.cross(tvec, edge1, tmpV4);
            const v = inv_det * Vector3.dot(normal, qvec);
            if (v < 0 || u + v > 1) {
                return null;
            }
            return Vector3.dot(edge2, qvec) * inv_det;
        } else {
            if (det < 0) {
                return null;
            }
            const tvec = Vector3.sub(start, v1, tmpV3);
            const u = Vector3.dot(tvec, pvec);
            if (u < 0 || u > det) {
                return null;
            }
            const qvec = Vector3.cross(tvec, edge1, tmpV4);
            const v = Vector3.dot(normal, qvec);
            if (v < 0 || u + v > det) {
                return null;
            }
            return Vector3.dot(edge2, qvec) / det;
        }
    }
    /** @internal */ qtestMMM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y < y0 || this._origin.z < z0 || this._jbyi * x0 - y1 + this._c_xy > 0 || this._ibyj * y0 - x1 + this._c_yx > 0 || this._jbyk * z0 - y1 + this._c_zy > 0 || this._kbyj * y0 - z1 + this._c_yz > 0 || this._kbyi * x0 - z1 + this._c_xz > 0 || this._ibyk * z0 - x1 + this._c_zx > 0) {
            return false;
        }
        return true;
    }
    /** @internal */ qtestMMMEx(bbox) {
        if (!this.qtestMMM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestMMP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y < y0 || this._origin.z > z1 || this._jbyi * x0 - y1 + this._c_xy > 0 || this._ibyj * y0 - x1 + this._c_yx > 0 || this._jbyk * z1 - y1 + this._c_zy > 0 || this._kbyj * y0 - z0 + this._c_yz < 0 || this._kbyi * x0 - z0 + this._c_xz < 0 || this._ibyk * z1 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMMPEx(bbox) {
        if (!this.qtestMMP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestMPM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y > y1 || this._origin.z < z0 || this._jbyi * x0 - y0 + this._c_xy < 0 || this._ibyj * y1 - x1 + this._c_yx > 0 || this._jbyk * z0 - y0 + this._c_zy < 0 || this._kbyj * y1 - z1 + this._c_yz > 0 || this._kbyi * x0 - z1 + this._c_xz > 0 || this._ibyk * z0 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMPMEx(bbox) {
        if (!this.qtestMPM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestMPP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y > y1 || this._origin.z > z1 || this._jbyi * x0 - y0 + this._c_xy < 0 || this._ibyj * y1 - x1 + this._c_yx > 0 || this._jbyk * z1 - y0 + this._c_zy < 0 || this._kbyj * y1 - z0 + this._c_yz < 0 || this._kbyi * x0 - z0 + this._c_xz < 0 || this._ibyk * z1 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMPPEx(bbox) {
        if (!this.qtestMPP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestPMM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y < y0 || this._origin.z < z0 || this._jbyi * x1 - y1 + this._c_xy > 0 || this._ibyj * y0 - x0 + this._c_yx < 0 || this._jbyk * z0 - y1 + this._c_zy > 0 || this._kbyj * y0 - z1 + this._c_yz > 0 || this._kbyi * x1 - z1 + this._c_xz > 0 || this._ibyk * z0 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPMMEx(bbox) {
        if (!this.qtestPMM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) {
            t = t1;
        }
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) {
            t = t2;
        }
        return t;
    }
    /** @internal */ qtestPMP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y < y0 || this._origin.z > z1 || this._jbyi * x1 - y1 + this._c_xy > 0 || this._ibyj * y0 - x0 + this._c_yx < 0 || this._jbyk * z1 - y1 + this._c_zy > 0 || this._kbyj * y0 - z0 + this._c_yz < 0 || this._kbyi * x1 - z0 + this._c_xz < 0 || this._ibyk * z1 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPMPEx(bbox) {
        if (!this.qtestPMP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t1 > t) t = t1;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPPM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y > y1 || this._origin.z < z0 || this._jbyi * x1 - y0 + this._c_xy < 0 || this._ibyj * y1 - x0 + this._c_yx < 0 || this._jbyk * z0 - y0 + this._c_zy < 0 || this._kbyj * y1 - z1 + this._c_yz > 0 || this._kbyi * x1 - z1 + this._c_xz > 0 || this._ibyk * z0 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPPMEx(bbox) {
        if (!this.qtestPPM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) t = t1;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPPP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y > y1 || this._origin.z > z1 || this._jbyi * x1 - y0 + this._c_xy < 0 || this._ibyj * y1 - x0 + this._c_yx < 0 || this._jbyk * z1 - y0 + this._c_zy < 0 || this._kbyj * y1 - z0 + this._c_yz < 0 || this._kbyi * x1 - z0 + this._c_xz < 0 || this._ibyk * z1 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPPPEx(bbox) {
        if (!this.qtestPPP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t1 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t1 > t) t = t1;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOMM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.z < z0 || this._jbyk * z0 - y1 + this._c_zy > 0 || this._kbyj * y0 - z1 + this._c_yz > 0) return false;
        return true;
    }
    /** @internal */ qtestOMMEx(bbox) {
        if (!this.qtestOMM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOMP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.z > z1 || this._jbyk * z1 - y1 + this._c_zy > 0 || this._kbyj * y0 - z0 + this._c_yz < 0) return false;
        return true;
    }
    /** @internal */ qtestOMPEx(bbox) {
        if (!this.qtestOMP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOPM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y > y1 || this._origin.z < z0 || this._jbyk * z0 - y0 + this._c_zy < 0 || this._kbyj * y1 - z1 + this._c_yz > 0) return false;
        return true;
    }
    /** @internal */ qtestOPMEx(bbox) {
        if (!this.qtestOPM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestOPP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.x > x1 || this._origin.y > y1 || this._origin.z > z1 || this._jbyk * z1 - y0 + this._c_zy < 0 || this._kbyj * y1 - z0 + this._c_yz < 0) return false;
        return true;
    }
    /** @internal */ qtestOPPEx(bbox) {
        if (!this.qtestOPP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.y - this._origin.y) * this._ij;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMOM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x < x0 || this._origin.z < z0 || this._kbyi * x0 - z1 + this._c_xz > 0 || this._ibyk * z0 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMOMEx(bbox) {
        if (!this.qtestMOM(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMOP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x < x0 || this._origin.z > z1 || this._kbyi * x0 - z0 + this._c_xz < 0 || this._ibyk * z1 - x1 + this._c_zx > 0) return false;
        return true;
    }
    /** @internal */ qtestMOPEx(bbox) {
        if (!this.qtestMOP(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPOM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x > x1 || this._origin.z < z0 || this._kbyi * x1 - z1 + this._c_xz > 0 || this._ibyk * z0 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPOMEx(bbox) {
        if (!this.qtestPOM(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPOP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.y > y1 || this._origin.x > x1 || this._origin.z > z1 || this._kbyi * x1 - z0 + this._c_xz < 0 || this._ibyk * z1 - x0 + this._c_zx < 0) return false;
        return true;
    }
    /** @internal */ qtestPOPEx(bbox) {
        if (!this.qtestPOP(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.z - this._origin.z) * this._ik;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMMO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x < x0 || this._origin.y < y0 || this._jbyi * x0 - y1 + this._c_xy > 0 || this._ibyj * y0 - x1 + this._c_yx > 0) return false;
        return true;
    }
    /** @internal */ qtestMMOEx(bbox) {
        if (!this.qtestMMO(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMPO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x < x0 || this._origin.y > y1 || this._jbyi * x0 - y0 + this._c_xy < 0 || this._ibyj * y1 - x1 + this._c_yx > 0) return false;
        return true;
    }
    /** @internal */ qtestMPOEx(bbox) {
        if (!this.qtestMPO(bbox)) {
            return null;
        }
        let t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPMO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x > x1 || this._origin.y < y0 || this._jbyi * x1 - y1 + this._c_xy > 0 || this._ibyj * y0 - x0 + this._c_yx < 0) return false;
        return true;
    }
    /** @internal */ qtestPMOEx(bbox) {
        if (!this.qtestPMO(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.maxPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestPPO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z < z0 || this._origin.z > z1 || this._origin.x > x1 || this._origin.y > y1 || this._jbyi * x1 - y0 + this._c_xy < 0 || this._ibyj * y1 - x0 + this._c_yx < 0) return false;
        return true;
    }
    /** @internal */ qtestPPOEx(bbox) {
        if (!this.qtestPPO(bbox)) {
            return null;
        }
        let t = (bbox.minPoint.x - this._origin.x) * this._ii;
        const t2 = (bbox.minPoint.y - this._origin.y) * this._ij;
        if (t2 > t) t = t2;
        return t;
    }
    /** @internal */ qtestMOO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x < x0 || this._origin.y < y0 || this._origin.y > y1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestMOOEx(bbox) {
        if (!this.qtestMOO(bbox)) {
            return null;
        }
        const t = (bbox.maxPoint.x - this._origin.x) * this._ii;
        return t;
    }
    /** @internal */ qtestPOO(bbox) {
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.x > x1 || this._origin.y < y0 || this._origin.y > y1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestPOOEx(bbox) {
        if (!this.qtestPOO(bbox)) {
            return null;
        }
        const t = (bbox.minPoint.x - this._origin.x) * this._ii;
        return t;
    }
    /** @internal */ qtestOMO(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y < y0 || this._origin.x < x0 || this._origin.x > x1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestOMOEx(bbox) {
        if (!this.qtestOMO(bbox)) {
            return null;
        }
        const t = (bbox.maxPoint.y - this._origin.y) * this._ij;
        return t;
    }
    /** @internal */ qtestOPO(bbox) {
        const x0 = bbox.minPoint.x;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.y > y1 || this._origin.x < x0 || this._origin.x > x1 || this._origin.z < z0 || this._origin.z > z1) return false;
        return true;
    }
    /** @internal */ qtestOPOEx(bbox) {
        if (!this.qtestOPO(bbox)) {
            return null;
        }
        const t = (bbox.minPoint.y - this._origin.y) * this._ij;
        return t;
    }
    /** @internal */ qtestOOM(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const z0 = bbox.minPoint.z;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        if (this._origin.z < z0 || this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.y > y1) return false;
        return true;
    }
    /** @internal */ qtestOOMEx(bbox) {
        if (!this.qtestOOM(bbox)) {
            return null;
        }
        const t = (bbox.maxPoint.z - this._origin.z) * this._ik;
        return t;
    }
    /** @internal */ qtestOOP(bbox) {
        const x0 = bbox.minPoint.x;
        const y0 = bbox.minPoint.y;
        const x1 = bbox.maxPoint.x;
        const y1 = bbox.maxPoint.y;
        const z1 = bbox.maxPoint.z;
        if (this._origin.z > z1 || this._origin.x < x0 || this._origin.x > x1 || this._origin.y < y0 || this._origin.y > y1) return false;
        return true;
    }
    /** @internal */ qtestOOPEx(bbox) {
        if (!this.qtestOOP(bbox)) {
            return null;
        }
        const t = (bbox.minPoint.z - this._origin.z) * this._ik;
        return t;
    }
    /** @internal */ prepare() {
        const x = this._origin.x;
        const y = this._origin.y;
        const z = this._origin.z;
        const i = this._direction.x;
        const j = this._direction.y;
        const k = this._direction.z;
        this._ii = 1.0 / i;
        this._ij = 1.0 / j;
        this._ik = 1.0 / k;
        this._ibyj = i * this._ij;
        this._jbyi = j * this._ii;
        this._jbyk = j * this._ik;
        this._kbyj = k * this._ij;
        this._ibyk = i * this._ik;
        this._kbyi = k * this._ii;
        this._c_xy = y - this._jbyi * x;
        this._c_xz = z - this._kbyi * x;
        this._c_yx = x - this._ibyj * y;
        this._c_yz = z - this._kbyj * y;
        this._c_zx = x - this._ibyk * z;
        this._c_zy = y - this._jbyk * z;
        if (i < 0) {
            if (j < 0) {
                if (k < 0) {
                    this.bboxIntersectionTest = this.qtestMMM;
                    this.bboxIntersectionTestEx = this.qtestMMMEx;
                } else if (k > 0) {
                    this.bboxIntersectionTest = this.qtestMMP;
                    this.bboxIntersectionTestEx = this.qtestMMPEx;
                } else {
                    this.bboxIntersectionTest = this.qtestMMO;
                    this.bboxIntersectionTestEx = this.qtestMMOEx;
                }
            } else {
                if (k < 0) {
                    this.bboxIntersectionTest = j > 0 ? this.qtestMPM : this.qtestMOM;
                    this.bboxIntersectionTestEx = j > 0 ? this.qtestMPMEx : this.qtestMOMEx;
                } else {
                    if (j === 0 && k === 0) {
                        this.bboxIntersectionTest = this.qtestMOO;
                        this.bboxIntersectionTestEx = this.qtestMOOEx;
                    } else if (k === 0) {
                        this.bboxIntersectionTest = this.qtestMPO;
                        this.bboxIntersectionTestEx = this.qtestMPOEx;
                    } else if (j === 0) {
                        this.bboxIntersectionTest = this.qtestMOP;
                        this.bboxIntersectionTestEx = this.qtestMOPEx;
                    } else {
                        this.bboxIntersectionTest = this.qtestMPP;
                        this.bboxIntersectionTestEx = this.qtestMPPEx;
                    }
                }
            }
        } else {
            if (j < 0) {
                if (k < 0) {
                    this.bboxIntersectionTest = i > 0 ? this.qtestPMM : this.qtestOMM;
                    this.bboxIntersectionTestEx = i > 0 ? this.qtestPMMEx : this.qtestOMMEx;
                } else {
                    if (i === 0 && k === 0) {
                        this.bboxIntersectionTest = this.qtestOMO;
                        this.bboxIntersectionTestEx = this.qtestOMOEx;
                    } else if (k === 0) {
                        this.bboxIntersectionTest = this.qtestPMO;
                        this.bboxIntersectionTestEx = this.qtestPMOEx;
                    } else if (i === 0) {
                        this.bboxIntersectionTest = this.qtestOMP;
                        this.bboxIntersectionTestEx = this.qtestOMPEx;
                    } else {
                        this.bboxIntersectionTest = this.qtestPMP;
                        this.bboxIntersectionTestEx = this.qtestPMPEx;
                    }
                }
            } else {
                if (k < 0) {
                    if (i === 0 && j === 0) {
                        this.bboxIntersectionTest = this.qtestOOM;
                        this.bboxIntersectionTestEx = this.qtestOOMEx;
                    } else if (i === 0) {
                        this.bboxIntersectionTest = this.qtestOPM;
                        this.bboxIntersectionTestEx = this.qtestOPMEx;
                    } else if (j === 0) {
                        this.bboxIntersectionTest = this.qtestPOM;
                        this.bboxIntersectionTestEx = this.qtestPOMEx;
                    } else {
                        this.bboxIntersectionTest = this.qtestPPM;
                        this.bboxIntersectionTestEx = this.qtestPPMEx;
                    }
                } else {
                    if (i === 0) {
                        if (j === 0) {
                            this.bboxIntersectionTest = this.qtestOOP;
                            this.bboxIntersectionTestEx = this.qtestOOPEx;
                        } else if (k === 0) {
                            this.bboxIntersectionTest = this.qtestOPO;
                            this.bboxIntersectionTestEx = this.qtestOPOEx;
                        } else {
                            this.bboxIntersectionTest = this.qtestOPP;
                            this.bboxIntersectionTestEx = this.qtestOPPEx;
                        }
                    } else {
                        if (j === 0 && k === 0) {
                            this.bboxIntersectionTest = this.qtestPOO;
                            this.bboxIntersectionTestEx = this.qtestPOOEx;
                        } else if (j === 0) {
                            this.bboxIntersectionTest = this.qtestPOP;
                            this.bboxIntersectionTestEx = this.qtestPOPEx;
                        } else if (k === 0) {
                            this.bboxIntersectionTest = this.qtestPPO;
                            this.bboxIntersectionTestEx = this.qtestPPOEx;
                        } else {
                            this.bboxIntersectionTest = this.qtestPPP;
                            this.bboxIntersectionTestEx = this.qtestPPPEx;
                        }
                    }
                }
            }
        }
    }
}

/**
 * The rectangle packer class
 * @public
 */ class RectsPacker {
    /** @internal */ _bins;
    /** @internal */ _maxBins;
    /** @internal */ _width;
    /** @internal */ _height;
    /**
   * @param width - width of image bin
   * @param height - height of image bin
   * @param maxBins - max count of image bins
   */ constructor(width, height, maxBins = 0){
        this._width = width;
        this._height = height;
        this._maxBins = maxBins;
        this._bins = [
            new Bin(this._width, this._height)
        ];
    }
    /** Clear all image bins of the packer */ clear() {
        this._bins = [
            new Bin(this._width, this._height)
        ];
    }
    /**
   * Inserts a new rectangle
   * @param width - Width of the rectangle.
   * @param height - Height of the rectangle.
   * @returns The pack result.
   */ insert(width, height) {
        if (width > this._width || height > this._height) {
            return null;
        }
        const rect = this._bins[this._bins.length - 1].insert(width, height);
        if (rect) {
            return {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                binIndex: this._bins.length - 1
            };
        }
        if (this._maxBins === 0 || this._bins.length < this._maxBins) {
            this._bins.push(new Bin(this._width, this._height));
            const rect = this._bins[this._bins.length - 1].insert(width, height);
            return {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                binIndex: this._bins.length - 1
            };
        }
        return null;
    }
}
class Bin {
    freeRects;
    constructor(width, height){
        this.freeRects = [
            {
                x: 0,
                y: 0,
                width,
                height
            }
        ];
    }
    insert(width, height) {
        const newRect = this.findBestFit(width, height);
        if (!newRect) {
            return null;
        }
        let numRectsToProcess = this.freeRects.length;
        let i = 0;
        while(i < numRectsToProcess){
            if (this.splitFreeRect(this.freeRects[i], newRect)) {
                this.freeRects.splice(i, 1);
                --numRectsToProcess;
                --i;
            }
            ++i;
        }
        this.pruneFreeRects();
        return newRect;
    }
    findBestFit(width, height) {
        let score = Number.MAX_VALUE;
        let rect = null;
        for (const freeRect of this.freeRects){
            if (freeRect.width >= width && freeRect.height >= height) {
                const areaFit = freeRect.width * freeRect.height - width * height;
                if (areaFit < score) {
                    if (!rect) {
                        rect = {
                            width,
                            height
                        };
                    }
                    rect.x = freeRect.x;
                    rect.y = freeRect.y;
                    score = areaFit;
                }
            }
        }
        return rect;
    }
    splitFreeRect(free, used) {
        if (used.x >= free.x + free.width || used.x + used.width <= free.x || used.y >= free.y + free.height || used.y + used.height <= free.y) {
            return false;
        }
        if (used.x < free.x + free.width && used.x + used.width > free.x) {
            if (used.y > free.y && used.y < free.y + free.height) {
                this.freeRects.push({
                    x: free.x,
                    y: free.y,
                    width: free.width,
                    height: used.y - free.y
                });
            }
            if (used.y + used.height < free.y + free.height) {
                this.freeRects.push({
                    x: free.x,
                    y: used.y + used.height,
                    width: free.width,
                    height: free.y + free.height - used.y - used.height
                });
            }
        }
        if (used.y < free.y + free.height && used.y + used.height > free.y) {
            if (used.x > free.x && used.x < free.x + free.width) {
                this.freeRects.push({
                    x: free.x,
                    y: free.y,
                    width: used.x - free.x,
                    height: free.height
                });
            }
            if (used.x + used.width < free.x + free.width) {
                this.freeRects.push({
                    x: used.x + used.width,
                    y: free.y,
                    width: free.x + free.width - used.x - used.width,
                    height: free.height
                });
            }
        }
        return true;
    }
    pruneFreeRects() {
        let i = 0;
        let j = 0;
        let len = this.freeRects.length;
        while(i < len){
            j = i + 1;
            const rect1 = this.freeRects[i];
            while(j < len){
                const rect2 = this.freeRects[j];
                if (this.isRectInRect(rect1, rect2)) {
                    this.freeRects.splice(i, 1);
                    --i;
                    --len;
                    break;
                }
                if (this.isRectInRect(rect2, rect1)) {
                    this.freeRects.splice(j, 1);
                    --j;
                    --len;
                }
                j++;
            }
            i++;
        }
    }
    isRectInRect(test, container) {
        return test.x >= container.x && test.y >= container.y && test.x + test.width <= container.x + container.width && test.y + test.height <= container.y + container.height;
    }
}

/**
 * Input manager class
 * @public
 */ class InputManager {
    _app;
    _target;
    _started;
    _clickDistTolerance;
    _clickTimeTolerance;
    _dblclickDistTolerance;
    _dblclickTimeTolerance;
    _pointerDownHandler;
    _pointerUpHandler;
    _pointerMoveHandler;
    _pointerCancelHandler;
    _keyboardHandler;
    _dragHandler;
    _wheelHandler;
    _captureId;
    _middlewares;
    _lastEventDatas;
    /**
   * Creates an instance of InputManager
   * @param app
   */ constructor(app){
        this._app = app;
        this._target = app.options.canvas;
        this._started = false;
        this._clickDistTolerance = 4 * 4;
        this._clickTimeTolerance = 400;
        this._dblclickDistTolerance = 4 * 4;
        this._dblclickTimeTolerance = 400;
        this._lastEventDatas = [];
        this._pointerDownHandler = this._getPointerDownHandler();
        this._pointerUpHandler = this._getPointerUpHandler();
        this._pointerMoveHandler = this._getPointerMoveHander();
        this._pointerCancelHandler = this._getPointerCancelHandler();
        this._keyboardHandler = this._getKeyboardHandler();
        this._dragHandler = this._getDragHandler();
        this._wheelHandler = this._getWheelHandler();
        this._captureId = -1;
        this._middlewares = [];
    }
    /** @internal */ start() {
        if (!this._started) {
            this._started = true;
            this._target.addEventListener('pointerdown', this._pointerDownHandler);
            this._target.addEventListener('pointerup', this._pointerUpHandler);
            this._target.addEventListener('pointermove', this._pointerMoveHandler);
            this._target.addEventListener('pointercancel', this._pointerCancelHandler);
            this._target.addEventListener('keydown', this._keyboardHandler);
            this._target.addEventListener('keyup', this._keyboardHandler);
            this._target.addEventListener('keypress', this._keyboardHandler);
            this._target.addEventListener('drag', this._dragHandler);
            this._target.addEventListener('dragenter', this._dragHandler);
            this._target.addEventListener('dragleave', this._dragHandler);
            this._target.addEventListener('dragstart', this._dragHandler);
            this._target.addEventListener('dragend', this._dragHandler);
            this._target.addEventListener('dragover', this._dragHandler);
            this._target.addEventListener('drop', this._dragHandler);
            this._target.addEventListener('wheel', this._wheelHandler);
        }
    }
    /** @internal */ stop() {
        if (this._started) {
            this._started = false;
            this._target.removeEventListener('pointerdown', this._pointerDownHandler);
            this._target.removeEventListener('pointerup', this._pointerUpHandler);
            this._target.removeEventListener('pointermove', this._pointerMoveHandler);
            this._target.removeEventListener('pointercancel', this._pointerCancelHandler);
            this._target.removeEventListener('keydown', this._keyboardHandler);
            this._target.removeEventListener('keyup', this._keyboardHandler);
            this._target.removeEventListener('keypress', this._keyboardHandler);
            this._target.removeEventListener('drag', this._dragHandler);
            this._target.removeEventListener('dragenter', this._dragHandler);
            this._target.removeEventListener('dragleave', this._dragHandler);
            this._target.removeEventListener('dragstart', this._dragHandler);
            this._target.removeEventListener('dragend', this._dragHandler);
            this._target.removeEventListener('dragover', this._dragHandler);
            this._target.removeEventListener('drop', this._dragHandler);
            this._target.removeEventListener('wheel', this._wheelHandler);
            this._lastEventDatas = [];
        }
    }
    /**
   * Adds a event handler middleware.
   *
   * @remarks
   * All handlers will be called in the order in which they were added
   * until a handler returns true.
   * If either handler returns true, the event that the Application
   * listens to will not be triggered
   *
   * @param handler The event handler to be added
   * @returns self
   */ use(handler) {
        if (handler) {
            this._middlewares.push(handler);
        }
        return this;
    }
    _callMiddlewares(ev, type) {
        for (const handler of this._middlewares){
            if (handler(ev, type ?? ev.type)) {
                return true;
            }
        }
        return false;
    }
    _getPointerCancelHandler() {
        const that = this;
        return function(ev) {
            const eventData = that._getPointerEventData(ev.pointerId);
            eventData.lastDown = false;
            eventData.lastClick = false;
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerMoveHander() {
        const that = this;
        return function(ev) {
            const eventData = that._getPointerEventData(ev.pointerId);
            eventData.lastMoveX = ev.offsetX;
            eventData.lastMoveY = ev.offsetY;
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerDownHandler() {
        const that = this;
        return function(ev) {
            if (ev.pointerType === 'mouse' && ev.button === 0) {
                that._captureId = ev.pointerId;
                that._app.options.canvas.setPointerCapture(ev.pointerId);
            }
            const eventData = that._getPointerEventData(ev.pointerId);
            eventData.lastDown = true;
            eventData.lastDownX = ev.offsetX;
            eventData.lastDownY = ev.offsetY;
            eventData.lastDownTime = Date.now();
            that._app.focus();
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerUpHandler() {
        const that = this;
        return function(ev) {
            if (ev.pointerType === 'mouse' && ev.button === 0 && that._captureId === ev.pointerId) {
                that._app.options.canvas.releasePointerCapture(ev.pointerId);
                that._captureId = -1;
            }
            const eventData = that._getPointerEventData(ev.pointerId);
            let emitClickEvent = false;
            let emitDoubleClickEvent = false;
            const now = Date.now();
            if (eventData.lastDown) {
                if (now <= eventData.lastDownTime + that._clickTimeTolerance) {
                    let deltaX = ev.offsetX - eventData.lastDownX;
                    let deltaY = ev.offsetY - eventData.lastDownY;
                    if (deltaX * deltaX + deltaY * deltaY <= that._clickDistTolerance) {
                        emitClickEvent = true;
                        if (eventData.lastClick && now <= eventData.lastClickTime + that._dblclickTimeTolerance) {
                            deltaX = ev.offsetX - eventData.lastClickX;
                            deltaY = ev.offsetY - eventData.lastClickY;
                            if (deltaX * deltaX + deltaY * deltaY <= that._dblclickDistTolerance) {
                                emitDoubleClickEvent = true;
                            }
                        }
                    }
                }
            }
            eventData.lastDown = false;
            eventData.lastMoveX = ev.offsetX;
            eventData.lastMoveY = ev.offsetY;
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
            if (emitClickEvent) {
                if (!that._callMiddlewares(ev, 'click')) {
                    that._app.dispatchEvent(ev, 'click');
                }
                if (emitDoubleClickEvent) {
                    if (!that._callMiddlewares(ev, 'dblclick')) {
                        that._app.dispatchEvent(ev, 'dblclick');
                    }
                    eventData.lastClick = false;
                } else {
                    eventData.lastClick = true;
                    eventData.lastClickX = ev.offsetX;
                    eventData.lastClickY = ev.offsetY;
                    eventData.lastClickTime = now;
                }
            }
        };
    }
    _getKeyboardHandler() {
        const that = this;
        return function(ev) {
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getDragHandler() {
        const that = this;
        return function(ev) {
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getWheelHandler() {
        const that = this;
        return function(ev) {
            if (!that._callMiddlewares(ev)) {
                that._app.dispatchEvent(ev);
            }
        };
    }
    _getPointerEventData(pointerId) {
        return this._lastEventDatas[pointerId] ?? (this._lastEventDatas[pointerId] = {
            lastClick: false,
            lastClickX: 0,
            lastClickY: 0,
            lastClickTime: 0,
            lastDown: false,
            lastDownX: 0,
            lastDownY: 0,
            lastDownTime: 0,
            lastMoveX: 0,
            lastMoveY: 0
        });
    }
}

/**
 * Event that will be fired every frame
 *
 * @remarks
 * This is where all the rendering work is done.
 *
 * @public
 */ class AppTickEvent {
    type = 'tick';
}
/**
 * This event will be fired whenever the device size changes
 * @public
 */ class AppResizeEvent {
    width;
    height;
    type;
    constructor(width, height){
        this.type = 'resize';
        this.width = width;
        this.height = height;
    }
}
/**
 * Application class
 *
 * @remarks
 * This is the entry point of your application.
 * The Application is responsible for initializing the rendering device
 * and doing the rendering loop.
 * The Application can not be created more than once. You can get the
 * instance by calling the 'Application.instance' static method.
 *
 * @public
 */ class Application extends makeEventTarget(Object)() {
    _options;
    _device;
    _inputManager;
    _running;
    _ready;
    _canRender;
    _drawEvent;
    _logger;
    _elapsed;
    static _instance;
    /**
   * Creates an instance of Application
   * @param opt - The creation options
   */ constructor(opt){
        super();
        if (Application._instance) {
            throw new Error('It is not allowed to have multiple Application instances');
        }
        Application._instance = this;
        this._options = {
            backend: opt.backend,
            enableMSAA: opt.enableMSAA ?? false,
            pixelRatio: opt.pixelRatio ?? window.devicePixelRatio ?? 1,
            canvas: opt.canvas
        };
        this._inputManager = new InputManager(this);
        this._running = null;
        this._ready = false;
        this._canRender = false;
        this._elapsed = 0;
        this._drawEvent = new AppTickEvent();
        this._logger = {
            log (text, mode) {
                if (mode === 'warn') {
                    console.warn(text);
                } else if (mode === 'error') {
                    console.error(text);
                } else if (mode === 'debug') {
                    console.debug(text);
                } else if (mode === 'info') {
                    console.info(text);
                } else {
                    console.log(text);
                }
            }
        };
    }
    /** The input manager instance */ get inputManager() {
        return this._inputManager;
    }
    /** The options that was used to create the application */ get options() {
        return this._options;
    }
    /**
   * Query if the device is ok to render objects now.
   *
   * @remarks
   * False will be returned if the device is lost.
   */ get canRender() {
        return this._canRender;
    }
    /**
   * Query time elapsed since last frame in seconds
   */ get timeElapsedInSeconds() {
        return this._elapsed;
    }
    /** Gets the singleton instance of the application */ static get instance() {
        return this._instance;
    }
    /** The rendering device that was initialized by the application */ get device() {
        return this._device;
    }
    /** Gets the device type */ get deviceType() {
        return this._options.backend.typeName();
    }
    /** The logger object */ get logger() {
        return this._logger;
    }
    set logger(val) {
        this._logger = val;
    }
    /** Set focus */ focus() {
        this._device.canvas.focus();
    }
    /** Wait until the application is ready. */ async ready() {
        if (!this._ready) {
            this._device = await this._options.backend.createDevice(this._options.canvas, {
                dpr: this._options.pixelRatio,
                msaa: !!this._options.enableMSAA
            });
            if (!this._device) {
                throw new Error('App.init(): create device failed');
            }
            this._device.canvas.focus();
            this._inputManager.start();
            this._device.on('resize', (ev)=>{
                this.dispatchEvent(new AppResizeEvent(ev.width, ev.height));
            });
            this._ready = true;
        }
    }
    /** Render one frame */ frame() {
        if (this._ready) {
            this._canRender = this.device.beginFrame();
            this._elapsed = this.device.frameInfo.elapsedFrame * 0.001;
            this.device.setFramebuffer(null);
            this.device.setViewport(null);
            this.device.setScissor(null);
            this.dispatchEvent(this._drawEvent);
            this.device.endFrame();
        }
    }
    /** Start running the rendering loop */ run() {
        if (this._running) {
            return;
        }
        const that = this;
        (function entry() {
            that._running = requestAnimationFrame(entry);
            that.frame();
        })();
    }
    /** Stop running the rendering loop */ stop() {
        if (this._running) {
            cancelAnimationFrame(this._running);
            this._running = null;
        }
    }
    /** Message log */ log(text, mode) {
        this._logger?.log(text, mode);
    }
}

let vertexLayout = null;
let renderStates = null;
const programs = {};
const faceDirections = [
    [
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0),
        new Vector3(1, 0, 0)
    ],
    [
        new Vector3(0, 0, 1),
        new Vector3(0, -1, 0),
        new Vector3(-1, 0, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, 1)
    ],
    [
        new Vector3(-1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, -1)
    ]
];
function init() {
    const device = Application.instance.device;
    const vertices = new Float32Array([
        1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        -1
    ]);
    const indices = new Uint16Array([
        0,
        1,
        2,
        0,
        2,
        3
    ]);
    vertexLayout = device.createVertexLayout({
        vertexBuffers: [
            {
                buffer: device.createVertexBuffer('position_f32x2', vertices)
            }
        ],
        indexBuffer: device.createIndexBuffer(indices)
    });
    renderStates = device.createRenderStateSet();
    renderStates.useRasterizerState().setCullMode('none');
    renderStates.useDepthState().enableTest(false).enableWrite(false);
}
function getProgramInfo(type, numSamples) {
    const device = Application.instance.device;
    const hash = `${type}:${numSamples}`;
    let ret = programs[hash];
    if (!ret) {
        const program = createPMREMProgram(type, numSamples);
        const bindgroup = device.createBindGroup(program.bindGroupLayouts[0]);
        programs[hash] = ret = {
            program,
            bindgroup
        };
    }
    return ret;
}
function createPMREMProgram(type, numSamples) {
    const device = Application.instance.device;
    const pb = device;
    return pb.buildRenderProgram({
        vertex (pb) {
            this.$inputs.pos = pb.vec2().attrib('position');
            this.up = pb.vec3().uniform(0);
            this.right = pb.vec3().uniform(0);
            this.front = pb.vec3().uniform(0);
            pb.main(function() {
                this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                this.$outputs.direction = pb.mul(pb.mat3(this.up, this.right, this.front), pb.vec3(this.$inputs.pos, 1));
                if (device.type === 'webgpu') {
                    this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                }
            });
        },
        fragment (pb) {
            if (type === 'ggx') {
                this.alphaG = pb.float().uniform(0);
            }
            this.vFilteringInfo = pb.vec2().uniform(0);
            this.hdrScale = pb.float().uniform(0);
            this.inputTexture = pb.texCube().uniform(0);
            this.NUM_SAMPLES_FLOAT = pb.float(numSamples);
            this.NUM_SAMPLES_FLOAT_INVERSED = pb.float(1 / numSamples);
            this.K = pb.float(4);
            this.$outputs.outcolor = pb.vec4();
            if (device.type === 'webgl') {
                pb.func('radicalInverse_VdC', [
                    pb.int('bits')
                ], function() {
                    this.$l.rand = pb.float(0);
                    this.$l.denom = pb.float(1);
                    this.$l.invBase = pb.float(0.5);
                    this.$l.n = this.bits;
                    this.$for(pb.int('i'), 0, 32, function() {
                        this.denom = pb.mul(this.denom, 2);
                        this.rand = pb.add(this.rand, pb.div(pb.mod(pb.float(this.n), 2), this.denom));
                        this.n = pb.div(this.n, 2);
                        this.$if(pb.equal(this.n, 0), function() {
                            this.$break();
                        });
                    });
                    this.$return(this.rand);
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(this.i)));
                });
            } else {
                pb.func('radicalInverse_VdC', [
                    pb.uint('bits')
                ], function() {
                    this.$l.n = this.bits;
                    this.n = pb.compOr(pb.sal(this.n, 16), pb.sar(this.n, 16));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x55555555), 1), pb.sar(pb.compAnd(this.n, 0xaaaaaaaa), 1));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x33333333), 2), pb.sar(pb.compAnd(this.n, 0xcccccccc), 2));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x0f0f0f0f), 4), pb.sar(pb.compAnd(this.n, 0xf0f0f0f0), 4));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x00ff00ff), 8), pb.sar(pb.compAnd(this.n, 0xff00ff00), 8));
                    this.$return(pb.mul(pb.float(this.n), 2.3283064365386963e-10));
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(pb.uint(this.i))));
                });
            }
            pb.func('log4', [
                pb.float('x')
            ], function() {
                this.$return(pb.mul(pb.log2(this.x), 0.5));
            });
            if (type === 'lambertian') {
                pb.func('hemisphereCosSample', [
                    pb.vec2('u')
                ], function() {
                    this.$l.phi = pb.mul(this.u.x, 2 * Math.PI);
                    this.$l.cosTheta2 = pb.sub(1, this.u.y);
                    this.$l.cosTheta = pb.sqrt(this.cosTheta2);
                    this.$l.sinTheta = pb.sqrt(pb.sub(1, this.cosTheta2));
                    this.$return(pb.vec3(pb.mul(this.sinTheta, pb.cos(this.phi)), pb.mul(this.sinTheta, pb.sin(this.phi)), this.cosTheta));
                });
                pb.func('irradiance', [
                    pb.vec3('direction'),
                    pb.vec2('vFilteringInfo')
                ], function() {
                    this.$l.n = pb.normalize(this.direction);
                    this.$l.result = pb.vec3(0);
                    this.$l.tangent = pb.vec3();
                    this.$if(pb.lessThan(pb.abs(this.n.z), 0.999), function() {
                        this.tangent = pb.vec3(0, 0, 1);
                    }).$else(function() {
                        this.tangent = pb.vec3(1, 0, 0);
                    });
                    this.tangent = pb.normalize(pb.cross(this.tangent, this.n));
                    this.$l.bitangent = pb.cross(this.n, this.tangent);
                    this.$l.tbn = pb.mat3(this.tangent, this.bitangent, this.n);
                    this.$l.maxLevel = this.vFilteringInfo.y;
                    this.$l.dim0 = this.vFilteringInfo.x;
                    this.$l.omegaP = pb.div(4 * Math.PI, pb.mul(this.dim0, this.dim0, 6));
                    this.$for(pb.int('i'), 0, numSamples, function() {
                        this.$l.Xi = this.hammersley2d(this.i, numSamples);
                        this.$l.Ls = pb.normalize(this.hemisphereCosSample(this.Xi));
                        this.$l.Ns = pb.vec3(0, 0, 1);
                        this.$l.NoL = pb.dot(this.Ns, this.Ls);
                        this.$if(pb.greaterThan(this.NoL, 0), function() {
                            this.$l.pdf_inversed = pb.div(Math.PI, this.NoL);
                            this.$l.omegaS = pb.mul(this.pdf_inversed, this.NUM_SAMPLES_FLOAT_INVERSED);
                            this.$l.l = pb.add(pb.sub(this.log4(this.omegaS), this.log4(this.omegaP)), this.log4(this.K));
                            this.$l.mipLevel = pb.clamp(this.l, 0, this.maxLevel);
                            this.$l.c = pb.textureSampleLevel(this.inputTexture, pb.mul(this.tbn, this.Ls), this.mipLevel).rgb;
                            this.result = pb.add(this.result, this.c);
                        });
                    });
                    this.result = pb.mul(this.result, this.NUM_SAMPLES_FLOAT_INVERSED);
                    this.$return(this.result);
                });
            }
            if (type === 'ggx') {
                pb.func('hemisphereImportanceSampleDggx', [
                    pb.vec2('u'),
                    pb.float('a')
                ], function() {
                    this.$l.phi = pb.mul(this.u.x, 2 * Math.PI);
                    this.$l.cosTheta2 = pb.div(pb.sub(1, this.u.y), pb.add(pb.mul(pb.add(this.a, 1), pb.sub(this.a, 1), this.u.y), 1));
                    this.$l.cosTheta = pb.sqrt(this.cosTheta2);
                    this.$l.sinTheta = pb.sqrt(pb.sub(1, this.cosTheta2));
                    this.$return(pb.vec3(pb.mul(pb.cos(this.phi), this.sinTheta), pb.mul(pb.sin(this.phi), this.sinTheta), this.cosTheta));
                });
                pb.func('normalDistributionFunction_TrowbridgeReitzGGX', [
                    pb.float('NoH'),
                    pb.float('alphaG')
                ], function() {
                    this.$l.a2 = pb.mul(this.alphaG, this.alphaG);
                    this.$l.d = pb.add(pb.mul(this.NoH, this.NoH, pb.sub(this.a2, 1)), 1);
                    this.$return(pb.div(this.a2, pb.mul(this.d, this.d, Math.PI)));
                });
                pb.func('radiance', [
                    pb.float('alphaG'),
                    pb.vec3('direction'),
                    pb.vec2('vFilteringInfo')
                ], function() {
                    this.$l.n = pb.normalize(this.direction);
                    this.$if(pb.equal(this.alphaG, 0), function() {
                        this.$l.c = pb.textureSampleLevel(this.inputTexture, this.n, 0).rgb;
                        this.$return(this.c);
                    }).$else(function() {
                        this.$l.result = pb.vec3(0);
                        this.$l.tangent = pb.vec3();
                        this.$if(pb.lessThan(pb.abs(this.n.z), 0.999), function() {
                            this.tangent = pb.vec3(0, 0, 1);
                        }).$else(function() {
                            this.tangent = pb.vec3(1, 0, 0);
                        });
                        this.tangent = pb.normalize(pb.cross(this.tangent, this.n));
                        this.$l.bitangent = pb.cross(this.n, this.tangent);
                        this.$l.tbn = pb.mat3(this.tangent, this.bitangent, this.n);
                        this.$l.maxLevel = this.vFilteringInfo.y;
                        this.$l.dim0 = this.vFilteringInfo.x;
                        this.$l.omegaP = pb.div(4 * Math.PI, pb.mul(this.dim0, this.dim0, 6));
                        this.$l.weight = pb.float(0);
                        this.$for(pb.int('i'), 0, numSamples, function() {
                            this.$l.Xi = this.hammersley2d(this.i, numSamples);
                            this.$l.H = this.hemisphereImportanceSampleDggx(this.Xi, this.alphaG);
                            this.$l.NoV = pb.float(1);
                            this.$l.NoH = this.H.z;
                            this.$l.NoH2 = pb.mul(this.H.z, this.H.z);
                            this.$l.NoL = pb.sub(pb.mul(this.NoH2, 2), 1);
                            this.$l.L = pb.normalize(pb.vec3(pb.mul(this.NoH, this.H.x, 2), pb.mul(this.NoH, this.H.y, 2), this.NoL));
                            this.$if(pb.greaterThan(this.NoL, 0), function() {
                                this.$l.pdf_inversed = pb.div(4, this.normalDistributionFunction_TrowbridgeReitzGGX(this.NoH, this.alphaG));
                                this.$l.omegaS = pb.mul(this.pdf_inversed, this.NUM_SAMPLES_FLOAT_INVERSED);
                                this.$l.l = pb.add(pb.sub(this.log4(this.omegaS), this.log4(this.omegaP)), this.log4(this.K));
                                this.$l.mipLevel = pb.clamp(this.l, 0, this.maxLevel);
                                this.weight = pb.add(this.weight, this.NoL);
                                this.$l.c = pb.textureSampleLevel(this.inputTexture, pb.mul(this.tbn, this.L), this.mipLevel).rgb;
                                this.result = pb.add(this.result, pb.mul(this.c, this.NoL));
                            });
                        });
                        this.result = pb.div(this.result, this.weight);
                        this.$return(this.result);
                    });
                });
            }
            pb.main(function() {
                if (type === 'ggx') {
                    this.$l.color = this.radiance(this.alphaG, this.$inputs.direction, this.vFilteringInfo);
                }
                if (type === 'lambertian') {
                    this.$l.color = this.irradiance(this.$inputs.direction, this.vFilteringInfo);
                }
                this.$outputs.outcolor = pb.vec4(pb.mul(this.color, this.hdrScale), 1);
            });
        }
    });
}
function doPrefilterCubemap(type, roughness, miplevel, srcTexture, dstTexture, filteringInfo, numSamples) {
    const device = Application.instance.device;
    const framebuffer = device.createFrameBuffer([
        dstTexture
    ], null);
    framebuffer.setColorAttachmentMipLevel(0, miplevel);
    framebuffer.setColorAttachmentGenerateMipmaps(0, false);
    const { program, bindgroup } = getProgramInfo(type, numSamples);
    bindgroup.setValue('vFilteringInfo', filteringInfo);
    bindgroup.setValue('hdrScale', 1);
    bindgroup.setTexture('inputTexture', srcTexture);
    if (type === 'ggx') {
        bindgroup.setValue('alphaG', roughness);
    }
    device.setProgram(program);
    device.setBindGroup(0, bindgroup);
    device.setFramebuffer(framebuffer);
    for(let i = 0; i < 6; i++){
        framebuffer.setColorAttachmentCubeFace(0, i);
        device.setVertexLayout(vertexLayout);
        device.setRenderStates(renderStates);
        bindgroup.setValue('up', faceDirections[i][0]);
        bindgroup.setValue('right', faceDirections[i][1]);
        bindgroup.setValue('front', faceDirections[i][2]);
        device.draw('triangle-list', 0, 6);
    }
}
/**
 * Prefilters an environment cubemap
 *
 * @param tex - The environment cubemap
 * @param type - The prefilter type
 * @param destTex - The output cubemap
 *
 * @public
 */ function prefilterCubemap(tex, type, destTex, numSamples) {
    if (!tex || !tex.isTextureCube()) {
        console.error('prefilterCubemap(): source texture must be cube texture');
        return;
    }
    const device = Application.instance.device;
    if (!vertexLayout) {
        init();
    }
    device.pushDeviceStates();
    const rs = device.getRenderStates();
    const srcTex = tex;
    const width = tex.width;
    const mipmapsCount = tex.mipLevelCount;
    const filteringInfo = new Vector2(width, mipmapsCount);
    const mips = type === 'ggx' ? destTex.mipLevelCount : 1;
    for(let i = 0; i < mips; i++){
        const alpha = i === 0 ? 0 : Math.pow(2, i) / width;
        doPrefilterCubemap(type, alpha, i, srcTex, destTex, filteringInfo, numSamples ?? 64);
    }
    device.popDeviceStates();
    device.setRenderStates(rs);
}

const RED_SHIFT = 0;
const GREEN_SHIFT = 1;
const BLUE_SHIFT = 2;
const ALPHA_SHIFT = 3;
const DEPTH_SHIFT = 4;
const STENCIL_SHIFT = 5;
const FLOAT_SHIFT = 6;
const INTEGER_SHIFT = 7;
const SIGNED_SHIFT = 8;
const SRGB_SHIFT = 9;
const BGR_SHIFT = 10;
const BLOCK_SIZE_SHIFT = 11;
const BLOCK_SIZE_MASK = 0x1f << BLOCK_SIZE_SHIFT;
const BLOCK_WIDTH_SHIFT = 16;
const BLOCK_WIDTH_MASK = 0xf << BLOCK_WIDTH_SHIFT;
const BLOCK_HEIGHT_SHIFT = 20;
const BLOCK_HEIGHT_MASK = 0xf << BLOCK_HEIGHT_SHIFT;
const COMPRESSED_FORMAT_SHIFT = 24;
const COMPRESSION_FORMAT_BC1 = 1 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC2 = 2 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC3 = 3 << COMPRESSED_FORMAT_SHIFT;
/*
const COMPRESSION_FORMAT_BC4 = 4 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC5 = 5 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC6 = 6 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_BC7 = 7 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGB8 = 8 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGB8_A1 = 9 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ETC2_RGBA8 = 10 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_4x4 = 11 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_5x4 = 12 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_5x5 = 13 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_6x5 = 14 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_6x6 = 15 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x5 = 16 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x6 = 17 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_8x8 = 18 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x5 = 19 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x6 = 20 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x8 = 21 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_10x10 = 22 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_12x10 = 23 << COMPRESSED_FORMAT_SHIFT;
const COMPRESSION_FORMAT_ASTC_12x12 = 24 << COMPRESSED_FORMAT_SHIFT;
*/ const COMPRESSION_FORMAT_BITMASK = 0x1f << COMPRESSED_FORMAT_SHIFT;
const RED_BITMASK = 1 << RED_SHIFT;
const GREEN_BITMASK = 1 << GREEN_SHIFT;
const BLUE_BITMASK = 1 << BLUE_SHIFT;
const ALPHA_BITMASK = 1 << ALPHA_SHIFT;
const DEPTH_BITMASK = 1 << DEPTH_SHIFT;
const STENCIL_BITMASK = 1 << STENCIL_SHIFT;
const FLOAT_BITMASK = 1 << FLOAT_SHIFT;
const INTEGER_BITMASK = 1 << INTEGER_SHIFT;
const SIGNED_BITMASK = 1 << SIGNED_SHIFT;
const SRGB_BITMASK = 1 << SRGB_SHIFT;
const BGR_BITMASK = 1 << BGR_SHIFT;
function makeTextureFormat(compression, r, g, b, a, depth, stencil, float, integer, signed, srgb, bgr, blockWidth, blockHeight, blockSize) {
    const compressionBits = compression;
    const colorBits = (r ? RED_BITMASK : 0) | (g ? GREEN_BITMASK : 0) | (b ? BLUE_BITMASK : 0) | (a ? ALPHA_BITMASK : 0);
    const depthStencilBits = (depth ? DEPTH_BITMASK : 0) | (stencil ? STENCIL_BITMASK : 0);
    const floatBits = float ? FLOAT_BITMASK : 0;
    const integerBits = integer ? INTEGER_BITMASK : 0;
    const signedBits = signed ? SIGNED_BITMASK : 0;
    const srgbBits = srgb ? SRGB_BITMASK : 0;
    const bgrBits = bgr ? BGR_BITMASK : 0;
    const blockBits = blockWidth << BLOCK_WIDTH_SHIFT | blockHeight << BLOCK_HEIGHT_SHIFT | blockSize << BLOCK_SIZE_SHIFT;
    return compressionBits | colorBits | depthStencilBits | floatBits | integerBits | signedBits | srgbBits | bgrBits | blockBits;
}
const textureFormatMap = {
    unknown: 0,
    r8unorm: makeTextureFormat(0, true, false, false, false, false, false, false, false, false, false, false, 1, 1, 1),
    r8snorm: makeTextureFormat(0, true, false, false, false, false, false, false, false, true, false, false, 1, 1, 1),
    r16f: makeTextureFormat(0, true, false, false, false, false, false, true, false, true, false, false, 1, 1, 2),
    r32f: makeTextureFormat(0, true, false, false, false, false, false, true, false, true, false, false, 1, 1, 4),
    r8ui: makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 1),
    r8i: makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 1),
    r16ui: makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 2),
    r16i: makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 2),
    r32ui: makeTextureFormat(0, true, false, false, false, false, false, false, true, false, false, false, 1, 1, 4),
    r32i: makeTextureFormat(0, true, false, false, false, false, false, false, true, true, false, false, 1, 1, 4),
    rg8unorm: makeTextureFormat(0, true, true, false, false, false, false, false, false, false, false, false, 1, 1, 2),
    rg8snorm: makeTextureFormat(0, true, true, false, false, false, false, false, false, true, false, false, 1, 1, 2),
    rg16f: makeTextureFormat(0, true, true, false, false, false, false, true, false, true, false, false, 1, 1, 4),
    rg32f: makeTextureFormat(0, true, true, false, false, false, false, true, false, true, false, false, 1, 1, 8),
    rg8ui: makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 2),
    rg8i: makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 2),
    rg16ui: makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 4),
    rg16i: makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 4),
    rg32ui: makeTextureFormat(0, true, true, false, false, false, false, false, true, false, false, false, 1, 1, 8),
    rg32i: makeTextureFormat(0, true, true, false, false, false, false, false, true, true, false, false, 1, 1, 8),
    rgba8unorm: makeTextureFormat(0, true, true, true, true, false, false, false, false, false, false, false, 1, 1, 4),
    'rgba8unorm-srgb': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, true, false, 1, 1, 4),
    rgba8snorm: makeTextureFormat(0, true, true, true, true, false, false, false, false, true, false, false, 1, 1, 4),
    bgra8unorm: makeTextureFormat(0, true, true, true, true, false, false, false, false, false, false, true, 1, 1, 4),
    'bgra8unorm-srgb': makeTextureFormat(0, true, true, true, true, false, false, false, false, false, true, true, 1, 1, 4),
    rgba16f: makeTextureFormat(0, true, true, true, true, false, false, true, false, true, false, false, 1, 1, 8),
    rgba32f: makeTextureFormat(0, true, true, true, true, false, false, true, false, true, false, false, 1, 1, 16),
    rgba8ui: makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 4),
    rgba8i: makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 4),
    rgba16ui: makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 8),
    rgba16i: makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 8),
    rgba32ui: makeTextureFormat(0, true, true, true, true, false, false, false, true, false, false, false, 1, 1, 16),
    rgba32i: makeTextureFormat(0, true, true, true, true, false, false, false, true, true, false, false, 1, 1, 16),
    rg11b10uf: makeTextureFormat(0, true, true, true, false, false, false, true, false, false, false, false, 1, 1, 4),
    d16: makeTextureFormat(0, false, false, false, false, true, false, false, false, false, false, false, 1, 1, 2),
    d24: makeTextureFormat(0, false, false, false, false, true, false, false, false, false, false, false, 0, 0, 0),
    d32f: makeTextureFormat(0, false, false, false, false, true, false, true, false, true, false, false, 1, 1, 4),
    d24s8: makeTextureFormat(0, false, false, false, false, true, true, false, false, false, false, false, 1, 1, 4),
    d32fs8: makeTextureFormat(0, false, false, false, false, true, true, true, false, true, false, false, 1, 1, 5),
    // compressed texture formats
    dxt1: makeTextureFormat(COMPRESSION_FORMAT_BC1, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 8),
    'dxt1-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC1, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 8),
    dxt3: makeTextureFormat(COMPRESSION_FORMAT_BC2, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 16),
    'dxt3-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC2, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 16),
    dxt5: makeTextureFormat(COMPRESSION_FORMAT_BC3, true, true, true, true, false, false, false, false, false, false, false, 4, 4, 16),
    'dxt5-srgb': makeTextureFormat(COMPRESSION_FORMAT_BC3, true, true, true, true, false, false, false, false, false, true, false, 4, 4, 16)
};
/**
 * Converts a non-sRGB texture format to the corresponding sRGB texture format
 * @param format - The texture format to be converted
 * @returns The sRGB texture format
 * @public
 */ function linearTextureFormatToSRGB(format) {
    switch(format){
        case 'rgba8unorm':
            return 'rgba8unorm-srgb';
        case 'bgra8unorm':
            return 'bgra8unorm-srgb';
        case 'dxt1':
            return 'dxt1-srgb';
        case 'dxt3':
            return 'dxt3-srgb';
        case 'dxt5':
            return 'dxt5-srgb';
        default:
            return format;
    }
}
/**
 * Check if a given texture format contains an alpha channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains an alpha channel, otherwise false
 * @public
 */ function hasAlphaChannel(format) {
    return !!(textureFormatMap[format] & ALPHA_BITMASK);
}
/**
 * Check if a given texture format contains a red channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a red channel, otherwise false
 * @public
 */ function hasRedChannel(format) {
    return !!(textureFormatMap[format] & RED_BITMASK);
}
/**
 * Check if a given texture format contains a green channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a green channel, otherwise false
 * @public
 */ function hasGreenChannel(format) {
    return !!(textureFormatMap[format] & GREEN_BITMASK);
}
/**
 * Check if a given texture format contains a blue channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a blue channel, otherwise false
 * @public
 */ function hasBlueChannel(format) {
    return !!(textureFormatMap[format] & BLUE_BITMASK);
}
/**
 * Check if a given texture format contains a depth channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a depth channel, otherwise false
 * @public
 */ function hasDepthChannel(format) {
    return !!(textureFormatMap[format] & DEPTH_BITMASK);
}
/**
 * Check if a given texture format contains a stencil channel.
 * @param format - The texture format to be checked.
 * @returns true if the texture format contains a stencil channel, otherwise false
 * @public
 */ function hasStencilChannel(format) {
    return !!(textureFormatMap[format] & STENCIL_BITMASK);
}
/**
 * Check whether a given texture format is floating-point.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is floating-point, otherwise false
 * @public
 */ function isFloatTextureFormat(format) {
    return !!(textureFormatMap[format] & FLOAT_BITMASK);
}
/**
 * Check whether a given texture format is integer.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is integer, otherwise false
 * @public
 */ function isIntegerTextureFormat(format) {
    return !!(textureFormatMap[format] & INTEGER_BITMASK);
}
/**
 * Check whether a given texture format is signed.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is signed, otherwise false
 * @public
 */ function isSignedTextureFormat(format) {
    return !!(textureFormatMap[format] & SIGNED_BITMASK);
}
/**
 * Check whether a given texture format is a compressed format.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is a compressed format, otherwise false
 * @public
 */ function isCompressedTextureFormat(format) {
    return !!(textureFormatMap[format] & COMPRESSION_FORMAT_BITMASK);
}
/**
 * Check whether a given texture format is sRGB format.
 * @param format - The texture format to be checked.
 * @returns true if the texture format is sRGB format, otherwise false
 * @public
 */ function isSRGBTextureFormat(format) {
    return !!(textureFormatMap[format] & SRGB_BITMASK);
}
/**
 * Get block size of given texture format
 * @param format - The texture format
 * @returns The block size
 * @public
 */ function getTextureFormatBlockSize(format) {
    return (textureFormatMap[format] & BLOCK_SIZE_MASK) >> BLOCK_SIZE_SHIFT;
}
/**
 * Get block width of given texture format
 * @param format - The texture format
 * @returns The block width
 * @public
 */ function getTextureFormatBlockWidth(format) {
    return (textureFormatMap[format] & BLOCK_WIDTH_MASK) >> BLOCK_WIDTH_SHIFT;
}
/**
 * Get block height of given texture format
 * @param format - The texture format
 * @returns The block height
 * @public
 */ function getTextureFormatBlockHeight(format) {
    return (textureFormatMap[format] & BLOCK_HEIGHT_MASK) >> BLOCK_HEIGHT_SHIFT;
}
var ShaderType;
(function(ShaderType) {
    ShaderType[ShaderType["Vertex"] = 1] = "Vertex";
    ShaderType[ShaderType["Fragment"] = 2] = "Fragment";
    ShaderType[ShaderType["Compute"] = 4] = "Compute";
})(ShaderType || (ShaderType = {}));
/**
 * Event that will be fired when device is lost
 * @public
 */ class DeviceLostEvent {
    /** The event name */ static NAME = 'devicelost';
    type = DeviceLostEvent.NAME;
}
/**
 * Event that will be fired when device has just been restored
 * @public
 */ class DeviceRestoreEvent {
    /** The event name */ static NAME = 'devicerestored';
    type = DeviceRestoreEvent.NAME;
}
/**
 * Event that will be fired when size of back buffer has changed
 * @public
 */ class DeviceResizeEvent {
    /** The event name */ static NAME = 'resize';
    width;
    height;
    type = DeviceResizeEvent.NAME;
    constructor(width, height){
        this.width = width;
        this.height = height;
    }
}
/**
 * Event that will be fired when any gpu object is created
 * @public
 */ class DeviceGPUObjectAddedEvent {
    /** the event name */ static NAME = 'gpuobject_added';
    object;
    type = DeviceGPUObjectAddedEvent.NAME;
    constructor(obj){
        this.object = obj;
    }
}
/**
 * Event that will be fired when any gpu object is disposed
 * @public
 */ class DeviceGPUObjectRemovedEvent {
    /** The event name */ static NAME = 'gpuobject_removed';
    object;
    type = DeviceGPUObjectRemovedEvent.NAME;
    constructor(obj){
        this.object = obj;
    }
}
/**
 * Event that will be fired when any gpu object name is changed
 * @public
 */ class DeviceGPUObjectRenameEvent {
    /** The event name */ static NAME = 'gpuobject_rename';
    object;
    lastName;
    type = DeviceGPUObjectRenameEvent.NAME;
    constructor(obj, lastName){
        this.object = obj;
        this.lastName = lastName;
    }
}

const F16_BITMASK = 1;
const F32_BITMASK = 2;
const BOOL_BITMASK = 3;
const I8_BITMASK = 4;
const I16_BITMASK = 5;
const I32_BITMASK = 6;
const U8_BITMASK = 7;
const U16_BITMASK = 8;
const U32_BITMASK = 9;
const SCALAR_TYPE_BITMASK = 15;
const ROWS_BITMASK = 7;
const ROWS_BITSHIFT = 4;
const COLS_BITMASK = 7;
const COLS_BITSHIFT = 7;
const NORM_BITMASK = 1;
const NORM_BITSHIFT = 10;
function align(n, alignment) {
    return n + alignment - 1 & ~(alignment - 1);
}
function getAlignment(type) {
    if (type.isPrimitiveType()) {
        return type.isScalarType() ? 4 : 1 << Math.min(4, type.cols + 1);
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 1 : getAlignment(type.elementType);
    } else {
        let alignment = 0;
        for (const member of type.structMembers){
            alignment = Math.max(alignment, getAlignment(member.type));
        }
        return Math.max(alignment, 16);
    }
}
function getAlignmentPacked(type) {
    return 1;
}
function getSize(type) {
    if (type.isPrimitiveType()) {
        return type.isMatrixType() ? type.rows * getAlignment(PBPrimitiveTypeInfo.getCachedTypeInfo(type.resizeType(1, type.cols))) : 4 * type.cols;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 0 : type.dimension * align(getSize(type.elementType), getAlignment(type.elementType));
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else {
        let size = 0;
        let structAlignment = 0;
        for (const member of type.structMembers){
            const memberAlignment = getAlignment(member.type);
            size = align(size, memberAlignment);
            size += getSize(member.type);
            structAlignment = Math.max(structAlignment, memberAlignment);
        }
        return align(size, structAlignment);
    }
}
function getSizePacked(type) {
    if (type.isPrimitiveType()) {
        let scalarSize;
        switch(type.scalarType){
            case PBPrimitiveType.U8:
            case PBPrimitiveType.U8_NORM:
            case PBPrimitiveType.I8:
            case PBPrimitiveType.I8_NORM:
                scalarSize = 1;
                break;
            case PBPrimitiveType.F16:
            case PBPrimitiveType.I16:
            case PBPrimitiveType.I16_NORM:
            case PBPrimitiveType.U16:
            case PBPrimitiveType.U16_NORM:
                scalarSize = 2;
                break;
            default:
                scalarSize = 4;
                break;
        }
        return type.rows * type.cols * scalarSize;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? 0 : type.dimension * getSizePacked(type.elementType);
    } else if (type.isAtomicI32() || type.isAtomicU32()) {
        return 4;
    } else {
        let size = 0;
        for (const member of type.structMembers){
            size += getSizePacked(member.type);
        }
        return size;
    }
}
function makePrimitiveType(scalarTypeMask, rows, cols, norm) {
    return scalarTypeMask | rows << ROWS_BITSHIFT | cols << COLS_BITSHIFT | norm << NORM_BITSHIFT;
}
function typeToTypedArray(type) {
    if (type.isPrimitiveType()) {
        return type.scalarType;
    } else if (type.isArrayType()) {
        return type.elementType.isAnyType() ? null : typeToTypedArray(type.elementType);
    } else {
        return PBPrimitiveType.U8;
    }
}
var PBPrimitiveType;
(function(PBPrimitiveType) {
    PBPrimitiveType[PBPrimitiveType["NONE"] = 0] = "NONE";
    PBPrimitiveType[PBPrimitiveType["F16"] = makePrimitiveType(F16_BITMASK, 1, 1, 0)] = "F16";
    PBPrimitiveType[PBPrimitiveType["F16VEC2"] = makePrimitiveType(F16_BITMASK, 1, 2, 0)] = "F16VEC2";
    PBPrimitiveType[PBPrimitiveType["F16VEC3"] = makePrimitiveType(F16_BITMASK, 1, 3, 0)] = "F16VEC3";
    PBPrimitiveType[PBPrimitiveType["F16VEC4"] = makePrimitiveType(F16_BITMASK, 1, 4, 0)] = "F16VEC4";
    PBPrimitiveType[PBPrimitiveType["F32"] = makePrimitiveType(F32_BITMASK, 1, 1, 0)] = "F32";
    PBPrimitiveType[PBPrimitiveType["F32VEC2"] = makePrimitiveType(F32_BITMASK, 1, 2, 0)] = "F32VEC2";
    PBPrimitiveType[PBPrimitiveType["F32VEC3"] = makePrimitiveType(F32_BITMASK, 1, 3, 0)] = "F32VEC3";
    PBPrimitiveType[PBPrimitiveType["F32VEC4"] = makePrimitiveType(F32_BITMASK, 1, 4, 0)] = "F32VEC4";
    PBPrimitiveType[PBPrimitiveType["BOOL"] = makePrimitiveType(BOOL_BITMASK, 1, 1, 0)] = "BOOL";
    PBPrimitiveType[PBPrimitiveType["BVEC2"] = makePrimitiveType(BOOL_BITMASK, 1, 2, 0)] = "BVEC2";
    PBPrimitiveType[PBPrimitiveType["BVEC3"] = makePrimitiveType(BOOL_BITMASK, 1, 3, 0)] = "BVEC3";
    PBPrimitiveType[PBPrimitiveType["BVEC4"] = makePrimitiveType(BOOL_BITMASK, 1, 4, 0)] = "BVEC4";
    PBPrimitiveType[PBPrimitiveType["I8"] = makePrimitiveType(I8_BITMASK, 1, 1, 0)] = "I8";
    PBPrimitiveType[PBPrimitiveType["I8VEC2"] = makePrimitiveType(I8_BITMASK, 1, 2, 0)] = "I8VEC2";
    PBPrimitiveType[PBPrimitiveType["I8VEC3"] = makePrimitiveType(I8_BITMASK, 1, 3, 0)] = "I8VEC3";
    PBPrimitiveType[PBPrimitiveType["I8VEC4"] = makePrimitiveType(I8_BITMASK, 1, 4, 0)] = "I8VEC4";
    PBPrimitiveType[PBPrimitiveType["I8_NORM"] = makePrimitiveType(I8_BITMASK, 1, 1, 1)] = "I8_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC2_NORM"] = makePrimitiveType(I8_BITMASK, 1, 2, 1)] = "I8VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC3_NORM"] = makePrimitiveType(I8_BITMASK, 1, 3, 1)] = "I8VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I8VEC4_NORM"] = makePrimitiveType(I8_BITMASK, 1, 4, 1)] = "I8VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["I16"] = makePrimitiveType(I16_BITMASK, 1, 1, 0)] = "I16";
    PBPrimitiveType[PBPrimitiveType["I16VEC2"] = makePrimitiveType(I16_BITMASK, 1, 2, 0)] = "I16VEC2";
    PBPrimitiveType[PBPrimitiveType["I16VEC3"] = makePrimitiveType(I16_BITMASK, 1, 3, 0)] = "I16VEC3";
    PBPrimitiveType[PBPrimitiveType["I16VEC4"] = makePrimitiveType(I16_BITMASK, 1, 4, 0)] = "I16VEC4";
    PBPrimitiveType[PBPrimitiveType["I16_NORM"] = makePrimitiveType(I16_BITMASK, 1, 1, 1)] = "I16_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC2_NORM"] = makePrimitiveType(I16_BITMASK, 1, 2, 1)] = "I16VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC3_NORM"] = makePrimitiveType(I16_BITMASK, 1, 3, 1)] = "I16VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I16VEC4_NORM"] = makePrimitiveType(I16_BITMASK, 1, 4, 1)] = "I16VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["I32"] = makePrimitiveType(I32_BITMASK, 1, 1, 0)] = "I32";
    PBPrimitiveType[PBPrimitiveType["I32VEC2"] = makePrimitiveType(I32_BITMASK, 1, 2, 0)] = "I32VEC2";
    PBPrimitiveType[PBPrimitiveType["I32VEC3"] = makePrimitiveType(I32_BITMASK, 1, 3, 0)] = "I32VEC3";
    PBPrimitiveType[PBPrimitiveType["I32VEC4"] = makePrimitiveType(I32_BITMASK, 1, 4, 0)] = "I32VEC4";
    PBPrimitiveType[PBPrimitiveType["I32_NORM"] = makePrimitiveType(I32_BITMASK, 1, 1, 1)] = "I32_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC2_NORM"] = makePrimitiveType(I32_BITMASK, 1, 2, 1)] = "I32VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC3_NORM"] = makePrimitiveType(I32_BITMASK, 1, 3, 1)] = "I32VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["I32VEC4_NORM"] = makePrimitiveType(I32_BITMASK, 1, 4, 1)] = "I32VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U8"] = makePrimitiveType(U8_BITMASK, 1, 1, 0)] = "U8";
    PBPrimitiveType[PBPrimitiveType["U8VEC2"] = makePrimitiveType(U8_BITMASK, 1, 2, 0)] = "U8VEC2";
    PBPrimitiveType[PBPrimitiveType["U8VEC3"] = makePrimitiveType(U8_BITMASK, 1, 3, 0)] = "U8VEC3";
    PBPrimitiveType[PBPrimitiveType["U8VEC4"] = makePrimitiveType(U8_BITMASK, 1, 4, 0)] = "U8VEC4";
    PBPrimitiveType[PBPrimitiveType["U8_NORM"] = makePrimitiveType(U8_BITMASK, 1, 1, 1)] = "U8_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC2_NORM"] = makePrimitiveType(U8_BITMASK, 1, 2, 1)] = "U8VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC3_NORM"] = makePrimitiveType(U8_BITMASK, 1, 3, 1)] = "U8VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U8VEC4_NORM"] = makePrimitiveType(U8_BITMASK, 1, 4, 1)] = "U8VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U16"] = makePrimitiveType(U16_BITMASK, 1, 1, 0)] = "U16";
    PBPrimitiveType[PBPrimitiveType["U16VEC2"] = makePrimitiveType(U16_BITMASK, 1, 2, 0)] = "U16VEC2";
    PBPrimitiveType[PBPrimitiveType["U16VEC3"] = makePrimitiveType(U16_BITMASK, 1, 3, 0)] = "U16VEC3";
    PBPrimitiveType[PBPrimitiveType["U16VEC4"] = makePrimitiveType(U16_BITMASK, 1, 4, 0)] = "U16VEC4";
    PBPrimitiveType[PBPrimitiveType["U16_NORM"] = makePrimitiveType(U16_BITMASK, 1, 1, 1)] = "U16_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC2_NORM"] = makePrimitiveType(U16_BITMASK, 1, 2, 1)] = "U16VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC3_NORM"] = makePrimitiveType(U16_BITMASK, 1, 3, 1)] = "U16VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U16VEC4_NORM"] = makePrimitiveType(U16_BITMASK, 1, 4, 1)] = "U16VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["U32"] = makePrimitiveType(U32_BITMASK, 1, 1, 0)] = "U32";
    PBPrimitiveType[PBPrimitiveType["U32VEC2"] = makePrimitiveType(U32_BITMASK, 1, 2, 0)] = "U32VEC2";
    PBPrimitiveType[PBPrimitiveType["U32VEC3"] = makePrimitiveType(U32_BITMASK, 1, 3, 0)] = "U32VEC3";
    PBPrimitiveType[PBPrimitiveType["U32VEC4"] = makePrimitiveType(U32_BITMASK, 1, 4, 0)] = "U32VEC4";
    PBPrimitiveType[PBPrimitiveType["U32_NORM"] = makePrimitiveType(U32_BITMASK, 1, 1, 1)] = "U32_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC2_NORM"] = makePrimitiveType(U32_BITMASK, 1, 2, 1)] = "U32VEC2_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC3_NORM"] = makePrimitiveType(U32_BITMASK, 1, 3, 1)] = "U32VEC3_NORM";
    PBPrimitiveType[PBPrimitiveType["U32VEC4_NORM"] = makePrimitiveType(U32_BITMASK, 1, 4, 1)] = "U32VEC4_NORM";
    PBPrimitiveType[PBPrimitiveType["MAT2"] = makePrimitiveType(F32_BITMASK, 2, 2, 0)] = "MAT2";
    PBPrimitiveType[PBPrimitiveType["MAT2x3"] = makePrimitiveType(F32_BITMASK, 2, 3, 0)] = "MAT2x3";
    PBPrimitiveType[PBPrimitiveType["MAT2x4"] = makePrimitiveType(F32_BITMASK, 2, 4, 0)] = "MAT2x4";
    PBPrimitiveType[PBPrimitiveType["MAT3x2"] = makePrimitiveType(F32_BITMASK, 3, 2, 0)] = "MAT3x2";
    PBPrimitiveType[PBPrimitiveType["MAT3"] = makePrimitiveType(F32_BITMASK, 3, 3, 0)] = "MAT3";
    PBPrimitiveType[PBPrimitiveType["MAT3x4"] = makePrimitiveType(F32_BITMASK, 3, 4, 0)] = "MAT3x4";
    PBPrimitiveType[PBPrimitiveType["MAT4x2"] = makePrimitiveType(F32_BITMASK, 4, 2, 0)] = "MAT4x2";
    PBPrimitiveType[PBPrimitiveType["MAT4x3"] = makePrimitiveType(F32_BITMASK, 4, 3, 0)] = "MAT4x3";
    PBPrimitiveType[PBPrimitiveType["MAT4"] = makePrimitiveType(F32_BITMASK, 4, 4, 0)] = "MAT4";
})(PBPrimitiveType || (PBPrimitiveType = {}));
const primitiveTypeMapWebGL = {
    [PBPrimitiveType.F32]: 'float',
    [PBPrimitiveType.F32VEC2]: 'vec2',
    [PBPrimitiveType.F32VEC3]: 'vec3',
    [PBPrimitiveType.F32VEC4]: 'vec4',
    [PBPrimitiveType.BOOL]: 'bool',
    [PBPrimitiveType.BVEC2]: 'bvec2',
    [PBPrimitiveType.BVEC3]: 'bvec3',
    [PBPrimitiveType.BVEC4]: 'bvec4',
    [PBPrimitiveType.I32]: 'int',
    [PBPrimitiveType.I32VEC2]: 'ivec2',
    [PBPrimitiveType.I32VEC3]: 'ivec3',
    [PBPrimitiveType.I32VEC4]: 'ivec4',
    [PBPrimitiveType.U32]: 'uint',
    [PBPrimitiveType.U32VEC2]: 'uvec2',
    [PBPrimitiveType.U32VEC3]: 'uvec3',
    [PBPrimitiveType.U32VEC4]: 'uvec4',
    [PBPrimitiveType.MAT2]: 'mat2',
    [PBPrimitiveType.MAT2x3]: 'mat2x3',
    [PBPrimitiveType.MAT2x4]: 'mat2x4',
    [PBPrimitiveType.MAT3x2]: 'mat3x2',
    [PBPrimitiveType.MAT3]: 'mat3',
    [PBPrimitiveType.MAT3x4]: 'mat3x4',
    [PBPrimitiveType.MAT4x2]: 'mat4x2',
    [PBPrimitiveType.MAT4x3]: 'mat4x3',
    [PBPrimitiveType.MAT4]: 'mat4'
};
const primitiveTypeMapWGSL = {
    [PBPrimitiveType.F32]: 'f32',
    [PBPrimitiveType.F32VEC2]: 'vec2<f32>',
    [PBPrimitiveType.F32VEC3]: 'vec3<f32>',
    [PBPrimitiveType.F32VEC4]: 'vec4<f32>',
    [PBPrimitiveType.BOOL]: 'bool',
    [PBPrimitiveType.BVEC2]: 'vec2<bool>',
    [PBPrimitiveType.BVEC3]: 'vec3<bool>',
    [PBPrimitiveType.BVEC4]: 'vec4<bool>',
    [PBPrimitiveType.I32]: 'i32',
    [PBPrimitiveType.I32VEC2]: 'vec2<i32>',
    [PBPrimitiveType.I32VEC3]: 'vec3<i32>',
    [PBPrimitiveType.I32VEC4]: 'vec4<i32>',
    [PBPrimitiveType.U32]: 'u32',
    [PBPrimitiveType.U32VEC2]: 'vec2<u32>',
    [PBPrimitiveType.U32VEC3]: 'vec3<u32>',
    [PBPrimitiveType.U32VEC4]: 'vec4<u32>',
    [PBPrimitiveType.MAT2]: 'mat2x2<f32>',
    [PBPrimitiveType.MAT2x3]: 'mat2x3<f32>',
    [PBPrimitiveType.MAT2x4]: 'mat2x4<f32>',
    [PBPrimitiveType.MAT3x2]: 'mat3x2<f32>',
    [PBPrimitiveType.MAT3]: 'mat3x3<f32>',
    [PBPrimitiveType.MAT3x4]: 'mat3x4<f32>',
    [PBPrimitiveType.MAT4x2]: 'mat4x2<f32>',
    [PBPrimitiveType.MAT4x3]: 'mat4x3<f32>',
    [PBPrimitiveType.MAT4]: 'mat4x4<f32>'
};
const BITFLAG_1D = 1 << 0;
const BITFLAG_2D = 1 << 1;
const BITFLAG_3D = 1 << 2;
const BITFLAG_CUBE = 1 << 3;
const BITFLAG_ARRAY = 1 << 4;
const BITFLAG_MULTISAMPLED = 1 << 5;
const BITFLAG_STORAGE = 1 << 6;
const BITFLAG_DEPTH = 1 << 7;
const BITFLAG_FLOAT = 1 << 8;
const BITFLAG_INT = 1 << 9;
const BITFLAG_UINT = 1 << 10;
const BITFLAG_EXTERNAL = 1 << 11;
var PBTextureType;
(function(PBTextureType) {
    PBTextureType[PBTextureType["TEX_1D"] = BITFLAG_1D | BITFLAG_FLOAT] = "TEX_1D";
    PBTextureType[PBTextureType["ITEX_1D"] = BITFLAG_1D | BITFLAG_INT] = "ITEX_1D";
    PBTextureType[PBTextureType["UTEX_1D"] = BITFLAG_1D | BITFLAG_UINT] = "UTEX_1D";
    PBTextureType[PBTextureType["TEX_2D"] = BITFLAG_2D | BITFLAG_FLOAT] = "TEX_2D";
    PBTextureType[PBTextureType["ITEX_2D"] = BITFLAG_2D | BITFLAG_INT] = "ITEX_2D";
    PBTextureType[PBTextureType["UTEX_2D"] = BITFLAG_2D | BITFLAG_UINT] = "UTEX_2D";
    PBTextureType[PBTextureType["TEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_FLOAT | BITFLAG_ARRAY] = "TEX_2D_ARRAY";
    PBTextureType[PBTextureType["ITEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_INT | BITFLAG_ARRAY] = "ITEX_2D_ARRAY";
    PBTextureType[PBTextureType["UTEX_2D_ARRAY"] = BITFLAG_2D | BITFLAG_UINT | BITFLAG_ARRAY] = "UTEX_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_3D"] = BITFLAG_3D | BITFLAG_FLOAT] = "TEX_3D";
    PBTextureType[PBTextureType["ITEX_3D"] = BITFLAG_3D | BITFLAG_INT] = "ITEX_3D";
    PBTextureType[PBTextureType["UTEX_3D"] = BITFLAG_3D | BITFLAG_UINT] = "UTEX_3D";
    PBTextureType[PBTextureType["TEX_CUBE"] = BITFLAG_CUBE | BITFLAG_FLOAT] = "TEX_CUBE";
    PBTextureType[PBTextureType["ITEX_CUBE"] = BITFLAG_CUBE | BITFLAG_INT] = "ITEX_CUBE";
    PBTextureType[PBTextureType["UTEX_CUBE"] = BITFLAG_CUBE | BITFLAG_UINT] = "UTEX_CUBE";
    PBTextureType[PBTextureType["TEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_FLOAT | BITFLAG_ARRAY] = "TEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["ITEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_INT | BITFLAG_ARRAY] = "ITEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["UTEX_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_UINT | BITFLAG_ARRAY] = "UTEX_CUBE_ARRAY";
    PBTextureType[PBTextureType["TEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_FLOAT | BITFLAG_MULTISAMPLED] = "TEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["ITEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_INT | BITFLAG_MULTISAMPLED] = "ITEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["UTEX_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_UINT | BITFLAG_MULTISAMPLED] = "UTEX_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["TEX_STORAGE_1D"] = BITFLAG_1D | BITFLAG_STORAGE] = "TEX_STORAGE_1D";
    PBTextureType[PBTextureType["TEX_STORAGE_2D"] = BITFLAG_2D | BITFLAG_STORAGE] = "TEX_STORAGE_2D";
    PBTextureType[PBTextureType["TEX_STORAGE_2D_ARRAY"] = BITFLAG_2D | BITFLAG_ARRAY | BITFLAG_STORAGE] = "TEX_STORAGE_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_STORAGE_3D"] = BITFLAG_3D | BITFLAG_STORAGE] = "TEX_STORAGE_3D";
    PBTextureType[PBTextureType["TEX_DEPTH_2D"] = BITFLAG_2D | BITFLAG_DEPTH] = "TEX_DEPTH_2D";
    PBTextureType[PBTextureType["TEX_DEPTH_2D_ARRAY"] = BITFLAG_2D | BITFLAG_ARRAY | BITFLAG_DEPTH] = "TEX_DEPTH_2D_ARRAY";
    PBTextureType[PBTextureType["TEX_DEPTH_CUBE"] = BITFLAG_CUBE | BITFLAG_DEPTH] = "TEX_DEPTH_CUBE";
    PBTextureType[PBTextureType["TEX_DEPTH_CUBE_ARRAY"] = BITFLAG_CUBE | BITFLAG_ARRAY | BITFLAG_DEPTH] = "TEX_DEPTH_CUBE_ARRAY";
    PBTextureType[PBTextureType["TEX_DEPTH_MULTISAMPLED_2D"] = BITFLAG_2D | BITFLAG_MULTISAMPLED | BITFLAG_DEPTH] = "TEX_DEPTH_MULTISAMPLED_2D";
    PBTextureType[PBTextureType["TEX_EXTERNAL"] = BITFLAG_EXTERNAL] = "TEX_EXTERNAL";
})(PBTextureType || (PBTextureType = {}));
const textureTypeMapWebGL = {
    [PBTextureType.TEX_1D]: 'highp sampler2D',
    [PBTextureType.TEX_2D]: 'highp sampler2D',
    [PBTextureType.TEX_CUBE]: 'highp samplerCube',
    [PBTextureType.TEX_EXTERNAL]: 'highp sampler2D'
};
const textureTypeMapWebGL2 = {
    [PBTextureType.TEX_1D]: 'highp sampler2D',
    [PBTextureType.TEX_2D]: 'highp sampler2D',
    [PBTextureType.ITEX_1D]: 'highp isampler2D',
    [PBTextureType.ITEX_2D]: 'highp isampler2D',
    [PBTextureType.UTEX_1D]: 'highp usampler2D',
    [PBTextureType.UTEX_2D]: 'highp usampler2D',
    [PBTextureType.TEX_2D_ARRAY]: 'highp sampler2DArray',
    [PBTextureType.ITEX_2D_ARRAY]: 'highp isampler2DArray',
    [PBTextureType.UTEX_2D_ARRAY]: 'highp usampler2DArray',
    [PBTextureType.TEX_3D]: 'highp sampler3D',
    [PBTextureType.ITEX_3D]: 'highp isampler3D',
    [PBTextureType.UTEX_3D]: 'highp usampler3D',
    [PBTextureType.TEX_CUBE]: 'highp samplerCube',
    [PBTextureType.ITEX_CUBE]: 'highp isamplerCube',
    [PBTextureType.UTEX_CUBE]: 'highp usamplerCube',
    [PBTextureType.TEX_DEPTH_2D]: 'highp sampler2DShadow',
    [PBTextureType.TEX_DEPTH_2D_ARRAY]: 'highp sampler2DArrayShadow',
    [PBTextureType.TEX_DEPTH_CUBE]: 'highp samplerCubeShadow',
    [PBTextureType.TEX_EXTERNAL]: 'highp sampler2D'
};
const textureTypeMapWGSL = {
    [PBTextureType.TEX_1D]: 'texture_1d<f32>',
    [PBTextureType.ITEX_1D]: 'texture_1d<i32>',
    [PBTextureType.UTEX_1D]: 'texture_1d<u32>',
    [PBTextureType.TEX_2D]: 'texture_2d<f32>',
    [PBTextureType.ITEX_2D]: 'texture_2d<i32>',
    [PBTextureType.UTEX_2D]: 'texture_2d<u32>',
    [PBTextureType.TEX_2D_ARRAY]: 'texture_2d_array<f32>',
    [PBTextureType.ITEX_2D_ARRAY]: 'texture_2d_array<i32>',
    [PBTextureType.UTEX_2D_ARRAY]: 'texture_2d_array<u32>',
    [PBTextureType.TEX_3D]: 'texture_3d<f32>',
    [PBTextureType.ITEX_3D]: 'texture_3d<i32>',
    [PBTextureType.UTEX_3D]: 'texture_3d<u32>',
    [PBTextureType.TEX_CUBE]: 'texture_cube<f32>',
    [PBTextureType.ITEX_CUBE]: 'texture_cube<i32>',
    [PBTextureType.UTEX_CUBE]: 'texture_cube<u32>',
    [PBTextureType.TEX_CUBE_ARRAY]: 'texture_cube_array<f32>',
    [PBTextureType.ITEX_CUBE_ARRAY]: 'texture_cube_array<i32>',
    [PBTextureType.UTEX_CUBE_ARRAY]: 'texture_cube_array<u32>',
    [PBTextureType.TEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<f32>',
    [PBTextureType.ITEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<i32>',
    [PBTextureType.UTEX_MULTISAMPLED_2D]: 'texture_multisampled_2d<u32>',
    [PBTextureType.TEX_STORAGE_1D]: 'texture_storage_1d',
    [PBTextureType.TEX_STORAGE_2D]: 'texture_storage_2d',
    [PBTextureType.TEX_STORAGE_2D_ARRAY]: 'texture_storage_2d_array',
    [PBTextureType.TEX_STORAGE_3D]: 'texture_storage_3d',
    [PBTextureType.TEX_DEPTH_2D]: 'texture_depth_2d',
    [PBTextureType.TEX_DEPTH_2D_ARRAY]: 'texture_depth_2d_array',
    [PBTextureType.TEX_DEPTH_CUBE]: 'texture_depth_cube',
    [PBTextureType.TEX_DEPTH_CUBE_ARRAY]: 'texture_depth_cube_array',
    [PBTextureType.TEX_DEPTH_MULTISAMPLED_2D]: 'texture_depth_multisampled_2d',
    [PBTextureType.TEX_EXTERNAL]: 'texture_external'
};
const storageTexelFormatMap = {
    rgba8unorm: 'rgba8unorm',
    rgba8snorm: 'rgba8snorm',
    bgra8unorm: 'bgra8unorm',
    rgba8ui: 'rgba8uint',
    rgba8i: 'rgba8sint',
    rgba16ui: 'rgba16uint',
    rgba16i: 'rgba16sint',
    rgba16f: 'rgba16float',
    r32f: 'r32float',
    r32ui: 'r32uint',
    r32i: 'r32sint',
    rg32f: 'rg32float',
    rg32ui: 'rg32uint',
    rg32i: 'rg32sint',
    rgba32f: 'rgba32float',
    rgba32ui: 'rgba32uint',
    rgba32i: 'rgba32sint'
};
var PBSamplerAccessMode;
(function(PBSamplerAccessMode) {
    PBSamplerAccessMode[PBSamplerAccessMode["UNKNOWN"] = 0] = "UNKNOWN";
    PBSamplerAccessMode[PBSamplerAccessMode["SAMPLE"] = 1] = "SAMPLE";
    PBSamplerAccessMode[PBSamplerAccessMode["COMPARISON"] = 2] = "COMPARISON";
})(PBSamplerAccessMode || (PBSamplerAccessMode = {}));
var PBAddressSpace;
(function(PBAddressSpace) {
    PBAddressSpace["UNKNOWN"] = 'unknown';
    PBAddressSpace["FUNCTION"] = 'function';
    PBAddressSpace["PRIVATE"] = 'private';
    PBAddressSpace["WORKGROUP"] = 'workgroup';
    PBAddressSpace["UNIFORM"] = 'uniform';
    PBAddressSpace["STORAGE"] = 'storage';
})(PBAddressSpace || (PBAddressSpace = {}));
var PBTypeClass;
(function(PBTypeClass) {
    PBTypeClass[PBTypeClass["UNKNOWN"] = 0] = "UNKNOWN";
    PBTypeClass[PBTypeClass["PLAIN"] = 1] = "PLAIN";
    PBTypeClass[PBTypeClass["ARRAY"] = 2] = "ARRAY";
    PBTypeClass[PBTypeClass["POINTER"] = 3] = "POINTER";
    PBTypeClass[PBTypeClass["ATOMIC_I32"] = 4] = "ATOMIC_I32";
    PBTypeClass[PBTypeClass["ATOMIC_U32"] = 5] = "ATOMIC_U32";
    PBTypeClass[PBTypeClass["TEXTURE"] = 6] = "TEXTURE";
    PBTypeClass[PBTypeClass["SAMPLER"] = 7] = "SAMPLER";
    PBTypeClass[PBTypeClass["FUNCTION"] = 8] = "FUNCTION";
    PBTypeClass[PBTypeClass["VOID"] = 9] = "VOID";
    PBTypeClass[PBTypeClass["ANY"] = 10] = "ANY";
})(PBTypeClass || (PBTypeClass = {}));
/**
 * Abstract base class for any type
 * @public
 */ class PBTypeInfo {
    /** @internal */ cls;
    /** @internal */ detail;
    /** @internal */ id;
    /** @internal */ constructor(cls, detail){
        this.cls = cls;
        this.detail = detail;
        this.id = null;
    }
    /** Get unique id for this type */ get typeId() {
        if (!this.id) {
            this.id = this.genTypeId();
        }
        return this.id;
    }
    /** returns true if this is a void type */ isVoidType() {
        return false;
    }
    /** returns true if this is an any type */ isAnyType() {
        return false;
    }
    /** returns true if this is a primitive type */ isPrimitiveType() {
        return false;
    }
    /** Wether this type have atomic members */ haveAtomicMembers() {
        return false;
    }
    /** returns true if this is a struct type */ isStructType() {
        return false;
    }
    /** returns true if this is an array type */ isArrayType() {
        return false;
    }
    /** returns true if this is a pointer type */ isPointerType() {
        return false;
    }
    /** returns true if this is an atomic int type */ isAtomicI32() {
        return false;
    }
    /** returns true if this is an atomic uint type */ isAtomicU32() {
        return false;
    }
    /** returns true if this is a sampler type */ isSamplerType() {
        return false;
    }
    /** returns true if this is a texture type */ isTextureType() {
        return false;
    }
    /** @internal */ isHostSharable() {
        return false;
    }
    /** @internal */ isConstructible() {
        return false;
    }
    /** @internal */ isStorable() {
        return false;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        return [];
    }
    /**
   * Check whether a given type is compatible with this type
   * @param other - The type to be checked
   * @returns true if the given type is compatible with this type, othewise false
   */ isCompatibleType(other) {
        return other.typeId === this.typeId;
    }
}
/**
 * The void type info
 * @public
 */ class PBVoidTypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.VOID, null);
    }
    /** {@inheritDoc PBTypeInfo.isVoidType} */ isVoidType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        return 'void';
    }
    /** @internal */ genTypeId() {
        return 'void';
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
}
/**
 * The void type info
 * @public
 */ class PBAnyTypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ANY, null);
    }
    /** {@inheritDoc PBTypeInfo.isAnyType} */ isAnyType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        return 'any';
    }
    /** @internal */ genTypeId() {
        return 'any';
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** {@inheritDoc PBTypeInfo.isCompatibleType} */ isCompatibleType(other) {
        return true;
    }
}
/**
 * The primitive type info
 * @public
 */ class PBPrimitiveTypeInfo extends PBTypeInfo {
    /** @internal */ static cachedTypes = {};
    /** @internal */ static cachedCtorOverloads = {};
    constructor(type){
        super(PBTypeClass.PLAIN, {
            primitiveType: type
        });
    }
    /** Get or create a PBPrimitiveTypeInfo instance for a given prmitive type */ static getCachedTypeInfo(primitiveType) {
        let typeinfo = this.cachedTypes[primitiveType];
        if (!typeinfo) {
            typeinfo = new PBPrimitiveTypeInfo(primitiveType);
            this.cachedTypes[primitiveType] = typeinfo;
        }
        return typeinfo;
    }
    /** @internal */ static getCachedOverloads(deviceType, primitiveType) {
        let deviceOverloads = this.cachedCtorOverloads[deviceType];
        if (!deviceOverloads) {
            deviceOverloads = {};
            this.cachedCtorOverloads[deviceType] = deviceOverloads;
        }
        let result = deviceOverloads[primitiveType];
        if (!result) {
            const typeinfo = this.getCachedTypeInfo(primitiveType);
            const name = typeinfo.toTypeName(deviceType);
            result = [
                new PBFunctionTypeInfo(name, typeinfo, [])
            ];
            if (typeinfo.isScalarType()) {
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.F32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.I32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.U32)
                    }
                ]));
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    {
                        type: this.getCachedTypeInfo(PBPrimitiveType.BOOL)
                    }
                ]));
            } else if (typeinfo.isVectorType()) {
                const scalarTypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.scalarType)
                };
                const vec2TypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.resizeType(1, 2))
                };
                const vec3TypeInfo = {
                    type: this.getCachedTypeInfo(typeinfo.resizeType(1, 3))
                };
                result.push(new PBFunctionTypeInfo(name, typeinfo, [
                    scalarTypeInfo
                ]));
                switch(typeinfo.cols){
                    case 2:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec2
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec2
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec2
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec2
                            }
                        ]));
                        break;
                    case 3:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec3
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec3
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec3
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec3
                            }
                        ]));
                        break;
                    case 4:
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            scalarTypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec2TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            scalarTypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec2TypeInfo,
                            vec2TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            scalarTypeInfo,
                            vec3TypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            vec3TypeInfo,
                            scalarTypeInfo
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeF32Vec4
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeI32Vec4
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeU32Vec4
                            }
                        ]));
                        result.push(new PBFunctionTypeInfo(name, typeinfo, [
                            {
                                type: typeBVec4
                            }
                        ]));
                }
            } else if (typeinfo.isMatrixType()) {
                const colType = this.getCachedTypeInfo(typeinfo.resizeType(1, typeinfo.cols));
                result.push(new PBFunctionTypeInfo(name, typeinfo, Array.from({
                    length: typeinfo.rows
                }).map(()=>({
                        type: colType
                    }))));
                result.push(new PBFunctionTypeInfo(name, typeinfo, Array.from({
                    length: typeinfo.rows * typeinfo.cols
                }).map(()=>({
                        type: typeF32
                    }))));
            }
            deviceOverloads[primitiveType] = result;
        }
        return result;
    }
    /** Get the primitive type */ get primitiveType() {
        return this.detail.primitiveType;
    }
    /** Whether the type is signed or unsigned integer scalar or vector */ isInteger() {
        const st = this.primitiveType & SCALAR_TYPE_BITMASK;
        return st === I8_BITMASK || st === U8_BITMASK || st === I16_BITMASK || st === U16_BITMASK || st === I32_BITMASK || st === U32_BITMASK;
    }
    /** Get the scalar type */ get scalarType() {
        return this.resizeType(1, 1);
    }
    /** Get number of rows */ get rows() {
        return this.primitiveType >> ROWS_BITSHIFT & ROWS_BITMASK;
    }
    /** Get number of columns */ get cols() {
        return this.primitiveType >> COLS_BITSHIFT & COLS_BITMASK;
    }
    /** Get if this is a normalized primitive type */ get normalized() {
        return !!(this.primitiveType >> NORM_BITSHIFT & NORM_BITMASK);
    }
    /** @internal */ getLayoutAlignment(layout) {
        return layout === 'packed' ? 1 : this.isScalarType() ? 4 : 1 << Math.min(4, this.cols + 1);
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        let scalarSize;
        switch(this.scalarType){
            case PBPrimitiveType.BOOL:
            case PBPrimitiveType.I32:
            case PBPrimitiveType.I32_NORM:
            case PBPrimitiveType.U32:
            case PBPrimitiveType.U32_NORM:
            case PBPrimitiveType.F32:
                scalarSize = 4;
                break;
            case PBPrimitiveType.F16:
            case PBPrimitiveType.I16:
            case PBPrimitiveType.I16_NORM:
            case PBPrimitiveType.U16:
            case PBPrimitiveType.U16_NORM:
                scalarSize = 2;
                break;
            default:
                scalarSize = 1;
                break;
        }
        return scalarSize * this.cols * this.rows;
    }
    /**
   * Creates a new primitive type info by changing row and column of this type
   * @param rows - The new value of row
   * @param cols - The new value of column
   * @returns The new primitive type
   */ resizeType(rows, cols) {
        return makePrimitiveType(this.primitiveType & SCALAR_TYPE_BITMASK, rows, cols, this.normalized ? 1 : 0);
    }
    /** Returns true if this is a scalar type */ isScalarType() {
        return this.rows === 1 && this.cols === 1;
    }
    /** Returns true if this is a vector type */ isVectorType() {
        return this.rows === 1 && this.cols > 1;
    }
    /** Returns true if this is a matrix type */ isMatrixType() {
        return this.rows > 1 && this.cols > 1;
    }
    /** {@inheritDoc PBTypeInfo.isPrimitiveType} */ isPrimitiveType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.scalarType !== PBPrimitiveType.BOOL;
    }
    /** @internal */ isConstructible() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        return PBPrimitiveTypeInfo.getCachedOverloads(deviceType, this.primitiveType);
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = primitiveTypeMapWGSL[this.primitiveType];
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            const typename = primitiveTypeMapWebGL[this.primitiveType];
            return varName ? `${typename} ${varName}` : typename;
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `PRIM:${this.primitiveType}`;
    }
}
/**
 * The struct type info
 * @public
 */ class PBStructTypeInfo extends PBTypeInfo {
    constructor(name, layout, members){
        super(PBTypeClass.PLAIN, {
            layout: layout || 'default',
            structName: name,
            structMembers: members.map((val)=>{
                const defaultAlignment = getAlignment(val.type);
                const defaultSize = getSize(val.type);
                return {
                    name: val.name,
                    type: val.type,
                    alignment: defaultAlignment,
                    size: defaultSize,
                    defaultAlignment: defaultAlignment,
                    defaultSize: defaultSize
                };
            })
        });
        if (this.layout === 'std140') {
            this.calcAlignmentAndSizeSTD140();
        } else if (this.layout === 'std430') {
            this.calcAlignmentAndSizePacked();
        }
    }
    /** Get the layout type */ get layout() {
        return this.detail.layout;
    }
    /** Get name of the struct type */ get structName() {
        return this.detail.structName;
    }
    set structName(val) {
        this.detail.structName = val;
    }
    /** Get member types of the struct type */ get structMembers() {
        return this.detail.structMembers;
    }
    /** Whether this struct has atomic members */ haveAtomicMembers() {
        for (const member of this.structMembers){
            if (member.type.isStructType() && member.type.haveAtomicMembers()) {
                return true;
            } else if (member.type.isArrayType() && member.type.haveAtomicMembers()) {
                return true;
            } else {
                return member.type.isAtomicI32() || member.type.isAtomicU32();
            }
        }
    }
    /**
   * Creates a new struct type by extending this type
   * @param name - Name of the new struct type
   * @param members - additional struct members
   * @returns The new struct type
   */ extends(name, members) {
        const oldMembers = this.structMembers.map((member)=>({
                name: member.name,
                type: member.type
            }));
        return new PBStructTypeInfo(name, this.layout, [
            ...oldMembers,
            ...members
        ]);
    }
    /** {@inheritDoc PBTypeInfo.isStructType} */ isStructType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.detail.structMembers.every((val)=>val.type.isHostSharable());
    }
    /** @internal */ isConstructible() {
        return this.detail.structMembers.every((val)=>val.type.isConstructible());
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads() {
        const result = [
            new PBFunctionTypeInfo(this.structName, this, [])
        ];
        if (this.isConstructible()) {
            result.push(new PBFunctionTypeInfo(this.structName, this, this.structMembers.map((val)=>({
                    type: val.type
                }))));
        }
        return result;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            return varName ? `${varName}: ${this.structName}` : this.structName;
        } else {
            return varName ? `${this.structName} ${varName}` : this.structName;
        }
    }
    /** @internal */ getLayoutAlignment(layout) {
        if (layout === 'packed') {
            return 1;
        }
        let alignment = 0;
        for (const member of this.structMembers){
            alignment = Math.max(alignment, member.type.getLayoutAlignment(layout));
        }
        if (layout === 'std140') {
            alignment = align(alignment, 16);
        }
        return alignment;
    }
    /** @internal */ getLayoutSize(layout) {
        let size = 0;
        let structAlignment = 0;
        for (const member of this.structMembers){
            const memberAlignment = member.type.getLayoutAlignment(layout);
            size = align(size, memberAlignment);
            size += member.type.getLayoutSize(layout);
            structAlignment = Math.max(structAlignment, memberAlignment);
        }
        return align(size, structAlignment);
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset, layout) {
        const bufferLayout = {
            byteSize: 0,
            entries: []
        };
        const start = offset;
        for (const member of this.structMembers){
            offset = align(offset, member.type.getLayoutAlignment(layout));
            const size = member.type.getLayoutSize(layout);
            bufferLayout.entries.push({
                name: member.name,
                offset: offset,
                byteSize: size,
                type: typeToTypedArray(member.type),
                subLayout: member.type.isStructType() ? member.type.toBufferLayout(offset, layout) : null,
                arraySize: member.type.isArrayType() ? member.type.dimension : 0
            });
            offset += size;
        }
        bufferLayout.byteSize = layout === 'std140' ? align(offset - start, 16) : offset - start;
        return bufferLayout;
    }
    /** @internal */ clone(newName) {
        return new PBStructTypeInfo(newName || this.structName, this.layout, this.structMembers);
    }
    /** @internal */ reset(name, layout, members) {
        this.detail = {
            layout: layout || 'default',
            structName: name,
            structMembers: members.map((val)=>{
                const defaultAlignment = getAlignment(val.type);
                const defaultSize = getSize(val.type);
                return {
                    name: val.name,
                    type: val.type,
                    alignment: defaultAlignment,
                    size: defaultSize,
                    defaultAlignment: defaultAlignment,
                    defaultSize: defaultSize
                };
            })
        };
        if (this.layout === 'std140') {
            this.calcAlignmentAndSizeSTD140();
        } else if (this.layout === 'std430') {
            this.calcAlignmentAndSizePacked();
        }
        this.id = null;
    }
    /** @internal */ genTypeId() {
        return `STRUCT:${this.structName}:${this.layout}:${this.structMembers.map((val)=>`${val.name}(${val.type.typeId})`).join(':')}`;
    }
    /** @internal */ calcAlignmentAndSizeSTD140() {
        for (const member of this.structMembers){
            if (member.type.isPrimitiveType()) {
                if (member.type.isMatrixType() && member.type.cols === 2) {
                    throw new Error(`matrix${member.type.rows}x${member.type.cols} can not be used in std140 layout`);
                }
            } else if (member.type.isArrayType() && (member.type.elementType.isAnyType() || getAlignment(member.type.elementType) !== 16)) {
                throw new Error('array element must be 16 bytes aligned in std140 layout');
            } else if (member.type.isStructType()) {
                member.alignment = 16;
                member.size = align(member.defaultSize, 16);
            }
        }
    }
    /** @internal */ calcAlignmentAndSizePacked() {
        for (const member of this.structMembers){
            member.alignment = getAlignmentPacked(member.type);
            member.size = getSizePacked(member.type);
        }
    }
}
/**
 * The array type info
 * @public
 */ class PBArrayTypeInfo extends PBTypeInfo {
    constructor(elementType, dimension){
        super(PBTypeClass.ARRAY, {
            elementType: elementType,
            dimension: Number(dimension) || 0
        });
    }
    /** Get the element type */ get elementType() {
        return this.detail.elementType;
    }
    /** Get dimension of the array type */ get dimension() {
        return this.detail.dimension;
    }
    /** Wether array have atomic members */ haveAtomicMembers() {
        if (this.elementType.isStructType() || this.elementType.isArrayType()) {
            return this.elementType.haveAtomicMembers();
        } else {
            return this.elementType.isAtomicI32() || this.elementType.isAtomicU32();
        }
    }
    /** {@inheritDoc PBTypeInfo.isArrayType} */ isArrayType() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return this.detail.elementType.isHostSharable();
    }
    /** @internal */ isConstructible() {
        return this.dimension && this.detail.elementType.isConstructible();
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ getConstructorOverloads(deviceType) {
        const name = this.toTypeName(deviceType);
        const result = [
            new PBFunctionTypeInfo(name, this, [])
        ];
        if (deviceType !== 'webgl' && this.isConstructible()) {
            result.push(new PBFunctionTypeInfo(name, this, Array.from({
                length: this.dimension
            }).map(()=>({
                    type: this.elementType
                }))));
        }
        return result;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const elementTypeName = this.elementType.toTypeName(deviceType);
            const typename = `array<${elementTypeName}${this.dimension ? ', ' + this.dimension : ''}>`;
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            console.assert(!!this.dimension, 'runtime-sized array not supported for webgl');
            console.assert(!this.elementType.isArrayType(), 'multi-dimensional arrays not supported for webgl');
            const elementTypeName = this.elementType.toTypeName(deviceType, varName);
            return `${elementTypeName}[${this.dimension}]`;
        }
    }
    /** @internal */ getLayoutAlignment(layout) {
        return layout === 'packed' || this.elementType.isAnyType() ? 1 : layout === 'std430' ? this.elementType.getLayoutAlignment(layout) : align(this.elementType.getLayoutAlignment(layout), 16);
    }
    /** @internal */ getLayoutSize(layout) {
        const elementAlignment = this.elementType.isAnyType() ? 1 : this.elementType.getLayoutAlignment(layout);
        if (layout === 'std140' && !!(elementAlignment & 15)) {
            // array element stride of std140 layout must be multiple of 16
            throw new Error('Error: array element stride of std140 must be multiple of 16');
        }
        return this.elementType.isAnyType() ? 0 : this.dimension * align(this.elementType.getLayoutSize(layout), elementAlignment);
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    isCompatibleType(other) {
        if (!other.isArrayType()) {
            return false;
        }
        if (this.dimension !== 0 && other.dimension !== this.dimension) {
            return false;
        }
        return this.elementType.isCompatibleType(other.elementType);
    }
    /** @internal */ genTypeId() {
        return `ARRAY:(${this.elementType.typeId})[${this.dimension}]`;
    }
}
/**
 * The pointer type info
 * @public
 */ class PBPointerTypeInfo extends PBTypeInfo {
    /** @internal */ writable;
    constructor(pointerType, addressSpace){
        super(PBTypeClass.POINTER, {
            pointerType,
            addressSpace
        });
        console.assert(pointerType.isStorable(), 'the pointee type must be storable');
        this.writable = false;
    }
    /** Get type of the pointer */ get pointerType() {
        return this.detail.pointerType;
    }
    /** Get address space of the pointer */ get addressSpace() {
        return this.detail.addressSpace;
    }
    set addressSpace(val) {
        if (this.detail.addressSpace !== val) {
            this.detail.addressSpace = val;
            this.id = null;
        }
    }
    /** {@inheritDoc PBTypeInfo.haveAtomicMembers} */ haveAtomicMembers() {
        return this.pointerType.haveAtomicMembers();
    }
    /** {@inheritDoc PBTypeInfo.isPointerType} */ isPointerType() {
        return true;
    }
    /** @internal */ toTypeName(device, varName) {
        if (device === 'webgpu') {
            const addressSpace = this.addressSpace === PBAddressSpace.UNKNOWN ? PBAddressSpace.FUNCTION : this.addressSpace;
            /*
      const mode = addressSpace === PBAddressSpace.UNIFORM || (addressSpace === PBAddressSpace.STORAGE && !this.writable) ? 'read' : 'read_write'
      const typename = `ptr<${addressSpace}, ${this.pointerType.toTypeName(device)}, ${mode}>`;
      */ /* WGSL spec:
        When writing a variable declaration or a pointer type in WGSL source:
        For the storage address space, the access mode is optional, and defaults to read.
        For other address spaces, the access mode must not be written.
      */ const mode = addressSpace === PBAddressSpace.STORAGE && this.writable ? ', read_write' : '';
            const typename = `ptr<${addressSpace}, ${this.pointerType.toTypeName(device)} ${mode}>`;
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('pointer type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `PTR:(${this.pointerType.typeId})`;
    }
}
/**
 * The atomic int type info
 * @public
 */ class PBAtomicI32TypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ATOMIC_I32, null);
    }
    /** {@inheritDoc PBTypeInfo.isPointerType} */ haveAtomicMembers() {
        return true;
    }
    /** @internal */ isAtomicI32() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = 'atomic<i32>';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('atomic type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ getLayoutAlignment(layout) {
        return 4;
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        return 4;
    }
    /** @internal */ genTypeId() {
        return `ATOMICI32`;
    }
}
/**
 * The atomic int type info
 * @public
 */ class PBAtomicU32TypeInfo extends PBTypeInfo {
    constructor(){
        super(PBTypeClass.ATOMIC_U32, null);
    }
    /** {@inheritDoc PBTypeInfo.isPointerType} */ haveAtomicMembers() {
        return true;
    }
    /** @internal */ isAtomicU32() {
        return true;
    }
    /** @internal */ isHostSharable() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = 'atomic<u32>';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('atomic type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ getLayoutAlignment(layout) {
        return 4;
    }
    /** @internal */ getLayoutSize() {
        return this.getSize();
    }
    /** @internal */ getSize() {
        return 4;
    }
    /** @internal */ genTypeId() {
        return `ATOMICU32`;
    }
}
/**
 * The sampler type info
 * @public
 */ class PBSamplerTypeInfo extends PBTypeInfo {
    constructor(accessMode){
        super(PBTypeClass.SAMPLER, {
            accessMode: accessMode
        });
    }
    /** Get the access mode */ get accessMode() {
        return this.detail.accessMode;
    }
    /** @internal */ isSamplerType() {
        return true;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            const typename = this.accessMode === PBSamplerAccessMode.SAMPLE ? 'sampler' : 'sampler_comparison';
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            throw new Error('sampler type not supported for webgl');
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `SAMPLER:${this.accessMode}`;
    }
}
/**
 * The texture type info
 * @public
 */ class PBTextureTypeInfo extends PBTypeInfo {
    constructor(textureType, texelFormat, readable, writable){
        super(PBTypeClass.TEXTURE, {
            textureType: textureType,
            readable,
            writable,
            storageTexelFormat: texelFormat || null
        });
        console.assert(!!textureTypeMapWGSL[textureType], 'unsupported texture type');
        console.assert(!(textureType & BITFLAG_STORAGE) || !!storageTexelFormatMap[texelFormat], 'invalid texel format for storage texture');
    }
    /** Get the texture type */ get textureType() {
        return this.detail.textureType;
    }
    /** Get texture format if this is a storage texture */ get storageTexelFormat() {
        return this.detail.storageTexelFormat;
    }
    /** Returns true if this is a readable storage texture type */ get readable() {
        return this.detail.readable;
    }
    set readable(val) {
        this.detail.readable = !!val;
    }
    /** Returns true if this is a writable storage texture type */ get writable() {
        return this.detail.writable;
    }
    set writable(val) {
        this.detail.writable = !!val;
    }
    /** @internal */ isStorable() {
        return true;
    }
    /** @internal */ is1DTexture() {
        return !!(this.detail.textureType & BITFLAG_1D);
    }
    /** Returns true if this is a 2D texture type */ is2DTexture() {
        return !!(this.detail.textureType & BITFLAG_2D);
    }
    /** Returns true if this is a 3D texture type */ is3DTexture() {
        return !!(this.detail.textureType & BITFLAG_3D);
    }
    /** Returns true if this is a cube texture type */ isCubeTexture() {
        return !!(this.detail.textureType & BITFLAG_CUBE);
    }
    /** Returns true if this is an array texture type */ isArrayTexture() {
        return !!(this.detail.textureType & BITFLAG_ARRAY);
    }
    /** Returns true if this is a storage texture type */ isStorageTexture() {
        return !!(this.detail.textureType & BITFLAG_STORAGE);
    }
    /** Return s true if this is a depth texture type */ isDepthTexture() {
        return !!(this.detail.textureType & BITFLAG_DEPTH);
    }
    /** Returns true if this is a multisampled texture type */ isMultisampledTexture() {
        return !!(this.detail.textureType & BITFLAG_MULTISAMPLED);
    }
    /** Returns true if this is an external texture type */ isExternalTexture() {
        return !!(this.detail.textureType & BITFLAG_EXTERNAL);
    }
    /** Returns true if the texture format is of type integer  */ isIntTexture() {
        return !!(this.detail.textureType & BITFLAG_INT);
    }
    /** Returns true if the texture format is of type unsigned integer  */ isUIntTexture() {
        return !!(this.detail.textureType & BITFLAG_UINT);
    }
    /** @internal */ isTextureType() {
        return true;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        if (deviceType === 'webgpu') {
            let typename = textureTypeMapWGSL[this.textureType];
            if (this.isStorageTexture()) {
                const storageTexelFormat = storageTexelFormatMap[this.storageTexelFormat];
                // storage textures currently only support 'write' access control
                const accessMode = this.writable ? this.readable ? 'read_write' : 'write' : 'read'; // this.readable ? (this.writable ? 'read_write' : 'read') : 'write';
                typename = `${typename}<${storageTexelFormat}, ${accessMode}>`;
            }
            return varName ? `${varName}: ${typename}` : typename;
        } else {
            const typename = (deviceType === 'webgl' ? textureTypeMapWebGL : textureTypeMapWebGL2)[this.textureType];
            console.assert(!!typename, 'unsupported texture type');
            return varName ? `${typename} ${varName}` : typename;
        }
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ genTypeId() {
        return `TEXTURE:${this.textureType}`;
    }
}
/**
 * The function type info
 * @public
 */ class PBFunctionTypeInfo extends PBTypeInfo {
    constructor(name, returnType, argTypes){
        super(PBTypeClass.FUNCTION, {
            name,
            returnType,
            argTypes
        });
    }
    /** Get name of the function */ get name() {
        return this.detail.name;
    }
    /** Get return type of the function */ get returnType() {
        return this.detail.returnType;
    }
    /** Get all the argument types for this function */ get argTypes() {
        return this.detail.argTypes;
    }
    /** Get hash for parameter types */ get argHash() {
        return this.argTypes.map((val)=>val.type.typeId).join(',');
    }
    /** @internal */ genTypeId() {
        return `fn(${this.argHash}):${this.returnType.typeId}`;
    }
    /** {@inheritDoc PBTypeInfo.toBufferLayout} */ toBufferLayout(offset) {
        return null;
    }
    /** @internal */ toTypeName(deviceType, varName) {
        throw new Error('not supported');
    }
}
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F16VEC4);
/** @internal */ const typeF32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32);
/** @internal */ const typeF32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC2);
/** @internal */ const typeF32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC3);
/** @internal */ const typeF32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.F32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I8VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I16VEC4_NORM);
/** @internal */ const typeAtomicI32 = new PBAtomicI32TypeInfo();
/** @internal */ const typeAtomicU32 = new PBAtomicU32TypeInfo();
/** @internal */ const typeI32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
/** @internal */ const typeI32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2);
/** @internal */ const typeI32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3);
/** @internal */ const typeI32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.I32VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U8VEC4_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC3);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16VEC4_NORM);
/** @internal */ const typeU32$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
/** @internal */ const typeU32Vec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2);
/** @internal */ const typeU32Vec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3);
/** @internal */ const typeU32Vec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC2_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC3_NORM);
/** @internal */ PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32VEC4_NORM);
/** @internal */ const typeBool = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BOOL);
/** @internal */ const typeBVec2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC2);
/** @internal */ const typeBVec3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC3);
/** @internal */ const typeBVec4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.BVEC4);
/** @internal */ const typeMat2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2);
/** @internal */ const typeMat2x3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2x3);
/** @internal */ const typeMat2x4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT2x4);
/** @internal */ const typeMat3x2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3x2);
/** @internal */ const typeMat3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3);
/** @internal */ const typeMat3x4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT3x4);
/** @internal */ const typeMat4x2 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4x2);
/** @internal */ const typeMat4x3 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4x3);
/** @internal */ const typeMat4 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.MAT4);
/** @internal */ const typeTex1D = new PBTextureTypeInfo(PBTextureType.TEX_1D);
/** @internal */ const typeITex1D = new PBTextureTypeInfo(PBTextureType.ITEX_1D);
/** @internal */ const typeUTex1D = new PBTextureTypeInfo(PBTextureType.UTEX_1D);
/** @internal */ const typeTex2D = new PBTextureTypeInfo(PBTextureType.TEX_2D);
/** @internal */ const typeITex2D = new PBTextureTypeInfo(PBTextureType.ITEX_2D);
/** @internal */ const typeUTex2D = new PBTextureTypeInfo(PBTextureType.UTEX_2D);
/** @internal */ const typeTex2DArray = new PBTextureTypeInfo(PBTextureType.TEX_2D_ARRAY);
/** @internal */ const typeITex2DArray = new PBTextureTypeInfo(PBTextureType.ITEX_2D_ARRAY);
/** @internal */ const typeUTex2DArray = new PBTextureTypeInfo(PBTextureType.UTEX_2D_ARRAY);
/** @internal */ const typeTex3D = new PBTextureTypeInfo(PBTextureType.TEX_3D);
/** @internal */ const typeITex3D = new PBTextureTypeInfo(PBTextureType.ITEX_3D);
/** @internal */ const typeUTex3D = new PBTextureTypeInfo(PBTextureType.UTEX_3D);
/** @internal */ const typeTexCube = new PBTextureTypeInfo(PBTextureType.TEX_CUBE);
/** @internal */ const typeITexCube = new PBTextureTypeInfo(PBTextureType.ITEX_CUBE);
/** @internal */ const typeUTexCube = new PBTextureTypeInfo(PBTextureType.UTEX_CUBE);
/** @internal */ const typeTexExternal = new PBTextureTypeInfo(PBTextureType.TEX_EXTERNAL);
/** @internal */ const typeTexCubeArray = new PBTextureTypeInfo(PBTextureType.TEX_CUBE_ARRAY);
/** @internal */ const typeITexCubeArray = new PBTextureTypeInfo(PBTextureType.ITEX_CUBE_ARRAY);
/** @internal */ const typeUTexCubeArray = new PBTextureTypeInfo(PBTextureType.UTEX_CUBE_ARRAY);
/** @internal */ const typeTexMultisampled2D = new PBTextureTypeInfo(PBTextureType.TEX_MULTISAMPLED_2D);
/** @internal */ const typeITexMultisampled2D = new PBTextureTypeInfo(PBTextureType.ITEX_MULTISAMPLED_2D);
/** @internal */ const typeUTexMultisampled2D = new PBTextureTypeInfo(PBTextureType.UTEX_MULTISAMPLED_2D);
/** @internal */ const typeTexStorage1D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8unorm');
/** @internal */ const typeTexStorage1D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8snorm');
/** @internal */ const typeTexStorage1D_bgra8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8unorm');
/** @internal */ const typeTexStorage1D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8ui');
/** @internal */ const typeTexStorage1D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba8i');
/** @internal */ const typeTexStorage1D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16ui');
/** @internal */ const typeTexStorage1D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16i');
/** @internal */ const typeTexStorage1D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba16f');
/** @internal */ const typeTexStorage1D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32ui');
/** @internal */ const typeTexStorage1D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32i');
/** @internal */ const typeTexStorage1D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rgba32f');
/** @internal */ const typeTexStorage1D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32ui');
/** @internal */ const typeTexStorage1D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32i');
/** @internal */ const typeTexStorage1D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'rg32f');
/** @internal */ const typeTexStorage1D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32ui');
/** @internal */ const typeTexStorage1D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32i');
/** @internal */ const typeTexStorage1D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_1D, 'r32f');
/** @internal */ const typeTexStorage2D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8unorm');
/** @internal */ const typeTexStorage2D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8snorm');
/** @internal */ const typeTexStorage2D_bgra8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'bgra8unorm');
/** @internal */ const typeTexStorage2D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8ui');
/** @internal */ const typeTexStorage2D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba8i');
/** @internal */ const typeTexStorage2D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16ui');
/** @internal */ const typeTexStorage2D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16i');
/** @internal */ const typeTexStorage2D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba16f');
/** @internal */ const typeTexStorage2D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32ui');
/** @internal */ const typeTexStorage2D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32i');
/** @internal */ const typeTexStorage2D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rgba32f');
/** @internal */ const typeTexStorage2D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32ui');
/** @internal */ const typeTexStorage2D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32i');
/** @internal */ const typeTexStorage2D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'rg32f');
/** @internal */ const typeTexStorage2D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32ui');
/** @internal */ const typeTexStorage2D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32i');
/** @internal */ const typeTexStorage2D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D, 'r32f');
/** @internal */ const typeTexStorage2DArray_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8unorm');
/** @internal */ const typeTexStorage2DArray_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8snorm');
/** @internal */ new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'bgra8unorm');
/** @internal */ const typeTexStorage2DArray_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8ui');
/** @internal */ const typeTexStorage2DArray_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba8i');
/** @internal */ const typeTexStorage2DArray_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16ui');
/** @internal */ const typeTexStorage2DArray_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16i');
/** @internal */ const typeTexStorage2DArray_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba16f');
/** @internal */ const typeTexStorage2DArray_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32ui');
/** @internal */ const typeTexStorage2DArray_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32i');
/** @internal */ const typeTexStorage2DArray_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rgba32f');
/** @internal */ const typeTexStorage2DArray_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32ui');
/** @internal */ const typeTexStorage2DArray_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32i');
/** @internal */ const typeTexStorage2DArray_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'rg32f');
/** @internal */ const typeTexStorage2DArray_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32ui');
/** @internal */ const typeTexStorage2DArray_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32i');
/** @internal */ const typeTexStorage2DArray_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_2D_ARRAY, 'r32f');
/** @internal */ const typeTexStorage3D_rgba8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8unorm');
/** @internal */ const typeTexStorage3D_rgba8snorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8snorm');
/** @internal */ const typeTexStorage3D_bgra8unorm = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'bgra8unorm');
/** @internal */ const typeTexStorage3D_rgba8uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8ui');
/** @internal */ const typeTexStorage3D_rgba8sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba8i');
/** @internal */ const typeTexStorage3D_rgba16uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16ui');
/** @internal */ const typeTexStorage3D_rgba16sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16i');
/** @internal */ const typeTexStorage3D_rgba16float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba16f');
/** @internal */ const typeTexStorage3D_rgba32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32ui');
/** @internal */ const typeTexStorage3D_rgba32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32i');
/** @internal */ const typeTexStorage3D_rgba32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rgba32f');
/** @internal */ const typeTexStorage3D_rg32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32ui');
/** @internal */ const typeTexStorage3D_rg32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32i');
/** @internal */ const typeTexStorage3D_rg32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'rg32f');
/** @internal */ const typeTexStorage3D_r32uint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32ui');
/** @internal */ const typeTexStorage3D_r32sint = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32i');
/** @internal */ const typeTexStorage3D_r32float = new PBTextureTypeInfo(PBTextureType.TEX_STORAGE_3D, 'r32f');
/** @internal */ const typeTexDepth2D = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_2D);
/** @internal */ const typeTexDepth2DArray = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_2D_ARRAY);
/** @internal */ const typeTexDepthCube = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_CUBE);
/** @internal */ const typeTexDepthCubeArray = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_CUBE_ARRAY);
/** @internal */ const typeTexDepthMultisampled2D = new PBTextureTypeInfo(PBTextureType.TEX_DEPTH_MULTISAMPLED_2D);
/** @internal */ const typeSampler = new PBSamplerTypeInfo(PBSamplerAccessMode.SAMPLE);
/** @internal */ const typeSamplerComparison = new PBSamplerTypeInfo(PBSamplerAccessMode.COMPARISON);
/** @internal */ const typeVoid = new PBVoidTypeInfo();
/** @internal */ new PBAnyTypeInfo();
/** @internal */ const typeFrexpResult = new PBStructTypeInfo('FrexpResult', 'default', [
    {
        name: 'sig',
        type: typeF32
    },
    {
        name: 'exp',
        type: typeI32
    }
]);
/** @internal */ const typeFrexpResultVec2 = new PBStructTypeInfo('FrexpResultVec2', 'default', [
    {
        name: 'sig',
        type: typeF32Vec2
    },
    {
        name: 'exp',
        type: typeI32Vec2
    }
]);
/** @internal */ const typeFrexpResultVec3 = new PBStructTypeInfo('FrexpResultVec3', 'default', [
    {
        name: 'sig',
        type: typeF32Vec3
    },
    {
        name: 'exp',
        type: typeI32Vec3
    }
]);
/** @internal */ const typeFrexpResultVec4 = new PBStructTypeInfo('FrexpResultVec4', 'default', [
    {
        name: 'sig',
        type: typeF32Vec4
    },
    {
        name: 'exp',
        type: typeI32Vec4
    }
]);

/** @internal */ const MAX_VERTEX_ATTRIBUTES = 16;
/** @internal */ const MAX_BINDING_GROUPS = 4;
/** @internal */ const VERTEX_ATTRIB_POSITION = 0;
/** @internal */ const VERTEX_ATTRIB_NORMAL = 1;
/** @internal */ const VERTEX_ATTRIB_DIFFUSE = 2;
/** @internal */ const VERTEX_ATTRIB_TANGENT = 3;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD0 = 4;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD1 = 5;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD2 = 6;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD3 = 7;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD4 = 8;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD5 = 9;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD6 = 10;
/** @internal */ const VERTEX_ATTRIB_TEXCOORD7 = 11;
/** @internal */ const VERTEX_ATTRIB_BLEND_WEIGHT = 12;
/** @internal */ const VERTEX_ATTRIB_BLEND_INDICES = 13;
const vertexAttribFormatMap = {
    position_u8normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    position_u8normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    position_i8normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    position_i8normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    position_u16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    position_u16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    position_i16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    position_i16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    position_u16normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    position_u16normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    position_i16normx2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    position_i16normx4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    position_f16x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    position_f16x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    position_f32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    position_f32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    position_f32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    position_f32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    position_i32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    position_i32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    position_i32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    position_i32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    position_u32: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    position_u32x2: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    position_u32x3: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    position_u32x4: [
        VERTEX_ATTRIB_POSITION,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    normal_f16x4: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    normal_f32x3: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    normal_f32x4: [
        VERTEX_ATTRIB_NORMAL,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    diffuse_u8normx4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    diffuse_u16x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    diffuse_u16normx4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    diffuse_f16x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    diffuse_f32x3: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    diffuse_f32x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    diffuse_u32x3: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    diffuse_u32x4: [
        VERTEX_ATTRIB_DIFFUSE,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tangent_f16x4: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tangent_f32x3: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tangent_f32x4: [
        VERTEX_ATTRIB_TANGENT,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex0_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex0_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex0_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex0_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex0_u16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex0_u16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex0_i16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex0_i16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex0_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex0_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex0_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex0_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex0_f16x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex0_f16x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex0_f32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex0_f32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex0_f32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex0_f32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex0_i32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex0_i32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex0_i32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex0_i32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex0_u32: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex0_u32x2: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex0_u32x3: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex0_u32x4: [
        VERTEX_ATTRIB_TEXCOORD0,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex1_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex1_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex1_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex1_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex1_u16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex1_u16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex1_i16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex1_i16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex1_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex1_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex1_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex1_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex1_f16x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex1_f16x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex1_f32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex1_f32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex1_f32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex1_f32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex1_i32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex1_i32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex1_i32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex1_i32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex1_u32: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex1_u32x2: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex1_u32x3: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex1_u32x4: [
        VERTEX_ATTRIB_TEXCOORD1,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex2_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex2_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex2_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex2_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex2_u16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex2_u16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex2_i16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex2_i16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex2_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex2_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex2_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex2_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex2_f16x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex2_f16x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex2_f32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex2_f32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex2_f32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex2_f32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex2_i32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex2_i32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex2_i32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex2_i32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex2_u32: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex2_u32x2: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex2_u32x3: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex2_u32x4: [
        VERTEX_ATTRIB_TEXCOORD2,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex3_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex3_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex3_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex3_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex3_u16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex3_u16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex3_i16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex3_i16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex3_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex3_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex3_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex3_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex3_f16x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex3_f16x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex3_f32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex3_f32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex3_f32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex3_f32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex3_i32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex3_i32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex3_i32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex3_i32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex3_u32: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex3_u32x2: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex3_u32x3: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex3_u32x4: [
        VERTEX_ATTRIB_TEXCOORD3,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex4_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex4_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex4_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex4_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex4_u16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex4_u16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex4_i16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex4_i16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex4_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex4_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex4_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex4_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex4_f16x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex4_f16x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex4_f32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex4_f32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex4_f32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex4_f32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex4_i32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex4_i32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex4_i32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex4_i32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex4_u32: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex4_u32x2: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex4_u32x3: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex4_u32x4: [
        VERTEX_ATTRIB_TEXCOORD4,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex5_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex5_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex5_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex5_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex5_u16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex5_u16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex5_i16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex5_i16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex5_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex5_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex5_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex5_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex5_f16x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex5_f16x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex5_f32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex5_f32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex5_f32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex5_f32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex5_i32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex5_i32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex5_i32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex5_i32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex5_u32: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex5_u32x2: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex5_u32x3: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex5_u32x4: [
        VERTEX_ATTRIB_TEXCOORD5,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex6_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex6_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex6_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex6_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex6_u16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex6_u16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex6_i16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex6_i16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex6_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex6_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex6_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex6_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex6_f16x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex6_f16x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex6_f32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex6_f32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex6_f32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex6_f32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex6_i32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex6_i32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex6_i32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex6_i32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex6_u32: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex6_u32x2: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex6_u32x3: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex6_u32x4: [
        VERTEX_ATTRIB_TEXCOORD6,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    tex7_u8normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U8VEC2_NORM,
        2,
        'u8norm',
        2
    ],
    tex7_u8normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U8VEC4_NORM,
        4,
        'u8norm',
        4
    ],
    tex7_i8normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I8VEC2_NORM,
        2,
        'i8norm',
        2
    ],
    tex7_i8normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I8VEC4_NORM,
        4,
        'i8norm',
        4
    ],
    tex7_u16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC2,
        4,
        'u16',
        2
    ],
    tex7_u16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    tex7_i16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC2,
        4,
        'i16',
        2
    ],
    tex7_i16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC4,
        8,
        'i16',
        4
    ],
    tex7_u16normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC2_NORM,
        4,
        'u16norm',
        2
    ],
    tex7_u16normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U16VEC4_NORM,
        8,
        'u16norm',
        4
    ],
    tex7_i16normx2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC2_NORM,
        4,
        'i16norm',
        2
    ],
    tex7_i16normx4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I16VEC4_NORM,
        8,
        'i16norm',
        4
    ],
    tex7_f16x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F16VEC2,
        4,
        'f16',
        2
    ],
    tex7_f16x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    tex7_f32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32,
        4,
        'f32',
        1
    ],
    tex7_f32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC2,
        8,
        'f32',
        2
    ],
    tex7_f32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC3,
        12,
        'f32',
        3
    ],
    tex7_f32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    tex7_i32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32,
        4,
        'i32',
        1
    ],
    tex7_i32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC2,
        8,
        'i32',
        2
    ],
    tex7_i32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC3,
        12,
        'i32',
        3
    ],
    tex7_i32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.I32VEC4,
        16,
        'i32',
        4
    ],
    tex7_u32: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32,
        4,
        'u32',
        1
    ],
    tex7_u32x2: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC2,
        8,
        'u32',
        2
    ],
    tex7_u32x3: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC3,
        12,
        'u32',
        3
    ],
    tex7_u32x4: [
        VERTEX_ATTRIB_TEXCOORD7,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ],
    blendweights_f16x4: [
        VERTEX_ATTRIB_BLEND_WEIGHT,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    blendweights_f32x4: [
        VERTEX_ATTRIB_BLEND_WEIGHT,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    blendindices_u16x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.U16VEC4,
        8,
        'u16',
        4
    ],
    blendindices_f16x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.F16VEC4,
        8,
        'f16',
        4
    ],
    blendindices_f32x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.F32VEC4,
        16,
        'f32',
        4
    ],
    blendindices_u32x4: [
        VERTEX_ATTRIB_BLEND_INDICES,
        PBPrimitiveType.U32VEC4,
        16,
        'u32',
        4
    ]
};
const vertexAttribNameMap = {
    position: VERTEX_ATTRIB_POSITION,
    normal: VERTEX_ATTRIB_NORMAL,
    diffuse: VERTEX_ATTRIB_DIFFUSE,
    tangent: VERTEX_ATTRIB_TANGENT,
    blendIndices: VERTEX_ATTRIB_BLEND_INDICES,
    blendWeights: VERTEX_ATTRIB_BLEND_WEIGHT,
    texCoord0: VERTEX_ATTRIB_TEXCOORD0,
    texCoord1: VERTEX_ATTRIB_TEXCOORD1,
    texCoord2: VERTEX_ATTRIB_TEXCOORD2,
    texCoord3: VERTEX_ATTRIB_TEXCOORD3,
    texCoord4: VERTEX_ATTRIB_TEXCOORD4,
    texCoord5: VERTEX_ATTRIB_TEXCOORD5,
    texCoord6: VERTEX_ATTRIB_TEXCOORD6,
    texCoord7: VERTEX_ATTRIB_TEXCOORD7
};
const vertexAttribNameRevMap = {
    [VERTEX_ATTRIB_POSITION]: 'position',
    [VERTEX_ATTRIB_NORMAL]: 'normal',
    [VERTEX_ATTRIB_DIFFUSE]: 'diffuse',
    [VERTEX_ATTRIB_TANGENT]: 'tangent',
    [VERTEX_ATTRIB_BLEND_INDICES]: 'blendIndices',
    [VERTEX_ATTRIB_BLEND_WEIGHT]: 'blendWeights',
    [VERTEX_ATTRIB_TEXCOORD0]: 'texCoord0',
    [VERTEX_ATTRIB_TEXCOORD1]: 'texCoord1',
    [VERTEX_ATTRIB_TEXCOORD2]: 'texCoord2',
    [VERTEX_ATTRIB_TEXCOORD3]: 'texCoord3',
    [VERTEX_ATTRIB_TEXCOORD4]: 'texCoord4',
    [VERTEX_ATTRIB_TEXCOORD5]: 'texCoord5',
    [VERTEX_ATTRIB_TEXCOORD6]: 'texCoord6',
    [VERTEX_ATTRIB_TEXCOORD7]: 'texCoord7'
};
var GPUResourceUsageFlags;
(function(GPUResourceUsageFlags) {
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_LINEAR_COLOR_SPACE"] = 2] = "TF_LINEAR_COLOR_SPACE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_NO_MIPMAP"] = 4] = "TF_NO_MIPMAP";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_WRITABLE"] = 8] = "TF_WRITABLE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["TF_NO_GC"] = 16] = "TF_NO_GC";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_VERTEX"] = 32] = "BF_VERTEX";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_INDEX"] = 64] = "BF_INDEX";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_READ"] = 128] = "BF_READ";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_WRITE"] = 256] = "BF_WRITE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_UNIFORM"] = 512] = "BF_UNIFORM";
    GPUResourceUsageFlags[GPUResourceUsageFlags["BF_STORAGE"] = 1024] = "BF_STORAGE";
    GPUResourceUsageFlags[GPUResourceUsageFlags["DYNAMIC"] = 2048] = "DYNAMIC";
    GPUResourceUsageFlags[GPUResourceUsageFlags["MANAGED"] = 4096] = "MANAGED";
})(GPUResourceUsageFlags || (GPUResourceUsageFlags = {}));
/**
 * Get vertex attribute index by semantic
 * @internal
 */ function getVertexAttribByName(name) {
    return vertexAttribNameMap[name];
}
/**
 * Get vertex semantic by attribute index
 * @internal
 */ function getVertexAttribName(attrib) {
    return vertexAttribNameRevMap[attrib];
}
/**
 * Get byte size of specified vertex format
 * @internal
 */ function getVertexFormatSize(fmt) {
    return vertexAttribFormatMap[fmt][2];
}
/**
 * Get vertex format by semantic and component type and component count
 * @param semantic - The vertex semantic
 * @param type - Data type of vertex component
 * @param count - The count of vertex components
 * @returns Vertex format
 * @public
 */ function getVertexAttribFormat(semantic, type, count) {
    const loc = getVertexAttribByName(semantic);
    for(const k in vertexAttribFormatMap){
        const v = vertexAttribFormatMap[k];
        if (v[0] === loc && v[3] === type && v[4] === count) {
            return k;
        }
    }
    return null;
}
/**
 * Get byte stride of a vertex buffer by specified structure type of the vertex buffer
 * @param vertexBufferType - The structure type of the vertex buffer
 * @returns The byte stride of the vertex buffer
 * @public
 */ function getVertexBufferStride(vertexBufferType) {
    const vertexType = vertexBufferType.structMembers[0].type.elementType;
    if (vertexType.isStructType()) {
        let stride = 0;
        for (const member of vertexType.structMembers){
            stride += member.type.getSize();
        }
        return stride;
    } else {
        return vertexType.getSize();
    }
}
/**
 * Get primitive type of a vertex attribute by specified vertex semantic
 * @param vertexBufferType - The structure type of the vertex buffer
 * @param semantic - The vertex semantic
 * @returns - The primitive type of the vertex attribute
 * @public
 */ function getVertexBufferAttribTypeBySemantic(vertexBufferType, semantic) {
    const k = vertexBufferType.structMembers[0];
    const vertexType = k.type.elementType;
    if (vertexType.isStructType()) {
        for (const member of vertexType.structMembers){
            if (member.name === semantic) {
                return member.type;
            }
        }
        return null;
    } else {
        return k.name === semantic ? vertexType : null;
    }
}
/**
 * Get primitive type of a vertex attribute by specified vertex attribute index
 * @param vertexBufferType - The structure type of the vertex buffer
 * @param semantic - The vertex attribute index
 * @returns - The primitive type of the vertex attribute
 * @public
 */ function getVertexBufferAttribType(vertexBufferType, attrib) {
    const attribName = getVertexAttribName(attrib);
    if (!attribName) {
        return null;
    }
    return getVertexBufferAttribTypeBySemantic(vertexBufferType, attribName);
}
/**
 * Get the structure type of a vertex buffer by specified vertex attribute formats and the length of the vertex buffer
 * @param length - The length of the vertex buffer
 * @param attributes - The vertex attributes
 * @returns The structure type of the vertex buffer
 * @public
 */ function makeVertexBufferType(length, ...attributes) {
    if (attributes.length === 0) {
        return null;
    }
    if (attributes.length === 1) {
        const format = vertexAttribFormatMap[attributes[0]];
        return new PBStructTypeInfo(null, 'packed', [
            {
                name: getVertexAttribName(format[0]),
                type: new PBArrayTypeInfo(PBPrimitiveTypeInfo.getCachedTypeInfo(format[1]), length)
            }
        ]);
    } else {
        const vertexType = new PBStructTypeInfo(null, 'packed', attributes.map((attrib)=>({
                name: getVertexAttribName(vertexAttribFormatMap[attrib][0]),
                type: PBPrimitiveTypeInfo.getCachedTypeInfo(vertexAttribFormatMap[attrib][1])
            })));
        return new PBStructTypeInfo(null, 'packed', [
            {
                name: 'value',
                type: new PBArrayTypeInfo(vertexType, length)
            }
        ]);
    }
}
/**
 * Vertex semantic list
 * @public
 */ const semanticList = function() {
    const list = [];
    for(let i = 0; i < MAX_VERTEX_ATTRIBUTES; i++){
        list.push(semanticToAttrib(i));
    }
    return list;
}();
/** @internal */ function semanticToAttrib(semantic) {
    switch(semantic){
        case VERTEX_ATTRIB_POSITION:
            return 'a_position';
        case VERTEX_ATTRIB_NORMAL:
            return 'a_normal';
        case VERTEX_ATTRIB_DIFFUSE:
            return 'a_diffuse';
        case VERTEX_ATTRIB_TANGENT:
            return 'a_tangent';
        case VERTEX_ATTRIB_TEXCOORD0:
            return 'a_texcoord0';
        case VERTEX_ATTRIB_TEXCOORD1:
            return 'a_texcoord1';
        case VERTEX_ATTRIB_TEXCOORD2:
            return 'a_texcoord2';
        case VERTEX_ATTRIB_TEXCOORD3:
            return 'a_texcoord3';
        case VERTEX_ATTRIB_TEXCOORD4:
            return 'a_texcoord4';
        case VERTEX_ATTRIB_TEXCOORD5:
            return 'a_texcoord5';
        case VERTEX_ATTRIB_TEXCOORD6:
            return 'a_texcoord6';
        case VERTEX_ATTRIB_TEXCOORD7:
            return 'a_texcoord7';
        case VERTEX_ATTRIB_BLEND_INDICES:
            return 'a_indices';
        case VERTEX_ATTRIB_BLEND_WEIGHT:
            return 'a_weight';
        default:
            return null;
    }
}
/**
 * Creates the default name for the type of given gpu object
 * @param obj - The gpu object
 * @returns The default name
 * @public
 */ function genDefaultName(obj) {
    if (obj.isTexture2D()) {
        return 'texture_2d';
    } else if (obj.isTexture2DArray()) {
        return 'texture_2darray';
    } else if (obj.isTexture3D()) {
        return 'texture_3d';
    } else if (obj.isTextureCube()) {
        return 'texture_cube';
    } else if (obj.isTextureVideo()) {
        return 'texture_video';
    } else if (obj.isBuffer()) {
        return 'buffer';
    } else if (obj.isFramebuffer()) {
        return 'framebuffer';
    } else if (obj.isProgram()) {
        return 'program';
    } else if (obj.isSampler()) {
        return 'sampler';
    } else if (obj.isVertexLayout()) {
        return 'vbo';
    } else {
        return 'unknown';
    }
}

/**
 * The vertex data class
 * @public
 */ class VertexData {
    /** @internal */ _vertexBuffers;
    /** @internal */ _indexBuffer;
    /** @internal */ _drawOffset;
    constructor(){
        this._vertexBuffers = [];
        for(let i = 0; i < MAX_VERTEX_ATTRIBUTES; i++){
            this._vertexBuffers.push(null);
        }
        this._indexBuffer = null;
        this._drawOffset = 0;
    }
    /**
   * Creates a new instance of VertexData by copying from this object
   * @returns New instance of VertexData
   */ clone() {
        const newVertexData = new VertexData();
        newVertexData._vertexBuffers = this._vertexBuffers.slice();
        newVertexData._indexBuffer = this._indexBuffer;
        newVertexData._drawOffset = this._drawOffset;
        return newVertexData;
    }
    /** Vertex buffer information list */ get vertexBuffers() {
        return this._vertexBuffers;
    }
    /** Index buffer */ get indexBuffer() {
        return this._indexBuffer;
    }
    /** Draw offset */ getDrawOffset() {
        return this._drawOffset;
    }
    setDrawOffset(offset) {
        if (offset !== this._drawOffset) {
            this._drawOffset = offset;
        }
    }
    /**
   * Gets the vertex buffer by specific vertex semantic
   * @param semantic - The vertex semantic
   * @returns Vertex buffer of the given semantic
   */ getVertexBuffer(semantic) {
        return this._vertexBuffers[getVertexAttribByName(semantic)]?.buffer ?? null;
    }
    /**
   * Gets the vertex buffer information by specific vertex semantic
   * @param semantic - The vertex semantic
   * @returns Vertex buffer information of the given semantic
   */ getVertexBufferInfo(semantic) {
        return this._vertexBuffers[getVertexAttribByName(semantic)] ?? null;
    }
    /**
   * Gets the index buffer
   * @returns The index buffer
   */ getIndexBuffer() {
        return this._indexBuffer || null;
    }
    /**
   * Sets a vertex buffer
   * @param buffer - The vertex buffer object
   * @param stepMode - Step mode of the buffer
   * @returns The buffer that was set
   */ setVertexBuffer(buffer, stepMode) {
        if (!buffer || !(buffer.usage & GPUResourceUsageFlags.BF_VERTEX)) {
            throw new Error('setVertexBuffer() failed: buffer is null or buffer has not Vertex usage flag');
        }
        stepMode = stepMode || 'vertex';
        const vertexType = buffer.structure.structMembers[0].type.elementType;
        if (vertexType.isStructType()) {
            let offset = 0;
            for (const attrib of vertexType.structMembers){
                const loc = getVertexAttribByName(attrib.name);
                this.internalSetVertexBuffer(loc, buffer, offset, stepMode);
                offset += attrib.size;
            }
        } else {
            const loc = getVertexAttribByName(buffer.structure.structMembers[0].name);
            this.internalSetVertexBuffer(loc, buffer, 0, stepMode);
        }
        return buffer;
    }
    /**
   * Removes a vertex buffer
   * @param buffer - Vertex buffer to be removed
   * @returns true if the buffer was successfully removed, otherwise false
   */ removeVertexBuffer(buffer) {
        let removed = false;
        for(let loc = 0; loc < this._vertexBuffers.length; loc++){
            const info = this._vertexBuffers[loc];
            const remove = info?.buffer === buffer;
            if (remove) {
                this._vertexBuffers[loc] = null;
                removed = true;
            }
        }
        return removed;
    }
    /**
   * Sets the index buffer
   * @param buffer - Index buffer to be set
   * @returns The index buffer that was set
   */ setIndexBuffer(buffer) {
        if (buffer !== this._indexBuffer) {
            this._indexBuffer = buffer || null;
        }
        return buffer;
    }
    /** @internal */ internalSetVertexBuffer(loc, buffer, offset, stepMode) {
        if (loc < 0 || loc >= MAX_VERTEX_ATTRIBUTES) {
            throw new Error(`setVertexBuffer() failed: location out of bounds: ${loc}`);
        }
        offset = Number(offset) || 0;
        stepMode = stepMode || 'vertex';
        const old = this._vertexBuffers[loc];
        if (!old || old.buffer !== buffer || old.offset !== offset || old.stepMode !== stepMode) {
            this._vertexBuffers[loc] = {
                buffer: buffer,
                offset: offset,
                type: getVertexBufferAttribType(buffer.structure, loc),
                stride: getVertexBufferStride(buffer.structure),
                drawOffset: 0,
                stepMode: stepMode
            };
            return buffer;
        }
        return null;
    }
}

/**
 * Abstract timer interface
 * @public
 */ /**
 * CPU timer class
 * @public
 */ class CPUTimer {
    /** @internal */ _cpuTimer;
    /** @internal */ _cpuStart;
    /** @internal */ _cpuTime;
    /** @internal */ _ended;
    constructor(){
        this._cpuTimer = window.performance || window.Date;
        this._cpuTime = null;
        this._ended = false;
    }
    now() {
        return this._cpuTimer.now();
    }
    begin() {
        this._cpuStart = this.now();
        this._cpuTime = null;
        this._ended = false;
    }
    end() {
        this._cpuTime = this.now() - this._cpuStart;
        this._ended = true;
    }
    ended() {
        return this._ended;
    }
    elapsed() {
        return this._cpuTime;
    }
}

/** @internal */ function expValueToString(deviceType, value) {
    if (typeof value === 'number' || typeof value === 'boolean' || Array.isArray(value)) {
        return `${value}`;
    } else {
        return value.$ast?.toString(deviceType);
    }
}
/** @internal */ function expValueTypeToString(deviceType, type) {
    return type?.toTypeName(deviceType);
}
/** @internal */ class PBError extends Error {
}
/** @internal */ class PBValueOutOfRange extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `value out of range: ${this.value}`;
    }
}
/** @internal */ class PBTypeCastError extends PBError {
    value;
    valueType;
    expectedType;
    constructor(value, valueType, expectedType){
        super();
        this.value = value;
        this.valueType = valueType;
        this.expectedType = expectedType;
    }
    getMessage(deviceType) {
        const valueStr = typeof this.value === 'string' ? this.value : expValueToString(deviceType, this.value);
        const valueTypeStr = typeof this.valueType === 'string' ? this.valueType : expValueTypeToString(deviceType, this.valueType);
        const expectedTypeStr = typeof this.expectedType === 'string' ? this.expectedType : expValueTypeToString(deviceType, this.expectedType);
        return `cannot convert '${valueStr}' of type '${valueTypeStr}' to type ${expectedTypeStr}`;
    }
}
/** @internal */ class PBParamLengthError extends PBError {
    func;
    constructor(func){
        super();
        this.func = func;
    }
    getMessage(deviceType) {
        return `wrong argument count for function '${this.func}'`;
    }
}
/** @internal */ class PBParamTypeError extends PBError {
    func;
    param;
    constructor(func, param){
        super();
        this.func = func;
        this.param = param || null;
    }
    getMessage(deviceType) {
        return `parameter type error for function '${this.func}': ${this.param}`;
    }
}
/** @internal */ class PBParamValueError extends PBError {
    func;
    param;
    reason;
    constructor(func, param, reason){
        super();
        this.func = func;
        this.param = param || null;
        this.reason = reason || null;
    }
    getMessage(deviceType) {
        return `invalid parameter value for function '${this.func}'${this.param ? ': ' + this.param : ''}${this.reason ? ': ' + this.reason : ''}}`;
    }
}
/** @internal */ class PBOverloadingMatchError extends PBError {
    func;
    constructor(func){
        super();
        this.func = func;
    }
    getMessage(deviceType) {
        return `No matched overloading found for function '${this.func}'`;
    }
}
/** @internal */ class PBReferenceValueRequired extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `'${expValueToString(deviceType, this.value)}' is not a reference type`;
    }
}
/** @internal */ class PBPointerValueRequired extends PBError {
    value;
    constructor(value){
        super();
        this.value = value;
    }
    getMessage(deviceType) {
        return `'${expValueToString(deviceType, this.value)}' is not a pointer type`;
    }
}
/** @internal */ class PBDeviceNotSupport extends PBError {
    feature;
    constructor(feature){
        super();
        this.feature = feature;
    }
    getMessage(deviceType) {
        return `feature not support for ${deviceType} device: ${this.feature}`;
    }
}
/** @internal */ class PBNonScopedFunctionCall extends PBError {
    funcName;
    constructor(funcName){
        super();
        this.funcName = funcName;
    }
    getMessage(deviceType) {
        return `function call must be made inside a function scope: ${this.funcName}()`;
    }
}
/** @internal */ class PBASTError extends PBError {
    ast;
    text;
    constructor(ast, text){
        super();
        this.ast = ast;
        this.text = text;
    }
    getMessage(deviceType) {
        return `${this.text}: ${this.ast.toString(deviceType)}`;
    }
}
/** @internal */ class PBInternalError extends PBError {
    constructor(desc){
        super(desc);
    }
    getMessage(deviceType) {
        return `Internal error: ${this.message}`;
    }
}

const BuiltinInputStructNameVS = 'zVSInput';
const BuiltinOutputStructNameVS = 'zVSOutput';
const BuiltinInputStructNameFS = 'zFSInput';
const BuiltinOutputStructNameFS = 'zFSOutput';
const BuiltinInputStructNameCS = 'zCSInput';
const BuiltinOutputStructNameCS = 'zCSOutput';
const BuiltinParamNameVS = 'zVertexInput';
const BuiltinParamNameFS = 'zVertexOutput';
const BuiltinParamNameCS = 'zComputeInput';
const BuiltinInputStructInstanceNameVS = 'zVSInputCpy';
const BuiltinOutputStructInstanceNameVS = 'zVSOutputCpy';
const BuiltinInputStructInstanceNameFS = 'zFSInputCpy';
const BuiltinOutputStructInstanceNameFS = 'zFSOutputCpy';
const BuiltinInputStructInstanceNameCS = 'zCSInputCpy';
const BuiltinOutputStructInstanceNameCS = 'zCSOutputCpy';
var DeclareType;
(function(DeclareType) {
    DeclareType[DeclareType["DECLARE_TYPE_NONE"] = 0] = "DECLARE_TYPE_NONE";
    DeclareType[DeclareType["DECLARE_TYPE_IN"] = 1] = "DECLARE_TYPE_IN";
    DeclareType[DeclareType["DECLARE_TYPE_OUT"] = 2] = "DECLARE_TYPE_OUT";
    DeclareType[DeclareType["DECLARE_TYPE_WORKGROUP"] = 3] = "DECLARE_TYPE_WORKGROUP";
    DeclareType[DeclareType["DECLARE_TYPE_UNIFORM"] = 4] = "DECLARE_TYPE_UNIFORM";
    DeclareType[DeclareType["DECLARE_TYPE_STORAGE"] = 5] = "DECLARE_TYPE_STORAGE";
})(DeclareType || (DeclareType = {}));
var ShaderPrecisionType;
(function(ShaderPrecisionType) {
    ShaderPrecisionType[ShaderPrecisionType["NONE"] = 0] = "NONE";
    ShaderPrecisionType[ShaderPrecisionType["HIGH"] = 1] = "HIGH";
    ShaderPrecisionType[ShaderPrecisionType["MEDIUM"] = 2] = "MEDIUM";
    ShaderPrecisionType[ShaderPrecisionType["LOW"] = 3] = "LOW";
})(ShaderPrecisionType || (ShaderPrecisionType = {}));
/** @internal */ function getBuiltinParamName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinParamNameVS;
        case ShaderType.Fragment:
            return BuiltinParamNameFS;
        case ShaderType.Compute:
            return BuiltinParamNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinInputStructInstanceName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinInputStructInstanceNameVS;
        case ShaderType.Fragment:
            return BuiltinInputStructInstanceNameFS;
        case ShaderType.Compute:
            return BuiltinInputStructInstanceNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinOutputStructInstanceName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinOutputStructInstanceNameVS;
        case ShaderType.Fragment:
            return BuiltinOutputStructInstanceNameFS;
        case ShaderType.Compute:
            return BuiltinOutputStructInstanceNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinInputStructName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinInputStructNameVS;
        case ShaderType.Fragment:
            return BuiltinInputStructNameFS;
        case ShaderType.Compute:
            return BuiltinInputStructNameCS;
        default:
            return null;
    }
}
/** @internal */ function getBuiltinOutputStructName(shaderType) {
    switch(shaderType){
        case ShaderType.Vertex:
            return BuiltinOutputStructNameVS;
        case ShaderType.Fragment:
            return BuiltinOutputStructNameFS;
        case ShaderType.Compute:
            return BuiltinOutputStructNameCS;
        default:
            return null;
    }
}
/** @internal */ function getTextureSampleType(type) {
    switch(type.textureType){
        case PBTextureType.TEX_1D:
        case PBTextureType.TEX_STORAGE_1D:
        case PBTextureType.TEX_2D:
        case PBTextureType.TEX_STORAGE_2D:
        case PBTextureType.TEX_2D_ARRAY:
        case PBTextureType.TEX_STORAGE_2D_ARRAY:
        case PBTextureType.TEX_3D:
        case PBTextureType.TEX_STORAGE_3D:
        case PBTextureType.TEX_CUBE:
        case PBTextureType.TEX_EXTERNAL:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4);
        case PBTextureType.TEX_DEPTH_2D_ARRAY:
        case PBTextureType.TEX_DEPTH_2D:
        case PBTextureType.TEX_DEPTH_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.F32);
        case PBTextureType.ITEX_2D_ARRAY:
        case PBTextureType.ITEX_1D:
        case PBTextureType.ITEX_2D:
        case PBTextureType.ITEX_3D:
        case PBTextureType.ITEX_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.I32);
        case PBTextureType.UTEX_2D_ARRAY:
        case PBTextureType.UTEX_1D:
        case PBTextureType.UTEX_2D:
        case PBTextureType.UTEX_3D:
        case PBTextureType.UTEX_CUBE:
            return new PBPrimitiveTypeInfo(PBPrimitiveType.U32);
        default:
            return null;
    }
}
/** @internal */ function genSamplerName(textureName, comparison) {
    return `ch_auto_sampler_${textureName}${comparison ? '_comparison' : ''}`;
}
/** @internal */ const builtinVariables = {
    webgl: {
        position: {
            name: 'gl_Position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'vertex'
        },
        pointSize: {
            name: 'gl_PointSize',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'vertex'
        },
        fragCoord: {
            name: 'gl_FragCoord',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'fragment'
        },
        frontFacing: {
            name: 'gl_FrontFacing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            stage: 'fragment'
        },
        fragDepth: {
            name: 'gl_FragDepthEXT',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            inOrOut: 'out',
            extension: 'GL_EXT_frag_depth',
            stage: 'fragment'
        }
    },
    webgl2: {
        vertexIndex: {
            name: 'gl_VertexID',
            semantic: 'vertex_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        instanceIndex: {
            name: 'gl_InstanceID',
            semantic: 'instance_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        position: {
            name: 'gl_Position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'vertex'
        },
        pointSize: {
            name: 'gl_PointSize',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'vertex'
        },
        fragCoord: {
            name: 'gl_FragCoord',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            stage: 'fragment'
        },
        frontFacing: {
            name: 'gl_FrontFacing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            stage: 'fragment'
        },
        fragDepth: {
            name: 'gl_FragDepth',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            stage: 'fragment'
        }
    },
    webgpu: {
        vertexIndex: {
            name: 'zVertexId',
            semantic: 'vertex_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        instanceIndex: {
            name: 'zInstanceId',
            semantic: 'instance_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'vertex'
        },
        position: {
            name: 'zPosition',
            semantic: 'position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            inOrOut: 'out',
            stage: 'vertex'
        },
        fragCoord: {
            name: 'zFragCoord',
            semantic: 'position',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32VEC4),
            inOrOut: 'in',
            stage: 'fragment'
        },
        frontFacing: {
            name: 'zFrontFacing',
            semantic: 'front_facing',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.BOOL),
            inOrOut: 'in',
            stage: 'fragment'
        },
        fragDepth: {
            name: 'zFragDepth',
            semantic: 'frag_depth',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.F32),
            inOrOut: 'out',
            stage: 'fragment'
        },
        localInvocationId: {
            name: 'zLocalInvocationId',
            semantic: 'local_invocation_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        globalInvocationId: {
            name: 'zGlobalInvocationId',
            semantic: 'global_invocation_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        workGroupId: {
            name: 'zWorkGroupId',
            semantic: 'workgroup_id',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        numWorkGroups: {
            name: 'zNumWorkGroups',
            semantic: 'num_workgroups',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32VEC3),
            inOrOut: 'in',
            stage: 'compute'
        },
        sampleMaskIn: {
            name: 'zSampleMaskIn',
            semantic: 'sample_mask_in',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'fragment'
        },
        sampleMaskOut: {
            name: 'zSampleMaskOut',
            semantic: 'sample_mask_out',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'out',
            stage: 'fragment'
        },
        sampleIndex: {
            name: 'zSampleIndex',
            semantic: 'sample_index',
            type: new PBPrimitiveTypeInfo(PBPrimitiveType.U32),
            inOrOut: 'in',
            stage: 'fragment'
        }
    }
};
function toFixed(n) {
    return n % 1 === 0 ? n.toFixed(1) : String(n);
}
function toInt(n) {
    return String(n | 0);
}
function toUint(n) {
    return String(n >>> 0);
}
function unbracket(e) {
    e = e.trim();
    if (e[0] === '(' && e[e.length - 1] === ')') {
        let match = 0;
        for(let i = 1; i < e.length - 1; i++){
            if (e[i] === '(') {
                match++;
            } else if (e[i] === ')') {
                match--;
                if (match < 0) {
                    break;
                }
            }
        }
        if (match > 0) {
            throw new PBInternalError(`Invalid expression: ${e}`);
        } else if (match === 0) {
            return e.substring(1, e.length - 1);
        }
    }
    return e;
}
/** @internal */ class ShaderAST {
    isReference() {
        return false;
    }
    isPointer() {
        return !!this.getType()?.isPointerType();
    }
    getType() {
        return null;
    }
    toWebGL(indent, ctx) {
        return '';
    }
    toWebGL2(indent, ctx) {
        return '';
    }
    toWGSL(indent, ctx) {
        return '';
    }
    toString(deviceType) {
        return this.constructor.name;
    }
}
/** @internal */ class ASTExpression extends ShaderAST {
}
/** @internal */ class ASTFunctionParameter extends ASTExpression {
    /** @internal */ paramAST;
    /** @internal */ writable;
    constructor(init){
        super();
        this.paramAST = init;
        this.writable = false;
    }
    getType() {
        return this.paramAST.getType();
    }
    markWritable() {
        if (this.paramAST instanceof ASTPrimitive) {
            console.warn(`Write to non-output parameter ${this.paramAST.value.$str}`);
        }
        this.writable = true;
    }
    isWritable() {
        return this.writable;
    }
    getAddressSpace() {
        return this.paramAST.getAddressSpace();
    }
    isConstExp() {
        return this.paramAST.isConstExp();
    }
    isReference() {
        return this.paramAST.isReference();
    }
    toWebGL(indent, ctx) {
        return this.paramAST.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.paramAST.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.paramAST.toWGSL(indent, ctx);
    }
}
/** @internal */ class ASTScope extends ShaderAST {
    statements;
    constructor(){
        super();
        this.statements = [];
    }
    toWebGL(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>stmt.toWebGL(indent, ctx)).join('');
    }
    toWebGL2(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>stmt.toWebGL2(indent, ctx)).join('');
    }
    toWGSL(indent, ctx) {
        return this.statements.filter((stmt)=>!(stmt instanceof ASTCallFunction) || stmt.isStatement).map((stmt)=>{
            if (stmt instanceof ASTCallFunction) {
                if (!stmt.getType().isVoidType()) {
                    return `${indent}_ = ${stmt.toWGSL('', ctx)}`;
                }
            }
            return stmt.toWGSL(indent, ctx);
        }).join('');
    }
}
/** @internal */ class ASTNakedScope extends ASTScope {
    toWebGL(indent, ctx) {
        return `${indent}{\n${super.toWebGL(indent + ' ', ctx)}${indent}}\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}{\n${super.toWebGL2(indent + ' ', ctx)}${indent}}\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}{\n${super.toWGSL(indent + ' ', ctx)}${indent}}\n`;
    }
}
/** @internal */ class ASTGlobalScope extends ASTScope {
    /** @internal */ uniforms;
    constructor(){
        super();
        this.uniforms = [];
    }
    findFunctions(name) {
        const result = [];
        for (const stmt of this.statements){
            if (stmt instanceof ASTFunction && stmt.name === name) {
                result.push(stmt);
            }
        }
        return result;
    }
    toWebGL(indent, ctx) {
        // TODO: precision
        const precisions = `${indent}precision highp float;\n${indent}precision highp int;\n`;
        const version = `${indent}#version 100\n`;
        const body = ctx.types.map((val)=>val.toWebGL(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWebGL(indent, ctx)).join('') + ctx.inputs.map((input)=>input.toWebGL(indent, ctx)).join('') + ctx.outputs.map((output)=>output.toWebGL(indent, ctx)).join('') + super.toWebGL(indent, ctx);
        for (const k of ctx.builtins){
            const info = builtinVariables.webgl[k];
            if (info.extension) {
                ctx.extensions.add(info.extension);
            }
        }
        const extensions = [
            ...ctx.extensions
        ].map((s)=>`${indent}#extension ${s}: enable\n`).join('');
        const defines = ctx.defines.join('');
        return version + extensions + precisions + defines + body;
    }
    toWebGL2(indent, ctx) {
        const precisions = `${indent}precision highp float;\n${indent}precision highp int;\n`;
        const version = `${indent}#version 300 es\n`;
        const body = ctx.types.map((val)=>val.toWebGL2(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWebGL2(indent, ctx)).join('') + ctx.inputs.map((input)=>input.toWebGL2(indent, ctx)).join('') + ctx.outputs.map((output)=>output.toWebGL2(indent, ctx)).join('') + super.toWebGL2(indent, ctx);
        for (const k of ctx.builtins){
            const info = builtinVariables.webgl2[k];
            if (info.extension) {
                ctx.extensions.add(info.extension);
            }
        }
        const extensions = [
            ...ctx.extensions
        ].map((s)=>`${indent}#extension ${s}: enable\n`).join('');
        const defines = ctx.defines.join('');
        return version + extensions + precisions + defines + body;
    }
    toWGSL(indent, ctx) {
        const structNames = ctx.type === ShaderType.Vertex ? [
            BuiltinInputStructNameVS,
            BuiltinOutputStructNameVS
        ] : ctx.type === ShaderType.Fragment ? [
            BuiltinInputStructNameFS,
            BuiltinOutputStructNameFS
        ] : [
            BuiltinInputStructNameCS
        ];
        const usedBuiltins = [];
        for (const k of ctx.builtins){
            usedBuiltins.push(builtinVariables.webgpu[k].name);
        }
        const allBuiltins = Object.keys(builtinVariables.webgpu).map((val)=>builtinVariables.webgpu[val].name);
        for (const type of ctx.types){
            if (type instanceof ASTStructDefine && structNames.indexOf(type.type.structName) >= 0) {
                for(let i = type.type.structMembers.length - 1; i >= 0; i--){
                    const member = type.type.structMembers[i];
                    if (allBuiltins.indexOf(member.name) >= 0 && usedBuiltins.indexOf(member.name) < 0) {
                        type.type.structMembers.splice(i, 1);
                        type.prefix.splice(i, 1);
                    }
                }
            }
        }
        ctx.types = ctx.types.filter((val)=>!(val instanceof ASTStructDefine) || val.type.structMembers.length > 0);
        return ctx.types.map((val)=>val.toWGSL(indent, ctx)).join('') + this.uniforms.map((uniform)=>uniform.toWGSL(indent, ctx)).join('') + super.toWGSL(indent, ctx);
    }
}
/** @internal */ class ASTPrimitive extends ASTExpression {
    /** @internal */ value;
    /** @internal */ ref;
    /** @internal */ writable;
    /** @internal */ constExp;
    constructor(value){
        super();
        this.value = value;
        this.ref = null;
        this.writable = false;
        this.constExp = false;
    }
    get name() {
        return this.value.$str;
    }
    isReference() {
        return true;
    }
    isConstExp() {
        return this.constExp;
    }
    markWritable() {
        this.writable = true;
        this.constExp = false;
        if (this.ref) {
            this.ref.markWritable();
        }
    }
    isWritable() {
        const type = this.getType();
        return this.writable || type.isAtomicI32() || type.isAtomicU32() || type.isStructType() && type.haveAtomicMembers();
    }
    getAddressSpace() {
        switch(this.value.$declareType){
            case DeclareType.DECLARE_TYPE_UNIFORM:
                return PBAddressSpace.UNIFORM;
            case DeclareType.DECLARE_TYPE_STORAGE:
                return PBAddressSpace.STORAGE;
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
                return null;
            default:
                return this.value.$global ? PBAddressSpace.PRIVATE : PBAddressSpace.FUNCTION;
        }
    }
    getType() {
        return this.value.$typeinfo;
    }
    toWebGL(indent, ctx) {
        return this.name;
    }
    toWebGL2(indent, ctx) {
        return this.name;
    }
    toWGSL(indent, ctx) {
        if (this.value.$declareType === DeclareType.DECLARE_TYPE_IN) {
            const structName = getBuiltinInputStructInstanceName(ctx.type);
            return ctx.global[structName][this.name].$ast.toWGSL(indent, ctx);
        } else if (this.value.$declareType === DeclareType.DECLARE_TYPE_OUT) {
            const structName = getBuiltinOutputStructInstanceName(ctx.type);
            return ctx.global[structName][this.name].$ast.toWGSL(indent, ctx);
        } else {
            return this.name;
        }
    }
    toString(deviceType) {
        return this.name;
    }
}
/** @internal */ class ASTLValue extends ShaderAST {
}
/** @internal */ class ASTLValueScalar extends ASTLValue {
    /** @internal */ value;
    constructor(value){
        super();
        if (value.getAddressSpace() === PBAddressSpace.UNIFORM) {
            throw new PBASTError(value, 'cannot assign to uniform variable');
        }
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        return this.value.getType();
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isReference() {
        return this.value.isReference();
    }
    toWebGL(indent, ctx) {
        return this.value.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.value.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.value.toWGSL(indent, ctx);
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTLValueHash extends ASTLValue {
    /** @internal */ scope;
    /** @internal */ field;
    /** @internal */ type;
    constructor(scope, field, type){
        super();
        this.scope = scope;
        this.field = field;
        this.type = type;
    }
    getType() {
        return this.type;
    }
    markWritable() {
        this.scope.markWritable();
    }
    isWritable() {
        return this.scope.isWritable();
    }
    isReference() {
        return this.scope.isReference();
    }
    toWebGL(indent, ctx) {
        return `${this.scope.toWebGL(indent, ctx)}.${this.field}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.scope.toWebGL2(indent, ctx)}.${this.field}`;
    }
    toWGSL(indent, ctx) {
        const scope = this.scope.isPointer() ? new ASTReferenceOf(this.scope) : this.scope;
        return `${scope.toWGSL(indent, ctx)}.${this.field}`;
    }
    toString(deviceType) {
        const scope = this.scope.isPointer() ? new ASTReferenceOf(this.scope) : this.scope;
        return `${scope.toString(deviceType)}.${this.field}`;
    }
}
/** @internal */ class ASTLValueArray extends ASTLValue {
    /** @internal */ value;
    /** @internal */ index;
    /** @internal */ type;
    constructor(value, index, type){
        super();
        this.value = value;
        this.index = index;
        this.type = type;
        if (this.index instanceof ASTCallFunction) {
            this.index.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isReference() {
        return this.value.isReference();
    }
    toWebGL(indent, ctx) {
        return `${this.value.toWebGL(indent, ctx)}[${this.index.toWebGL(indent, ctx)}]`;
    }
    toWebGL2(indent, ctx) {
        return `${this.value.toWebGL2(indent, ctx)}[${this.index.toWebGL2(indent, ctx)}]`;
    }
    toWGSL(indent, ctx) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${value.toWGSL(indent, ctx)}[${this.index.toWGSL(indent, ctx)}]`;
    }
    toString(deviceType) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${value.toString(deviceType)}[${this.index.toString(deviceType)}]`;
    }
}
/** @internal */ class ASTLValueDeclare extends ASTLValue {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        this.value.constExp = true;
    }
    getType() {
        return this.value.getType();
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isReference() {
        return true;
    }
    toWebGL(indent, ctx) {
        let prefix = '';
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                prefix = this.value.constExp && !this.value.isWritable() && !this.getType().isStructType() ? 'const ' : '';
                break;
        }
        {
            return `${prefix}${this.getType().toTypeName('webgl', this.value.name)}`;
        }
    }
    toWebGL2(indent, ctx) {
        let prefix = '';
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                prefix = this.value.constExp && !this.value.isWritable() && !this.getType().isStructType() ? 'const ' : '';
                break;
        }
        {
            return `${prefix}${this.getType().toTypeName('webgl2', this.value.name)}`;
        }
    }
    toWGSL(indent, ctx) {
        let prefix;
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
            case DeclareType.DECLARE_TYPE_UNIFORM:
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error('invalid declare type');
            default:
                {
                    const addressSpace = this.value.getAddressSpace();
                    const readonly = this.getType().isPointerType() || !this.value.isWritable() && (addressSpace === PBAddressSpace.PRIVATE || addressSpace === PBAddressSpace.FUNCTION);
                    const moduleScope = addressSpace === PBAddressSpace.PRIVATE;
                    const storageAccessMode = addressSpace === PBAddressSpace.STORAGE && this.value.isWritable() ? ', read_write' : '';
                    const decorator = addressSpace !== PBAddressSpace.FUNCTION ? `<${addressSpace}${storageAccessMode}>` : '';
                    prefix = readonly ? moduleScope ? 'const ' : 'let ' : `var${decorator} `;
                    break;
                }
        }
        {
            // const decl = this.value.value.$global ? this.getType().toTypeName('webgpu', this.value.name) : this.value.name;
            const type = this.getType();
            if (type.isPointerType() && (this.value.isWritable() || this.value.ref.isWritable())) {
                type.writable = true;
            }
            const decl = type.toTypeName('webgpu', this.value.name);
            return `${prefix}${decl}`;
        }
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTShaderExpConstructor extends ASTExpression {
    /** @internal */ type;
    /** @internal */ args;
    /** @internal */ constExp;
    constructor(type, args){
        super();
        this.type = type;
        this.args = args;
        this.constExp = true;
        for (const arg of args){
            if (arg === null || arg === undefined) {
                throw new Error('invalid constructor argument');
            }
            if (arg instanceof ASTCallFunction) {
                arg.isStatement = false;
            }
            this.constExp &&= !(arg instanceof ASTExpression) || arg.isConstExp();
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.constExp;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        console.assert(!this.type.isArrayType(), 'array constructor not supported in webgl1 device');
        console.assert(this.type.isConstructible(), `type '${this.type.toTypeName('webgl')}' is not constructible`);
        const overloads = this.type.getConstructorOverloads('webgl');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWebGL(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgl')}`);
    }
    toWebGL2(indent, ctx) {
        console.assert(this.type.isConstructible(), `type '${this.type.toTypeName('webgl2')}' is not constructible`, true);
        const overloads = this.type.getConstructorOverloads('webgl2');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWebGL2(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgl2')}`);
    }
    toWGSL(indent, ctx) {
        /*
    console.assert(
      this.type.isConstructible(),
      `type '${this.type.toTypeName('webgpu')}' is not constructible`,
      true
    );
    */ const overloads = this.type.getConstructorOverloads('webgpu');
        for (const overload of overloads){
            const convertedArgs = convertArgs(this.args, overload);
            if (convertedArgs) {
                const c = convertedArgs.args.map((arg)=>unbracket(arg.toWGSL(indent, ctx))).join(',');
                return `${convertedArgs.name}(${c})`;
            }
        }
        throw new Error(`no matching overload function found for type ${this.type.toTypeName('webgpu')}`);
    }
    toString(deviceType) {
        return 'constructor';
    }
}
/** @internal */ class ASTScalar extends ASTExpression {
    /** @internal */ value;
    /** @internal */ type;
    constructor(value, type){
        super();
        this.value = value;
        this.type = type;
        if (typeof value === 'number') {
            if (type.primitiveType === PBPrimitiveType.BOOL) {
                throw new PBTypeCastError(value, typeof value, type);
            }
            if (type.primitiveType === PBPrimitiveType.I32 && (!Number.isInteger(value) || value < 0x80000000 >> 0 || value > 0xffffffff)) {
                throw new PBTypeCastError(value, typeof value, type);
            }
            if (value < 0 && type.primitiveType === PBPrimitiveType.U32 && (!Number.isInteger(value) || value < 0 || value > 0xffffffff)) {
                throw new PBTypeCastError(value, typeof value, type);
            }
        } else if (type.primitiveType !== PBPrimitiveType.BOOL) {
            throw new PBTypeCastError(value, typeof value, type);
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return true;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return toUint(this.value);
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toWebGL2(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return `${toUint(this.value)}u`;
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toWGSL(indent, ctx) {
        switch(this.type.primitiveType){
            case PBPrimitiveType.F32:
                return toFixed(this.value);
            case PBPrimitiveType.I32:
                return toInt(this.value);
            case PBPrimitiveType.U32:
                return `${toUint(this.value)}u`;
            case PBPrimitiveType.BOOL:
                return String(!!this.value);
            default:
                throw new Error('Invalid scalar type');
        }
    }
    toString(deviceType) {
        return `${this.value}`;
    }
}
/** @internal */ class ASTHash extends ASTExpression {
    /** @internal */ source;
    /** @internal */ field;
    /** @internal */ type;
    constructor(source, field, type){
        super();
        this.source = source;
        this.field = field;
        this.type = type;
        if (this.source instanceof ASTCallFunction) {
            this.source.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    isReference() {
        return this.source.isReference();
    }
    isConstExp() {
        return this.source.isConstExp();
    }
    markWritable() {
        this.source.markWritable();
    }
    isWritable() {
        return this.source.isWritable();
    }
    getAddressSpace() {
        return this.source.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        return `${this.source.toWebGL(indent, ctx)}.${this.field}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.source.toWebGL2(indent, ctx)}.${this.field}`;
    }
    toWGSL(indent, ctx) {
        const source = this.source.isPointer() ? new ASTReferenceOf(this.source) : this.source;
        return `${source.toWGSL(indent, ctx)}.${this.field}`;
    }
    toString(deviceType) {
        const source = this.source.isPointer() ? new ASTReferenceOf(this.source) : this.source;
        return `${source.toString(deviceType)}.${this.field}`;
    }
}
/** @internal */ class ASTCast extends ASTExpression {
    /** @internal */ sourceValue;
    /** @internal */ castType;
    constructor(source, type){
        super();
        this.sourceValue = source;
        this.castType = type;
        if (this.sourceValue instanceof ASTCallFunction) {
            this.sourceValue.isStatement = false;
        }
    }
    getType() {
        return this.castType;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.sourceValue.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgl')}(${unbracket(this.sourceValue.toWebGL(indent, ctx))})`;
        } else {
            return this.sourceValue.toWebGL(indent, ctx);
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgl2')}(${unbracket(this.sourceValue.toWebGL2(indent, ctx))})`;
        } else {
            return this.sourceValue.toWebGL2(indent, ctx);
        }
    }
    toWGSL(indent, ctx) {
        if (!this.castType.isCompatibleType(this.sourceValue.getType())) {
            return `${this.castType.toTypeName('webgpu')}(${unbracket(this.sourceValue.toWGSL(indent, ctx))})`;
        } else {
            return this.sourceValue.toWGSL(indent, ctx);
        }
    }
    toString(deviceType) {
        return `${this.castType.toTypeName(deviceType)}(${unbracket(this.sourceValue.toString(deviceType))})`;
    }
}
/** @internal */ class ASTAddressOf extends ASTExpression {
    /** @internal */ value;
    /** @internal */ type;
    constructor(value){
        super();
        console.assert(value.isReference(), 'no pointer type for non-reference values', true);
        this.value = value;
        this.type = new PBPointerTypeInfo(value.getType(), value.getAddressSpace());
    }
    getType() {
        return this.type;
    }
    isConstExp() {
        return false;
    }
    markWritable() {
        const addressSpace = this.value.getAddressSpace();
        if (addressSpace === PBAddressSpace.UNIFORM) {
            throw new PBASTError(this.value, 'uniforms are not writable');
        }
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    getAddressSpace() {
        return this.value.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        throw new Error('GLSL does not support pointer type');
    }
    toWebGL2(indent, ctx) {
        throw new Error('GLSL does not support pointer type');
    }
    toWGSL(indent, ctx) {
        const ast = this.value instanceof ASTFunctionParameter ? this.value.paramAST : this.value;
        return ast instanceof ASTReferenceOf ? ast.value.toWGSL(indent, ctx) : `(&${ast.toWGSL(indent, ctx)})`;
    }
    toString(deviceType) {
        const ast = this.value instanceof ASTFunctionParameter ? this.value.paramAST : this.value;
        return ast instanceof ASTReferenceOf ? ast.value.toString(deviceType) : `(&${ast.toString(deviceType)})`;
    }
}
/** @internal */ class ASTReferenceOf extends ASTExpression {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        const type = this.value.getType();
        return type.isPointerType() ? type.pointerType : type;
    }
    isReference() {
        return true;
    }
    markWritable() {
        this.value.markWritable();
    }
    isWritable() {
        return this.value.isWritable();
    }
    isConstExp() {
        return false;
    }
    getAddressSpace() {
        return this.value instanceof ASTExpression ? this.value.getAddressSpace() : null;
    }
    toWebGL(indent, ctx) {
        return this.value.toWebGL(indent, ctx);
    }
    toWebGL2(indent, ctx) {
        return this.value.toWebGL2(indent, ctx);
    }
    toWGSL(indent, ctx) {
        return this.value.getType().isPointerType() ? `(*${this.value.toWGSL(indent, ctx)})` : this.value.toWGSL(indent, ctx);
    }
    toString(deviceType) {
        return `*${this.value.toString(deviceType)}`;
    }
}
/** @internal */ class ASTUnaryFunc extends ASTExpression {
    /** @internal */ value;
    /** @internal */ op;
    /** @internal */ type;
    constructor(value, op, type){
        super();
        this.value = value;
        this.op = op;
        this.type = type;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.value.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `${this.op}${this.value.toWebGL(indent, ctx)}`;
    }
    toWebGL2(indent, ctx) {
        return `${this.op}${this.value.toWebGL2(indent, ctx)}`;
    }
    toWGSL(indent, ctx) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${this.op}${value.toWGSL(indent, ctx)}`;
    }
    toString(deviceType) {
        const value = this.value.isPointer() ? new ASTReferenceOf(this.value) : this.value;
        return `${this.op}${value.toString(deviceType)}`;
    }
}
/** @internal */ class ASTBinaryFunc extends ASTExpression {
    /** @internal */ left;
    /** @internal */ right;
    /** @internal */ type;
    /** @internal */ op;
    constructor(left, right, op, type){
        super();
        this.left = left;
        this.right = right;
        this.op = op;
        this.type = type;
        if (this.left instanceof ASTCallFunction) {
            this.left.isStatement = false;
        }
        if (this.right instanceof ASTCallFunction) {
            this.right.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    isConstExp() {
        return this.left.isConstExp() && this.right.isConstExp();
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `(${this.left.toWebGL(indent, ctx)} ${this.op} ${this.right.toWebGL(indent, ctx)})`;
    }
    toWebGL2(indent, ctx) {
        return `(${this.left.toWebGL2(indent, ctx)} ${this.op} ${this.right.toWebGL2(indent, ctx)})`;
    }
    toWGSL(indent, ctx) {
        const left = this.left.isPointer() ? new ASTReferenceOf(this.left) : this.left;
        const right = this.right.isPointer() ? new ASTReferenceOf(this.right) : this.right;
        return `(${left.toWGSL(indent, ctx)} ${this.op} ${right.toWGSL(indent, ctx)})`;
    }
    toString(deviceType) {
        const left = this.left.isPointer() ? new ASTReferenceOf(this.left) : this.left;
        const right = this.right.isPointer() ? new ASTReferenceOf(this.right) : this.right;
        return `(${left.toString(deviceType)} ${this.op} ${right.toString(deviceType)})`;
    }
}
/** @internal */ class ASTArrayIndex extends ASTExpression {
    /** @internal */ source;
    /** @internal */ index;
    /** @internal */ type;
    constructor(source, index, type){
        super();
        this.source = source;
        this.index = index;
        this.type = type;
        if (this.source instanceof ASTCallFunction) {
            this.source.isStatement = false;
        }
        if (this.index instanceof ASTCallFunction) {
            this.index.isStatement = false;
        }
    }
    getType() {
        return this.type;
    }
    isReference() {
        return this.source.isReference();
    }
    markWritable() {
        this.source.markWritable();
    }
    isWritable() {
        return this.source.isWritable();
    }
    isConstExp() {
        return this.source.isConstExp() && this.index.isConstExp();
    }
    getAddressSpace() {
        return this.source.getAddressSpace();
    }
    toWebGL(indent, ctx) {
        return `${this.source.toWebGL(indent, ctx)}[${unbracket(this.index.toWebGL(indent, ctx))}]`;
    }
    toWebGL2(indent, ctx) {
        return `${this.source.toWebGL2(indent, ctx)}[${unbracket(this.index.toWebGL2(indent, ctx))}]`;
    }
    toWGSL(indent, ctx) {
        return `${this.source.toWGSL(indent, ctx)}[${unbracket(this.index.toWGSL(indent, ctx))}]`;
    }
    toString(deviceType) {
        return `${this.source.toString(deviceType)}[${unbracket(this.index.toString(deviceType))}]`;
    }
}
/** @internal */ class ASTTouch extends ShaderAST {
    /** @internal */ value;
    constructor(value){
        super();
        if (value.getType().isVoidType()) {
            throw new Error('can not touch void type');
        }
        if (value instanceof ASTCallFunction) {
            value.isStatement = false;
        }
        this.value = value;
    }
    toWebGL(indent, ctx) {
        return `${indent}${this.value.toWebGL('', ctx)};\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}${this.value.toWebGL2('', ctx)};\n`;
    }
    toWGSL(indent, ctx) {
        if (!this.value.getType().isVoidType()) {
            return `${indent}_ = ${this.value.toWGSL('', ctx)};\n`;
        } else {
            return `${indent}${this.value.toWGSL('', ctx)};\n`;
        }
    }
}
/** @internal */ class ASTSelect extends ASTExpression {
    /** @internal */ condition;
    /** @internal */ first;
    /** @internal */ second;
    /** @internal */ type;
    constructor(condition, first, second){
        super();
        this.condition = condition instanceof ASTExpression ? condition : new ASTScalar(condition, typeBool);
        let firstType = null;
        let secondType = null;
        if (first instanceof ASTExpression) {
            firstType = first.getType();
            this.first = first;
            if (first instanceof ASTCallFunction) {
                first.isStatement = false;
            }
        } else if (typeof first === 'number') {
            if (!Number.isInteger(first)) {
                this.first = new ASTScalar(first, typeF32);
                firstType = typeF32;
            }
        } else if (typeof first === 'boolean') {
            this.first = new ASTScalar(first, typeBool);
            firstType = typeBool;
        } else {
            throw new Error('select: invalid first value');
        }
        if (second instanceof ASTExpression) {
            secondType = second.getType();
            this.second = second;
            if (second instanceof ASTCallFunction) {
                second.isStatement = false;
            }
        } else if (typeof second === 'number') {
            if (!Number.isInteger(second)) {
                this.second = new ASTScalar(second, typeF32);
                secondType = typeF32;
            }
        } else if (typeof second === 'boolean') {
            this.second = new ASTScalar(second, typeBool);
            secondType = typeBool;
        } else {
            throw new Error('select: invalid second value');
        }
        if (!firstType && !secondType) {
            throw new Error('select: cannot determine the value types');
        }
        if (firstType && secondType) {
            if (!firstType.isCompatibleType(secondType)) {
                throw new Error('select: first value and second value must be the same type');
            } else {
                this.type = firstType;
            }
        } else if (!firstType) {
            if (secondType.typeId === typeF32.typeId) {
                this.first = new ASTScalar(first, typeF32);
            } else if (secondType.typeId === typeI32.typeId) {
                this.first = new ASTScalar(first, typeI32);
            } else if (secondType.typeId === typeU32$1.typeId) {
                this.first = new ASTScalar(first, typeU32$1);
            } else {
                throw new Error('select: invalid type of the first value');
            }
            this.type = secondType;
        } else {
            if (firstType.typeId === typeF32.typeId) {
                this.second = new ASTScalar(second, typeF32);
            } else if (firstType.typeId === typeI32.typeId) {
                this.second = new ASTScalar(second, typeI32);
            } else if (firstType.typeId === typeU32$1.typeId) {
                this.second = new ASTScalar(second, typeU32$1);
            } else {
                throw new Error('select: invalid type of the second value');
            }
            this.type = firstType;
        }
    }
    getType() {
        return this.type;
    }
    isConstExp() {
        return false;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        return `${indent}(${this.condition.toWebGL('', ctx)} ? ${this.first.toWebGL('', ctx)} : ${this.second.toWebGL('', ctx)})`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}(${this.condition.toWebGL2('', ctx)} ? ${this.first.toWebGL2('', ctx)} : ${this.second.toWebGL2('', ctx)})`;
    }
    toWGSL(indent, ctx) {
        return `${indent}select(${this.second.toWGSL('', ctx)}, ${this.first.toWGSL('', ctx)}, ${this.condition.toWGSL('', ctx)})`;
    //return `${indent}${this.condition.toWGSL('', ctx)} ? ${this.first.toWGSL('', ctx)} : ${this.second.toWGSL('', ctx)}`;
    }
}
/** @internal */ class ASTAssignment extends ShaderAST {
    /** @internal */ lvalue;
    /** @internal */ rvalue;
    constructor(lvalue, rvalue){
        super();
        if (!lvalue.isReference()) {
            throw new Error('assignment: l-value required');
        }
        this.lvalue = lvalue;
        this.rvalue = rvalue;
        if (!(this.lvalue instanceof ASTLValueDeclare)) {
            if (this.lvalue.getType().isPointerType()) {
                throw new PBASTError(this.lvalue, 'cannot assign to read-only variable');
            }
            this.lvalue.markWritable();
        } else if (this.lvalue.getType().isPointerType()) {
            if (this.rvalue instanceof ASTPrimitive) {
                this.lvalue.value.ref = this.rvalue.ref;
            } else if (this.rvalue instanceof ASTAddressOf) {
                this.lvalue.value.ref = this.rvalue.value;
            } else {
                throw new PBASTError(this.lvalue, 'invalid pointer assignment');
            }
        } else if (this.rvalue instanceof ASTExpression) {
            this.lvalue.value.constExp = this.rvalue.isConstExp();
        }
        if (this.rvalue instanceof ASTCallFunction) {
            this.rvalue.isStatement = false;
        }
    }
    getType() {
        return null;
    }
    toWebGL(indent, ctx) {
        let rhs = null;
        const ltype = this.lvalue.getType();
        const rtype = this.checkScalarType(this.rvalue, ltype);
        if (!ltype.isCompatibleType(rtype)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgl') : `${this.rvalue}`, rtype, ltype);
        }
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWebGL(indent, ctx));
        }
        if (this.lvalue instanceof ASTLValueDeclare) {
            this.lvalue.value.constExp &&= !(this.rvalue instanceof ASTExpression) || this.rvalue.isConstExp();
        }
        return `${indent}${this.lvalue.toWebGL(indent, ctx)} = ${rhs};\n`;
    }
    toWebGL2(indent, ctx) {
        let rhs = null;
        const ltype = this.lvalue.getType();
        const rtype = this.checkScalarType(this.rvalue, ltype);
        if (!ltype.isCompatibleType(rtype)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgl2') : `${this.rvalue}`, rtype, ltype);
        }
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWebGL2(indent, ctx));
        }
        if (this.lvalue instanceof ASTLValueDeclare) {
            this.lvalue.value.constExp &&= !(this.rvalue instanceof ASTExpression) || this.rvalue.isConstExp();
        }
        return `${indent}${this.lvalue.toWebGL2(indent, ctx)} = ${rhs};\n`;
    }
    toWGSL(indent, ctx) {
        const ltype = this.lvalue.getType();
        const [valueTypeLeft, lvalueIsPtr] = ltype.isPointerType() ? [
            ltype.pointerType,
            true
        ] : [
            ltype,
            false
        ];
        const rtype = this.checkScalarType(this.rvalue, valueTypeLeft);
        const rvalueIsPtr = rtype && rtype.isPointerType();
        const valueTypeRight = rvalueIsPtr ? rtype.pointerType : rtype;
        if (!valueTypeLeft.isCompatibleType(valueTypeRight)) {
            throw new PBTypeCastError(this.rvalue instanceof ASTExpression ? this.rvalue.toString('webgpu') : `${this.rvalue}`, rtype, ltype);
        }
        if (this.lvalue instanceof ASTLValueScalar || this.lvalue instanceof ASTLValueDeclare) {
            const structName = valueTypeLeft.isStructType() ? valueTypeLeft.structName : null;
            if (structName && ctx.types.findIndex((val)=>val instanceof ASTStructDefine && val.type.structName === structName) < 0) {
                return '';
            }
        }
        let rhs;
        if (typeof this.rvalue === 'number' || typeof this.rvalue === 'boolean') {
            rhs = rtype.primitiveType === PBPrimitiveType.F32 ? toFixed(this.rvalue) : String(this.rvalue);
        } else {
            rhs = unbracket(this.rvalue.toWGSL(indent, ctx));
        }
        const name = this.lvalue.toWGSL(indent, ctx);
        if (lvalueIsPtr && !rvalueIsPtr) {
            if (this.lvalue instanceof ASTLValueDeclare) {
                throw new Error(`rvalue must be pointer type: ${rhs}`);
            } else {
                return `${indent}*(${name}) = ${rhs};\n`;
            }
        } else if (rvalueIsPtr && !lvalueIsPtr) {
            return `${indent}${name} = *(${rhs});\n`;
        } else {
            return `${indent}${name} = ${rhs};\n`;
        }
    }
    checkScalarType(value, targetType) {
        if (value instanceof ASTExpression) {
            return value.getType();
        }
        const isBool = typeof value === 'boolean';
        const isInt = typeof value === 'number' && Number.isInteger(value) && value >= 0x80000000 >> 0 && value <= 0x7fffffff;
        const isUint = typeof value === 'number' && Number.isInteger(value) && value >= 0 && value <= 0xffffffff;
        const isFloat = typeof value === 'number';
        if (targetType.isPrimitiveType()) {
            switch(targetType.primitiveType){
                case PBPrimitiveType.BOOL:
                    return isBool ? targetType : isInt ? typeI32 : isUint ? typeU32$1 : typeF32;
                case PBPrimitiveType.F32:
                    return isFloat ? targetType : typeBool;
                case PBPrimitiveType.I32:
                    return isInt ? targetType : isBool ? typeBool : isUint ? typeU32$1 : typeF32;
                case PBPrimitiveType.U32:
                    return isUint ? targetType : isBool ? typeBool : isInt ? typeI32 : typeF32;
                default:
                    return null;
            }
        } else {
            return isBool ? typeBool : isInt ? typeI32 : isUint ? typeU32$1 : typeF32;
        }
    }
}
/** @internal */ class ASTDiscard extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}discard;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}discard;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}discard;\n`;
    }
}
/** @internal */ class ASTBreak extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}break;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}break;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}break;\n`;
    }
}
/** @internal */ class ASTContinue extends ShaderAST {
    toWebGL(indent, ctx) {
        return `${indent}continue;\n`;
    }
    toWebGL2(indent, ctx) {
        return `${indent}continue;\n`;
    }
    toWGSL(indent, ctx) {
        return `${indent}continue;\n`;
    }
}
/** @internal */ class ASTReturn extends ShaderAST {
    /** @internal */ value;
    constructor(value){
        super();
        this.value = value;
        if (this.value instanceof ASTCallFunction) {
            this.value.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWebGL(indent, ctx))};\n` : `${indent}return;\n`;
    }
    toWebGL2(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWebGL2(indent, ctx))};\n` : `${indent}return;\n`;
    }
    toWGSL(indent, ctx) {
        return this.value ? `${indent}return ${unbracket(this.value.toWGSL(indent, ctx))};\n` : `${indent}return;\n`;
    }
}
/** @internal */ class ASTCallFunction extends ASTExpression {
    /** @internal */ name;
    /** @internal */ args;
    /** @internal */ retType;
    /** @internal */ func;
    /** @internal */ isStatement;
    constructor(name, args, func, deviceType, retType){
        super();
        this.name = name;
        this.args = args;
        this.retType = func?.returnType ?? retType ?? typeVoid;
        this.func = func;
        this.isStatement = true;
        if (func) {
            if (func.funcType.argTypes.length !== this.args.length) {
                throw new PBInternalError(`ASTCallFunction(): number of parameters mismatch`);
            }
            for(let i = 0; i < this.args.length; i++){
                const funcArg = func.funcType.argTypes[i];
                if (funcArg.byRef) {
                    if (deviceType === 'webgpu') {
                        const argAddressSpace = args[i].getAddressSpace();
                        if (argAddressSpace !== PBAddressSpace.FUNCTION && argAddressSpace !== PBAddressSpace.PRIVATE) {
                            throw new PBParamTypeError(name, 'pointer type of function parameter must be function or private');
                        }
                        const argType = funcArg.type;
                        if (!argType.isPointerType()) {
                            throw new PBInternalError(`ASTCallFunction(): invalid reference type`);
                        }
                        if (argType.addressSpace === PBAddressSpace.UNKNOWN) {
                            argType.addressSpace = argAddressSpace;
                        } else if (argType.addressSpace !== argAddressSpace) {
                            throw new PBParamTypeError(name, `invalid pointer parameter address space '${argAddressSpace}', should be '${argType.addressSpace}`);
                        }
                    }
                    this.args[i].markWritable();
                }
            }
        }
        for (const arg of this.args){
            if (arg instanceof ASTCallFunction) {
                arg.isStatement = false;
            }
        }
    }
    getType() {
        return this.retType;
    }
    isConstExp() {
        return false;
    }
    markWritable() {}
    isWritable() {
        return false;
    }
    getAddressSpace() {
        return null;
    }
    toWebGL(indent, ctx) {
        if (this.name === 'dFdx' || this.name === 'dFdy' || this.name === 'fwidth') {
            ctx.extensions.add('GL_OES_standard_derivatives');
        } else if (this.name === 'texture2DLodEXT' || this.name === 'texture2DProjLodEXT' || this.name === 'textureCubeLodEXT' || this.name === 'texture2DGradEXT' || this.name === 'texture2DProjGradEXT' || this.name === 'textureCubeGradEXT') {
            ctx.extensions.add('GL_EXT_shader_texture_lod');
        }
        const args = this.args.map((arg)=>unbracket(arg.toWebGL(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toWebGL2(indent, ctx) {
        const args = this.args.map((arg)=>unbracket(arg.toWebGL2(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toWGSL(indent, ctx) {
        let thisArgs = this.args;
        if (this.func) {
            let argsNew;
            const convertedArgs = convertArgs(thisArgs, this.func.funcType);
            if (convertedArgs) {
                argsNew = convertedArgs.args;
            }
            if (!argsNew) {
                throw new Error(`no matching overloading found for function '${this.name}'`);
            }
            thisArgs = argsNew.filter((val)=>{
                const type = val.getType();
                if (type.isStructType() && ctx.types.findIndex((t)=>t instanceof ASTStructDefine && t.type.structName === type.structName) < 0) {
                    return false;
                }
                return true;
            });
        }
        const args = thisArgs.map((arg)=>unbracket(arg.toWGSL(indent, ctx)));
        return `${this.isStatement ? indent : ''}${this.name}(${args.join(',')})${this.isStatement ? ';\n' : ''}`;
    }
    toString(deviceType) {
        return `${this.name}(...)`;
    }
}
/** @internal */ class ASTDeclareVar extends ShaderAST {
    /** @internal */ value;
    /** @internal */ group;
    /** @internal */ binding;
    /** @internal */ blockName;
    constructor(exp){
        super();
        this.value = exp;
        this.group = 0;
        this.binding = 0;
    }
    isReference() {
        return true;
    }
    isPointer() {
        return this.value.getType().isPointerType();
    }
    toWebGL(indent, ctx) {
        let prefix = '';
        let builtin = false;
        let valueType = this.value.getType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
                if (ctx.type === ShaderType.Vertex) {
                    prefix = 'attribute ';
                    ctx.defines.push(`#define ${this.value.name} ${semanticToAttrib(ctx.vertexAttributes[this.value.value.$location])}\n`);
                } else {
                    prefix = 'varying ';
                // ctx.defines.push(`#define ${this.value.$str} ch_varying_${this.value.$location}\n`);
                }
                break;
            case DeclareType.DECLARE_TYPE_OUT:
                if (ctx.type === ShaderType.Vertex) {
                    prefix = 'varying ';
                // ctx.defines.push(`#define ${this.value.$str} ch_varying_${this.value.$location}\n`);
                } else {
                    builtin = true;
                    if (ctx.mrt) {
                        ctx.defines.push(`#define ${this.value.name} gl_FragData[${this.value.value.$location}]\n`);
                        ctx.extensions.add('GL_EXT_draw_buffers');
                    } else {
                        ctx.defines.push(`#define ${this.value.name} gl_FragColor\n`);
                    }
                }
                break;
            case DeclareType.DECLARE_TYPE_UNIFORM:
                prefix = 'uniform ';
                valueType = ctx.typeReplacement?.get(this.value.value) || valueType;
                break;
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error(`invalid variable declare type: ${this.value.name}`);
        }
        if (!builtin) {
            return `${indent}${prefix}${valueType.toTypeName('webgl', this.value.name)};\n`;
        }
    }
    toWebGL2(indent, ctx) {
        let prefix = '';
        let valueType = this.value.getType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
                if (ctx.type === ShaderType.Fragment && valueType.isPrimitiveType() && valueType.isInteger()) {
                    prefix = 'flat in ';
                } else {
                    prefix = 'in ';
                }
                if (ctx.type === ShaderType.Vertex) {
                    ctx.defines.push(`#define ${this.value.name} ${semanticToAttrib(ctx.vertexAttributes[this.value.value.$location])}\n`);
                }
                break;
            case DeclareType.DECLARE_TYPE_OUT:
                if (ctx.type === ShaderType.Vertex) {
                    if (valueType.isPrimitiveType() && valueType.isInteger()) {
                        prefix = 'flat out ';
                    } else {
                        prefix = 'out ';
                    }
                } else {
                    prefix = `layout(location = ${this.value.value.$location}) out `;
                }
                break;
            case DeclareType.DECLARE_TYPE_UNIFORM:
                if (valueType.isStructType()) {
                    /*
          if (valueType.layout !== 'std140') {
            throw new errors.PBASTError(this, 'uniform buffer layout must be std140');
          }
          */ return `${indent}layout(std140) uniform ${this.blockName} { ${valueType.structName} ${this.value.name}; };\n`;
                } else {
                    valueType = ctx.typeReplacement?.get(this.value.value) || valueType;
                    return `${indent}uniform ${valueType.toTypeName('webgl2', this.value.name)};\n`;
                }
            case DeclareType.DECLARE_TYPE_STORAGE:
                throw new Error(`invalid variable declare type: ${this.value.name}`);
        }
        {
            return `${indent}${prefix}${this.value.getType().toTypeName('webgl2', this.value.name)};\n`;
        }
    }
    toWGSL(indent, ctx) {
        let prefix;
        const isBlock = this.value.getType().isPrimitiveType() || this.value.getType().isStructType() || this.value.getType().isArrayType();
        switch(this.value.value.$declareType){
            case DeclareType.DECLARE_TYPE_IN:
            case DeclareType.DECLARE_TYPE_OUT:
                // prefix = `@location(${this.value.value.$location}) var<out> `;
                throw new Error(`Internal error`);
            case DeclareType.DECLARE_TYPE_UNIFORM:
                prefix = `@group(${this.group}) @binding(${this.binding}) var${isBlock ? '<uniform>' : ''} `;
                break;
            case DeclareType.DECLARE_TYPE_STORAGE:
                prefix = `@group(${this.group}) @binding(${this.binding}) var<storage, ${this.value.value.$readonly ? 'read' : 'read_write' //this.value.isWritable() || this.value.getType().haveAtomicMembers() ? 'read_write' : 'read'
                }> `;
                break;
            case DeclareType.DECLARE_TYPE_WORKGROUP:
                prefix = `var<workgroup> `;
                break;
            default:
                prefix = `${this.value.getType().isPointerType() ? 'let' : 'var'}${this.value.value.$global && !this.value.getType().isPointerType() ? '<private>' : ''} `;
        }
        {
            const type = this.value.getType();
            const structName = type.isStructType() ? type.structName : null;
            if (structName && ctx.types.findIndex((val)=>val instanceof ASTStructDefine && val.type.structName === structName) < 0) {
                return '';
            } else {
                return `${indent}${prefix}${type.toTypeName('webgpu', this.value.name)};\n`;
            }
        }
    }
    toString(deviceType) {
        return this.value.toString(deviceType);
    }
}
/** @internal */ class ASTFunction extends ASTScope {
    /** @internal */ name;
    /** @internal */ args;
    /** @internal */ isBuiltin;
    /** @internal */ isMainFunc;
    /** @internal */ funcType;
    /** @internal */ builtins;
    /** @internal */ returnType;
    constructor(name, args, isMainFunc, type, isBuiltin = false){
        super();
        this.name = name;
        this.args = args;
        this.funcType = type;
        this.builtins = [];
        this.isBuiltin = isBuiltin;
        this.isMainFunc = isMainFunc;
        this.returnType = type ? type.returnType : null;
    }
    toWebGL(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [];
            for (const param of this.args){
                let exp;
                let name;
                let qualifier;
                if (param.paramAST instanceof ASTPrimitive) {
                    exp = param.paramAST.value;
                    name = param.paramAST.name;
                    qualifier = '';
                } else {
                    exp = param.paramAST.value.value;
                    name = param.paramAST.value.name;
                    qualifier = `${exp.$inout} `;
                }
                p.push(`${qualifier}${param.getType().toTypeName('webgl', name)}`);
            }
            str += `${indent}${this.returnType.toTypeName('webgl')} ${this.name}(${p.join(',')}) {\n`;
            str += super.toWebGL(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [];
            for (const param of this.args){
                let exp;
                let name;
                let qualifier;
                if (param.paramAST instanceof ASTPrimitive) {
                    exp = param.paramAST.value;
                    name = param.paramAST.name;
                    qualifier = '';
                } else {
                    exp = param.paramAST.value.value;
                    name = param.paramAST.value.name;
                    qualifier = `${exp.$inout} `;
                }
                p.push(`${qualifier}${param.getType().toTypeName('webgl2', name)}`);
            }
            str += `${indent}${this.returnType.toTypeName('webgl2')} ${this.name}(${p.join(',')}) {\n`;
            str += super.toWebGL2(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
    toWGSL(indent, ctx) {
        if (!this.isBuiltin) {
            let str = '';
            const p = [
                ...this.builtins
            ];
            for (const param of this.args){
                const name = param.paramAST instanceof ASTPrimitive ? param.paramAST.name : param.paramAST.value.name;
                const paramType = param.paramAST instanceof ASTPrimitive ? param.paramAST.getType() : param.paramAST.value.getType();
                const dataType = paramType.isPointerType() ? paramType.pointerType : paramType;
                if (dataType.isStructType() && ctx.types.findIndex((t)=>t instanceof ASTStructDefine && t.type.structName === dataType.structName) < 0) {
                    continue;
                }
                p.push(`${paramType.toTypeName('webgpu', name)}`);
            }
            let t = '';
            if (this.isMainFunc) {
                switch(ctx.type){
                    case ShaderType.Vertex:
                        t = '@vertex ';
                        break;
                    case ShaderType.Fragment:
                        t = '@fragment ';
                        break;
                    case ShaderType.Compute:
                        t = `@compute @workgroup_size(${ctx.workgroupSize[0]}, ${ctx.workgroupSize[1]}, ${ctx.workgroupSize[2]}) `;
                        break;
                }
            }
            const retName = this.returnType.isVoidType() ? null : this.returnType.toTypeName('webgpu');
            const retStr = retName ? ` -> ${retName}` : '';
            str += `${indent}${t}fn ${this.name}(${p.join(',')})${retStr} {\n`;
            str += super.toWGSL(indent + '  ', ctx);
            str += `${indent}}\n`;
            return str;
        } else {
            return '';
        }
    }
}
/** @internal */ class ASTIf extends ASTScope {
    /** @internal */ keyword;
    /** @internal */ condition;
    /** @internal */ nextElse;
    constructor(keyword, condition){
        super();
        this.keyword = keyword;
        this.condition = condition;
        this.nextElse = null;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWebGL(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWebGL(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWebGL(indent, ctx);
        }
        return str;
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWebGL2(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWebGL2(indent, ctx);
        }
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}${this.keyword} ${this.condition ? '(' + unbracket(this.condition.toWGSL(indent, ctx)) + ')' : ''} {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        if (this.nextElse) {
            str += this.nextElse.toWGSL(indent, ctx);
        }
        return str;
    }
}
/** @internal */ class ASTRange extends ASTScope {
    /** @internal */ init;
    /** @internal */ start;
    /** @internal */ end;
    /** @internal */ open;
    constructor(init, start, end, open){
        super();
        this.init = init;
        this.start = start;
        this.end = end;
        this.open = open;
        this.statements = [];
        if (this.start instanceof ASTCallFunction) {
            this.start.isStatement = false;
        }
        if (this.end instanceof ASTCallFunction) {
            this.end.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        const init = this.init.getType().toTypeName('webgl', this.init.name);
        const start = unbracket(this.start.toWebGL(indent, ctx));
        const end = unbracket(this.end.toWebGL(indent, ctx));
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name}++) {\n`;
        str += super.toWebGL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWebGL2(indent, ctx) {
        const init = this.init.getType().toTypeName('webgl2', this.init.name);
        const start = unbracket(this.start.toWebGL2(indent, ctx));
        const end = unbracket(this.end.toWebGL2(indent, ctx));
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name}++) {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        const init = `var ${this.init.getType().toTypeName('webgpu', this.init.name)}`;
        const start = unbracket(this.start.toWGSL(indent, ctx));
        const end = unbracket(this.end.toWGSL(indent, ctx));
        const incr = new ASTScalar(1, this.init.getType()).toWGSL(indent, ctx);
        const comp = this.open ? '<' : '<=';
        let str = `${indent}for (${init} = ${start}; ${this.init.name} ${comp} ${end}; ${this.init.name} = ${this.init.name} + ${incr}) {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
}
/** @internal */ class ASTDoWhile extends ASTScope {
    /** @internal */ condition;
    constructor(condition){
        super();
        this.condition = condition;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        throw new Error(`No do-while() loop support for WebGL1.0 device`);
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}do {\n`;
        str += super.toWebGL2(indent + ' ', ctx);
        str += `${indent}} while(${unbracket(this.condition.toWebGL2(indent, ctx))});\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}loop {\n`;
        str += super.toWGSL(indent + ' ', ctx);
        str += `${indent}  if (!(${unbracket(this.condition.toWGSL(indent, ctx))})) { break; }\n`;
        str += `${indent}}\n`;
        return str;
    }
}
/** @internal */ class ASTWhile extends ASTScope {
    /** @internal */ condition;
    constructor(condition){
        super();
        this.condition = condition;
        if (this.condition instanceof ASTCallFunction) {
            this.condition.isStatement = false;
        }
    }
    toWebGL(indent, ctx) {
        let str = `${indent}for(int z_tmp_counter = 0; z_tmp_counter == 0; z_tmp_counter += 0) {\n`;
        const indent2 = indent + '  ';
        str += `${indent2}if(!(${unbracket(this.condition.toWebGL(indent, ctx))})){ break; }\n`;
        str += super.toWebGL(indent2, ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWebGL2(indent, ctx) {
        let str = `${indent}while(${unbracket(this.condition.toWebGL2(indent, ctx))}) {\n`;
        str += super.toWebGL2(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    }
    toWGSL(indent, ctx) {
        let str = `${indent}for(;${unbracket(this.condition.toWGSL(indent, ctx))};) {\n`;
        str += super.toWGSL(indent + '  ', ctx);
        str += `${indent}}\n`;
        return str;
    /*
    let str = `${indent}loop {\n`;
    const newIndent = indent + '  ';
    str += `${newIndent}if (!(${unbracket(this.condition.toWGSL(indent, ctx))})) { break; }\n`;
    str += super.toWGSL(newIndent, ctx);
    str += `${indent}}\n`;
    return str;
    */ }
}
/** @internal */ class ASTStructDefine extends ShaderAST {
    /** @internal */ type;
    /** @internal */ prefix;
    /** @internal */ builtin;
    constructor(type, builtin){
        super();
        this.prefix = null;
        this.builtin = builtin;
        this.type = type;
    }
    getType() {
        return this.type;
    }
    toWebGL(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            for (const arg of this.type.structMembers){
                str += `${indent}  ${arg.type.toTypeName('webgl', arg.name)};\n`;
            }
            str += `${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
    toWebGL2(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            for (const arg of this.type.structMembers){
                str += `${indent}  ${arg.type.toTypeName('webgl2', arg.name)};\n`;
            }
            str += `${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
    toWGSL(indent, ctx) {
        if (!this.builtin) {
            let str = `${indent}struct ${this.type.structName} {\n`;
            str += this.type.structMembers.map((arg, i)=>{
                const prefix = this.prefix ? this.prefix[i] : '';
                const sizePrefix = arg.type.getLayoutSize(this.type.layout) !== arg.type.getLayoutSize('default') ? `@size(${arg.type.getLayoutSize(this.type.layout)}) ` : '';
                const alignPrefix = i > 0 && arg.type.getLayoutAlignment(this.type.layout) !== arg.type.getLayoutAlignment('default') ? `@align(${arg.type.getLayoutAlignment(this.type.layout)}) ` : '';
                return `${indent}  ${prefix}${alignPrefix}${sizePrefix}${arg.type.toTypeName('webgpu', arg.name)}`;
            }).join(',\n');
            str += `\n${indent}};\n`;
            return str;
        } else {
            return '';
        }
    }
}
function convertArgs(args, overload) {
    if (args.length !== overload.argTypes.length) {
        return null;
    }
    const result = [];
    for(let i = 0; i < args.length; i++){
        const isRef = !!overload.argTypes[i].byRef;
        const argType = isRef ? overload.argTypes[i].type.pointerType : overload.argTypes[i].type;
        const arg = args[i];
        if (typeof arg === 'number') {
            if (!isRef && argType.isPrimitiveType() && argType.isScalarType() && argType.primitiveType !== PBPrimitiveType.BOOL) {
                result.push(new ASTScalar(arg, argType));
            } else {
                return null;
            }
        } else if (typeof arg === 'boolean') {
            if (!isRef && argType.isPrimitiveType() && argType.primitiveType === PBPrimitiveType.BOOL) {
                result.push(new ASTScalar(arg, argType));
            } else {
                return null;
            }
        } else if (argType.isCompatibleType(arg.getType())) {
            if (isRef) {
                arg.markWritable();
                result.push(new ASTAddressOf(arg));
            } else {
                result.push(arg);
            }
        } else {
            return null;
        }
    }
    return {
        name: overload.name,
        args: result
    };
}

/**
 * Reflection interface for program builder
 * @public
 */ class PBReflection {
    /** @internal */ _builder;
    /** @internal */ _tagList;
    /** @internal */ _attribList;
    constructor(builder){
        this._builder = builder;
        this._tagList = {};
        this._attribList = {};
    }
    /** Gets all the vertex attributes that was used by the program */ get vertexAttributes() {
        return this._builder.getVertexAttributes();
    }
    /**
   * Check if specified vertex attribute was used by the program
   * @param attrib - The vertex attribute to check
   */ hasVertexAttribute(attrib) {
        return this.vertexAttributes.indexOf(attrib) >= 0;
    }
    /**
   * Clear all contents
   */ clear() {
        this._tagList = {};
        this._attribList = {};
    }
    tag(arg0, arg1) {
        if (typeof arg0 === 'string') {
            if (arg1 === undefined) {
                return this.getTag(arg0);
            } else {
                this.addTag(arg0, arg1);
            }
        } else {
            for (const k of Object.keys(arg0)){
                this.addTag(k, arg0[k]);
            }
        }
    }
    /**
   * Gets the variable which is the vertex attribute of specified semantic
   * @param attrib - The vertex semantic
   */ attribute(attrib) {
        return this._attribList[attrib] || null;
    }
    /** @internal */ setAttrib(attrib, exp) {
        this._attribList[attrib] = exp;
    }
    /** @internal */ addTag(name, exp) {
        this._tagList[name] = exp;
    }
    /** @internal */ getTag(name) {
        const getter = this._tagList[name];
        return getter ? getter(this._builder.getGlobalScope()) : null;
    }
}

let currentProgramBuilder = null;
const constructorCache = new Map();
/** @internal */ function setCurrentProgramBuilder(pb) {
    currentProgramBuilder = pb;
}
/** @internal */ function getCurrentProgramBuilder() {
    return currentProgramBuilder;
}
/** @internal */ function makeConstructor(typeFunc, elementType) {
    const wrappedTypeFunc = new Proxy(typeFunc, {
        get: function(target, prop) {
            if (typeof prop === 'symbol' || prop in target) {
                return target[prop];
            }
            let entries = constructorCache.get(typeFunc);
            if (!entries) {
                entries = {};
                constructorCache.set(typeFunc, entries);
            }
            let ctor = entries[prop];
            if (!ctor) {
                if (elementType.isPrimitiveType() || elementType.isStructType() || elementType.isArrayType() || elementType.isAtomicI32() || elementType.isAtomicU32()) {
                    if (prop === 'ptr') {
                        const pointerType = new PBPointerTypeInfo(elementType, PBAddressSpace.FUNCTION);
                        ctor = function pointerCtor(...args) {
                            if (args.length === 1 && typeof args[0] === 'string') {
                                return new PBShaderExp(args[0], pointerType);
                            } else {
                                throw new Error(`Invalid pointer type constructor`);
                            }
                        };
                    } else {
                        const dim = Number(prop);
                        if (Number.isInteger(dim) && dim >= 0) {
                            const arrayType = new PBArrayTypeInfo(elementType, dim);
                            const arrayTypeFunc = function arrayCtor(...args) {
                                if (args.length === 1 && typeof args[0] === 'string') {
                                    return new PBShaderExp(args[0], arrayType);
                                } else {
                                    const exp = new PBShaderExp('', arrayType);
                                    exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, args.map((arg)=>arg instanceof PBShaderExp ? arg.$ast : arg));
                                    return exp;
                                }
                            };
                            ctor = makeConstructor(arrayTypeFunc, arrayType);
                        }
                    }
                }
            }
            if (ctor) {
                entries[prop] = ctor;
            }
            return ctor;
        }
    });
    return wrappedTypeFunc;
}
/**
 * Base class for proxiable object
 * @public
 */ class Proxiable {
    /** @internal */ proxy;
    constructor(){
        this.proxy = new Proxy(this, {
            get: function(target, prop) {
                return typeof prop === 'string' ? target.$get(prop) : undefined;
            },
            set: function(target, prop, value) {
                return typeof prop === 'string' ? target.$set(prop, value) : false;
            }
        });
        return this.proxy;
    }
    get $thisProxy() {
        return this.proxy;
    }
}
let uidExp = 0;
/**
 * Base class for a expression in the shader
 * @public
 */ class PBShaderExp extends Proxiable {
    /** @internal */ $uid;
    /** @internal */ $str;
    /** @internal */ $location;
    /** @internal */ $typeinfo;
    /** @internal */ $global;
    /** @internal */ $sampleType;
    /** @internal */ $precision;
    /** @internal */ $ast;
    /** @internal */ $inout;
    /** @internal */ $memberCache;
    /** @internal */ $attrib;
    /** @internal */ $tags;
    /** @internal */ $_group;
    /** @internal */ $declareType;
    /** @internal */ $isBuffer;
    /** @internal */ $readonly;
    /** @internal */ $bindingSize;
    /** @internal */ constructor(str, typeInfo){
        super();
        if (!str && typeInfo.isPointerType()) {
            throw new Error('no default constructor for pointer type');
        }
        this.$uid = uidExp++;
        this.$str = str || '';
        this.$location = 0;
        this.$global = false;
        this.$typeinfo = typeInfo;
        this.$qualifier = null;
        this.$precision = ShaderPrecisionType.NONE;
        this.$ast = new ASTPrimitive(this);
        this.$inout = null;
        this.$memberCache = {};
        this.$attrib = null;
        this.$tags = [];
        this.$_group = null;
        this.$declareType = DeclareType.DECLARE_TYPE_NONE;
        this.$isBuffer = false;
        this.$bindingSize = 0;
        this.$readonly = false;
        if (typeInfo.isTextureType()) {
            if (typeInfo.isDepthTexture()) {
                this.$sampleType = 'depth';
            } else {
                const t = getTextureSampleType(typeInfo);
                if (t.primitiveType === PBPrimitiveType.I32) {
                    this.$sampleType = 'sint';
                } else if (t.primitiveType === PBPrimitiveType.U32) {
                    this.$sampleType = 'uint';
                } else {
                    this.$sampleType = 'float';
                }
            }
        }
    }
    get $group() {
        return this.$_group;
    }
    set $group(val) {
        this.$_group = val;
        if (this.$_group === undefined) {
            debugger;
        }
    }
    /**
   * Point out that the variable should be in uniform address space
   * @param group - The bind group index
   * @returns self
   */ uniform(group) {
        this.$declareType = DeclareType.DECLARE_TYPE_UNIFORM;
        this.$group = group;
        this.$isBuffer = false;
        return this;
    }
    /**
   * Point out that the variable should be an uniform buffer
   * @param group - The bind group index
   * @returns self
   */ uniformBuffer(group, bindingSize = 0) {
        if (!this.$typeinfo.isPrimitiveType() && !this.$typeinfo.isArrayType() && !this.$typeinfo.isStructType()) {
            throw new PBASTError(this.$ast, 'only primitive type, array type or structure type can be set as uniform buffer');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_UNIFORM;
        this.$group = group;
        this.$isBuffer = true;
        this.$bindingSize = bindingSize;
        return this;
    }
    /**
   * Point out that the variable should be in workgroup address space
   *
   * @remarks
   * WebGPU device only
   *
   * @returns self
   */ workgroup() {
        this.$declareType = DeclareType.DECLARE_TYPE_WORKGROUP;
        return this;
    }
    /**
   * Point out that the variable should be in storage address space
   * @param group - The bind group index
   * @returns self
   */ storage(group) {
        if (!this.$typeinfo.isHostSharable()) {
            throw new PBASTError(this.$ast, 'type cannot be declared in storage address space');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_STORAGE;
        this.$group = group;
        this.$isBuffer = false;
        this.$readonly = false;
        return this;
    }
    /**
   * Point out that the variable is read-only and should be in storage address space
   * @param group - The bind group index
   * @returns self
   */ storageReadonly(group) {
        this.storage(group);
        this.$readonly = true;
        return this;
    }
    /**
   * Point out that the variable should be a storage buffer
   * @param group - The bind group index
   * @returns self
   */ storageBuffer(group, bindingSize = 0) {
        if (!this.$typeinfo.isPrimitiveType() && !this.$typeinfo.isArrayType() && !this.$typeinfo.isStructType() && !this.$typeinfo.isAtomicI32() && !this.$typeinfo.isAtomicU32()) {
            throw new PBASTError(this.$ast, 'only primitive type, array type or structure type can be set as storage buffer');
        }
        this.$declareType = DeclareType.DECLARE_TYPE_STORAGE;
        this.$group = group;
        this.$isBuffer = true;
        this.$bindingSize = bindingSize;
        this.$readonly = false;
        return this;
    }
    /**
   * Point out that the variable is read-only and should be a storage buffer
   * @param group - The bind group index
   * @returns self
   */ storageBufferReadonly(group, bindingSize = 0) {
        this.storageBuffer(group, bindingSize);
        this.$readonly = true;
        return this;
    }
    inout() {
        this.$inout = 'inout';
        return this;
    }
    out() {
        this.$inout = 'out';
        return this;
    }
    /**
   * Point out that the variable is a input vertex attribute
   * @param attr - The vertex semantic
   * @returns self
   */ attrib(attr) {
        this.$declareType = DeclareType.DECLARE_TYPE_IN;
        this.$attrib = attr;
        return this;
    }
    /**
   * Create tags for the variable
   * @param args - tags
   * @returns self
   */ tag(...args) {
        args.forEach((val)=>{
            if (this.$tags.indexOf(val) < 0) {
                this.$tags.push(val);
            }
        });
        return this;
    }
    /**
   * Set sample type for the variable if the variable is of type texture
   * @param type - sample type
   * @returns self
   */ sampleType(type) {
        if (type) {
            this.$sampleType = type;
        }
        return this;
    }
    /**
   * Get element in the array by index
   * @param index - index of the element
   * @returns the element variable
   */ at(index) {
        const varType = this.$ast.getType();
        if (!varType.isArrayType() && (!varType.isPrimitiveType() || !varType.isVectorType() && !varType.isMatrixType())) {
            throw new Error('at() function must be used with array types');
        }
        let elementType = null;
        let dimension;
        if (varType.isArrayType()) {
            elementType = varType.elementType;
            dimension = varType.dimension;
        } else if (varType.isVectorType()) {
            elementType = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, 1));
            dimension = varType.cols;
        } else if (varType.isMatrixType()) {
            elementType = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
            dimension = varType.rows;
        }
        const result = new PBShaderExp('', elementType);
        if (typeof index === 'number') {
            if (!Number.isInteger(index)) {
                throw new Error('at() array index must be integer type');
            }
            if (index < 0 || dimension > 0 && index >= dimension) {
                throw new Error('at() array index out of bounds');
            }
            result.$ast = new ASTArrayIndex(this.$ast, new ASTScalar(index, typeI32), elementType);
        } else {
            const type = index.$ast.getType();
            if (!type.isPrimitiveType() || !type.isScalarType()) {
                throw new Error('at() array index must be scalar type');
            }
            let ast = index.$ast;
            if (type.scalarType !== PBPrimitiveType.I32 && type.scalarType !== PBPrimitiveType.U32) {
                ast = new ASTCast(ast, typeI32);
            }
            result.$ast = new ASTArrayIndex(this.$ast, ast, elementType);
        }
        return result;
    }
    /**
   * Set element in the array by index
   * @param index - index of the element
   * @param val - value to set
   */ setAt(index, val) {
        const varType = this.$ast.getType();
        if (!varType.isArrayType()) {
            throw new Error('setAt() function must be used with array types');
        }
        if (typeof index === 'number') {
            if (!Number.isInteger(index)) {
                throw new Error('setAt() array index must be integer type');
            }
            if (index < 0 || varType.dimension > 0 && index >= varType.dimension) {
                throw new Error('setAt() array index out of bounds');
            }
        }
        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), typeof index === 'number' ? new ASTScalar(index, typeI32) : index.$ast, varType.elementType), val instanceof PBShaderExp ? val.$ast : val));
    }
    /**
   * Point out that the variable should be in high precision
   * @returns self
   */ highp() {
        this.$precision = ShaderPrecisionType.HIGH;
        return this;
    }
    /**
   * Points out that the variable should be in medium precision
   * @returns self
   */ mediump() {
        this.$precision = ShaderPrecisionType.MEDIUM;
        return this;
    }
    /**
   * Points out that the variable should be in low precision
   * @returns self
   */ lowp() {
        this.$precision = ShaderPrecisionType.LOW;
        return this;
    }
    /**
   * Whether this is a constructor
   * @returns true if this is a constructor
   */ isConstructor() {
        return this.$ast instanceof ASTShaderExpConstructor && this.$ast.args.length === 0;
    }
    /**
   * Determine if this variable is of vector type
   * @returns true if the variable is of vector type, otherwise false
   */ isVector() {
        const varType = this.$ast.getType();
        return varType.isPrimitiveType() && varType.isVectorType();
    }
    /**
   * Get vector component count of the variable if this variable is of vector type
   * @returns the vector component count
   */ numComponents() {
        const varType = this.$ast.getType();
        return varType.isPrimitiveType() ? varType.cols : 0;
    }
    /**
   * Get type name of this variable
   * @returns The type name of this variable
   */ getTypeName() {
        return this.$ast.getType().toTypeName(currentProgramBuilder.getDevice().type);
    }
    /** @internal */ $get(prop) {
        if (typeof prop === 'string') {
            if (prop[0] === '$' || prop in this) {
                return this[prop];
            } else {
                let exp = this.$memberCache[prop];
                if (!exp) {
                    const varType = this.$ast?.getType() || this.$typeinfo;
                    const num = Number(prop);
                    if (Number.isNaN(num)) {
                        if (varType.isStructType()) {
                            const elementIndex = varType.structMembers.findIndex((val)=>val.name === prop);
                            if (elementIndex < 0) {
                                throw new Error(`unknown struct member '${prop}'`);
                            }
                            const element = varType.structMembers[elementIndex];
                            if (element.type.isStructType()) {
                                const ctor = currentProgramBuilder.structInfo.structs[element.type.structName];
                                exp = ctor.call(currentProgramBuilder, `${this.$str}.${prop}`);
                            } else {
                                exp = new PBShaderExp(`${this.$str}.${prop}`, element.type);
                            }
                            exp.$ast = new ASTHash(this.$ast, prop, element.type);
                        } else {
                            if (!varType.isPrimitiveType() || !varType.isVectorType()) {
                                throw new Error(`invalid index operation: ${this.$ast.toString(currentProgramBuilder.getDevice().type)}[${prop}]`);
                            }
                            if (prop.length === 0 || prop.length > 4 || [
                                ...prop
                            ].some((val)=>'xyzw'.slice(0, varType.cols).indexOf(val) < 0) && [
                                ...prop
                            ].some((val)=>'rgba'.slice(0, varType.cols).indexOf(val) < 0)) {
                                throw new Error(`unknown swizzle target: ${this.$ast.toString(currentProgramBuilder.getDevice().type)}[${prop}]`);
                            }
                            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, prop.length));
                            exp = new PBShaderExp('', type);
                            exp.$ast = new ASTHash(this.$ast, prop, type);
                        }
                    } else {
                        if (varType.isArrayType()) {
                            exp = this.at(num);
                        } else if (varType.isPrimitiveType() && varType.isVectorType()) {
                            if (num >= varType.cols) {
                                throw new Error(`component index out of bounds: ${this.$str}[${num}]`);
                            }
                            exp = this.$get('xyzw'[num]);
                        } else if (varType.isPrimitiveType() && varType.isMatrixType()) {
                            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
                            exp = new PBShaderExp('', type);
                            exp.$ast = new ASTArrayIndex(this.$ast, new ASTScalar(num, typeI32), type);
                        } else {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                    }
                    this.$memberCache[prop] = exp;
                }
                return exp;
            }
        } else {
            return undefined;
        }
    }
    /** @internal */ $set(prop, value) {
        if (typeof prop === 'string') {
            if (prop[0] === '$' || prop in this) {
                this[prop] = value;
            } else {
                if (typeof value !== 'number' && typeof value !== 'boolean' && !(value instanceof PBShaderExp)) {
                    throw new Error(`Invalid output value assignment`);
                }
                const varType = this.$ast?.getType() || this.$typeinfo;
                const num = Number(prop);
                if (Number.isNaN(num)) {
                    if (varType.isStructType()) {
                        const elementIndex = varType.structMembers.findIndex((val)=>val.name === prop);
                        if (elementIndex < 0) {
                            throw new Error(`unknown struct member '${prop}`);
                        }
                        const element = varType.structMembers[elementIndex];
                        let dstAST;
                        if (typeof value === 'number' || typeof value === 'boolean') {
                            if (!element.type.isPrimitiveType() || !element.type.isScalarType()) {
                                throw new Error(`can not set struct member '${prop}: invalid value type`);
                            }
                            dstAST = new ASTScalar(value, element.type);
                        } else if (value instanceof PBShaderExp) {
                            dstAST = value.$ast;
                        }
                        if (!dstAST) {
                            throw new Error(`can not set struct member '${prop}: invalid value type`);
                        }
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, element.type), dstAST));
                    } else {
                        // FIXME: WGSL does not support l-value swizzling
                        if (prop.length > 1 || 'xyzw'.indexOf(prop) < 0 && 'rgba'.indexOf(prop) < 0) {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                        if (!varType.isPrimitiveType() || !varType.isVectorType()) {
                            throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                        }
                        const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.scalarType);
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, type), value instanceof PBShaderExp ? value.$ast : value));
                    }
                } else {
                    if (varType.isArrayType()) {
                        this.setAt(num, value);
                    } else if (varType.isPrimitiveType() && varType.isVectorType()) {
                        if (num >= varType.cols) {
                            throw new Error(`component index out of bounds: ${this.$str}[${num}]`);
                        }
                        this.$set('xyzw'[num], value);
                    } else if (varType.isPrimitiveType() && varType.isMatrixType()) {
                        if (!(value instanceof PBShaderExp)) {
                            throw new Error(`invalid matrix column vector assignment: ${this.$str}[${num}]`);
                        }
                        const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));
                        currentProgramBuilder.getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), new ASTScalar(num, typeI32), type), value.$ast));
                    } else {
                        throw new Error(`invalid index operation: ${this.$str}[${num}]`);
                    }
                }
            }
            return true;
        }
        return false;
    }
}

const genTypeList = [
    [
        typeF32,
        typeF32Vec2,
        typeF32Vec3,
        typeF32Vec4
    ],
    [
        typeI32,
        typeI32Vec2,
        typeI32Vec3,
        typeI32Vec4
    ],
    [
        typeU32$1,
        typeU32Vec2,
        typeU32Vec3,
        typeU32Vec4
    ],
    [
        typeBool,
        typeBVec2,
        typeBVec3,
        typeBVec4
    ]
];
const genMatrixTypeList = [
    typeMat2,
    typeMat2x3,
    typeMat2x4,
    typeMat3x2,
    typeMat3,
    typeMat3x4,
    typeMat4x2,
    typeMat4x3,
    typeMat4
];
function matchFunctionOverloadings(pb, name, ...args) {
    const bit = pb.getDevice().type === 'webgl' ? MASK_WEBGL1 : pb.getDevice().type === 'webgl2' ? MASK_WEBGL2 : MASK_WEBGPU;
    const overloadings = builtinFunctionsAll?.[name].overloads.filter((val)=>!!(val[1] & bit)).map((val)=>val[0]);
    if (!overloadings || overloadings.length === 0) {
        throw new PBDeviceNotSupport(`builtin shader function '${name}'`);
    }
    const argsNonArray = args.map((val)=>pb.normalizeExpValue(val));
    const matchResult = pb._matchFunctionOverloading(overloadings, argsNonArray);
    if (!matchResult) {
        throw new PBOverloadingMatchError(name);
    }
    return matchResult;
}
function callBuiltinChecked(pb, matchResult) {
    return pb.$callFunction(matchResult[0].name, matchResult[1], matchResult[0]);
}
function callBuiltin(pb, name, ...args) {
    return callBuiltinChecked(pb, matchFunctionOverloadings(pb, name, ...args));
}
function genMatrixType(name, shaderTypeMask, r, args) {
    const result = [];
    for(let i = 0; i < genMatrixTypeList.length; i++){
        const returnType = r || genMatrixTypeList[i];
        const argTypes = args.map((arg)=>{
            return {
                type: arg || genMatrixTypeList[i]
            };
        });
        result.push([
            new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, returnType, argTypes), true),
            shaderTypeMask
        ]);
    }
    return result;
}
function genType(name, shaderTypeMask, r, args, vecOnly) {
    if (args.findIndex((val)=>typeof val === 'number') < 0) {
        return [
            [
                new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, r, args.map((arg)=>({
                        type: arg
                    }))), true),
                shaderTypeMask
            ]
        ];
    } else {
        const result = [];
        let i = vecOnly ? 1 : 0;
        for(; i < 4; i++){
            const returnType = typeof r === 'number' ? genTypeList[r][i] : r;
            const argTypes = args.map((arg)=>{
                if (typeof arg === 'number') {
                    return {
                        type: genTypeList[arg][i]
                    };
                } else {
                    return {
                        type: arg
                    };
                }
            });
            result.push([
                new ASTFunction(name, null, false, new PBFunctionTypeInfo(name, returnType, argTypes), true),
                shaderTypeMask
            ]);
        }
        return result;
    }
}
function unaryFunc(a, op, type) {
    const exp = new PBShaderExp('', type);
    exp.$ast = new ASTUnaryFunc(a, op, type);
    return exp;
}
function binaryFunc(a, b, op, type) {
    const exp = new PBShaderExp('', type);
    exp.$ast = new ASTBinaryFunc(a, b, op, type);
    return exp;
}
const MASK_WEBGL1 = 1 << 0;
const MASK_WEBGL2 = 1 << 1;
const MASK_WEBGPU = 1 << 2;
const MASK_WEBGL = MASK_WEBGL1 | MASK_WEBGL2;
const MASK_ALL = MASK_WEBGL | MASK_WEBGPU;
const builtinFunctionsAll = {
    add_2: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32,
                typeF32Vec2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32Vec2,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32,
                typeF32Vec3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32Vec3,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32,
                typeF32Vec4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32Vec4,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32,
                typeI32Vec2
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32Vec2,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32,
                typeI32Vec3
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32Vec3,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32,
                typeI32Vec4
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32Vec4,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32$1,
                typeU32Vec2
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32Vec2,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32$1,
                typeU32Vec3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32Vec3,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32Vec4,
                typeU32$1
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                null
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {
                return args[0] + args[1];
            }
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '+', matchResult[0].returnType);
        }
    },
    add: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('add');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.add_2(result, args[i]);
            }
            return result;
        }
    },
    sub: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32,
                typeF32Vec2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32Vec2,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32,
                typeF32Vec3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32Vec3,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32,
                typeF32Vec4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32Vec4,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32,
                typeI32Vec2
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32Vec2,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32,
                typeI32Vec3
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32Vec3,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32,
                typeI32Vec4
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32Vec4,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32$1,
                typeU32Vec2
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32Vec2,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32$1,
                typeU32Vec3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32Vec3,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32Vec4,
                typeU32$1
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                null
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '-', matchResult[0].returnType);
        }
    },
    div: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32,
                typeF32Vec2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32Vec2,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32,
                typeF32Vec3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32Vec3,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32,
                typeF32Vec4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32Vec4,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32,
                typeI32Vec2
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32Vec2,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32,
                typeI32Vec3
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32Vec3,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32,
                typeI32Vec4
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32Vec4,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32$1,
                typeU32Vec2
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32Vec2,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32$1,
                typeU32Vec3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32Vec3,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32Vec4,
                typeU32$1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '/', matchResult[0].returnType);
        }
    },
    mul_2: {
        overloads: [
            ...genType('', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('', MASK_ALL, 3, [
                3,
                3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32,
                typeF32Vec2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32Vec2,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32,
                typeF32Vec3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32Vec3,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32,
                typeF32Vec4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32Vec4,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32,
                typeI32Vec2
            ]),
            ...genType('', MASK_ALL, typeI32Vec2, [
                typeI32Vec2,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32,
                typeI32Vec3
            ]),
            ...genType('', MASK_ALL, typeI32Vec3, [
                typeI32Vec3,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32,
                typeI32Vec4
            ]),
            ...genType('', MASK_ALL, typeI32Vec4, [
                typeI32Vec4,
                typeI32
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32$1,
                typeU32Vec2
            ]),
            ...genType('', MASK_ALL, typeU32Vec2, [
                typeU32Vec2,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32$1,
                typeU32Vec3
            ]),
            ...genType('', MASK_ALL, typeU32Vec3, [
                typeU32Vec3,
                typeU32$1
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('', MASK_ALL, typeU32Vec4, [
                typeU32Vec4,
                typeU32$1
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                typeF32,
                null
            ]),
            ...genMatrixType('', MASK_ALL, null, [
                null,
                typeF32
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat2,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat2,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat2,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeMat2,
                typeF32Vec2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32Vec2,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat2x3,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat2x3,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat2x3,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeMat2x3,
                typeF32Vec2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32Vec3,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat2x4,
                typeMat2
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat2x4,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat2x4,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeMat2x4,
                typeF32Vec2
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeF32Vec4,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat3x2,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat3x2,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat3x2,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeMat3x2,
                typeF32Vec3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32Vec2,
                typeMat3x2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat3,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat3,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat3,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeMat3,
                typeF32Vec3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32Vec3,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat3x4,
                typeMat2x3
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat3x4,
                typeMat3
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat3x4,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeMat3x4,
                typeF32Vec3
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeF32Vec4,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat2, [
                typeMat4x2,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3x2, [
                typeMat4x2,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4x2, [
                typeMat4x2,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec2, [
                typeMat4x2,
                typeF32Vec4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32Vec2,
                typeMat4x2
            ]),
            ...genType('', MASK_ALL, typeMat2x3, [
                typeMat4x3,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3, [
                typeMat4x3,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4x3, [
                typeMat4x3,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec3, [
                typeMat4x3,
                typeF32Vec4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32Vec3,
                typeMat4x3
            ]),
            ...genType('', MASK_ALL, typeMat2x4, [
                typeMat4,
                typeMat2x4
            ]),
            ...genType('', MASK_ALL, typeMat3x4, [
                typeMat4,
                typeMat3x4
            ]),
            ...genType('', MASK_ALL, typeMat4, [
                typeMat4,
                typeMat4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeMat4,
                typeF32Vec4
            ]),
            ...genType('', MASK_ALL, typeF32Vec4, [
                typeF32Vec4,
                typeMat4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '*', matchResult[0].returnType);
        }
    },
    mul: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('mul');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.mul_2(result, args[i]);
            }
            return result;
        }
    },
    mod: {
        overloads: [
            ...genType('mod', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('mod', MASK_ALL, 1, [
                1,
                1
            ]),
            ...genType('mod', MASK_ALL, 2, [
                2,
                2
            ]),
            ...genType('mod', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            const isIntegerType = argType.isPrimitiveType() && (argType.scalarType === PBPrimitiveType.I32 || argType.scalarType === PBPrimitiveType.U32);
            if (pb.getDevice().type === 'webgl' && isIntegerType) {
                throw new PBDeviceNotSupport('integer modulus');
            }
            if (pb.getDevice().type === 'webgpu' || isIntegerType) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '%', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    radians: {
        overloads: genType('radians', MASK_ALL, 0, [
            0
        ])
    },
    degrees: {
        overloads: genType('degrees', MASK_ALL, 0, [
            0
        ])
    },
    sin: {
        overloads: genType('sin', MASK_ALL, 0, [
            0
        ])
    },
    cos: {
        overloads: genType('cos', MASK_ALL, 0, [
            0
        ])
    },
    tan: {
        overloads: genType('tan', MASK_ALL, 0, [
            0
        ])
    },
    asin: {
        overloads: genType('asin', MASK_ALL, 0, [
            0
        ])
    },
    acos: {
        overloads: genType('acos', MASK_ALL, 0, [
            0
        ])
    },
    atan: {
        overloads: genType('atan', MASK_ALL, 0, [
            0
        ])
    },
    atan2: {
        overloads: [
            ...genType('atan', MASK_WEBGL, 0, [
                0,
                0
            ]),
            ...genType('atan2', MASK_WEBGPU, 0, [
                0,
                0
            ])
        ]
    },
    sinh: {
        overloads: genType('sinh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    cosh: {
        overloads: genType('cosh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    tanh: {
        overloads: genType('tanh', MASK_WEBGL2 | MASK_WEBGPU, 0, [
            0
        ])
    },
    asinh: {
        overloads: genType('asinh', MASK_WEBGL2, 0, [
            0
        ])
    },
    acosh: {
        overloads: genType('acosh', MASK_WEBGL2, 0, [
            0
        ])
    },
    atanh: {
        overloads: genType('atanh', MASK_WEBGL2, 0, [
            0
        ])
    },
    pow: {
        overloads: genType('pow', MASK_ALL, 0, [
            0,
            0
        ])
    },
    exp: {
        overloads: genType('exp', MASK_ALL, 0, [
            0
        ])
    },
    exp2: {
        overloads: genType('exp2', MASK_ALL, 0, [
            0
        ])
    },
    log: {
        overloads: genType('log', MASK_ALL, 0, [
            0
        ])
    },
    log2: {
        overloads: genType('log2', MASK_ALL, 0, [
            0
        ])
    },
    sqrt: {
        overloads: genType('sqrt', MASK_ALL, 0, [
            0
        ])
    },
    inverseSqrt: {
        overloads: [
            ...genType('inversesqrt', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('inverseSqrt', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    abs: {
        overloads: [
            ...genType('abs', MASK_ALL, 0, [
                0
            ]),
            ...genType('abs', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1
            ]),
            ...genType('abs', MASK_WEBGPU, 2, [
                2
            ])
        ]
    },
    sign: {
        overloads: [
            ...genType('sign', MASK_ALL, 0, [
                0
            ]),
            ...genType('sign', MASK_WEBGL2, 1, [
                1
            ])
        ]
    },
    floor: {
        overloads: genType('floor', MASK_ALL, 0, [
            0
        ])
    },
    ceil: {
        overloads: genType('ceil', MASK_ALL, 0, [
            0
        ])
    },
    fract: {
        overloads: genType('fract', MASK_ALL, 0, [
            0
        ])
    },
    fma: {
        overloads: genType('fma', MASK_ALL, 0, [
            0,
            0,
            0
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            if (pb.getDevice().type === 'webgpu') {
                return callBuiltinChecked(pb, matchResult);
            } else {
                return pb.add(pb.mul(args[0], args[1]), args[2]);
            }
        }
    },
    round: {
        overloads: genType('round', MASK_WEBGPU, 0, [
            0
        ])
    },
    trunc: {
        overloads: genType('trunc', MASK_WEBGPU, 0, [
            0
        ])
    },
    // TODO: modf
    min: {
        overloads: [
            ...genType('min', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('min', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('min', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ]
    },
    max: {
        overloads: [
            ...genType('max', MASK_ALL, 0, [
                0,
                0
            ]),
            ...genType('max', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('max', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ]
    },
    clamp: {
        overloads: [
            ...genType('clamp', MASK_ALL, 0, [
                0,
                0,
                0
            ]),
            ...genType('clamp', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1,
                1
            ]),
            ...genType('clamp', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2,
                2
            ])
        ]
    },
    mix: {
        overloads: [
            ...genType('mix', MASK_ALL, 0, [
                0,
                0,
                0
            ]),
            ...genType('mix', MASK_ALL, 0, [
                0,
                0,
                typeF32
            ])
        ]
    },
    step: {
        overloads: genType('step', MASK_ALL, 0, [
            0,
            0
        ])
    },
    smoothStep: {
        overloads: genType('smoothstep', MASK_ALL, 0, [
            0,
            0,
            0
        ])
    },
    isnan: {
        overloads: genType('isnan', MASK_WEBGL2, 3, [
            0
        ])
    },
    isinf: {
        overloads: genType('isinf', MASK_WEBGL2, 3, [
            0
        ])
    },
    length: {
        overloads: genType('length', MASK_ALL, typeF32, [
            0
        ])
    },
    distance: {
        overloads: genType('distance', MASK_ALL, typeF32, [
            0,
            0
        ])
    },
    dot: {
        overloads: [
            ...genType('dot', MASK_ALL, typeF32, [
                0,
                0
            ], true),
            ...genType('dot', MASK_WEBGPU, typeI32, [
                1,
                1
            ], true),
            ...genType('dot', MASK_WEBGPU, typeU32$1, [
                2,
                2
            ], true)
        ]
    },
    cross: {
        overloads: genType('cross', MASK_ALL, typeF32Vec3, [
            typeF32Vec3,
            typeF32Vec3
        ])
    },
    normalize: {
        overloads: genType('normalize', MASK_ALL, 0, [
            0
        ], true)
    },
    faceForward: {
        overloads: [
            ...genType('faceforward', MASK_WEBGL, 0, [
                0,
                0,
                0
            ], true),
            ...genType('faceForward', MASK_WEBGPU, 0, [
                0,
                0,
                0
            ], true)
        ]
    },
    reflect: {
        overloads: genType('reflect', MASK_ALL, 0, [
            0,
            0
        ], true)
    },
    refract: {
        overloads: genType('refract', MASK_ALL, 0, [
            0,
            0,
            typeF32
        ], true)
    },
    frexp: {
        overloads: [
            ...genType('frexp', MASK_WEBGPU, typeFrexpResult, [
                typeF32
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec2, [
                typeF32Vec2
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec3, [
                typeF32Vec3
            ]),
            ...genType('frexp', MASK_WEBGPU, typeFrexpResultVec4, [
                typeF32Vec4
            ])
        ]
    },
    outerProduct: {
        overloads: [
            ...genType('outerProduct', MASK_WEBGL2, typeMat2, [
                typeF32Vec2,
                typeF32Vec2
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3, [
                typeF32Vec3,
                typeF32Vec3
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4, [
                typeF32Vec4,
                typeF32Vec4
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat2x3, [
                typeF32Vec3,
                typeF32Vec2
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3x2, [
                typeF32Vec2,
                typeF32Vec3
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat2x4, [
                typeF32Vec4,
                typeF32Vec2
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4x2, [
                typeF32Vec2,
                typeF32Vec4
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat3x4, [
                typeF32Vec4,
                typeF32Vec3
            ]),
            ...genType('outerProduct', MASK_WEBGL2, typeMat4x3, [
                typeF32Vec3,
                typeF32Vec4
            ])
        ]
    },
    transpose: {
        overloads: [
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2, [
                typeMat2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3, [
                typeMat3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4, [
                typeMat4
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2x3, [
                typeMat3x2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3x2, [
                typeMat2x3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat2x4, [
                typeMat4x2
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4x2, [
                typeMat2x4
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat3x4, [
                typeMat4x3
            ]),
            ...genType('transpose', MASK_WEBGL2 | MASK_WEBGPU, typeMat4x3, [
                typeMat3x4
            ])
        ]
    },
    determinant: {
        overloads: [
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32, [
                typeMat2
            ]),
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32, [
                typeMat3
            ]),
            ...genType('determinant', MASK_WEBGL2 | MASK_WEBGPU, typeF32, [
                typeMat4
            ])
        ]
    },
    inverse: {
        overloads: [
            ...genType('inverse', MASK_WEBGL2, typeMat2, [
                typeMat2
            ]),
            ...genType('inverse', MASK_WEBGL2, typeMat3, [
                typeMat3
            ]),
            ...genType('inverse', MASK_WEBGL2, typeMat4, [
                typeMat4
            ])
        ]
    },
    lessThan: {
        overloads: [
            ...genType('lessThan', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('lessThan', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('lessThan', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '<', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    lessThanEqual: {
        overloads: [
            ...genType('lessThanEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('lessThanEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('lessThanEqual', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '<=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    greaterThan: {
        overloads: [
            ...genType('greaterThan', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('greaterThan', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('greaterThan', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '>', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    greaterThanEqual: {
        overloads: [
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('greaterThanEqual', MASK_ALL, 3, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '>=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    compEqual: {
        overloads: [
            ...genType('equal', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('equal', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('equal', MASK_ALL, 3, [
                2,
                2
            ]),
            ...genType('equal', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '==', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    compNotEqual: {
        overloads: [
            ...genType('notEqual', MASK_ALL, 3, [
                0,
                0
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                1,
                1
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                2,
                2
            ]),
            ...genType('notEqual', MASK_ALL, 3, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '!=', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    equal: {
        overloads: [
            ...genType('equal', MASK_ALL, typeBool, [
                0,
                0
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                1,
                1
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                2,
                2
            ]),
            ...genType('equal', MASK_ALL, typeBool, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' && argType.isPrimitiveType() && !argType.isScalarType()) {
                return pb.all(pb.compEqual(args[0], args[1]));
            } else {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '==', matchResult[0].returnType);
            }
        }
    },
    notEqual: {
        overloads: [
            ...genType('notEqual', MASK_ALL, typeBool, [
                0,
                0
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                1,
                1
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                2,
                2
            ]),
            ...genType('notEqual', MASK_ALL, typeBool, [
                3,
                3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' && argType.isPrimitiveType() && !argType.isScalarType()) {
                return pb.any(pb.compNotEqual(args[0], args[1]));
            } else {
                return binaryFunc(matchResult[1][0], matchResult[1][1], '!=', matchResult[0].returnType);
            }
        }
    },
    any: {
        overloads: genType('any', MASK_ALL, typeBool, [
            3
        ], true)
    },
    all: {
        overloads: genType('all', MASK_ALL, typeBool, [
            3
        ], true)
    },
    not: {
        overloads: genType('not', MASK_ALL, 3, [
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            const argType = matchResult[1][0].getType();
            if (pb.getDevice().type === 'webgpu' || argType.isPrimitiveType() && argType.isScalarType()) {
                return unaryFunc(matchResult[1][0], '!', matchResult[0].returnType);
            } else {
                return callBuiltinChecked(pb, matchResult);
            }
        }
    },
    neg: {
        overloads: [
            ...genType('neg', MASK_ALL, 0, [
                0
            ]),
            ...genType('neg', MASK_ALL, 1, [
                1
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return unaryFunc(matchResult[1][0], '-', matchResult[0].returnType);
        }
    },
    or_2: {
        overloads: genType('or', MASK_ALL, typeBool, [
            3,
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '||', matchResult[0].returnType);
        }
    },
    or: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('or');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.or_2(result, args[i]);
            }
            return result;
        }
    },
    compOr: {
        overloads: [
            ...genType('compOr', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compOr', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '|', matchResult[0].returnType);
        }
    },
    and_2: {
        overloads: genType('and', MASK_ALL, typeBool, [
            3,
            3
        ]),
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '&&', matchResult[0].returnType);
        }
    },
    and: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 2) {
                throw new PBParamLengthError('and');
            }
            let result = args[0];
            for(let i = 1; i < args.length; i++){
                result = pb.and_2(result, args[i]);
            }
            return result;
        }
    },
    compAnd: {
        overloads: [
            ...genType('compAnd', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compAnd', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '&', matchResult[0].returnType);
        }
    },
    compXor: {
        overloads: [
            ...genType('compXor', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                1
            ]),
            ...genType('compXor', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '^', matchResult[0].returnType);
        }
    },
    sal: {
        overloads: [
            ...genType('sal', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                2
            ]),
            ...genType('sal', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '<<', matchResult[0].returnType);
        }
    },
    sar: {
        overloads: [
            ...genType('sar', MASK_WEBGL2 | MASK_WEBGPU, 1, [
                1,
                2
            ]),
            ...genType('sar', MASK_WEBGL2 | MASK_WEBGPU, 2, [
                2,
                2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const matchResult = matchFunctionOverloadings(pb, name, ...args);
            return binaryFunc(matchResult[1][0], matchResult[1][1], '>>', matchResult[0].returnType);
        }
    },
    arrayLength: {
        overloads: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError('arrayLength');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('arrayLength', 'array');
            }
            const type = args[0].$ast.getType();
            const arrayType = type.isPointerType() ? type.pointerType : type;
            if (!arrayType.isArrayType() || arrayType.dimension !== 0) {
                throw new PBParamTypeError('arrayLength', 'array');
            }
            const arg = type.isArrayType() ? pb.addressOf(args[0]).$ast : args[0].$ast;
            return pb.$callFunctionNoCheck(name, [
                arg
            ], typeU32$1);
        }
    },
    select: {
        overloads: [
            ...genType('select', MASK_WEBGPU, 0, [
                0,
                0,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 1, [
                1,
                1,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 2, [
                2,
                2,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 3, [
                3,
                3,
                typeBool
            ]),
            ...genType('select', MASK_WEBGPU, 0, [
                0,
                0,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 1, [
                1,
                1,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 2, [
                2,
                2,
                3
            ], true),
            ...genType('select', MASK_WEBGPU, 3, [
                3,
                3,
                3
            ], true),
            ...genType('mix', MASK_WEBGL2, 0, [
                0,
                0,
                3
            ]),
            ...genType('mix', MASK_WEBGL2, 1, [
                1,
                1,
                3
            ]),
            ...genType('mix', MASK_WEBGL2, 2, [
                2,
                2,
                3
            ])
        ]
    },
    floatBitsToInt: {
        overloads: genType('floatBitsToInt', MASK_WEBGL2, 1, [
            0
        ]),
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError('floatBitsToInt');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                if (typeof args[0] !== 'number') {
                    throw new PBParamValueError('floatBitsToInt', 'x');
                }
            } else {
                const type = args[0].$ast.getType();
                if (type.typeId !== typeF32.typeId) {
                    throw new PBParamTypeError('floatBitsToInt', 'x');
                }
            }
            if (pb.getDevice().type === 'webgpu') {
                return pb.$callFunctionNoCheck('bitcast<i32>', [
                    args[0] instanceof PBShaderExp ? args[0].$ast : new ASTScalar(args[0], typeF32)
                ], typeI32);
            } else {
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    floatBitsToUint: {
        overloads: genType('floatBitsToUint', MASK_WEBGL2, 2, [
            0
        ]),
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError('floatBitsToUint');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                if (typeof args[0] !== 'number') {
                    throw new PBParamValueError('floatBitsToUint', 'x');
                }
            } else {
                const type = args[0].$ast.getType();
                if (type.typeId !== typeF32.typeId) {
                    throw new PBParamTypeError('floatBitsToUint', 'x');
                }
            }
            if (pb.getDevice().type === 'webgpu') {
                return pb.$callFunctionNoCheck('bitcast<u32>', [
                    args[0] instanceof PBShaderExp ? args[0].$ast : new ASTScalar(args[0], typeF32)
                ], typeU32$1);
            } else {
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    intBitsToFloat: {
        overloads: genType('intBitsToFloat', MASK_WEBGL2, 0, [
            1
        ]),
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError('intBitsToFloat');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                if (typeof args[0] !== 'number') {
                    throw new PBParamValueError('intBitsToFloat', 'x');
                }
            } else {
                const type = args[0].$ast.getType();
                if (type.typeId !== typeI32.typeId) {
                    throw new PBParamTypeError('intBitsToFloat', 'x');
                }
            }
            if (pb.getDevice().type === 'webgpu') {
                return pb.$callFunctionNoCheck('bitcast<f32>', [
                    args[0] instanceof PBShaderExp ? args[0].$ast : new ASTScalar(args[0], typeI32)
                ], typeF32);
            } else {
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    uintBitsToFloat: {
        overloads: genType('uintBitsToFloat', MASK_WEBGL2, 0, [
            2
        ]),
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError('uintBitsToFloat');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                if (typeof args[0] !== 'number') {
                    throw new PBParamValueError('uintBitsToFloat', 'x');
                }
            } else {
                const type = args[0].$ast.getType();
                if (type.typeId !== typeU32$1.typeId) {
                    throw new PBParamTypeError('uintBitsToFloat', 'x');
                }
            }
            if (pb.getDevice().type === 'webgpu') {
                return pb.$callFunctionNoCheck('bitcast<f32>', [
                    args[0] instanceof PBShaderExp ? args[0].$ast : new ASTScalar(args[0], typeU32$1)
                ], typeF32);
            } else {
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    pack4x8snorm: {
        overloads: genType('pack4x8snorm', MASK_WEBGPU, typeU32$1, [
            typeF32Vec4
        ])
    },
    unpack4x8snorm: {
        overloads: genType('unpack4x8snorm', MASK_WEBGPU, typeF32Vec4, [
            typeU32$1
        ])
    },
    pack4x8unorm: {
        overloads: genType('pack4x8unorm', MASK_WEBGPU, typeU32$1, [
            typeF32Vec4
        ])
    },
    unpack4x8unorm: {
        overloads: genType('unpack4x8unorm', MASK_WEBGPU, typeF32Vec4, [
            typeU32$1
        ])
    },
    pack2x16snorm: {
        overloads: [
            ...genType('pack2x16snorm', MASK_WEBGPU, typeU32$1, [
                typeF32Vec2
            ]),
            ...genType('packSnorm2x16', MASK_WEBGL2, typeU32$1, [
                typeF32Vec2
            ])
        ]
    },
    unpack2x16snorm: {
        overloads: [
            ...genType('unpack2x16snorm', MASK_WEBGPU, typeF32Vec2, [
                typeU32$1
            ]),
            ...genType('unpackSnorm2x16', MASK_WEBGL2, typeF32Vec2, [
                typeU32$1
            ])
        ]
    },
    pack2x16unorm: {
        overloads: [
            ...genType('pack2x16unorm', MASK_WEBGPU, typeU32$1, [
                typeF32Vec2
            ]),
            ...genType('packUnorm2x16', MASK_WEBGL2, typeU32$1, [
                typeF32Vec2
            ])
        ]
    },
    unpack2x16unorm: {
        overloads: [
            ...genType('unpack2x16unorm', MASK_WEBGPU, typeF32Vec2, [
                typeU32$1
            ]),
            ...genType('unpackUnorm2x16', MASK_WEBGL2, typeF32Vec2, [
                typeU32$1
            ])
        ]
    },
    pack2x16float: {
        overloads: [
            ...genType('pack2x16float', MASK_WEBGPU, typeU32$1, [
                typeF32Vec2
            ]),
            ...genType('packHalf2x16', MASK_WEBGL2, typeU32$1, [
                typeF32Vec2
            ])
        ]
    },
    unpack2x16float: {
        overloads: [
            ...genType('unpack2x16float', MASK_WEBGPU, typeF32Vec2, [
                typeU32$1
            ]),
            ...genType('unpackHalf2x16', MASK_WEBGL2, typeF32Vec2, [
                typeU32$1
            ])
        ]
    },
    matrixCompMult: {
        overloads: genMatrixType('matrixCompMult', MASK_WEBGL, null, [
            null,
            null
        ])
    },
    dpdx: {
        overloads: [
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('dpdx', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    dpdy: {
        overloads: [
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ]),
            ...genType('dpdy', MASK_WEBGPU, 0, [
                0
            ])
        ]
    },
    fwidth: {
        overloads: genType('fwidth', MASK_ALL, 0, [
            0
        ])
    },
    dpdxCoarse: {
        overloads: [
            ...genType('dpdxCoarse', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdxFine: {
        overloads: [
            ...genType('dpdxFine', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdx', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdyCoarse: {
        overloads: [
            ...genType('dpdyCoarse', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    dpdyFine: {
        overloads: [
            ...genType('dpdyFine', MASK_WEBGPU, 0, [
                0
            ]),
            ...genType('dFdy', MASK_WEBGL, 0, [
                0
            ])
        ]
    },
    // textureDimensions(tex: PBShaderExp, level?: number|PBShaderExp);
    textureDimensions: {
        overloads: [
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTex1D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeITex1D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeUTex1D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTex2D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeITex2D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeUTex2D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTex2DArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeITex2DArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeUTex2DArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTex3D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeITex3D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeUTex3D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexCube,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeITexCube,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeUTexCube,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexCubeArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeITexCubeArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeUTexCubeArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeITexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeUTexMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexDepth2D,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexDepth2DArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexDepthCube,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexDepthCubeArray,
                typeI32
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexDepthMultisampled2D
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32$1, [
                typeTexStorage1D_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2D_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec2, [
                typeTexStorage2DArray_r32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba8unorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba8snorm
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba8uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba8sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba16uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba16sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba16float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rgba32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rg32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rg32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_rg32float
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_r32uint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_r32sint
            ]),
            ...genType('textureDimensions', MASK_WEBGPU, typeU32Vec3, [
                typeTexStorage3D_r32float
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeTex1D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeTex2D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeITex1D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeITex2D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeUTex1D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeUTex2D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeTex2DArray,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeITex2DArray,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeUTex2DArray,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeTexCube,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeITexCube,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeUTexCube,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3, [
                typeTex3D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3, [
                typeITex3D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec3, [
                typeUTex3D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeTexDepth2D,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeTexDepthCube,
                typeI32
            ]),
            ...genType('textureSize', MASK_WEBGL2, typeI32Vec2, [
                typeTexDepth2DArray,
                typeI32
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length < 1 || args.length > 2) {
                throw new PBParamLengthError('textureDimensions');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('textureDimensions', 'tex');
            }
            const texType = args[0].$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureDimensions', 'tex');
            }
            if (pb.getDevice().type === 'webgpu') {
                if (texType.isMultisampledTexture() || texType.isStorageTexture()) {
                    if (args[1] !== undefined) {
                        throw new PBParamValueError('textureDimensions', 'level');
                    }
                }
                return callBuiltin(pb, name, ...args);
            } else if (pb.getDevice().type === 'webgl2') {
                const tex = args[0];
                const level = args[1] || 0;
                return texType.is1DTexture() ? callBuiltin(pb, name, tex, level).x : callBuiltin(pb, name, tex, level);
            }
        }
    },
    // textureGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp);
    // textureGather(component: number|PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp);
    textureGather: {
        overloads: [
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeI32,
                typeTex2D,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4, [
                typeI32,
                typeITex2D,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4, [
                typeI32,
                typeUTex2D,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeI32,
                typeTexCube,
                typeSampler,
                typeF32Vec3
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4, [
                typeI32,
                typeITexCube,
                typeSampler,
                typeF32Vec3
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4, [
                typeI32,
                typeUTexCube,
                typeSampler,
                typeF32Vec3
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3
            ])
        ]
    },
    // textureArrayGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp);
    // textureArrayGather(component: number|PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp);
    textureArrayGather: {
        overloads: [
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeI32,
                typeTex2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4, [
                typeI32,
                typeITex2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4, [
                typeI32,
                typeUTex2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeI32,
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeI32Vec4, [
                typeI32,
                typeITexCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeU32Vec4, [
                typeI32,
                typeUTexCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32
            ]),
            ...genType('textureGather', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32
            ])
        ]
    },
    // textureGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp);
    textureGatherCompare: {
        overloads: [
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3,
                typeF32
            ])
        ]
    },
    // textureArrayGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp);
    textureArrayGatherCompare: {
        overloads: [
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2,
                typeI32,
                typeF32
            ]),
            ...genType('textureGatherCompare', MASK_WEBGPU, typeF32Vec4, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3,
                typeI32,
                typeF32
            ])
        ]
    },
    // textureLoad(tex: PBShaderExp, coords: number|PBShaderExp, levelOrSampleIndex: number|PBShaderExp);
    textureLoad: {
        overloads: [
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTex1D,
                typeI32,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeITex1D,
                typeI32,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeUTex1D,
                typeI32,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage1D_bgra8unorm,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage1D_r32float,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage1D_r32sint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage1D_r32uint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage1D_rg32float,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage1D_rg32sint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage1D_rg32uint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage1D_rgba16float,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage1D_rgba16sint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage1D_rgba16uint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage1D_rgba32float,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage1D_rgba32sint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage1D_rgba32uint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage1D_rgba8sint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage1D_rgba8uint,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage1D_rgba8snorm,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage1D_rgba8unorm,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTex2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeITex2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeUTex2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage2D_bgra8unorm,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage2D_r32float,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage2D_r32sint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage2D_r32uint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage2D_rg32float,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage2D_rg32sint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage2D_rg32uint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage2D_rgba16float,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage2D_rgba16sint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage2D_rgba16uint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage2D_rgba32float,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage2D_rgba32sint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage2D_rgba32uint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage2D_rgba8sint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage2D_rgba8uint,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage2D_rgba8snorm,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage2D_rgba8unorm,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTex3D,
                typeI32Vec3,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeITex3D,
                typeI32Vec3,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeUTex3D,
                typeI32Vec3,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage3D_bgra8unorm,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage3D_r32float,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage3D_r32sint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage3D_r32uint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage3D_rg32float,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage3D_rg32sint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage3D_rg32uint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage3D_rgba16float,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage3D_rgba16sint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage3D_rgba16uint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage3D_rgba32float,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage3D_rgba32sint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage3D_rgba32uint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeTexStorage3D_rgba8sint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeTexStorage3D_rgba8uint,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage3D_rgba8snorm,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexStorage3D_rgba8unorm,
                typeI32Vec3
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexMultisampled2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeITexMultisampled2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeUTexMultisampled2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTexExternal,
                typeI32Vec2
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32, [
                typeTexDepth2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32, [
                typeTexDepthMultisampled2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4, [
                typeTex1D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4, [
                typeTex2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4, [
                typeTex3D,
                typeI32Vec3,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4, [
                typeTexExternal,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4, [
                typeITex1D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4, [
                typeITex2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4, [
                typeITex3D,
                typeI32Vec3,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4, [
                typeUTex1D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4, [
                typeUTex2D,
                typeI32Vec2,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4, [
                typeUTex3D,
                typeI32Vec3,
                typeI32
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length === 0) {
                throw new PBParamLengthError('textureLoad');
            }
            if (!(args[0] instanceof PBShaderExp)) {
                throw new PBParamValueError('textureLoad', 'tex');
            }
            const texType = args[0].$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureLoad', 'tex');
            }
            if (pb.getDevice().type === 'webgl2') {
                if (args.length !== 3) {
                    throw new PBParamLengthError('textureLoad');
                }
                if (texType.is1DTexture()) {
                    if (typeof args[1] === 'number') {
                        if (!Number.isInteger(args[1])) {
                            throw new PBParamTypeError('textureLoad', 'coord');
                        }
                    } else if (args[1] instanceof PBShaderExp) {
                        const coordType = args[1].$ast.getType();
                        if (!coordType.isPrimitiveType() || !coordType.isScalarType() || coordType.scalarType !== PBPrimitiveType.I32) {
                            throw new PBParamTypeError('textureLoad', 'coord');
                        }
                    } else {
                        throw new PBParamTypeError('textureLoad', 'coord');
                    }
                    args[1] = pb.ivec2(args[1], 0);
                }
            } else if (pb.getDevice().type === 'webgpu') {
                if (texType.isExternalTexture()) {
                    args = args.slice(0, 2);
                }
                if (texType.isStorageTexture()) {
                    texType.readable = true;
                }
            }
            return callBuiltin(pb, name, ...args);
        }
    },
    // textureArrayLoad(tex: PBShaderExp, coords: number|PBShaderExp, arrayIndex: number|PBShaderExp, level: number|PBShaderExp);
    textureArrayLoad: {
        overloads: [
            ...genType('textureLoad', MASK_WEBGPU, typeF32Vec4, [
                typeTex2DArray,
                typeI32Vec2,
                typeI32,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeI32Vec4, [
                typeITex2DArray,
                typeI32Vec2,
                typeI32,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeU32Vec4, [
                typeUTex2DArray,
                typeI32Vec2,
                typeI32,
                typeI32
            ]),
            ...genType('textureLoad', MASK_WEBGPU, typeF32, [
                typeTexDepth2DArray,
                typeI32Vec2,
                typeI32,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeF32Vec4, [
                typeTex2DArray,
                typeI32Vec3,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeI32Vec4, [
                typeITex2DArray,
                typeI32Vec3,
                typeI32
            ]),
            ...genType('texelFetch', MASK_WEBGL2, typeU32Vec4, [
                typeUTex2DArray,
                typeI32Vec3,
                typeI32
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (pb.getDevice().type === 'webgl2') {
                if (args.length !== 4) {
                    throw new PBParamLengthError('textureArrayLoad');
                }
                const tex = args[0];
                const coords = pb.ivec3(args[1], args[2]);
                const level = args[3];
                return callBuiltin(pb, name, tex, coords, level);
            } else {
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureStore(tex: PBShaderExp, coords: number|PBShaderExp, value: PBShaderExp);
    textureStore: {
        overloads: [
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8unorm,
                typeU32$1,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8snorm,
                typeU32$1,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8uint,
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba8sint,
                typeU32$1,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16uint,
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16sint,
                typeU32$1,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba16float,
                typeU32$1,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32uint,
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32sint,
                typeU32$1,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rgba32float,
                typeU32$1,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32uint,
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32sint,
                typeU32$1,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_rg32float,
                typeU32$1,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32uint,
                typeU32$1,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32sint,
                typeU32$1,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage1D_r32float,
                typeU32$1,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8unorm,
                typeU32Vec2,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8snorm,
                typeU32Vec2,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8uint,
                typeU32Vec2,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba8sint,
                typeU32Vec2,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16uint,
                typeU32Vec2,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16sint,
                typeU32Vec2,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba16float,
                typeU32Vec2,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32uint,
                typeU32Vec2,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32sint,
                typeU32Vec2,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rgba32float,
                typeU32Vec2,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32uint,
                typeU32Vec2,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32sint,
                typeU32Vec2,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_rg32float,
                typeU32Vec2,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32uint,
                typeU32Vec2,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32uint,
                typeI32Vec2,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32sint,
                typeU32Vec2,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2D_r32float,
                typeU32Vec2,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8unorm,
                typeU32Vec3,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8snorm,
                typeU32Vec3,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8uint,
                typeU32Vec3,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba8sint,
                typeU32Vec3,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16uint,
                typeU32Vec3,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16sint,
                typeU32Vec3,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba16float,
                typeU32Vec3,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32uint,
                typeU32Vec3,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32sint,
                typeU32Vec3,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rgba32float,
                typeU32Vec3,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32uint,
                typeU32Vec3,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32sint,
                typeU32Vec3,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_rg32float,
                typeU32Vec3,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32uint,
                typeU32Vec3,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32sint,
                typeU32Vec3,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage3D_r32float,
                typeU32Vec3,
                typeF32Vec4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (pb.getDevice().type === 'webgpu') {
                const tex = args[0];
                if (tex instanceof PBShaderExp) {
                    const texType = tex.$ast.getType();
                    if (texType?.isTextureType() && texType.isStorageTexture()) {
                        texType.writable = true;
                    }
                }
            }
            return callBuiltin(pb, name, ...args);
        }
    },
    // textureArrayStore(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, value: PBShaderExp);
    textureArrayStore: {
        overloads: [
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8unorm,
                typeI32Vec2,
                typeI32,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8snorm,
                typeI32Vec2,
                typeI32,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8uint,
                typeI32Vec2,
                typeI32,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba8sint,
                typeI32Vec2,
                typeI32,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16uint,
                typeI32Vec2,
                typeI32,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16sint,
                typeI32Vec2,
                typeI32,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba16float,
                typeI32Vec2,
                typeI32,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32uint,
                typeI32Vec2,
                typeI32,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32sint,
                typeI32Vec2,
                typeI32,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rgba32float,
                typeI32Vec2,
                typeI32,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32uint,
                typeI32Vec2,
                typeI32,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32sint,
                typeI32Vec2,
                typeI32,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_rg32float,
                typeI32Vec2,
                typeI32,
                typeF32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32uint,
                typeI32Vec2,
                typeI32,
                typeU32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32sint,
                typeI32Vec2,
                typeI32,
                typeI32Vec4
            ]),
            ...genType('textureStore', MASK_WEBGPU, typeVoid, [
                typeTexStorage2DArray_r32float,
                typeI32Vec2,
                typeI32,
                typeF32Vec4
            ])
        ]
    },
    // textureNumLayers(tex: PBShaderExp);
    textureNumLayers: {
        overloads: [
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeITex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeUTex2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeITexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeUTexCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexDepth2DArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexDepthCubeArray
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_r32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_r32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_r32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rg32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rg32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rg32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba16float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba16sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba16uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba32float
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba32sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba32uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba8sint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba8snorm
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba8uint
            ]),
            ...genType('textureNumLayers', MASK_WEBGPU, typeI32, [
                typeTexStorage2DArray_rgba8unorm
            ])
        ]
    },
    // textureNumLevels(tex: PBShaderExp);
    textureNumLevels: {
        overloads: [
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeITex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeUTex1D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeITex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeUTex2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeITex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeUTex2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeITex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeUTex3D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeITexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeUTexCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeITexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeUTexCubeArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTexDepth2D
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTexDepth2DArray
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTexDepthCube
            ]),
            ...genType('textureNumLevels', MASK_WEBGPU, typeI32, [
                typeTexDepthCubeArray
            ])
        ]
    },
    // textureNumSamples(tex: PBShaderExp);
    textureNumSamples: {
        overloads: [
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32, [
                typeTexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32, [
                typeITexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32, [
                typeUTexMultisampled2D
            ]),
            ...genType('textureNumSamples', MASK_WEBGPU, typeI32, [
                typeTexDepthMultisampled2D
            ])
        ]
    },
    // textureSample(tex: texture, coords: number|PBShaderExp);
    textureSample: {
        overloads: [
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4, [
                typeTex1D,
                typeSampler,
                typeF32
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4, [
                typeTex2D,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4, [
                typeTex3D,
                typeSampler,
                typeF32Vec3
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4, [
                typeTexCube,
                typeSampler,
                typeF32Vec3
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3
            ]),
            ...genType('textureSampleBaseClampToEdge', MASK_WEBGPU, typeF32Vec4, [
                typeTexExternal,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTex1D,
                typeF32Vec2
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTexExternal,
                typeF32Vec2
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTexDepth2D,
                typeF32Vec2
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTex3D,
                typeF32Vec3
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTexDepthCube,
                typeF32Vec3
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4, [
                typeTex1D,
                typeF32Vec2
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4, [
                typeTexExternal,
                typeF32Vec2
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4, [
                typeTexDepth2D,
                typeF32Vec2
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4, [
                typeTexDepthCube,
                typeF32Vec3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError('textureSample');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSample', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSample', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                if (texType.isStorageTexture()) {
                    throw new PBParamTypeError('textureSample', 'texture');
                }
                const sampler = pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const ret = callBuiltin(pb, name, tex, sampler, coords);
                if (ret.$ast.getType().isCompatibleType(typeF32)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                if (texType.is1DTexture()) {
                    if (args[1] instanceof PBShaderExp) {
                        const coordType = args[1].$ast.getType();
                        if (!coordType.isPrimitiveType() || !coordType.isScalarType() || coordType.scalarType !== PBPrimitiveType.F32) {
                            throw new PBParamTypeError('textureSample', 'coord');
                        }
                    } else if (typeof args[1] !== 'number') {
                        throw new PBParamTypeError('textureSample', 'coord');
                    }
                    args[1] = pb.vec2(args[1], 0);
                }
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySample(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp)
    textureArraySample: {
        overloads: [
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32Vec4, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32
            ]),
            ...genType('textureSample', MASK_WEBGPU, typeF32, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTex2DArray,
                typeF32Vec3
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTexDepth2DArray,
                typeF32Vec3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureArraySample');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySample', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySample', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const ret = callBuiltin(pb, name, tex, sampler, coords, arrayIndex);
                if (ret.$ast.getType().isCompatibleType(typeF32)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const coordsComposit = pb.vec3(coords, pb.float(arrayIndex));
                return callBuiltin(pb, name, tex, coordsComposit);
            }
        }
    },
    // textureSampleBias(tex: PBShaderExp, coords: PBShaderExp, bias: number|PBShaderExp)
    textureSampleBias: {
        overloads: [
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4, [
                typeTex2D,
                typeSampler,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4, [
                typeTex3D,
                typeSampler,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4, [
                typeTexCube,
                typeSampler,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTex3D,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('texture2D', MASK_WEBGL1, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureCube', MASK_WEBGL1, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3,
                typeF32
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleBias');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleBias', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleBias', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySampleBias(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, bias: number|PBShaderExp)
    textureArraySampleBias: {
        overloads: [
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32,
                typeF32
            ]),
            ...genType('textureSampleBias', MASK_WEBGPU, typeF32Vec4, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32Vec4, [
                typeTex2DArray,
                typeF32Vec3,
                typeF32
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleBias');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleBias', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySampleBias', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else if (pb.getDevice().type === 'webgl2') {
                pb.getDefaultSampler(tex, false);
                const coords = args[1];
                const arrayIndex = args[2];
                const coordsComposit = pb.vec3(coords, pb.float(arrayIndex));
                return callBuiltin(pb, name, tex, coordsComposit, args[3]);
            }
        }
    },
    // textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp)
    textureSampleCompare: {
        overloads: [
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32, [
                typeTexDepth2D,
                typeF32Vec3
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32, [
                typeTexDepthCube,
                typeF32Vec4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleCompare');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleCompare', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureSampleCompare', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(args[0], true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(args[0], true);
                let coordsComposite;
                if (texType.isCubeTexture() || texType.isArrayTexture()) {
                    coordsComposite = pb.vec4(args[1], args[2]);
                } else {
                    coordsComposite = pb.vec3(args[1], args[2]);
                }
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureArraySampleCompare(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp)
    textureArraySampleCompare: {
        overloads: [
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2,
                typeI32,
                typeF32
            ]),
            ...genType('textureSampleCompare', MASK_WEBGPU, typeF32, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3,
                typeI32,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32, [
                typeTexDepth2DArray,
                typeF32Vec4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleCompare');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleCompare', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureArraySampleCompare', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(args[0], true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(args[0], true);
                const coordsComposite = pb.vec4(args[1], pb.float(args[2]), args[3]);
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureSampleLevel(tex: PBShaderExp, coords: PBShaderExp, level: number|PBShaderExp)
    textureSampleLevel: {
        overloads: [
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4, [
                typeTex2D,
                typeSampler,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4, [
                typeTex3D,
                typeSampler,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4, [
                typeTexCube,
                typeSampler,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4, [
                typeTexExternal,
                typeSampler,
                typeF32Vec2
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32, [
                typeTexDepth2D,
                typeSampler,
                typeF32Vec2,
                typeI32
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32, [
                typeTexDepthCube,
                typeSampler,
                typeF32Vec3,
                typeI32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4, [
                typeTexDepth2D,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4, [
                typeTexExternal,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4, [
                typeTex3D,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4, [
                typeTexDepthCube,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4, [
                typeTexDepth2D,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('texture2DLodEXT', MASK_WEBGL1, typeF32Vec4, [
                typeTexExternal,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureCubeLodEXT', MASK_WEBGL1, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('textureCubeLodEXT', MASK_WEBGL1, typeF32Vec4, [
                typeTexDepthCube,
                typeF32Vec3,
                typeF32
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgl' && pb.shaderKind === 'vertex') {
                // WebGL1 does not support vertex texture lod
                return pb.textureSample(tex, args[1]);
            }
            if (pb.getDevice().type === 'webgpu') {
                if (texType.isExternalTexture()) {
                    return pb.textureLoad(tex, pb.ivec2(args[1]), 0);
                } else {
                    const sampler = pb.getDefaultSampler(tex, false);
                    const level = texType.isDepthTexture() && (typeof args[2] === 'number' || args[2] instanceof PBShaderExp && args[2].$ast.getType().isCompatibleType(typeF32)) ? pb.int(args[2]) : args[2];
                    const ret = texType.isExternalTexture() ? callBuiltin(pb, name, tex, sampler, args[1]) : callBuiltin(pb, name, tex, sampler, args[1], level);
                    if (ret.$ast.getType().isCompatibleType(typeF32)) {
                        return pb.vec4(ret);
                    } else {
                        return ret;
                    }
                }
            } else {
                pb.getDefaultSampler(tex, false);
                return texType.isExternalTexture() ? callBuiltin(pb, name, args[0], args[1], 0) : callBuiltin(pb, name, args[0], args[1], args[2]);
            }
        }
    },
    // textureArraySampleLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, level: number|PBShaderExp)
    textureArraySampleLevel: {
        overloads: [
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32,
                typeF32
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32Vec4, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32,
                typeF32
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32, [
                typeTexDepth2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32,
                typeI32
            ]),
            ...genType('textureSampleLevel', MASK_WEBGPU, typeF32, [
                typeTexDepthCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32,
                typeI32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32Vec4, [
                typeTex2DArray,
                typeF32Vec3,
                typeF32
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureArraySampleLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                const level = texType.isDepthTexture() && (typeof args[3] === 'number' || args[3] instanceof PBShaderExp && args[3].$ast.getType().isCompatibleType(typeF32)) ? pb.int(args[3]) : args[3];
                const ret = callBuiltin(pb, name, tex, sampler, args[1], args[2], level);
                if (ret.$ast.getType().isCompatibleType(typeF32)) {
                    return pb.vec4(ret);
                } else {
                    return ret;
                }
            } else {
                pb.getDefaultSampler(tex, false);
                const coordsComposite = pb.vec3(args[1], pb.float(args[2]));
                return callBuiltin(pb, name, tex, coordsComposite, args[3]);
            }
        }
    },
    // textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number|PBShaderExp)
    textureSampleCompareLevel: {
        overloads: [
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32, [
                typeTexDepth2D,
                typeSamplerComparison,
                typeF32Vec2,
                typeF32
            ]),
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32, [
                typeTexDepthCube,
                typeSamplerComparison,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('textureLod', MASK_WEBGL2, typeF32, [
                typeTexDepth2D,
                typeF32Vec3,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32, [
                typeTexDepthCube,
                typeF32Vec4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 3) {
                throw new PBParamLengthError('textureSampleCompareLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleCompareLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureSampleCompareLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2]);
            } else {
                pb.getDefaultSampler(args[0], true);
                let coordsComposite;
                if (texType.isCubeTexture() || texType.isArrayTexture()) {
                    coordsComposite = pb.vec4(args[1], args[2]);
                } else {
                    coordsComposite = pb.vec3(args[1], args[2]);
                }
                return texType.isCubeTexture() ? callBuiltin(pb, name, tex, coordsComposite) : callBuiltin(pb, name, tex, coordsComposite, 0);
            }
        }
    },
    // textureArraySampleCompareLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, depthRef: number|PBShaderExp)
    textureArraySampleCompareLevel: {
        overloads: [
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32, [
                typeTexDepth2DArray,
                typeSamplerComparison,
                typeF32Vec2,
                typeI32,
                typeF32
            ]),
            ...genType('textureSampleCompareLevel', MASK_WEBGPU, typeF32, [
                typeTexDepthCubeArray,
                typeSamplerComparison,
                typeF32Vec3,
                typeI32,
                typeF32
            ]),
            ...genType('texture', MASK_WEBGL2, typeF32, [
                typeTexDepth2DArray,
                typeF32Vec4
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureArraySampleCompareLevel');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleCompareLevel', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isDepthTexture()) {
                throw new PBParamTypeError('textureArraySampleCompareLevel', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, true);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(args[0], true);
                const coordsComposite = pb.vec4(args[1], pb.float(args[2]), args[3]);
                return callBuiltin(pb, name, tex, coordsComposite);
            }
        }
    },
    // textureSampleGrad(tex: PBShaderExp, coords: PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp)
    textureSampleGrad: {
        overloads: [
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4, [
                typeTex2D,
                typeSampler,
                typeF32Vec2,
                typeF32Vec2,
                typeF32Vec2
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4, [
                typeTex3D,
                typeSampler,
                typeF32Vec3,
                typeF32Vec3,
                typeF32Vec3
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4, [
                typeTexCube,
                typeSampler,
                typeF32Vec3,
                typeF32Vec3,
                typeF32Vec3
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2,
                typeF32Vec2,
                typeF32Vec2
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4, [
                typeTex3D,
                typeF32Vec3,
                typeF32Vec3,
                typeF32Vec3
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3,
                typeF32Vec3,
                typeF32Vec3
            ]),
            ...genType('texture2DGradEXT', MASK_WEBGL1, typeF32Vec4, [
                typeTex2D,
                typeF32Vec2,
                typeF32Vec2,
                typeF32Vec2
            ]),
            ...genType('textureCubeGradEXT', MASK_WEBGL1, typeF32Vec4, [
                typeTexCube,
                typeF32Vec3,
                typeF32Vec3,
                typeF32Vec3
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 4) {
                throw new PBParamLengthError('textureSampleGrad');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureSampleGrad', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType()) {
                throw new PBParamTypeError('textureSampleGrad', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3]);
            } else {
                pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, ...args);
            }
        }
    },
    // textureArraySampleGrad(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number|PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp)
    textureArraySampleGrad: {
        overloads: [
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4, [
                typeTex2DArray,
                typeSampler,
                typeF32Vec2,
                typeI32,
                typeF32Vec2,
                typeF32Vec2
            ]),
            ...genType('textureSampleGrad', MASK_WEBGPU, typeF32Vec4, [
                typeTexCubeArray,
                typeSampler,
                typeF32Vec3,
                typeI32,
                typeF32Vec3,
                typeF32Vec3
            ]),
            ...genType('textureGrad', MASK_WEBGL2, typeF32Vec4, [
                typeTex2DArray,
                typeF32Vec3,
                typeF32Vec2,
                typeF32Vec2
            ])
        ],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 5) {
                throw new PBParamLengthError('textureArraySampleGrad');
            }
            const tex = args[0];
            if (!(tex instanceof PBShaderExp)) {
                throw new PBParamTypeError('textureArraySampleGrad', 'texture');
            }
            const texType = tex.$ast.getType();
            if (!texType.isTextureType() || !texType.isArrayTexture()) {
                throw new PBParamTypeError('textureArraySampleGrad', 'texture');
            }
            if (pb.getDevice().type === 'webgpu') {
                const sampler = pb.getDefaultSampler(tex, false);
                return callBuiltin(pb, name, tex, sampler, args[1], args[2], args[3], args[4]);
            } else {
                pb.getDefaultSampler(tex, false);
                const coordsComposite = pb.vec3(args[1], pb.float(args[2]));
                return callBuiltin(pb, name, tex, coordsComposite, args[3], args[4]);
            }
        }
    },
    storageBarrier: {
        overloads: genType('storageBarrier', MASK_WEBGPU, typeVoid, [])
    },
    workgroupBarrier: {
        overloads: genType('workgroupBarrier', MASK_WEBGPU, typeVoid, [])
    },
    atomicLoad: {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 1) {
                throw new PBParamLengthError(name);
            }
            const arg = args[0];
            if (!(arg instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg.$ast.getType().typeId === typeAtomicI32.typeId) {
                return pb.$callFunctionNoCheck(name, [
                    new ASTAddressOf(arg.$ast)
                ], typeI32);
            } else if (arg.$ast.getType().typeId === typeAtomicU32.typeId) {
                return pb.$callFunctionNoCheck(name, [
                    new ASTAddressOf(arg.$ast)
                ], typeU32$1);
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    },
    atomicStore: {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError(name);
            }
            const arg1 = args[0];
            const arg2 = args[1];
            if (!(arg1 instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg1.$ast.getType().typeId === typeAtomicI32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeI32)
                    ], typeVoid);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeI32.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeVoid);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else if (arg1.$ast.getType().typeId === typeAtomicU32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeU32$1)
                    ], typeVoid);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeU32$1.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeVoid);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    }
};
for (const name of [
    'atomicAdd',
    'atomicSub',
    'atomicMax',
    'atomicMin',
    'atomicAnd',
    'atomicOr',
    'atomicXor',
    'atomicExchange'
]){
    builtinFunctionsAll[name] = {
        overloades: [],
        normalizeFunc (pb, name, ...args) {
            if (args.length !== 2) {
                throw new PBParamLengthError(name);
            }
            const arg1 = args[0];
            const arg2 = args[1];
            if (!(arg1 instanceof PBShaderExp)) {
                throw new PBParamTypeError(name, 'ptr');
            }
            if (arg1.$ast.getType().typeId === typeAtomicI32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeI32)
                    ], typeI32);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeI32.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeI32);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else if (arg1.$ast.getType().typeId === typeAtomicU32.typeId) {
                if (typeof arg2 === 'number') {
                    if (!Number.isInteger(arg2)) {
                        throw new PBParamValueError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        new ASTScalar(arg2, typeU32$1)
                    ], typeU32$1);
                } else if (arg2 instanceof PBShaderExp) {
                    if (arg2.$ast.getType().typeId !== typeU32$1.typeId) {
                        throw new PBParamTypeError(name, 'value');
                    }
                    return pb.$callFunctionNoCheck(name, [
                        new ASTAddressOf(arg1.$ast),
                        arg2.$ast
                    ], typeU32$1);
                } else {
                    throw new PBParamTypeError(name, 'value');
                }
            } else {
                throw new PBParamValueError(name, 'ptr must be atomic type');
            }
        }
    };
}
/** @internal */ function setBuiltinFuncs(cls) {
    for (const k of Object.keys(builtinFunctionsAll)){
        cls.prototype[k] = function(...args) {
            const normalizeFunc = builtinFunctionsAll?.[k]?.normalizeFunc || callBuiltin;
            return normalizeFunc(this, k, ...args);
        };
    }
}

const StorageTextureFormatMap = {
    rgba8unorm: 'rgba8unorm',
    rgba8snorm: 'rgba8snorm',
    rgba8uint: 'rgba8ui',
    rgba8sint: 'rgba8i',
    rgba16uint: 'rgba16ui',
    rgba16sint: 'rgba16i',
    rgba16float: 'rgba16f',
    r32float: 'r32f',
    r32uint: 'r32ui',
    r32sint: 'r32i',
    rg32float: 'rg32f',
    rg32uint: 'rg32ui',
    rg32sint: 'rg32i',
    rgba32float: 'rgba32f',
    rgba32uint: 'rgba32ui',
    rgba32sint: 'rgba32i'
};
function vec_n(vecType, ...args) {
    if (this.getDevice().type === 'webgl') {
        if (vecType.scalarType === PBPrimitiveType.U32) {
            throw new PBDeviceNotSupport('unsigned integer type');
        }
        if (vecType.isMatrixType() && vecType.cols !== vecType.rows) {
            throw new PBDeviceNotSupport('non-square matrix type');
        }
    }
    if (args.length === 1 && typeof args[0] === 'string') {
        return new PBShaderExp(args[0], vecType);
    } else {
        const exp = new PBShaderExp('', vecType);
        if (vecType.isScalarType() && args.length === 1 && (typeof args[0] === 'number' || typeof args[0] === 'boolean')) {
            exp.$ast = new ASTScalar(args[0], vecType);
        } else {
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, args.map((arg)=>{
                if (typeof arg === 'string') {
                    throw new PBParamTypeError('vec_n');
                }
                return arg instanceof PBShaderExp ? arg.$ast : arg;
            }));
        }
        return exp;
    }
}
const primitiveCtors = {
    float: typeF32,
    int: typeI32,
    uint: typeU32$1,
    bool: typeBool,
    vec2: typeF32Vec2,
    ivec2: typeI32Vec2,
    uvec2: typeU32Vec2,
    bvec2: typeBVec2,
    vec3: typeF32Vec3,
    ivec3: typeI32Vec3,
    uvec3: typeU32Vec3,
    bvec3: typeBVec3,
    vec4: typeF32Vec4,
    ivec4: typeI32Vec4,
    uvec4: typeU32Vec4,
    bvec4: typeBVec4,
    mat2: typeMat2,
    mat2x3: typeMat2x3,
    mat2x4: typeMat2x4,
    mat3x2: typeMat3x2,
    mat3: typeMat3,
    mat3x4: typeMat3x4,
    mat4x2: typeMat4x2,
    mat4x3: typeMat4x3,
    mat4: typeMat4
};
const simpleCtors = {
    tex1D: typeTex1D,
    tex2D: typeTex2D,
    tex3D: typeTex3D,
    texCube: typeTexCube,
    tex2DShadow: typeTexDepth2D,
    texCubeShadow: typeTexDepthCube,
    tex2DArray: typeTex2DArray,
    tex2DArrayShadow: typeTexDepth2DArray,
    texExternal: typeTexExternal,
    itex1D: typeITex1D,
    itex2D: typeITex2D,
    itex3D: typeITex3D,
    itexCube: typeITexCube,
    itex2DArray: typeITex2DArray,
    utex1D: typeUTex1D,
    utex2D: typeUTex2D,
    utex3D: typeUTex3D,
    utexCube: typeUTexCube,
    utex2DArray: typeUTex2DArray,
    sampler: typeSampler,
    samplerComparison: typeSamplerComparison
};
function makeStorageTextureCtor(type) {
    const ctor = {};
    for (const k of Object.keys(StorageTextureFormatMap)){
        ctor[k] = function(rhs) {
            return new PBShaderExp(rhs, new PBTextureTypeInfo(type, StorageTextureFormatMap[k]));
        };
    }
    return ctor;
}
const texStorageCtors = {
    texStorage1D: PBTextureType.TEX_STORAGE_1D,
    texStorage2D: PBTextureType.TEX_STORAGE_2D,
    texStorage2DArray: PBTextureType.TEX_STORAGE_2D_ARRAY,
    texStorage3D: PBTextureType.TEX_STORAGE_3D
};
/** @internal */ function setConstructors(cls) {
    Object.keys(primitiveCtors).forEach((k)=>{
        cls.prototype[k] = makeConstructor(function(...args) {
            return vec_n.call(this, primitiveCtors[k], ...args);
        }, primitiveCtors[k]);
    });
    Object.keys(simpleCtors).forEach((k)=>{
        cls.prototype[k] = function(rhs) {
            return new PBShaderExp(rhs, simpleCtors[k]);
        };
    });
    Object.keys(texStorageCtors).forEach((k)=>{
        cls.prototype[k] = makeStorageTextureCtor(texStorageCtors[k]);
    });
    cls.prototype['atomic_int'] = makeConstructor(function(...args) {
        if (args.length > 1) {
            throw new PBParamLengthError('atomic_int');
        }
        if (args.length === 1) {
            if (typeof args[0] !== 'string') {
                throw new PBParamTypeError('atomic_int', 'name');
            }
            return new PBShaderExp(args[0], typeAtomicI32);
        } else {
            const exp = new PBShaderExp('', typeAtomicI32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, []);
            return exp;
        }
    }, typeAtomicI32);
    cls.prototype['atomic_uint'] = makeConstructor(function(...args) {
        if (args.length > 1) {
            throw new PBParamLengthError('atomic_uint');
        }
        if (args.length === 1 && typeof args[0] === 'string') {
            return new PBShaderExp(args[0], typeAtomicU32);
        } else if (args.length === 0) {
            const exp = new PBShaderExp('', typeAtomicU32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, []);
            return exp;
        }
        const arg = args[0];
        if (typeof arg === 'number' && Number.isInteger(arg) || arg instanceof PBShaderExp && arg.$ast.getType().typeId === typeU32$1.typeId) {
            const exp = new PBShaderExp('', typeAtomicU32);
            exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, [
                arg instanceof PBShaderExp ? arg.$ast : arg
            ]);
            return exp;
        }
        return null;
    }, typeAtomicU32);
} /*
ProgramBuilder.prototype.texStorage1D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_1D);
ProgramBuilder.prototype.texStorage2D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_2D);
ProgramBuilder.prototype.texStorage2DArray = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_2D_ARRAY);
ProgramBuilder.prototype.texStorage3D = makeStorageTextureCtor(typeinfo.PBTextureType.TEX_STORAGE_3D);
*/

const COMPUTE_UNIFORM_NAME = 'ch_compute_uniform_block';
const COMPUTE_STORAGE_NAME = 'ch_compute_storage_block';
const VERTEX_UNIFORM_NAME = 'ch_vertex_uniform_block';
const FRAGMENT_UNIFORM_NAME = 'ch_fragment_uniform_block';
const SHARED_UNIFORM_NAME = 'ch_shared_uniform_block';
const VERTEX_STORAGE_NAME = 'ch_vertex_storage_block';
const FRAGMENT_STORAGE_NAME = 'ch_fragment_storage_block';
const SHARED_STORAGE_NAME = 'ch_shared_storage_block';
const input_prefix = 'zVSInput_';
const output_prefix_vs = 'zVSOutput_';
const output_prefix_fs = 'zFSOutput_';
/**
 * The program builder class
 * @public
 */ class ProgramBuilder {
    /** @internal */ _device;
    /** @internal */ _workgroupSize;
    /** @internal */ _scopeStack = [];
    /** @internal */ _shaderType = ShaderType.Vertex | ShaderType.Fragment | ShaderType.Compute;
    /** @internal */ _structInfo;
    /** @internal */ _uniforms;
    /** @internal */ _globalScope;
    /** @internal */ _builtinScope;
    /** @internal */ _inputScope;
    /** @internal */ _outputScope;
    /** @internal */ _inputs;
    /** @internal */ _outputs;
    /** @internal */ _vertexAttributes;
    /** @internal */ _depthRangeCorrection;
    /** @internal */ _emulateDepthClamp;
    /** @internal */ _lastError;
    /** @internal */ _reflection;
    /** @internal */ _autoStructureTypeIndex;
    /** @internal */ _nameMap;
    /**
   * Creates a program builder for given device
   * @param device - The device
   */ constructor(device){
        this._device = device;
        this._workgroupSize = null;
        this._structInfo = {};
        this._uniforms = [];
        this._scopeStack = [];
        this._globalScope = null;
        this._builtinScope = null;
        this._inputScope = null;
        this._outputScope = null;
        this._inputs = [];
        this._outputs = [];
        this._vertexAttributes = [];
        this._depthRangeCorrection = device.type === 'webgpu';
        this._emulateDepthClamp = false;
        this._lastError = null;
        this._reflection = new PBReflection(this);
        this._autoStructureTypeIndex = 0;
        this._nameMap = [];
    }
    /** Get last error */ get lastError() {
        return this._lastError;
    }
    /** @internal */ get shaderType() {
        return this._shaderType;
    }
    /** Current shader kind */ get shaderKind() {
        return this._shaderType === ShaderType.Vertex ? 'vertex' : this._shaderType === ShaderType.Fragment ? 'fragment' : this._shaderType === ShaderType.Compute ? 'compute' : null;
    }
    /** Gets the global scope */ getGlobalScope() {
        return this._globalScope;
    }
    /** @internal */ get builtinScope() {
        return this._builtinScope;
    }
    /** @internal */ get inputScope() {
        return this._inputScope;
    }
    /** @internal */ get outputScope() {
        return this._outputScope;
    }
    /** @internal */ get depthRangeCorrection() {
        return this._depthRangeCorrection;
    }
    get emulateDepthClamp() {
        return this._emulateDepthClamp;
    }
    set emulateDepthClamp(val) {
        this._emulateDepthClamp = val;
    }
    /** Get the shader code reflection interface */ getReflection() {
        return this._reflection;
    }
    /** Get the device */ getDevice() {
        return this._device;
    }
    /** @internal */ reset() {
        this._workgroupSize = null;
        this._structInfo = {};
        this._uniforms = [];
        this._scopeStack = [];
        this._globalScope = null;
        this._builtinScope = null;
        this._inputScope = null;
        this._outputScope = null;
        this._inputs = [];
        this._outputs = [];
        this._vertexAttributes = [];
        this._depthRangeCorrection = this._device.type === 'webgpu';
        this._reflection = new PBReflection(this);
        this._autoStructureTypeIndex = 0;
        this._nameMap = [];
    }
    /**
   * Query the global variable by the name
   * @param name - Name of the variable
   * @returns The variable or null if not exists
   */ queryGlobal(name) {
        return this.getReflection().tag(name);
    }
    /** @internal */ pushScope(scope) {
        this._scopeStack.unshift(scope);
    }
    /** @internal */ popScope() {
        return this._scopeStack.shift();
    }
    /** Gets the current scope */ getCurrentScope() {
        return this._scopeStack[0];
    }
    /** Gets the current function scope */ getCurrentFunctionScope() {
        let funcScope = this.getCurrentScope();
        while(funcScope && !(funcScope instanceof PBFunctionScope)){
            funcScope = funcScope.$parent;
        }
        return funcScope;
    }
    /**
   * Generates shader codes for a render program
   * @param options - The build options
   * @returns a tuple made by vertex shader source, fragment shader source, bind group layouts and vertex attributes used, or null if build faild
   */ buildRender(options) {
        setCurrentProgramBuilder(this);
        this._lastError = null;
        this.defineInternalStructs();
        const ret = this.buildRenderSource(options);
        setCurrentProgramBuilder(null);
        this.reset();
        return ret;
    }
    /**
   * Generates shader code for a compute program
   * @param options - The build programs
   * @returns a tuple made by compute shader source and bind group layouts, or null if build failed
   */ buildCompute(options) {
        setCurrentProgramBuilder(this);
        this._lastError = null;
        this._workgroupSize = options.workgroupSize;
        this.defineInternalStructs();
        const ret = this.buildComputeSource(options);
        setCurrentProgramBuilder(null);
        this.reset();
        return ret;
    }
    /**
   * Creates a shader program for render
   * @param options - The build options
   * @returns The created program or null if build failed
   */ buildRenderProgram(options) {
        const ret = this.buildRender(options);
        return ret ? this._device.createGPUProgram({
            type: 'render',
            label: options.label,
            params: {
                vs: ret[0],
                fs: ret[1],
                bindGroupLayouts: ret[2],
                vertexAttributes: ret[3]
            }
        }) : null;
    }
    /**
   * Creates a shader program for compute
   * @param options - The build options
   * @returns The created program or null if build failed
   */ buildComputeProgram(options) {
        const ret = this.buildCompute(options);
        return ret ? this._device.createGPUProgram({
            type: 'compute',
            params: {
                source: ret[0],
                bindGroupLayouts: ret[1]
            }
        }) : null;
    }
    /**
   * Creates a function
   * @param name - Name of the function
   * @param params - Parameters of the function
   * @param body - The generator function
   */ func(name, params, body) {
        this.getGlobalScope().$createFunctionIfNotExists(name, params, body);
    }
    /**
   * Create the main entry function of the shader
   * @param body - The shader generator function
   */ main(body) {
        this.getGlobalScope().$mainFunc(body);
    }
    /**
   * Create an 'AddressOf' expression for WGSL
   * @param ref - The reference variable
   * @returns the 'AddressOf' expression
   */ addressOf(ref) {
        if (this._device.type !== 'webgpu') {
            throw new PBDeviceNotSupport('pointer shader type');
        }
        if (!ref.$ast.isReference()) {
            throw new PBReferenceValueRequired(ref);
        }
        const exp = new PBShaderExp('', ref.$ast.getType());
        exp.$ast = new ASTAddressOf(ref.$ast);
        return exp;
    }
    /**
   * Creates a 'referenceOf' expression for WGSL
   * @param ptr - The pointer variable
   * @returns the 'referenceOf' expression
   */ referenceOf(ptr) {
        if (this._device.type !== 'webgpu') {
            throw new PBDeviceNotSupport('pointer shader type');
        }
        if (!ptr.$ast.getType().isPointerType()) {
            throw new PBPointerValueRequired(ptr);
        }
        const ast = new ASTReferenceOf(ptr.$ast);
        const exp = new PBShaderExp('', ast.getType());
        exp.$ast = ast;
        return exp;
    }
    /**
   * Creates a structure type variable
   * @param structName - Name of the structure type
   * @param instanceName - Name of the variable
   * @returns the created variable
   */ struct(structName, instanceName) {
        let ctor = null;
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & this._shaderType) {
                const structInfo = this._structInfo[st];
                ctor = structInfo?.structs[structName];
                if (ctor) {
                    break;
                }
            }
        }
        if (!ctor) {
            throw new PBParamValueError('struct', 'structName', `Struct type ${structName} not exists`);
        }
        return ctor.call(this, instanceName);
    }
    /** @internal */ isIdenticalStruct(a, b, checkName) {
        if (checkName && a.structName && b.structName && a.structName !== b.structName) {
            return false;
        }
        if (a.structMembers.length !== b.structMembers.length) {
            return false;
        }
        for(let index = 0; index < a.structMembers.length; index++){
            const val = a.structMembers[index];
            const other = b.structMembers[index];
            if (val.name !== other.name) {
                return false;
            }
            if (val.type.isStructType()) {
                if (!other.type.isStructType()) {
                    return false;
                }
                if (!this.isIdenticalStruct(val.type, other.type, true)) {
                    return false;
                }
            } else if (!val.type.isCompatibleType(other.type)) {
                return false;
            }
        }
        return true;
    }
    /** @internal */ generateStructureName() {
        return `zStruct${this._autoStructureTypeIndex++}`;
    }
    /** @internal */ getVertexAttributes() {
        return this._vertexAttributes;
    }
    /** @internal */ defineHiddenStruct(type) {
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structInfo = this._structInfo[shaderType];
            if (!structInfo) {
                structInfo = {
                    structs: {},
                    types: []
                };
                this._structInfo[shaderType] = structInfo;
            }
            if (structInfo.structs[type.structName]) {
                throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${type.structName}'`);
            }
            structInfo.types.push(new ASTStructDefine(type, true));
        }
    }
    // /**
    //  * Defines an uniform buffer
    //  * @param name - Name of the uniform buffer
    //  * @param args - Members of the buffer structure
    //  * @returns The structure type constructor
    //  */
    // defineUniformBuffer(name: string, ...args: PBShaderExp[]): ShaderTypeFunc {
    //   return this.defineStructOrUniformBuffer(name, 'std140', ...args);
    // }
    // /**
    //  * Defines a structure type
    //  * @param structName - Name of the type
    //  * @param layout - The structure layout
    //  * @param args - Members of the structure
    //  * @returns The structure type constructor
    //  */
    // defineStruct(structName: string, ...args: PBShaderExp[]): ShaderTypeFunc {
    //   return this.defineStructOrUniformBuffer(structName, 'default', ...args);
    // }
    /**
   * Defines a structure type
   * @param members - Members of the structure
   * @param structName - Name of the type
   * @returns The structure type constructor
   */ defineStruct(members, structName) {
        const layout = 'default';
        const structType = new PBStructTypeInfo(structName ?? '', layout, members.map((arg)=>{
            if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType() && !arg.$typeinfo.isAtomicI32() && !arg.$typeinfo.isAtomicU32()) {
                throw new Error(`invalid struct member type: '${arg.$str}'`);
            }
            return {
                name: arg.$str,
                type: arg.$typeinfo
            };
        }));
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structDef = null;
            let ctor = null;
            const structInfo = this._structInfo[shaderType];
            if (structInfo) {
                if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[structType.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);
                }
                for (const type of structInfo.types){
                    if (!type.builtin && this.isIdenticalStruct(type.getType(), structType, false)) {
                        structDef = type;
                        ctor = structInfo.structs[type.getType().structName];
                        break;
                    }
                }
            }
            if (structDef) {
                if (structDef.type.layout !== layout) {
                    throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);
                }
                if (shaderType !== getCurrentProgramBuilder().shaderType) {
                    if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {
                        this._structInfo[getCurrentProgramBuilder().shaderType] = {
                            structs: {},
                            types: []
                        };
                    }
                    if (this._structInfo[getCurrentProgramBuilder().shaderType].types.indexOf(structDef) < 0) {
                        this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);
                        this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;
                    }
                }
                return ctor;
            }
        }
        return this.internalDefineStruct(structName ?? this.generateStructureName(), layout, this._shaderType, false, ...members);
    }
    /**
   * Defines a structure type
   * @param structType - The structure type info
   * @returns The structure type constructor
   */ defineStructByType(structType) {
        const typeCopy = structType.extends(structType.structName || this.generateStructureName(), []);
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            let structDef = null;
            let ctor = null;
            const structInfo = this._structInfo[shaderType];
            if (structInfo) {
                if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[typeCopy.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${typeCopy.structName}'`);
                }
                for (const type of structInfo.types){
                    if (!type.builtin && this.isIdenticalStruct(type.getType(), typeCopy, false)) {
                        structDef = type;
                        ctor = structInfo.structs[type.getType().structName];
                        break;
                    }
                }
            }
            if (structDef) {
                if (structDef.type.layout !== typeCopy.layout) {
                    throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);
                }
                if (shaderType !== getCurrentProgramBuilder().shaderType) {
                    if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {
                        this._structInfo[getCurrentProgramBuilder().shaderType] = {
                            structs: {},
                            types: []
                        };
                    }
                    this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);
                    this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;
                }
                return ctor;
            }
        }
        return this.internalDefineStructByType(this._shaderType, false, typeCopy);
    }
    /** @internal */ internalDefineStruct(structName, layout, shaderTypeMask, builtin, ...args) {
        const structType = new PBStructTypeInfo(structName, layout, args.map((arg)=>{
            if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType() && !arg.$typeinfo.isAtomicI32() && !arg.$typeinfo.isAtomicU32()) {
                throw new Error(`invalid struct member type: '${arg.$str}'`);
            }
            return {
                name: arg.$str,
                type: arg.$typeinfo
            };
        }));
        return this.internalDefineStructByType(shaderTypeMask, builtin, structType);
    }
    /** @internal */ internalDefineStructByType(shaderTypeMask, builtin, structType) {
        const struct = makeConstructor(function structConstructor(...blockArgs) {
            let e;
            if (blockArgs.length === 1 && typeof blockArgs[0] === 'string') {
                e = new PBShaderExp(blockArgs[0], structType);
            } else {
                e = new PBShaderExp('', structType);
                e.$ast = new ASTShaderExpConstructor(e.$typeinfo, blockArgs.map((arg)=>arg instanceof PBShaderExp ? arg.$ast : arg));
            }
            return e;
        }, structType);
        for (const shaderType of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (shaderTypeMask & shaderType) {
                let structInfo = this._structInfo[shaderType];
                if (!structInfo) {
                    structInfo = {
                        structs: {},
                        types: []
                    };
                    this._structInfo[shaderType] = structInfo;
                }
                if (structInfo.structs[structType.structName]) {
                    throw new PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);
                }
                structInfo.types.push(new ASTStructDefine(structType, builtin));
                structInfo.structs[structType.structName] = struct;
            }
        }
        // this.changeStructLayout(structType, layout);
        return struct;
    }
    /** @internal */ getFunction(name) {
        return this._globalScope ? this._globalScope.$getFunctions(name) : null;
    }
    /** @internal */ get structInfo() {
        return this._structInfo[this._shaderType];
    }
    /** @internal */ getBlockName(instanceName) {
        return `ch_block_name_${instanceName}`;
    }
    /** @internal */ defineBuiltinStruct(shaderType, inOrOut) {
        const structName = inOrOut === 'in' ? getBuiltinInputStructName(shaderType) : getBuiltinOutputStructName(shaderType);
        const instanceName = inOrOut === 'in' ? getBuiltinInputStructInstanceName(shaderType) : getBuiltinOutputStructInstanceName(shaderType);
        const stage = shaderType === ShaderType.Vertex ? 'vertex' : shaderType === ShaderType.Fragment ? 'fragment' : 'compute';
        const builtinVars = builtinVariables['webgpu'];
        const args = [];
        const prefix = [];
        for(const k in builtinVars){
            if (builtinVars[k].stage === stage && builtinVars[k].inOrOut === inOrOut) {
                args.push({
                    name: builtinVars[k].name,
                    type: builtinVars[k].type
                });
                prefix.push(`@builtin(${builtinVars[k].semantic}) `);
            }
        }
        const inoutList = inOrOut === 'in' ? this._inputs : this._outputs;
        for (const k of inoutList){
            // for debug only
            if (!(k[1] instanceof ASTDeclareVar)) {
                throw new PBInternalError('defineBuiltinStruct() failed: input/output is not declare var ast node');
            }
            const type = k[1].value.getType();
            if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {
                throw new Error(`invalid in/out variable type: '${k[1].value.name}'`);
            }
            args.push({
                name: k[1].value.name,
                type: type
            });
            prefix.push(`@location(${k[1].value.value.$location}) ${type.isPrimitiveType() && type.isInteger() ? '@interpolate(flat) ' : ''}`);
        }
        if (args.length > 0) {
            const st = this.findStructType(structName, shaderType);
            if (st) {
                st.getType().reset(structName, 'default', args);
                st.prefix = prefix;
                return null;
            } else {
                const structType = this.internalDefineStructByType(this._shaderType, false, new PBStructTypeInfo(structName, 'default', args));
                this.findStructType(structName, shaderType).prefix = prefix;
                const structInstance = this.struct(structName, instanceName);
                const structInstanceIN = inOrOut === 'in' ? this.struct(structName, getBuiltinParamName(shaderType)) : structInstance;
                return [
                    structType,
                    structInstance,
                    structName,
                    structInstanceIN
                ];
            }
        } else {
            return null;
        }
    }
    /** @internal */ defineInternalStructs() {
        this.defineHiddenStruct(typeFrexpResult);
        this.defineHiddenStruct(typeFrexpResultVec2);
        this.defineHiddenStruct(typeFrexpResultVec3);
        this.defineHiddenStruct(typeFrexpResultVec4);
    }
    /** @internal */ array(...args) {
        if (args.length === 0) {
            throw new PBParamLengthError('array');
        }
        args = args.map((arg)=>this.normalizeExpValue(arg));
        let typeok = true;
        let type = null;
        let isBool = true;
        let isFloat = true;
        let isInt = true;
        let isUint = true;
        let isComposite = false;
        for (const arg of args){
            if (arg instanceof PBShaderExp) {
                const argType = arg.$ast.getType();
                if (!argType.isConstructible()) {
                    typeok = false;
                    break;
                }
                if (!type) {
                    type = argType;
                } else if (!argType.isCompatibleType(type)) {
                    typeok = false;
                }
            }
        }
        if (typeok) {
            if (type && type.isPrimitiveType() && type.isScalarType()) {
                isBool = type.primitiveType === PBPrimitiveType.BOOL;
                isFloat = type.primitiveType === PBPrimitiveType.F32;
                isUint = type.primitiveType === PBPrimitiveType.U32;
                isInt = type.primitiveType === PBPrimitiveType.I32;
            } else if (type) {
                isBool = false;
                isFloat = false;
                isUint = false;
                isInt = false;
                isComposite = true;
            }
            for (const arg of args){
                if (!(arg instanceof PBShaderExp) && isComposite) {
                    typeok = false;
                    break;
                }
                if (typeof arg === 'number') {
                    isBool = false;
                    if ((arg | 0) === arg) {
                        if (arg < 0) {
                            isUint = false;
                            isInt = isInt && arg >= 0x80000000 >> 0;
                        } else {
                            isUint = isUint && arg <= 0xffffffff;
                            isInt = isInt && arg <= 0x7fffffff;
                        }
                    }
                } else if (typeof arg === 'boolean') {
                    isFloat = false;
                    isInt = false;
                    isUint = false;
                }
            }
        }
        if (typeok && !isComposite) {
            if (isBool) {
                type = typeBool;
            } else if (isInt) {
                type = typeI32;
            } else if (isUint) {
                type = typeU32$1;
            } else if (isFloat) {
                type = typeF32;
            }
            typeok = !!type;
        }
        if (!typeok) {
            throw new PBParamTypeError('array');
        }
        if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {
            throw new PBParamTypeError('array');
        }
        const arrayType = new PBArrayTypeInfo(type, args.length);
        const exp = new PBShaderExp('', arrayType);
        exp.$ast = new ASTShaderExpConstructor(arrayType, args.map((arg)=>{
            if (arg instanceof PBShaderExp) {
                return arg.$ast;
            }
            if (!type.isPrimitiveType() || !type.isScalarType()) {
                throw new PBTypeCastError(arg, typeof arg, type);
            }
            return new ASTScalar(arg, type);
        }));
        return exp;
    }
    /**
   * Creates a 'discard' statement
   */ discard() {
        this.getCurrentScope().$ast.statements.push(new ASTDiscard());
    }
    /** @internal */ tagShaderExp(getter, tagValue) {
        if (typeof tagValue === 'string') {
            this._reflection.tag(tagValue, getter);
        } else if (Array.isArray(tagValue)) {
            tagValue.forEach((tag)=>this.tagShaderExp(getter, tag));
        } else {
            for (const k of Object.keys(tagValue)){
                this.tagShaderExp((scope)=>{
                    const value = getter(scope);
                    return value[k];
                }, tagValue[k]);
            }
        }
    }
    /** @internal */ in(location, name, variable) {
        if (this._inputs[location]) {
            // input already exists, create an alias
            if (!this._inputScope[name]) {
                Object.defineProperty(this._inputScope, name, {
                    get: function() {
                        return variable;
                    },
                    set: function() {
                        throw new Error(`cannot assign to readonly variable: ${name}`);
                    }
                });
            }
        //throw new Error(`input location ${location} already declared`);
        } else {
            variable.$location = location;
            variable.$declareType = DeclareType.DECLARE_TYPE_IN;
            this._inputs[location] = [
                name,
                new ASTDeclareVar(new ASTPrimitive(variable))
            ];
            Object.defineProperty(this._inputScope, name, {
                get: function() {
                    return variable;
                },
                set: function() {
                    throw new Error(`cannot assign to readonly variable: ${name}`);
                }
            });
            variable.$tags.forEach((val)=>this.tagShaderExp(()=>variable, val));
        }
    }
    /** @internal */ out(location, name, variable) {
        if (this._outputs[location]) {
            throw new Error(`output location ${location} has already been used`);
        }
        variable.$location = location;
        variable.$declareType = DeclareType.DECLARE_TYPE_OUT;
        this._outputs[location] = [
            name,
            new ASTDeclareVar(new ASTPrimitive(variable))
        ];
        for (const prop of [
            name,
            String(location)
        ]){
            Object.defineProperty(this._outputScope, prop, {
                get: function() {
                    return variable;
                },
                set: function(v) {
                    getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(variable.$ast), v instanceof PBShaderExp ? v.$ast : v));
                }
            });
        }
    }
    /** @internal */ getDefaultSampler(t, comparison) {
        const u = this._uniforms.findIndex((val)=>val.texture?.exp === t);
        if (u < 0) {
            return;
        //throw new Error('invalid texture uniform object');
        }
        const samplerType = comparison ? 'comparison' : 'sample';
        if (this._uniforms[u].texture.autoBindSampler && this._uniforms[u].texture.autoBindSampler !== samplerType) {
            throw new Error('multiple sampler not supported');
        }
        this._uniforms[u].texture.autoBindSampler = samplerType;
        if (this._device.type === 'webgpu') {
            const samplerName = genSamplerName(t.$str, comparison);
            if (!this.getGlobalScope()[samplerName]) {
                throw new Error(`failed to find sampler name ${samplerName}`);
            }
            return this.getGlobalScope()[samplerName];
        } else {
            return null;
        }
    }
    /** @internal */ normalizeExpValue(value) {
        if (Array.isArray(value)) {
            const converted = value.map((val)=>Array.isArray(val) ? this.normalizeExpValue(val) : val);
            return this.array(...converted);
        } else {
            return value;
        }
    }
    /** @internal */ guessExpValueType(value) {
        const val = this.normalizeExpValue(value);
        if (typeof val === 'boolean') {
            return typeBool;
        } else if (typeof val === 'number') {
            if (!Number.isInteger(val)) {
                return typeF32;
            } else if (val >= 0x80000000 >> 1 && val <= 0x7fffffff) {
                return typeI32;
            } else if (val >= 0 && val <= 0xffffffff) {
                return typeU32$1;
            } else {
                throw new PBValueOutOfRange(val);
            }
        } else if (val instanceof PBShaderExp) {
            return val.$ast?.getType() || val.$typeinfo;
        }
    }
    /** @internal */ findStructType(name, shaderType) {
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & shaderType) {
                const structInfo = this._structInfo[st];
                if (structInfo) {
                    for (const t of structInfo.types){
                        if (t.type.structName === name) {
                            return t;
                        }
                    }
                }
            }
        }
        return null;
    }
    /** @internal */ findStructConstructor(name, shaderType) {
        for (const st of [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Compute
        ]){
            if (st & shaderType) {
                const structInfo = this._structInfo[st];
                if (structInfo && structInfo.structs?.[name]) {
                    return structInfo.structs[name];
                }
            }
        }
        return null;
    }
    /** @internal */ buildComputeSource(options) {
        try {
            this._lastError = null;
            this._shaderType = ShaderType.Compute;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            this.generate(options.compute);
            // this.removeUnusedSamplerBindings(this._globalScope);
            this.mergeUniformsCompute(this._globalScope);
            this.updateUniformBindings([
                this._globalScope
            ], [
                ShaderType.Compute
            ]);
            return [
                this.generateComputeSource(this._globalScope, this._builtinScope),
                this.createBindGroupLayouts(options.label)
            ];
        } catch (err) {
            if (err instanceof PBError) {
                this._lastError = err.getMessage(this._device.type);
                console.error(this._lastError);
                return null;
            } else if (err instanceof Error) {
                this._lastError = err.toString();
                console.error(this._lastError);
                return null;
            } else {
                this._lastError = Object.prototype.toString.call(err);
                console.log(`Error: ${this._lastError}`);
                return null;
            }
        }
    }
    /** @internal */ buildRenderSource(options) {
        try {
            this._lastError = null;
            this._shaderType = ShaderType.Vertex;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            this.generate(options.vertex);
            const vertexScope = this._globalScope;
            const vertexBuiltinScope = this._builtinScope;
            const vertexInputs = this._inputs;
            const vertexOutputs = this._outputs;
            if (this._device.type === 'webgpu') {
            // this.removeUnusedSamplerBindings(vertexScope);
            }
            this._shaderType = ShaderType.Fragment;
            this._scopeStack = [];
            this._globalScope = new PBGlobalScope();
            this._builtinScope = new PBBuiltinScope();
            this._inputs = [];
            this._outputs = [];
            this._inputScope = new PBInputScope();
            this._outputScope = new PBOutputScope();
            this._reflection.clear();
            vertexOutputs.forEach((val, index)=>{
                this.in(index, val[0], new PBShaderExp(val[1].value.name, val[1].value.getType()).tag(...val[1].value.value.$tags));
            });
            this.generate(options.fragment);
            const fragScope = this._globalScope;
            const fragBuiltinScope = this._builtinScope;
            const fragInputs = this._inputs;
            const fragOutputs = this._outputs;
            if (this._device.type === 'webgpu') {
            // this.removeUnusedSamplerBindings(fragScope);
            }
            this.mergeUniforms(vertexScope, fragScope);
            this.updateUniformBindings([
                vertexScope,
                fragScope
            ], [
                ShaderType.Vertex,
                ShaderType.Fragment
            ]);
            return [
                this.generateRenderSource(ShaderType.Vertex, vertexScope, vertexBuiltinScope, vertexInputs.map((val)=>val[1]), vertexOutputs.map((val)=>val[1])),
                this.generateRenderSource(ShaderType.Fragment, fragScope, fragBuiltinScope, fragInputs.map((val)=>val[1]), fragOutputs.map((val)=>val[1])),
                this.createBindGroupLayouts(options.label),
                this._vertexAttributes
            ];
        } catch (err) {
            if (err instanceof PBError) {
                this._lastError = err.getMessage(this._device.type);
                console.error(this._lastError);
                return null;
            } else if (err instanceof Error) {
                this._lastError = err.toString();
                console.error(this._lastError);
                return null;
            } else {
                this._lastError = Object.prototype.toString.call(err);
                console.log(`Error: ${this._lastError}`);
                return null;
            }
        }
    }
    /** @internal */ generate(body) {
        this.pushScope(this._globalScope);
        if (this._emulateDepthClamp && this._shaderType === ShaderType.Vertex) {
            this._globalScope.$outputs.clamppedDepth = this.float().tag('CLAMPPED_DEPTH');
        }
        body && body.call(this._globalScope, this);
        this.popScope();
        // Global delcarations should be at the first
        this._globalScope.$ast.statements = [
            ...this._globalScope.$ast.statements.filter((val)=>val instanceof ASTDeclareVar || val instanceof ASTAssignment),
            ...this._globalScope.$ast.statements.filter((val)=>!(val instanceof ASTDeclareVar) && !(val instanceof ASTAssignment))
        ];
    }
    /** @internal */ generateRenderSource(shaderType, scope, builtinScope, inputs, outputs) {
        const context = {
            type: shaderType,
            mrt: shaderType === ShaderType.Fragment && outputs.length > 1,
            defines: [],
            extensions: new Set(),
            builtins: [
                ...builtinScope.$_usedBuiltins
            ],
            types: this._structInfo[shaderType]?.types || [],
            typeReplacement: new Map(),
            inputs: inputs,
            outputs: outputs,
            global: scope,
            vertexAttributes: this._vertexAttributes,
            workgroupSize: null
        };
        switch(this._device.type){
            case 'webgl':
                for (const u of this._uniforms){
                    if (u.texture) {
                        const type = u.texture.exp.$ast.getType();
                        if (type.isTextureType() && type.isDepthTexture()) {
                            if (u.texture.autoBindSampler === 'comparison') {
                                throw new PBDeviceNotSupport('depth texture comparison');
                            }
                            if (u.texture.autoBindSampler === 'sample') {
                                if (type.is2DTexture()) {
                                    context.typeReplacement.set(u.texture.exp, typeTex2D);
                                } else if (type.isCubeTexture()) {
                                    context.typeReplacement.set(u.texture.exp, typeTexCube);
                                }
                            }
                        }
                    }
                }
                return scope.$ast.toWebGL('', context);
            case 'webgl2':
                for (const u of this._uniforms){
                    if (u.texture) {
                        const type = u.texture.exp.$ast.getType();
                        if (type.isTextureType() && type.isDepthTexture() && u.texture.autoBindSampler === 'sample') {
                            if (type.is2DTexture()) {
                                context.typeReplacement.set(u.texture.exp, type.isArrayTexture() ? typeTex2DArray : typeTex2D);
                            } else if (type.isCubeTexture()) {
                                context.typeReplacement.set(u.texture.exp, typeTexCube);
                            }
                        }
                    }
                }
                return scope.$ast.toWebGL2('', context);
            case 'webgpu':
                return scope.$ast.toWGSL('', context);
            default:
                return null;
        }
    }
    /** @internal */ generateComputeSource(scope, builtinScope) {
        const context = {
            type: ShaderType.Compute,
            mrt: false,
            defines: [],
            extensions: new Set(),
            builtins: [
                ...builtinScope.$_usedBuiltins
            ],
            types: this._structInfo[ShaderType.Compute]?.types || [],
            typeReplacement: null,
            inputs: [],
            outputs: [],
            global: scope,
            vertexAttributes: [],
            workgroupSize: this._workgroupSize
        };
        return scope.$ast.toWGSL('', context);
    }
    /** @internal */ mergeUniformsCompute(globalScope) {
        const uniformList = [];
        for(let i = 0; i < this._uniforms.length; i++){
            const u = this._uniforms[i];
            if (u.block && (u.block.exp.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || u.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE)) {
                if (u.block.exp.$typeinfo.isStructType() && u.block.exp.$isBuffer) {
                    continue;
                }
                if (!uniformList[u.group]) {
                    uniformList[u.group] = [];
                }
                const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                exp.$declareType = u.block.exp.$declareType;
                exp.$isBuffer = u.block.exp.$isBuffer;
                exp.$bindingSize = u.block.exp.$bindingSize;
                exp.$readonly = u.block.exp.$readonly;
                uniformList[u.group].push({
                    member: exp,
                    uniform: i
                });
            }
        }
        for(const k in uniformList){
            if (uniformList[k].length > 0) {
                const types = [
                    'std140',
                    'std430'
                ];
                const nameList = [
                    COMPUTE_UNIFORM_NAME,
                    COMPUTE_STORAGE_NAME
                ];
                const ulist = [
                    uniformList[k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_UNIFORM),
                    uniformList[k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_STORAGE)
                ];
                for(let i = 0; i < 2; i++){
                    if (ulist[i].length === 0) {
                        continue;
                    }
                    const nonBufferList = ulist[i].filter((val)=>!val.member.$isBuffer);
                    const bufferList = ulist[i].filter((val)=>val.member.$isBuffer);
                    const allLists = [
                        nonBufferList,
                        ...bufferList.map((val)=>[
                                val
                            ])
                    ];
                    for(let p = 0; p < allLists.length; p++){
                        if (allLists[p].length === 0) {
                            continue;
                        }
                        const uname = `${nameList[i]}_${k}_${p}`;
                        const structName = this.generateStructureName();
                        const t = getCurrentProgramBuilder().internalDefineStruct(structName, types[i], ShaderType.Compute, false, ...allLists[p].map((val)=>val.member));
                        const readonly = i > 0 ? allLists[p].findIndex((val)=>!val.member.$readonly) < 0 : true;
                        const exp = t();
                        if (i === 0) {
                            exp.uniformBuffer(Number(k), p > 0 ? allLists[p][0].member.$bindingSize : 0);
                        } else {
                            exp.storageBuffer(Number(k), p > 0 ? allLists[p][0].member.$bindingSize : 0);
                            exp.$readonly = readonly;
                        }
                        globalScope[uname] = exp;
                        const index = this._uniforms.findIndex((val)=>val.block?.name === uname);
                        this._uniforms[index].mask = ShaderType.Compute;
                        let nameMap = this._nameMap[Number(k)];
                        if (!nameMap) {
                            nameMap = {};
                            this._nameMap[Number(k)] = nameMap;
                        }
                        let writable = false;
                        for(let n = allLists[p].length - 1; n >= 0; n--){
                            const u = allLists[p][n];
                            const exp = this._uniforms[u.uniform].block.exp;
                            nameMap[exp.$str] = uname;
                            exp.$str = `${uname}.${exp.$str}`;
                            writable ||= exp.$ast.isWritable();
                        }
                        if (writable) {
                            globalScope[uname].$ast.markWritable();
                        }
                    }
                }
            }
        }
        this._uniforms = this._uniforms.filter((val)=>{
            return !val.block || val.block.exp.$typeinfo.isStructType() && val.block.exp.$isBuffer;
        //return !val.block || val.block.exp.$isBuffer;
        /*
      if (!val.block || (val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_UNIFORM && val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_STORAGE)) {
        return true;
      }
      const type = val.block.exp.$ast.getType();
      return (
        type.isTextureType() ||
        type.isSamplerType() ||
        (type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430'))
      );
      */ });
    }
    /** @internal */ mergeUniforms(globalScopeVertex, globalScopeFragmet) {
        const vertexUniformList = [];
        const fragUniformList = [];
        const sharedUniformList = [];
        //const vertexUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        //const fragUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        //const sharedUniformList: { members: PBShaderExp[]; uniforms: number[] }[] = [];
        for(let i = 0; i < this._uniforms.length; i++){
            const u = this._uniforms[i];
            if (u.block && (u.block.exp.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || u.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE)) {
                if (u.block.exp.$typeinfo.isStructType() && u.block.exp.$isBuffer) {
                    continue;
                }
                const v = !!(u.mask & ShaderType.Vertex);
                const f = !!(u.mask & ShaderType.Fragment);
                if (v && f) {
                    if (!sharedUniformList[u.group]) {
                        sharedUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    exp.$bindingSize = u.block.exp.$bindingSize;
                    exp.$readonly = u.block.exp.$readonly;
                    sharedUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    });
                //sharedUniformList[u.group].uniforms.push(i);
                } else if (v) {
                    if (!vertexUniformList[u.group]) {
                        vertexUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    exp.$bindingSize = u.block.exp.$bindingSize;
                    exp.$readonly = u.block.exp.$readonly;
                    vertexUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    });
                //vertexUniformList[u.group].uniforms.push(i);
                } else if (f) {
                    if (!fragUniformList[u.group]) {
                        fragUniformList[u.group] = []; //{ members: [], uniforms: [] };
                    }
                    const exp = new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType());
                    exp.$declareType = u.block.exp.$declareType;
                    exp.$isBuffer = u.block.exp.$isBuffer;
                    exp.$bindingSize = u.block.exp.$bindingSize;
                    exp.$readonly = u.block.exp.$readonly;
                    fragUniformList[u.group].push({
                        member: exp,
                        uniform: i
                    }); //members.push(exp);
                //fragUniformList[u.group].uniforms.push(i);
                }
            }
        }
        const uniformLists = [
            vertexUniformList,
            fragUniformList,
            sharedUniformList
        ];
        const nameListUniform = [
            VERTEX_UNIFORM_NAME,
            FRAGMENT_UNIFORM_NAME,
            SHARED_UNIFORM_NAME
        ];
        const nameListStorage = [
            VERTEX_STORAGE_NAME,
            FRAGMENT_STORAGE_NAME,
            SHARED_STORAGE_NAME
        ];
        const maskList = [
            ShaderType.Vertex,
            ShaderType.Fragment,
            ShaderType.Vertex | ShaderType.Fragment
        ];
        for(let i = 0; i < 3; i++){
            for(const k in uniformLists[i]){
                if (uniformLists[i][k]?.length > 0) {
                    const ulist = [
                        uniformLists[i][k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_UNIFORM),
                        uniformLists[i][k].filter((val)=>val.member.$declareType === DeclareType.DECLARE_TYPE_STORAGE)
                    ];
                    const nameList = [
                        nameListUniform,
                        nameListStorage
                    ];
                    const layoutList = [
                        'std140',
                        'std430'
                    ];
                    for(let j = 0; j < 2; j++){
                        if (ulist[j].length === 0) {
                            continue;
                        }
                        const nonBufferList = ulist[j].filter((val)=>!val.member.$isBuffer);
                        const bufferList = ulist[j].filter((val)=>val.member.$isBuffer);
                        const allLists = [
                            nonBufferList,
                            ...bufferList.map((val)=>[
                                    val
                                ])
                        ];
                        for(let p = 0; p < allLists.length; p++){
                            if (allLists[p].length === 0) {
                                continue;
                            }
                            const uname = `${nameList[j][i]}_${k}_${p}`;
                            const structName = this.generateStructureName();
                            const t = getCurrentProgramBuilder().internalDefineStruct(structName, layoutList[j], maskList[i], false, ...allLists[p].map((val)=>val.member));
                            const readonly = j > 0 ? allLists[p].findIndex((val)=>!val.member.$readonly) < 0 : true;
                            if (maskList[i] & ShaderType.Vertex) {
                                const exp = t();
                                if (j > 0 && !readonly) {
                                    throw new Error(`Storage buffer in vertex shader must be read-only`);
                                }
                                if (j === 0) {
                                    exp.uniformBuffer(Number(k), p > 0 ? allLists[p][0].member.$bindingSize : 0);
                                } else {
                                    exp.storageBuffer(Number(k), p > 0 ? allLists[p][0].member.$bindingSize : 0);
                                    exp.$readonly = readonly;
                                }
                                globalScopeVertex[uname] = exp;
                            }
                            if (maskList[i] & ShaderType.Fragment) {
                                const exp = t();
                                if (j === 0) {
                                    exp.uniformBuffer(Number(k), p > 0 ? allLists[p][0].member.$bindingSize : 0);
                                } else {
                                    exp.storageBuffer(Number(k), p > 0 ? allLists[p][0].member.$bindingSize : 0);
                                    exp.$readonly = readonly;
                                }
                                globalScopeFragmet[uname] = exp;
                            }
                            const index = this._uniforms.findIndex((val)=>val.block?.name === uname);
                            this._uniforms[index].mask = maskList[i];
                            let nameMap = this._nameMap[Number(k)];
                            if (!nameMap) {
                                nameMap = {};
                                this._nameMap[Number(k)] = nameMap;
                            }
                            let writable = false;
                            for(let n = allLists[p].length - 1; n >= 0; n--){
                                const u = allLists[p][n];
                                const exp = this._uniforms[u.uniform].block.exp;
                                nameMap[exp.$str] = uname;
                                exp.$str = `${uname}.${exp.$str}`;
                                writable ||= exp.$ast.isWritable();
                            }
                            if (writable) {
                                if (maskList[i] & ShaderType.Vertex) {
                                    globalScopeVertex[uname].$ast.markWritable();
                                } else {
                                    globalScopeFragmet[uname].$ast.markWritable();
                                }
                            }
                        }
                    }
                }
            }
        }
        this._uniforms = this._uniforms.filter((val)=>{
            return !val.block || val.block.exp.$typeinfo.isStructType() && val.block.exp.$isBuffer;
        /*
      if (!val.block) {
        return true;
      }
      const type = val.block.exp.$ast.getType();
      return (
        type.isTextureType() ||
        type.isSamplerType() ||
        (type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430'))
      );
      */ });
    }
    /** @internal */ updateUniformBindings(scopes, shaderTypes) {
        this._uniforms = this._uniforms.filter((val)=>!!val.mask);
        const bindings = Array.from({
            length: MAX_BINDING_GROUPS
        }).fill(0);
        for (const u of this._uniforms){
            u.binding = bindings[u.group]++;
        }
        for(let i = 0; i < scopes.length; i++){
            const scope = scopes[i];
            const type = shaderTypes[i];
            for (const u of this._uniforms){
                if (u.mask & type) {
                    const uniforms = scope.$ast.uniforms;
                    const name = u.block ? u.block.name : u.texture ? u.texture.exp.$str : u.sampler.$str;
                    const index = uniforms.findIndex((val)=>val.value.name === name);
                    if (index < 0) {
                        throw new Error(`updateUniformBindings() failed: unable to find uniform ${name}`);
                    }
                    uniforms[index].binding = u.binding;
                }
            }
        }
    }
    /** @internal */ createBindGroupLayouts(label) {
        const layouts = [];
        const dynamicOffsetIndex = [
            0,
            0,
            0,
            0
        ];
        for (const uniformInfo of this._uniforms){
            let layout = layouts[uniformInfo.group];
            if (!layout) {
                layout = {
                    label: `${label || 'unknown'}[${uniformInfo.group}]`,
                    entries: []
                };
                if (this._nameMap[uniformInfo.group]) {
                    layout.nameMap = this._nameMap[uniformInfo.group];
                }
                layouts[uniformInfo.group] = layout;
            }
            const entry = {
                binding: uniformInfo.binding,
                visibility: uniformInfo.mask,
                type: null,
                name: ''
            };
            if (uniformInfo.block) {
                entry.type = uniformInfo.block.exp.$typeinfo.clone(this.getBlockName(uniformInfo.block.name));
                const isStorage = uniformInfo.block.exp.$declareType === DeclareType.DECLARE_TYPE_STORAGE;
                entry.buffer = {
                    type: isStorage ? uniformInfo.block.exp.$readonly ? 'read-only-storage' : 'storage' : 'uniform',
                    minBindingSize: uniformInfo.block.bindingSize,
                    hasDynamicOffset: !!uniformInfo.block.bindingSize,
                    uniformLayout: entry.type.toBufferLayout(0, entry.type.layout),
                    dynamicOffsetIndex: !!uniformInfo.block.bindingSize ? dynamicOffsetIndex[uniformInfo.group]++ : -1
                };
                entry.name = uniformInfo.block.name;
            } else if (uniformInfo.texture) {
                entry.type = uniformInfo.texture.exp.$typeinfo;
                if (!entry.type.isTextureType()) {
                    throw new Error('internal error');
                }
                if (entry.type.isStorageTexture()) {
                    entry.storageTexture = {
                        access: 'write-only',
                        viewDimension: entry.type.is1DTexture() ? '1d' : '2d',
                        format: entry.type.storageTexelFormat
                    };
                } else if (entry.type.isExternalTexture()) {
                    entry.externalTexture = {
                        autoBindSampler: uniformInfo.texture.autoBindSampler ? genSamplerName(uniformInfo.texture.exp.$str, false) : null
                    };
                } else {
                    const sampleType = this._device.type === 'webgpu' ? uniformInfo.texture.exp.$sampleType : uniformInfo.texture.autoBindSampler && entry.type.isDepthTexture() ? 'float' : uniformInfo.texture.exp.$sampleType;
                    let viewDimension;
                    if (entry.type.isArrayTexture()) {
                        viewDimension = entry.type.isCubeTexture() ? 'cube-array' : '2d-array';
                    } else if (entry.type.is3DTexture()) {
                        viewDimension = '3d';
                    } else if (entry.type.isCubeTexture()) {
                        viewDimension = 'cube';
                    } else if (entry.type.is1DTexture()) {
                        viewDimension = '1d';
                    } else {
                        viewDimension = '2d';
                    }
                    entry.texture = {
                        sampleType: sampleType,
                        viewDimension: viewDimension,
                        multisampled: false,
                        autoBindSampler: null,
                        autoBindSamplerComparison: null
                    };
                    if (this._device.type === 'webgpu' || uniformInfo.texture.autoBindSampler === 'sample') {
                        entry.texture.autoBindSampler = genSamplerName(uniformInfo.texture.exp.$str, false);
                    }
                    if (this._device.type === 'webgpu' && entry.type.isDepthTexture() || uniformInfo.texture.autoBindSampler === 'comparison') {
                        entry.texture.autoBindSamplerComparison = genSamplerName(uniformInfo.texture.exp.$str, true);
                    }
                }
                entry.name = uniformInfo.texture.exp.$str;
            } else if (uniformInfo.sampler) {
                entry.type = uniformInfo.sampler.$typeinfo;
                if (!entry.type.isSamplerType()) {
                    throw new Error('internal error');
                }
                entry.sampler = {
                    type: entry.type.accessMode === PBSamplerAccessMode.SAMPLE ? uniformInfo.sampler.$sampleType === 'float' ? 'filtering' : 'non-filtering' : 'comparison'
                };
                entry.name = uniformInfo.sampler.$str;
            } else {
                throw new PBInternalError('invalid uniform entry type');
            }
            layout.entries.push(entry);
        }
        for(let i = 0; i < layouts.length; i++){
            if (!layouts[i]) {
                layouts[i] = {
                    label: `${label || 'unknown'}[${i}]`,
                    entries: []
                };
            }
        }
        return layouts;
    }
    /** @internal */ _getFunctionOverload(funcName, args) {
        const thisArgs = args.filter((val)=>{
            if (val instanceof PBShaderExp) {
                const type = val.$ast.getType();
                if (type.isStructType() && this._structInfo[this._shaderType]?.types.findIndex((t)=>t.type.structName === type.structName) < 0) {
                    return false;
                }
            }
            return true;
        });
        const fn = this.getGlobalScope().$getFunctions(funcName);
        return fn ? this._matchFunctionOverloading(fn, thisArgs) : null;
    }
    /** @internal */ _matchFunctionOverloading(overloadings, args) {
        for (const overload of overloadings){
            if (args.length !== overload.funcType.argTypes.length) {
                continue;
            }
            const result = [];
            let matches = true;
            for(let i = 0; i < args.length; i++){
                const argInfo = overload.funcType.argTypes[i];
                const argType = argInfo.byRef && argInfo.type instanceof PBPointerTypeInfo ? argInfo.type.pointerType : argInfo.type;
                const arg = args[i];
                if (typeof arg === 'boolean') {
                    if (!argType.isPrimitiveType() || argType.primitiveType !== PBPrimitiveType.BOOL) {
                        matches = false;
                        break;
                    }
                    result.push(new ASTScalar(arg, typeBool));
                } else if (typeof arg === 'number') {
                    if (!argType.isPrimitiveType() || !argType.isScalarType() || argType.scalarType === PBPrimitiveType.BOOL) {
                        matches = false;
                        break;
                    }
                    if (argType.scalarType === PBPrimitiveType.I32) {
                        if (!Number.isInteger(arg) || arg < 0x80000000 >> 0 || arg > 0x7fffffff) {
                            matches = false;
                            break;
                        }
                        result.push(new ASTScalar(arg, typeI32));
                    } else if (argType.scalarType === PBPrimitiveType.U32) {
                        if (!Number.isInteger(arg) || arg < 0 || arg > 0xffffffff) {
                            matches = false;
                            break;
                        }
                        result.push(new ASTScalar(arg, typeU32$1));
                    } else {
                        result.push(new ASTScalar(arg, argType));
                    }
                } else {
                    if (!argType.isCompatibleType(arg.$ast.getType())) {
                        matches = false;
                        break;
                    }
                    result.push(arg.$ast);
                }
            }
            if (matches) {
                return [
                    overload,
                    result
                ];
            }
        }
        return null;
    }
    /** @internal */ $callFunction(funcName, args, func) {
        if (this.getCurrentScope() === this.getGlobalScope()) {
            throw new PBNonScopedFunctionCall(funcName);
        }
        const exp = new PBShaderExp('', func.returnType);
        exp.$ast = new ASTCallFunction(funcName, args, func, getCurrentProgramBuilder().getDevice().type);
        this.getCurrentScope().$ast.statements.push(exp.$ast);
        return exp;
    }
    /** @internal */ $callFunctionNoCheck(funcName, args, retType) {
        if (this.getCurrentScope() === this.getGlobalScope()) {
            throw new PBNonScopedFunctionCall(funcName);
        }
        const exp = new PBShaderExp('', retType);
        exp.$ast = new ASTCallFunction(funcName, args, null, getCurrentProgramBuilder().getDevice().type, retType);
        this.getCurrentScope().$ast.statements.push(exp.$ast);
        return exp;
    }
}
/**
 * Base class for scope of the shader program
 * @public
 */ class PBScope extends Proxiable {
    /** @internal */ $_variables;
    /** @internal */ $_parentScope;
    /** @internal */ $_AST;
    /** @internal */ $_localScope;
    /** @internal */ constructor(astScope, parent){
        super();
        this.$_parentScope = parent || null;
        this.$_variables = {};
        this.$_AST = astScope;
        this.$_localScope = null;
    }
    /** Get the program builder */ get $builder() {
        return getCurrentProgramBuilder();
    }
    /** Returns the scope of the builtin variables */ get $builtins() {
        return getCurrentProgramBuilder().builtinScope;
    }
    /** Returns the scope of the input variables */ get $inputs() {
        return getCurrentProgramBuilder().inputScope;
    }
    /** Returns the scope of the output variables */ get $outputs() {
        return getCurrentProgramBuilder().outputScope;
    }
    /** @internal */ get $parent() {
        return this.$_parentScope;
    }
    /** @internal */ get $ast() {
        return this.$_AST;
    }
    /** @internal */ set $ast(ast) {
        this.$_AST = ast;
    }
    /**
   * Get the input vertex attribute by specified semantic
   *
   * @remarks
   * Can only be called only in vertex shader
   *
   * @param semantic - The vertex semantic
   * @returns The input vertex attribute or null if not exists
   */ $getVertexAttrib(semantic) {
        return this.$inputs.$getVertexAttrib(semantic); // getCurrentProgramBuilder().getReflection().attribute(semantic);
    }
    /** Get the current local scope */ get $l() {
        return this.$_getLocalScope();
    }
    /** Get the global scope */ get $g() {
        return this.$_getGlobalScope();
    }
    /** @internal */ $local(variable, init) {
        const initNonArray = getCurrentProgramBuilder().normalizeExpValue(init);
        variable.$global = this instanceof PBGlobalScope;
        this.$_declare(variable, initNonArray);
    }
    /** @internal */ $touch(exp) {
        this.$ast.statements.push(new ASTTouch(exp.$ast));
    }
    /**
   * Query the global variable by the name
   * @param name - Name of the variable
   * @returns The variable or null if not exists
   */ $query(name) {
        return this.$builder.getReflection().tag(name);
    }
    /** @internal */ $_declareInternal(variable, init) {
        const key = variable.$str;
        if (this.$_variables[key]) {
            throw new Error(`cannot re-declare variable '${key}'`);
        }
        if (!(variable.$ast instanceof ASTPrimitive)) {
            throw new Error(`invalid variable declaration: '${variable.$ast.toString(getCurrentProgramBuilder().getDevice().type)}'`);
        }
        const varType = variable.$typeinfo;
        if (varType.isPointerType()) {
            if (!init) {
                throw new Error(`cannot declare pointer type variable without initialization: '${variable.$str}'`);
            }
            if (!(init instanceof PBShaderExp)) {
                throw new Error(`invalid initialization for pointer type declaration: '${variable.$str}`);
            }
            const initType = init.$ast.getType();
            if (!initType.isPointerType() || !varType.pointerType.isCompatibleType(initType.pointerType)) {
                throw new Error(`incompatible pointer type assignment: '${variable.$str}'`);
            }
            variable.$typeinfo = initType;
        }
        this.$_registerVar(variable, key);
        if (init === undefined || init === null) {
            return new ASTDeclareVar(variable.$ast);
        } else {
            if (init instanceof PBShaderExp && init.$ast instanceof ASTShaderExpConstructor && init.$ast.args.length === 0) {
                if (!init.$ast.getType().isCompatibleType(variable.$ast.getType())) {
                    throw new PBTypeCastError(init, init.$ast.getType(), variable.$ast.getType());
                }
                return new ASTDeclareVar(variable.$ast);
            } else {
                return new ASTAssignment(new ASTLValueDeclare(variable.$ast), init instanceof PBShaderExp ? init.$ast : init);
            }
        }
    }
    /** @internal */ $_findOrSetUniform(variable) {
        const name = variable.$str;
        const uniformInfo = {
            group: variable.$group,
            binding: 0,
            mask: 0
        };
        if (variable.$typeinfo.isTextureType()) {
            uniformInfo.texture = {
                autoBindSampler: null,
                exp: variable
            };
        } else if (variable.$typeinfo.isSamplerType()) {
            uniformInfo.sampler = variable;
        } else {
            uniformInfo.block = {
                name: name,
                bindingSize: variable.$bindingSize,
                exp: variable
            };
        // throw new Error(`unsupported uniform type: ${name}`);
        }
        let found = false;
        for (const u of getCurrentProgramBuilder()._uniforms){
            if (u.group !== uniformInfo.group) {
                continue;
            }
            if (uniformInfo.block && u.block && u.block.name === uniformInfo.block.name && u.block.exp.$typeinfo.isCompatibleType(uniformInfo.block.exp.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.block.exp;
                // u.block.exp = variable;
                found = true;
                break;
            }
            if (uniformInfo.texture && u.texture && uniformInfo.texture.exp.$str === u.texture.exp.$str && uniformInfo.texture.exp.$typeinfo.isCompatibleType(u.texture.exp.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.texture.exp;
                // u.texture.exp = variable;
                found = true;
                break;
            }
            if (uniformInfo.sampler && u.sampler && uniformInfo.sampler.$str === u.sampler.$str && uniformInfo.sampler.$typeinfo.isCompatibleType(u.sampler.$typeinfo)) {
                u.mask |= getCurrentProgramBuilder().shaderType;
                variable = u.sampler;
                // u.sampler = variable;
                found = true;
                break;
            }
        }
        if (!found) {
            uniformInfo.mask = getCurrentProgramBuilder().shaderType;
            getCurrentProgramBuilder()._uniforms.push(uniformInfo);
        }
        if (uniformInfo.texture && !uniformInfo.texture.exp.$typeinfo.isStorageTexture() && getCurrentProgramBuilder().getDevice().type === 'webgpu') {
            // webgpu requires explicit sampler bindings
            const isDepth = variable.$typeinfo.isTextureType() && variable.$typeinfo.isDepthTexture();
            const samplerName = genSamplerName(variable.$str, false);
            const samplerExp = getCurrentProgramBuilder().sampler(samplerName).uniform(uniformInfo.group).sampleType(variable.$sampleType);
            samplerExp.$sampleType = variable.$sampleType;
            this.$local(samplerExp);
            if (isDepth) {
                const samplerNameComp = genSamplerName(variable.$str, true);
                const samplerExpComp = getCurrentProgramBuilder().samplerComparison(samplerNameComp).uniform(uniformInfo.group).sampleType(variable.$sampleType);
                this.$local(samplerExpComp);
            }
        }
        return variable;
    }
    /** @internal */ $_declare(variable, init) {
        if (this.$_variables[variable.$str]) {
            throw new PBASTError(variable.$ast, 'cannot re-declare variable');
        }
        if (variable.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || variable.$declareType === DeclareType.DECLARE_TYPE_STORAGE) {
            const name = variable.$ast.name;
            if (!(this instanceof PBGlobalScope)) {
                throw new Error(`uniform or storage variables can only be declared within global scope: ${name}`);
            }
            if (variable.$declareType === DeclareType.DECLARE_TYPE_UNIFORM && !variable.$typeinfo.isTextureType() && !variable.$typeinfo.isSamplerType() && (!variable.$typeinfo.isConstructible() || !variable.$typeinfo.isHostSharable())) {
                throw new PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDevice().type)}' cannot be declared in uniform address space`);
            }
            if (variable.$declareType === DeclareType.DECLARE_TYPE_STORAGE) {
                if (getCurrentProgramBuilder().getDevice().type !== 'webgpu') {
                    throw new PBDeviceNotSupport('storage buffer binding');
                } else if (!variable.$typeinfo.isHostSharable()) {
                    throw new PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDevice().type)}' cannot be declared in storage address space`);
                }
            }
            /*
      if (
        variable.$declareType === AST.DeclareType.DECLARE_TYPE_STORAGE &&
        (variable.$typeinfo.isPrimitiveType() || variable.$typeinfo.isArrayType() || variable.$typeinfo.isAtomicI32() || variable.$typeinfo.isAtomicU32())
      ) {
        originalType = variable.$typeinfo as PBPrimitiveTypeInfo | PBArrayTypeInfo;
        const wrappedStruct = getCurrentProgramBuilder().defineStruct(null, new PBShaderExp('value', originalType));
        variable.$typeinfo = wrappedStruct().$typeinfo;
      }
      */ variable = this.$_findOrSetUniform(variable);
            const ast = this.$_declareInternal(variable);
            ast.group = variable.$group;
            ast.binding = 0;
            ast.blockName = getCurrentProgramBuilder().getBlockName(name);
            const type = variable.$typeinfo;
            if (type.isStructType() && variable.$isBuffer || type.isTextureType() || type.isSamplerType() || type.isStructType() && (type.detail.layout === 'std140' || type.detail.layout === 'std430')) {
                this.$ast.uniforms.push(ast);
            }
            variable.$tags.forEach((val)=>{
                getCurrentProgramBuilder().tagShaderExp(()=>variable, val);
            });
        } else {
            const ast = this.$_declareInternal(variable, init);
            this.$ast.statements.push(ast);
        }
    }
    /** @internal */ $_registerVar(variable, name) {
        const key = name || variable.$str;
        const options = {
            configurable: true,
            get: function() {
                return variable;
            },
            set: function(val) {
                getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(variable.$ast), val instanceof PBShaderExp ? val.$ast : val));
            }
        };
        Object.defineProperty(this, key, options);
        this.$_variables[key] = variable;
    }
    /** @internal */ $localGet(prop) {
        if (typeof prop === 'string' && (prop[0] === '$' || prop in this)) {
            return this[prop];
        }
        return undefined;
    }
    /** @internal */ $localSet(prop, value) {
        if (prop[0] === '$' || prop in this) {
            this[prop] = value;
            return true;
        }
        return false;
    }
    /** @internal */ $get(prop) {
        const ret = this.$localGet(prop);
        return ret === undefined && this.$_parentScope ? this.$_parentScope.$thisProxy.$get(prop) : ret;
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
            return true;
        } else {
            let scope = this;
            while(scope && !(prop in scope)){
                scope = scope.$_parentScope;
            }
            if (scope) {
                scope[prop] = value;
                return true;
            } else {
                if (this.$l) {
                    this.$l[prop] = value;
                    return true;
                }
            }
        }
        return false;
    }
    /** @internal */ $_getLocalScope() {
        if (!this.$_localScope) {
            this.$_localScope = new PBLocalScope(this);
        }
        return this.$_localScope;
    }
    /** @internal */ $_getGlobalScope() {
        return this.$builder.getGlobalScope();
    }
}
/**
 * The local scope of a shader
 * @public
 */ class PBLocalScope extends PBScope {
    /** @internal */ $_scope;
    constructor(scope){
        super(null, null);
        this.$_scope = scope;
    }
    /** @internal */ $get(prop) {
        return prop[0] === '$' ? this[prop] : this.$_scope.$localGet(prop);
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
            return true;
        }
        if (!(this.$_scope instanceof PBGlobalScope) && value instanceof PBShaderExp && (value.isConstructor() || value.$typeinfo.isTextureType() && value.$ast instanceof ASTPrimitive && !value.$ast.name) && (value.$declareType === DeclareType.DECLARE_TYPE_UNIFORM || value.$declareType === DeclareType.DECLARE_TYPE_STORAGE)) {
            // We are setting uniform a uniform, should invoke in the global scope
            this.$g[prop] = value;
            return true;
        }
        const val = this.$_scope.$localGet(prop);
        if (val === undefined) {
            const type = getCurrentProgramBuilder().guessExpValueType(value);
            if (type.isCompatibleType(typeVoid)) {
                throw new Error(`Cannot assign void type to '${prop}'`);
            }
            const exp = new PBShaderExp(prop, type);
            if (value instanceof PBShaderExp && !this.$_scope.$parent) {
                exp.$declareType = value.$declareType;
                exp.$isBuffer = value.$isBuffer;
                exp.$bindingSize = value.$bindingSize;
                exp.$readonly = value.$readonly;
                exp.$group = value.$group;
                exp.$attrib = value.$attrib;
                exp.$sampleType = value.$sampleType;
                exp.$precision = value.$precision;
                exp.tag(...value.$tags);
            }
            this.$_scope.$local(exp, value);
            return true;
        } else {
            return this.$_scope.$localSet(prop, value);
        }
    }
    /** @internal */ $_getLocalScope() {
        return this;
    }
}
/**
 * The builtin scope of a shader
 * @public
 */ class PBBuiltinScope extends PBScope {
    /** @internal */ $_usedBuiltins;
    /** @internal */ $_builtinVars;
    constructor(){
        super(null);
        this.$_usedBuiltins = new Set();
        const isWebGPU = getCurrentProgramBuilder().getDevice().type === 'webgpu';
        if (!isWebGPU) {
            this.$_builtinVars = {};
            const v = builtinVariables[getCurrentProgramBuilder().getDevice().type];
            for(const k in v){
                const info = v[k];
                this.$_builtinVars[k] = new PBShaderExp(info.name, info.type);
            }
        }
        const v = builtinVariables[getCurrentProgramBuilder().getDevice().type];
        const that = this;
        for (const k of Object.keys(v)){
            Object.defineProperty(this, k, {
                get: function() {
                    return that.$getBuiltinVar(k);
                },
                set: function(v) {
                    if (typeof v !== 'number' && !(v instanceof PBShaderExp)) {
                        throw new Error(`Invalid output value assignment`);
                    }
                    const exp = that.$getBuiltinVar(k);
                    getCurrentProgramBuilder().getCurrentScope().$ast.statements.push(new ASTAssignment(new ASTLValueScalar(exp.$ast), v instanceof PBShaderExp ? v.$ast : v));
                }
            });
        }
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $getBuiltinVar(name) {
        const pb = getCurrentProgramBuilder();
        this.$_usedBuiltins.add(name);
        const isWebGPU = pb.getDevice().type === 'webgpu';
        if (isWebGPU) {
            const v = builtinVariables[pb.getDevice().type];
            const info = v[name];
            const inout = info.inOrOut;
            if (inout === 'in') {
                return pb.getCurrentFunctionScope()[getBuiltinParamName(pb.shaderType)][info.name];
            }
            const structName = inout === 'in' ? getBuiltinInputStructInstanceName(pb.shaderType) : getBuiltinOutputStructInstanceName(pb.shaderType);
            const scope = pb.getCurrentScope();
            if (!scope[structName] || !scope[structName][info.name]) {
                throw new Error(`invalid use of builtin variable ${name}`);
            }
            return scope[structName][info.name];
        } else {
            if (pb.getDevice().type === 'webgl2' && (name === 'vertexIndex' || name === 'instanceIndex')) {
                return pb.uint(this.$_builtinVars[name]);
            } else {
                return this.$_builtinVars[name];
            }
        }
    }
}
/**
 * The input scope of a shader
 * @public
 */ class PBInputScope extends PBScope {
    /** @internal */ $_names;
    $_aliases;
    /** @internal */ constructor(){
        super(null);
        this.$_names = {};
        this.$_aliases = {};
    }
    /** @internal */ $getVertexAttrib(attrib) {
        const name = this.$_names[attrib];
        return name ? this[name] : null;
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $get(prop) {
        if (prop[0] === '$') {
            return this[prop];
        }
        if (this.$_aliases[prop]) {
            prop = this.$_aliases[prop];
        }
        const pb = this.$builder;
        if (pb.getDevice().type === 'webgpu') {
            const param = pb.getCurrentFunctionScope()[getBuiltinParamName(pb.shaderType)];
            const prefix = pb.shaderKind === 'vertex' ? input_prefix : output_prefix_vs;
            const name = `${prefix}${prop}`;
            if (param.$typeinfo.structMembers.findIndex((val)=>val.name === name) < 0) {
                return undefined;
            }
            return param[`${prefix}${prop}`];
        }
        return super.$get(prop);
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$') {
            this[prop] = value;
        } else {
            if (!(value instanceof PBShaderExp)) {
                throw new Error(`invalid vertex input value`);
            }
            const st = getCurrentProgramBuilder().shaderType;
            if (st !== ShaderType.Vertex) {
                throw new Error(`shader input variables can only be declared in vertex shader: "${prop}"`);
            }
            const attrib = getVertexAttribByName(value.$attrib);
            if (attrib === undefined) {
                throw new Error(`can not declare shader input variable: invalid vertex attribute: "${prop}"`);
            }
            if (getCurrentProgramBuilder()._vertexAttributes.indexOf(attrib) >= 0) {
                const lastName = this.$_names[value.$attrib];
                if (prop !== lastName) {
                    const p = this[lastName];
                    if (p.$typeinfo.typeId !== value.$typeinfo.typeId) {
                        throw new Error(`can not declare shader input variable: attribute already declared with different type: "${prop}"`);
                    }
                    this.$_aliases[prop] = lastName;
                }
                return true;
            }
            if (!(value instanceof PBShaderExp) || !(value.$ast instanceof ASTShaderExpConstructor)) {
                throw new Error(`invalid shader input variable declaration: "${prop}"`);
            }
            const type = value.$ast.getType();
            if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {
                throw new Error(`type cannot be used as pipeline input/output: ${prop}`);
            }
            this.$_names[value.$attrib] = prop;
            const location = getCurrentProgramBuilder()._inputs.length;
            const exp = new PBShaderExp(`${input_prefix}${prop}`, type).tag(...value.$tags);
            getCurrentProgramBuilder().in(location, prop, exp);
            getCurrentProgramBuilder()._vertexAttributes.push(attrib);
            //getCurrentProgramBuilder().getReflection().setAttrib(value.$attrib, exp);
            // modify input struct for webgpu
            if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                if (getCurrentProgramBuilder().findStructType(getBuiltinInputStructName(st), st)) {
                    getCurrentProgramBuilder().defineBuiltinStruct(st, 'in');
                }
            }
        }
        return true;
    }
}
/**
 * The output scope of a shader
 * @public
 */ class PBOutputScope extends PBScope {
    constructor(){
        super(null);
    }
    /** @internal */ $_getLocalScope() {
        return null;
    }
    /** @internal */ $set(prop, value) {
        if (prop[0] === '$' /* || prop in this*/ ) {
            this[prop] = value;
        } else {
            const pb = getCurrentProgramBuilder();
            if (!(prop in this)) {
                if (pb.getCurrentScope() === pb.getGlobalScope() && (!(value instanceof PBShaderExp) || !(value.$ast instanceof ASTShaderExpConstructor))) {
                    throw new Error(`invalid shader output variable declaration: ${prop}`);
                }
                const type = value.$ast.getType();
                if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {
                    throw new Error(`type cannot be used as pipeline input/output: ${prop}`);
                }
                const location = pb._outputs.length;
                pb.out(location, prop, new PBShaderExp(`${pb.shaderKind === 'vertex' ? output_prefix_vs : output_prefix_fs}${prop}`, type).tag(...value.$tags));
                // modify output struct for webgpu
                if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                    const st = getCurrentProgramBuilder().shaderType;
                    if (getCurrentProgramBuilder().findStructType(getBuiltinInputStructName(st), st)) {
                        getCurrentProgramBuilder().defineBuiltinStruct(st, 'out');
                    }
                }
            }
            if (getCurrentProgramBuilder().getCurrentScope() !== getCurrentProgramBuilder().getGlobalScope()) {
                const ast = value.$ast;
                if (!(ast instanceof ASTShaderExpConstructor) || ast.args.length > 0) {
                    this[prop] = value;
                }
            }
        }
        return true;
    }
}
/**
 * The global scope of a shader
 * @public
 */ class PBGlobalScope extends PBScope {
    /** @internal */ $_inputStructInfo;
    /** @internal */ constructor(){
        super(new ASTGlobalScope());
        this.$_inputStructInfo = null;
    }
    /** @internal */ get $inputStructInfo() {
        if (!this.$_inputStructInfo) {
            this.$_inputStructInfo = this.$builder.defineBuiltinStruct(this.$builder.shaderType, 'in');
        }
        return this.$_inputStructInfo;
    }
    /** @internal */ get $inputStruct() {
        return this.$inputStructInfo[0];
    }
    /** @internal */ $mainFunc(body) {
        const pb = getCurrentProgramBuilder();
        if (pb.getDevice().type === 'webgpu') {
            const inputStruct = this.$inputStructInfo;
            //this.$local(inputStruct[1]);
            const isCompute = pb.shaderType === ShaderType.Compute;
            const outputStruct = isCompute ? null : pb.defineBuiltinStruct(pb.shaderType, 'out');
            if (outputStruct) {
                this.$local(outputStruct[1]);
            }
            // this.$internalCreateFunction('chMainStub', [], false, body);
            this.$internalCreateFunction('main', inputStruct ? [
                inputStruct[3]
            ] : [], true, function() {
                /*
          if (inputStruct) {
            this[inputStruct[1].$str] = this[inputStruct[3].$str];
          }
          */ if (pb.shaderType === ShaderType.Fragment && pb.emulateDepthClamp) {
                    this.$builtins.fragDepth = pb.clamp(this.$inputs.clamppedDepth, 0, 1);
                }
                body?.call(this);
                //this.chMainStub();
                if (pb.shaderType === ShaderType.Vertex) {
                    if (pb.depthRangeCorrection) {
                        this.$builtins.position.z = pb.mul(pb.add(this.$builtins.position.z, this.$builtins.position.w), 0.5);
                    }
                    if (pb.emulateDepthClamp) {
                        //z = gl_Position.z / gl_Position.w;
                        //z = (gl_DepthRange.diff * z + gl_DepthRange.near + gl_DepthRange.far) * 0.5;
                        this.$outputs.clamppedDepth = pb.div(this.$builtins.position.z, this.$builtins.position.w);
                        this.$builtins.position.z = 0;
                    }
                }
                if (!isCompute) {
                    this.$return(outputStruct[1]);
                }
            });
        } else {
            this.$internalCreateFunction('main', [], true, function() {
                if (pb.shaderType === ShaderType.Fragment && pb.emulateDepthClamp) {
                    this.$builtins.fragDepth = pb.clamp(this.$inputs.clamppedDepth, 0, 1);
                }
                body?.call(this);
                if (pb.shaderType === ShaderType.Vertex && pb.emulateDepthClamp) {
                    this.$outputs.clamppedDepth = pb.div(pb.add(pb.div(this.$builtins.position.z, this.$builtins.position.w), 1), 2);
                    this.$builtins.position.z = 0;
                }
            });
        }
    }
    /** @internal */ $createFunctionIfNotExists(name, params, body) {
        {
            this.$internalCreateFunction(name, params, false, body);
        }
    }
    /** @internal */ $getFunctions(name) {
        return this.$ast.findFunctions(name);
    }
    /** @internal */ $getCurrentFunctionScope() {
        let scope = getCurrentProgramBuilder().getCurrentScope();
        while(scope && !(scope instanceof PBFunctionScope)){
            scope = scope.$parent;
        }
        return scope;
    }
    /** @internal */ $internalCreateFunction(name, params, isMain, body) {
        const pb = getCurrentProgramBuilder();
        if (pb.getDevice().type === 'webgpu' && !isMain) {
            params.push(this.$inputStruct(getBuiltinParamName(pb.shaderType)));
        }
        params.forEach((param)=>{
            if (!(param.$ast instanceof ASTPrimitive)) {
                throw new Error(`${name}(): invalid function definition`);
            }
            let ast = param.$ast;
            if (param.$inout) {
                if (getCurrentProgramBuilder().getDevice().type === 'webgpu') {
                    param.$typeinfo = new PBPointerTypeInfo(param.$typeinfo, PBAddressSpace.UNKNOWN);
                }
                ast = new ASTReferenceOf(param.$ast);
            }
            param.$ast = new ASTFunctionParameter(ast);
        });
        const overloads = this.$getFunctions(name);
        const currentFunctionScope = this.$getCurrentFunctionScope();
        const astFunc = new ASTFunction(name, params.map((val)=>val.$ast), isMain, null, false);
        if (currentFunctionScope) {
            const curIndex = this.$ast.statements.indexOf(currentFunctionScope.$ast);
            if (curIndex < 0) {
                throw new Error('Internal error');
            }
            this.$ast.statements.splice(curIndex, 0, astFunc);
        } else {
            this.$ast.statements.push(astFunc);
        }
        new PBFunctionScope(this, params, astFunc, body);
        if (!astFunc.returnType) {
            astFunc.returnType = typeVoid;
        }
        astFunc.funcType = new PBFunctionTypeInfo(astFunc.name, astFunc.returnType, params.map((param)=>{
            const ast = param.$ast;
            return ast.paramAST instanceof ASTReferenceOf ? {
                type: ast.paramAST.value.getType(),
                byRef: ast.paramAST instanceof ASTReferenceOf
            } : {
                type: ast.paramAST.getType(),
                byRef: false
            };
        }));
        for (const overload of overloads){
            if (overload.funcType.argHash === astFunc.funcType.argHash) {
                if (overload.returnType.isCompatibleType(astFunc.returnType)) {
                    // Function signature already exists
                    // console.warn(`Function '${name}' already exists`);
                    this.$ast.statements.splice(this.$ast.statements.indexOf(astFunc), 1);
                    return;
                } else {
                    throw new Error(`Invalid function overloading: ${name}`);
                }
            }
        }
        if (overloads.length === 0) {
            Object.defineProperty(this, name, {
                get: function() {
                    const func = this.$getFunctions(name);
                    if (func.length === 0) {
                        throw new Error(`function ${name} not found`);
                    }
                    return (...args)=>{
                        let inputArg = null;
                        if (pb.getDevice().type === 'webgpu') {
                            let funcScope = pb.getCurrentScope();
                            while(funcScope && !(funcScope instanceof PBFunctionScope)){
                                funcScope = funcScope.$parent;
                            }
                            const funcArgs = funcScope.$ast.args;
                            const arg = funcArgs[funcArgs.length - 1].paramAST;
                            const name = arg.name;
                            inputArg = funcScope[name];
                        }
                        const argsNonArray = (inputArg ? [
                            ...args,
                            inputArg
                        ] : args).map((val)=>pb.normalizeExpValue(val));
                        const funcType = pb._getFunctionOverload(name, argsNonArray);
                        if (!funcType) {
                            throw new Error(`ERROR: no matching overloads for function ${name}`);
                        }
                        return getCurrentProgramBuilder().$callFunction(name, funcType[1], funcType[0]);
                    };
                }
            });
        }
    }
}
/**
 * Scope that is inside a function
 * @public
 */ class PBInsideFunctionScope extends PBScope {
    /** @internal */ constructor(parent){
        super(new ASTScope(), parent);
    }
    /**
   * Creates a 'return' statement
   * @param retval - The return value
   */ $return(retval) {
        const functionScope = this.findOwnerFunction();
        const astFunc = functionScope.$ast;
        let returnType = null;
        const retValNonArray = getCurrentProgramBuilder().normalizeExpValue(retval);
        if (retValNonArray !== undefined && retValNonArray !== null) {
            if (typeof retValNonArray === 'number') {
                if (astFunc.returnType) {
                    if (astFunc.returnType.isPrimitiveType() && astFunc.returnType.isScalarType() && !astFunc.returnType.isCompatibleType(typeBool)) {
                        returnType = astFunc.returnType;
                    }
                }
                if (!returnType) {
                    if (Number.isInteger(retValNonArray)) {
                        if (retValNonArray < 0) {
                            if (retValNonArray < 0x80000000 >> 0) {
                                throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);
                            }
                            returnType = typeI32;
                        } else {
                            if (retValNonArray > 0xffffffff) {
                                throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);
                            }
                            returnType = retValNonArray <= 0x7fffffff ? typeI32 : typeU32$1;
                        }
                    } else {
                        returnType = typeF32;
                    }
                }
            } else if (typeof retValNonArray === 'boolean') {
                returnType = typeBool;
            } else {
                returnType = retValNonArray.$ast.getType();
            }
        } else {
            returnType = typeVoid;
        }
        if (returnType.isPointerType()) {
            throw new Error('function can not return pointer type');
        }
        if (!astFunc.returnType) {
            astFunc.returnType = returnType;
        } else if (!astFunc.returnType.isCompatibleType(returnType)) {
            throw new Error(`function ${astFunc.name}: return type must be ${astFunc.returnType?.toTypeName(getCurrentProgramBuilder().getDevice().type) || 'void'}`);
        }
        let returnValue = null;
        if (retValNonArray !== undefined && retValNonArray !== null) {
            if (retValNonArray instanceof PBShaderExp) {
                returnValue = retValNonArray.$ast;
            } else {
                if (!returnType.isPrimitiveType() || !returnType.isScalarType()) {
                    throw new PBTypeCastError(retValNonArray, typeof retValNonArray, returnType);
                }
                returnValue = new ASTScalar(retValNonArray, returnType);
            }
        }
        this.$ast.statements.push(new ASTReturn(returnValue));
    }
    /**
   * Creates a new scope
   * @param body - Generator function for the scope
   * @returns The created scope
   */ $scope(body) {
        const astScope = new ASTNakedScope();
        this.$ast.statements.push(astScope);
        return new PBNakedScope(this, astScope, body);
    }
    /**
   * Creates an 'if' statement
   * @param condition - Condition expression for the if statement
   * @param body - Generator function for the scope inside the if statement
   * @returns The scope inside the if statement
   */ $if(condition, body) {
        const astIf = new ASTIf('if', condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool));
        this.$ast.statements.push(astIf);
        return new PBIfScope(this, astIf, body);
    }
    /**
   * Creates a select statement: condition ? first : second
   * @param condition - Condition expression
   * @param first - The first value
   * @param second - The second value
   * @returns The first value if condition evaluates to true, otherwise returns the second value
   */ $choice(condition, first, second) {
        const ast = new ASTSelect(condition instanceof PBShaderExp ? condition.$ast : condition, first instanceof PBShaderExp ? first.$ast : first, second instanceof PBShaderExp ? second.$ast : second);
        const exp = new PBShaderExp('', ast.getType());
        exp.$ast = ast;
        return exp;
    }
    /** Creates a 'break' statement */ $break() {
        this.$ast.statements.push(new ASTBreak());
    }
    /** Creates a 'continue' statement */ $continue() {
        this.$ast.statements.push(new ASTContinue());
    }
    /**
   * Creates a 'for' statement
   * @param counter - The repeat counter variable declaration
   * @param init - initial value of the repeat counter variable
   * @param end - end value of the counter exclusive
   * @param body - Generator function for the scope that inside the for statement
   */ $for(counter, init, end, body) {
        const initializerType = counter.$ast.getType();
        if (!initializerType.isPrimitiveType() || !initializerType.isScalarType()) {
            throw new PBASTError(counter.$ast, 'invalid for range initializer type');
        }
        const initval = init instanceof PBShaderExp ? init.$ast : new ASTScalar(init, initializerType);
        const astFor = new ASTRange(counter.$ast, initval, end instanceof PBShaderExp ? end.$ast : new ASTScalar(end, initializerType), true);
        this.$ast.statements.push(astFor);
        new PBForScope(this, counter, end, astFor, body);
    }
    /**
   * Creates a 'do..while' statement
   * @param body - Generator function for the scope that inside the do..while statment
   * @returns The scope that inside the do..while statement
   */ $do(body) {
        if (this.$builder.getDevice().type === 'webgl') {
            throw new Error(`No do-while() loop support for WebGL1.0 device`);
        }
        const astDoWhile = new ASTDoWhile(null);
        this.$ast.statements.push(astDoWhile);
        return new PBDoWhileScope(this, astDoWhile, body);
    }
    /**
   * Creates a 'while' statement
   * @param condition - Condition expression for the while statement
   * @param body - Generator function for the scope that inside the while statement
   */ $while(condition, body) {
        const astWhile = new ASTWhile(condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool));
        this.$ast.statements.push(astWhile);
        new PBWhileScope(this, astWhile, body);
    }
    /** @internal */ findOwnerFunction() {
        for(let scope = this; scope; scope = scope.$parent){
            if (scope instanceof PBFunctionScope) {
                return scope;
            }
        }
        return null;
    }
}
/**
 * Scope that insides a function
 * @public
 */ class PBFunctionScope extends PBInsideFunctionScope {
    /** @internal */ $typeinfo;
    /** @internal */ constructor(parent, params, ast, body){
        super(parent);
        this.$ast = ast;
        for (const param of params){
            if (this.$_variables[param.$str]) {
                throw new Error('Duplicate function parameter name is not allowed');
            }
            this.$_registerVar(param);
        }
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    $isMain() {
        return this.$ast.isMainFunc;
    }
}
/**
 * Scope that insides a while statement
 * @public
 */ class PBWhileScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * Scope that insides a do..while statement
 * @public
 */ class PBDoWhileScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    $while(condition) {
        this.$ast.condition = condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool);
    }
}
/**
 * Scope that insides a for statement
 * @public
 */ class PBForScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, counter, count, ast, body){
        super(parent);
        this.$ast = ast;
        this.$_registerVar(counter);
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * A naked scope
 * @public
 */ class PBNakedScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
}
/**
 * Scope that insides an if statement
 * @public
 */ class PBIfScope extends PBInsideFunctionScope {
    /** @internal */ constructor(parent, ast, body){
        super(parent);
        this.$ast = ast;
        getCurrentProgramBuilder().pushScope(this);
        body && body.call(this);
        getCurrentProgramBuilder().popScope();
    }
    /**
   * Creates an 'else if' branch
   * @param condition - Condition expression for the else if branch
   * @param body - Generator function for the scope that insides the else if statement
   * @returns The scope that insides the else if statement
   */ $elseif(condition, body) {
        const astElseIf = new ASTIf('else if', condition instanceof PBShaderExp ? condition.$ast : new ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool));
        this.$ast.nextElse = astElseIf;
        return new PBIfScope(this.$_parentScope, astElseIf, body);
    }
    /**
   * Creates an 'else' branch
   * @param body - Generator function for the scope that insides the else statement
   */ $else(body) {
        const astElse = new ASTIf('else', null);
        this.$ast.nextElse = astElse;
        new PBIfScope(this.$_parentScope, astElse, body);
    }
}
setBuiltinFuncs(ProgramBuilder);
setConstructors(ProgramBuilder);

/** @internal */ class FontCanvas {
    static _canvas = null;
    static _context = null;
    static get canvas() {
        this._realize();
        return this._canvas;
    }
    static get context() {
        this._realize();
        return this._context;
    }
    static get font() {
        return this.context.font;
    }
    static set font(font) {
        this.context.font = font;
    }
    static _realize() {
        if (!this._canvas) {
            this._canvas = document.createElement('canvas');
            this._canvas.width = 512;
            this._canvas.height = 512;
            this._canvas.style.left = '-10000px';
            this._canvas.style.position = 'absolute';
            //document.body.appendChild(this._canvas);
            this._context = this._canvas.getContext('2d', {
                willReadFrequently: true
            });
            this._context.textBaseline = 'top';
            this._context.textAlign = 'left';
            this._context.fillStyle = 'transparent';
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
            this._context.fillStyle = '#ffffff';
            this._context.imageSmoothingEnabled = true;
        }
    }
}
/**
 * The font class
 * @public
 */ class Font {
    /** @internal */ static fontCache = {};
    /** @internal */ _name;
    /** @internal */ _nameScaled;
    /** @internal */ _scale;
    /** @internal */ _size;
    /** @internal */ _family;
    /** @internal */ _top;
    /** @internal */ _bottom;
    /** @internal */ _topScaled;
    /** @internal */ _bottomScaled;
    /** @internal */ _div;
    /**
   * Creates a instance of font class from font name and the scale value
   * @param name - The font name
   * @param scale - The scale value
   */ constructor(name, scale){
        this._top = 0;
        this._bottom = 0;
        this._size = 0;
        this._topScaled = 0;
        this._bottomScaled = 0;
        this._family = '';
        this._scale = scale;
        this._name = name;
        this._nameScaled = null;
        this._div = document.createElement('div');
        if (this._name) {
            this._normalizeFont();
        }
    }
    /**
   * Fetch a font from cache
   * @param name - The font name
   * @param scale - The scale value
   * @returns The font object
   */ static fetchFont(name, scale) {
        let fontlist = this.fontCache[name];
        if (!fontlist) {
            fontlist = {};
            this.fontCache[name] = fontlist;
        }
        let font = fontlist[scale];
        if (!font) {
            font = new Font(name, scale);
            fontlist[scale] = font;
        }
        return font;
    }
    /** Gets the font name */ get fontName() {
        return this._name;
    }
    set fontName(name) {
        this._name = name;
        this._normalizeFont();
    }
    /** Gets the scaled font name */ get fontNameScaled() {
        return this._nameScaled;
    }
    /** Gets the font size */ get size() {
        return this._size;
    }
    /** Gets the font family */ get family() {
        return this._family;
    }
    /** Gets top position of the font */ get top() {
        return this._top;
    }
    /** Gets the bottom position of the font */ get bottom() {
        return this._bottom;
    }
    /** Gets the scaled top position of the font */ get topScaled() {
        return this._topScaled;
    }
    /** Gets the scaled bottom position of the font */ get bottomScaled() {
        return this._bottomScaled;
    }
    /** Gets the maximum height of the font */ get maxHeight() {
        return this._bottom - this._top + 1;
    }
    /** Gets the scaled maximum height of the font */ get maxHeightScaled() {
        return this._bottomScaled - this._topScaled + 1;
    }
    /** Tests if two fonts are the same */ equalTo(other) {
        return this._size === other._size && this._family === other._family;
    }
    /** @internal */ _measureFontHeight(fontName) {
        const oldFont = FontCanvas.context.font;
        const oldTextBaseline = FontCanvas.context.textBaseline;
        const oldFillStyle = FontCanvas.context.fillStyle;
        FontCanvas.context.font = fontName;
        this._div.style.font = FontCanvas.context.font;
        const fontSize = this._div.style.fontSize;
        const size = parseInt(fontSize.substring(0, fontSize.length - 2));
        const family = this._div.style.fontFamily;
        const testString = 'bdfghijklpq国美|_~';
        const metric = FontCanvas.context.measureText(testString);
        let top, bottom;
        top = 0;
        bottom = size - 1;
        const extra = 10;
        const halfExtra = extra >> 1;
        const maxWidth = Math.ceil(metric.width) + extra;
        const maxHeight = size + extra;
        FontCanvas.context.clearRect(0, 0, maxWidth, maxHeight);
        FontCanvas.context.textBaseline = 'top';
        FontCanvas.context.fillStyle = '#ffffff';
        FontCanvas.context.fillText(testString, halfExtra, halfExtra);
        const bitmap = FontCanvas.context.getImageData(0, 0, maxWidth, maxHeight);
        const pixels = bitmap.data;
        for(let i = 0; i < maxWidth * maxHeight; i++){
            if (pixels[i * 4 + 3] > 0) {
                top = Math.floor(i / maxWidth);
                break;
            }
        }
        for(let i = maxWidth * maxHeight - 1; i >= 0; i--){
            if (pixels[i * 4 + 3] > 0) {
                bottom = Math.floor(i / maxWidth);
                break;
            }
        }
        top -= halfExtra;
        bottom -= halfExtra;
        FontCanvas.context.font = oldFont;
        FontCanvas.context.textBaseline = oldTextBaseline;
        FontCanvas.context.fillStyle = oldFillStyle;
        return {
            size,
            family,
            top,
            bottom
        };
    }
    /** @internal */ _normalizeFont() {
        const info = this._measureFontHeight(this._name);
        this._nameScaled = `${Math.round(info.size * this._scale)}px ${info.family}`;
        const infoScaled = this._measureFontHeight(this._nameScaled);
        this._size = info.size;
        this._family = info.family;
        this._top = info.top;
        this._bottom = info.bottom;
        this._topScaled = infoScaled.top;
        this._bottomScaled = infoScaled.bottom;
    }
}

/**
 * Texture atlas manager
 * @public
 */ class TextureAtlasManager {
    /** @internal */ static ATLAS_WIDTH = 1024;
    /** @internal */ static ATLAS_HEIGHT = 1024;
    /** @internal */ _packer;
    /** @internal */ _device;
    /** @internal */ _binWidth;
    /** @internal */ _binHeight;
    /** @internal */ _rectBorderWidth;
    /** @internal */ _linearSpace;
    /** @internal */ _atlasList;
    /** @internal */ _atlasInfoMap;
    /** @internal */ _atlasRestoreHandler;
    /**
   * Creates a new texture atlas manager instance
   * @param device - The render device
   * @param binWidth - Width of an atlas bin
   * @param binHeight - Height of an atlas bin
   * @param rectBorderWidth - Border width of an atlas
   * @param linearSpace - true if the texture space is linear
   */ constructor(device, binWidth, binHeight, rectBorderWidth, linearSpace){
        this._device = device;
        this._binWidth = binWidth;
        this._binHeight = binHeight;
        this._rectBorderWidth = rectBorderWidth;
        this._linearSpace = !!linearSpace;
        this._packer = new RectsPacker(this._binWidth, this._binHeight);
        this._atlasList = [];
        this._atlasInfoMap = {};
        this._atlasRestoreHandler = null;
    }
    /**
   * The texture restore handler callback function
   * This callback function will be called whenever the device has been restored
   */ get atlasTextureRestoreHandler() {
        return this._atlasRestoreHandler;
    }
    set atlasTextureRestoreHandler(f) {
        this._atlasRestoreHandler = f;
    }
    /**
   * Gets the atlas texture of a given index
   * @param index - Index of the atlas bin
   * @returns Atlas texture for given index
   */ getAtlasTexture(index) {
        return this._atlasList[index];
    }
    /**
   * Gets the information about specified atlas
   * @param key - Key of the atlas
   * @returns Information of the atlas
   */ getAtlasInfo(key) {
        return this._atlasInfoMap[key] || null;
    }
    /**
   * Check if no atlas has been created
   * @returns true if no atlas has been created
   */ isEmpty() {
        return this._atlasList.length === 0;
    }
    /**
   * Removes all created atlases
   */ clear() {
        this._packer.clear();
        for (const tex of this._atlasList){
            tex.dispose();
        }
        this._atlasList = [];
        this._atlasInfoMap = {};
    }
    /**
   * Inserts a rectangle of a canvas to the atlas texture
   * @param key - Key of the atlas
   * @param ctx - The canvas context
   * @param x - x offset of the rectangle
   * @param y - y offset of the rectangle
   * @param w - width of the rectangle
   * @param h - height of the rectangle
   * @returns The atals info or null if insert failed
   */ pushCanvas(key, ctx, x, y, w, h) {
        const rc = this._packer.insert(w + 2 * this._rectBorderWidth, h + 2 * this._rectBorderWidth);
        if (rc) {
            const atlasX = rc.x + this._rectBorderWidth;
            const atlasY = rc.y + this._rectBorderWidth;
            this._updateAtlasTextureCanvas(rc.binIndex, ctx, atlasX, atlasY, w, h, x, y);
            const info = {
                atlasIndex: rc.binIndex,
                uMin: atlasX / this._binWidth,
                vMin: atlasY / this._binHeight,
                uMax: (atlasX + w) / this._binWidth,
                vMax: (atlasY + h) / this._binHeight,
                width: w,
                height: h
            };
            this._atlasInfoMap[key] = info;
            return info;
        }
        return null;
    }
    /**
   * Inserts a bitmap to the atlas texture
   * @param key - Key of the atlas
   * @param bitmap - The bitmap object
   * @returns The atals info or null if insert failed
   */ pushBitmap(key, bitmap) {
        const rc = this._packer.insert(bitmap.width + 2 * this._rectBorderWidth, bitmap.height + 2 * this._rectBorderWidth);
        if (rc) {
            const atlasX = rc.x + this._rectBorderWidth;
            const atlasY = rc.y + this._rectBorderWidth;
            this._updateAtlasTexture(rc.binIndex, bitmap, atlasX, atlasY);
            const info = {
                atlasIndex: rc.binIndex,
                uMin: atlasX / this._binWidth,
                vMin: atlasY / this._binHeight,
                uMax: (atlasX + bitmap.width) / this._binWidth,
                vMax: (atlasY + bitmap.height) / this._binHeight,
                width: bitmap.width,
                height: bitmap.height
            };
            this._atlasInfoMap[key] = info;
            return info;
        }
        return null;
    }
    /** @internal */ _createAtlasTexture() {
        const tex = this._device.createTexture2D('rgba8unorm', this._binWidth, this._binHeight, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        tex.update(new Uint8Array(tex.width * tex.height * 4), 0, 0, tex.width, tex.height);
        tex.restoreHandler = async ()=>{
            tex.update(new Uint8Array(tex.width * tex.height * 4), 0, 0, tex.width, tex.height);
            this._atlasRestoreHandler && await this._atlasRestoreHandler(tex);
        };
        return tex;
    }
    /** @internal */ _updateAtlasTextureCanvas(atlasIndex, ctx, x, y, w, h, xOffset, yOffset) {
        let textureAtlas = null;
        if (atlasIndex === this._atlasList.length) {
            textureAtlas = this._createAtlasTexture();
            this._atlasList.push(textureAtlas);
        } else {
            textureAtlas = this._atlasList[atlasIndex];
        }
        textureAtlas.updateFromElement(ctx.canvas, x, y, xOffset, yOffset, w, h);
    }
    /** @internal */ _updateAtlasTexture(atlasIndex, bitmap, x, y) {
        let textureAtlas = null;
        if (atlasIndex === this._atlasList.length) {
            textureAtlas = this._createAtlasTexture();
            this._atlasList.push(textureAtlas);
        } else {
            textureAtlas = this._atlasList[atlasIndex];
        }
        if (bitmap instanceof ImageBitmap) {
            textureAtlas.updateFromElement(bitmap, x, y, 0, 0, bitmap.width, bitmap.height);
        } else {
            const originValues = new Uint8Array(bitmap.data.buffer);
            textureAtlas.update(originValues, x, y, bitmap.width, bitmap.height);
        }
    }
}

/**
 * Manager of texture glyphs
 * @public
 */ class GlyphManager extends TextureAtlasManager {
    /**
   * Creates a new glyph manager instance
   * @param device - The render device
   * @param binWidth - Width of an atlas bin
   * @param binHeight - Height of an atlas bin
   * @param border - Border width of an atlas
   */ constructor(device, binWidth, binHeight, border){
        super(device, binWidth, binHeight, border, true);
        this.atlasTextureRestoreHandler = async ()=>{
            if (!this.isEmpty()) {
                this.clear();
            }
        };
    }
    /**
   * Gets the atlas information for given character
   * @param char - The character
   * @param font - Font of the character
   * @returns Atlas information for the glyph
   */ getGlyphInfo(char, font) {
        if (!char || !font) {
            return null;
        }
        let glyphInfo = this.getAtlasInfo(this._hash(char, font));
        if (!glyphInfo) {
            glyphInfo = this._cacheGlyph(char, font);
            glyphInfo.width = Math.round(glyphInfo.width * (font.maxHeight / font.maxHeightScaled));
            glyphInfo.height = font.maxHeight;
        }
        return glyphInfo;
    }
    /**
   * Measuring the width of a string
   * @param str - The string to be measured
   * @param charMargin - margin size between characters
   * @param font - Font of the string
   * @returns Width of the string
   */ measureStringWidth(str, charMargin, font) {
        let w = 0;
        for (const ch of str){
            w += charMargin + this.getCharWidth(ch, font);
        }
        return w;
    }
    /**
   * Clips a string so that it's width is not larger than the given value
   * @param str - The string to be clipped
   * @param width - The desired maximum width
   * @param charMargin - Margin size between characters
   * @param start - Start index of the string to be clipped
   * @param font - Font of the string
   * @returns
   */ clipStringToWidth(str, width, charMargin, start, font) {
        let sum = 0;
        let i = start;
        for(; i < str.length; i++){
            sum += charMargin + this.getCharWidth(str[i], font);
            if (sum > width) {
                break;
            }
        }
        return i - start;
    }
    /** @internal */ _hash(char, font) {
        return `${font.family}@${font.size}&${char}`;
    }
    /** @internal */ _cacheGlyph(char, font) {
        const bitmap = this._getGlyphBitmap(char, font);
        return this.pushBitmap(this._hash(char, font), bitmap);
    }
    /**
   * Measuring width of a character
   * @param char - The character to be measured
   * @param font - Font of the character
   * @returns Width of the character
   */ getCharWidth(char, font) {
        if (!font) {
            return 0;
        }
        FontCanvas.font = font.fontNameScaled;
        const metric = FontCanvas.context.measureText(char);
        let w = metric.width;
        if (w === 0) {
            return 0;
        }
        if (typeof metric.actualBoundingBoxRight === 'number') {
            w = Math.floor(Math.max(w, metric.actualBoundingBoxRight) + 0.8);
        }
        w = Math.round(w * (font.maxHeight / font.maxHeightScaled));
        return w;
    }
    /** @internal */ _getGlyphBitmap(char, font) {
        if (!font) {
            return null;
        }
        FontCanvas.font = font.fontNameScaled;
        const metric = FontCanvas.context.measureText(char);
        let w = metric.width;
        if (w === 0) {
            return null;
        }
        if (typeof metric.actualBoundingBoxRight === 'number') {
            w = Math.floor(Math.max(w, metric.actualBoundingBoxRight) + 0.8);
        }
        const h = font.maxHeightScaled;
        FontCanvas.context.fillStyle = '#fff';
        FontCanvas.context.clearRect(0, 0, w + 2, h);
        FontCanvas.context.fillText(char, 0, -font.topScaled);
        return FontCanvas.context.getImageData(0, 0, w, h);
    }
}

const MAX_GLYPH_COUNT = 1024;
/**
 * Helper class to draw some text onto the screen
 * @public
 */ class DrawText {
    /** @internal */ static GLYPH_COUNT = MAX_GLYPH_COUNT;
    /** @internal */ static glyphManager = null;
    /** @internal */ static prepared = false;
    /** @internal */ static textVertexBuffer = null;
    /** @internal */ static textVertexLayout = null;
    /** @internal */ static textProgram = null;
    /** @internal */ static textBindGroup = null;
    /** @internal */ static textRenderStates = null;
    /** @internal */ static textOffset = 0;
    /** @internal */ static textMatrix = new Matrix4x4();
    /** @internal */ static font = null;
    /** @internal */ static vertexCache = null;
    /** @internal */ static colorValue = new Vector4();
    /** @internal */ static calculateTextMatrix(device, matrix) {
        const viewport = device.getViewport();
        const projectionMatrix = Matrix4x4.ortho(0, viewport.width, 0, viewport.height, 1, 100);
        const flipMatrix = Matrix4x4.translation(new Vector3(0, viewport.height, 0)).scaleRight(new Vector3(1, -1, 1));
        Matrix4x4.multiply(projectionMatrix, flipMatrix, matrix);
    }
    /**
   * Set the font that will be used to draw strings
   * @param device - The render device
   * @param name - The font name
   */ static setFont(device, name) {
        this.font = Font.fetchFont(name, device.getScale()) || Font.fetchFont('12px arial', device.getScale());
    }
    /**
   * Draw text onto the screen
   * @param device - The render device
   * @param text - The text to be drawn
   * @param color - The text color
   * @param x - X coordinate of the text
   * @param y - Y coordinate of the text
   */ static drawText(device, text, color, x, y) {
        if (text.length > 0) {
            device.pushDeviceStates();
            this.prepareDrawText(device);
            this.calculateTextMatrix(device, this.textMatrix);
            const colorValue = parseColor(color);
            this.colorValue.x = colorValue.r;
            this.colorValue.y = colorValue.g;
            this.colorValue.z = colorValue.b;
            this.colorValue.w = colorValue.a;
            this.textBindGroup.setValue('flip', device.type === 'webgpu' && device.getFramebuffer() ? 1 : 0);
            this.textBindGroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
            this.textBindGroup.setValue('textMatrix', this.textMatrix);
            this.textBindGroup.setValue('textColor', this.colorValue);
            device.setProgram(this.textProgram);
            device.setVertexLayout(this.textVertexLayout);
            device.setRenderStates(this.textRenderStates);
            device.setBindGroup(0, this.textBindGroup);
            let drawn = 0;
            const total = text.length;
            while(drawn < total){
                const count = Math.min(total - drawn, this.GLYPH_COUNT - this.textOffset);
                if (count > 0) {
                    x = this.drawTextNoOverflow(device, text, drawn, count, x, y);
                    drawn += count;
                    this.textOffset += count;
                }
                if (this.GLYPH_COUNT === this.textOffset) {
                    this.textOffset = 0;
                    device.flush();
                }
            }
            device.popDeviceStates();
        }
    }
    /** @internal */ static drawTextNoOverflow(device, text, start, count, x, y) {
        let drawn = 0;
        let atlasIndex = -1;
        let i = 0;
        for(; i < count; i++){
            const glyph = this.glyphManager.getGlyphInfo(text[i + start], this.font) || this.glyphManager.getGlyphInfo('?', this.font);
            if (atlasIndex >= 0 && glyph.atlasIndex !== atlasIndex) {
                this.textVertexBuffer.bufferSubData((this.textOffset + drawn) * 16 * 4, this.vertexCache, (this.textOffset + drawn) * 16, (i - drawn) * 16);
                this.textBindGroup.setTexture('tex', this.glyphManager.getAtlasTexture(atlasIndex));
                device.draw('triangle-list', (this.textOffset + drawn) * 6, (i - drawn) * 6);
                drawn = i;
            }
            atlasIndex = glyph.atlasIndex;
            const base = (this.textOffset + i) * 16;
            this.vertexCache[base + 0] = x;
            this.vertexCache[base + 1] = y;
            this.vertexCache[base + 2] = glyph.uMin;
            this.vertexCache[base + 3] = glyph.vMin;
            this.vertexCache[base + 4] = x + glyph.width;
            this.vertexCache[base + 5] = y;
            this.vertexCache[base + 6] = glyph.uMax;
            this.vertexCache[base + 7] = glyph.vMin;
            this.vertexCache[base + 8] = x + glyph.width;
            this.vertexCache[base + 9] = y + glyph.height;
            this.vertexCache[base + 10] = glyph.uMax;
            this.vertexCache[base + 11] = glyph.vMax;
            this.vertexCache[base + 12] = x;
            this.vertexCache[base + 13] = y + glyph.height;
            this.vertexCache[base + 14] = glyph.uMin;
            this.vertexCache[base + 15] = glyph.vMax;
            x += glyph.width;
        }
        this.textVertexBuffer.bufferSubData((this.textOffset + drawn) * 16 * 4, this.vertexCache, (this.textOffset + drawn) * 16, (i - drawn) * 16);
        this.textBindGroup.setTexture('tex', this.glyphManager.getAtlasTexture(atlasIndex));
        device.draw('triangle-list', (this.textOffset + drawn) * 6, (i - drawn) * 6);
        return x;
    }
    /** @internal */ static prepareDrawText(device) {
        if (!this.prepared) {
            this.prepared = true;
            this.font = this.font || Font.fetchFont('16px arial', device.getScale());
            this.glyphManager = new GlyphManager(device, 1024, 1024, 1);
            this.vertexCache = new Float32Array(this.GLYPH_COUNT * 16);
            this.textVertexBuffer = device.createInterleavedVertexBuffer([
                'position_f32x2',
                'tex0_f32x2'
            ], this.vertexCache, {
                dynamic: true
            });
            const indices = new Uint16Array(this.GLYPH_COUNT * 6);
            for(let i = 0; i < this.GLYPH_COUNT; i++){
                const base = i * 4;
                indices[i * 6 + 0] = base + 0;
                indices[i * 6 + 1] = base + 1;
                indices[i * 6 + 2] = base + 2;
                indices[i * 6 + 3] = base + 0;
                indices[i * 6 + 4] = base + 2;
                indices[i * 6 + 5] = base + 3;
            }
            const textIndexBuffer = device.createIndexBuffer(indices);
            this.textVertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: this.textVertexBuffer
                    }
                ],
                indexBuffer: textIndexBuffer
            });
            this.textOffset = 0;
            this.textProgram = device.buildRenderProgram({
                vertex (pb) {
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$inputs.uv = pb.vec2().attrib('texCoord0');
                    this.$outputs.uv = pb.vec2();
                    this.flip = pb.int(0).uniform(0);
                    this.textMatrix = pb.mat4().uniform(0);
                    pb.main(function() {
                        this.$builtins.position = pb.mul(this.textMatrix, pb.vec4(this.$inputs.pos, -50, 1));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                        this.$outputs.uv = this.$inputs.uv;
                    });
                },
                fragment (pb) {
                    this.$outputs.color = pb.vec4();
                    this.textColor = pb.vec4().uniform(0);
                    this.tex = pb.tex2D().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    pb.main(function() {
                        this.alpha = pb.mul(pb.textureSample(this.tex, this.$inputs.uv).a, this.textColor.a);
                        this.$if(pb.notEqual(this.srgbOut, 0), function() {
                            this.$outputs.color = pb.vec4(pb.mul(pb.pow(this.textColor.rgb, pb.vec3(1 / 2.2)), this.alpha), this.alpha);
                        }).$else(function() {
                            this.$outputs.color = pb.vec4(pb.mul(this.textColor.rgb, this.alpha), this.alpha);
                        });
                    });
                }
            });
            this.textBindGroup = device.createBindGroup(this.textProgram.bindGroupLayouts[0]);
            this.textRenderStates = device.createRenderStateSet();
            this.textRenderStates.useBlendingState().enable(true).setBlendFuncRGB('one', 'inv-src-alpha').setBlendFuncAlpha('zero', 'one');
            this.textRenderStates.useDepthState().enableTest(false).enableWrite(false);
            this.textRenderStates.useRasterizerState().setCullMode('none');
        }
    }
}

/**
 * Base class for rendering device
 * @public
 */ class BaseDevice {
    _canvas;
    _canvasClientWidth;
    _canvasClientHeight;
    _gpuObjectList;
    _gpuMemCost;
    _disposeObjectList;
    _beginFrameTime;
    _endFrameTime;
    _frameInfo;
    _cpuTimer;
    _gpuTimer;
    _runningLoop;
    _fpsCounter;
    _runLoopFunc;
    _backend;
    _beginFrameCounter;
    _programBuilder;
    _stateStack;
    constructor(cvs, backend){
        this._backend = backend;
        this._gpuObjectList = {
            textures: [],
            samplers: [],
            buffers: [],
            programs: [],
            framebuffers: [],
            vertexArrayObjects: [],
            bindGroups: []
        };
        this._canvas = cvs;
        this._canvas.setAttribute('tabindex', '1');
        this._canvasClientWidth = cvs.clientWidth;
        this._canvasClientHeight = cvs.clientHeight;
        this._gpuMemCost = 0;
        this._disposeObjectList = [];
        this._beginFrameTime = 0;
        this._endFrameTime = 0;
        this._runLoopFunc = null;
        this._frameInfo = {
            frameCounter: 0,
            frameTimestamp: 0,
            elapsedTimeCPU: 0,
            elapsedTimeGPU: 0,
            elapsedFrame: 0,
            elapsedOverall: 0,
            FPS: 0,
            drawCalls: 0,
            computeCalls: 0,
            nextFrameCall: [],
            nextFrameCallNext: []
        };
        this._programBuilder = new ProgramBuilder(this);
        this._cpuTimer = new CPUTimer();
        this._gpuTimer = null;
        this._runningLoop = null;
        this._fpsCounter = {
            time: 0,
            frame: 0
        };
        this._stateStack = [];
        this._beginFrameCounter = 0;
        this._registerEventHandlers();
    }
    get backend() {
        return this._backend;
    }
    get videoMemoryUsage() {
        return this._gpuMemCost;
    }
    get frameInfo() {
        return this._frameInfo;
    }
    get isRendering() {
        return this._runningLoop !== null;
    }
    get canvas() {
        return this._canvas;
    }
    get type() {
        return this._backend.typeName();
    }
    get runLoopFunction() {
        return this._runLoopFunc;
    }
    get programBuilder() {
        return this._programBuilder;
    }
    setFont(fontName) {
        DrawText.setFont(this, fontName);
    }
    drawText(text, x, y, color) {
        DrawText.drawText(this, text, color, x, y);
    }
    disposeObject(obj, remove = true) {
        if (obj) {
            if (remove) {
                this.removeGPUObject(obj);
            }
            if (!obj.disposed) {
                if (this.isContextLost()) {
                    obj.destroy();
                } else {
                    this._disposeObjectList.push(obj);
                }
            }
            obj.dispatchEvent(null, 'disposed');
        }
    }
    async restoreObject(obj) {
        if (obj && obj.disposed && !this.isContextLost()) {
            await obj.restore();
            if (obj.restoreHandler) {
                await obj.restoreHandler(obj);
            }
        }
    }
    enableGPUTimeRecording(enable) {
        if (enable && !this._gpuTimer) {
            this._gpuTimer = this.createGPUTimer();
        } else if (!enable) {
            this._gpuTimer?.end();
            this._gpuTimer = null;
        }
    }
    beginFrame() {
        if (this._beginFrameCounter === 0) {
            for (const obj of this._disposeObjectList){
                obj.destroy();
            }
            this._disposeObjectList = [];
        }
        this._beginFrameCounter++;
        this._beginFrameTime = this._cpuTimer.now();
        this.updateFrameInfo();
        return this.onBeginFrame();
    }
    endFrame() {
        if (this._beginFrameCounter > 0) {
            this._beginFrameCounter--;
            if (this._beginFrameCounter === 0) {
                this._endFrameTime = this._cpuTimer.now();
                this.onEndFrame();
            }
        }
    }
    getVertexAttribFormat(semantic, dataType, componentCount) {
        return getVertexAttribFormat(semantic, dataType, componentCount);
    }
    createInterleavedVertexBuffer(attribFormats, data, options) {
        if (options && options.usage && options.usage !== 'vertex') {
            console.error(`createVertexBuffer() failed: options.usage must be 'vertex' or not set`);
            return null;
        }
        let size = 0;
        for (const format of attribFormats){
            size += getVertexFormatSize(format);
        }
        const vertexBufferType = makeVertexBufferType(data.byteLength / size >> 0, ...attribFormats);
        const opt = Object.assign({
            usage: 'vertex',
            dynamic: false,
            managed: true,
            storage: false
        }, options || {});
        if (opt.storage) {
            opt.dynamic = false;
            opt.managed = false;
        }
        if (opt.dynamic) {
            opt.managed = false;
        }
        return this.createStructuredBuffer(vertexBufferType, opt, data);
    }
    createVertexBuffer(attribFormat, data, options) {
        if (options && options.usage && options.usage !== 'vertex') {
            console.error(`createVertexBuffer() failed: options.usage must be 'vertex' or not set`);
            return null;
        }
        const count = getVertexFormatSize(attribFormat);
        const vertexBufferType = makeVertexBufferType(data.byteLength / count >> 0, attribFormat);
        const opt = Object.assign({
            usage: 'vertex',
            dynamic: false,
            managed: true,
            storage: false
        }, options || {});
        if (opt.storage) {
            opt.dynamic = false;
            opt.managed = false;
        }
        if (opt.dynamic) {
            opt.managed = false;
        }
        return this.createStructuredBuffer(vertexBufferType, opt, data);
    }
    draw(primitiveType, first, count) {
        this._frameInfo.drawCalls++;
        this._draw(primitiveType, first, count);
    }
    drawInstanced(primitiveType, first, count, numInstances) {
        this._frameInfo.drawCalls++;
        this._drawInstanced(primitiveType, first, count, numInstances);
    }
    compute(workgroupCountX, workgroupCountY, workgroupCountZ) {
        this._frameInfo.computeCalls++;
        this._compute(workgroupCountX, workgroupCountY, workgroupCountZ);
    }
    runNextFrame(f) {
        if (f) {
            this._frameInfo.nextFrameCall.push(f);
        }
    }
    exitLoop() {
        if (this._runningLoop) {
            cancelAnimationFrame(this._runningLoop);
            this._runningLoop = null;
        }
    }
    runLoop(func) {
        if (this._runningLoop !== null) {
            console.error('Device.runLoop() can not be nested');
            return;
        }
        if (!func) {
            console.error('Device.runLoop() argment error');
            return;
        }
        const that = this;
        that._runLoopFunc = func;
        (function entry() {
            that._runningLoop = requestAnimationFrame(entry);
            if (that.beginFrame()) {
                that._runLoopFunc(that);
                that.endFrame();
            }
        })();
    }
    pushDeviceStates() {
        this._stateStack.push({
            windowOrderReversed: this.isWindingOrderReversed(),
            framebuffer: this.getFramebuffer(),
            viewport: this.getViewport(),
            scissor: this.getScissor(),
            program: this.getProgram(),
            renderStateSet: this.getRenderStates(),
            vertexLayout: this.getVertexLayout(),
            bindGroups: [
                this.getBindGroup(0),
                this.getBindGroup(1),
                this.getBindGroup(2),
                this.getBindGroup(3)
            ]
        });
    }
    popDeviceStates() {
        if (this._stateStack.length === 0) {
            console.error('Device.popDeviceStates(): stack is empty');
        } else {
            const top = this._stateStack.pop();
            this.setFramebuffer(top.framebuffer);
            this.setViewport(top.viewport);
            this.setScissor(top.scissor);
            this.setProgram(top.program);
            this.setRenderStates(top.renderStateSet);
            this.setVertexLayout(top.vertexLayout);
            this.setBindGroup(0, ...top.bindGroups[0]);
            this.setBindGroup(1, ...top.bindGroups[1]);
            this.setBindGroup(2, ...top.bindGroups[2]);
            this.setBindGroup(3, ...top.bindGroups[3]);
            this.reverseVertexWindingOrder(top.windowOrderReversed);
        }
    }
    getGPUObjects() {
        return this._gpuObjectList;
    }
    getGPUObjectById(uid) {
        for (const list of [
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.buffers,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.programs,
            this._gpuObjectList.vertexArrayObjects
        ]){
            for (const obj of list){
                if (obj.uid === uid) {
                    return obj;
                }
            }
        }
        return null;
    }
    screenToDevice(val) {
        return this.getFramebuffer() ? val : Math.round(val * this.getScale());
    }
    deviceToScreen(val) {
        return this.getFramebuffer() ? val : Math.round(val / this.getScale());
    }
    buildRenderProgram(options) {
        return this._programBuilder.buildRenderProgram(options);
    }
    buildComputeProgram(options) {
        return this._programBuilder.buildComputeProgram(options);
    }
    addGPUObject(obj) {
        const list = this.getGPUObjectList(obj);
        if (list && list.indexOf(obj) < 0) {
            list.push(obj);
            this.dispatchEvent(new DeviceGPUObjectAddedEvent(obj));
        }
    }
    removeGPUObject(obj) {
        const list = this.getGPUObjectList(obj);
        if (list) {
            const index = list.indexOf(obj);
            if (index >= 0) {
                list.splice(index, 1);
                this.dispatchEvent(new DeviceGPUObjectRemovedEvent(obj));
            }
        }
    }
    updateVideoMemoryCost(delta) {
        this._gpuMemCost += delta;
    }
    _onresize() {
        if (this._canvasClientWidth !== this._canvas.clientWidth || this._canvasClientHeight !== this._canvas.clientHeight) {
            this._canvasClientWidth = this._canvas.clientWidth;
            this._canvasClientHeight = this._canvas.clientHeight;
            this.dispatchEvent(new DeviceResizeEvent(this._canvasClientWidth, this._canvasClientHeight));
        }
    }
    _registerEventHandlers() {
        const canvas = this._canvas;
        const that = this;
        if (window.ResizeObserver) {
            new window.ResizeObserver((entries)=>{
                that._onresize();
            }).observe(canvas, {});
        } else {
            if (window.MutationObserver) {
                new MutationObserver(function(mutations) {
                    if (mutations.length > 0) {
                        that._onresize();
                    }
                }).observe(canvas, {
                    attributes: true,
                    attributeFilter: [
                        'style'
                    ]
                });
            }
            window.addEventListener('resize', ()=>{
                this._onresize();
            });
        }
    }
    updateFrameInfo() {
        this._frameInfo.frameCounter++;
        this._frameInfo.drawCalls = 0;
        this._frameInfo.computeCalls = 0;
        const now = this._beginFrameTime;
        if (this._frameInfo.frameTimestamp === 0) {
            this._frameInfo.frameTimestamp = now;
            this._frameInfo.elapsedTimeCPU = 0;
            this._frameInfo.elapsedTimeGPU = 0;
            this._frameInfo.elapsedFrame = 0;
            this._frameInfo.elapsedOverall = 0;
            this._frameInfo.FPS = 0;
            this._fpsCounter.time = now;
            this._fpsCounter.frame = this._frameInfo.frameCounter;
            if (this._gpuTimer) {
                this._gpuTimer.begin();
            }
        } else {
            this._frameInfo.elapsedFrame = now - this._frameInfo.frameTimestamp;
            this._frameInfo.elapsedOverall += this._frameInfo.elapsedFrame;
            let gpuTime = 0;
            let cpuTime = 0;
            if (this._endFrameTime !== 0) {
                gpuTime = now - this._endFrameTime;
                cpuTime = this._endFrameTime - this._frameInfo.frameTimestamp;
            }
            this._frameInfo.frameTimestamp = now;
            if (now >= this._fpsCounter.time + 1000) {
                this._frameInfo.FPS = (this._frameInfo.frameCounter - this._fpsCounter.frame) * 1000 / (now - this._fpsCounter.time);
                this._fpsCounter.time = now;
                this._fpsCounter.frame = this._frameInfo.frameCounter;
                this._frameInfo.elapsedTimeGPU = gpuTime;
                this._frameInfo.elapsedTimeCPU = cpuTime;
            }
        }
        const tmp = this._frameInfo.nextFrameCall;
        this._frameInfo.nextFrameCall = this._frameInfo.nextFrameCallNext;
        this._frameInfo.nextFrameCallNext = tmp;
        for (const f of this._frameInfo.nextFrameCallNext){
            f();
        }
        this._frameInfo.nextFrameCallNext.length = 0;
    }
    getGPUObjectList(obj) {
        let list = null;
        if (obj.isTexture()) {
            list = this._gpuObjectList.textures;
        } else if (obj.isSampler()) {
            list = this._gpuObjectList.samplers;
        } else if (obj.isBuffer()) {
            list = this._gpuObjectList.buffers;
        } else if (obj.isFramebuffer()) {
            list = this._gpuObjectList.framebuffers;
        } else if (obj.isProgram()) {
            list = this._gpuObjectList.programs;
        } else if (obj.isVertexLayout()) {
            list = this._gpuObjectList.vertexArrayObjects;
        } else if (obj.isBindGroup()) {
            list = this._gpuObjectList.bindGroups;
        }
        return list;
    }
    invalidateAll() {
        for (const list of [
            this._gpuObjectList.buffers,
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.programs,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.vertexArrayObjects,
            this._gpuObjectList.bindGroups
        ]){
            for (const obj of list){
                this.disposeObject(obj, false);
            }
        }
        if (this.isContextLost()) {
            for (const obj of this._disposeObjectList){
                obj.destroy();
            }
            this._disposeObjectList = [];
        }
    }
    async reloadAll() {
        const promises = [];
        for (const list of [
            this._gpuObjectList.buffers,
            this._gpuObjectList.textures,
            this._gpuObjectList.samplers,
            this._gpuObjectList.programs,
            this._gpuObjectList.framebuffers,
            this._gpuObjectList.vertexArrayObjects,
            this._gpuObjectList.bindGroups
        ]){
            // obj.reload() may change the list, so make a copy first
            for (const obj of list.slice()){
                promises.push(obj.reload());
            }
        }
        Promise.all(promises);
        return;
    }
    parseTextureOptions(options) {
        const noMipmapFlag = options?.samplerOptions?.mipFilter === 'none' ? GPUResourceUsageFlags.TF_NO_MIPMAP : 0;
        const writableFlag = options?.writable ? GPUResourceUsageFlags.TF_WRITABLE : 0;
        const dynamicFlag = options?.dynamic ? GPUResourceUsageFlags.DYNAMIC : 0;
        return noMipmapFlag | writableFlag | dynamicFlag;
    }
    parseBufferOptions(options, defaultUsage) {
        const usage = options?.usage || defaultUsage;
        let usageFlag;
        switch(usage){
            case 'uniform':
                usageFlag = GPUResourceUsageFlags.BF_UNIFORM;
                options.managed = false;
                options.dynamic = options.dynamic ?? true;
                break;
            case 'vertex':
                usageFlag = GPUResourceUsageFlags.BF_VERTEX;
                break;
            case 'index':
                usageFlag = GPUResourceUsageFlags.BF_INDEX;
                break;
            case 'read':
                usageFlag = GPUResourceUsageFlags.BF_READ;
                options.managed = false;
                break;
            case 'write':
                usageFlag = GPUResourceUsageFlags.BF_WRITE;
                options.managed = false;
                break;
            default:
                usageFlag = 0;
                break;
        }
        const storageFlag = options?.storage ?? false ? GPUResourceUsageFlags.BF_STORAGE : 0;
        const dynamicFlag = options?.dynamic ?? false ? GPUResourceUsageFlags.DYNAMIC : 0;
        const managedFlag = dynamicFlag === 0 && (options?.managed ?? true) ? GPUResourceUsageFlags.MANAGED : 0;
        return usageFlag | storageFlag | dynamicFlag | managedFlag;
    }
}

/**
 * Structured buffer data
 * @public
 */ class StructuredBufferData {
    /** @internal */ _cache;
    /** @internal */ _buffer;
    /** @internal */ _size;
    /** @internal */ _uniformMap;
    /** @internal */ _uniformPositions;
    /**
   * Creates a new structured buffer data
   * @param layout - Layout of the structure
   * @param buffer - Buffer that holds the data
   */ constructor(layout, buffer){
        this._size = layout.byteSize + 15 & ~15;
        if (this._size <= 0) {
            throw new Error(`UniformBuffer(): invalid uniform buffer byte size: ${this._size}`);
        }
        // this._cache = new ArrayBuffer(size);
        this._uniformMap = {};
        this._uniformPositions = {};
        this._cache = buffer instanceof ArrayBuffer ? buffer : null;
        this._buffer = buffer instanceof ArrayBuffer ? null : buffer;
        this.init(layout, 0, '');
    }
    /** The buffer size in bytes */ get byteLength() {
        return this._size;
    }
    /** Get the data cache buffer */ get buffer() {
        return this._cache;
    }
    /** Get all the uniform datas */ get uniforms() {
        return this._uniformMap;
    }
    /**
   * Sets the value of a structure member
   * @param name - Name of the member
   * @param value - Value to set
   */ set(name, value) {
        if (value !== undefined) {
            const view = this._uniformMap[name];
            if (view) {
                if (this._cache) {
                    if (typeof value === 'number') {
                        view[0] = value;
                    } else if (value?._v) {
                        view.set(value._v);
                    } else if (typeof value?.length === 'number') {
                        view.set(value);
                    } else {
                        throw new Error('invalid uniform value');
                    }
                } else {
                    const size = this._uniformPositions[name][1];
                    if (typeof value === 'number') {
                        view[0] = value;
                        this._buffer.bufferSubData(this._uniformPositions[name][0], view);
                    } else if (value['BYTES_PER_ELEMENT'] && size <= value['byteLength']) {
                        const arr = value;
                        this._buffer.bufferSubData(this._uniformPositions[name][0], arr, 0, size / arr.BYTES_PER_ELEMENT >> 0);
                    } else {
                        throw new Error('invalid uniform value');
                    }
                }
            } else {
                const proto = Object.getPrototypeOf(value);
                if (proto === Object.getPrototypeOf({})) {
                    this.setStruct(name, value);
                } else {
                    throw new Error('invalid uniform value');
                }
            }
        }
    }
    /** @internal */ setStruct(name, value) {
        for(const k in value){
            this.set(`${name}.${k}`, value[k]);
        }
    }
    /** @internal */ init(layout, offset, prefix) {
        for (const entry of layout.entries){
            if (entry.subLayout) {
                offset = this.init(entry.subLayout, offset, `${prefix}${entry.name}.`);
            } else {
                const name = `${prefix}${entry.name}`;
                if (this._uniformPositions[name]) {
                    throw new Error(`UniformBuffer(): duplicate uniform name: ${name}`);
                }
                if (entry.offset < offset || entry.byteSize < 0) {
                    throw new Error('UniformBuffer(): invalid layout');
                }
                this._uniformPositions[name] = [
                    entry.offset,
                    entry.byteSize
                ];
                let viewCtor = null;
                switch(entry.type){
                    case PBPrimitiveType.F32:
                        viewCtor = Float32Array;
                        break;
                    case PBPrimitiveType.U32:
                    case PBPrimitiveType.BOOL:
                        viewCtor = Uint32Array;
                        break;
                    case PBPrimitiveType.I32:
                        viewCtor = Int32Array;
                        break;
                    case PBPrimitiveType.U16:
                    case PBPrimitiveType.U16_NORM:
                    case PBPrimitiveType.F16:
                        viewCtor = Uint16Array;
                        break;
                    case PBPrimitiveType.I16:
                    case PBPrimitiveType.I16_NORM:
                        viewCtor = Int16Array;
                        break;
                    case PBPrimitiveType.U8:
                    case PBPrimitiveType.U8_NORM:
                        viewCtor = Uint8Array;
                        break;
                    case PBPrimitiveType.I8:
                    case PBPrimitiveType.I8_NORM:
                        viewCtor = Int8Array;
                        break;
                }
                if (!viewCtor) {
                    throw new Error(`UniformBuffer(): invalid data type for uniform: ${name}`);
                }
                if (entry.byteSize % viewCtor.BYTES_PER_ELEMENT) {
                    throw new Error(`UniformBuffer(): invalid byte size for uniform: ${name}`);
                }
                if (this._cache) {
                    this._uniformMap[name] = new viewCtor(this._cache, entry.offset, entry.byteSize / viewCtor.BYTES_PER_ELEMENT);
                } else {
                    this._uniformMap[name] = new viewCtor(1);
                }
                offset = entry.offset + entry.byteSize;
            }
        }
        return offset;
    }
}

/**
 * Decodes a float that was encoded into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param value - The rgba8unorm to be decoded
 * @returns The decoded float value
 *
 * @public
 */ function decodeNormalizedFloatFromRGBA(scope, value) {
    const pb = scope.$builder;
    if (!value || !value.$typeinfo.isPrimitiveType() || value.$typeinfo.primitiveType !== PBPrimitiveType.F32VEC4) {
        throw new Error('decodeNormalizedFloatFromRGBA() failed: parameter type must be vec4');
    }
    if (!scope || !(scope instanceof PBInsideFunctionScope)) {
        throw new Error('decodeNormalizedFloatFromRGBA() failed: decodeNormalizedFloatFromRGBA() must be called inside a function');
    }
    const funcName = 'Z_decodeNormalizedFloatFromRGBA';
    pb.func(funcName, [
        pb.vec4('value')
    ], function() {
        this.$l.bitShift = pb.vec4(1 / (256 * 256 * 256), 1 / (256 * 256), 1 / 256, 1);
        this.$return(pb.dot(this.value, this.bitShift));
    });
    return scope[funcName](value);
}
/**
 * Encodes a float into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param value - The float value to be encode
 * @returns The encoded rgba8unorm
 *
 * @public
 */ function encodeNormalizedFloatToRGBA(scope, value) {
    const pb = scope.$builder;
    const funcName = 'Z_encodeNormalizedFloatToRGBA';
    pb.func(funcName, [
        pb.float('value')
    ], function() {
        this.$l.bitShift = pb.vec4(256 * 256 * 256, 256 * 256, 256, 1);
        this.$l.bitMask = pb.vec4(0, 1 / 256, 1 / 256, 1 / 256);
        this.$l.t = pb.fract(pb.mul(this.value, this.bitShift));
        this.$return(pb.sub(this.t, pb.mul(this.t.xxyz, this.bitMask)));
    });
    return pb.getGlobalScope()[funcName](value);
}
/**
 * Encodes two half floats into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param a - The first half float to be encode
 * @param b - The second half float to be encode
 * @returns The encoded rgba8unorm
 *
 * @public
 */ function encode2HalfToRGBA(scope, a, b) {
    const pb = scope.$builder;
    const funcName = 'Z_encode2HalfToRGBA';
    pb.func(funcName, [
        pb.float('a'),
        pb.float('b')
    ], function() {
        this.$l.t = pb.vec4(this.a, pb.fract(pb.mul(this.a, 255)), this.b, pb.fract(pb.mul(this.b, 255)));
        this.$return(pb.vec4(pb.sub(this.t.x, pb.div(this.t.y, 255)), this.t.y, pb.sub(this.t.z, pb.div(this.t.w, 255)), this.t.w));
    });
    return pb.getGlobalScope()[funcName](a, b);
}
/**
 * Decodes two half floats that was encoded into a rgba8unorm
 *
 * @param scope - Current shader scope
 * @param value - The rgba8unorm to be decoded
 * @returns A vec2 that contains the two half floats
 *
 * @public
 */ function decode2HalfFromRGBA(scope, value) {
    const pb = scope.$builder;
    const funcName = 'Z_decode2HalfFromRGBA';
    pb.func(funcName, [
        pb.vec4('value')
    ], function() {
        this.$return(pb.vec2(pb.add(this.value.x, pb.div(this.value.y, 255)), pb.add(this.value.z, pb.div(this.value.w, 255))));
    });
    return pb.getGlobalScope()[funcName](value);
}
/**
 * Converts a vec3 color from linear space to gamma space
 *
 * @param scope - Current shader scope
 * @param color - The vec3 color to be converted
 * @returns The gamma space vec3 color
 *
 * @public
 */ function linearToGamma(scope, color) {
    const pb = scope.$builder;
    const funcName = 'Z_linearToGamma';
    pb.func(funcName, [
        pb.vec3('color')
    ], function() {
        // Almost perfect version from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
        // C_srgb_2 = max(1.055 * pow(C_lin, 0.416666667) - 0.055, 0);
        this.$return(pb.max(pb.sub(pb.mul(pb.pow(this.color, pb.vec3(0.416666667)), 1.055), pb.vec3(0.055)), pb.vec3(0)));
    });
    return pb.getGlobalScope()[funcName](color);
}

[
    [
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0),
        new Vector3(1, 0, 0)
    ],
    [
        new Vector3(0, 0, 1),
        new Vector3(0, -1, 0),
        new Vector3(-1, 0, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, 1)
    ],
    [
        new Vector3(-1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, -1)
    ]
];

/**
 * Primitive contains only the vertex and index data of a mesh
 * @public
 */ class Primitive {
    /** @internal */ _vertexLayout;
    /** @internal */ _vertexLayoutOptions;
    /** @internal */ _primitiveType;
    /** @internal */ _indexStart;
    /** @internal */ _indexCount;
    /** @internal */ _defaultIndexCount;
    /** @internal */ _vertexLayoutDirty;
    /** @internal */ static _nextId = 0;
    /** @internal */ _id;
    /** @internal */ _bbox;
    /** @internal */ _bboxChangeCallback;
    /**
   * Creates an instance of a primitive
   */ constructor(){
        this._vertexLayout = null;
        this._vertexLayoutOptions = {
            vertexBuffers: []
        };
        this._primitiveType = 'triangle-list';
        this._indexStart = 0;
        this._indexCount = null;
        this._defaultIndexCount = 0;
        this._vertexLayoutDirty = false;
        this._id = ++Primitive._nextId;
        this._bbox = null;
        this._bboxChangeCallback = [];
    }
    /**
   * Unique identifier of the primitive
   * @internal
   */ get id() {
        return this._id;
    }
    /**
   * Adds a callback function that will be called whenever the bounding box of the primitive changes.
   * @param cb - The callback function
   *
   * @internal
   */ addBoundingboxChangeCallback(cb) {
        cb && this._bboxChangeCallback.push(cb);
    }
    /**
   * Removes a callback function for bounding box changing
   * @param cb - The callback function to be removed
   */ removeBoundingboxChangeCallback(cb) {
        const index = this._bboxChangeCallback.indexOf(cb);
        if (index >= 0) {
            this._bboxChangeCallback.splice(index, 1);
        }
    }
    /** Primitive type */ get primitiveType() {
        return this._primitiveType;
    }
    set primitiveType(type) {
        this._primitiveType = type;
    }
    /** Start index for drawing */ get indexStart() {
        return this._indexStart;
    }
    set indexStart(val) {
        this._indexStart = val;
    }
    /** The number of the indices or vertices to be drawn */ get indexCount() {
        this._indexCount = this._indexCount ?? this.calcDefaultIndexCount();
        return this._indexCount;
    }
    set indexCount(val) {
        this._indexCount = val;
    }
    /**
   * Query total vertex count
   * @returns Total vertex count, 0 if no position vertex buffer set
   */ getNumVertices() {
        const posInfo = this.getVertexBufferInfo('position');
        return posInfo?.buffer ? posInfo.buffer.byteLength / posInfo.stride >> 0 : 0;
    }
    /**
   * Query total face count
   * @returns Total face count
   */ getNumFaces() {
        const ib = this.getIndexBuffer();
        const count = ib ? ib.byteLength >> (ib.indexType.primitiveType === PBPrimitiveType.U16 ? 1 : 2) : this.getNumVertices();
        switch(this.primitiveType){
            case 'line-list':
                return count >> 1;
            case 'point-list':
                return count;
            case 'line-strip':
                return count - 1;
            case 'triangle-fan':
                return count - 2;
            case 'triangle-strip':
                return count - 2;
            case 'triangle-list':
                return count / 3 >> 0;
            default:
                return 0;
        }
    }
    /**
   * Removes a vertex buffer from the primitive
   * @param buffer - The vertex buffer to be removed
   */ removeVertexBuffer(buffer) {
        for(let loc = 0; loc < this._vertexLayoutOptions.vertexBuffers.length; loc++){
            const info = this._vertexLayoutOptions.vertexBuffers[loc];
            if (info?.buffer === buffer) {
                info[loc] = null;
                this._vertexLayoutDirty = true;
            }
        }
    }
    /**
   * Gets the vertex buffer by a given semantic
   * @param semantic - The semantic of the vertex buffer
   * @returns The vertex buffer which semantic matches the given value
   */ getVertexBuffer(semantic) {
        this.checkVertexLayout();
        return this._vertexLayout.getVertexBuffer(semantic);
    }
    /**
   * Gets the vertex buffer information by a given semantic
   * @param semantic - The semantic of the vertex buffer
   * @returns The vertex buffer information of the given semantic
   */ getVertexBufferInfo(semantic) {
        this.checkVertexLayout();
        return this._vertexLayout.getVertexBufferInfo(semantic);
    }
    /**
   * Creates a vertex buffer from the given options and then adds it to the primitive
   * @param format - Vertex format for the vertex buffer
   * @param data - Contents of the vertex buffer
   * @param stepMode - Step mode of the vertex buffer
   * @returns The created vertex buffer
   */ createAndSetVertexBuffer(format, data, stepMode) {
        const buffer = Application.instance.device.createVertexBuffer(format, data);
        return this.setVertexBuffer(buffer, stepMode);
    }
    /**
   * Adds a vertex buffer to the primitive
   * @param buffer - The vertex buffer to be added
   * @param stepMode - Step mode of the vertex buffer
   * @returns The added vertex buffer
   */ setVertexBuffer(buffer, stepMode) {
        this._vertexLayoutOptions.vertexBuffers.push({
            buffer,
            stepMode
        });
        this._vertexLayoutDirty = true;
        return buffer;
    }
    /**
   * Creates an index buffer from the given options and then adds it to the prmitive
   * @param data - Contents of the index buffer
   * @param dynamic - true if the index buffer is dynamic
   * @returns The created index buffer
   */ createAndSetIndexBuffer(data, dynamic) {
        const buffer = Application.instance.device.createIndexBuffer(data, {
            dynamic: !!dynamic,
            managed: !dynamic
        });
        this.setIndexBuffer(buffer);
        return buffer;
    }
    /**
   * Adds an index buffer to the primitive
   * @param buffer - The index buffer to be added
   */ setIndexBuffer(buffer) {
        if (this._vertexLayoutOptions.indexBuffer !== buffer) {
            this._vertexLayoutOptions.indexBuffer = buffer;
            this._vertexLayoutDirty = true;
        }
    }
    /**
   * Gets the index buffer of the primitive
   * @returns The index buffer of the primitive
   */ getIndexBuffer() {
        return this._vertexLayoutOptions.indexBuffer;
    }
    /**
   * Draw the prmitive
   */ draw() {
        this.checkVertexLayout();
        if (this.indexCount > 0) {
            this._vertexLayout?.draw(this._primitiveType, this._indexStart, this.indexCount);
        }
    }
    /**
   * Draw multiple instances of the primitive
   * @param numInstances - How many instances of the primitive should be drawn
   */ drawInstanced(numInstances) {
        this.checkVertexLayout();
        if (this.indexCount > 0) {
            this._vertexLayout?.drawInstanced(this._primitiveType, this._indexStart, this.indexCount, numInstances);
        }
    }
    /**
   * Disposes the primitive
   *
   * @remarks
   * The vertex buffers and index buffer will also be disposed.
   * To prevent specific vertex buffer or index buffer to be disposed,
   * call removeVertexBuffer() or setIndexBuffer(null) first.
   */ dispose() {
        if (this._vertexLayout) {
            const vertexBuffers = this._vertexLayout.vertexBuffers;
            for(const k in vertexBuffers){
                vertexBuffers[k]?.buffer?.dispose();
            }
            this._vertexLayout.indexBuffer?.dispose();
            this._vertexLayout.dispose();
            this._vertexLayout = null;
        }
        this._indexCount = null;
        this._indexStart = 0;
    }
    /*
  createAABBTree(): AABBTree {
    const indices = this.getIndexBuffer() ? this.getIndexBuffer().getData() : null;
    const vertices = (this.getVertexBuffer(VERTEX_ATTRIB_POSITION)?.getData() as Float32Array) || null;
    const aabbtree = new AABBTree();
    aabbtree.buildFromPrimitives(vertices, indices, this._primitiveType);
    return aabbtree;
  }
  */ /**
   * Gets the bounding volume of the primitive
   * @returns The bounding volume of the primitive, or null if no bounding volume set
   */ getBoundingVolume() {
        return this._bbox;
    }
    /**
   * Sets the bounding volume of the primitive
   * @param bv - The bounding volume to be set
   */ setBoundingVolume(bv) {
        if (bv !== this._bbox) {
            this._bbox = bv;
            for (const cb of this._bboxChangeCallback){
                cb();
            }
        }
    }
    /**
   * Ray intersection test
   * @param ray - Ray object used to do intersection test with this object
   * @returns The distance from ray origin to the intersection point if ray intersects with this object, otherwise null
   */ raycast(ray) {
        const aabb = this.getBoundingVolume()?.toAABB();
        return aabb ? ray.bboxIntersectionTestEx(aabb) : null;
    }
    /** @internal */ checkVertexLayout() {
        if (this._vertexLayoutDirty) {
            this._vertexLayout?.dispose();
            this._vertexLayout = Application.instance.device.createVertexLayout(this._vertexLayoutOptions);
            this._vertexLayoutDirty = false;
        }
    }
    /** @internal */ calcDefaultIndexCount() {
        const indexBuffer = this.getIndexBuffer();
        if (indexBuffer) {
            return Math.max(0, indexBuffer.length - this._indexStart);
        }
        const info = this.getVertexBufferInfo('position');
        if (info) {
            return Math.max(0, Math.floor((info.buffer.byteLength - info.drawOffset) / info.stride) - this._indexStart);
        }
        return 0;
    }
}

/**
 * Base class for any kind of blitters
 * @public
 */ class Blitter {
    /** @internal */ _hash;
    /** @internal */ _renderStates;
    /** @internal */ _srgbOut;
    /** @internal */ _flip;
    /** @internal */ _viewport;
    /** @internal */ _scissor;
    /** @internal */ _destRect;
    /** @internal */ _offsetParams;
    /**
   * Creates an instance of Blitter
   */ constructor(){
        this._hash = null;
        this._renderStates = null;
        this._srgbOut = false;
        this._flip = false;
        this._viewport = null;
        this._scissor = null;
        this._destRect = null;
        this._offsetParams = new Vector4();
    }
    /** Viewport */ get viewport() {
        return this._viewport;
    }
    set viewport(val) {
        this._viewport = val ?? null;
    }
    /** Scissor rect */ get scissor() {
        return this._scissor;
    }
    set scissor(val) {
        this._scissor = val ?? null;
    }
    /** Destination rectangle */ get destRect() {
        return this._destRect;
    }
    set destRect(val) {
        if (!!this._destRect !== !!val) {
            this.invalidateHash();
        }
        this._destRect = val ?? null;
    }
    /**
   * Whether output color value in gamma color space
   */ get srgbOut() {
        return this._srgbOut;
    }
    set srgbOut(val) {
        if (this._srgbOut !== !!val) {
            this._srgbOut = !!val;
            this.invalidateHash();
        }
    }
    /**
   * Render states used to do the blitting
   */ get renderStates() {
        return this._renderStates;
    }
    set renderStates(rs) {
        this._renderStates = rs;
    }
    /**
   * Program hash code
   */ get hash() {
        if (!this._hash) {
            this._hash = `${this.constructor.name}:${this._srgbOut ? 1 : 0}:${this._flip ? 1 : 0}:${this._destRect ? 1 : 0}:${this.calcHash()}`;
        }
        return this._hash;
    }
    /**
   * Force the hash code to be regenerated
   */ invalidateHash() {
        this._hash = null;
    }
    /**
   * Reads a texel from the source texture
   * @param scope - The shader scope
   * @param type - The blit type
   * @param srcTex - The source texture
   * @param uv - The texture coordinate from where the texel will be read
   * @param srcLayer - The layer of the source texture
   * @returns The read texel
   */ readTexel(scope, type, srcTex, uv, srcLayer, sampleType) {
        const pb = scope.$builder;
        if (sampleType === 'float') {
            switch(type){
                case '2d':
                case 'cube':
                    return Application.instance.device.getDeviceCaps().shaderCaps.supportShaderTextureLod ? pb.textureSampleLevel(srcTex, uv, 0) : pb.textureSample(srcTex, uv);
                case '2d-array':
                    return pb.textureArraySampleLevel(srcTex, uv, srcLayer, 0);
                default:
                    return null;
            }
        } else {
            switch(type){
                case '2d':
                    return pb.textureLoad(srcTex, pb.ivec2(pb.mul(pb.vec2(pb.textureDimensions(srcTex, 0)), uv)), 0);
                case 'cube':
                    throw new Error('Integer format cube texture not supported');
                case '2d-array':
                    return pb.textureArrayLoad(srcTex, pb.ivec2(pb.mul(pb.vec2(pb.textureDimensions(srcTex, 0)), uv)), srcLayer, 0);
                default:
                    return null;
            }
        }
    }
    /**
   * Writes a texel to destination texture
   * @param scope - The shader scope
   * @param type - The blit type
   * @param uv - The texture coordinate to where the texel will be written
   * @param texel - The texel to be written
   * @returns The written texel
   */ writeTexel(scope, type, uv, texel) {
        return texel;
    }
    /**
   * Initialize uniforms of the blit program
   * @param scope - The shader scope
   * @param type - The blit type
   */ setup(scope, type) {}
    /**
   * Update uniforms of the bind group
   * @param bindGroup - The bind group to be updated
   */ setUniforms(bindGroup, sourceTex) {}
    /** @internal */ blit2D(source, dest, sampler) {
        const device = Application.instance.device;
        const flip = !dest && device.type === 'webgpu';
        const bilinearFiltering = sampler ? sampler.magFilter === 'linear' || sampler.minFilter === 'linear' || sampler.mipFilter === 'linear' : source.isFilterable();
        const programInfo = getBlitProgram('2d', this, bilinearFiltering, source.isIntegerFormat() ? source.isSignedFormat() ? 'int' : 'uint' : 'float', flip);
        programInfo.bindGroup.setTexture('srcTex', source, sampler);
        if (this._destRect) {
            const destWidth = this._viewport?.[2] ?? dest?.getWidth() ?? device.getBackBufferWidth();
            const destHeight = this._viewport?.[3] ?? dest?.getHeight() ?? device.getBackBufferHeight();
            this._offsetParams.setXYZW(this._destRect[2] / destWidth, this._destRect[3] / destHeight, (this._destRect[2] + 2 * this._destRect[0]) / destWidth - 1, (this._destRect[3] + 2 * this._destRect[1]) / destHeight - 1);
            programInfo.bindGroup.setValue('scaleBias', this._offsetParams);
        }
        this.setUniforms(programInfo.bindGroup, source);
        device.setFramebuffer(dest ?? null);
        device.setViewport(this._viewport);
        device.setScissor(this._scissor);
        device.setProgram(programInfo.program);
        device.setBindGroup(0, programInfo.bindGroup);
        device.setRenderStates(this._renderStates ?? getBlitRenderStateSet());
        getBlitPrimitive2D().draw();
    }
    /** @internal */ blit2DArray(source, dest, layer, sampler) {
        const device = Application.instance.device;
        const flip = !dest && device.type === 'webgpu';
        const bilinearFiltering = sampler ? sampler.magFilter === 'linear' || sampler.minFilter === 'linear' || sampler.mipFilter === 'linear' : source.isFilterable();
        const programInfo = getBlitProgram('2d-array', this, bilinearFiltering, source.isIntegerFormat() ? source.isSignedFormat() ? 'int' : 'uint' : 'float', flip);
        programInfo.bindGroup.setTexture('srcTex', source, sampler);
        programInfo.bindGroup.setValue('srcLayer', layer);
        this.setUniforms(programInfo.bindGroup, source);
        device.setFramebuffer(dest ?? null);
        device.setViewport(this._viewport);
        device.setScissor(this._scissor);
        device.setProgram(programInfo.program);
        device.setBindGroup(0, programInfo.bindGroup);
        device.setRenderStates(this._renderStates ?? getBlitRenderStateSet());
        getBlitPrimitive2D().draw();
    }
    /** @internal */ blitCubeMap(source, dest, face, sampler) {
        const device = Application.instance.device;
        const flip = !dest && device.type === 'webgpu';
        const bilinearFiltering = sampler ? sampler.magFilter === 'linear' || sampler.minFilter === 'linear' || sampler.mipFilter === 'linear' : source.isFilterable();
        const programInfo = getBlitProgram('cube', this, bilinearFiltering, source.isIntegerFormat() ? source.isSignedFormat() ? 'int' : 'uint' : 'float', flip);
        programInfo.bindGroup.setTexture('srcTex', source, sampler);
        programInfo.bindGroup.setValue('texelSize', 1 / source.width);
        programInfo.bindGroup.setValue('cubeFace', face);
        this.setUniforms(programInfo.bindGroup, source);
        device.setFramebuffer(dest ?? null);
        device.setViewport(this._viewport);
        device.setScissor(this._scissor);
        device.setProgram(programInfo.program);
        device.setBindGroup(0, programInfo.bindGroup);
        device.setRenderStates(this._renderStates ?? getBlitRenderStateSet());
        getBlitPrimitive2D().draw();
    }
    blit(source, dest, layer, sampler) {
        const device = Application.instance.device;
        device.pushDeviceStates();
        if (!dest) {
            if (source.isTexture2D()) {
                this.blit2D(source, null, sampler);
            } else if (source.isTexture2DArray()) {
                this.blit2DArray(source, null, layer || 0, sampler);
            } else if (source.isTextureCube()) {
                this.blitCubeMap(source, null, layer || 0, sampler);
            } else {
                throw new Error('Blitter.blit() failed: invalid texture type');
            }
        } else {
            const framebuffer = dest.isFramebuffer() ? dest : device.createFrameBuffer([
                dest
            ], null);
            const destTexture = dest.isFramebuffer() ? dest.getColorAttachments()?.[0] : dest;
            if (source.isTexture2D()) {
                if (!destTexture?.isTexture2D() && !destTexture?.isTexture2DArray()) {
                    throw new Error('Blitter.blit() failed: invalid destination texture type');
                }
                if (destTexture.isTexture2DArray()) {
                    framebuffer.setColorAttachmentLayer(0, layer || 0);
                }
                this.blit2D(source, framebuffer, sampler);
            } else if (source.isTexture2DArray()) {
                if (!destTexture?.isTexture2D() && !destTexture.isTexture2DArray()) {
                    throw new Error('Blitter.blit() failed: invalid destination texture type');
                }
                if (destTexture.isTexture2D()) {
                    this.blit2DArray(source, framebuffer, layer || 0, sampler);
                } else {
                    if (destTexture.depth !== source.depth) {
                        throw new Error('Blitter.blit() failed: can not blit between texture 2d arrays with different array size');
                    } else {
                        for(let i = 0; i < source.depth; i++){
                            framebuffer.setColorAttachmentLayer(0, i);
                            this.blit2DArray(source, framebuffer, i, layer);
                        }
                    }
                }
            } else if (source.isTextureCube()) {
                if (!destTexture.isTextureCube() && !destTexture.isTexture2D()) {
                    throw new Error('Blitter.blit() failed: invalid destination texture type');
                }
                if (destTexture.isTextureCube()) {
                    for(let i = 0; i < 6; i++){
                        framebuffer.setColorAttachmentCubeFace(0, i);
                        this.blitCubeMap(source, framebuffer, i, layer);
                    }
                } else {
                    this.blitCubeMap(source, framebuffer, layer || 0, sampler);
                }
            } else {
                throw new Error('Blitter.blit() failed: invalid texture type');
            }
            if (framebuffer && framebuffer !== dest) {
                framebuffer.dispose();
            }
        }
        device.popDeviceStates();
    }
}
const blitProgramCache = {};
let blitPrimitive2D = null;
let blitRenderStates = null;
function getBlitPrimitive2D() {
    if (!blitPrimitive2D) {
        blitPrimitive2D = new Primitive();
        const vb = Application.instance.device.createVertexBuffer('position_f32x2', new Float32Array([
            -1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1
        ]));
        blitPrimitive2D.setVertexBuffer(vb);
        blitPrimitive2D.indexCount = 4;
        blitPrimitive2D.indexStart = 0;
        blitPrimitive2D.primitiveType = 'triangle-strip';
    }
    return blitPrimitive2D;
}
function getBlitRenderStateSet() {
    if (!blitRenderStates) {
        blitRenderStates = Application.instance.device.createRenderStateSet();
        blitRenderStates.useDepthState().enableTest(false).enableWrite(false);
        blitRenderStates.useRasterizerState().setCullMode('none');
    }
    return blitRenderStates;
}
function getBlitProgram(type, filter, bilinearFiltering, sampleType, flip) {
    const hash = `${type}:${filter.hash}:${bilinearFiltering}:${sampleType}:${flip ? 1 : 0}`;
    let programInfo = blitProgramCache[hash];
    if (programInfo === undefined) {
        programInfo = createBlitProgram(type, filter, bilinearFiltering, sampleType, flip, !!filter.destRect) || null;
        blitProgramCache[hash] = programInfo;
    }
    return programInfo;
}
function createBlitProgram(type, filter, bilinearFiltering, st, flip, scaleBias) {
    const program = Application.instance.device.buildRenderProgram({
        vertex (pb) {
            this.$inputs.pos = pb.vec2().attrib('position');
            this.$outputs.uv = pb.vec2();
            if (scaleBias) {
                this.scaleBias = pb.vec4().uniform(0);
            }
            filter.setup(this, type);
            pb.main(function() {
                this.$builtins.position = pb.vec4(this.$inputs.pos, 1, 1);
                this.$outputs.uv = type === 'cube' ? pb.mul(pb.vec2(1, -1), this.$inputs.pos.xy) : pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                if (Application.instance.device.type === 'webgpu') {
                    this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                }
                if (scaleBias) {
                    this.$l.xy = pb.add(pb.mul(this.$builtins.position.xy, this.scaleBias.xy), this.scaleBias.zw);
                    this.$builtins.position = pb.vec4(this.xy, 1, 1);
                }
            });
        },
        fragment (pb) {
            switch(type){
                case '2d':
                    if (st === 'int') {
                        this.srcTex = pb.itex2D().sampleType('sint').uniform(0);
                    } else if (st === 'uint') {
                        this.srcTex = pb.utex2D().sampleType('uint').uniform(0);
                    } else {
                        this.srcTex = pb.tex2D().sampleType(bilinearFiltering ? 'float' : 'unfilterable-float').uniform(0);
                    }
                    break;
                case '2d-array':
                    if (st === 'int') {
                        this.srcTex = pb.itex2DArray().sampleType('sint').uniform(0);
                    } else if (st === 'uint') {
                        this.srcTex = pb.utex2DArray().sampleType('uint').uniform(0);
                    } else {
                        this.srcTex = pb.tex2DArray().sampleType(bilinearFiltering ? 'float' : 'unfilterable-float').uniform(0);
                    }
                    this.srcLayer = pb.int().uniform(0);
                    break;
                case 'cube':
                    if (st === 'int') {
                        this.srcTex = pb.itexCube().sampleType('sint').uniform(0);
                    } else if (st === 'uint') {
                        this.srcTex = pb.utexCube().sampleType('uint').uniform(0);
                    } else {
                        this.srcTex = pb.texCube().sampleType(bilinearFiltering ? 'float' : 'unfilterable-float').uniform(0);
                    }
                    this.texelSize = pb.float().uniform(0);
                    this.cubeFace = pb.int().uniform(0);
                    break;
                default:
                    throw new Error(`invalid blit type: ${type}`);
            }
            this.$outputs.outColor = pb.vec4();
            filter.setup(this, type);
            pb.main(function() {
                if (type === 'cube') {
                    this.uv = pb.vec3();
                    this.$if(pb.equal(this.cubeFace, 0), function() {
                        this.uv = pb.vec3(1, this.$inputs.uv.y, pb.neg(this.$inputs.uv.x));
                    }).$elseif(pb.equal(this.cubeFace, 1), function() {
                        this.uv = pb.vec3(-1, this.$inputs.uv.y, this.$inputs.uv.x);
                    }).$elseif(pb.equal(this.cubeFace, 2), function() {
                        this.uv = pb.vec3(this.$inputs.uv.x, 1, pb.neg(this.$inputs.uv.y));
                    }).$elseif(pb.equal(this.cubeFace, 3), function() {
                        this.uv = pb.vec3(this.$inputs.uv.x, -1, this.$inputs.uv.y);
                    }).$elseif(pb.equal(this.cubeFace, 4), function() {
                        this.uv = pb.vec3(this.$inputs.uv.x, this.$inputs.uv.y, 1);
                    }).$else(function() {
                        this.uv = pb.vec3(pb.neg(this.$inputs.uv.x), this.$inputs.uv.y, -1);
                    });
                } else {
                    this.uv = this.$inputs.uv;
                }
                if (flip) {
                    this.uv.y = pb.sub(1, this.uv.y);
                }
                this.$l.outTexel = filter.filter(this, type, this.srcTex, this.uv, type === '2d' ? null : this.srcLayer, st);
                this.$outputs.outColor = filter.writeTexel(this, type, this.$inputs.uv, this.outTexel);
                if (filter.srgbOut) {
                    this.$outputs.outColor = pb.vec4(linearToGamma(this, this.$outputs.outColor.rgb), this.$outputs.outColor.a);
                }
            });
        }
    });
    return program ? {
        program,
        bindGroup: Application.instance.device.createBindGroup(program.bindGroupLayouts[0])
    } : null;
}

/**
 * Copy blitter
 * @public
 */ class CopyBlitter extends Blitter {
    /**
   * {@inheritDoc Blitter.filter}
   * @override
   */ filter(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        return this.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
    }
    /**
   * {@inheritDoc Blitter.calcHash}
   * @override
   */ calcHash() {
        return '';
    }
}

[
    [
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0),
        new Vector3(1, 0, 0)
    ],
    [
        new Vector3(0, 0, 1),
        new Vector3(0, -1, 0),
        new Vector3(-1, 0, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, 0, -1),
        new Vector3(0, -1, 0)
    ],
    [
        new Vector3(1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, 1)
    ],
    [
        new Vector3(-1, 0, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, -1)
    ]
];

/**
 * The bounding box class
 * @public
 */ class BoundingBox extends AABB {
    constructor(arg0, arg1){
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        super(arg0, arg1);
    }
    /** {@inheritDoc BoundingVolume.behindPlane} */ behindPlane(plane) {
        return this.toAABB().behindPlane(plane);
    }
    /** {@inheritDoc BoundingVolume.clone} */ clone() {
        return new BoundingBox(this);
    }
    /** {@inheritDoc BoundingVolume.transform} */ transform(matrix) {
        return new BoundingBox(AABB.transform(this, matrix));
    }
    /** {@inheritDoc BoundingVolume.outsideFrustum} */ outsideFrustum(frustum) {
        return (frustum instanceof Frustum ? this.getClipStateWithFrustum(frustum) : this.getClipState(frustum)) === ClipState.NOT_CLIPPED;
    }
    /** {@inheritDoc BoundingVolume.toAABB} */ toAABB() {
        return this;
    }
}

/**
 * Abstract base class for any kind of shapes
 * @public
 */ class Shape extends Primitive {
    /** @internal */ _options;
    /**
   * Creates an instance of shape
   * @param options - The creation options
   */ constructor(options){
        super();
        this._options = this.createDefaultOptions();
        this.create(options);
    }
    /**
   * Creation options
   */ get options() {
        return this._options;
    }
    /** @internal */ create(options) {
        if (options) {
            this._options = this.createDefaultOptions();
            Object.assign(this._options, options);
        }
        return this._create();
    }
    /** @internal */ createDefaultOptions() {
        return {
            needNormal: true,
            needTangent: false,
            needUV: true
        };
    }
}

/**
 * Box shape
 * @public
 */ class BoxShape extends Shape {
    /**
   * Creates an instance of box shape
   * @param options - The creation options
   */ constructor(options){
        super(options);
    }
    /** @internal */ createDefaultOptions() {
        const options = super.createDefaultOptions();
        options.size = 1;
        return options;
    }
    /** @internal */ _createArrays(vertices, normals, uvs, indices, minx, miny, minz, maxx, maxy, maxz) {
        const needTangent = this._options.needTangent;
        const needNormal = this._options.needNormal || needTangent;
        const needUV = this._options.needUV;
        const uv = needUV ? [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ] : null;
        const topFacePos = [
            minx,
            maxy,
            minz,
            minx,
            maxy,
            maxz,
            maxx,
            maxy,
            maxz,
            maxx,
            maxy,
            minz
        ];
        const topFacenormal = needNormal ? [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ] : null;
        const frontFacePos = [
            minx,
            maxy,
            maxz,
            minx,
            miny,
            maxz,
            maxx,
            miny,
            maxz,
            maxx,
            maxy,
            maxz
        ];
        const frontFaceNormal = needNormal ? [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ] : null;
        const rightFacePos = [
            maxx,
            maxy,
            maxz,
            maxx,
            miny,
            maxz,
            maxx,
            miny,
            minz,
            maxx,
            maxy,
            minz
        ];
        const rightFaceNormal = needNormal ? [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ] : null;
        const backFacePos = [
            maxx,
            maxy,
            minz,
            maxx,
            miny,
            minz,
            minx,
            miny,
            minz,
            minx,
            maxy,
            minz
        ];
        const backFaceNormal = needNormal ? [
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1
        ] : null;
        const leftFacePos = [
            minx,
            maxy,
            minz,
            minx,
            miny,
            minz,
            minx,
            miny,
            maxz,
            minx,
            maxy,
            maxz
        ];
        const leftFaceNormal = needNormal ? [
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0
        ] : null;
        const bottomFacePos = [
            minx,
            miny,
            maxz,
            minx,
            miny,
            minz,
            maxx,
            miny,
            minz,
            maxx,
            miny,
            maxz
        ];
        const bottomFaceNormal = needNormal ? [
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0,
            0,
            -1,
            0
        ] : null;
        indices && indices.push(0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23);
        vertices && vertices.push(...topFacePos, ...frontFacePos, ...rightFacePos, ...backFacePos, ...leftFacePos, ...bottomFacePos);
        needNormal && normals && normals.push(...topFacenormal, ...frontFaceNormal, ...rightFaceNormal, ...backFaceNormal, ...leftFaceNormal, ...bottomFaceNormal);
        needUV && uvs && uvs.push(...uv, ...uv, ...uv, ...uv, ...uv, ...uv);
        this.primitiveType = 'triangle-list';
    }
    /** Box width */ get width() {
        return this._options.sizeX ?? this._options.size ?? 1;
    }
    /** Box height */ get height() {
        return this._options.sizeY ?? this._options.size ?? 1;
    }
    /** Box depth */ get depth() {
        return this._options.sizeZ ?? this._options.size ?? 1;
    }
    /** @internal */ _create() {
        const needNormal = this._options.needNormal;
        const needUV = this._options.needUV;
        const sizeX = this._options.sizeX ?? this._options.size ?? 1;
        const sizeY = this._options.sizeY ?? this._options.size ?? 1;
        const sizeZ = this._options.sizeZ ?? this._options.size ?? 1;
        const anchorX = 0.5;
        const anchorY = 0.5;
        const anchorZ = 0.5;
        const minx = -anchorX * sizeX;
        const maxx = minx + sizeX;
        const miny = -anchorY * sizeY;
        const maxy = miny + sizeY;
        const minz = -anchorZ * sizeZ;
        const maxz = minz + sizeZ;
        const vertices = [];
        const indices = [];
        const normals = needNormal ? [] : null;
        const uvs = needUV ? [] : null;
        this._createArrays(vertices, normals, uvs, indices, minx, miny, minz, maxx, maxy, maxz);
        this.createAndSetVertexBuffer('position_f32x3', new Float32Array(vertices));
        normals && this.createAndSetVertexBuffer('normal_f32x3', new Float32Array(normals));
        uvs && this.createAndSetVertexBuffer('tex0_f32x2', new Float32Array(uvs));
        this.createAndSetIndexBuffer(new Uint16Array(indices));
        this.setBoundingVolume(new BoundingBox(new Vector3(minx, miny, minz), new Vector3(maxx, maxy, maxz)));
        this.indexCount = indices.length;
        return true;
    }
}
/**
 * Wireframe box shape
 * @public
 */ class BoxFrameShape extends Shape {
    /**
   * Creates an instance of wireframe box shape
   * @param options - The creation options
   */ constructor(options){
        super(options);
    }
    /** @internal */ createDefaultOptions() {
        const options = super.createDefaultOptions();
        options.size = 1;
        options.needNormal = false;
        options.needTangent = false;
        options.needUV = false;
        return options;
    }
    /** @internal */ _createArrays(vertices, indices, minx, miny, minz, maxx, maxy, maxz) {
        const topFacePos = [
            minx,
            maxy,
            minz,
            minx,
            maxy,
            maxz,
            maxx,
            maxy,
            maxz,
            maxx,
            maxy,
            minz
        ];
        const bottomFacePos = [
            minx,
            miny,
            maxz,
            minx,
            miny,
            minz,
            maxx,
            miny,
            minz,
            maxx,
            miny,
            maxz
        ];
        indices && indices.push(0, 1, 1, 2, 2, 3, 3, 0, 0, 5, 1, 4, 2, 7, 3, 6, 6, 5, 5, 4, 4, 7, 7, 6);
        vertices && vertices.push(...topFacePos, ...bottomFacePos);
        this.primitiveType = 'line-list';
    }
    /** @internal */ _create() {
        const sizeX = this._options.sizeX ?? this._options.size ?? 1;
        const sizeY = this._options.sizeY ?? this._options.size ?? 1;
        const sizeZ = this._options.sizeZ ?? this._options.size ?? 1;
        const anchorX = 0.5;
        const anchorY = 0.5;
        const anchorZ = 0.5;
        const minx = -anchorX * sizeX;
        const maxx = minx + sizeX;
        const miny = -anchorY * sizeY;
        const maxy = miny + sizeY;
        const minz = -anchorZ * sizeZ;
        const maxz = minz + sizeZ;
        const vertices = [];
        const indices = [];
        this._createArrays(vertices, indices, minx, miny, minz, maxx, maxy, maxz);
        this.createAndSetVertexBuffer('position_f32x3', new Float32Array(vertices));
        this.createAndSetIndexBuffer(new Uint16Array(indices));
        this.setBoundingVolume(new BoundingBox(new Vector3(minx, miny, minz), new Vector3(maxx, maxy, maxz)));
        this.indexCount = indices.length;
        return true;
    }
}

/**
 * Sphere shape
 * @public
 */ class SphereShape extends Shape {
    /**
   * Creates an instance of sphere shape
   * @param options - The creation options
   */ constructor(options){
        super(options);
    }
    /**
   * {@inheritDoc Primitive.raycast}
   * @override
   */ raycast(ray) {
        const rSquared = this._options.radius * this._options.radius;
        const eSquared = Vector3.dot(ray.origin, ray.origin);
        if (eSquared < rSquared) {
            return null;
        }
        const a = -Vector3.dot(ray.origin, ray.direction);
        const bSquared = eSquared - a * a;
        if (rSquared < bSquared) {
            return null;
        }
        return a - Math.sqrt(rSquared - bSquared);
    }
    /** Sphere radius */ get radius() {
        return this._options.radius ?? 1;
    }
    /** @internal */ createDefaultOptions() {
        const options = super.createDefaultOptions();
        options.radius = 1;
        options.verticalDetail = 20;
        options.horizonalDetail = 20;
        return options;
    }
    /** @internal */ _create() {
        function getVertex(v, h, r) {
            const y = r * Math.cos(v);
            const hRadius = r * Math.sin(v);
            const x = hRadius * Math.sin(h);
            const z = hRadius * Math.cos(h);
            return [
                x,
                y,
                z
            ];
        }
        const radius = this._options.radius ?? 1;
        const verticalDetail = this._options.verticalDetail ?? 20;
        const horizonalDetail = this._options.horizonalDetail ?? 20;
        const vTheta = Math.PI / verticalDetail;
        const hTheta = Math.PI * 2 / horizonalDetail;
        const vertices = [];
        const normals = [];
        const uv = [];
        const indices = [];
        for(let i = 0; i <= verticalDetail; i++){
            for(let j = 0; j <= horizonalDetail; j++){
                const v = getVertex(i * vTheta, j * hTheta, radius);
                vertices.push(...v);
                if (this._options.needUV) {
                    uv.push(j / horizonalDetail, i / verticalDetail);
                }
                if (this._options.needNormal) {
                    normals.push(v[0] / radius, v[1] / radius, v[2] / radius);
                }
            }
        }
        for(let i = 0; i < verticalDetail; i++){
            for(let j = 0; j <= horizonalDetail; j++){
                const startIndex = i * (horizonalDetail + 1);
                indices.push(startIndex + j, startIndex + j + horizonalDetail + 1);
            }
            indices.push(indices[indices.length - 1]);
            indices.push((i + 1) * (horizonalDetail + 1));
        }
        this.createAndSetVertexBuffer('position_f32x3', new Float32Array(vertices));
        normals?.length > 0 && this.createAndSetVertexBuffer('normal_f32x3', new Float32Array(normals));
        uv?.length > 0 && this.createAndSetVertexBuffer('tex0_f32x2', new Float32Array(uv));
        this.createAndSetIndexBuffer(new Uint32Array(indices));
        this.setBoundingVolume(new BoundingBox(new Vector3(-radius, -radius, -radius), new Vector3(radius, radius, radius)));
        this.primitiveType = 'triangle-strip';
        this.indexCount = indices.length;
        return true;
    }
}

var OctreePlacement;
(function(OctreePlacement) {
    OctreePlacement[OctreePlacement["PPP"] = 0] = "PPP";
    OctreePlacement[OctreePlacement["PPN"] = 1] = "PPN";
    OctreePlacement[OctreePlacement["PNP"] = 2] = "PNP";
    OctreePlacement[OctreePlacement["PNN"] = 3] = "PNN";
    OctreePlacement[OctreePlacement["NPP"] = 4] = "NPP";
    OctreePlacement[OctreePlacement["NPN"] = 5] = "NPN";
    OctreePlacement[OctreePlacement["NNP"] = 6] = "NNP";
    OctreePlacement[OctreePlacement["NNN"] = 7] = "NNN";
})(OctreePlacement || (OctreePlacement = {}));
/**
 * Octree node
 * @public
 */ class OctreeNode {
    /** @internal */ _chunk;
    /** @internal */ _position;
    /** @internal */ _nodes;
    /** @internal */ _box;
    /** @internal */ _boxLoosed;
    /**
   * Creates an instance of octree node
   */ constructor(){
        this._chunk = null;
        this._position = 0;
        this._nodes = [];
        this._box = null;
        this._boxLoosed = null;
    }
    /**
   * Get all the scene nodes that this octree node contains
   * @returns An array of the scene nodes
   */ getNodes() {
        return this._nodes;
    }
    /**
   * Gets the level index of the octree node
   * @returns The level index
   */ getLevel() {
        return this._chunk.getLevel();
    }
    /**
   * Adds a scene node to this node
   * @param node - The scene node to be added
   */ addNode(node) {
        if (node && this._nodes.indexOf(node) < 0) {
            this._nodes.push(node);
            node.octreeNode = this;
        }
    }
    /**
   * Removes a scene node from this node
   * @param node - The scene node to be removed
   */ removeNode(node) {
        const index = this._nodes.indexOf(node);
        if (index >= 0) {
            this._nodes.splice(index, 1);
            node.octreeNode = null;
        }
    }
    /** Removes all the scene nodes that this octree node contains */ clearNodes() {
        for (const node of this._nodes){
            node.octreeNode = null;
        }
        this._nodes = [];
    }
    /**
   * Sets the octree chunk
   * @param chunk - The octree chunk to be set
   */ setChunk(chunk) {
        console.assert(!!chunk, 'Invalid chunk');
        this._chunk = chunk;
    }
    /**
   * Gets the octree chunk
   * @returns The octree chunk
   */ getChunk() {
        return this._chunk;
    }
    /**
   * Sets the position of the node
   * @param index - Position of the node
   */ setPosition(index) {
        this._position = index;
    }
    /**
   * Gets the position of the octree node
   * @returns Position of the octree node
   */ getPosition() {
        return this._position;
    }
    /**
   * Get the bounding box of the octree node
   * @returns The bounding box of the octree node
   */ getBox() {
        if (this._box === null) {
            const box = new AABB();
            box.beginExtend();
            for(let i = 0; i < 8; i++){
                const child = this.getChild(i);
                if (child) {
                    const childBox = child.getBox();
                    if (childBox) {
                        box.extend(childBox.minPoint);
                        box.extend(childBox.maxPoint);
                    }
                }
            }
            if (box.isValid()) {
                this._box = box;
            }
        }
        return this._box;
    }
    /**
   * Gets the loosed bounding box of the node
   * @returns The loosed bounding box of the node
   */ getBoxLoosed() {
        if (this._boxLoosed === null) {
            console.assert(!!this._chunk, 'Invalid chunk');
            const d = this._chunk.getDimension();
            const nodeSize = this._chunk.getNodeSize();
            const halfWorldSize = this._chunk.getWorldSize() * 0.5;
            const px = this._position % d;
            const py = Math.floor(this._position / d) % d;
            const pz = Math.floor(Math.floor(this._position / d) / d);
            const minPoint = new Vector3(px - 0.5, py - 0.5, pz - 0.5).scaleBy(nodeSize).subBy(new Vector3(halfWorldSize, halfWorldSize, halfWorldSize));
            const maxPoint = new Vector3(minPoint.x + nodeSize * 2, minPoint.y + nodeSize * 2, minPoint.z + nodeSize * 2);
            this._boxLoosed = new AABB(minPoint, maxPoint);
        }
        return this._boxLoosed;
    }
    /**
   * Gets min point of the node
   * @returns Min point of the node
   */ getMinPoint() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const d = this._chunk.getDimension();
        const nodeSize = this._chunk.getNodeSize();
        const halfWorldSize = this._chunk.getWorldSize() * 0.5;
        const px = this._position % d;
        const py = Math.floor(this._position / d) % d;
        const pz = Math.floor(Math.floor(this._position / d) / d);
        return new Vector3(px, py, pz).scaleBy(nodeSize).subBy(new Vector3(halfWorldSize, halfWorldSize, halfWorldSize));
    }
    /**
   * Gets max point of the node
   * @returns Max point of the node
   */ getMaxPoint() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const d = this._chunk.getDimension();
        const nodeSize = this._chunk.getNodeSize();
        const halfWorldSize = this._chunk.getWorldSize() * 0.5;
        const px = this._position % d + 1;
        const py = Math.floor(this._position / d) % d + 1;
        const pz = Math.floor(Math.floor(this._position / d) / d) + 1;
        return new Vector3(px, py, pz).scaleBy(nodeSize).subBy(new Vector3(halfWorldSize, halfWorldSize, halfWorldSize));
    }
    /**
   * Gets the loosed min point of the node
   * @returns Loosed min point of the node
   */ getMinPointLoosed() {
        const halfNodeSize = this._chunk.getNodeSize() * 0.5;
        return this.getMinPoint().subBy(new Vector3(halfNodeSize, halfNodeSize, halfNodeSize));
    }
    /**
   * Gets the loosed max point of the node
   * @returns Loosed max point of the node
   */ getMaxPointLoosed() {
        const halfNodeSize = this._chunk.getNodeSize() * 0.5;
        return this.getMaxPoint().addBy(new Vector3(halfNodeSize, halfNodeSize, halfNodeSize));
    }
    /**
   * Gets the child node by a given placement
   * @param placement - The placement
   * @returns Child node at the given placement
   */ getChild(placement) {
        console.assert(!!this._chunk, 'Invalid chunk');
        const next = this._chunk.getNext();
        return next ? next.getNode(this._chunk.getChildIndex(this._position, placement)) : null;
    }
    /**
   * Gets or creates a child node by a given placement
   * @param placement - The placement
   * @returns The child node fetched
   */ getOrCreateChild(placement) {
        console.assert(!!this._chunk, 'Invalid chunk');
        const next = this._chunk.getNext();
        return next ? next.getOrCreateNode(this._chunk.getChildIndex(this._position, placement)) : null;
    }
    /**
   * Gets parent of the node
   * @returns Parent of the node
   */ getParent() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const prev = this._chunk.getPrev();
        return prev ? prev.getNode(this._chunk.getParentIndex(this._position)) : null;
    }
    /**
   * Gets or creates the parent node
   * @returns The parent node
   */ getOrCreateParent() {
        console.assert(!!this._chunk, 'Invalid chunk');
        const prev = this._chunk.getPrev();
        return prev ? prev.getOrCreateNode(this._chunk.getParentIndex(this._position)) : null;
    }
    /**
   * Creates all children of this node
   */ createChildren() {
        this.getOrCreateChild(OctreePlacement.PPP);
        this.getOrCreateChild(OctreePlacement.PPN);
        this.getOrCreateChild(OctreePlacement.PNP);
        this.getOrCreateChild(OctreePlacement.PNN);
        this.getOrCreateChild(OctreePlacement.NPP);
        this.getOrCreateChild(OctreePlacement.NPN);
        this.getOrCreateChild(OctreePlacement.NNP);
        this.getOrCreateChild(OctreePlacement.NNN);
    }
    /**
   * Traverse this node by a visitor
   * @param v - The visitor
   */ traverse(v) {
        if (v.visit(this)) {
            for(let i = 0; i < 8; i++){
                const child = this.getChild(i);
                if (child) {
                    child.traverse(v);
                }
            }
        }
    }
}
/**
 * Octree node chunk
 * @public
 */ class OctreeNodeChunk {
    /** @internal */ _level;
    /** @internal */ _dimension;
    /** @internal */ _nodeSize;
    /** @internal */ _prev;
    /** @internal */ _next;
    /** @internal */ _octree;
    /** @internal */ _nodeMap;
    /**
   * Creates an instance of octree chunk
   * @param octree - Octree to which the chunk belongs
   */ constructor(octree){
        this._octree = octree;
        this._level = 0;
        this._dimension = 0;
        this._nodeSize = 0;
        this._next = null;
        this._prev = null;
        this._nodeMap = new Map();
    }
    /** @internal */ get nodeMap() {
        return this._nodeMap;
    }
    /**
   * Gets an octree node at a given index
   * @param index - Index of the node
   * @returns The octree node
   */ getNode(index) {
        return this._nodeMap.get(index) || null;
    }
    /**
   * Gets or creates an octree node at a given index
   * @param index - Index of the node
   * @returns The octree node
   */ getOrCreateNode(index) {
        let node = this.getNode(index);
        if (!node) {
            node = new OctreeNode();
            node.setChunk(this);
            node.setPosition(index);
            this._nodeMap.set(index, node);
        }
        return node;
    }
    /**
   * Gets or creates an octree node chain at a given index
   * @param index - Index of the head node
   * @returns The head node of the chain
   */ getOrCreateNodeChain(index) {
        const node = this.getOrCreateNode(index);
        if (this._prev) {
            this._prev.getOrCreateNodeChain(this.getParentIndex(index));
        }
        return node;
    }
    /**
   * Removes all octree nodes of this chunk
   */ clearNodes() {
        for (const key of this._nodeMap.keys()){
            this._nodeMap.get(key).clearNodes();
            this._nodeMap.delete(key);
        }
    }
    /**
   * Gets the index of a child node at given placement
   * @param index - Index of the parent node
   * @param placement - The placement
   * @returns Index of the child
   */ getChildIndex(index, placement) {
        const dim = this._dimension;
        let px = 2 * (index % dim);
        let py = 2 * (Math.floor(index / dim) % dim);
        let pz = 2 * Math.floor(Math.floor(index / dim) / dim);
        switch(placement){
            case OctreePlacement.PPP:
                ++px;
                ++py;
                ++pz;
                break;
            case OctreePlacement.PPN:
                ++px;
                ++py;
                break;
            case OctreePlacement.PNP:
                ++px;
                ++pz;
                break;
            case OctreePlacement.PNN:
                ++px;
                break;
            case OctreePlacement.NPP:
                ++py;
                ++pz;
                break;
            case OctreePlacement.NPN:
                ++py;
                break;
            case OctreePlacement.NNP:
                ++pz;
                break;
            case OctreePlacement.NNN:
                break;
            default:
                console.assert(false, 'getChildIndex: Got invalid index');
                return 0;
        }
        const dimension2 = 2 * dim;
        return pz * dimension2 * dimension2 + py * dimension2 + px;
    }
    /**
   * Gets the index of the parent node
   * @param index - Index of the child node
   * @returns Index of the parent node
   */ getParentIndex(index) {
        const dim = this._dimension;
        const px = index % dim >> 1;
        const py = Math.floor(index / dim) % dim >> 1;
        const pz = Math.floor(Math.floor(index / dim) / dim) >> 1;
        const d = dim >> 1;
        return px + py * d + pz * d * d;
    }
    /**
   * Gets the size of the node in this chunk
   * @returns The size of the node in this chunk
   */ getNodeSize() {
        return this._nodeSize;
    }
    /**
   * Gets the root size of the octree
   * @returns The root size of the octree
   */ getWorldSize() {
        return this._octree.getRootSize();
    }
    /**
   * Gets the dimension of this chunk
   * @returns Dimension of this chunk
   */ getDimension() {
        return this._dimension;
    }
    /**
   * Gets the level index of this chunk
   * @returns Level index of this chunk
   */ getLevel() {
        return this._level;
    }
    /**
   * Check if this chunk is empty
   * @returns true if this chunk is empty, otherwise false
   */ empty() {
        return this._nodeMap.size === 0;
    }
    /**
   * Gets the chunk next to this chunk
   * @returns The next chunk
   */ getNext() {
        return this._next;
    }
    /**
   * Gets the chunk previous to this chunk
   * @returns The previous chunk
   */ getPrev() {
        return this._prev;
    }
    /**
   * Gets the octree that the chunk belongs to
   * @returns The octree
   */ getOctree() {
        return this._octree;
    }
    /**
   * Sets the level index of this chunk
   * @param level - The level index to set
   */ setLevel(level) {
        this._level = level;
    }
    /**
   * Sets the dimension of this chunk
   * @param dimension - The dimension to set
   */ setDimension(dimension) {
        this._dimension = dimension;
    }
    /**
   * Sets the size of octree node in this chunk
   * @param size - The node size to set
   */ setNodeSize(size) {
        this._nodeSize = size;
    }
    /**
   * Sets the next chunk
   * @param chunk - The chunk to set
   */ setNext(chunk) {
        this._next = chunk;
    }
    /**
   * Sets the previous chunk
   * @param chunk - The chunk to set
   */ setPrev(chunk) {
        this._prev = chunk;
    }
}
/**
 * Octree class
 * @public
 */ class Octree {
    /** @internal */ _scene;
    /** @internal */ _chunks;
    /** @internal */ _rootSize;
    /** @internal */ _leafSize;
    /** @internal */ _rootNode;
    /** @internal */ _nodeMap;
    /**
   * Creates an instance of octree
   * @param scene - The scene to which the octree belongs
   * @param rootSize - Root size of the octre
   * @param leafSize - Leaf size of the octree
   */ constructor(scene, rootSize = 4096, leafSize = 64){
        this._scene = scene;
        this._chunks = [];
        this._rootSize = 0;
        this._leafSize = 0;
        this._rootNode = null;
        this._nodeMap = new WeakMap();
        this.initialize(rootSize, leafSize);
    }
    /**
   * Initialize the octree with specified root size and leaf size
   * @param rootSize - Root size of the octree
   * @param leafSize - Leaf size of the octree
   */ initialize(rootSize, leafSize) {
        this.finalize();
        this._leafSize = leafSize;
        this._rootSize = Math.max(leafSize, rootSize);
        let n = 1;
        for(; rootSize >= leafSize * 2; leafSize *= 2, ++n);
        for(let i = 0; i < n; ++i, rootSize *= 0.5){
            const chunk = new OctreeNodeChunk(this);
            chunk.setLevel(i);
            chunk.setNodeSize(rootSize);
            chunk.setDimension(1 << i);
            this._chunks.push(chunk);
            if (i > 0) {
                this._chunks[i - 1].setNext(chunk);
                chunk.setPrev(this._chunks[i - 1]);
            }
        }
    }
    /** Free up the octree */ finalize() {
        this._chunks.forEach((chunk)=>chunk.clearNodes());
        this._chunks = [];
        this._rootSize = 0;
        this._leafSize = 0;
        this._rootNode = null;
        this._nodeMap = new WeakMap();
    }
    /**
   * Gets the scene to which the octree belongs
   * @returns The scene
   */ getScene() {
        return this._scene;
    }
    /**
   * Gets the root size of the octree
   * @returns The root size of the octree
   */ getRootSize() {
        return this._rootSize;
    }
    /**
   * Gets the leaf size of the octree
   * @returns The leaf size of the octree
   */ getLeafSize() {
        return this._leafSize;
    }
    /**
   * Locates a node chain in the octree by a sphere
   * @param candidate - The candidate node
   * @param center - center of the sphere
   * @param radius - radius of the sphere
   * @returns Head node of the located node chain
   */ locateNodeChain(candidate, center, radius) {
        let level = this._chunks.length - 1;
        while(level && this._chunks[level].getNodeSize() < 4 * radius){
            --level;
        }
        const dim = this._chunks[level].getDimension();
        const inv_node_size = 1 / this._chunks[level].getNodeSize();
        const px = Math.floor((center.x + this._rootSize * 0.5) * inv_node_size);
        const py = Math.floor((center.y + this._rootSize * 0.5) * inv_node_size);
        const pz = Math.floor((center.z + this._rootSize * 0.5) * inv_node_size);
        if (px >= dim || py >= dim || pz >= dim) {
            return null;
        }
        const index = px + py * dim + pz * dim * dim;
        if (candidate && candidate.getChunk().getLevel() === level && candidate.getPosition() === index) {
            return candidate;
        }
        return this._chunks[level].getOrCreateNodeChain(index);
    }
    /**
   * Gets the root node of the octree
   * @returns Root node of the octree
   */ getRootNode() {
        if (!this._rootNode) {
            this._rootNode = this._chunks[0].getOrCreateNode(0);
        }
        return this._rootNode;
    }
    /**
   * Gets the number of chunks in the octree
   * @returns The number of chunks in the octree
   */ getNumChunks() {
        return this._chunks.length;
    }
    /**
   * Gets the chunk by a given index
   * @param level - The chunk index
   * @returns The chunk at given index
   */ getChunk(level) {
        return this._chunks[level];
    }
    /**
   * Place a scene node into the octree
   * @param node - The scene node to be placed
   */ placeNode(node) {
        const curNode = this._nodeMap.get(node) || null;
        let locatedNode = this.getRootNode();
        if (node.clipTestEnabled) {
            const bbox = node.getWorldBoundingVolume()?.toAABB();
            if (bbox && bbox.isValid()) {
                const center = bbox.center;
                const extents = bbox.extents;
                const size = Math.max(Math.max(extents.x, extents.y), extents.z);
                locatedNode = this.locateNodeChain(curNode, center, size);
                if (!locatedNode) {
                    const d = Math.max(...Vector3.abs(bbox.minPoint), ...Vector3.abs(bbox.maxPoint));
                    // nodeSize >= 4 * size & octreeSize >= 2 * d
                    this.resize(Math.max(d * 2, 4 * size));
                    this.placeNode(node);
                    return;
                }
            }
        }
        if (curNode !== locatedNode) {
            curNode?.removeNode(node);
            locatedNode?.addNode(node);
            this._nodeMap.set(node, locatedNode);
        }
    }
    /**
   * Removes a scene node from the octree
   * @param node - The scene node to be removed
   */ removeNode(node) {
        if (node.isGraphNode()) {
            const curNode = this._nodeMap.get(node) || null;
            if (curNode) {
                curNode.removeNode(node);
                this._nodeMap.delete(node);
            }
        }
    }
    resize(size) {
        size = Math.max(nextPowerOf2(size), this._leafSize);
        if (size === this._rootSize) {
            return;
        }
        const nodes = [];
        for (const chunk of this._chunks){
            chunk.nodeMap.forEach((node)=>{
                nodes.push(...node.getNodes());
            });
        }
        this.initialize(size, this._leafSize);
        for (const node of nodes){
            this.placeNode(node);
        }
    }
}

/**
 * Forward render pass type
 * @public
 */ const RENDER_PASS_TYPE_LIGHT = 0;
/**
 * Shadow map render pass type
 * @public
 */ const RENDER_PASS_TYPE_SHADOWMAP = 1;
/**
 * Depth only render pass type
 * @public
 */ const RENDER_PASS_TYPE_DEPTH = 2;
/**
 * No light
 * @public
 */ const LIGHT_TYPE_NONE = 0;
/**
 * Directional light type
 * @public
 */ const LIGHT_TYPE_DIRECTIONAL = 1;
/**
 * Point light type
 * @public
 */ const LIGHT_TYPE_POINT = 2;
/**
 * Spot light type
 * @public
 */ const LIGHT_TYPE_SPOT = 3;
/**
 * Max light size for clustered lighting
 * @public
 */ const MAX_CLUSTERED_LIGHTS = 255;
/**
 * Opaque render queue type
 * @public
 */ const QUEUE_OPAQUE = 1;
/**
 * Transparent render queue type
 * @public
 */ const QUEUE_TRANSPARENT = 2;

/**
 * Node visitor for culling
 * @public
 */ class CullVisitor {
    /** @internal */ _primaryCamera;
    /** @internal */ _camera;
    /** @internal */ _skipClipTest;
    /** @internal */ _renderQueue;
    /** @internal */ _renderPass;
    /**
   * Creates an instance of CullVisitor
   * @param renderPass - Render pass for the culling task
   * @param camera - Camera that will be used for culling
   * @param rendeQueue - RenderQueue
   * @param viewPoint - Camera position of the primary render pass
   */ constructor(renderPass, camera, renderQueue, primaryCamera){
        this._primaryCamera = primaryCamera;
        this._camera = camera;
        this._renderQueue = renderQueue;
        this._skipClipTest = false;
        this._renderPass = renderPass;
    }
    /** The camera that will be used for culling */ get camera() {
        return this._camera;
    }
    set camera(camera) {
        this._camera = camera || null;
    }
    /** true if cull with frustum culling, otherwise false. default is true */ get frustumCulling() {
        return !this._skipClipTest;
    }
    set frustumCulling(val) {
        this._skipClipTest = !val;
    }
    /** The camera position of the primary render pass */ get primaryCamera() {
        return this._primaryCamera;
    }
    /** Render pass for the culling task */ get renderPass() {
        return this._renderPass;
    }
    /** The result of culling */ get renderQueue() {
        return this._renderQueue;
    }
    set renderQueue(renderQueue) {
        this._renderQueue = renderQueue;
    }
    /** Frustum for culling */ get frustum() {
        return this._camera?.frustum || null;
    }
    /** @internal */ push(camera, drawable, renderOrder) {
        this.renderQueue.push(camera, drawable, renderOrder);
    }
    /** @internal */ pushRenderQueue(renderQueue) {
        this.renderQueue.pushRenderQueue(renderQueue);
    }
    /**
   * Visits a node
   * @param target - The node to be visit
   */ visit(target) {
        if (target instanceof OctreeNode) {
            return this.visitOctreeNode(target);
        } else if (target.isMesh()) {
            return this.visitMesh(target);
        } else if (target.isTerrain()) {
            return this.visitTerrain(target);
        } else if (target.isPunctualLight()) {
            return this.visitPunctualLight(target);
        } else if (target.isBatchGroup()) {
            return this.visitBatchGroup(target);
        }
    }
    /** @internal */ visitPunctualLight(node) {
        if (!node.hidden) {
            const clipState = this.getClipStateWithNode(node);
            if (clipState !== ClipState.NOT_CLIPPED) {
                this.renderQueue.pushLight(node);
                return true;
            }
        }
        return false;
    }
    /** @internal */ visitTerrain(node) {
        if (!node.hidden && (node.castShadow || this._renderPass.type !== RENDER_PASS_TYPE_SHADOWMAP)) {
            const clipState = this.getClipStateWithNode(node);
            if (clipState !== ClipState.NOT_CLIPPED) {
                return node.cull(this) > 0;
            }
        }
        return false;
    }
    /** @internal */ visitBatchGroup(node) {
        if (!node.hidden) {
            const renderQueue = node.getRenderQueue(this);
            this.pushRenderQueue(renderQueue);
            return true;
        }
        return false;
    }
    /** @internal */ visitMesh(node) {
        if (!node.hidden && (node.castShadow || this._renderPass.type !== RENDER_PASS_TYPE_SHADOWMAP)) {
            const clipState = this.getClipStateWithNode(node);
            if (clipState !== ClipState.NOT_CLIPPED) {
                this.push(this._camera, node, node.renderOrder);
                return true;
            }
        }
        return false;
    }
    /** @internal */ visitOctreeNode(node) {
        const clipState = node.getLevel() > 0 ? this.getClipStateWithAABB(node.getBoxLoosed()) : ClipState.CLIPPED;
        if (clipState !== ClipState.NOT_CLIPPED) {
            const saveSkipFlag = this._skipClipTest;
            this._skipClipTest = this._skipClipTest || clipState === ClipState.A_INSIDE_B;
            const nodes = node.getNodes();
            for(let i = 0; i < nodes.length; i++){
                this.visit(nodes[i]);
            }
            this._skipClipTest = saveSkipFlag;
            return true;
        }
        return false;
    }
    /** @internal */ getClipStateWithNode(node) {
        let clipState;
        if (this._skipClipTest) {
            clipState = ClipState.A_INSIDE_B;
        } else if (!node.clipTestEnabled) {
            clipState = ClipState.CLIPPED;
        } else {
            const bv = node.getWorldBoundingVolume();
            clipState = bv ? this.getClipStateWithAABB(bv.toAABB()) : ClipState.CLIPPED;
        }
        return clipState;
    }
    /** @internal */ getClipStateWithAABB(aabb) {
        return this.camera.clipMask ? aabb.getClipStateWithFrustumMask(this.frustum, this.camera.clipMask) : aabb.getClipStateWithFrustum(this.frustum);
    }
}

class ScatteringLut {
    static _groundAlbedo = 1.0;
    static _groundRadiusMM = 6.36;
    static _atmosphereRadiusMM = 6.46;
    static _scatteringSteps = 32;
    static _sunTransmittanceSteps = 40;
    static _rayleighScatteringBase = [
        5.802,
        13.558,
        33.1
    ];
    static _rayleighAbsorptionBase = 0;
    static _mieScatteringBase = 3.996;
    static _mieAbsorptionBase = 4.4;
    static _ozoneAbsorptionBase = [
        0.65,
        1.881,
        0.085
    ];
    static _multiScatteringSteps = 20;
    static _sqrtSamples = 8;
    static _transmittanceLutWidth = 256;
    static _transmittanceLutHeight = 64;
    static _multiScatteringLutWidth = 32;
    static _multiScatteringLutHeight = 32;
    static _skyViewLutWidth = 256;
    static _skyViewLutHeight = 256;
    static _vertexLayout = null;
    static _renderStates = null;
    static _programTransmittanceLut = null;
    static _bindgroupTransmittanceLut = null;
    static _programMultiScatteringLut = null;
    static _bindgroupMultiScatteringLut = null;
    static _programSkyViewLut = null;
    static _bindgroupSkyViewLut = null;
    static _transmittanceLut = null;
    static _multiScatteringLut = null;
    static _skyViewFramebuffer = null;
    static _programAerialPerspectiveLut = null;
    static _bindgroupAerialPerspectiveLut = null;
    static _aerialPerspectiveLut = null;
    static _currentSkyViewSunAltitude = 0;
    static _currentAerialPerspectiveAltitude = 0;
    static _currentMaxAerialPerspectiveDistance = 800;
    static _aerialPerspectiveSliceX = 32;
    static _aerialPerspectiveSliceY = 32;
    static _aerialPerspectiveSliceZ = 32;
    static _aerialPerspectiveTextureWidth = this._aerialPerspectiveSliceX * this._aerialPerspectiveSliceZ;
    static _aerialPerspectiveTextureHeight = this._aerialPerspectiveSliceY;
    static _viewPos = new Vector3(0.0, this._groundRadiusMM + 0.00005, 0.0);
    static get aerialPerspectiveSliceZ() {
        return this._aerialPerspectiveSliceZ;
    }
    static get groundRadius() {
        return this._groundRadiusMM;
    }
    static get atmosphereRadius() {
        return this._atmosphereRadiusMM;
    }
    static get viewPosition() {
        return this._viewPos;
    }
    static getMultiScatteringLut() {
        const device = Application.instance.device;
        if (!this._multiScatteringLut) {
            this.prepare(device);
            const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
            this._multiScatteringLut = device.createTexture2D(format, this._multiScatteringLutWidth, this._multiScatteringLutHeight, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            this._multiScatteringLut.name = 'MultiScatteringLUT';
            const tLut = this.getTransmittanceLut();
            const tempFramebuffer = device.createFrameBuffer([
                this._multiScatteringLut
            ], null);
            device.pushDeviceStates();
            device.setFramebuffer(tempFramebuffer);
            device.setProgram(this._programMultiScatteringLut);
            device.setBindGroup(0, this._bindgroupMultiScatteringLut);
            this._bindgroupMultiScatteringLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this._bindgroupMultiScatteringLut.setTexture('tLut', tLut);
            this.drawQuad(device);
            device.popDeviceStates();
            tempFramebuffer.dispose();
        }
        return this._multiScatteringLut;
    }
    static getAerialPerspectiveLut(sunAltitude, maxDistance) {
        const device = Application.instance.device;
        if (sunAltitude !== this._currentAerialPerspectiveAltitude || maxDistance !== this._currentMaxAerialPerspectiveDistance || !this._aerialPerspectiveLut) {
            if (!this._aerialPerspectiveLut) {
                const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
                if (!this._aerialPerspectiveLut) {
                    this._aerialPerspectiveLut = device.createTexture2D(format, this._aerialPerspectiveTextureWidth, this._aerialPerspectiveTextureHeight, {
                        samplerOptions: {
                            mipFilter: 'none'
                        }
                    });
                    this._aerialPerspectiveLut.name = 'AerialPerspectiveLUT';
                }
            }
            const fb = device.createFrameBuffer([
                this._aerialPerspectiveLut
            ], null);
            const tLut = this.getTransmittanceLut();
            const msLut = this.getMultiScatteringLut();
            this._currentAerialPerspectiveAltitude = sunAltitude;
            this._currentMaxAerialPerspectiveDistance = maxDistance;
            device.pushDeviceStates();
            device.setFramebuffer(fb);
            device.setProgram(this._programAerialPerspectiveLut);
            device.setBindGroup(0, this._bindgroupAerialPerspectiveLut);
            this._bindgroupAerialPerspectiveLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this._bindgroupAerialPerspectiveLut.setValue('sunAltitude', this._currentAerialPerspectiveAltitude);
            this._bindgroupAerialPerspectiveLut.setValue('maxDistance', this._currentMaxAerialPerspectiveDistance);
            this._bindgroupAerialPerspectiveLut.setTexture('tLut', tLut);
            this._bindgroupAerialPerspectiveLut.setTexture('msLut', msLut);
            this.drawQuad(device);
            device.popDeviceStates();
            fb.dispose();
        }
        return this._aerialPerspectiveLut;
    }
    static getSkyViewLut(sunAltitude) {
        const device = Application.instance.device;
        if (sunAltitude !== this._currentSkyViewSunAltitude || !this._skyViewFramebuffer) {
            if (!this._skyViewFramebuffer) {
                const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
                const skyViewLut = device.createTexture2D(format, this._skyViewLutWidth, this._skyViewLutHeight, {
                    samplerOptions: {
                        mipFilter: 'none'
                    }
                });
                skyViewLut.name = 'SkyViewLut';
                this._skyViewFramebuffer = device.createFrameBuffer([
                    skyViewLut
                ], null);
            }
            const tLut = this.getTransmittanceLut();
            const msLut = this.getMultiScatteringLut();
            this._currentSkyViewSunAltitude = sunAltitude;
            device.pushDeviceStates();
            device.setFramebuffer(this._skyViewFramebuffer);
            device.setProgram(this._programSkyViewLut);
            device.setBindGroup(0, this._bindgroupSkyViewLut);
            this._bindgroupSkyViewLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this._bindgroupSkyViewLut.setValue('sunAltitude', this._currentSkyViewSunAltitude);
            this._bindgroupSkyViewLut.setTexture('tLut', tLut);
            this._bindgroupSkyViewLut.setTexture('msLut', msLut);
            this.drawQuad(device);
            device.popDeviceStates();
        }
        return this._skyViewFramebuffer.getColorAttachments()[0];
    }
    static getTransmittanceLut() {
        const device = Application.instance.device;
        if (!this._transmittanceLut) {
            this.prepare(device);
            const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? 'rgba16f' : 'rgba8unorm';
            this._transmittanceLut = device.createTexture2D(format, this._transmittanceLutWidth, this._transmittanceLutHeight, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            this._transmittanceLut.name = 'TransmittanceLUT';
            const tempFramebuffer = device.createFrameBuffer([
                this._transmittanceLut
            ], null);
            device.pushDeviceStates();
            device.setFramebuffer(tempFramebuffer);
            device.setProgram(this._programTransmittanceLut);
            device.setBindGroup(0, this._bindgroupTransmittanceLut);
            this._bindgroupTransmittanceLut.setValue('flip', device.type === 'webgpu' ? 1 : 0);
            this.drawQuad(device);
            device.popDeviceStates();
            tempFramebuffer.dispose();
        }
        return this._transmittanceLut;
    }
    static drawQuad(device) {
        const lastRenderState = device.getRenderStates();
        device.setRenderStates(this._renderStates);
        device.setVertexLayout(this._vertexLayout);
        device.draw('triangle-strip', 0, 4);
        device.setRenderStates(lastRenderState);
    }
    static commonVertexShader() {
        const pb = this.$builder;
        this.flip = pb.int().uniform(0);
        this.$inputs.pos = pb.vec2().attrib('position');
        this.$outputs.uv = pb.vec2();
        pb.main(function() {
            this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
            this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
            this.$if(pb.notEqual(this.flip, 0), function() {
                this.$builtins.position.y = pb.neg(this.$builtins.position.y);
            });
        });
    }
    static commonFunctions() {
        const pb = this.$builder;
        this.viewPos = pb.vec3(ScatteringLut._viewPos.x, ScatteringLut._viewPos.y, ScatteringLut._viewPos.z);
        pb.func('getMiePhase', [
            pb.float('cosTheta')
        ], function() {
            this.$l.g = pb.float(0.8);
            this.$l.scale = pb.float(3 / (Math.PI * 8));
            this.$l.gg = pb.mul(this.g, this.g);
            this.$l.num = pb.mul(pb.sub(1, this.gg), pb.add(pb.mul(this.cosTheta, this.cosTheta), 1));
            this.$l.denom = pb.mul(pb.add(2, this.gg), pb.pow(pb.sub(pb.add(1, this.gg), pb.mul(this.g, this.cosTheta, 2)), 1.5));
            this.$return(pb.div(pb.mul(this.scale, this.num), this.denom));
        });
        pb.func('getRayleighPhase', [
            pb.float('cosTheta')
        ], function() {
            this.$l.k = pb.float(3 / (Math.PI * 16));
            this.$return(pb.mul(this.k, pb.add(1, pb.mul(this.cosTheta, this.cosTheta))));
        });
        pb.func('rayIntersectSphere', [
            pb.vec3('ro'),
            pb.vec3('rd'),
            pb.float('rad')
        ], function() {
            this.$l.b = pb.dot(this.ro, this.rd);
            this.$l.c = pb.sub(pb.dot(this.ro, this.ro), pb.mul(this.rad, this.rad));
            this.$if(pb.and(pb.greaterThan(this.c, 0), pb.greaterThan(this.b, 0)), function() {
                this.$return(pb.float(-1));
            });
            this.$l.bb = pb.mul(this.b, this.b);
            this.$l.discr = pb.sub(this.bb, this.c);
            this.$if(pb.lessThan(this.discr, 0), function() {
                this.$return(pb.float(-1));
            });
            this.$if(pb.greaterThan(this.discr, this.bb), function() {
                this.$return(pb.sub(pb.sqrt(this.discr), this.b));
            });
            this.$return(pb.sub(pb.neg(pb.sqrt(this.discr)), this.b));
        });
        pb.func('getScatteringValues', [
            pb.vec3('pos'),
            pb.vec3('rayleighScattering').out(),
            pb.float('mieScattering').out(),
            pb.vec3('extinction').out()
        ], function() {
            this.$l.altitudeKM = pb.mul(pb.sub(pb.length(this.pos), ScatteringLut._groundRadiusMM), 1000);
            this.$l.rayleighDensity = pb.exp(pb.div(this.altitudeKM, -8));
            this.$l.mieDensity = pb.exp(pb.div(this.altitudeKM, -1.2));
            this.rayleighScattering = pb.mul(pb.vec3(...ScatteringLut._rayleighScatteringBase), this.rayleighDensity);
            this.$l.rayleighAbsorption = pb.mul(ScatteringLut._rayleighAbsorptionBase, this.rayleighDensity);
            this.mieScattering = pb.mul(ScatteringLut._mieScatteringBase, this.mieDensity);
            this.$l.mieAbsorption = pb.mul(ScatteringLut._mieAbsorptionBase, this.mieDensity);
            this.$l.ozoneAbsorption = pb.mul(pb.vec3(...ScatteringLut._ozoneAbsorptionBase), pb.max(0, pb.sub(1, pb.div(pb.abs(pb.sub(this.altitudeKM, 25)), 15))));
            this.extinction = pb.add(this.rayleighScattering, pb.vec3(this.rayleighAbsorption), pb.vec3(this.mieScattering), pb.vec3(this.mieAbsorption), this.ozoneAbsorption);
        });
    }
    static prepare(device) {
        const that = this;
        if (!this._vertexLayout) {
            this._vertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                            -1,
                            -1,
                            1,
                            -1,
                            -1,
                            1,
                            1,
                            1
                        ]))
                    }
                ]
            });
        }
        if (!this._renderStates) {
            this._renderStates = device.createRenderStateSet();
            this._renderStates.useRasterizerState().setCullMode('none');
            this._renderStates.useDepthState().enableTest(false).enableWrite(false);
        }
        if (!this._programAerialPerspectiveLut) {
            this._programAerialPerspectiveLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.sunAltitude = pb.float().uniform(0);
                    this.tLut = pb.tex2D().uniform(0);
                    this.msLut = pb.tex2D().uniform(0);
                    this.maxDistance = pb.float().uniform(0);
                    that.commonFunctions.call(this);
                    pb.func('getValFromTLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                    });
                    pb.func('getValFromMSLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.msLut, this.uv, 0).rgb);
                    });
                    pb.func('raymarchScattering', [
                        pb.vec3('pos'),
                        pb.vec3('rayDir'),
                        pb.vec3('sunDir'),
                        pb.float('tMax')
                    ], function() {
                        this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                        this.$l.miePhaseValue = this.getMiePhase(this.cosTheta);
                        this.$l.rayleighPhaseValue = this.getRayleighPhase(pb.neg(this.cosTheta));
                        this.$l.lum = pb.vec3(0);
                        this.$l.transmittance = pb.vec3(1);
                        this.$l.t = pb.float(0);
                        this.$for(pb.int('i'), 0, that._scatteringSteps, function() {
                            this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.i), 0.3), that._scatteringSteps), this.tMax);
                            this.$l.dt = pb.sub(this.newT, this.t);
                            this.t = this.newT;
                            this.$l.newPos = pb.add(this.pos, pb.mul(this.rayDir, this.t));
                            this.$l.rayleighScattering = pb.vec3();
                            this.$l.extinction = pb.vec3();
                            this.$l.mieScattering = pb.float();
                            this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                            this.$l.sampleTransmittance = pb.exp(pb.mul(pb.neg(this.dt), this.extinction));
                            this.$l.sunTransmittance = this.getValFromTLUT(this.newPos, this.sunDir);
                            this.$l.psiMS = this.getValFromMSLUT(this.newPos, this.sunDir);
                            this.$l.rayleighInScattering = pb.mul(this.rayleighScattering, pb.add(pb.mul(this.sunTransmittance, this.rayleighPhaseValue), this.psiMS));
                            this.$l.mieInScattering = pb.mul(pb.add(pb.mul(this.sunTransmittance, this.miePhaseValue), this.psiMS), this.mieScattering);
                            this.$l.inScattering = pb.add(this.rayleighInScattering, this.mieInScattering);
                            this.$l.scatteringIntegral = pb.div(pb.sub(this.inScattering, pb.mul(this.inScattering, this.sampleTransmittance)), this.extinction);
                            this.lum = pb.add(this.lum, pb.mul(this.scatteringIntegral, this.transmittance));
                            this.transmittance = pb.mul(this.transmittance, this.sampleTransmittance);
                        });
                        this.$return(this.lum);
                    });
                    pb.main(function() {
                        this.$l.slice = pb.clamp(pb.floor(pb.div(this.$inputs.uv.x, 1 / ScatteringLut._aerialPerspectiveSliceZ)), 0, pb.sub(ScatteringLut._aerialPerspectiveSliceZ, 1));
                        this.$l.sliceU = pb.clamp(pb.div(pb.sub(this.$inputs.uv.x, pb.mul(this.slice, 1 / ScatteringLut._aerialPerspectiveSliceZ)), 1 / ScatteringLut._aerialPerspectiveSliceZ), 0, 1);
                        this.$l.horizonAngle = pb.sub(pb.mul(this.sliceU, Math.PI * 2), Math.PI);
                        this.$l.zenithAngle = pb.mul(this.$inputs.uv.y, Math.PI / 2);
                        /*
            this.$l.rayDir = pb.vec3(pb.mul(this.cosAltitude, pb.sin(this.azimuthAngle)), pb.sin(this.altitudeAngle), pb.mul(pb.neg(this.cosAltitude), pb.cos(this.azimuthAngle)));
            this.$l.sunDir = pb.vec3(0, pb.sin(this.sunAltitude), pb.neg(pb.cos(this.sunAltitude)));
            */ this.$l.rayDir = pb.vec3(pb.mul(pb.cos(this.zenithAngle), pb.sin(this.horizonAngle)), pb.sin(this.zenithAngle), pb.mul(pb.neg(pb.cos(this.zenithAngle)), pb.cos(this.horizonAngle)));
                        this.$l.atmoDist = this.rayIntersectSphere(this.viewPos, this.rayDir, ScatteringLut._atmosphereRadiusMM);
                        this.$l.groundDist = this.rayIntersectSphere(this.viewPos, this.rayDir, ScatteringLut._groundRadiusMM);
                        this.$l.tMax = pb.float();
                        this.$if(pb.lessThan(this.groundDist, 0), function() {
                            this.tMax = this.atmoDist;
                        }).$else(function() {
                            this.tMax = this.groundDist;
                        });
                        this.tMax = this.atmoDist;
                        this.$l.maxDistanceMM = pb.mul(this.maxDistance, 1e-6);
                        this.$l.sliceDist = pb.mul(this.maxDistanceMM, pb.div(this.slice, ScatteringLut._aerialPerspectiveSliceZ));
                        this.tMax = pb.min(this.tMax, this.sliceDist);
                        this.$l.sunDir = pb.vec3(0, pb.sin(this.sunAltitude), pb.neg(pb.cos(this.sunAltitude)));
                        this.$l.lum = this.raymarchScattering(this.viewPos, this.rayDir, this.sunDir, this.tMax);
                        const heightKM = (that._viewPos.y - that._groundRadiusMM) * 1000;
                        const rayleighDensity = Math.exp(-heightKM / 8);
                        const mieDensity = Math.exp(-heightKM / 1.2);
                        this.$l.extinction = pb.vec3(-((that._rayleighScatteringBase[0] + that._rayleighAbsorptionBase) * rayleighDensity + (that._mieScatteringBase + that._mieAbsorptionBase) * mieDensity), -((that._rayleighScatteringBase[1] + that._rayleighAbsorptionBase) * rayleighDensity + (that._mieScatteringBase + that._mieAbsorptionBase) * mieDensity), -((that._rayleighScatteringBase[2] + that._rayleighAbsorptionBase) * rayleighDensity + (that._mieScatteringBase + that._mieAbsorptionBase) * mieDensity));
                        this.$l.t = pb.exp(pb.mul(this.extinction, this.tMax));
                        this.$outputs.outColor = pb.vec4(this.lum, pb.dot(this.t, pb.vec3(1 / 3, 1 / 3, 1 / 3)));
                    });
                }
            });
            this._bindgroupAerialPerspectiveLut = device.createBindGroup(this._programAerialPerspectiveLut.bindGroupLayouts[0]);
        }
        if (!this._programSkyViewLut) {
            this._programSkyViewLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.sunAltitude = pb.float().uniform(0);
                    this.tLut = pb.tex2D().uniform(0);
                    this.msLut = pb.tex2D().uniform(0);
                    that.commonFunctions.call(this);
                    pb.func('getValFromTLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                    });
                    pb.func('getValFromMSLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.msLut, this.uv, 0).rgb);
                    });
                    pb.func('raymarchScattering', [
                        pb.vec3('pos'),
                        pb.vec3('rayDir'),
                        pb.vec3('sunDir'),
                        pb.float('tMax')
                    ], function() {
                        this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                        this.$l.miePhaseValue = this.getMiePhase(this.cosTheta);
                        this.$l.rayleighPhaseValue = this.getRayleighPhase(pb.neg(this.cosTheta));
                        this.$l.lum = pb.vec3(0);
                        this.$l.transmittance = pb.vec3(1);
                        this.$l.t = pb.float(0);
                        this.$for(pb.int('i'), 0, that._scatteringSteps, function() {
                            this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.i), 0.3), that._scatteringSteps), this.tMax);
                            this.$l.dt = pb.sub(this.newT, this.t);
                            this.t = this.newT;
                            this.$l.newPos = pb.add(this.pos, pb.mul(this.rayDir, this.t));
                            this.$l.rayleighScattering = pb.vec3();
                            this.$l.extinction = pb.vec3();
                            this.$l.mieScattering = pb.float();
                            this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                            this.$l.sampleTransmittance = pb.exp(pb.mul(pb.neg(this.dt), this.extinction));
                            this.$l.sunTransmittance = this.getValFromTLUT(this.newPos, this.sunDir);
                            this.$l.psiMS = this.getValFromMSLUT(this.newPos, this.sunDir);
                            this.$l.rayleighInScattering = pb.mul(this.rayleighScattering, pb.add(pb.mul(this.sunTransmittance, this.rayleighPhaseValue), this.psiMS));
                            this.$l.mieInScattering = pb.mul(pb.add(pb.mul(this.sunTransmittance, this.miePhaseValue), this.psiMS), this.mieScattering);
                            this.$l.inScattering = pb.add(this.rayleighInScattering, this.mieInScattering);
                            this.$l.scatteringIntegral = pb.div(pb.sub(this.inScattering, pb.mul(this.inScattering, this.sampleTransmittance)), this.extinction);
                            this.lum = pb.add(this.lum, pb.mul(this.scatteringIntegral, this.transmittance));
                            this.transmittance = pb.mul(this.transmittance, this.sampleTransmittance);
                        });
                        this.$return(this.lum);
                    });
                    pb.main(function() {
                        this.$l.azimuthAngle = pb.mul(pb.sub(this.$inputs.uv.x, 0.5), 2 * Math.PI);
                        this.$l.adjV = pb.float();
                        this.$if(pb.lessThan(this.$inputs.uv.y, 0.5), function() {
                            this.$l.coord = pb.sub(1, pb.mul(this.$inputs.uv.y, 2));
                            this.adjV = pb.neg(pb.mul(this.coord, this.coord));
                        }).$else(function() {
                            this.$l.coord = pb.sub(pb.mul(this.$inputs.uv.y, 2), 1);
                            this.adjV = pb.mul(this.coord, this.coord);
                        });
                        this.$l.height = pb.length(this.viewPos);
                        this.$l.up = pb.div(this.viewPos, this.height);
                        this.$l.horizonAngle = pb.sub(pb.acos(pb.clamp(pb.div(pb.sqrt(pb.sub(pb.mul(this.height, this.height), pb.mul(that._groundRadiusMM, that._groundRadiusMM))), this.height), -1, 1)), Math.PI * 0.5);
                        this.$l.altitudeAngle = pb.sub(pb.mul(this.adjV, Math.PI * 0.5), this.horizonAngle);
                        this.$l.cosAltitude = pb.cos(this.altitudeAngle);
                        this.$l.rayDir = pb.vec3(pb.mul(this.cosAltitude, pb.sin(this.azimuthAngle)), pb.sin(this.altitudeAngle), pb.mul(pb.neg(this.cosAltitude), pb.cos(this.azimuthAngle)));
                        this.$l.sunDir = pb.vec3(0, pb.sin(this.sunAltitude), pb.neg(pb.cos(this.sunAltitude)));
                        this.$l.atmoDist = this.rayIntersectSphere(this.viewPos, this.rayDir, that._atmosphereRadiusMM);
                        this.$l.groundDist = this.rayIntersectSphere(this.viewPos, this.rayDir, that._groundRadiusMM);
                        this.$l.tMax = pb.float();
                        this.$if(pb.lessThan(this.groundDist, 0), function() {
                            this.tMax = this.atmoDist;
                        }).$else(function() {
                            this.tMax = this.groundDist;
                        });
                        this.$l.lum = this.raymarchScattering(this.viewPos, this.rayDir, this.sunDir, this.tMax);
                        this.$outputs.outColor = pb.vec4(this.lum, 1);
                    });
                }
            });
            this._bindgroupSkyViewLut = device.createBindGroup(this._programSkyViewLut.bindGroupLayouts[0]);
        }
        if (!this._programMultiScatteringLut) {
            this._programMultiScatteringLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.tLut = pb.tex2D().uniform(0);
                    that.commonFunctions.call(this);
                    pb.func('getValFromTLUT', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$l.height = pb.length(this.pos);
                        this.$l.up = pb.div(this.pos, this.height);
                        this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                        this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, that._groundRadiusMM), pb.sub(that._atmosphereRadiusMM, that._groundRadiusMM)))));
                        this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                    });
                    pb.func('getSphericalDir', [
                        pb.float('theta'),
                        pb.float('phi')
                    ], function() {
                        this.$l.cosPhi = pb.cos(this.phi);
                        this.$l.sinPhi = pb.sin(this.phi);
                        this.$l.cosTheta = pb.cos(this.theta);
                        this.$l.sinTheta = pb.sin(this.theta);
                        this.$return(pb.vec3(pb.mul(this.sinPhi, this.sinTheta), this.cosPhi, pb.mul(this.sinPhi, this.cosTheta)));
                    });
                    pb.func('getMultiScatteringValues', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir'),
                        pb.vec3('lumTotal').out(),
                        pb.vec3('fms').out()
                    ], function() {
                        this.lumTotal = pb.vec3(0);
                        this.fms = pb.vec3(0);
                        this.$l.invSamples = pb.div(pb.float(1), pb.mul(that._sqrtSamples, that._sqrtSamples));
                        this.$for(pb.int('i'), 0, that._sqrtSamples, function() {
                            this.$for(pb.int('j'), 0, that._sqrtSamples, function() {
                                this.$l.theta = pb.div(pb.mul(pb.add(pb.float(this.i), 0.5), Math.PI), that._sqrtSamples);
                                this.$l.c = pb.sub(1, pb.div(pb.mul(pb.add(pb.float(this.j), 0.5), 2), that._sqrtSamples));
                                this.$l.phi = pb.acos(pb.clamp(this.c, -1, 1));
                                this.$l.rayDir = this.getSphericalDir(this.theta, this.phi);
                                this.$l.atmoDist = this.rayIntersectSphere(this.pos, this.rayDir, that._atmosphereRadiusMM);
                                this.$l.groundDist = this.rayIntersectSphere(this.pos, this.rayDir, that._groundRadiusMM);
                                this.$l.tMax = this.atmoDist;
                                this.$if(pb.greaterThan(this.groundDist, 0), function() {
                                    this.tMax = this.groundDist;
                                });
                                this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                                this.$l.miePhaseValue = this.getMiePhase(this.cosTheta);
                                this.$l.rayleighPhaseValue = this.getRayleighPhase(pb.neg(this.cosTheta));
                                this.$l.lum = pb.vec3(0);
                                this.$l.lumFactor = pb.vec3(0);
                                this.$l.transmittance = pb.vec3(1);
                                this.$l.t = pb.float(0);
                                this.$for(pb.int('stepI'), 0, that._multiScatteringSteps, function() {
                                    this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.stepI), 0.3), that._multiScatteringSteps), this.tMax);
                                    this.$l.dt = pb.sub(this.newT, this.t);
                                    this.t = this.newT;
                                    this.$l.newPos = pb.add(this.pos, pb.mul(this.rayDir, this.t));
                                    this.$l.rayleighScattering = pb.vec3();
                                    this.$l.extinction = pb.vec3();
                                    this.$l.mieScattering = pb.float();
                                    this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                                    this.$l.sampleTransmittance = pb.exp(pb.mul(pb.neg(this.dt), this.extinction));
                                    this.$l.scatteringNoPhase = pb.add(this.rayleighScattering, pb.vec3(this.mieScattering));
                                    this.$l.scatteringF = pb.div(pb.sub(this.scatteringNoPhase, pb.mul(this.scatteringNoPhase, this.sampleTransmittance)), this.extinction);
                                    this.lumFactor = pb.add(this.lumFactor, pb.mul(this.transmittance, this.scatteringF));
                                    this.$l.sunTransmittance = this.getValFromTLUT(this.newPos, this.sunDir);
                                    this.$l.rayleighInscattering = pb.mul(this.rayleighScattering, this.rayleighPhaseValue);
                                    this.$l.mieInscattering = pb.mul(this.mieScattering, this.miePhaseValue);
                                    this.$l.inscattering = pb.mul(pb.add(this.rayleighInscattering, pb.vec3(this.mieInscattering)), this.sunTransmittance);
                                    this.$l.scatteringIntegral = pb.div(pb.sub(this.inscattering, pb.mul(this.inscattering, this.sampleTransmittance)), this.extinction);
                                    this.lum = pb.add(this.lum, pb.mul(this.scatteringIntegral, this.transmittance));
                                    this.transmittance = pb.mul(this.transmittance, this.sampleTransmittance);
                                });
                                this.$if(pb.greaterThan(this.groundDist, 0), function() {
                                    this.$l.hitPos = pb.add(this.pos, pb.mul(this.rayDir, this.groundDist));
                                    this.$if(pb.greaterThan(pb.dot(this.pos, this.sunDir), 0), function() {
                                        this.hitPos = pb.mul(pb.normalize(this.hitPos), that._groundRadiusMM);
                                        this.lum = pb.add(this.lum, pb.mul(this.transmittance, pb.vec3(that._groundAlbedo), this.getValFromTLUT(this.hitPos, this.sunDir)));
                                    });
                                });
                                this.fms = pb.add(this.fms, pb.mul(this.lumFactor, this.invSamples));
                                this.lumTotal = pb.add(this.lumTotal, pb.mul(this.lum, this.invSamples));
                            });
                        });
                    });
                    pb.main(function() {
                        this.$l.sunCosTheta = pb.sub(pb.mul(this.$inputs.uv.x, 2), 1);
                        this.$l.sunTheta = pb.acos(pb.clamp(this.sunCosTheta, -1, 1));
                        this.$l.height = pb.mix(that._groundRadiusMM, that._atmosphereRadiusMM, this.$inputs.uv.y);
                        this.$l.pos = pb.vec3(0, this.height, 0);
                        this.$l.sunDir = pb.normalize(pb.vec3(0, this.sunCosTheta, pb.neg(pb.sin(this.sunTheta))));
                        this.$l.lum = pb.vec3();
                        this.$l.fms = pb.vec3();
                        this.getMultiScatteringValues(this.pos, this.sunDir, this.lum, this.fms);
                        this.$l.psi = pb.div(this.lum, pb.sub(1, this.fms));
                        this.$outputs.outColor = pb.vec4(this.psi, 1);
                    });
                }
            });
        }
        this._bindgroupMultiScatteringLut = device.createBindGroup(this._programMultiScatteringLut.bindGroupLayouts[0]);
        if (!this._programTransmittanceLut) {
            this._programTransmittanceLut = device.buildRenderProgram({
                vertex (pb) {
                    that.commonVertexShader.call(this);
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    that.commonFunctions.call(this);
                    pb.func('getSunTransmittance', [
                        pb.vec3('pos'),
                        pb.vec3('sunDir')
                    ], function() {
                        this.$if(pb.greaterThan(this.rayIntersectSphere(this.pos, this.sunDir, that._groundRadiusMM), 0), function() {
                            this.$return(pb.vec3(0));
                        });
                        this.$l.atmoDist = this.rayIntersectSphere(this.pos, this.sunDir, that._atmosphereRadiusMM);
                        this.$l.t = pb.float(0);
                        this.$l.transmittance = pb.vec3(1);
                        this.$for(pb.int('i'), 0, that._sunTransmittanceSteps, function() {
                            this.$l.newT = pb.mul(pb.div(pb.add(pb.float(this.i), 0.3), that._sunTransmittanceSteps), this.atmoDist);
                            this.$l.dt = pb.sub(this.newT, this.t);
                            this.t = this.newT;
                            this.$l.newPos = pb.add(this.pos, pb.mul(this.sunDir, this.t));
                            this.$l.rayleighScattering = pb.vec3();
                            this.$l.extinction = pb.vec3();
                            this.$l.mieScattering = pb.float();
                            this.getScatteringValues(this.newPos, this.rayleighScattering, this.mieScattering, this.extinction);
                            this.transmittance = pb.mul(this.transmittance, pb.exp(pb.mul(this.extinction, pb.neg(this.dt))));
                        });
                        this.$return(this.transmittance);
                    });
                    pb.main(function() {
                        this.$l.sunCosTheta = pb.sub(pb.mul(this.$inputs.uv.x, 2), 1);
                        this.$l.sunTheta = pb.acos(pb.clamp(this.sunCosTheta, -1, 1));
                        this.$l.height = pb.mix(that._groundRadiusMM, that._atmosphereRadiusMM, this.$inputs.uv.y);
                        this.$l.pos = pb.vec3(0, this.height, 0);
                        this.$l.sunDir = pb.normalize(pb.vec3(0, this.sunCosTheta, pb.neg(pb.sin(this.sunTheta))));
                        this.$outputs.outColor = pb.vec4(this.getSunTransmittance(this.pos, this.sunDir), 1);
                    });
                }
            });
        }
        this._bindgroupTransmittanceLut = device.createBindGroup(this._programTransmittanceLut.bindGroupLayouts[0]);
    }
}

const UNIFORM_NAME_GLOBAL = 'Z_UniformGlobal';
const UNIFORM_NAME_LIGHT_BUFFER = 'Z_UniformLightBuffer';
const UNIFORM_NAME_LIGHT_INDEX_TEXTURE = 'Z_UniformLightIndexTex';
const UNIFORM_NAME_AERIALPERSPECTIVE_LUT = 'Z_UniformAerialPerspectiveLUT';
const UNIFORM_NAME_SHADOW_MAP = 'Z_UniformShadowMap';
const UNIFORM_NAME_WORLD_MATRIX = 'Z_UniformWorldMatrix';
const UNIFORM_NAME_INSTANCE_DATA_STRIDE = 'Z_UniformInstanceDataStride';
const UNIFORM_NAME_INSTANCE_DATA = 'Z_UniformInstanceData';
const UNIFORM_NAME_INSTANCE_DATA_OFFSET = 'Z_UniformInstanceDataOffset';
const UNIFORM_NAME_BONE_MATRICES = 'Z_UniformBoneMatrices';
const UNIFORM_NAME_BONE_TEXTURE_SIZE = 'Z_UniformBoneTexSize';
const UNIFORM_NAME_BONE_INV_BIND_MATRIX = 'Z_UniformBoneInvBindMatrix';
/**
 * Helper shader functions for the builtin material system
 * @public
 */ class ShaderHelper {
    static FOG_TYPE_NONE = 0;
    static FOG_TYPE_LINEAR = 1;
    static FOG_TYPE_EXP = 2;
    static FOG_TYPE_EXP2 = 3;
    static FOG_TYPE_SCATTER = 4;
    static BILLBOARD_SPHERICAL = 1;
    static BILLBOARD_SYLINDRAL = 2;
    /** @internal */ static defaultSunDir = Vector3.one().inplaceNormalize();
    /** @internal */ static SKIN_MATRIX_NAME = 'Z_SkinMatrix';
    /** @internal */ static _lightUniformShadow = {
        light: {
            sunDir: new Vector3(),
            envLightStrength: 1,
            shadowCascades: 1,
            positionAndRange: new Vector4(),
            directionAndCutoff: new Vector4(),
            diffuseAndIntensity: new Vector4(),
            cascadeDistances: new Vector4(),
            depthBiasValues: new Vector4(),
            shadowCameraParams: new Vector4(),
            depthBiasScales: new Vector4(),
            shadowMatrices: new Float32Array(16 * 4)
        }
    };
    /** @internal */ static _fogUniforms = {
        fog: {
            fogType: 0,
            fogColor: null,
            // [near, far, top, density]
            fogParams: null,
            // aerial perspective density
            apDensity: 1
        }
    };
    static getWorldMatrixUniformName() {
        return UNIFORM_NAME_WORLD_MATRIX;
    }
    static getInstanceDataUniformName() {
        return UNIFORM_NAME_INSTANCE_DATA;
    }
    static getInstanceDataOffsetUniformName() {
        return UNIFORM_NAME_INSTANCE_DATA_OFFSET;
    }
    static getInstanceDataStrideUniformName() {
        return UNIFORM_NAME_INSTANCE_DATA_STRIDE;
    }
    static getBoneMatricesUniformName() {
        return UNIFORM_NAME_BONE_MATRICES;
    }
    static getBoneTextureSizeUniformName() {
        return UNIFORM_NAME_BONE_TEXTURE_SIZE;
    }
    static getBoneInvBindMatrixUniformName() {
        return UNIFORM_NAME_BONE_INV_BIND_MATRIX;
    }
    static getLightBufferUniformName() {
        return UNIFORM_NAME_LIGHT_BUFFER;
    }
    /**
   * Prepares the fragment shader which is going to be used in our material system
   *
   * @remarks
   * This function will setup all nessesary uniforms acoording to the drawing context
   *
   * @param pb - The program builder
   * @param ctx - The drawing context
   */ static prepareFragmentShader(pb, ctx) {
        this.setupGlobalUniforms(pb, ctx);
    }
    /**
   * Prepares the vertex shader which is going to be used in our material system
   *
   * @remarks
   * This function will setup all nessesary uniforms according to the drawing context
   *
   * @param pb - The program builder
   * @param ctx - The drawing context
   */ static prepareVertexShader(pb, ctx) {
        this.setupGlobalUniforms(pb, ctx);
        this.prepareVertexShaderCommon(pb, ctx);
    }
    /** @internal */ static setupGlobalUniforms(pb, ctx) {
        const scope = pb.getGlobalScope();
        const cameraStruct = pb.defineStruct([
            pb.vec4('position'),
            pb.vec4('clipPlane'),
            pb.mat4('viewProjectionMatrix'),
            pb.mat4('viewMatrix'),
            pb.mat4('projectionMatrix'),
            pb.vec4('params')
        ]);
        if (ctx.renderPass.type === RENDER_PASS_TYPE_SHADOWMAP) {
            const lightStruct = pb.defineStruct([
                pb.vec4('positionAndRange'),
                pb.vec4('directionCutoff'),
                pb.mat4('viewMatrix'),
                pb.vec4('depthBias'),
                pb.int('lightType')
            ]);
            const globalStruct = pb.defineStruct([
                cameraStruct('camera'),
                lightStruct('light')
            ]);
            scope[UNIFORM_NAME_GLOBAL] = globalStruct().uniform(0);
        } else if (ctx.renderPass.type === RENDER_PASS_TYPE_DEPTH) {
            const globalStruct = pb.defineStruct([
                cameraStruct('camera')
            ]);
            scope[UNIFORM_NAME_GLOBAL] = globalStruct().uniform(0);
        } else if (ctx.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
            const useClusteredLighting = !ctx.currentShadowLight;
            const fogStruct = pb.defineStruct([
                pb.int('fogType'),
                pb.vec4('fogColor'),
                pb.vec4('fogParams'),
                pb.float('apDensity')
            ]);
            const lightStruct = ctx.currentShadowLight ? pb.defineStruct([
                pb.vec3('sunDir'),
                pb.int('shadowCascades'),
                pb.vec4('positionAndRange'),
                pb.vec4('directionAndCutoff'),
                pb.vec4('diffuseAndIntensity'),
                pb.vec4('cascadeDistances'),
                pb.vec4('depthBiasValues'),
                pb.vec4('shadowCameraParams'),
                pb.vec4('depthBiasScales'),
                pb.vec4[16]('shadowMatrices'),
                pb.float('envLightStrength')
            ]) : pb.defineStruct([
                pb.vec3('sunDir'),
                pb.float('envLightStrength'),
                pb.vec4('clusterParams'),
                pb.ivec4('countParams'),
                pb.ivec2('lightIndexTexSize')
            ]);
            const globalStruct = pb.defineStruct([
                cameraStruct('camera'),
                lightStruct('light'),
                fogStruct('fog')
            ]);
            scope[UNIFORM_NAME_GLOBAL] = globalStruct().uniform(0);
            if (useClusteredLighting) {
                scope[UNIFORM_NAME_LIGHT_BUFFER] = pb.vec4[(MAX_CLUSTERED_LIGHTS + 1) * 3]().uniformBuffer(0);
                scope[UNIFORM_NAME_LIGHT_INDEX_TEXTURE] = (pb.getDevice().type === 'webgl' ? pb.tex2D() : pb.utex2D()).uniform(0);
            }
            if (ctx.applyFog === 'scatter') {
                scope[UNIFORM_NAME_AERIALPERSPECTIVE_LUT] = pb.tex2D().uniform(0);
            }
            if (ctx.currentShadowLight) {
                const scope = pb.getGlobalScope();
                const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
                const tex = shadowMapParams.shadowMap.isTextureCube() ? shadowMapParams.shadowMap.isDepth() ? scope.$builder.texCubeShadow() : scope.$builder.texCube() : shadowMapParams.shadowMap.isTexture2D() ? shadowMapParams.shadowMap.isDepth() ? scope.$builder.tex2DShadow() : scope.$builder.tex2D() : shadowMapParams.shadowMap.isDepth() ? scope.$builder.tex2DArrayShadow() : scope.$builder.tex2DArray();
                if (!shadowMapParams.shadowMap.isDepth() && !ctx.device.getDeviceCaps().textureCaps.getTextureFormatInfo(shadowMapParams.shadowMap.format).filterable) {
                    tex.sampleType('unfilterable-float');
                }
                scope[UNIFORM_NAME_SHADOW_MAP] = tex.uniform(0);
            }
            ctx.drawEnvLight && ctx.env.light.envLight.initShaderBindings(pb);
        }
    }
    /**
   * This function checks if the shader needs to process skeletal animation.
   *
   * @param scope - Current shader scope
   *
   * @returns true if the shader needs to process skeletal animation, otherwise false.
   */ static hasSkinning(scope) {
        return !!scope[UNIFORM_NAME_BONE_MATRICES];
    }
    /**
   * Calculate skinning matrix for current vertex
   *
   * @param scope - Current shader scope
   *
   * @returns Skinning matrix for current vertex, or null if there is not skeletal animation
   */ static calculateSkinMatrix(scope) {
        if (!this.hasSkinning(scope)) {
            return null;
        }
        const pb = scope.$builder;
        const funcNameGetBoneMatrixFromTexture = 'Z_getBoneMatrixFromTexture';
        pb.func(funcNameGetBoneMatrixFromTexture, [
            pb.int('boneIndex')
        ], function() {
            const boneTexture = this[UNIFORM_NAME_BONE_MATRICES];
            this.$l.w = pb.float(this[UNIFORM_NAME_BONE_TEXTURE_SIZE]);
            this.$l.pixelIndex = pb.float(pb.mul(this.boneIndex, 4));
            this.$l.xIndex = pb.mod(this.pixelIndex, this.w);
            this.$l.yIndex = pb.floor(pb.div(this.pixelIndex, this.w));
            this.$l.u1 = pb.div(pb.add(this.xIndex, 0.5), this.w);
            this.$l.u2 = pb.div(pb.add(this.xIndex, 1.5), this.w);
            this.$l.u3 = pb.div(pb.add(this.xIndex, 2.5), this.w);
            this.$l.u4 = pb.div(pb.add(this.xIndex, 3.5), this.w);
            this.$l.v = pb.div(pb.add(this.yIndex, 0.5), this.w);
            this.$l.row1 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u1, this.v), 0);
            this.$l.row2 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u2, this.v), 0);
            this.$l.row3 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u3, this.v), 0);
            this.$l.row4 = pb.textureSampleLevel(boneTexture, pb.vec2(this.u4, this.v), 0);
            this.$return(pb.mat4(this.row1, this.row2, this.row3, this.row4));
        });
        const funcNameGetSkinningMatrix = 'Z_getSkinningMatrix';
        pb.func(funcNameGetSkinningMatrix, [], function() {
            const invBindMatrix = this[UNIFORM_NAME_BONE_INV_BIND_MATRIX];
            const blendIndices = scope.$getVertexAttrib('blendIndices');
            const blendWeights = scope.$getVertexAttrib('blendWeights');
            this.$l.m0 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[0]));
            this.$l.m1 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[1]));
            this.$l.m2 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[2]));
            this.$l.m3 = scope.$g[funcNameGetBoneMatrixFromTexture](pb.int(blendIndices[3]));
            this.$l.m = pb.add(pb.mul(this.m0, blendWeights.x), pb.mul(this.m1, blendWeights.y), pb.mul(this.m2, blendWeights.z), pb.mul(this.m3, blendWeights.w));
            this.$return(pb.mul(invBindMatrix, this.m));
        });
        return scope.$g[funcNameGetSkinningMatrix]();
    }
    /**
   * Calculates the vertex position of type vec3 in object space
   *
   * @param scope - Current shader scope
   * @param pos - Vertex position input, must be type of vec3, null if no vertex position input
   * @param skinMatrix - The skinning matrix if there is skeletal animation, otherwise null
   * @returns The calculated vertex position in object space, or null if pos is null
   */ static resolveVertexPosition(scope, pos) {
        const pb = scope.$builder;
        if (pb.shaderKind !== 'vertex') {
            throw new Error(`ShaderHelper.resolveVertexPosition(): must be called at vertex stage`);
        }
        const funcScope = pb.getCurrentFunctionScope();
        if (!funcScope || !funcScope.$isMain()) {
            throw new Error(`ShaderHelper.resolveVertexPosition(): must be called at entry function`);
        }
        if (!pos) {
            if (!scope.$getVertexAttrib('position')) {
                scope.$inputs.Z_pos = pb.vec3().attrib('position');
            }
            pos = scope.$getVertexAttrib('position');
        }
        if (this.hasSkinning(scope)) {
            if (!funcScope[this.SKIN_MATRIX_NAME]) {
                funcScope[this.SKIN_MATRIX_NAME] = this.calculateSkinMatrix(funcScope);
            }
            return pb.mul(scope[this.SKIN_MATRIX_NAME], pb.vec4(pos, 1)).xyz;
        } else {
            return pos;
        }
    }
    /**
   * Calculates the normal vector of type vec3 in object space
   *
   * @param scope - Current shader scope
   * @param normal - Vertex normal input, must be type of vec3, null if no vertex normal input
   * @param skinMatrix - The skinning matrix if there is skeletal animation, otherwise null
   * @returns The calculated normal vector in object space, or null if normal is null
   */ static resolveVertexNormal(scope, normal) {
        const pb = scope.$builder;
        if (pb.shaderKind !== 'vertex') {
            throw new Error(`ShaderHelper.resolveVertexNormal(): must be called in vertex stage`);
        }
        const funcScope = pb.getCurrentFunctionScope();
        if (!funcScope || !funcScope.$isMain()) {
            throw new Error(`ShaderHelper.resolveVertexNormal(): must be called at entry function`);
        }
        if (!normal) {
            if (!scope.$getVertexAttrib('normal')) {
                scope.$inputs.Z_normal = pb.vec3().attrib('normal');
            }
            normal = scope.$getVertexAttrib('normal');
        }
        if (this.hasSkinning(scope)) {
            if (!funcScope[this.SKIN_MATRIX_NAME]) {
                funcScope[this.SKIN_MATRIX_NAME] = this.calculateSkinMatrix(funcScope);
            }
            return pb.mul(scope[this.SKIN_MATRIX_NAME], pb.vec4(normal, 0)).xyz;
        } else {
            return normal;
        }
    }
    /**
   * Calculates the tangent vector of type vec3 in object space
   *
   * @param scope - Current shader scope
   * @param tangent - Vertex tangent input, must be type of vec4, null if no vertex tangent input
   * @param skinMatrix - The skinning matrix if there is skeletal animation, otherwise null
   * @returns The calculated tangent vector of type vec4 in object space, or null if tangent is null
   */ static resolveVertexTangent(scope, tangent) {
        const pb = scope.$builder;
        if (pb.shaderKind !== 'vertex') {
            throw new Error(`ShaderHelper.resolveVertexTangent(): must be called in vertex stage`);
        }
        const funcScope = pb.getCurrentFunctionScope();
        if (!funcScope || !funcScope.$isMain()) {
            throw new Error(`ShaderHelper.resolveVertexTangent(): must be called at entry function`);
        }
        if (!tangent) {
            if (!scope.$getVertexAttrib('tangent')) {
                scope.$inputs.Z_tangent = pb.vec4().attrib('tangent');
            }
            tangent = scope.$getVertexAttrib('tangent');
        }
        if (this.hasSkinning(scope)) {
            if (!funcScope[this.SKIN_MATRIX_NAME]) {
                funcScope[this.SKIN_MATRIX_NAME] = this.calculateSkinMatrix(funcScope);
            }
            return pb.vec4(pb.mul(scope[this.SKIN_MATRIX_NAME], pb.vec4(tangent.xyz, 0)).xyz, tangent.w);
        } else {
            return tangent;
        }
    }
    /**
   * Gets the uniform variable of type mat4 which holds the world matrix of current object to be drawn
   * @param scope - Current shader scope
   * @returns The world matrix of current object to be drawn
   */ static getWorldMatrix(scope) {
        const pb = scope.$builder;
        return scope[UNIFORM_NAME_WORLD_MATRIX] ?? pb.mat4(this.getInstancedUniform(scope, 0), this.getInstancedUniform(scope, 1), this.getInstancedUniform(scope, 2), this.getInstancedUniform(scope, 3));
    }
    /**
   * Gets the instance uniform value of type vec4 by uniform index
   * @param scope - Current shader scope
   * @returns instance uniform value
   */ static getInstancedUniform(scope, uniformIndex) {
        const pb = scope.$builder;
        return scope[UNIFORM_NAME_INSTANCE_DATA].at(pb.add(pb.mul(scope[UNIFORM_NAME_INSTANCE_DATA_STRIDE], pb.uint(scope.$builtins.instanceIndex)), scope[UNIFORM_NAME_INSTANCE_DATA_OFFSET], uniformIndex));
    }
    /**
   * Gets the uniform variable of type mat4 which holds the normal matrix of current object to be drawn
   *
   * @param scope - Current shader scope
   * @returns The normal matrix of current object to be drawn
   */ static getNormalMatrix(scope) {
        return this.getWorldMatrix(scope);
    }
    /**
   * Vertex shader drawable stuff
   *
   * @param scope - Current shader scope
   * @param skinning - true if skinning is used, otherwise false.
   * @param instanced - true if instancing is used, otherwise false.
   */ static vertexShaderDrawableStuff(scope, skinning, instanced) {
        const pb = scope.$builder;
        if (instanced) {
            scope[UNIFORM_NAME_INSTANCE_DATA_STRIDE] = pb.uint().uniform(1);
            scope[UNIFORM_NAME_INSTANCE_DATA_OFFSET] = pb.uint().uniform(1);
            scope[UNIFORM_NAME_INSTANCE_DATA] = pb.vec4[65536 >> 4]().uniformBuffer(3);
        } else {
            scope[UNIFORM_NAME_WORLD_MATRIX] = pb.mat4().uniform(1);
        }
        if (skinning) {
            scope[UNIFORM_NAME_BONE_MATRICES] = pb.tex2D().uniform(1).sampleType('unfilterable-float');
            scope[UNIFORM_NAME_BONE_INV_BIND_MATRIX] = pb.mat4().uniform(1);
            scope[UNIFORM_NAME_BONE_TEXTURE_SIZE] = pb.int().uniform(1);
        }
    }
    /** @internal */ static prepareVertexShaderCommon(pb, ctx) {
        this.vertexShaderDrawableStuff(pb.getGlobalScope(), !!ctx.skinAnimation, !!ctx.instancing);
    /*
    const skinning = !!ctx.target?.getBoneMatrices();
    const scope = pb.getGlobalScope();
    if (ctx.instanceData) {
      scope[UNIFORM_NAME_INSTANCE_DATA_STRIDE] = pb.uint().uniform(1);
      scope[UNIFORM_NAME_INSTANCE_DATA_OFFSET] = pb.uint().uniform(1);
      scope[UNIFORM_NAME_INSTANCE_DATA] = pb.vec4[65536 >> 4]().uniformBuffer(3);
    } else {
      scope[UNIFORM_NAME_WORLD_MATRIX] = pb.mat4().uniform(1);
    }
    if (skinning) {
      scope[UNIFORM_NAME_BONE_MATRICES] = pb.tex2D().uniform(1).sampleType('unfilterable-float');
      scope[UNIFORM_NAME_BONE_INV_BIND_MATRIX] = pb.mat4().uniform(1);
      scope[UNIFORM_NAME_BONE_TEXTURE_SIZE] = pb.int().uniform(1);
    }
    */ }
    /** @internal */ static setCameraUniforms(bindGroup, camera, flip, linear) {
        const pos = camera.getWorldPosition();
        const cameraStruct = {
            position: new Vector4(pos.x, pos.y, pos.z, camera.clipPlane ? 1 : 0),
            clipPlane: camera.clipPlane ?? Vector4.zero(),
            viewProjectionMatrix: camera.viewProjectionMatrix,
            viewMatrix: camera.viewMatrix,
            projectionMatrix: camera.getProjectionMatrix(),
            params: new Vector4(camera.getNearPlane(), camera.getFarPlane(), flip ? -1 : 1, linear ? 0 : 1)
        };
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, {
            camera: cameraStruct
        });
    }
    /** @internal */ static setLightUniformsShadowMap(bindGroup, ctx, light) {
        if (light) {
            const shadowMapParams = ctx.shadowMapInfo.get(light);
            bindGroup.setValue(UNIFORM_NAME_GLOBAL, {
                light: {
                    positionAndRange: light.positionAndRange,
                    directionCutoff: light.directionAndCutoff,
                    viewMatrix: light.viewMatrix,
                    depthBias: shadowMapParams.depthBiasValues[0],
                    lightType: light.lightType
                }
            });
        }
    }
    /** @internal */ static setFogUniforms(bindGroup, fogType, fogColor, fogParams, apDensity, aerialPerspectiveLUT) {
        this._fogUniforms.fog.fogColor = fogColor;
        this._fogUniforms.fog.fogParams = fogParams;
        this._fogUniforms.fog.fogType = fogType;
        this._fogUniforms.fog.apDensity = apDensity;
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, this._fogUniforms);
        if (aerialPerspectiveLUT) {
            bindGroup.setTexture(UNIFORM_NAME_AERIALPERSPECTIVE_LUT, aerialPerspectiveLUT);
        }
    }
    /** @internal */ static setLightUniforms(bindGroup, ctx, clusterParams, countParams, lightBuffer, lightIndexTexture) {
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, {
            light: {
                sunDir: ctx.sunLight ? ctx.sunLight.directionAndCutoff.xyz().scaleBy(-1) : this.defaultSunDir,
                clusterParams: clusterParams,
                countParams: countParams,
                envLightStrength: ctx.env.light.strength ?? 0,
                lightIndexTexSize: new Int32Array([
                    lightIndexTexture.width,
                    lightIndexTexture.height
                ])
            }
        });
        bindGroup.setBuffer(UNIFORM_NAME_LIGHT_BUFFER, lightBuffer);
        bindGroup.setTexture(UNIFORM_NAME_LIGHT_INDEX_TEXTURE, lightIndexTexture);
        ctx.drawEnvLight && ctx.env.light.envLight.updateBindGroup(bindGroup);
    }
    /** @internal */ static setLightUniformsShadow(bindGroup, ctx, light) {
        const shadowMapParams = ctx.shadowMapInfo.get(light);
        this._lightUniformShadow.light.sunDir = ctx.sunLight ? ctx.sunLight.directionAndCutoff.xyz().scaleBy(-1) : this.defaultSunDir, this._lightUniformShadow.light.envLightStrength = ctx.env?.light.strength ?? 0;
        this._lightUniformShadow.light.shadowCascades = shadowMapParams.numShadowCascades;
        this._lightUniformShadow.light.positionAndRange.set(light.positionAndRange);
        this._lightUniformShadow.light.directionAndCutoff.set(light.directionAndCutoff);
        this._lightUniformShadow.light.diffuseAndIntensity.set(light.diffuseAndIntensity);
        this._lightUniformShadow.light.cascadeDistances.set(shadowMapParams.cascadeDistances);
        this._lightUniformShadow.light.depthBiasValues.set(shadowMapParams.depthBiasValues[0]);
        this._lightUniformShadow.light.shadowCameraParams.set(shadowMapParams.cameraParams);
        this._lightUniformShadow.light.depthBiasScales.set(shadowMapParams.depthBiasScales);
        this._lightUniformShadow.light.shadowMatrices.set(shadowMapParams.shadowMatrices);
        bindGroup.setValue(UNIFORM_NAME_GLOBAL, this._lightUniformShadow);
        bindGroup.setTexture(UNIFORM_NAME_SHADOW_MAP, shadowMapParams.shadowMap, shadowMapParams.shadowMapSampler);
        ctx.drawEnvLight && ctx.env.light.envLight.updateBindGroup(bindGroup);
    }
    /**
   * Gets the uniform variable of type float which holds the strength of the environment light
   *
   * @remarks
   * This function can only be used in the fragment shader
   *
   * @param scope - Current shader scope
   * @returns The uniform variable of which presents the strength of the environment light
   */ static getEnvLightStrength(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.envLightStrength;
    }
    /**
   * Gets the uniform variable of type vec3 which holds the camera position
   * @param scope - Current shader scope
   * @returns The camera position
   */ static getCameraPosition(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.position.xyz;
    }
    /**
   * Discard the fragment if it was clipped by the clip plane
   * @param scope - Current shader scope
   */ static discardIfClipped(scope, worldPos) {
        const funcName = 'Z_discardIfClippped';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcName, [
            pb.vec3('worldPos')
        ], function() {
            this.$if(pb.notEqual(that.getCameraClipPlaneFlag(this), 0), function() {
                this.$l.clipPlane = that.getCameraClipPlane(this);
                this.$if(pb.greaterThan(pb.add(pb.dot(this.worldPos.xyz, this.clipPlane.xyz), this.clipPlane.w), 0), function() {
                    pb.discard();
                });
            });
        });
        pb.getGlobalScope()[funcName](worldPos);
    }
    /**
   * Gets the clip plane flag
   * @param scope - Current shader scope
   * @returns A float value of 1 indices the clip plane presents, otherwise 0
   */ static getCameraClipPlaneFlag(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.position.w;
    }
    /**
   * Gets the clip plane
   * @param scope - Current shader scope
   * @returns A vec4 presents the clip plane
   */ static getCameraClipPlane(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.clipPlane;
    }
    /**
   * Gets the uniform variable of type vec4 which holds the camera parameters
   * @param scope - Current shader scope
   * @returns The camera parameters
   */ static getCameraParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.params;
    }
    /**
   * Gets the uniform variable of type vec4 which holds the fog color
   * @param scope - Current shader scope
   * @returns The fog color
   */ static getFogColor(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.fogColor;
    }
    /** @internal */ static getClusterParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.clusterParams;
    }
    /** @internal */ static getCountParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.countParams;
    }
    /** @internal */ static getClusteredLightIndexTexture(scope) {
        return scope[UNIFORM_NAME_LIGHT_INDEX_TEXTURE];
    }
    /**
   * Gets the uniform variable of type vec4 which holds the fog color
   * @param scope - Current shader scope
   * @returns The fog color
   */ static getFogType(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.fogType;
    }
    /**
   * Gets the aerial perspective LUT
   * @param scope - Current shader scope
   * @returns The aerial perspective LUT texture
   */ static getAerialPerspectiveLUT(scope) {
        return scope[UNIFORM_NAME_AERIALPERSPECTIVE_LUT];
    }
    /**
   * Gets the uniform variable of type vec4 which holds the fog parameters
   * @param scope - Current shader scope
   * @returns The fog parameters
   */ static getFogParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.fogParams;
    }
    /**
   * Gets the uniform variable of type float which holds the aerial perspective density
   * @param scope - Current shader scope
   * @returns aerial perspective density
   */ static getAPDensity(scope) {
        return scope[UNIFORM_NAME_GLOBAL].fog.apDensity;
    }
    /**
   * Computes the fog factor for a given view vector
   * @param scope - Current shader scope
   * @param viewDir - the view vector
   * @param fogType - Type of the fog
   * @param fogParams - Fog parameters [start, end, top, density]
   * @returns The computed fog factor
   */ static computeFogFactor(scope, viewDir, fogType, fogParams) {
        const pb = scope.$builder;
        const funcName = 'Z_computeFogFactor';
        const that = this;
        pb.func(funcName, [
            pb.vec3('viewDir'),
            pb.int('fogType'),
            pb.vec4('fogParams')
        ], function() {
            this.$l.distance = pb.length(this.viewDir);
            this.$l.top = pb.max(this.viewDir.y, 0.0001);
            this.$l.distance = pb.mul(this.$l.distance, pb.min(1, pb.div(this.fogParams.z, this.top)));
            this.$if(pb.equal(this.fogType, that.FOG_TYPE_LINEAR), function() {
                this.$return(pb.clamp(pb.div(pb.sub(this.distance, this.fogParams.x), pb.sub(this.fogParams.y, this.fogParams.x)), 0, 1));
            }).$elseif(pb.equal(this.fogType, that.FOG_TYPE_EXP), function() {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(this.e))));
            }).$elseif(pb.equal(this.fogType, that.FOG_TYPE_EXP2), function() {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(pb.mul(this.e, this.e)))));
            }).$else(function() {
                this.$return(0);
            });
        });
        return pb.getGlobalScope()[funcName](viewDir, fogType, fogParams);
    }
    /**
   * Computes the fog factor with given type for a given view vector
   * @param scope - Current shader scope
   * @param viewDir - the view vector
   * @param fogParams - The fog params [start, end, top, density]
   * @param fogType - Type of the fog
   * @returns The computed fog factor
   */ static computeFogFactorForType(scope, viewDir, fogParams, fogType) {
        const pb = scope.$builder;
        const funcName = `Z_computeFogFactor${fogType[0].toUpperCase()}${fogType.slice(1)}`;
        pb.func(funcName, [
            pb.vec3('viewDir'),
            pb.vec4('fogParams')
        ], function() {
            this.$l.distance = pb.length(this.viewDir);
            this.$l.top = pb.max(this.viewDir.y, 0.0001);
            this.$l.distance = pb.mul(this.$l.distance, pb.min(1, pb.div(this.fogParams.z, this.top)));
            if (fogType === 'linear') {
                this.$return(pb.clamp(pb.div(pb.sub(this.distance, this.fogParams.x), pb.sub(this.fogParams.y, this.fogParams.x)), 0, 1));
            } else if (fogType === 'exp') {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(this.e))));
            } else if (fogType === 'exp2') {
                this.$l.e = pb.mul(this.distance, this.fogParams.w);
                this.$return(pb.sub(1, pb.div(1, pb.exp(pb.mul(this.e, this.e)))));
            } else {
                this.$return(0);
            }
        });
        return pb.getGlobalScope()[funcName](viewDir, fogParams);
    }
    /**
   * Gets the uniform variable of type mat4 which holds the view projection matrix of current camera
   * @param scope - Current shader scope
   * @returns The view projection matrix of current camera
   */ static getViewProjectionMatrix(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.viewProjectionMatrix;
    }
    /**
   * Gets the uniform variable of type mat4 which holds the view matrix of current camera
   * @param scope - Current shader scope
   * @returns The view matrix of current camera
   */ static getViewMatrix(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.viewMatrix;
    }
    /**
   * Gets the uniform variable of type mat4 which holds the projection matrix of current camera
   * @param scope - Current shader scope
   * @returns The projection matrix of current camera
   */ static getProjectionMatrix(scope) {
        return scope[UNIFORM_NAME_GLOBAL].camera.projectionMatrix;
    }
    /** @internal */ static getCascadeDistances(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.cascadeDistances;
    }
    /** @internal */ static getDepthBiasValues(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.depthBiasValues;
    }
    /** @internal */ static getShadowCameraParams(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.shadowCameraParams;
    }
    /** @internal */ static getDepthBiasScales(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.depthBiasScales;
    }
    /** @internal */ static getNumLights(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.numLights;
    }
    /** @internal */ static getSunLightDir(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.sunDir;
    }
    /** @internal */ static getLightTypeForShadow(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.lightType;
    }
    /** @internal */ static getLightPositionAndRangeForShadow(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.positionAndRange;
    }
    /** @internal */ static getLightViewMatrixForShadow(scope) {
        return scope[UNIFORM_NAME_GLOBAL].light.viewMatrix;
    }
    /** @internal */ static calculateShadowSpaceVertex(scope, worldPos, cascade = 0) {
        const pb = scope.$builder;
        return pb.vec4(pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 0)), worldPos), pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 1)), worldPos), pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 2)), worldPos), pb.dot(scope[UNIFORM_NAME_GLOBAL].light.shadowMatrices.at(pb.add(pb.mul(cascade, 4), 3)), worldPos));
    }
    /** @internal */ static getLightPositionAndRange(scope, lightIndex) {
        return scope[UNIFORM_NAME_LIGHT_BUFFER].at(scope.$builder.mul(lightIndex, 3));
    }
    /** @internal */ static getLightDirectionAndCutoff(scope, lightIndex) {
        return scope[UNIFORM_NAME_LIGHT_BUFFER].at(scope.$builder.add(scope.$builder.mul(lightIndex, 3), 1));
    }
    /** @internal */ static getLightColorAndIntensity(scope, lightIndex) {
        return scope[UNIFORM_NAME_LIGHT_BUFFER].at(scope.$builder.add(scope.$builder.mul(lightIndex, 3), 2));
    }
    /**
   * Sets the clip space position in vertex shader
   *
   * @remarks
   * Use this function instead of using
   * <pre>
   * // Do not use this
   * this.$builtins.position = some_value;
   * // Use this
   * ShaderFramework.setClipSpacePosition(some_value);
   * </pre>,
   *
   * @param scope - Current shader scope
   * @param pos - The clip space position to be set
   */ static setClipSpacePosition(scope, pos) {
        const pb = scope.$builder;
        const cameraParams = this.getCameraParams(scope);
        if (cameraParams) {
            scope.$builtins.position = pb.mul(pos, pb.vec4(1, cameraParams.z, 1, 1));
        } else {
            scope.$builtins.position = pos;
        }
    }
    /**
   * Get global uniforms
   *
   * @param scope - Shader scope
   */ static getGlobalUniforms(scope) {
        return scope[UNIFORM_NAME_GLOBAL];
    }
    /**
   * Get shadow map uniform value
   *
   * @param scope - Shader scope
   * @returns The shadow map texture uniform
   */ static getShadowMap(scope) {
        return scope[UNIFORM_NAME_SHADOW_MAP];
    }
    /**
   * Calculates shadow of current fragment
   *
   * @param scope - Shader scope
   * @param NoL - NdotL vector
   * @returns Shadow of current fragment, 1 means no shadow and 0 means full shadowed.
   */ static calculateShadow(scope, worldPos, NoL, ctx) {
        const pb = scope.$builder;
        const that = this;
        const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
        const funcName = 'Z_calculateShadow';
        pb.func(funcName, [
            pb.vec3('worldPos'),
            pb.float('NoL')
        ], function() {
            if (shadowMapParams.numShadowCascades > 1) {
                this.$l.shadowCascades = that.getGlobalUniforms(this).light.shadowCascades;
                this.$l.shadowBound = pb.vec4(0, 0, 1, 1);
                this.$l.linearDepth = that.nonLinearDepthToLinear(this, this.$builtins.fragCoord.z);
                this.$l.splitDistances = that.getCascadeDistances(this);
                this.$l.comparison = pb.vec4(pb.greaterThan(pb.vec4(this.linearDepth), this.splitDistances));
                this.$l.cascadeFlags = pb.vec4(pb.float(pb.greaterThan(this.shadowCascades, 0)), pb.float(pb.greaterThan(this.shadowCascades, 1)), pb.float(pb.greaterThan(this.shadowCascades, 2)), pb.float(pb.greaterThan(this.shadowCascades, 3)));
                this.$l.split = pb.int(pb.dot(this.comparison, this.cascadeFlags));
                if (ctx.device.type === 'webgl') {
                    this.$l.shadowVertex = pb.vec4();
                    this.$for(pb.int('cascade'), 0, 4, function() {
                        this.$if(pb.equal(this.cascade, this.split), function() {
                            this.shadowVertex = that.calculateShadowSpaceVertex(this, pb.vec4(this.worldPos, 1), this.cascade);
                            this.$break();
                        });
                    });
                } else {
                    this.$l.shadowVertex = that.calculateShadowSpaceVertex(this, pb.vec4(this.worldPos, 1), this.split);
                }
                const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
                this.$l.shadow = shadowMapParams.impl.computeShadowCSM(shadowMapParams, this, this.shadowVertex, this.NoL, this.split);
                this.$l.shadowDistance = that.getShadowCameraParams(scope).w;
                this.shadow = pb.mix(this.shadow, 1, pb.smoothStep(pb.mul(this.shadowDistance, 0.8), this.shadowDistance, pb.distance(that.getCameraPosition(this), this.worldPos)));
                this.$return(this.shadow);
            } else {
                this.$l.shadowVertex = that.calculateShadowSpaceVertex(this, pb.vec4(this.worldPos, 1));
                const shadowMapParams = ctx.shadowMapInfo.get(ctx.currentShadowLight);
                this.$l.shadow = shadowMapParams.impl.computeShadow(shadowMapParams, this, this.shadowVertex, this.NoL);
                this.$l.shadowDistance = that.getShadowCameraParams(scope).w;
                this.shadow = pb.mix(this.shadow, 1, pb.smoothStep(pb.mul(this.shadowDistance, 0.8), this.shadowDistance, pb.distance(that.getCameraPosition(this), this.worldPos)));
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcName](worldPos, NoL);
    }
    static applyFog(scope, worldPos, color, ctx) {
        const pb = scope.$builder;
        const that = this;
        if (ctx.applyFog === 'scatter') {
            const funcName = 'Z_applySkyFog';
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec4('color').inout()
            ], function() {
                this.$l.viewDir = pb.sub(this.worldPos, that.getCameraPosition(this));
                this.viewDir.y = pb.max(this.viewDir.y, 0);
                this.$l.distance = pb.mul(pb.length(this.viewDir), that.getAPDensity(this));
                this.$l.sliceDist = pb.div(pb.mul(that.getCameraParams(this).y, that.getAPDensity(this)), ScatteringLut.aerialPerspectiveSliceZ);
                this.$l.slice0 = pb.floor(pb.div(this.distance, this.sliceDist));
                this.$l.slice1 = pb.add(this.slice0, 1);
                this.$l.factor = pb.sub(pb.div(this.distance, this.sliceDist), this.slice0);
                this.$l.viewNormal = pb.normalize(this.viewDir);
                this.$l.horizonAngle = pb.acos(pb.clamp(pb.dot(pb.normalize(that.getSunLightDir(this).xz), pb.normalize(this.viewNormal.xz)), 0, 1));
                this.$l.zenithAngle = pb.asin(this.viewNormal.y);
                this.$l.sliceU = pb.max(pb.div(this.horizonAngle, Math.PI * 2), 0.5 / ScatteringLut.aerialPerspectiveSliceZ);
                this.$l.u0 = pb.div(pb.add(this.slice0, this.sliceU), ScatteringLut.aerialPerspectiveSliceZ);
                this.$l.u1 = pb.add(this.u0, 1 / ScatteringLut.aerialPerspectiveSliceZ);
                this.$l.v = pb.div(this.zenithAngle, Math.PI / 2);
                this.$l.t0 = pb.textureSampleLevel(that.getAerialPerspectiveLUT(this), pb.vec2(this.u0, this.v), 0);
                this.$l.t1 = pb.textureSampleLevel(that.getAerialPerspectiveLUT(this), pb.vec2(this.u1, this.v), 0);
                this.$l.t = pb.mix(this.t0, this.t1, this.factor);
                this.color = pb.vec4(pb.add(pb.mul(this.color.rgb, this.t.a), this.t.rgb), this.color.a);
            //this.color = pb.vec4(pb.vec3(pb.mix(this.u0, this.u1, this.factor)), this.color.a);
            });
            scope[funcName](worldPos, color);
        } else if (ctx.applyFog) {
            const funcName = 'Z_applyFog';
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec4('color').inout()
            ], function() {
                this.$l.viewDir = pb.sub(this.worldPos, that.getCameraPosition(this));
                this.$l.fogFactor = that.computeFogFactor(this, this.viewDir, that.getFogType(this), that.getFogParams(this));
                this.color = pb.vec4(pb.mix(this.color.rgb, that.getFogColor(this).rgb, this.fogFactor), this.color.a);
            });
            scope[funcName](worldPos, color);
        }
    }
    /**
   * Calculates the non-linear depth from linear depth
   *
   * @param scope - Current shader scope
   * @param depth - The linear depth
   * @param nearFar - A vector that contains the near clip plane in x component and the far clip plane in y component
   * @returns The calculated non-linear depth
   */ static linearDepthToNonLinear(scope, depth, nearFar) {
        const pb = scope.$builder;
        nearFar = nearFar ?? this.getCameraParams(scope);
        return pb.div(pb.sub(nearFar.y, pb.div(pb.mul(nearFar.x, nearFar.y), depth)), pb.sub(nearFar.y, nearFar.x));
    }
    /**
   * Calculates the linear depth from non-linear depth
   *
   * @param scope - Current shader scope
   * @param depth - The non-linear depth
   * @param nearFar - A vector that contains the near clip plane in x component and the far clip plane in y component
   * @returns The calculated linear depth
   */ static nonLinearDepthToLinear(scope, depth, nearFar) {
        const pb = scope.$builder;
        nearFar = nearFar ?? this.getCameraParams(scope);
        return pb.div(pb.mul(nearFar.x, nearFar.y), pb.mix(nearFar.y, nearFar.x, depth));
    }
    /**
   * Calculates the normalized linear depth from non-linear depth
   *
   * @param scope - Current shader scope
   * @param depth - The non-linear depth
   * @param nearFar - A vector that contains the near clip plane in x component and the far clip plane in y component
   * @returns The calculated normalized linear depth
   */ static nonLinearDepthToLinearNormalized(scope, depth, nearFar) {
        const pb = scope.$builder;
        nearFar = nearFar ?? this.getCameraParams(scope);
        return pb.div(nearFar.x, pb.mix(nearFar.y, nearFar.x, depth));
    }
    /**
   * Transform color to sRGB color space if nessesary
   *
   * @param scope - Current shader scope
   * @param outputColor - The color to be transformed
   * @returns The transformed color
   */ static encodeColorOutput(scope, outputColor) {
        const pb = scope.$builder;
        const that = this;
        const funcName = 'Z_encodeColorOutput';
        pb.func(funcName, [
            pb.vec4('outputColor')
        ], function() {
            const params = that.getCameraParams(this);
            this.$if(pb.notEqual(params.w, 0), function() {
                this.$return(pb.vec4(linearToGamma(this, this.outputColor.rgb), this.outputColor.w));
            }).$else(function() {
                this.$return(this.outputColor);
            });
        });
        return pb.getGlobalScope()[funcName](outputColor);
    }
}

/**
 * Base class for any kind of materials
 *
 * @public
 */ class Material {
    /** @internal */ static _nextId = 0;
    /** @internal */ _states;
    /** @internal */ _numPasses;
    /** @internal */ _hash;
    /** @internal */ _optionTag;
    /** @internal */ _id;
    /** @internal */ _currentHash;
    /**
   * Creates an instance of material
   */ constructor(){
        this._id = ++Material._nextId;
        this._states = {};
        this._numPasses = 1;
        this._hash = [
            null
        ];
        this._optionTag = 0;
        this._currentHash = [];
    }
    /** Unique identifier of the material */ get instanceId() {
        return this._id;
    }
    get numPasses() {
        return this._numPasses;
    }
    set numPasses(val) {
        while(this._hash.length < val){
            this._hash.push(null);
        }
        this._numPasses = val;
    }
    /** @internal */ getHash(pass) {
        if (this._hash[pass] === null) {
            this._hash[pass] = this.createHash(pass);
        }
        return this._hash[pass];
    }
    getQueueType() {
        return QUEUE_OPAQUE;
    }
    /** Returns true if given pass is transparent */ isTransparentPass(pass) {
        return false;
    }
    /** Returns true if shading of the material will be affected by lights  */ supportLighting() {
        return true;
    }
    /** Returns true if this material supports geometry instancing  */ supportInstancing() {
        return true;
    }
    /** Returns true if this material supports geometry instancing  */ isBatchable() {
        return false;
    }
    /** @internal */ get coreMaterial() {
        return this;
    }
    /**
   * Apply material
   * @param ctx - Draw context
   * @returns true if no error, otherwise false
   */ apply(ctx) {
        for(let pass = 0; pass < this._numPasses; pass++){
            const hash = this.calcGlobalHash(ctx, pass);
            let state = this._states[hash];
            if (!state) {
                const program = this.createProgram(ctx, pass) ?? null;
                const bindGroup = program.bindGroupLayouts.length > 2 ? ctx.device.createBindGroup(program.bindGroupLayouts[2]) : null;
                state = {
                    program,
                    bindGroup,
                    renderStateSet: ctx.device.createRenderStateSet(),
                    materialTag: -1
                };
                this._states[hash] = state;
            }
            if (!state.program) {
                return false;
            }
            this.applyUniforms(state.bindGroup, ctx, state.materialTag !== this._optionTag, pass);
            state.materialTag = this._optionTag;
            this.updateRenderStates(pass, state.renderStateSet, ctx);
            this._currentHash[pass] = hash;
        }
    }
    /** @internal */ bind(device, pass) {
        const hash = this._currentHash[pass];
        const state = this._states[hash];
        if (!state) {
            console.error('Material.bind() failed: state not found');
            return false;
        }
        if (!state.program) {
            return false;
        }
        device.setProgram(state.program);
        device.setBindGroup(2, state.bindGroup);
        device.setRenderStates(state.renderStateSet);
    }
    /** @internal */ calcGlobalHash(ctx, pass) {
        return `${this.getHash(pass)}:${Number(!!ctx.skinAnimation)}:${Number(!!ctx.instancing)}:${ctx.renderPassHash}`;
    }
    /**
   * Draws a primitive using this material
   * @internal
   *
   * @param primitive - The prmitive to be drawn
   * @param ctx - The context of current drawing task
   * @param numInstances - How many instances should be drawn. if zero, the instance count will be automatically detected.
   */ draw(primitive, ctx, numInstances = 0) {
        for(let pass = 0; pass < this._numPasses; pass++){
            this.bind(ctx.device, pass);
            this.drawPrimitive(pass, primitive, ctx, numInstances);
        }
    }
    /**
   * Sets all uniform values to the bind group of the material if needed
   * @param bindGroup - The bind group of the material
   * @param ctx - The context of current drawing task
   * @param needUpdate - true if the uniform values needs to update
   */ applyUniforms(bindGroup, ctx, needUpdate, pass) {
        if (needUpdate) {
            this._applyUniforms(bindGroup, ctx, pass);
        }
    }
    /** @internal */ optionChanged(changeHash) {
        this._optionTag++;
        if (changeHash) {
            for(let i = 0; i < this._numPasses; i++){
                this._hash[i] = null;
            }
        }
    }
    /**
   * Convert pass to hash
   * @param pass - pass number
   * @returns String hash
   */ passToHash(pass) {
        return String(pass);
    }
    /** @internal */ createHash(pass) {
        return `${this.constructor.name}|${pass}|${this._createHash()}`;
    }
    /**
   * Draw primitve
   *
   * @param primitive - Primitive to be drawn
   * @param ctx - Draw context
   */ drawPrimitive(pass, primitive, ctx, numInstances) {
        if (numInstances > 0) {
            primitive.drawInstanced(numInstances);
        } else if (ctx.instanceData) {
            primitive.drawInstanced(ctx.instanceData.numInstances);
        } else {
            primitive.draw();
        }
    }
    /** @internal */ createProgram(ctx, pass) {
        const pb = new ProgramBuilder(ctx.device);
        return this._createProgram(pb, ctx, pass);
    }
    /**
   * Creates the shader program
   * @param pb - The program builder
   * @param ctx - The drawing context
   * @param func - The material func
   * @returns The created shader program
   */ _createProgram(pb, ctx, pass) {
        return null;
    }
    /**
   * Applies uniform values
   * @param bindGroup - The bind group
   * @param ctx - The drawing context
   */ _applyUniforms(bindGroup, ctx, pass) {}
    /**
   * Update render states according to draw context and current material pass
   * @param pass - Current material pass
   * @param renderStates - Render state set to be updated
   * @param ctx - Draw context
   */ updateRenderStates(pass, renderStates, ctx) {}
    /**
   * Calculates the hash code of the shader program
   * @returns The hash code
   */ _createHash() {
        return '';
    }
    /**
   * True if this is a material instance
   * @internal
   **/ get $isInstance() {
        return false;
    }
    /**
   * Returns the instance uniforms if this is a material instance
   * @internal
   **/ get $instanceUniforms() {
        return null;
    }
}

/**
 * Apply material mixins to specific material class
 * @param target - Material class
 * @param mixins - mixins
 * @returns Mixed mesh material class
 *
 * @public
 */ function applyMaterialMixins(target, ...mixins) {
    return applyMixins(target, ...mixins);
}
let FEATURE_ALPHATEST = 0;
let FEATURE_ALPHABLEND = 0;
let FEATURE_ALPHATOCOVERAGE = 0;
/**
 * Base class for any kind of mesh materials
 *
 * @public
 */ class MeshMaterial extends Material {
    /** @internal */ static INSTANCE_UNIFORMS = [];
    /** @internal */ static NEXT_FEATURE_INDEX = 3;
    /** @internal */ _featureStates;
    /** @internal */ _alphaCutoff;
    /** @internal */ _blendMode;
    /** @internal */ _cullMode;
    /** @internal */ _opacity;
    /** @internal */ _ctx;
    /** @internal */ _materialPass;
    /**
   * Creates an instance of MeshMaterial class
   * @param args - constructor arguments
   */ constructor(...args){
        super();
        this._featureStates = [];
        this._alphaCutoff = 0;
        this._blendMode = 'none';
        this._cullMode = 'back';
        this._opacity = 1;
        this._ctx = null;
        this._materialPass = -1;
    }
    /** Indicate that the uniform has changed and needs to be resubmitted. */ uniformChanged() {
        this.optionChanged(false);
    }
    /** Define feature index */ static defineFeature() {
        const val = this.NEXT_FEATURE_INDEX;
        this.NEXT_FEATURE_INDEX++;
        return val;
    }
    /** Define instance uniform index */ static defineInstanceUniform(prop, type) {
        if (this.INSTANCE_UNIFORMS.findIndex((val)=>val[0] === prop) >= 0) {
            throw new Error(`${this.name}.defineInstanceUniform(): ${prop} was already defined`);
        }
        if (type !== 'float' && type !== 'vec2' && type !== 'vec3' && type !== 'vec4') {
            throw new Error(`${this.name}.defineInstanceUniform(): invalid uniform type ${type}`);
        }
        this.INSTANCE_UNIFORMS = [
            ...this.INSTANCE_UNIFORMS,
            [
                prop,
                type
            ]
        ];
        return this.INSTANCE_UNIFORMS.length - 1;
    }
    getInstancedUniform(scope, uniformIndex) {
        const pb = scope.$builder;
        const instanceID = scope.$builtins.instanceIndex;
        const uniformName = ShaderHelper.getInstanceDataUniformName();
        const strideName = ShaderHelper.getInstanceDataStrideUniformName();
        const offsetName = ShaderHelper.getInstanceDataOffsetUniformName();
        return scope[uniformName].at(pb.add(pb.mul(scope[strideName], instanceID), 4 + uniformIndex, scope[offsetName]));
    }
    /** Create material instance */ createInstance() {
        if (this.$isInstance) {
            return this.coreMaterial.createInstance();
        }
        const instanceUniforms = this.constructor.INSTANCE_UNIFORMS;
        const uniformsHolder = instanceUniforms.length > 0 ? new Float32Array(4 * instanceUniforms.length) : null;
        const isWebGL1 = Application.instance.device.type === 'webgl';
        const instance = {};
        const that = this;
        instance.isBatchable = ()=>!isWebGL1 && that.supportInstancing();
        instance.$instanceUniforms = uniformsHolder;
        instance.$isInstance = true;
        instance.coreMaterial = that;
        // Copy original uniform values
        for(let i = 0; i < instanceUniforms.length; i++){
            const [prop, type] = instanceUniforms[i];
            const value = that[prop];
            switch(type){
                case 'float':
                    {
                        uniformsHolder[i * 4] = Number(value);
                        Object.defineProperty(instance, prop, {
                            get () {
                                return uniformsHolder[i * 4];
                            },
                            set (value) {
                                uniformsHolder[i * 4 + 0] = value;
                                that[prop] = value;
                            }
                        });
                        break;
                    }
                case 'vec2':
                    {
                        if (!(value instanceof Vector2)) {
                            throw new Error(`Instance uniform property ${prop} must be of type Vector2`);
                        }
                        uniformsHolder[i * 4] = value.x;
                        uniformsHolder[i * 4 + 1] = value.y;
                        Object.defineProperty(instance, prop, {
                            get () {
                                return new Vector2(uniformsHolder[i * 4], uniformsHolder[i * 4 + 1]);
                            },
                            set (value) {
                                uniformsHolder.set(value);
                                that[prop] = value;
                            }
                        });
                        break;
                    }
                case 'vec3':
                    {
                        if (!(value instanceof Vector3)) {
                            throw new Error(`Instance uniform property ${prop} must be of type Vector3`);
                        }
                        uniformsHolder[i * 4] = value.x;
                        uniformsHolder[i * 4 + 1] = value.y;
                        uniformsHolder[i * 4 + 2] = value.z;
                        Object.defineProperty(instance, prop, {
                            get () {
                                return new Vector3(uniformsHolder[i * 4], uniformsHolder[i * 4 + 1], uniformsHolder[i * 4 + 2]);
                            },
                            set (value) {
                                uniformsHolder.set(value);
                                that[prop] = value;
                            }
                        });
                        break;
                    }
                case 'vec4':
                    {
                        if (!(value instanceof Vector4)) {
                            throw new Error(`Instance uniform property ${prop} must be of type Vector4`);
                        }
                        uniformsHolder[i * 4] = value.x;
                        uniformsHolder[i * 4 + 1] = value.y;
                        uniformsHolder[i * 4 + 2] = value.z;
                        uniformsHolder[i * 4 + 3] = value.w;
                        Object.defineProperty(instance, prop, {
                            get () {
                                return new Vector4(uniformsHolder[i * 4], uniformsHolder[i * 4 + 1], uniformsHolder[i * 4 + 2], uniformsHolder[i * 4 + 3]);
                            },
                            set (value) {
                                uniformsHolder.set(value);
                                that[prop] = value;
                            }
                        });
                        break;
                    }
            }
        }
        Object.setPrototypeOf(instance, that);
        return instance;
    }
    /** Draw context for shader creation */ get drawContext() {
        return this._ctx;
    }
    /** Current material pass */ get pass() {
        return this._materialPass;
    }
    /** A value between 0 and 1, presents the cutoff for alpha testing */ get alphaCutoff() {
        return this._alphaCutoff;
    }
    set alphaCutoff(val) {
        if (this._alphaCutoff !== val) {
            this.useFeature(FEATURE_ALPHATEST, val > 0);
            this._alphaCutoff = val;
            this.uniformChanged();
        }
    }
    get alphaToCoverage() {
        return this.featureUsed(FEATURE_ALPHATOCOVERAGE);
    }
    set alphaToCoverage(val) {
        this.useFeature(FEATURE_ALPHATOCOVERAGE, !!val);
    }
    /** Blending mode */ get blendMode() {
        return this._blendMode;
    }
    set blendMode(val) {
        if (this._blendMode !== val) {
            this._blendMode = val;
            this.useFeature(FEATURE_ALPHABLEND, this._blendMode !== 'none' || this._opacity < 1);
        }
    }
    /** Cull mode */ get cullMode() {
        return this._cullMode;
    }
    set cullMode(val) {
        this._cullMode = val;
    }
    /** A value between 0 and 1, presents the opacity */ get opacity() {
        return this._opacity;
    }
    set opacity(val) {
        val = val < 0 ? 0 : val > 1 ? 1 : val;
        if (this._opacity !== val) {
            this._opacity = val;
            this.useFeature(FEATURE_ALPHABLEND, this._blendMode !== 'none' || this._opacity < 1);
            this.uniformChanged();
        }
    }
    /** Returns true if shading of the material will be affected by lights  */ supportLighting() {
        return true;
    }
    /**
   * {@inheritDoc Material.updateRenderStates}
   */ updateRenderStates(pass, stateSet, ctx) {
        const blending = this.featureUsed(FEATURE_ALPHABLEND) || ctx.lightBlending;
        const a2c = this.featureUsed(FEATURE_ALPHATOCOVERAGE);
        if (blending || a2c) {
            const blendingState = stateSet.useBlendingState();
            if (blending) {
                blendingState.enable(true);
                blendingState.setBlendFuncAlpha('zero', 'one');
                blendingState.setBlendEquation('add', 'add');
                if (this._blendMode === 'additive' || ctx.lightBlending) {
                    blendingState.setBlendFuncRGB('one', 'one');
                } else {
                    blendingState.setBlendFuncRGB('one', 'inv-src-alpha');
                }
            } else {
                blendingState.enable(false);
            }
            blendingState.enableAlphaToCoverage(a2c);
            if (blendingState.enabled) {
                stateSet.useDepthState().enableTest(true).enableWrite(false);
            } else {
                stateSet.defaultDepthState();
            }
        } else if (stateSet.blendingState?.enabled && !blending) {
            stateSet.defaultBlendingState();
            stateSet.defaultDepthState();
        }
        if (this._cullMode !== 'back') {
            stateSet.useRasterizerState().cullMode = this._cullMode;
        } else {
            stateSet.defaultRasterizerState();
        }
        stateSet.defaultColorState();
        stateSet.defaultStencilState();
        if (ctx.oit) {
            ctx.oit.setRenderStates(stateSet);
        }
    }
    /**
   * Submit Uniform values before rendering with this material.
   *
   * @param bindGroup - Bind group for this material
   * @param ctx - Draw context
   * @param pass - Current pass of the material
   */ applyUniformValues(bindGroup, ctx, pass) {
        if (this.featureUsed(FEATURE_ALPHATEST)) {
            bindGroup.setValue('zAlphaCutoff', this._alphaCutoff);
        }
        if (this.isTransparentPass(pass)) {
            bindGroup.setValue('zOpacity', this._opacity);
        }
        if (ctx.oit) {
            ctx.oit.applyUniforms(ctx, bindGroup);
        }
    }
    /**
   * Determine which queue should be used to render this material.
   * @returns QUEUE_TRANSPARENT or QUEUE_OPAQUE
   */ getQueueType() {
        return this.isTransparentPass(0) ? QUEUE_TRANSPARENT : QUEUE_OPAQUE;
    }
    /**
   * Determine if a certain pass of this material is translucent.
   * @param pass - Pass of the material
   * @returns True if it is translucent, otherwise false.
   */ isTransparentPass(pass) {
        return this.featureUsed(FEATURE_ALPHABLEND);
    }
    /** @internal */ createProgram(ctx, pass) {
        const pb = new ProgramBuilder(ctx.device);
        if (ctx.renderPass.type === RENDER_PASS_TYPE_SHADOWMAP) {
            const shadowMapParams = ctx.shadowMapInfo.get(ctx.renderPass.light);
            pb.emulateDepthClamp = !!shadowMapParams.depthClampEnabled;
        }
        return this._createProgram(pb, ctx, pass);
    }
    /**
   * Check if a feature is in use for given render pass type.
   *
   * @param feature - The feature index
   * @returns true if the feature is in use, otherwise false.
   */ featureUsed(feature) {
        return this._featureStates[feature];
    }
    /**
   * Use or unuse a feature of the material, this will cause the shader to be rebuild.
   *
   * @param feature - Which feature will be used or unused
   * @param use - true if use the feature, otherwise false
   */ useFeature(feature, use) {
        if (this._featureStates[feature] !== use) {
            this._featureStates[feature] = use;
            this.optionChanged(true);
        }
    }
    /**
   * {@inheritDoc Material._createHash}
   * @override
   *
   * @internal
   */ _createHash() {
        return this._featureStates.map((val)=>val === undefined ? '' : val).join('|');
    }
    /**
   * {@inheritDoc Material._applyUniforms}
   * @override
   *
   * @internal
   */ _applyUniforms(bindGroup, ctx, pass) {
        this.applyUniformValues(bindGroup, ctx, pass);
    }
    /**
   * Check if the color should be computed in fragment shader, this is required for forward render pass or alpha test is in use or alpha to coverage is in use.
   *
   * @returns - true if the color should be computed in fragment shader, otherwise false.
   */ needFragmentColor(ctx) {
        return (ctx ?? this.drawContext).renderPass.type === RENDER_PASS_TYPE_LIGHT || this._alphaCutoff > 0 || this.alphaToCoverage;
    }
    /**
   * Vertex shader implementation of this material
   * @param scope - Shader scope
   */ vertexShader(scope) {
        const pb = scope.$builder;
        ShaderHelper.prepareVertexShader(pb, this.drawContext);
        if (this.drawContext.skinAnimation) {
            scope.$inputs.zBlendIndices = pb.vec4().attrib('blendIndices');
            scope.$inputs.zBlendWeights = pb.vec4().attrib('blendWeights');
        }
    }
    /**
   * Fragment shader implementation of this material
   * @param scope - Shader scope
   */ fragmentShader(scope) {
        const pb = scope.$builder;
        ShaderHelper.prepareFragmentShader(pb, this.drawContext);
        if (this._alphaCutoff > 0) {
            scope.zAlphaCutoff = pb.float().uniform(2);
        }
        if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
            if (this.isTransparentPass(this.pass)) {
                scope.zOpacity = pb.float().uniform(2);
            }
        }
    }
    /**
   * {@inheritDoc Material._createProgram}
   * @override
   *
   * @internal
   */ _createProgram(pb, ctx, pass) {
        const that = this;
        this._ctx = ctx;
        this._materialPass = pass;
        const program = pb.buildRenderProgram({
            vertex (pb) {
                pb.main(function() {
                    that.vertexShader(this);
                });
            },
            fragment (pb) {
                if (that.drawContext.oit) {
                    that.drawContext.oit.setupFragmentOutput(this);
                } else {
                    this.$outputs.zFragmentOutput = pb.vec4();
                }
                pb.main(function() {
                    that.fragmentShader(this);
                });
            }
        });
        /*
    if (program) {
      console.log(program.getShaderSource('vertex'));
      console.log(program.getShaderSource('fragment'));
    }
    */ return program;
    }
    doAlphaTest(scope, color) {}
    /**
   * Calculate final fragment color for output.
   *
   * @param scope - Shader scope
   * @param color - Lit fragment color
   *
   * @returns The final fragment color
   */ outputFragmentColor(scope, worldPos, color) {
        const pb = scope.$builder;
        const that = this;
        const funcName = 'Z_outputFragmentColor';
        pb.func(funcName, color ? [
            pb.vec3('worldPos'),
            pb.vec4('color')
        ] : [
            pb.vec3('worldPos')
        ], function() {
            this.$l.outColor = color ? this.color : pb.vec4();
            if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                ShaderHelper.discardIfClipped(this, this.worldPos);
                if (!that.isTransparentPass(that.pass) && !this.zAlphaCutoff && !that.alphaToCoverage) {
                    this.outColor.a = 1;
                } else if (this.zOpacity) {
                    this.outColor.a = pb.mul(this.outColor.a, this.zOpacity);
                }
                if (this.zAlphaCutoff) {
                    this.$if(pb.lessThan(this.outColor.a, this.zAlphaCutoff), function() {
                        pb.discard();
                    });
                }
                if (that.isTransparentPass(that.pass)) {
                    if (!that.drawContext.oit || !that.drawContext.oit.outputFragmentColor(this, this.outColor)) {
                        this.outColor = pb.vec4(pb.mul(this.outColor.rgb, this.outColor.a), this.outColor.a);
                    }
                }
                ShaderHelper.applyFog(this, this.worldPos, this.outColor, that.drawContext);
                this.$outputs.zFragmentOutput = ShaderHelper.encodeColorOutput(this, this.outColor);
            } else if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_DEPTH) {
                if (color) {
                    this.$if(pb.lessThan(this.outColor.a, this.zAlphaCutoff), function() {
                        pb.discard();
                    });
                }
                ShaderHelper.discardIfClipped(this, this.worldPos);
                this.$l.depth = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.$builtins.fragCoord.z);
                if (that.drawContext.device.type === 'webgl') {
                    this.$outputs.zFragmentOutput = encodeNormalizedFloatToRGBA(this, this.depth);
                } else {
                    this.$outputs.zFragmentOutput = pb.vec4(this.depth, 0, 0, 1);
                }
            } else {
                if (color) {
                    this.$if(pb.lessThan(this.outColor.a, this.zAlphaCutoff), function() {
                        pb.discard();
                    });
                }
                ShaderHelper.discardIfClipped(this, this.worldPos);
                const shadowMapParams = that.drawContext.shadowMapInfo.get(that.drawContext.renderPass.light);
                this.$outputs.zFragmentOutput = shadowMapParams.impl.computeShadowMapDepth(shadowMapParams, this, this.worldPos);
            }
        });
        color ? pb.getGlobalScope()[funcName](worldPos, color) : pb.getGlobalScope()[funcName](worldPos);
    }
}
FEATURE_ALPHATEST = MeshMaterial.defineFeature();
FEATURE_ALPHABLEND = MeshMaterial.defineFeature();
FEATURE_ALPHATOCOVERAGE = MeshMaterial.defineFeature();

/**
 * Texture property mixin
 * @param name - Texture name
 * @returns Texture mixin
 *
 * @public
 */ function mixinTextureProps(name) {
    return function(BaseCls, vertex = false) {
        const capName = `${name[0].toUpperCase()}${name.slice(1)}`;
        const id = `mixinTexture${capName}`;
        let feature = 0;
        let featureTexIndex = 0;
        let featureTexMatrix = 0;
        if (BaseCls[id]) {
            return BaseCls;
        }
        const cls = class extends BaseCls {
            constructor(...args){
                super(...args);
            }
            vertexShader(scope) {
                super.vertexShader(scope);
                if (vertex || this.needFragmentColor()) {
                    const pb = scope.$builder;
                    const that = this;
                    if (this.featureUsed(feature)) {
                        const texCoordIndex = that[`${name}TexCoordIndex`];
                        if (texCoordIndex >= 0) {
                            const semantic = `texCoord${that[`${name}TexCoordIndex`]}`;
                            if (!scope.$getVertexAttrib(semantic)) {
                                scope.$inputs[semantic] = pb.vec2().attrib(semantic);
                            }
                            if (this.featureUsed(featureTexMatrix)) {
                                scope[`z${capName}TextureMatrix`] = pb.mat4().uniform(2);
                                if (!vertex) {
                                    scope.$outputs[`z${capName}TexCoord`] = pb.mul(scope[`z${capName}TextureMatrix`], pb.vec4(scope.$inputs[semantic], 0, 1)).xy;
                                }
                            } else if (!vertex) {
                                scope.$outputs[`z${capName}TexCoord`] = scope.$inputs[semantic];
                            }
                        }
                    }
                }
            }
            fragmentShader(scope) {
                super.fragmentShader(scope);
                if (this.needFragmentColor()) {
                    const pb = scope.$builder;
                    if (this.featureUsed(feature)) {
                        scope[`z${capName}Tex`] = pb.tex2D().uniform(2);
                    }
                }
            }
            applyUniformValues(bindGroup, ctx, pass) {
                super.applyUniformValues(bindGroup, ctx, pass);
                if (this.needFragmentColor(ctx)) {
                    if (this.featureUsed(feature)) {
                        const that = this;
                        bindGroup.setTexture(`z${capName}Tex`, that[`${name}Texture`], that[`${name}TextureSampler`]);
                        if (this.featureUsed(featureTexMatrix)) {
                            bindGroup.setValue(`z${capName}TextureMatrix`, that[`${name}TexCoordMatrix`]);
                        }
                    }
                }
            }
        };
        feature = cls.defineFeature();
        featureTexIndex = cls.defineFeature();
        featureTexMatrix = cls.defineFeature();
        const proto = cls.prototype;
        const propTexture = `__${name}Texture`;
        const propSampler = `__${name}Sampler`;
        const propTexCoord = `__${name}TexCoordIndex`;
        const propMatrix = `__${name}TexMatrix`;
        proto[propTexture] = null;
        proto[propSampler] = null;
        proto[propTexCoord] = 0;
        proto[propMatrix] = null;
        proto[`sample${capName}Texture`] = function(scope, texCoord) {
            const tex = this[`get${capName}TextureUniform`](scope);
            const coord = texCoord ?? this[`get${capName}TexCoord`](scope);
            return scope.$builder.textureSample(tex, coord);
        };
        proto[`get${capName}TextureUniform`] = function(scope) {
            return scope.$builder.shaderKind === 'fragment' ? scope[`z${capName}Tex`] : null;
        };
        proto[`get${capName}TexCoord`] = function(scope) {
            if (proto[propTexCoord] < 0) {
                return null;
            }
            const pb = scope.$builder;
            if (pb.shaderKind === 'vertex' !== !!vertex) {
                throw new Error(`mixinTextureProps.get${capName}TexCoord(): must be called in ${vertex ? 'vertex' : 'fragment'} stage`);
            }
            return scope.$builder.shaderKind === 'fragment' ? scope.$inputs[`z${capName}TexCoord`] : this.featureUsed(featureTexMatrix) ? pb.mul(scope[`z${capName}TextureMatrix`], pb.vec4(scope.$inputs[`texCoord${proto[propTexCoord]}`], 0, 1)).xy : scope.$inputs[`texCoord${proto[propTexCoord]}`];
        };
        Object.defineProperty(proto, `${name}Texture`, {
            get: function() {
                return this[propTexture];
            },
            set: function(newValue) {
                if (this[propTexture] !== newValue) {
                    this[propTexture] = newValue ?? null;
                    this.useFeature(feature, !!this[propTexture]);
                    if (this[propTexture]) {
                        this.useFeature(featureTexIndex, this[propTexCoord]);
                        this.useFeature(featureTexMatrix, !!this[propMatrix]);
                        this.uniformChanged();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, `${name}TextureSampler`, {
            get: function() {
                return this[propSampler];
            },
            set: function(newValue) {
                this[propSampler] = newValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, `${name}TexCoordMatrix`, {
            get: function() {
                return this[propMatrix];
            },
            set: function(newValue) {
                if (this[propMatrix] !== newValue) {
                    this[propMatrix] = newValue;
                    this.useFeature(featureTexMatrix, !!this[propMatrix]);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, `${name}TexCoordIndex`, {
            get: function() {
                return this[propTexCoord];
            },
            set: function(newValue) {
                if (this[propTexCoord] !== newValue) {
                    this[propTexCoord] = newValue;
                    this.useFeature(featureTexIndex, this[propTexCoord]);
                }
            },
            enumerable: true,
            configurable: true
        });
        cls[id] = true;
        return cls;
    };
}

/**
 * Albedo color mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 *
 * @public
 */ function mixinAlbedoColor(BaseCls) {
    if (BaseCls.albedoColorMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinTextureProps('albedo'));
    const ALBEDO_COLOR_UNIFORM = S.defineInstanceUniform('albedoColor', 'vec4');
    return class extends S {
        static albedoColorMixed = true;
        _albedoColor;
        constructor(){
            super();
            this._albedoColor = Vector4.one();
        }
        /** Albedo color */ get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(val) {
            this._albedoColor.set(val);
            this.uniformChanged();
        }
        getUniformValueAlbedoColor(scope) {
            return this.drawContext.instancing ? scope.$inputs.zAlbedo : scope.zAlbedo;
        }
        calculateAlbedoColor(scope, uv) {
            const pb = scope.$builder;
            if (!this.needFragmentColor()) {
                console.warn('mixinAlbedoColor.calculateAlbedoColor(): No need to calculate albedo color, make sure needFragmentColor() returns true');
                return pb.vec4(1);
            }
            let color = this.getUniformValueAlbedoColor(scope);
            if (this.albedoTexture) {
                color = pb.mul(color, this.sampleAlbedoTexture(scope, uv));
            }
            return color;
        }
        vertexShader(scope) {
            super.vertexShader(scope);
            if (this.needFragmentColor()) {
                if (this.drawContext.instancing) {
                    scope.$outputs.zAlbedo = this.getInstancedUniform(scope, ALBEDO_COLOR_UNIFORM);
                }
            }
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            if (this.needFragmentColor() && !this.drawContext.instancing) {
                const pb = scope.$builder;
                scope.zAlbedo = pb.vec4().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx) && !this.drawContext.instancing) {
                bindGroup.setValue('zAlbedo', this._albedoColor);
            }
        }
    };
}

/**
 * Light mixin
 * @param BaseCls - class to mix in
 * @returns Mixed class
 * @public
 */ function mixinLight(BaseCls) {
    if (BaseCls.lightMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinAlbedoColor, mixinTextureProps('normal'));
    let FEATURE_DOUBLE_SIDED_LIGHTING = 0;
    let FEATURE_OBJECT_SPACE_NORMALMAP = 0;
    const cls = class extends S {
        static lightMixed = true;
        _normalScale;
        constructor(){
            super();
            this._normalScale = 1;
            this.useFeature(FEATURE_DOUBLE_SIDED_LIGHTING, true);
        }
        get normalScale() {
            return this._normalScale;
        }
        set normalScale(val) {
            if (val !== this._normalScale) {
                this._normalScale = val;
                this.uniformChanged();
            }
        }
        get normalMapMode() {
            return this.featureUsed(FEATURE_OBJECT_SPACE_NORMALMAP);
        }
        set normalMapMode(val) {
            this.useFeature(FEATURE_OBJECT_SPACE_NORMALMAP, val);
        }
        /** true if double sided lighting is used */ get doubleSidedLighting() {
            return this.featureUsed(FEATURE_DOUBLE_SIDED_LIGHTING);
        }
        set doubleSidedLighting(val) {
            this.useFeature(FEATURE_DOUBLE_SIDED_LIGHTING, !!val);
        }
        /**
     * Calculates the normalized vector from world coordinates to the viewpoint.
     *
     * @param scope - Shader scope
     *
     * @returns The view vector
     */ calculateViewVector(scope, worldPos) {
            const pb = scope.$builder;
            return pb.normalize(pb.sub(ShaderHelper.getCameraPosition(scope), worldPos.xyz));
        }
        /**
     * Calculate the reflection vector of the view vector with respect to the normal.
     *
     * @param scope - Shader scope
     * @param normal - Surface normal
     * @param viewVec - The view vector
     * @returns The reflection vector
     */ calculateReflectionVector(scope, normal, viewVec) {
            const pb = scope.$builder;
            return pb.reflect(pb.neg(viewVec), normal);
        }
        /**
     * Calculate the normal vector for current fragment
     * @param scope - The shader scope
     * @returns Normal vector for current fragment
     */ calculateNormal(scope, worldPos, worldNormal, worldTangent, worldBinormal) {
            const pb = scope.$builder;
            const that = this;
            const args = [
                worldPos
            ];
            const params = [
                pb.vec3('worldPos')
            ];
            let funcName = 'Z_calculateNormal';
            if (worldNormal) {
                params.push(pb.vec3('worldNormal'));
                args.push(worldNormal);
                funcName += '_N';
                if (worldTangent && worldBinormal) {
                    params.push(pb.vec3('worldTangent'), pb.vec3('worldBinormal'));
                    args.push(worldTangent, worldBinormal);
                    funcName += '_T';
                }
            }
            pb.func(funcName, params, function() {
                this.$l.uv = that.normalTexture ? that.getNormalTexCoord(this) ?? pb.vec2(0) : that.albedoTexture ? that.getAlbedoTexCoord(this) ?? pb.vec2(0) : pb.vec2(0);
                this.$l.TBN = that.calculateTBN(this, this.worldPos, this.worldNormal, this.worldTangent, this.worldBinormal);
                if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && that.normalTexture) {
                    if (that.normalMapMode === 'object-space') {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(pb.normalize(normalTex));
                    } else {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(pb.normalize(pb.mul(this.TBN, normalTex)));
                    }
                } else {
                    this.$return(this.TBN[2]);
                }
            });
            return pb.getGlobalScope()[funcName](...args);
        }
        /**
     * Calculate the normal vector for current fragment
     *
     * @param scope - The shader scope
     * @returns Structure that contains normal vector and TBN matrix
     */ calculateNormalAndTBN(scope, worldPos, worldNormal, worldTangent, worldBinormal) {
            const pb = scope.$builder;
            const NormalStruct = pb.defineStruct([
                pb.mat3('TBN'),
                pb.vec3('normal')
            ]);
            const that = this;
            const args = [
                worldPos.xyz
            ];
            const params = [
                pb.vec3('worldPos')
            ];
            let funcName = 'Z_calculateNormalAndTBN';
            if (worldNormal) {
                params.push(pb.vec3('worldNormal'));
                args.push(worldNormal);
                funcName += '_N';
                if (worldTangent && worldBinormal) {
                    params.push(pb.vec3('worldTangent'), pb.vec3('worldBinormal'));
                    args.push(worldTangent, worldBinormal);
                    funcName += '_T';
                }
            }
            pb.func(funcName, params, function() {
                this.$l.uv = that.normalTexture ? that.getNormalTexCoord(this) ?? pb.vec2(0) : that.albedoTexture ? that.getAlbedoTexCoord(this) ?? pb.vec2(0) : pb.vec2(0);
                this.$l.TBN = that.calculateTBN(this, this.worldPos, this.worldNormal, this.worldTangent, this.worldBinormal);
                if (that.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && that.normalTexture) {
                    if (that.normalMapMode === 'object-space') {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(NormalStruct(this.TBN, pb.normalize(normalTex)));
                    } else {
                        const pixel = pb.sub(pb.mul(pb.textureSample(that.getNormalTextureUniform(this), this.uv).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(this.zNormalScale).xx, 1));
                        this.$return(NormalStruct(this.TBN, pb.normalize(pb.mul(this.TBN, normalTex))));
                    }
                } else {
                    this.$return(NormalStruct(this.TBN, this.TBN[2]));
                }
            });
            return pb.getGlobalScope()[funcName](...args);
        }
        /**
     * Calculate the TBN matrix
     *
     * @param scope - The shader scope
     * @returns TBN matrix
     */ calculateTBN(scope, worldPos, worldNormal, worldTangent, worldBinormal) {
            const pb = scope.$builder;
            const that = this;
            const args = [
                worldPos.xyz
            ];
            const params = [
                pb.vec3('worldPos')
            ];
            let funcName = 'Z_calculateTBN';
            if (worldNormal) {
                params.push(pb.vec3('worldNormal'));
                args.push(worldNormal);
                funcName += '_N';
                if (worldTangent && worldBinormal) {
                    params.push(pb.vec3('worldTangent'), pb.vec3('worldBinormal'));
                    args.push(worldTangent, worldBinormal);
                    funcName += '_T';
                }
            }
            pb.func(funcName, params, function() {
                const posW = this.worldPos;
                this.$l.uv = that.normalTexture ? that.getNormalTexCoord(this) ?? pb.vec2(0) : that.albedoTexture ? that.getAlbedoTexCoord(this) ?? pb.vec2(0) : pb.vec2(0);
                this.$l.TBN = pb.mat3();
                if (!worldNormal) {
                    this.$l.uv_dx = pb.dpdx(pb.vec3(this.uv, 0));
                    this.$l.uv_dy = pb.dpdy(pb.vec3(this.uv, 0));
                    this.$if(pb.lessThanEqual(pb.add(pb.length(this.uv_dx), pb.length(this.uv_dy)), 0.000001), function() {
                        this.uv_dx = pb.vec3(1, 0, 0);
                        this.uv_dy = pb.vec3(0, 1, 0);
                    });
                    this.$l.t_ = pb.div(pb.sub(pb.mul(pb.dpdx(posW), this.uv_dy.y), pb.mul(pb.dpdy(posW), this.uv_dx.y)), pb.sub(pb.mul(this.uv_dx.x, this.uv_dy.y), pb.mul(this.uv_dx.y, this.uv_dy.x)));
                    this.$l.ng = pb.normalize(pb.cross(pb.dpdx(posW), pb.dpdy(posW)));
                    this.$l.t = pb.normalize(pb.sub(this.t_, pb.mul(this.ng, pb.dot(this.ng, this.t_))));
                    this.$l.b = pb.cross(this.ng, this.t);
                    if (that.doubleSidedLighting) {
                        this.$if(pb.not(this.$builtins.frontFacing), function() {
                            this.t = pb.mul(this.t, -1);
                            this.b = pb.mul(this.b, -1);
                            this.ng = pb.mul(this.ng, -1);
                        });
                    }
                    this.TBN = pb.mat3(this.t, this.b, this.ng);
                } else if (!worldTangent) {
                    this.$l.uv_dx = pb.dpdx(pb.vec3(this.uv, 0));
                    this.$l.uv_dy = pb.dpdy(pb.vec3(this.uv, 0));
                    this.$if(pb.lessThanEqual(pb.add(pb.length(this.uv_dx), pb.length(this.uv_dy)), 0.000001), function() {
                        this.uv_dx = pb.vec3(1, 0, 0);
                        this.uv_dy = pb.vec3(0, 1, 0);
                    });
                    this.$l.t_ = pb.div(pb.sub(pb.mul(pb.dpdx(posW), this.uv_dy.y), pb.mul(pb.dpdy(posW), this.uv_dx.y)), pb.sub(pb.mul(this.uv_dx.x, this.uv_dy.y), pb.mul(this.uv_dx.y, this.uv_dy.x)));
                    this.$l.ng = pb.normalize(this.worldNormal);
                    this.$l.t = pb.normalize(pb.sub(this.t_, pb.mul(this.ng, pb.dot(this.ng, this.t_))));
                    this.$l.b = pb.cross(this.ng, this.t);
                    if (that.doubleSidedLighting) {
                        this.$if(pb.not(this.$builtins.frontFacing), function() {
                            this.t = pb.mul(this.t, -1);
                            this.b = pb.mul(this.b, -1);
                            this.ng = pb.mul(this.ng, -1);
                        });
                    }
                    this.TBN = pb.mat3(this.t, this.b, this.ng);
                } else {
                    this.$l.ng = pb.normalize(this.worldNormal);
                    this.$l.t = pb.normalize(this.worldTangent);
                    this.$l.b = pb.normalize(this.worldBinormal);
                    if (that.doubleSidedLighting) {
                        this.$if(pb.not(this.$builtins.frontFacing), function() {
                            this.t = pb.mul(this.t, -1);
                            this.b = pb.mul(this.b, -1);
                            this.ng = pb.mul(this.ng, -1);
                        });
                    }
                    this.TBN = pb.mat3(this.t, this.b, this.ng);
                }
                this.$return(this.TBN);
            });
            return pb.getGlobalScope()[funcName](...args);
        }
        /**
     * {@inheritDoc MeshMaterial.applyUniformsValues}
     * @override
     */ applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (ctx.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                if (this.normalTexture) {
                    bindGroup.setValue('zNormalScale', this._normalScale);
                }
            }
        }
        /**
     * Check if the environment lighting should be calculated.
     *
     * @returns true Environment lighting should be calculated, otherwise false
     */ needCalculateEnvLight() {
            return this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && this.drawContext.drawEnvLight;
        }
        /**
     * Get irradiance of current environment light
     *
     * @param scope - Shader scope
     * @param normal - Fragment normal vector
     *
     * @returns Irradiance of current environment light of type vec3
     */ getEnvLightIrradiance(scope, normal) {
            if (!this.needCalculateEnvLight()) {
                console.warn('getEnvLightIrradiance(): No need to calculate environment lighting');
                return scope.$builder.vec3(0);
            }
            return this.drawContext.env.light.envLight.hasIrradiance() ? scope.$builder.mul(this.drawContext.env.light.envLight.getIrradiance(scope, normal).rgb, ShaderHelper.getEnvLightStrength(scope)) : scope.$builder.vec3(0);
        }
        /**
     * Get Radiance of current environment light
     *
     * @param scope - Shader scope
     * @param reflectVec - The reflection vector
     * @param roughness - Roughness value of current fragment
     *
     * @returns Radiance of current environment light of type vec3
     */ getEnvLightRadiance(scope, reflectVec, roughness) {
            if (!this.needCalculateEnvLight()) {
                console.warn('getEnvLightRadiance(): No need to calculate environment lighting');
                return scope.$builder.vec3(0);
            }
            return this.drawContext.env.light.envLight.hasRadiance() ? scope.$builder.mul(this.drawContext.env.light.envLight.getRadiance(scope, reflectVec, roughness).rgb, ShaderHelper.getEnvLightStrength(scope)) : scope.$builder.vec3(0);
        }
        /**
     * Checks if shadow should be computed
     *
     * @returns true if shadow should be computed, other wise false
     */ needCalucateShadow() {
            return this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT && !!this.drawContext.currentShadowLight;
        }
        /**
     * Calculates shadow of current fragment
     *
     * @param scope - Shader scope
     * @param NoL - NdotL vector
     * @returns Shadow of current fragment, 1 means no shadow and 0 means full shadowed.
     */ calculateShadow(scope, worldPos, NoL) {
            const pb = scope.$builder;
            if (!this.needCalucateShadow()) {
                console.warn('calculateShadow(): No need to calculate shadow');
                return pb.float(1);
            }
            return ShaderHelper.calculateShadow(scope, worldPos, NoL, this.drawContext);
        }
        getClusterIndex(scope, fragCoord) {
            const pb = scope.$builder;
            const funcName = 'lm_getClusterIndex';
            pb.func(funcName, [
                pb.vec3('fragCoord')
            ], function() {
                const clusterParams = ShaderHelper.getClusterParams(this);
                const countParams = ShaderHelper.getCountParams(this);
                this.$l.zTile = pb.int(pb.max(pb.add(pb.mul(pb.log2(ShaderHelper.nonLinearDepthToLinear(this, this.fragCoord.z)), clusterParams.z), clusterParams.w), 0));
                this.$l.f = pb.vec2(this.fragCoord.x, pb.sub(clusterParams.y, pb.add(this.fragCoord.y, 1)));
                this.$l.xyTile = pb.ivec2(pb.div(this.f, pb.div(clusterParams.xy, pb.vec2(countParams.xy))));
                this.$return(pb.ivec3(this.xyTile, this.zTile));
            });
            return pb.getGlobalScope()[funcName](fragCoord);
        }
        calculatePointLightAttenuation(scope, worldPos, posRange) {
            const pb = scope.$builder;
            const funcName = 'Z_calculatePointLightAttenuation';
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec4('posRange')
            ], function() {
                this.$l.dist = pb.distance(this.posRange.xyz, this.worldPos);
                this.$l.falloff = pb.max(0, pb.sub(1, pb.div(this.dist, this.posRange.w)));
                this.$return(pb.mul(this.falloff, this.falloff));
            });
            return pb.getGlobalScope()[funcName](worldPos, posRange);
        }
        calculateSpotLightAttenuation(scope, worldPos, posRange, dirCutoff) {
            const pb = scope.$builder;
            const funcName = 'Z_calculateSpotLightAttenuation';
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec4('posRange'),
                pb.vec4('dirCutoff')
            ], function() {
                this.$l.dist = pb.distance(this.posRange.xyz, this.worldPos);
                this.$l.falloff = pb.max(0, pb.sub(1, pb.div(this.dist, this.posRange.w)));
                this.$l.spotFactor = pb.dot(pb.normalize(pb.sub(this.worldPos, this.posRange.xyz)), this.dirCutoff.xyz);
                this.spotFactor = pb.smoothStep(this.dirCutoff.w, pb.mix(this.dirCutoff.w, 1, 0.5), this.spotFactor);
                this.$return(pb.mul(this.spotFactor, this.falloff, this.falloff));
            });
            return pb.getGlobalScope()[funcName](worldPos, posRange, dirCutoff);
        }
        calculateLightAttenuation(scope, type, worldPos, posRange, dirCutoff) {
            const pb = scope.$builder;
            return scope.$choice(pb.equal(type, LIGHT_TYPE_DIRECTIONAL), pb.float(1), scope.$choice(pb.equal(type, LIGHT_TYPE_POINT), this.calculatePointLightAttenuation(scope, worldPos.xyz, posRange), this.calculateSpotLightAttenuation(scope, worldPos.xyz, posRange, dirCutoff)));
        }
        calculateLightDirection(scope, type, worldPos, posRange, dirCutoff) {
            const pb = scope.$builder;
            return scope.$choice(pb.equal(type, LIGHT_TYPE_DIRECTIONAL), pb.neg(dirCutoff.xyz), pb.normalize(pb.sub(posRange.xyz, worldPos.xyz)));
        }
        forEachLight(scope, callback) {
            const pb = scope.$builder;
            const that = this;
            if (that.drawContext.renderPass.type !== RENDER_PASS_TYPE_LIGHT) {
                console.warn('LitMaterial.forEachLight(): must be called in forward render pass');
                return;
            }
            if (that.drawContext.currentShadowLight) {
                const posRange = ShaderHelper.getGlobalUniforms(scope).light.positionAndRange;
                const dirCutoff = ShaderHelper.getGlobalUniforms(scope).light.directionAndCutoff;
                const colorIntensity = ShaderHelper.getGlobalUniforms(scope).light.diffuseAndIntensity;
                scope.$scope(function() {
                    const lightType = scope.$choice(pb.lessThan(posRange.w, 0), pb.int(LIGHT_TYPE_DIRECTIONAL), scope.$choice(pb.lessThan(dirCutoff.w, 0), pb.int(LIGHT_TYPE_POINT), pb.int(LIGHT_TYPE_SPOT)));
                    callback.call(this, lightType, posRange, dirCutoff, colorIntensity, true);
                });
            } else {
                scope.$scope(function() {
                    const countParams = ShaderHelper.getCountParams(this);
                    this.$l.cluster = that.getClusterIndex(this, this.$builtins.fragCoord.xyz);
                    this.$l.clusterIndex = pb.add(this.cluster.x, pb.mul(this.cluster.y, countParams.x), pb.mul(this.cluster.z, countParams.x, countParams.y));
                    this.$l.texSize = ShaderHelper.getGlobalUniforms(scope).light.lightIndexTexSize;
                    if (pb.getDevice().type === 'webgl') {
                        this.$l.texCoordX = pb.div(pb.add(pb.mod(pb.float(this.clusterIndex), pb.float(this.texSize.x)), 0.5), pb.float(this.texSize.x));
                        this.$l.texCoordY = pb.div(pb.add(pb.float(pb.div(this.clusterIndex, this.texSize.x)), 0.5), pb.float(this.texSize.y));
                        this.$l.samp = pb.textureSample(ShaderHelper.getClusteredLightIndexTexture(this), pb.vec2(this.texCoordX, this.texCoordY));
                    } else {
                        this.$l.texCoordX = pb.mod(this.clusterIndex, this.texSize.x);
                        this.$l.texCoordY = pb.div(this.clusterIndex, this.texSize.x);
                        this.$l.samp = pb.textureLoad(ShaderHelper.getClusteredLightIndexTexture(this), pb.ivec2(this.texCoordX, this.texCoordY), 0);
                    }
                    if (pb.getDevice().type === 'webgl') {
                        this.$for(pb.int('i'), 0, 4, function() {
                            this.$l.k = this.samp.at(this.i);
                            this.$l.lights = pb.int[2]();
                            this.$l.lights[0] = pb.int(pb.mod(this.k, 256));
                            this.$l.lights[1] = pb.int(pb.div(this.k, 256));
                            this.$for(pb.int('k'), 0, 2, function() {
                                this.$l.li = this.lights.at(this.k);
                                this.$if(pb.greaterThan(this.li, 0), function() {
                                    this.$for(pb.int('j'), 1, 256, function() {
                                        this.$if(pb.equal(this.j, this.li), function() {
                                            this.$l.positionRange = ShaderHelper.getLightPositionAndRange(this, this.j);
                                            this.$l.directionCutoff = ShaderHelper.getLightDirectionAndCutoff(this, this.j);
                                            this.$l.diffuseIntensity = ShaderHelper.getLightColorAndIntensity(this, this.j);
                                            this.$l.lightType = this.$choice(pb.lessThan(this.positionRange.w, 0), pb.int(LIGHT_TYPE_DIRECTIONAL), this.$choice(pb.lessThan(this.directionCutoff.w, 0), pb.int(LIGHT_TYPE_POINT), pb.int(LIGHT_TYPE_SPOT)));
                                            this.$scope(function() {
                                                callback.call(this, this.lightType, this.positionRange, this.directionCutoff, this.diffuseIntensity, false);
                                            });
                                            this.$break();
                                        });
                                    });
                                });
                            });
                        });
                    } else {
                        this.$for(pb.uint('i'), 0, 4, function() {
                            this.$for(pb.uint('k'), 0, 4, function() {
                                this.$l.c = pb.compAnd(pb.sar(this.samp.at(this.i), pb.mul(this.k, 8)), 0xff);
                                this.$if(pb.greaterThan(this.c, 0), function() {
                                    this.$l.positionRange = ShaderHelper.getLightPositionAndRange(this, this.c);
                                    this.$l.directionCutoff = ShaderHelper.getLightDirectionAndCutoff(this, this.c);
                                    this.$l.diffuseIntensity = ShaderHelper.getLightColorAndIntensity(this, this.c);
                                    this.$l.lightType = this.$choice(pb.lessThan(this.positionRange.w, 0), pb.int(LIGHT_TYPE_DIRECTIONAL), this.$choice(pb.lessThan(this.directionCutoff.w, 0), pb.int(LIGHT_TYPE_POINT), pb.int(LIGHT_TYPE_SPOT)));
                                    this.$scope(function() {
                                        callback.call(this, this.lightType, this.positionRange, this.directionCutoff, this.diffuseIntensity, false);
                                    });
                                });
                            });
                        });
                    }
                });
            }
        }
        /**
     * Fragment shader implementation
     *
     * @param scope - Shader scope
     * @returns Calucated fragment color
     */ fragmentShader(scope) {
            super.fragmentShader(scope);
            const pb = scope.$builder;
            if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                if (this.normalTexture) {
                    scope.zNormalScale = pb.float().uniform(2);
                }
            }
        }
        /**
     * {@inheritDoc Material.supportLighting}
     * @override
     */ supportLighting() {
            return true;
        }
    };
    FEATURE_DOUBLE_SIDED_LIGHTING = cls.defineFeature();
    FEATURE_OBJECT_SPACE_NORMALMAP = cls.defineFeature();
    return cls;
}

/**
 * Vertex color mixin
 *
 * @param BaseCls - Base class to mix in
 * @returns Mixed class
 *
 * @public
 */ function mixinVertexColor(BaseCls) {
    if (BaseCls.vertexColorMixed) {
        return BaseCls;
    }
    let FEATURE_VERTEX_COLOR = 0;
    const cls = class extends BaseCls {
        static vertexColorMixed = true;
        constructor(...args){
            super(...args);
        }
        /** Albedo color */ get vertexColor() {
            return this.featureUsed(FEATURE_VERTEX_COLOR);
        }
        set vertexColor(val) {
            this.useFeature(FEATURE_VERTEX_COLOR, !!val);
        }
        vertexShader(scope) {
            super.vertexShader(scope);
            if (this.needFragmentColor()) {
                if (this.vertexColor) {
                    if (scope.$getVertexAttrib('diffuse')) {
                        throw new Error('mixinVertexColor.vertexShader(): diffuse vertex stream already defined');
                    }
                    scope.$inputs.zDiffuse = scope.$builder.vec4().attrib('diffuse');
                    scope.$outputs.zOutDiffuse = scope.$inputs.zDiffuse;
                }
            }
        }
        getVertexColor(scope) {
            if (!this.needFragmentColor()) {
                throw new Error('mixinVertexColor.getVertexColor(): No need to calculate albedo color, make sure needFragmentColor() returns true');
            }
            if (scope.$builder.shaderKind === 'fragment') {
                return scope.$inputs.zOutDiffuse;
            } else {
                return scope.$inputs.zDiffuse;
            }
        }
    };
    FEATURE_VERTEX_COLOR = cls.defineFeature();
    return cls;
}

/**
 * Lambert material
 * @public
 */ class LambertMaterial extends applyMaterialMixins(MeshMaterial, mixinLight, mixinVertexColor) {
    static FEATURE_VERTEX_NORMAL = this.defineFeature();
    static FEATURE_VERTEX_TANGENT = this.defineFeature();
    constructor(){
        super();
        this.useFeature(LambertMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(LambertMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(LambertMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(LambertMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(LambertMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.color = pb.vec3(0);
            scope.$l.normal = this.calculateNormal(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            if (this.needCalculateEnvLight()) {
                scope.color = pb.add(scope.color, this.getEnvLightIrradiance(scope, scope.normal));
            }
            this.forEachLight(scope, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                this.$l.lightAtten = that.calculateLightAttenuation(this, type, scope.$inputs.worldPos, posRange, dirCutoff);
                this.$l.lightDir = that.calculateLightDirection(this, type, scope.$inputs.worldPos, posRange, dirCutoff);
                this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                this.$l.lightContrib = pb.mul(colorIntensity.rgb, colorIntensity.a, this.NoL, this.lightAtten);
                if (shadow) {
                    this.$l.shadow = pb.vec3(that.calculateShadow(this, scope.$inputs.worldPos, this.NoL));
                    this.lightContrib = pb.mul(this.lightContrib, this.shadow);
                }
                this.color = pb.add(this.color, this.lightContrib);
            });
            scope.$l.litColor = pb.mul(scope.albedo, pb.vec4(scope.color, 1));
            this.outputFragmentColor(scope, scope.$inputs.worldPos, scope.litColor);
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

/**
 * Blinn-phong lighting model mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 * @public
 */ function mixinBlinnPhong(BaseCls) {
    if (BaseCls.blinnPhongMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinLight);
    return class extends S {
        static blinnPhongMixed = true;
        _shininess;
        constructor(){
            super();
            this._shininess = 32;
        }
        /** Shininess */ get shininess() {
            return this._shininess;
        }
        set shininess(val) {
            if (val !== this._shininess) {
                this._shininess = val;
                this.uniformChanged();
            }
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            const pb = scope.$builder;
            if (this.needFragmentColor()) {
                scope.zShininess = pb.float().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zShininess', this._shininess);
            }
        }
        blinnPhongLight(scope, worldPos, normal, viewVec, albedo) {
            const pb = scope.$builder;
            const funcName = 'Z_blinnPhongLight';
            const that = this;
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec3('normal'),
                pb.vec3('viewVec'),
                pb.vec4('albedo')
            ], function() {
                if (!that.needFragmentColor()) {
                    this.$return(this.albedo.rgb);
                } else {
                    if (that.needCalculateEnvLight()) {
                        this.$l.diffuseColor = that.getEnvLightIrradiance(this, this.normal);
                    } else {
                        this.$l.diffuseColor = pb.vec3(0);
                    }
                    this.$l.specularColor = pb.vec3(0);
                    that.forEachLight(this, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                        this.$l.lightAtten = that.calculateLightAttenuation(this, type, this.worldPos, posRange, dirCutoff);
                        this.$l.lightDir = that.calculateLightDirection(this, type, this.worldPos, posRange, dirCutoff);
                        this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                        this.$l.halfVec = pb.normalize(pb.add(this.viewVec, this.lightDir));
                        this.$l.NoH = pb.clamp(pb.dot(this.normal, this.halfVec), 0, 1);
                        this.$l.lightColor = pb.mul(colorIntensity.rgb, colorIntensity.a, this.lightAtten);
                        this.$l.diffuse = pb.mul(this.lightColor, this.NoL);
                        this.$l.specular = pb.mul(this.lightColor, pb.pow(this.NoH, this.zShininess));
                        if (shadow) {
                            this.$l.shadow = pb.vec3(that.calculateShadow(this, this.worldPos, this.NoL));
                            this.diffuse = pb.mul(this.diffuse, this.shadow);
                            this.specular = pb.mul(this.specular, this.shadow);
                        }
                        this.diffuseColor = pb.add(this.diffuseColor, this.diffuse);
                        this.specularColor = pb.add(this.specularColor, this.specular);
                    });
                    this.$l.litColor = pb.add(pb.mul(this.albedo.rgb, this.diffuseColor), this.specularColor);
                    this.$return(this.litColor);
                }
            });
            return pb.getGlobalScope()[funcName](worldPos, normal, viewVec, albedo);
        }
    };
}

/**
 * Blinn material
 * @public
 */ class BlinnMaterial extends applyMaterialMixins(MeshMaterial, mixinBlinnPhong, mixinVertexColor) {
    /** @internal */ static FEATURE_VERTEX_NORMAL = this.defineFeature();
    /** @internal */ static FEATURE_VERTEX_TANGENT = this.defineFeature();
    /**
   * Creates an instance of BlinnMaterial class
   */ constructor(){
        super();
        this.useFeature(BlinnMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(BlinnMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(BlinnMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(BlinnMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(BlinnMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.normal = this.calculateNormal(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.blinnPhongLight(scope, scope.$inputs.worldPos, scope.normal, scope.viewVec, scope.albedo);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

/**
 * Unlit material
 * @public
 */ class UnlitMaterial extends applyMaterialMixins(MeshMaterial, mixinVertexColor, mixinAlbedoColor) {
    static FEATURE_VERTEX_COLOR = 'um_vertexcolor';
    constructor(){
        super();
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        let color = this.calculateAlbedoColor(scope);
        if (this.vertexColor) {
            color = scope.$builder.mul(color, this.getVertexColor(scope));
        }
        this.outputFragmentColor(scope, scope.$inputs.worldPos, this.needFragmentColor() ? color : null);
    }
}

const ggxLut = new Map();
function getGGXLUT(size) {
    let lut = ggxLut.get(size);
    if (!lut) {
        lut = createGGXLUT(size);
        ggxLut.set(size, lut);
    }
    return lut;
}
function createGGXLUT(size) {
    const device = Application.instance.device;
    const program = device.buildRenderProgram({
        vertex (pb) {
            this.$inputs.pos = pb.vec2().attrib('position');
            this.$outputs.uv = pb.vec2();
            pb.main(function() {
                this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                if (device.type === 'webgpu') {
                    this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                }
            });
        },
        fragment (pb) {
            this.$outputs.color = pb.vec4();
            const SAMPLE_COUNT = 1024;
            if (device.type === 'webgl') {
                pb.func('radicalInverse_VdC', [
                    pb.int('bits')
                ], function() {
                    this.$l.rand = pb.float(0);
                    this.$l.denom = pb.float(1);
                    this.$l.invBase = pb.float(0.5);
                    this.$l.n = this.bits;
                    this.$for(pb.int('i'), 0, 32, function() {
                        this.denom = pb.mul(this.denom, 2);
                        this.rand = pb.add(this.rand, pb.div(pb.mod(pb.float(this.n), 2), this.denom));
                        this.n = pb.div(this.n, 2);
                        this.$if(pb.equal(this.n, 0), function() {
                            this.$break();
                        });
                    });
                    this.$return(this.rand);
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(this.i)));
                });
            } else {
                pb.func('radicalInverse_VdC', [
                    pb.uint('bits')
                ], function() {
                    this.$l.n = this.bits;
                    this.n = pb.compOr(pb.sal(this.n, 16), pb.sar(this.n, 16));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x55555555), 1), pb.sar(pb.compAnd(this.n, 0xaaaaaaaa), 1));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x33333333), 2), pb.sar(pb.compAnd(this.n, 0xcccccccc), 2));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x0f0f0f0f), 4), pb.sar(pb.compAnd(this.n, 0xf0f0f0f0), 4));
                    this.n = pb.compOr(pb.sal(pb.compAnd(this.n, 0x00ff00ff), 8), pb.sar(pb.compAnd(this.n, 0xff00ff00), 8));
                    this.$return(pb.mul(pb.float(this.n), 2.3283064365386963e-10));
                });
                pb.func('hammersley2d', [
                    pb.int('i'),
                    pb.int('N')
                ], function() {
                    this.$return(pb.vec2(pb.div(pb.float(this.i), pb.float(this.N)), this.radicalInverse_VdC(pb.uint(this.i))));
                });
            }
            pb.func('generateTBN', [
                pb.vec3('normal')
            ], function() {
                this.$l.bitangent = pb.vec3(0, 1, 0);
                this.$l.NoU = this.normal.y;
                this.$l.epsl = 0.0000001;
                this.$if(pb.lessThanEqual(pb.sub(1, pb.abs(this.normal.y)), this.epsl), function() {
                    this.bitangent = this.$choice(pb.greaterThan(this.normal.y, 0), pb.vec3(0, 0, 1), pb.vec3(0, 0, -1));
                });
                this.$l.tangent = pb.normalize(pb.cross(this.bitangent, this.normal));
                this.bitangent = pb.cross(this.normal, this.tangent);
                this.$return(pb.mat3(this.tangent, this.bitangent, this.normal));
            });
            pb.func('D_Charlie', [
                pb.float('sheenRoughness'),
                pb.float('NdotH')
            ], function() {
                this.$l.roughness = pb.max(this.sheenRoughness, 0.000001);
                this.$l.invR = pb.div(1, this.roughness);
                this.$l.cos2h = pb.mul(this.NdotH, this.NdotH);
                this.$l.sin2h = pb.sub(1, this.cos2h);
                this.$return(pb.div(pb.mul(pb.add(this.invR, 2), pb.pow(this.sin2h, pb.mul(this.invR, 0.5))), Math.PI * 2));
            });
            pb.func('smithGGXCorrelated', [
                pb.float('NoV'),
                pb.float('NoL'),
                pb.float('roughness')
            ], function() {
                this.$l.a2 = pb.mul(this.roughness, this.roughness, this.roughness, this.roughness);
                this.$l.GGXV = pb.mul(this.NoL, pb.sqrt(pb.add(pb.mul(this.NoV, this.NoV, pb.sub(1, this.a2)), this.a2)));
                this.$l.GGXL = pb.mul(this.NoV, pb.sqrt(pb.add(pb.mul(this.NoL, this.NoL, pb.sub(1, this.a2)), this.a2)));
                this.$return(pb.div(0.5, pb.add(this.GGXV, this.GGXL)));
            });
            pb.func('V_Ashikhmin', [
                pb.float('NdotL'),
                pb.float('NdotV')
            ], function() {
                this.$return(pb.clamp(pb.div(1, pb.mul(pb.sub(pb.add(this.NdotL, this.NdotV), pb.mul(this.NdotL, this.NdotV)), 4)), 0, 1));
            });
            pb.func('importanceSample', [
                pb.vec2('xi'),
                pb.vec3('normal'),
                pb.float('roughness'),
                pb.vec3('ggx').out(),
                pb.vec3('charlie').out()
            ], function() {
                this.$l.alphaRoughness = pb.mul(this.roughness, this.roughness);
                this.$l.cosTheta = pb.clamp(pb.sqrt(pb.div(pb.sub(1, this.xi.y), pb.add(1, pb.mul(pb.sub(pb.mul(this.alphaRoughness, this.alphaRoughness), 1), this.xi.y)))), 0, 1);
                this.$l.sinTheta = pb.sqrt(pb.sub(1, pb.mul(this.cosTheta, this.cosTheta)));
                this.$l.phi = pb.mul(this.xi.x, Math.PI * 2);
                this.$l.TBN = this.generateTBN(this.normal);
                this.$l.localSpaceDir = pb.normalize(pb.vec3(pb.mul(this.sinTheta, pb.cos(this.phi)), pb.mul(this.sinTheta, pb.sin(this.phi)), this.cosTheta));
                this.ggx = pb.mul(this.TBN, this.localSpaceDir);
                this.sinTheta = pb.pow(this.xi.y, pb.div(this.alphaRoughness, pb.add(pb.mul(this.alphaRoughness, 2), 1)));
                this.cosTheta = pb.sqrt(pb.sub(1, pb.mul(this.sinTheta, this.sinTheta)));
                this.localSpaceDir = pb.normalize(pb.vec3(pb.mul(this.sinTheta, pb.cos(this.phi)), pb.mul(this.sinTheta, pb.sin(this.phi)), this.cosTheta));
                this.charlie = pb.mul(this.TBN, this.localSpaceDir);
            });
            pb.func('integrateBRDF', [
                pb.float('NoV'),
                pb.float('roughness')
            ], function() {
                this.$l.V = pb.vec3(pb.sub(1, pb.mul(this.NoV, this.NoV)), 0, this.NoV);
                this.$l.a = pb.float(0);
                this.$l.b = pb.float(0);
                this.$l.c = pb.float(0);
                this.$l.n = pb.vec3(0, 0, 1);
                this.$for(pb.int('i'), 0, SAMPLE_COUNT, function() {
                    this.$l.xi = this.hammersley2d(this.i, SAMPLE_COUNT);
                    this.$l.ggxSample = pb.vec3();
                    this.$l.charlieSample = pb.vec3();
                    this.importanceSample(this.xi, this.n, this.roughness, this.ggxSample, this.charlieSample);
                    this.$l.ggxL = pb.normalize(pb.reflect(pb.neg(this.V), this.ggxSample.xyz));
                    this.$l.ggxNoL = pb.clamp(this.ggxL.z, 0, 1);
                    this.$l.ggxNoH = pb.clamp(this.ggxSample.z, 0, 1);
                    this.$l.ggxVoH = pb.clamp(pb.dot(this.V, this.ggxSample.xyz), 0, 1);
                    this.$l.charlieL = pb.normalize(pb.reflect(pb.neg(this.V), this.charlieSample.xyz));
                    this.$l.charlieNoL = pb.clamp(this.charlieL.z, 0, 1);
                    this.$l.charlieNoH = pb.clamp(this.charlieSample.z, 0, 1);
                    this.$l.charlieVoH = pb.clamp(pb.dot(this.V, this.charlieSample.xyz), 0, 1);
                    this.$if(pb.greaterThan(this.ggxNoL, 0), function() {
                        this.$l.pdf = pb.div(pb.mul(this.smithGGXCorrelated(this.NoV, this.ggxNoL, this.roughness), this.ggxVoH, this.ggxNoL), this.ggxNoH);
                        this.$l.Fc = pb.pow(pb.sub(1, this.ggxVoH), 5);
                        this.a = pb.add(this.a, pb.mul(pb.sub(1, this.Fc), this.pdf));
                        this.b = pb.add(this.b, pb.mul(this.Fc, this.pdf));
                    });
                    this.$if(pb.greaterThan(this.charlieNoL, 0), function() {
                        this.$l.sheenDistribution = this.D_Charlie(this.roughness, this.charlieNoH);
                        this.$l.sheenVis = this.V_Ashikhmin(this.charlieNoL, this.NoV);
                        this.c = pb.add(this.c, pb.mul(this.sheenVis, this.sheenDistribution, this.charlieNoL, this.charlieVoH));
                    });
                });
                this.$return(pb.div(pb.vec3(pb.mul(this.a, 4), pb.mul(this.b, 4), pb.mul(this.c, 8 * Math.PI)), SAMPLE_COUNT));
            });
            pb.main(function() {
                this.$outputs.color = pb.vec4(this.integrateBRDF(this.$inputs.uv.x, this.$inputs.uv.y), 1);
            });
        }
    });
    const vertexLayout = device.createVertexLayout({
        vertexBuffers: [
            {
                buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                    -1,
                    -1,
                    1,
                    -1,
                    -1,
                    1,
                    1,
                    1
                ]))
            }
        ]
    });
    const rs = device.createRenderStateSet();
    rs.useRasterizerState().setCullMode('none');
    rs.useDepthState().enableTest(false).enableWrite(false);
    const tex = device.createTexture2D('rgba8unorm', size, size, {
        samplerOptions: {
            mipFilter: 'none'
        }
    });
    tex.name = 'GGXLUT';
    const fb = device.createFrameBuffer([
        tex
    ], null);
    device.pushDeviceStates();
    device.setProgram(program);
    device.setVertexLayout(vertexLayout);
    device.setRenderStates(rs);
    device.setFramebuffer(fb);
    device.draw('triangle-strip', 0, 4);
    device.popDeviceStates();
    fb.dispose();
    vertexLayout.dispose();
    program.dispose();
    return tex;
}

/**
 * PBR common stuff mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 *
 * @public
 */ function mixinPBRCommon(BaseCls) {
    if (BaseCls.pbrCommonMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinTextureProps('occlusion'), mixinTextureProps('emissive'), mixinTextureProps('sheenColor'), mixinTextureProps('sheenRoughness'), mixinTextureProps('clearcoatIntensity'), mixinTextureProps('clearcoatRoughness'), mixinTextureProps('clearcoatNormal'));
    let FEATURE_SHEEN = 0;
    let FEATURE_CLEARCOAT = 0;
    const cls = class extends S {
        static pbrCommonMixed = true;
        _f0;
        _emissiveFactor;
        _occlusionStrength;
        _sheenFactor;
        _clearcoatFactor;
        constructor(){
            super();
            this._f0 = new Vector4(0.04, 0.04, 0.04, 1.5);
            this._occlusionStrength = 1;
            this._emissiveFactor = new Vector4(0, 0, 0, 1);
            this._sheenFactor = Vector4.zero();
            this._clearcoatFactor = new Vector4(0, 0, 1, 0);
        }
        get ior() {
            return this._f0.w;
        }
        set ior(val) {
            if (val !== this._f0.w) {
                let k = (val - 1) / (val + 1);
                k *= k;
                this._f0.setXYZW(k, k, k, val);
                this.uniformChanged();
            }
        }
        get occlusionStrength() {
            return this._occlusionStrength;
        }
        set occlusionStrength(val) {
            if (val !== this._occlusionStrength) {
                this._occlusionStrength = val;
                this.uniformChanged();
            }
        }
        get emissiveColor() {
            return this._emissiveFactor.xyz();
        }
        set emissiveColor(val) {
            if (val.x !== this._emissiveFactor.x || val.y !== this._emissiveFactor.y || val.z !== this._emissiveFactor.z) {
                this._emissiveFactor.x = val.x;
                this._emissiveFactor.y = val.y;
                this._emissiveFactor.z = val.z;
                this.uniformChanged();
            }
        }
        get emissiveStrength() {
            return this._emissiveFactor.w;
        }
        set emissiveStrength(val) {
            if (this._emissiveFactor.w !== val) {
                this._emissiveFactor.w = val;
                this.uniformChanged();
            }
        }
        get clearcoat() {
            return this.featureUsed(FEATURE_CLEARCOAT);
        }
        set clearcoat(val) {
            this.useFeature(FEATURE_CLEARCOAT, !!val);
        }
        get clearcoatIntensity() {
            return this._clearcoatFactor.x;
        }
        set clearcoatIntensity(val) {
            if (val !== this._clearcoatFactor.x) {
                this._clearcoatFactor.x = val;
                this.uniformChanged();
            }
        }
        get clearcoatRoughnessFactor() {
            return this._clearcoatFactor.y;
        }
        set clearcoatRoughnessFactor(val) {
            if (val !== this._clearcoatFactor.y) {
                this._clearcoatFactor.y = val;
                this.uniformChanged();
            }
        }
        get clearcoatNormalScale() {
            return this._clearcoatFactor.z;
        }
        set clearcoatNormalScale(val) {
            if (val !== this._clearcoatFactor.z) {
                this._clearcoatFactor.z = val;
                this.uniformChanged();
            }
        }
        get sheen() {
            return this.featureUsed(FEATURE_SHEEN);
        }
        set sheen(val) {
            this.useFeature(FEATURE_SHEEN, !!val);
        }
        get sheenColorFactor() {
            return this._sheenFactor.xyz();
        }
        set sheenColorFactor(val) {
            if (val.x !== this._sheenFactor.x || val.y !== this._sheenFactor.y || val.z !== this._sheenFactor.z) {
                this._sheenFactor.x = val.x;
                this._sheenFactor.y = val.y;
                this._sheenFactor.z = val.z;
                this.uniformChanged();
            }
        }
        get sheenRoughnessFactor() {
            return this._sheenFactor.w;
        }
        set sheenRoughnessFactor(val) {
            if (val !== this._sheenFactor.w) {
                this._sheenFactor.w = val;
                this.uniformChanged();
            }
        }
        fragmentShader(scope) {
            const pb = scope.$builder;
            super.fragmentShader(scope);
            if (this.needFragmentColor()) {
                scope.zF0 = pb.vec4().uniform(2);
                scope.zEmissiveFactor = pb.vec4().uniform(2);
                if (this.occlusionTexture) {
                    scope.zOcclusionStrength = pb.float().uniform(2);
                }
                if (this.sheen) {
                    scope.zSheenFactor = pb.vec4().uniform(2);
                }
                if (this.clearcoat) {
                    scope.zClearcoatFactor = pb.vec4().uniform(2);
                }
                if (this.drawContext.drawEnvLight) {
                    scope.zGGXLut = pb.tex2D().uniform(2);
                }
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zF0', this._f0);
                bindGroup.setValue('zEmissiveFactor', this._emissiveFactor);
                if (this.occlusionTexture) {
                    bindGroup.setValue('zOcclusionStrength', this._occlusionStrength);
                }
                if (this.sheen) {
                    bindGroup.setValue('zSheenFactor', this._sheenFactor);
                }
                if (this.clearcoat) {
                    bindGroup.setValue('zClearcoatFactor', this._clearcoatFactor);
                }
                if (ctx.drawEnvLight) {
                    bindGroup.setTexture('zGGXLut', getGGXLUT(1024));
                }
            }
        }
        getF0(scope) {
            return scope.zF0;
        }
        getCommonDatasStruct(scope) {
            const pb = scope.$builder;
            return pb.defineStruct([
                pb.vec4('f0'),
                pb.vec3('f90'),
                pb.vec4('diffuse'),
                pb.float('metallic'),
                pb.float('roughness'),
                pb.float('specularWeight'),
                ...this.sheen ? [
                    pb.float('sheenAlbedoScaling'),
                    pb.vec3('sheenColor'),
                    pb.float('sheenRoughness')
                ] : [],
                ...this.clearcoat ? [
                    pb.vec4('ccFactor'),
                    pb.vec3('ccNormal'),
                    pb.float('ccNoV'),
                    pb.float('ccFresnel')
                ] : []
            ]);
        }
        getCommonData(scope, albedo, viewVec, TBN) {
            const pb = scope.$builder;
            const that = this;
            const funcName = 'Z_getCommonData';
            pb.func(funcName, [
                pb.vec4('albedo'),
                pb.vec3('viewVec'),
                pb.mat3('TBN')
            ], function() {
                this.$l.data = that.getCommonDatasStruct(this)();
                that.calculateCommonData(this, this.albedo, this.viewVec, this.TBN, this.data);
                this.$return(this.data);
            });
            return scope.$g[funcName](albedo, viewVec, TBN);
        }
        calculateCommonData(scope, albedo, viewVec, TBN, data) {
            const pb = scope.$builder;
            if (this.sheen) {
                if (this.sheenColorTexture) {
                    data.sheenColor = pb.mul(this.sampleSheenColorTexture(scope).rgb, scope.zSheenFactor.rgb);
                } else {
                    data.sheenColor = scope.zSheenFactor.rgb;
                }
                if (this.sheenRoughnessTexture) {
                    data.sheenRoughness = pb.mul(this.sampleSheenRoughnessTexture(scope).a, scope.zSheenFactor.a);
                } else {
                    data.sheenRoughness = scope.zSheenFactor.a;
                }
                scope.$l.sheenDFG = 0.157;
                data.sheenAlbedoScaling = pb.sub(1, pb.mul(pb.max(pb.max(data.sheenColor.r, data.sheenColor.g), data.sheenColor.b), scope.sheenDFG));
            }
            if (this.clearcoat) {
                if (this.clearcoatNormalTexture) {
                    const ccNormal = pb.mul(pb.sub(pb.mul(this.sampleClearcoatNormalTexture(scope).rgb, 2), pb.vec3(1)), pb.vec3(scope.zClearcoatFactor.zz, 1));
                    data.ccNormal = pb.normalize(pb.mul(TBN, ccNormal));
                } else {
                    data.ccNormal = TBN[2];
                }
                data.ccNoV = pb.clamp(pb.dot(data.ccNormal, viewVec), 0.0001, 1);
                data.ccFactor = scope.zClearcoatFactor;
                if (this.clearcoatIntensityTexture) {
                    data.ccFactor.x = pb.mul(data.ccFactor.x, this.sampleClearcoatIntensityTexture(scope).r);
                }
                if (this.clearcoatRoughnessTexture) {
                    data.ccFactor.y = pb.clamp(pb.mul(data.ccFactor.y, this.sampleClearcoatRoughnessTexture(scope).g), 0, 1);
                }
            }
        }
        calculateEmissiveColor(scope) {
            const pb = scope.$builder;
            if (this.emissiveTexture) {
                return pb.mul(this.sampleEmissiveTexture(scope).rgb, scope.zEmissiveFactor.rgb, scope.zEmissiveFactor.a);
            } else {
                return pb.mul(scope.zEmissiveFactor.rgb, scope.zEmissiveFactor.a);
            }
        }
        D_Charlie(scope, NdotH, sheenRoughness) {
            const funcNameDCharlie = 'Z_DCharlie';
            const pb = scope.$builder;
            pb.func(funcNameDCharlie, [
                pb.float('NdotH'),
                pb.float('sheenRoughness')
            ], function() {
                this.$l.alphaG = pb.mul(this.sheenRoughness, this.sheenRoughness);
                this.$l.invR = pb.div(1, this.alphaG);
                this.$l.cos2h = pb.mul(this.NdotH, this.NdotH);
                this.$l.sin2h = pb.max(pb.sub(1, this.cos2h), 0.0078125);
                this.$return(pb.div(pb.mul(pb.add(this.invR, 2), pb.pow(this.sin2h, pb.mul(this.invR, 0.5))), 2 * Math.PI));
            });
            return scope.$g[funcNameDCharlie](NdotH, sheenRoughness);
        }
        V_Ashikhmin(scope, NdotL, NdotV) {
            const funcNameVAshikhmin = 'Z_VAshikhmin';
            const pb = scope.$builder;
            pb.func(funcNameVAshikhmin, [
                pb.float('NdotL'),
                pb.float('NdotV')
            ], function() {
                this.$return(pb.clamp(pb.div(1, pb.mul(pb.sub(pb.add(this.NdotL, this.NdotV), pb.mul(this.NdotL, this.NdotV)), 4)), 0, 1));
            });
            return scope.$g[funcNameVAshikhmin](NdotL, NdotV);
        }
        directLighting(scope, lightDir, lightColor, normal, viewVec, commonData, outColor) {
            const pb = scope.$builder;
            const that = this;
            const funcName = 'Z_PBRDirectLighting';
            pb.func(funcName, [
                pb.vec3('L'),
                pb.vec3('lightColor'),
                pb.vec3('normal'),
                pb.vec3('viewVec'),
                that.getCommonDatasStruct(scope)('data'),
                pb.vec3('outColor').inout()
            ], function() {
                this.$l.H = pb.normalize(pb.add(this.viewVec, this.L));
                this.$l.NoH = pb.clamp(pb.dot(this.normal, this.H), 0, 1);
                this.$l.NoL = pb.clamp(pb.dot(this.normal, this.L), 0, 1);
                this.$l.NoV = pb.clamp(pb.dot(this.normal, this.viewVec), 0, 1);
                this.$if(pb.greaterThan(this.NoL, 0), function() {
                    this.$l.VoH = pb.clamp(pb.dot(this.viewVec, this.H), 0, 1);
                    this.$l.F = that.fresnelSchlick(this, this.VoH, this.data.f0.rgb, this.data.f90);
                    this.$l.alphaRoughness = pb.mul(this.data.roughness, this.data.roughness);
                    this.$l.D = that.distributionGGX(this, this.NoH, this.alphaRoughness);
                    this.$l.V = that.visGGX(this, this.NoV, this.NoL, this.alphaRoughness);
                    this.$l.specular = pb.mul(this.lightColor, this.D, this.V, this.F, this.data.specularWeight);
                    if (that.sheen) {
                        this.specular = pb.mul(this.specular, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.specular);
                    this.$l.diffuse = pb.mul(this.lightColor, pb.max(pb.mul(pb.sub(pb.vec3(1), pb.mul(this.F, this.data.specularWeight)), pb.div(this.data.diffuse.rgb, Math.PI)), pb.vec3(0)));
                    if (that.sheen) {
                        this.diffuse = pb.mul(this.diffuse, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.diffuse);
                    if (that.sheen) {
                        this.$l.sheenD = that.D_Charlie(this, this.NoH, this.data.sheenRoughness);
                        this.$l.sheenV = that.V_Ashikhmin(this, this.NoL, this.NoV);
                        this.outColor = pb.add(this.outColor, pb.mul(this.lightColor, this.data.sheenColor, this.sheenD, this.sheenV));
                    }
                    if (that.clearcoat) {
                        this.alphaRoughness = pb.mul(this.data.ccFactor.y, this.data.ccFactor.y);
                        this.NoH = pb.clamp(pb.dot(this.data.ccNormal, this.H), 0, 1);
                        this.NoL = pb.clamp(pb.dot(this.data.ccNormal, this.L), 0, 1);
                        this.ccF0 = pb.vec3(pb.pow(pb.div(pb.sub(this.data.f0.a, 1), pb.add(this.data.f0.a, 1)), 2));
                        this.F = that.fresnelSchlick(this, this.VoH, this.ccF0, pb.vec3(1));
                        this.D = that.distributionGGX(this, this.NoH, this.alphaRoughness);
                        this.V = that.visGGX(this, this.data.ccNoV, this.NoL, this.alphaRoughness);
                        this.outColor = pb.add(this.outColor, pb.mul(this.D, this.V, this.F, this.data.ccFactor.x));
                    }
                });
            });
            scope.$g[funcName](lightDir, lightColor, normal, viewVec, commonData, outColor);
        }
        indirectLighting(scope, normal, viewVec, commonData, outColor) {
            const pb = scope.$builder;
            const that = this;
            const ctx = that.drawContext;
            const funcName = 'Z_PBRIndirectLighting';
            pb.func(funcName, [
                pb.vec3('normal'),
                pb.vec3('viewVec'),
                that.getCommonDatasStruct(scope)('data'),
                pb.vec3('outColor').inout()
            ], function() {
                if (!ctx.drawEnvLight || !ctx.env.light.envLight.hasRadiance() && !ctx.env.light.envLight.hasIrradiance()) {
                    return;
                }
                const envLightStrength = ShaderHelper.getEnvLightStrength(this);
                if (that.occlusionTexture) {
                    const occlusionSample = that.sampleOcclusionTexture(this).r;
                    this.$l.occlusion = pb.mul(pb.add(pb.mul(this.zOcclusionStrength, pb.sub(occlusionSample, 1)), 1), envLightStrength);
                } else {
                    this.$l.occlusion = envLightStrength;
                }
                this.$l.NoV = pb.clamp(pb.dot(this.normal, this.viewVec), 0.0001, 1);
                this.$l.ggxLutSample = pb.clamp(pb.textureSampleLevel(this.zGGXLut, pb.clamp(pb.vec2(this.NoV, this.data.roughness), pb.vec2(0), pb.vec2(1)), 0), pb.vec4(0), pb.vec4(1));
                this.$l.f_ab = this.ggxLutSample.rg;
                this.$l.Fr = pb.sub(pb.max(pb.vec3(pb.sub(1, this.data.roughness)), this.data.f0.rgb), this.data.f0.rgb);
                this.$l.k_S = pb.add(this.data.f0.rgb, pb.mul(this.Fr, pb.pow(pb.sub(1, this.NoV), 5)));
                if (ctx.env.light.envLight.hasRadiance()) {
                    this.$l.radiance = ctx.env.light.envLight.getRadiance(this, pb.reflect(pb.neg(this.viewVec), this.normal), this.data.roughness);
                    this.$l.FssEss = pb.add(pb.mul(this.k_S, this.f_ab.x), pb.vec3(this.f_ab.y));
                    this.$l.iblSpecular = pb.mul(this.radiance, this.FssEss, this.data.specularWeight, this.occlusion);
                    if (that.sheen) {
                        this.iblSpecular = pb.mul(this.iblSpecular, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.iblSpecular);
                }
                if (ctx.env.light.envLight.hasIrradiance()) {
                    this.$l.irradiance = ctx.env.light.envLight.getIrradiance(this, this.normal);
                    this.$l.FssEss = pb.add(pb.mul(this.k_S, this.f_ab.x, this.data.specularWeight), pb.vec3(this.f_ab.y));
                    this.$l.Ems = pb.sub(1, pb.add(this.f_ab.x, this.f_ab.y));
                    this.$l.F_avg = pb.mul(pb.add(this.data.f0.rgb, pb.div(pb.sub(pb.vec3(1), this.data.f0.rgb), 21)), this.data.specularWeight);
                    this.$l.FmsEms = pb.div(pb.mul(this.FssEss, this.F_avg, this.Ems), pb.sub(pb.vec3(1), pb.mul(this.F_avg, this.Ems)));
                    this.$l.k_D = pb.mul(this.data.diffuse.rgb, pb.add(pb.sub(pb.vec3(1), this.FssEss), this.FmsEms));
                    this.$l.iblDiffuse = pb.mul(pb.add(this.FmsEms, this.k_D), this.irradiance, this.occlusion);
                    if (that.sheen) {
                        this.iblDiffuse = pb.mul(this.iblDiffuse, this.data.sheenAlbedoScaling);
                    }
                    this.outColor = pb.add(this.outColor, this.iblDiffuse);
                }
                if (that.sheen && ctx.env.light.envLight.hasIrradiance()) {
                    this.$l.refl = pb.reflect(pb.neg(this.viewVec), this.normal);
                    this.$l.sheenBRDF = pb.clamp(pb.textureSampleLevel(this.zGGXLut, pb.clamp(pb.vec2(this.NoV, this.data.sheenRoughness), pb.vec2(0), pb.vec2(1)), 0), pb.vec4(0), pb.vec4(1)).b;
                    this.outColor = pb.add(this.outColor, pb.mul(this.data.sheenColor, this.irradiance.rgb, this.sheenBRDF));
                }
                if (that.clearcoat && ctx.env.light.envLight.hasRadiance()) {
                    this.$l.NoV = pb.clamp(pb.dot(this.data.ccNormal, this.viewVec), 0.0001, 1);
                    this.$l.ggxLutSample = pb.clamp(pb.textureSampleLevel(this.zGGXLut, pb.clamp(pb.vec2(this.NoV, this.data.ccFactor.y), pb.vec2(0), pb.vec2(1)), 0), pb.vec4(0), pb.vec4(1));
                    this.$l.f_ab = this.ggxLutSample.rg;
                    this.$l.Fr = pb.sub(pb.max(pb.vec3(pb.sub(1, this.data.ccFactor.y)), this.data.f0.rgb), this.data.f0.rgb);
                    this.$l.k_S = pb.add(this.data.f0.rgb, pb.mul(this.Fr, pb.pow(pb.sub(1, this.NoV), 5)));
                    this.$l.radiance = ctx.env.light.envLight.getRadiance(this, pb.reflect(pb.neg(this.viewVec), this.data.ccNormal), this.data.ccFactor.y);
                    this.$l.FssEss = pb.add(pb.mul(this.k_S, this.f_ab.x), pb.vec3(this.f_ab.y));
                    this.$l.ccSpecular = pb.mul(this.radiance, this.FssEss, this.data.specularWeight, this.occlusion);
                    this.outColor = pb.add(this.outColor, pb.mul(this.ccSpecular, this.data.ccFactor.x));
                }
            });
            scope.$g[funcName](normal, viewVec, commonData, outColor);
        }
        fresnelSchlick(scope, cosTheta, F0, F90) {
            const pb = scope.$builder;
            const funcName = 'Z_fresnelSchlick';
            pb.func(funcName, [
                pb.float('cosTheta'),
                pb.vec3('f0'),
                pb.vec3('f90')
            ], function() {
                this.$return(pb.add(this.f0, pb.mul(pb.sub(this.f90, this.f0), pb.pow(pb.clamp(pb.sub(1, this.cosTheta), 0, 1), 5))));
            });
            return scope.$g[funcName](cosTheta, F0, F90);
        }
        distributionGGX(scope, NdotH, alphaRoughness) {
            const pb = scope.$builder;
            const funcName = 'Z_distributionGGX';
            pb.func(funcName, [
                pb.float('NdotH'),
                pb.float('roughness')
            ], function() {
                this.$l.a2 = pb.mul(this.roughness, this.roughness);
                this.$l.NdotH2 = pb.mul(this.NdotH, this.NdotH);
                this.$l.num = this.a2;
                this.$l.denom = pb.add(pb.mul(this.NdotH2, pb.sub(this.a2, 1)), 1);
                this.denom = pb.mul(pb.mul(3.14159265, this.denom), this.denom);
                this.$return(pb.div(this.num, this.denom));
            });
            return scope.$g[funcName](NdotH, alphaRoughness);
        }
        visGGX(scope, NdotV, NdotL, alphaRoughness) {
            const pb = scope.$builder;
            const funcName = 'Z_visGGX';
            pb.func(funcName, [
                pb.float('NdotV'),
                pb.float('NdotL'),
                pb.float('roughness')
            ], function() {
                this.$l.a = this.roughness;
                this.$l.ggxV = pb.mul(this.NdotL, pb.sqrt(pb.add(pb.mul(this.NdotV, this.NdotV, pb.sub(1, this.a)), this.a)));
                this.$l.ggxL = pb.mul(this.NdotV, pb.sqrt(pb.add(pb.mul(this.NdotL, this.NdotL, pb.sub(1, this.a)), this.a)));
                this.$l.ggx = pb.add(this.ggxV, this.ggxL, 1e-5);
                this.$if(pb.greaterThan(this.ggx, 0), function() {
                    this.$return(pb.div(0.5, this.ggx));
                }).$else(function() {
                    this.$return(pb.float(0));
                });
            });
            return scope.$g[funcName](NdotV, NdotL, alphaRoughness);
        }
    };
    FEATURE_SHEEN = cls.defineFeature();
    FEATURE_CLEARCOAT = cls.defineFeature();
    return cls;
}

/**
 * PBRMetallicRoughness lighting model mixin
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 * @public
 */ function mixinPBRMetallicRoughness(BaseCls) {
    if (BaseCls.pbrMetallicRoughnessMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinPBRCommon, mixinLight, mixinTextureProps('metallicRoughness'), mixinTextureProps('occlusion'), mixinTextureProps('specular'), mixinTextureProps('specularColor'));
    return class extends S {
        static pbrMetallicRoughnessMixed = true;
        _metallic;
        _roughness;
        _specularFactor;
        constructor(){
            super();
            this._metallic = 1;
            this._roughness = 1;
            this._specularFactor = Vector4.one();
        }
        get metallic() {
            return this._metallic;
        }
        set metallic(val) {
            if (val !== this._metallic) {
                this._metallic = val;
                this.uniformChanged();
            }
        }
        get roughness() {
            return this._roughness;
        }
        set roughness(val) {
            if (val !== this._roughness) {
                this._roughness = val;
                this.uniformChanged();
            }
        }
        get specularFactor() {
            return this._specularFactor;
        }
        set specularFactor(val) {
            if (!val.equalsTo(this._specularFactor)) {
                this._specularFactor.set(val);
                this.uniformChanged();
            }
        }
        PBRLight(scope, worldPos, normal, viewVec, albedo, TBN) {
            const pb = scope.$builder;
            const funcName = 'Z_PBRMetallicRoughnessLight';
            const that = this;
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec3('normal'),
                pb.mat3('TBN'),
                pb.vec3('viewVec'),
                pb.vec4('albedo')
            ], function() {
                this.$l.pbrData = that.getCommonData(this, this.albedo, this.viewVec, this.TBN);
                this.$l.lightingColor = pb.vec3(0);
                this.$l.emissiveColor = that.calculateEmissiveColor(this);
                that.indirectLighting(this, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                that.forEachLight(this, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                    this.$l.diffuse = pb.vec3();
                    this.$l.specular = pb.vec3();
                    this.$l.lightAtten = that.calculateLightAttenuation(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.lightDir = that.calculateLightDirection(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                    this.$l.lightColor = pb.mul(colorIntensity.rgb, colorIntensity.a, this.lightAtten, this.NoL);
                    if (shadow) {
                        this.lightColor = pb.mul(this.lightColor, that.calculateShadow(this, this.worldPos, this.NoL));
                    }
                    that.directLighting(this, this.lightDir, this.lightColor, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                });
                this.$return(pb.add(this.lightingColor, this.emissiveColor));
            });
            return pb.getGlobalScope()[funcName](worldPos, normal, TBN, viewVec, albedo);
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            if (this.needFragmentColor()) {
                const pb = scope.$builder;
                scope.zMetallic = pb.float().uniform(2);
                scope.zRoughness = pb.float().uniform(2);
                scope.zSpecularFactor = pb.vec4().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zMetallic', this._metallic);
                bindGroup.setValue('zRoughness', this._roughness);
                bindGroup.setValue('zSpecularFactor', this._specularFactor);
            }
        }
        calculateCommonData(scope, albedo, viewVec, TBN, data) {
            super.calculateCommonData(scope, albedo, viewVec, TBN, data);
            const pb = scope.$builder;
            if (this.metallicRoughnessTexture) {
                scope.$l.metallicRoughnessSample = this.sampleMetallicRoughnessTexture(scope);
                data.metallic = pb.mul(scope.zMetallic, scope.metallicRoughnessSample.z);
                data.roughness = pb.mul(scope.zRoughness, scope.metallicRoughnessSample.y);
            } else {
                data.metallic = scope.zMetallic;
                data.roughness = scope.zRoughness;
            }
            if (this.specularColorTexture) {
                scope.$l.specularColor = pb.mul(scope.zSpecularFactor.rgb, this.sampleSpecularColorTexture(scope).rgb);
            } else {
                scope.$l.specularColor = scope.zSpecularFactor.rgb;
            }
            if (this.specularTexture) {
                data.specularWeight = pb.mul(scope.zSpecularFactor.a, this.sampleSpecularTexture(scope).a);
            } else {
                data.specularWeight = scope.zSpecularFactor.a;
            }
            data.f0 = pb.vec4(pb.mix(pb.min(pb.mul(this.getF0(scope).rgb, scope.specularColor), pb.vec3(1)), albedo.rgb, data.metallic), this.getF0(scope).a);
            data.f90 = pb.vec3(1);
            data.diffuse = pb.vec4(pb.mix(albedo.rgb, pb.vec3(0), data.metallic), albedo.a);
        }
    };
}

/**
 * Foliage mixin
 *
 * @param BaseCls - Class to mix in
 * @returns Mixed class
 *
 * @public
 */ function mixinFoliage(BaseCls) {
    if (BaseCls.foliageMixed) {
        return BaseCls;
    }
    return class extends BaseCls {
        static foliageMixed = true;
        constructor(...args){
            super(...args);
            this.cullMode = 'none';
        }
        calculateFoliageAlbedo(scope, albedoColor, texelCoord) {
            const pb = scope.$builder;
            const that = this;
            const funcNameCalcMipLevel = 'Z_CalcFoliageMipLevel';
            pb.func(funcNameCalcMipLevel, [
                pb.vec2('coord')
            ], function() {
                this.$l.dx = pb.dpdx(this.coord);
                this.$l.dy = pb.dpdy(this.coord);
                this.$l.deltaMaxSqr = pb.max(pb.dot(this.dx, this.dx), pb.dot(this.dy, this.dy));
                this.$return(pb.max(0, pb.mul(pb.log2(this.deltaMaxSqr), 0.5)));
            });
            const funcNameCalcFoliageAlbedo = 'Z_calcFoliageAlbedo';
            pb.func(funcNameCalcFoliageAlbedo, [
                pb.vec4('albedo'),
                pb.vec2('coord')
            ], function() {
                this.$l.a = pb.mul(this.albedo.a, pb.add(1, pb.mul(pb.max(0, scope[funcNameCalcMipLevel](this.coord)), 0.25)));
                if (that.alphaToCoverage) {
                    this.a = pb.add(pb.div(pb.sub(this.a, 0.4), pb.max(pb.fwidth(this.albedo.a), 0.0001)), 0.5);
                }
                this.$return(pb.vec4(this.albedo.rgb, this.a));
            });
            return pb.getGlobalScope()[funcNameCalcFoliageAlbedo](albedoColor, texelCoord);
        }
    };
}

/**
 * Terrain grass material
 * @public
 */ class GrassMaterial extends applyMaterialMixins(MeshMaterial, mixinPBRMetallicRoughness, mixinFoliage) {
    /** @internal */ _terrainSize;
    /** @internal */ _terrainNormalMap;
    /** @internal */ _textureSize;
    /**
   * Creates an instance of GrassMaterial class
   * @param terrainSize - terrain size
   * @param normalMap - normal map
   * @param grassTexture - grass texture
   */ constructor(terrainSize, normalMap, grassTexture){
        super();
        this.metallic = 0;
        this.roughness = 1;
        this.specularFactor = new Vector4(1, 1, 1, 0.2);
        this.doubleSidedLighting = false;
        this._terrainSize = terrainSize;
        this._terrainNormalMap = normalMap;
        this._textureSize = Vector2.one();
        if (grassTexture) {
            this.albedoTexture = grassTexture;
            this._textureSize.setXY(grassTexture.width, grassTexture.height);
        }
    }
    /**
   * {@inheritDoc MeshMaterial.isTransparentPass}
   * @override
   */ isTransparentPass(pass) {
        return false;
    }
    /**
   * {@inheritDoc Material.supportLighting}
   * @override
   */ supportLighting() {
        return true;
    }
    /**
   * {@inheritDoc Material.supportInstancing}
   * @override
   */ supportInstancing() {
        return false;
    }
    applyUniformValues(bindGroup, ctx, pass) {
        super.applyUniformValues(bindGroup, ctx, pass);
        bindGroup.setTexture('terrainNormalMap', this._terrainNormalMap);
        bindGroup.setValue('terrainSize', this._terrainSize);
        if (this.needFragmentColor(ctx)) {
            bindGroup.setValue('albedoTextureSize', this._textureSize);
        }
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$inputs.pos = pb.vec3().attrib('position');
        scope.$inputs.placement = pb.vec4().attrib('texCoord1');
        scope.terrainNormalMap = pb.tex2D().uniform(2);
        scope.terrainSize = pb.vec2().uniform(2);
        const normalSample = pb.textureSampleLevel(scope.terrainNormalMap, pb.div(scope.$inputs.placement.xz, scope.terrainSize), 0).rgb;
        scope.$l.normal = pb.normalize(pb.sub(pb.mul(normalSample, 2), pb.vec3(1)));
        scope.$l.axisX = pb.vec3(1, 0, 0);
        scope.$l.axisZ = pb.cross(scope.axisX, scope.normal);
        scope.$l.axisX = pb.cross(scope.normal, scope.axisZ);
        scope.$l.rotPos = pb.mul(pb.mat3(scope.axisX, scope.normal, scope.axisZ), scope.$inputs.pos);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(pb.add(scope.rotPos, scope.$inputs.placement.xyz), 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        scope.$outputs.worldNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.normal, 0)).xyz;
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            scope.albedoTextureSize = pb.vec2().uniform(2);
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            scope.albedo = that.calculateFoliageAlbedo(scope, scope.albedo, pb.mul(that.getAlbedoTexCoord(scope), scope.albedoTextureSize));
            scope.$l.litColor = pb.vec3(0);
            if (this.drawContext.renderPass.type === RENDER_PASS_TYPE_LIGHT) {
                scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.worldNorm);
                scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
                scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            }
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
    apply(ctx) {
        this.alphaToCoverage = ctx.device.getFrameBufferSampleCount() > 1;
        this.alphaCutoff = this.alphaToCoverage ? 1 : 0.8;
        return super.apply(ctx);
    }
    updateRenderStates(pass, stateSet, ctx) {
        super.updateRenderStates(pass, stateSet, ctx);
        stateSet.useRasterizerState().setCullMode('none');
    }
}

let quadVertexLayout = null;
let quadRenderStateSet = null;
function drawFullscreenQuad(renderStates) {
    const device = Application.instance.device;
    if (!quadVertexLayout) {
        quadVertexLayout = device.createVertexLayout({
            vertexBuffers: [
                {
                    buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                        -1,
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1
                    ]))
                }
            ]
        });
    }
    if (!quadRenderStateSet) {
        quadRenderStateSet = device.createRenderStateSet();
        quadRenderStateSet.useRasterizerState().setCullMode('none');
        quadRenderStateSet.useDepthState().enableTest(false).enableWrite(false);
    }
    const saveRenderStateSet = device.getRenderStates();
    device.setRenderStates(renderStates ?? quadRenderStateSet);
    device.setVertexLayout(quadVertexLayout);
    device.draw('triangle-strip', 0, 4);
    device.setRenderStates(saveRenderStateSet);
}

/**
 * Terrain material class
 * @public
 */ class TerrainMaterial extends applyMaterialMixins(MeshMaterial, mixinLight, mixinPBRMetallicRoughness) {
    static _metallicRoughnessGenerationProgram = null;
    static _metallicRoughnessGenerationBindGroup = null;
    _options;
    _uvScales;
    _numDetailMaps;
    _terrainInfo;
    constructor(options){
        super();
        this.normalMapMode = 'object-space';
        this._options = null;
        this._numDetailMaps = 0;
        this._uvScales = null;
        this._terrainInfo = null;
        if (options && options.splatMap && options.detailMaps && options.detailMaps.albedoTextures) {
            this._options = Object.assign({}, options);
            const albedoTextures = this._options.detailMaps.albedoTextures;
            this._numDetailMaps = Array.isArray(albedoTextures) ? albedoTextures.length : albedoTextures.depth;
            if (!this._numDetailMaps) {
                throw new Error(`TerrainMaterial(): Invalid detail textures`);
            }
            if (this._numDetailMaps > 4) {
                throw new Error(`TerrainMaterial(): The maximum detail levels is 4`);
            }
            if (!this._options.detailMaps.uvScale || this._options.detailMaps.uvScale.length !== this._numDetailMaps) {
                throw new Error(`TerrainMaterial(): Invalid uv scale`);
            }
            this._uvScales = new Float32Array(this._numDetailMaps * 4);
            for(let i = 0; i < this._numDetailMaps; i++){
                this._uvScales[i * 4] = this._options.detailMaps.uvScale[i];
                this._uvScales[i * 4 + 1] = 1;
                this._uvScales[i * 4 + 2] = 0.01;
                this._uvScales[i * 4 + 3] = 0.99;
            }
            if (this._options.detailMaps.metallic) {
                if (this._options.detailMaps.metallic.length !== this._numDetailMaps) {
                    throw new Error(`TerrainMaterial(): Invalid metallic values`);
                }
                for(let i = 0; i < this._numDetailMaps; i++){
                    this._uvScales[i * 4 + 2] = this._options.detailMaps.metallic[i];
                }
            }
            if (this._options.detailMaps.roughness) {
                if (this._options.detailMaps.roughness.length !== this._numDetailMaps) {
                    throw new Error(`TerrainMaterial(): Invalid roughness values`);
                }
                for(let i = 0; i < this._numDetailMaps; i++){
                    this._uvScales[i * 4 + 3] = this._options.detailMaps.roughness[i];
                }
            }
            const normalTextures = options.detailMaps.normalTextures;
            if (normalTextures) {
                const m = Array.isArray(normalTextures) ? normalTextures.length : normalTextures.depth;
                if (m !== this._numDetailMaps) {
                    throw new Error(`TerrainMaterial(): The number of normal textures not match the number of albedo textures`);
                }
                if (options.detailMaps.normalScale) {
                    if (options.detailMaps.normalScale.length !== this._numDetailMaps) {
                        throw new Error(`TerrainMaterial(): Invalid normal scale`);
                    }
                    for(let i = 0; i < this._numDetailMaps; i++){
                        this._uvScales[i * 4 + 1] = options.detailMaps.normalScale[i];
                    }
                }
            }
            this._options = Object.assign({}, options);
            if (Array.isArray(albedoTextures)) {
                for(let i = 0; i < albedoTextures.length; i++){
                    if (!albedoTextures[i]) {
                        throw new Error(`TerrainMaterial(): Invalid detail albedo texture`);
                    }
                    albedoTextures[i].samplerOptions = {
                        addressU: 'repeat',
                        addressV: 'repeat'
                    };
                }
            } else {
                albedoTextures.samplerOptions = {
                    addressU: 'repeat',
                    addressV: 'repeat'
                };
            }
            if (Array.isArray(normalTextures)) {
                for(let i = 0; i < normalTextures.length; i++){
                    if (!normalTextures[i]) {
                        throw new Error(`TerrainMaterial(): Invalid detail normal texture`);
                    }
                    normalTextures[i].samplerOptions = {
                        addressU: 'repeat',
                        addressV: 'repeat'
                    };
                }
            } else if (normalTextures) {
                normalTextures.samplerOptions = {
                    addressU: 'repeat',
                    addressV: 'repeat'
                };
            }
        }
        this.metallicRoughnessTexture = this.generateMetallicRoughnessMap();
        this.metallicRoughnessTexCoordIndex = -1;
        this.albedoTexCoordIndex = -1;
        this.normalTexCoordIndex = -1;
    }
    get terrainInfo() {
        return this._terrainInfo;
    }
    set terrainInfo(val) {
        this._terrainInfo = val;
        this.uniformChanged();
    }
    /**
   * {@inheritDoc MeshMaterial.isTransparentPass}
   * @override
   */ isTransparentPass(pass) {
        return false;
    }
    /**
   * {@inheritDoc Material.supportLighting}
   * @override
   */ supportLighting() {
        return true;
    }
    /**
   * {@inheritDoc Material.supportInstancing}
   * @override
   */ supportInstancing() {
        return false;
    }
    /**
   * {@inheritDoc Material.isBatchable}
   * @override
   */ isBatchable() {
        return false;
    }
    applyUniformValues(bindGroup, ctx, pass) {
        super.applyUniformValues(bindGroup, ctx, pass);
        if (this.needFragmentColor(ctx)) {
            bindGroup.setValue('terrainInfo', this._terrainInfo);
            if (this._options) {
                bindGroup.setValue('detailScales', this._uvScales);
                bindGroup.setTexture('splatMap', this._options.splatMap);
                if (Array.isArray(this._options.detailMaps.albedoTextures)) {
                    for(let i = 0; i < this._numDetailMaps; i++){
                        bindGroup.setTexture(`detailAlbedoMap${i}`, this._options.detailMaps.albedoTextures[i]);
                    }
                } else {
                    bindGroup.setTexture('detailAlbedoMap', this._options.detailMaps.albedoTextures);
                }
                if (Array.isArray(this._options.detailMaps.normalTextures)) {
                    for(let i = 0; i < this._numDetailMaps; i++){
                        bindGroup.setTexture(`detailNormalMap${i}`, this._options.detailMaps.normalTextures[i]);
                    }
                } else {
                    bindGroup.setTexture('detailNormalMap', this._options.detailMaps.normalTextures);
                }
            }
        }
    }
    /** @ts-ignore */ getMetallicRoughnessTexCoord(scope) {
        return scope.$inputs.mapUV;
    }
    /** @ts-ignore */ getNormalTexCoord(scope) {
        return scope.$inputs.mapUV;
    }
    /** @ts-ignore */ getAlbedoTexCoord(scope) {
        return scope.$inputs.mapUV;
    }
    calculateAlbedoColor(scope) {
        if (!this._options) {
            return super.calculateAlbedoColor(scope);
        }
        const that = this;
        const pb = scope.$builder;
        const funcName = 'getTerrainAlbedo';
        pb.func(funcName, [], function() {
            this.$l.mask = pb.textureSample(this.splatMap, this.$inputs.mapUV);
            this.$l.color = pb.vec3(0);
            const useTextureArray = !Array.isArray(that._options.detailMaps.albedoTextures);
            for(let i = 0; i < that._numDetailMaps; i++){
                const uv = pb.mul(this.$inputs.mapUV, this.detailScales.at(i).x);
                const sample = useTextureArray ? pb.textureArraySample(this.detailAlbedoMap, uv, i).rgb : pb.textureSample(this[`detailAlbedoMap${i}`], uv).rgb;
                this.color = pb.add(this.color, pb.mul(sample, this.mask[i]));
            }
            this.$return(pb.vec4(this.color, 1));
        });
        return pb.getGlobalScope()[funcName]();
    }
    sampleDetailNormalMap(scope, tex, texCoord, normalScale, TBN) {
        const pb = scope.$builder;
        const pixel = pb.sub(pb.mul(pb.textureSample(tex, texCoord).rgb, 2), pb.vec3(1));
        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(normalScale).xx, 1));
        return pb.normalize(pb.mul(TBN, normalTex));
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.needFragmentColor()) {
            scope.terrainInfo = pb.vec4().uniform(2);
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.worldNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            scope.$outputs.mapUV = pb.div(scope.oPos.xz, scope.terrainInfo.xy);
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        const that = this;
        if (this.needFragmentColor()) {
            if (this._options) {
                scope.detailScales = pb.vec4[this._numDetailMaps]().uniform(2);
                scope.splatMap = pb.tex2D().uniform(2);
                const useAlbedoTextureArray = !Array.isArray(that._options.detailMaps.albedoTextures);
                if (useAlbedoTextureArray) {
                    scope.detailAlbedoMap = pb.tex2DArray().uniform(2);
                } else {
                    for(let i = 0; i < that._numDetailMaps; i++){
                        scope[`detailAlbedoMap${i}`] = pb.tex2D().uniform(2);
                    }
                }
                const useNormalTextureArray = !Array.isArray(that._options.detailMaps.normalTextures);
                if (useNormalTextureArray) {
                    scope.detailNormalMap = pb.tex2DArray().uniform(2);
                } else {
                    for(let i = 0; i < that._numDetailMaps; i++){
                        scope[`detailNormalMap${i}`] = pb.tex2D().uniform(2);
                    }
                }
            }
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.worldNorm);
            let calcNormal = false;
            if (this._options && this._options.detailMaps.normalTextures) {
                scope.$l.detailMask = pb.textureSample(scope.splatMap, scope.$inputs.mapUV);
                if (Array.isArray(this._options.detailMaps.normalTextures)) {
                    for(let i = 0; i < this._options.detailMaps.normalTextures.length; i++){
                        const tex = scope[`detailNormalMap${i}`];
                        const scale = scope.detailScales.at(i).y;
                        const texCoord = pb.mul(scope.$inputs.mapUV, scope.detailScales.at(i).x);
                        scope.normalInfo.normal = pb.add(scope.normalInfo.normal, pb.mul(this.sampleDetailNormalMap(scope, tex, texCoord, scale, scope.normalInfo.TBN), scope.detailMask[i]));
                        calcNormal = true;
                    }
                } else {
                    const tex = scope.detailNormalMap;
                    for(let i = 0; i < this._numDetailMaps; i++){
                        const scale = scope.detailScales.at(i).y;
                        const texCoord = pb.mul(scope.$inputs.mapUV, scope.detailScales.at(i).x);
                        const pixel = pb.sub(pb.mul(pb.textureArraySample(tex, texCoord, i).rgb, 2), pb.vec3(1));
                        const normalTex = pb.mul(pixel, pb.vec3(pb.vec3(scale).xx, 1));
                        const detailNormal = pb.normalize(pb.mul(scope.normalInfo.TBN, normalTex));
                        scope.normalInfo.normal = pb.add(scope.normalInfo.normal, pb.mul(detailNormal, scope.detailMask[i]));
                        calcNormal = true;
                    }
                }
            }
            if (calcNormal) {
                scope.normalInfo.normal = pb.normalize(scope.normalInfo.normal);
            }
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
    generateMetallicRoughnessMap() {
        const device = Application.instance.device;
        if (!this._options) {
            const tex = device.createTexture2D('rgba8unorm', 1, 1, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            tex.update(new Uint8Array([
                0,
                1,
                0,
                0
            ]), 0, 0, 1, 1);
            tex.name = 'TerrainMetallicRoughnessMap';
            return tex;
        }
        if (!TerrainMaterial._metallicRoughnessGenerationProgram) {
            TerrainMaterial._metallicRoughnessGenerationProgram = device.buildRenderProgram({
                vertex (pb) {
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        if (device.type === 'webgpu') {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        }
                    });
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.roughness = pb.vec4().uniform(0);
                    this.metallic = pb.vec4().uniform(0);
                    this.splatMap = pb.tex2D().uniform(0);
                    pb.main(function() {
                        this.weights = pb.textureSample(this.splatMap, this.$inputs.uv);
                        this.roughnessValue = pb.dot(this.weights, this.roughness);
                        this.metallicValue = pb.dot(this.weights, this.metallic);
                        this.$outputs.outColor = pb.vec4(0, this.roughnessValue, this.metallicValue, 1);
                    });
                }
            });
            TerrainMaterial._metallicRoughnessGenerationBindGroup = device.createBindGroup(TerrainMaterial._metallicRoughnessGenerationProgram.bindGroupLayouts[0]);
        }
        const roughnessValues = Vector4.one();
        const metallicValues = Vector4.zero();
        for(let i = 0; i < this._numDetailMaps; i++){
            metallicValues[i] = this._uvScales[i * 4 + 2];
            roughnessValues[i] = this._uvScales[i * 4 + 3];
        }
        const tex = device.createTexture2D('rgba8unorm', this._options.splatMap.width, this._options.splatMap.height);
        tex.name = 'TerrainMetallicRoughnessMap';
        const program = TerrainMaterial._metallicRoughnessGenerationProgram;
        const bindgroup = TerrainMaterial._metallicRoughnessGenerationBindGroup;
        bindgroup.setValue('roughness', roughnessValues);
        bindgroup.setValue('metallic', metallicValues);
        bindgroup.setTexture('splatMap', this._options.splatMap);
        const fb = device.createFrameBuffer([
            tex
        ], null);
        device.pushDeviceStates();
        device.setFramebuffer(fb);
        device.setProgram(program);
        device.setBindGroup(0, bindgroup);
        drawFullscreenQuad();
        device.popDeviceStates();
        fb.dispose();
        return tex;
    }
    updateRenderStates(pass, stateSet, ctx) {
        super.updateRenderStates(pass, stateSet, ctx);
        const isShadowMapPass = ctx.renderPass.type === RENDER_PASS_TYPE_SHADOWMAP;
        if (isShadowMapPass) {
            stateSet.useRasterizerState().setCullMode('front');
        } else {
            stateSet.defaultRasterizerState();
        }
    }
}

/**
 * PBRMetallicRoughnessMaterial class
 * @public
 */ class PBRMetallicRoughnessMaterial extends applyMaterialMixins(MeshMaterial, mixinPBRMetallicRoughness, mixinVertexColor) {
    /** @internal */ static FEATURE_VERTEX_NORMAL = this.defineFeature();
    /** @internal */ static FEATURE_VERTEX_TANGENT = this.defineFeature();
    /**
   * Creates an instance of PBRMetallicRoughnessMaterial class
   */ constructor(){
        super();
        this.useFeature(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(PBRMetallicRoughnessMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

/**
 * PBRSpecularGlossiness mixin
 *
 * @param BaseCls - Base class to mix in
 * @returns Mixed class
 *
 * @public
 */ function mixinPBRSpecularGlossness(BaseCls) {
    if (BaseCls.pbrSpecularGlossnessMixed) {
        return BaseCls;
    }
    const S = applyMaterialMixins(BaseCls, mixinPBRCommon, mixinLight, mixinTextureProps('specular'));
    return class extends S {
        static pbrSpecularGlossnessMixed = true;
        _specularFactor;
        _glossinessFactor;
        constructor(){
            super();
            this._specularFactor = Vector4.one();
            this._glossinessFactor = 1;
        }
        get specularFactor() {
            return this._specularFactor;
        }
        set specularFactor(val) {
            if (!val.equalsTo(this._specularFactor)) {
                this._specularFactor.set(val);
                this.uniformChanged();
            }
        }
        get glossinessFactor() {
            return this._glossinessFactor;
        }
        set glossinessFactor(val) {
            if (val !== this._glossinessFactor) {
                this._glossinessFactor = val;
                this.uniformChanged();
            }
        }
        fragmentShader(scope) {
            super.fragmentShader(scope);
            if (this.needFragmentColor()) {
                const pb = scope.$builder;
                scope.zSpecularFactor = pb.vec4().uniform(2);
                scope.zGlossinessFactor = pb.float().uniform(2);
            }
        }
        applyUniformValues(bindGroup, ctx, pass) {
            super.applyUniformValues(bindGroup, ctx, pass);
            if (this.needFragmentColor(ctx)) {
                bindGroup.setValue('zSpecularFactor', this._specularFactor);
                bindGroup.setValue('zGlossinessFactor', this._glossinessFactor);
            }
        }
        PBRLight(scope, worldPos, normal, viewVec, albedo, TBN) {
            const pb = scope.$builder;
            const funcName = 'Z_PBRSpecularGlossinessLight';
            const that = this;
            pb.func(funcName, [
                pb.vec3('worldPos'),
                pb.vec3('normal'),
                pb.mat3('TBN'),
                pb.vec3('viewVec'),
                pb.vec4('albedo')
            ], function() {
                this.$l.pbrData = that.getCommonData(this, this.albedo, this.viewVec, this.TBN);
                this.$l.lightingColor = pb.vec3(0);
                this.$l.emissiveColor = that.calculateEmissiveColor(this);
                that.indirectLighting(this, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                that.forEachLight(this, function(type, posRange, dirCutoff, colorIntensity, shadow) {
                    this.$l.diffuse = pb.vec3();
                    this.$l.specular = pb.vec3();
                    this.$l.lightAtten = that.calculateLightAttenuation(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.lightDir = that.calculateLightDirection(this, type, this.worldPos, posRange, dirCutoff);
                    this.$l.NoL = pb.clamp(pb.dot(this.normal, this.lightDir), 0, 1);
                    this.$l.lightColor = pb.mul(colorIntensity.rgb, colorIntensity.a, this.lightAtten, this.NoL);
                    if (shadow) {
                        this.lightColor = pb.mul(this.lightColor, that.calculateShadow(this, this.worldPos, this.NoL));
                    }
                    that.directLighting(this, this.lightDir, this.lightColor, this.normal, this.viewVec, this.pbrData, this.lightingColor);
                });
                this.$return(pb.add(this.lightingColor, this.emissiveColor));
            });
            return pb.getGlobalScope()[funcName](worldPos, normal, TBN, viewVec, albedo);
        }
        calculateCommonData(scope, albedo, viewVec, TBN, data) {
            super.calculateCommonData(scope, albedo, viewVec, TBN, data);
            const pb = scope.$builder;
            if (this.specularTexture) {
                scope.$l.specularTextureSample = this.sampleSpecularTexture(scope);
                data.roughness = pb.sub(1, pb.mul(scope.zGlossinessFactor, scope.specularTextureSample.a));
                data.f0 = pb.vec4(pb.mul(scope.specularTextureSample.rgb, scope.zSpecularFactor.rgb), this.getF0(scope).a);
            } else {
                data.roughness = pb.sub(1, scope.zGlossinessFactor);
                data.f0 = pb.vec4(scope.zSpecularFactor.rgb, this.getF0(scope).a);
            }
            data.metallic = pb.max(pb.max(data.f0.r, data.f0.g), data.f0.b);
            data.diffuse = pb.vec4(pb.mul(albedo.rgb, pb.sub(1, data.metallic)), albedo.a);
            data.specularWeight = 1;
            data.f90 = pb.vec3(1);
        }
    };
}

/**
 * PBRSpecularGlossinessMaterial class
 * @public
 */ class PBRSpecularGlossinessMaterial extends applyMaterialMixins(MeshMaterial, mixinPBRSpecularGlossness, mixinVertexColor) {
    /** @internal */ static FEATURE_VERTEX_NORMAL = this.defineFeature();
    /** @internal */ static FEATURE_VERTEX_TANGENT = this.defineFeature();
    /**
   * Creates an instance of PBRSpecularGlossinessMaterial class
   */ constructor(){
        super();
        this.useFeature(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_NORMAL, true);
    }
    /** true if vertex normal attribute presents */ get vertexNormal() {
        return this.featureUsed(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_NORMAL);
    }
    set vertexNormal(val) {
        this.useFeature(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_NORMAL, !!val);
    }
    /** true if vertex normal attribute presents */ get vertexTangent() {
        return this.featureUsed(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_TANGENT);
    }
    set vertexTangent(val) {
        this.useFeature(PBRSpecularGlossinessMaterial.FEATURE_VERTEX_TANGENT, !!val);
    }
    vertexShader(scope) {
        super.vertexShader(scope);
        const pb = scope.$builder;
        scope.$l.oPos = ShaderHelper.resolveVertexPosition(scope);
        scope.$outputs.worldPos = pb.mul(ShaderHelper.getWorldMatrix(scope), pb.vec4(scope.oPos, 1)).xyz;
        ShaderHelper.setClipSpacePosition(scope, pb.mul(ShaderHelper.getViewProjectionMatrix(scope), pb.vec4(scope.$outputs.worldPos, 1)));
        if (this.vertexNormal) {
            scope.$l.oNorm = ShaderHelper.resolveVertexNormal(scope);
            scope.$outputs.wNorm = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oNorm, 0)).xyz;
            if (this.vertexTangent) {
                scope.$l.oTangent = ShaderHelper.resolveVertexTangent(scope);
                scope.$outputs.wTangent = pb.mul(ShaderHelper.getNormalMatrix(scope), pb.vec4(scope.oTangent.xyz, 0)).xyz;
                scope.$outputs.wBinormal = pb.mul(pb.cross(scope.$outputs.wNorm, scope.$outputs.wTangent), scope.oTangent.w);
            }
        }
    }
    fragmentShader(scope) {
        super.fragmentShader(scope);
        const pb = scope.$builder;
        if (this.needFragmentColor()) {
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.albedo = this.calculateAlbedoColor(scope);
            if (this.vertexColor) {
                scope.albedo = pb.mul(scope.albedo, this.getVertexColor(scope));
            }
            scope.$l.normalInfo = this.calculateNormalAndTBN(scope, scope.$inputs.worldPos, scope.$inputs.wNorm, scope.$inputs.wTangent, scope.$inputs.wBinormal);
            scope.$l.viewVec = this.calculateViewVector(scope, scope.$inputs.worldPos);
            scope.$l.litColor = this.PBRLight(scope, scope.$inputs.worldPos, scope.normalInfo.normal, scope.viewVec, scope.albedo, scope.normalInfo.TBN);
            this.outputFragmentColor(scope, scope.$inputs.worldPos, pb.vec4(scope.litColor, scope.albedo.a));
        } else {
            this.outputFragmentColor(scope, scope.$inputs.worldPos, null);
        }
    }
}

class RenderBundleWrapper {
    _renderBundles;
    constructor(){
        this._renderBundles = {};
    }
    getRenderBundle(hash) {
        return this._renderBundles[hash] ?? null;
    }
    beginRenderBundle() {
        Application.instance.device.beginCapture();
    }
    endRenderBundle(hash) {
        this._renderBundles[hash] = Application.instance.device.endCapture();
    }
}

const maxBufferSizeInFloats = 65536 / 4;
/** @internal */ class InstanceBindGroupAllocator {
    static _instanceBindGroupLayout = null;
    _bindGroupList = [];
    _allocFrameStamp;
    constructor(){
        this._allocFrameStamp = -1;
        this._bindGroupList = [];
    }
    allocateInstanceBindGroup(framestamp, sizeInFloats) {
        // Reset if render frame changed
        if (this._allocFrameStamp !== framestamp) {
            this._allocFrameStamp = framestamp;
            for (const k of this._bindGroupList){
                k.offset = 0;
            }
        }
        for (const k of this._bindGroupList){
            if (k.offset + sizeInFloats <= maxBufferSizeInFloats) {
                k.dirty = true;
                return k;
            }
        }
        if (!InstanceBindGroupAllocator._instanceBindGroupLayout) {
            const buildInfo = new ProgramBuilder(Application.instance.device).buildRender({
                vertex (pb) {
                    this[ShaderHelper.getInstanceDataUniformName()] = pb.vec4[65536 >> 4]().uniformBuffer(3);
                    pb.main(function() {});
                },
                fragment (pb) {
                    pb.main(function() {});
                }
            });
            InstanceBindGroupAllocator._instanceBindGroupLayout = buildInfo[2][3];
        }
        const bindGroup = {
            bindGroup: Application.instance.device.createBindGroup(InstanceBindGroupAllocator._instanceBindGroupLayout),
            buffer: new Float32Array(maxBufferSizeInFloats),
            offset: 0,
            dirty: true
        };
        this._bindGroupList.push(bindGroup);
        return bindGroup;
    }
}
const defaultInstanceBindGroupAlloator = new InstanceBindGroupAllocator();
/**
 * A queue that contains the items to be rendered
 * @public
 */ class RenderQueue {
    /** @internal */ _itemLists;
    /** @internal */ _renderPass;
    /** @internal */ _shadowedLightList;
    /** @internal */ _unshadowedLightList;
    /** @internal */ _sunLight;
    /** @internal */ _bindGroupAllocator;
    /** @internal */ _ref;
    /** @internal */ _instanceInfo;
    /**
   * Creates an instance of a render queue
   * @param renderPass - The render pass to which the render queue belongs
   */ constructor(renderPass, bindGroupAllocator){
        this._bindGroupAllocator = bindGroupAllocator ?? defaultInstanceBindGroupAlloator;
        this._itemLists = {};
        this._renderPass = renderPass;
        this._shadowedLightList = [];
        this._unshadowedLightList = [];
        this._sunLight = null;
        this._ref = {
            ref: this
        };
        this._instanceInfo = new Map();
    }
    /** The sun light */ get sunLight() {
        return this._sunLight;
    }
    set sunLight(light) {
        this._sunLight = light;
    }
    /** The render pass to which the render queue belongs */ get renderPass() {
        return this._renderPass;
    }
    /**
   * Gets the items of the render queue
   */ get items() {
        return this._itemLists;
    }
    /**
   * Gets the shadowed lights
   */ get shadowedLights() {
        return this._shadowedLightList;
    }
    /**
   * Gets the unshadowed lights
   */ get unshadowedLights() {
        return this._unshadowedLightList;
    }
    /**
   * Gets the indirect reference of this
   */ get ref() {
        return this._ref;
    }
    /**
   * Gets the instance information for given drawable object
   * @param drawable - The drawable object
   * @returns The instane information for given drawable object, null if no exists
   */ getInstanceInfo(drawable) {
        return this._instanceInfo.get(drawable);
    }
    /**
   * Gets the maximum batch size of a given device
   * @returns The maximum batch size of the device
   *
   * @internal
   */ getMaxBatchSize() {
        return Application.instance.device.getDeviceCaps().shaderCaps.maxUniformBufferSize / 64;
    }
    /**
   * Push a punctual light
   * @param light - The light to be pushed
   */ pushLight(light) {
        if (light.castShadow) {
            this._shadowedLightList.push(light);
        } else {
            this._unshadowedLightList.push(light);
        }
        if (light.isDirectionLight() && light.sunLight) {
            this.sunLight = light;
        }
    }
    /**
   * Push items from another render queue
   * @param queue - The render queue to be pushed
   */ pushRenderQueue(queue) {
        for(const order in queue._itemLists){
            let itemLists = this._itemLists[order];
            if (!itemLists) {
                itemLists = this.newRenderItemList(true);
                this._itemLists[order] = itemLists;
            }
            const newItemLists = queue._itemLists[order];
            itemLists.opaque.lit.push(...newItemLists.opaque.lit);
            itemLists.opaque.unlit.push(...newItemLists.opaque.unlit);
            itemLists.transparent.lit.push(...newItemLists.transparent.lit);
            itemLists.transparent.unlit.push(...newItemLists.transparent.unlit);
        }
    }
    /**
   * Push an item to the render queue
   * @param camera - The camera for drawing the item
   * @param drawable - The object to be drawn
   * @param renderOrder - Render order of the object
   */ push(camera, drawable, renderOrder) {
        if (drawable) {
            let itemList = this._itemLists[renderOrder];
            if (!itemList) {
                itemList = this.newRenderItemList(false);
                this._itemLists[renderOrder] = itemList;
            }
            const trans = drawable.getQueueType() === QUEUE_TRANSPARENT;
            const unlit = drawable.isUnlit();
            if (drawable.isBatchable()) {
                const instanceList = trans ? unlit ? itemList.transparent.unlit[0].instanceList : itemList.transparent.lit[0].instanceList : unlit ? itemList.opaque.unlit[0].instanceList : itemList.opaque.lit[0].instanceList;
                const hash = drawable.getInstanceId(this._renderPass);
                let drawableList = instanceList[hash];
                if (!drawableList) {
                    drawableList = [];
                    instanceList[hash] = drawableList;
                }
                drawableList.push(drawable);
            } else {
                const list = trans ? unlit ? itemList.transparent.unlit[0] : itemList.transparent.lit[0] : unlit ? itemList.opaque.unlit[0] : itemList.opaque.lit[0];
                this.binaryInsert(drawable.getBoneMatrices() ? list.skinItemList : list.itemList, {
                    drawable,
                    sortDistance: drawable.getSortDistance(camera),
                    instanceData: null
                });
                drawable.applyTransformUniforms(this);
                const mat = drawable.getMaterial();
                if (mat) {
                    list.materialList.add(mat.coreMaterial);
                }
            }
            drawable.pushRenderQueueRef(this._ref);
        }
    }
    /**
   * Removes all items in the render queue
   */ reset() {
        this._itemLists = {};
        this._shadowedLightList = [];
        this._unshadowedLightList = [];
        this._sunLight = null;
    }
    /** @internal */ dispose() {
        this._ref.ref = null;
        this._ref = null;
        this.reset();
    }
    /** @internal */ end(camera, createRenderBundles) {
        const frameCounter = Application.instance.device.frameInfo.frameCounter;
        for(const k in this._itemLists){
            const itemList = this._itemLists[k];
            const lists = [
                itemList.opaque.lit,
                itemList.opaque.unlit,
                itemList.transparent.lit,
                itemList.transparent.unlit
            ];
            for(let i = 0; i < 4; i++){
                const list = lists[i];
                for (const info of list){
                    if (info.renderQueue !== this) {
                        continue;
                    }
                    const instanceList = info.instanceList;
                    for(const x in instanceList){
                        const drawables = instanceList[x];
                        if (drawables.length === 1) {
                            this.binaryInsert(info.itemList, {
                                drawable: drawables[0],
                                sortDistance: drawables[0].getSortDistance(camera),
                                instanceData: null
                            });
                            drawables[0].applyTransformUniforms(this);
                            const mat = drawables[0].getMaterial();
                            if (mat) {
                                info.materialList.add(mat.coreMaterial);
                            }
                        } else {
                            let bindGroup = null;
                            let item = null;
                            for(let i = 0; i < drawables.length; i++){
                                const drawable = drawables[i];
                                const instanceUniforms = drawable.getInstanceUniforms();
                                const instanceUniformsSize = instanceUniforms?.length ?? 0;
                                const stride = 16 + instanceUniformsSize;
                                if (!bindGroup || bindGroup.offset + stride > maxBufferSizeInFloats) {
                                    bindGroup = this._bindGroupAllocator.allocateInstanceBindGroup(frameCounter, stride);
                                    item = {
                                        drawable,
                                        sortDistance: drawable.getSortDistance(camera),
                                        instanceData: {
                                            bindGroup,
                                            offset: bindGroup.offset,
                                            numInstances: 0,
                                            stride
                                        }
                                    };
                                    this.binaryInsert(info.instanceItemList, item);
                                    drawable.applyInstanceOffsetAndStride(this, stride, bindGroup.offset);
                                }
                                const instanceInfo = {
                                    bindGroup,
                                    offset: bindGroup.offset
                                };
                                this._instanceInfo.set(drawable, instanceInfo);
                                drawable.applyTransformUniforms(this);
                                drawable.applyMaterialUniforms(instanceInfo);
                                bindGroup.offset += stride;
                                item.instanceData.numInstances++;
                                const mat = drawable.getMaterial();
                                if (mat) {
                                    info.materialList.add(mat.coreMaterial);
                                }
                            }
                        }
                    }
                    info.instanceList = {};
                    if (createRenderBundles) {
                        if (info.itemList.length > 0) {
                            info.renderBundle = new RenderBundleWrapper();
                        }
                        if (info.skinItemList.length > 0) {
                            info.skinRenderBundle = new RenderBundleWrapper();
                        }
                        if (info.instanceItemList.length > 0) {
                            info.instanceRenderBundle = new RenderBundleWrapper();
                        }
                    }
                }
            }
        /*
      itemList.opaque.lit.forEach(info => {
        info.itemList.sort((a, b) => (a.drawable.getMaterial()?.instanceId ?? 0) - (b.drawable.getMaterial()?.instanceId ?? 0))
      });
      itemList.opaque.unlit.forEach(info => {
        info.itemList.sort((a, b) => (a.drawable.getMaterial()?.instanceId ?? 0) - (b.drawable.getMaterial()?.instanceId ?? 0))
      });
      */ }
        return this;
    }
    binaryInsert(itemList, item) {
        let left = 0;
        let right = itemList.length - 1;
        const newInstanceId = item.drawable.getMaterial().instanceId;
        while(left <= right){
            const mid = Math.floor((left + right) / 2);
            const instanceId = itemList[mid].drawable.getMaterial().instanceId;
            if (instanceId === newInstanceId) {
                itemList.splice(mid + 1, 0, item);
                return;
            } else if (instanceId < newInstanceId) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        itemList.splice(left, 0, item);
    }
    /**
   * Sorts the items in the render queue for rendering
   */ sortTransparentItems(cameraPos) {
        for (const list of Object.values(this._itemLists)){
            list.transparent.lit[0].itemList.sort((a, b)=>this.drawableDistanceToCamera(b.drawable, cameraPos) - this.drawableDistanceToCamera(a.drawable, cameraPos));
            list.transparent.lit[0].skinItemList.sort((a, b)=>this.drawableDistanceToCamera(b.drawable, cameraPos) - this.drawableDistanceToCamera(a.drawable, cameraPos));
            list.transparent.unlit[0].itemList.sort((a, b)=>this.drawableDistanceToCamera(b.drawable, cameraPos) - this.drawableDistanceToCamera(a.drawable, cameraPos));
            list.transparent.unlit[0].skinItemList.sort((a, b)=>this.drawableDistanceToCamera(b.drawable, cameraPos) - this.drawableDistanceToCamera(a.drawable, cameraPos));
        }
    }
    drawableDistanceToCamera(drawable, cameraPos) {
        const drawablePos = drawable.getXForm().position;
        return Vector3.distanceSq(drawablePos, cameraPos);
    }
    newRenderItemList(empty) {
        return {
            opaque: {
                lit: empty ? [] : [
                    {
                        itemList: [],
                        skinItemList: [],
                        instanceItemList: [],
                        materialList: new Set(),
                        instanceList: {},
                        renderQueue: this
                    }
                ],
                unlit: empty ? [] : [
                    {
                        itemList: [],
                        skinItemList: [],
                        instanceItemList: [],
                        materialList: new Set(),
                        instanceList: {},
                        renderQueue: this
                    }
                ]
            },
            transparent: {
                lit: empty ? [] : [
                    {
                        itemList: [],
                        skinItemList: [],
                        instanceItemList: [],
                        materialList: new Set(),
                        instanceList: {},
                        renderQueue: this
                    }
                ],
                unlit: empty ? [] : [
                    {
                        itemList: [],
                        skinItemList: [],
                        instanceItemList: [],
                        materialList: new Set(),
                        instanceList: {},
                        renderQueue: this
                    }
                ]
            }
        };
    }
}

/**
 * Base class for any kind of render passes
 * @public
 */ class RenderPass {
    /** @internal */ _type;
    /** @internal */ _globalBindGroups;
    /** @internal */ _clearColor;
    /** @internal */ _clearDepth;
    /** @internal */ _clearStencil;
    /**
   * Creates an instanceof RenderPass
   * @param type - Render pass type
   */ constructor(type){
        this._type = type;
        this._clearColor = new Vector4(0, 0, 0, 1);
        this._clearDepth = 1;
        this._clearStencil = 0;
        this._globalBindGroups = {};
    }
    /** Color value that is used to clear the frame buffer  */ get clearColor() {
        return this._clearColor;
    }
    set clearColor(color) {
        this._clearColor = color ?? null;
    }
    /** Depth value that is used to clear the frame buffer */ get clearDepth() {
        return this._clearDepth;
    }
    set clearDepth(depth) {
        this._clearDepth = depth ?? null;
    }
    /** Stencil value that is used to clear the frame buffer */ get clearStencil() {
        return this._clearStencil;
    }
    set clearStencil(stencil) {
        this._clearStencil = stencil ?? null;
    }
    /**
   * The render pass type
   */ get type() {
        return this._type;
    }
    /** @internal */ isAutoFlip(ctx) {
        return !!(ctx.device.getFramebuffer() && ctx.device.type === 'webgpu');
    }
    /**
   * Renders a scene
   * @param ctx - Drawing context
   */ render(ctx, cullCamera, renderQueue) {
        ctx.renderPass = this;
        this.drawScene(ctx, cullCamera ?? ctx.camera, renderQueue);
    }
    /** @internal */ getGlobalBindGroup(ctx) {
        const hash = this.getGlobalBindGroupHash(ctx);
        let bindGroup = this._globalBindGroups[hash];
        if (!bindGroup) {
            const ret = ctx.device.programBuilder.buildRender({
                vertex (pb) {
                    ShaderHelper.prepareVertexShader(pb, ctx);
                    pb.main(function() {});
                },
                fragment (pb) {
                    ShaderHelper.prepareFragmentShader(pb, ctx);
                    pb.main(function() {});
                }
            });
            bindGroup = ctx.device.createBindGroup(ret[2][0]);
            this._globalBindGroups[hash] = bindGroup;
        }
        return bindGroup;
    }
    /**
   * Disposes the render pass
   */ dispose() {
        this._globalBindGroups = {};
    }
    /** @internal */ getGlobalBindGroupHash(ctx) {
        return `${this.constructor.name}:${this._getGlobalBindGroupHash(ctx)}`;
    }
    /** @internal */ drawScene(ctx, cullCamera, renderQueue) {
        const device = ctx.device;
        this.clearFramebuffer();
        const rq = renderQueue ?? this.cullScene(ctx, cullCamera);
        if (rq) {
            const windingReversed = device.isWindingOrderReversed();
            device.reverseVertexWindingOrder(this.isAutoFlip(ctx) ? !windingReversed : windingReversed);
            this.renderItems(ctx, rq);
            device.reverseVertexWindingOrder(windingReversed);
            if (rq !== renderQueue) {
                rq.dispose();
            }
        }
    }
    /**
   * Culls a scene by a given camera
   * @param ctx - The draw context
   * @param cullCamera - The camera that will be used to cull the scene
   * @returns The cull result
   */ cullScene(ctx, cullCamera) {
        if (cullCamera) {
            const renderQueue = new RenderQueue(this);
            const cullVisitor = new CullVisitor(this, cullCamera, renderQueue, ctx.primaryCamera);
            if (ctx.scene.octree) {
                ctx.scene.octree.getRootNode().traverse(cullVisitor);
            } else {
                ctx.scene.rootNode.traverse(cullVisitor);
            }
            return renderQueue.end(cullCamera);
        }
        return null;
    }
    /** @internal */ drawItem(device, item, ctx, reverseWinding) {
        const reverse = reverseWinding !== item.drawable.getXForm().worldMatrixDet < 0;
        if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
        }
        item.drawable.draw(ctx);
        if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
        }
    }
    /** @internal */ internalDrawItemList(ctx, items, renderBundle, reverseWinding, hash) {
        if (renderBundle && ctx.primaryCamera.commandBufferReuse) {
            const bundle = renderBundle.getRenderBundle(hash);
            if (bundle) {
                ctx.device.executeRenderBundle(bundle);
                return;
            }
            renderBundle.beginRenderBundle();
        }
        for (const item of items){
            ctx.instanceData = item.instanceData;
            const reverse = reverseWinding !== item.drawable.getXForm().worldMatrixDet < 0;
            if (reverse) {
                ctx.device.reverseVertexWindingOrder(!ctx.device.isWindingOrderReversed());
            }
            item.drawable.draw(ctx);
            if (reverse) {
                ctx.device.reverseVertexWindingOrder(!ctx.device.isWindingOrderReversed());
            }
        }
        if (renderBundle && ctx.primaryCamera.commandBufferReuse) {
            renderBundle.endRenderBundle(hash);
        }
    }
    /** @internal */ drawItemList(itemList, ctx, reverseWinding) {
        ctx.renderQueue = itemList.renderQueue;
        ctx.instanceData = null;
        const windingHash = reverseWinding ? '1' : '0';
        const bindGroupHash = ctx.device.getBindGroup(0)[0].getGPUId();
        const framebufferHash = ctx.device.getFramebuffer()?.getHash() ?? '';
        const hash = `${windingHash}-${bindGroupHash}-${framebufferHash}-${ctx.renderPassHash}`;
        if (itemList) {
            if (itemList.itemList.length > 0) {
                ctx.skinAnimation = false;
                ctx.instancing = false;
                itemList.materialList.forEach((mat)=>mat.apply(ctx));
                this.internalDrawItemList(ctx, itemList.itemList, itemList.renderBundle, reverseWinding, hash);
            }
            if (itemList.skinItemList.length > 0) {
                ctx.skinAnimation = true;
                ctx.instancing = false;
                itemList.materialList.forEach((mat)=>mat.apply(ctx));
                this.internalDrawItemList(ctx, itemList.skinItemList, itemList.skinRenderBundle, reverseWinding, hash);
            /*
        for (const item of itemList.skinItemList) {
          ctx.instanceData = item.instanceData;
          const reverse = reverseWinding !== item.drawable.getXForm().worldMatrixDet < 0;
          if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
          }
          item.drawable.draw(ctx);
          if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
          }
        }
        */ }
            if (itemList.instanceItemList.length > 0) {
                ctx.skinAnimation = false;
                ctx.instancing = true;
                itemList.materialList.forEach((mat)=>mat.apply(ctx));
                this.internalDrawItemList(ctx, itemList.instanceItemList, itemList.instanceRenderBundle, reverseWinding, hash);
            /*
        for (const item of itemList.instanceItemList) {
          ctx.instanceData = item.instanceData;
          const reverse = reverseWinding !== item.drawable.getXForm().worldMatrixDet < 0;
          if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
          }
          item.drawable.draw(ctx);
          if (reverse) {
            device.reverseVertexWindingOrder(!device.isWindingOrderReversed());
          }
        }
        */ }
        }
        ctx.renderQueue = null;
    }
    /** @internal */ clearFramebuffer() {
        Application.instance.device.clearFrameBuffer(this._clearColor, this._clearDepth, this._clearStencil);
    }
}

/**
 * Forward render pass
 * @internal
 */ class LightPass extends RenderPass {
    /** @internal */ _shadowMapHash;
    /**
   * Creates an instance of ForwardRenderPass
   */ constructor(){
        super(RENDER_PASS_TYPE_LIGHT);
        this._shadowMapHash = null;
    }
    /** @internal */ _getGlobalBindGroupHash(ctx) {
        return `lp:${this._shadowMapHash}:${ctx.linearDepthTexture?.uid ?? ''}:${ctx.oit?.calculateHash() ?? ''}:${ctx.env.getHash(ctx)}`;
    }
    /** @internal */ renderLightPass(ctx, itemList, lights, flags) {
        const baseLightPass = !ctx.lightBlending;
        ctx.drawEnvLight = baseLightPass && ctx.env.light.type !== 'none' && (ctx.env.light.envLight.hasRadiance() || ctx.env.light.envLight.hasIrradiance());
        ctx.renderPassHash = this.getGlobalBindGroupHash(ctx);
        const bindGroup = ctx.globalBindGroupAllocator.getGlobalBindGroup(ctx);
        if (!flags.cameraSet[ctx.renderPassHash]) {
            ShaderHelper.setCameraUniforms(bindGroup, ctx.camera, ctx.flip, !!ctx.device.getFramebuffer());
            flags.cameraSet[ctx.renderPassHash] = 1;
        }
        if (ctx.currentShadowLight) {
            ShaderHelper.setLightUniformsShadow(bindGroup, ctx, lights[0]);
        } else {
            if (!flags.lightSet[ctx.renderPassHash]) {
                ShaderHelper.setLightUniforms(bindGroup, ctx, ctx.clusteredLight.clusterParam, ctx.clusteredLight.countParam, ctx.clusteredLight.lightBuffer, ctx.clusteredLight.lightIndexTexture);
                flags.lightSet[ctx.renderPassHash] = 1;
            }
        }
        if (ctx.applyFog && !flags.fogSet[ctx.renderPassHash]) {
            ShaderHelper.setFogUniforms(bindGroup, ctx.env.sky.mappedFogType, baseLightPass ? ctx.env.sky.fogColor : Vector4.zero(), ctx.env.sky.fogParams, ctx.env.sky.aerialPerspectiveDensity * ctx.env.sky.aerialPerspectiveDensity, ctx.env.sky.getAerialPerspectiveLUT(ctx));
            flags.fogSet[ctx.renderPassHash] = 1;
        }
        ctx.device.setBindGroup(0, bindGroup);
        const reverseWinding = ctx.camera.worldMatrixDet < 0;
        for (const lit of itemList.lit){
            this.drawItemList(lit, ctx, reverseWinding);
        }
        if (!ctx.lightBlending) {
            for (const unlit of itemList.unlit){
                this.drawItemList(unlit, ctx, reverseWinding);
            }
        }
    }
    /** @internal */ renderItems(ctx, renderQueue) {
        ctx.applyFog = null;
        ctx.renderPassHash = null;
        ctx.env = ctx.scene.env;
        ctx.drawEnvLight = false;
        ctx.flip = this.isAutoFlip(ctx);
        const oit = ctx.primaryCamera.oit && ctx.primaryCamera.oit.supportDevice(ctx.device.type) ? ctx.primaryCamera.oit : null;
        if (!oit) {
            renderQueue.sortTransparentItems(ctx.primaryCamera.getWorldPosition());
        }
        const flags = {
            lightSet: {},
            cameraSet: {},
            fogSet: {}
        };
        const orders = Object.keys(renderQueue.items).map((val)=>Number(val)).sort((a, b)=>a - b);
        for(let i = 0; i < 2; i++){
            ctx.applyFog = i === 1 && ctx.env.sky.fogType !== 'none' ? ctx.env.sky.fogType : null;
            ctx.queue = i === 0 ? QUEUE_OPAQUE : QUEUE_TRANSPARENT;
            ctx.oit = i === 0 ? null : oit;
            const numOitPasses = ctx.oit ? ctx.oit.begin(ctx) : 1;
            for(let p = 0; p < numOitPasses; p++){
                if (ctx.oit) {
                    if (!ctx.oit.beginPass(ctx, p)) {
                        continue;
                    }
                }
                for (const order of orders){
                    const items = renderQueue.items[order];
                    const lists = [
                        items.opaque,
                        items.transparent
                    ];
                    let lightIndex = 0;
                    if (ctx.shadowMapInfo) {
                        for (const k of ctx.shadowMapInfo.keys()){
                            ctx.currentShadowLight = k;
                            ctx.lightBlending = lightIndex > 0;
                            this._shadowMapHash = ctx.shadowMapInfo.get(k).shaderHash;
                            this.renderLightPass(ctx, lists[i], [
                                k
                            ], flags);
                            lightIndex++;
                        }
                    }
                    if (lightIndex === 0 || renderQueue.unshadowedLights.length > 0) {
                        ctx.currentShadowLight = null;
                        ctx.lightBlending = lightIndex > 0;
                        this._shadowMapHash = '';
                        this.renderLightPass(ctx, lists[i], renderQueue.unshadowedLights, flags);
                    }
                }
                if (ctx.oit) {
                    ctx.oit.endPass(ctx, p);
                }
            }
            if (ctx.oit) {
                ctx.oit.end(ctx);
            }
            if (i === 0) {
                ctx.env.sky.skyWorldMatrix = ctx.scene.rootNode.worldMatrix;
                ctx.env.sky.renderSky(ctx);
            }
            ctx.compositor?.drawPostEffects(ctx, i === 0, ctx.linearDepthTexture);
            if (i === 0) {
                ctx.env.sky.renderFog(ctx);
            }
        }
    }
}

/**
 * Shadow map render pass
 *
 * @public
 */ class ShadowMapPass extends RenderPass {
    /** @internal */ _currentLight;
    /**
   * Creates an instance of ShadowMapPass
   */ constructor(){
        super(RENDER_PASS_TYPE_SHADOWMAP);
        this._currentLight = null;
    }
    /** The light that will be used to render shadow map */ get light() {
        return this._currentLight;
    }
    set light(light) {
        this._currentLight = light;
    }
    /** @internal */ _getGlobalBindGroupHash(ctx) {
        return `sm:${ctx.shadowMapInfo.get(this.light).shaderHash}`;
    }
    /** @internal */ renderItems(ctx, renderQueue) {
        ctx.drawEnvLight = false;
        ctx.env = null;
        ctx.applyFog = null;
        ctx.flip = this.isAutoFlip(ctx);
        ctx.renderPassHash = this.getGlobalBindGroupHash(ctx);
        const bindGroup = ctx.globalBindGroupAllocator.getGlobalBindGroup(ctx);
        ctx.device.setBindGroup(0, bindGroup);
        ShaderHelper.setLightUniformsShadowMap(bindGroup, ctx, this._currentLight);
        ShaderHelper.setCameraUniforms(bindGroup, ctx.camera, ctx.flip, true);
        const reverseWinding = ctx.camera.worldMatrixDet < 0;
        for (const order of Object.keys(renderQueue.items).map((val)=>Number(val)).sort((a, b)=>a - b)){
            const renderItems = renderQueue.items[order];
            for (const lit of renderItems.opaque.lit){
                this.drawItemList(lit, ctx, reverseWinding);
            }
            for (const unlit of renderItems.opaque.unlit){
                this.drawItemList(unlit, ctx, reverseWinding);
            }
        }
    }
}

/**
 * Depth render pass
 *
 * Scene depth render pass
 *
 * @public
 */ class DepthPass extends RenderPass {
    /**
   * Creates an instance of DepthRenderPass
   */ constructor(){
        super(RENDER_PASS_TYPE_DEPTH);
    }
    /** @internal */ _getGlobalBindGroupHash(ctx) {
        return '';
    }
    /** @internal */ renderItems(ctx, renderQueue) {
        ctx.applyFog = null;
        ctx.drawEnvLight = false;
        ctx.env = null;
        ctx.flip = this.isAutoFlip(ctx);
        ctx.renderPassHash = this.getGlobalBindGroupHash(ctx);
        const bindGroup = ctx.globalBindGroupAllocator.getGlobalBindGroup(ctx);
        ctx.device.setBindGroup(0, bindGroup);
        ShaderHelper.setCameraUniforms(bindGroup, ctx.camera, ctx.flip, true);
        const reverseWinding = ctx.camera.worldMatrixDet < 0;
        for (const order of Object.keys(renderQueue.items).map((val)=>Number(val)).sort((a, b)=>a - b)){
            const renderItems = renderQueue.items[order];
            for (const lit of renderItems.opaque.lit){
                this.drawItemList(lit, ctx, reverseWinding);
            }
            for (const unlit of renderItems.opaque.unlit){
                this.drawItemList(unlit, ctx, reverseWinding);
            }
        }
    }
}

/**
 * Calculate 3d noise by a 3d position
 *
 * @param scope - current shader scope
 * @param p - 3d position at where to calculate noise
 * @returns noise value between 0 and 1
 *
 * @public
 */ function noise3D(scope, p) {
    const pb = scope.$builder;
    const funcName = 'Z_noise3d';
    pb.func(funcName, [
        pb.vec3('p')
    ], function() {
        this.$l.p3 = pb.fract(pb.mul(this.p, 0.1031));
        this.$l.p3 = pb.add(this.p3, pb.vec3(pb.dot(this.p3, pb.add(this.p3.yzx, pb.vec3(33.33)))));
        this.$return(pb.fract(pb.mul(pb.add(this.p3.x, this.p3.y), this.p3.z)));
    });
    return pb.getGlobalScope()[funcName](p);
}
/**
 * Calculate smooth 3d noise by a 3d position
 *
 * @param scope - current shader scope
 * @param p - 3d position at where to calculate noise
 * @returns noise value between 0 and 1
 *
 * @public
 */ function smoothNoise3D(scope, p) {
    const pb = scope.$builder;
    const funcName = 'Z_smoothNoise3D';
    pb.func(funcName, [
        pb.vec3('p')
    ], function() {
        this.$l.cell = pb.floor(this.p);
        this.$l.local = pb.fract(this.p);
        this.$l.local = pb.mul(this.local, pb.mul(this.local, pb.sub(pb.vec3(3), pb.mul(this.local, 2))));
        this.$l.ldb = noise3D(this, this.cell);
        this.$l.rdb = noise3D(this, pb.add(this.cell, pb.vec3(1, 0, 0)));
        this.$l.ldf = noise3D(this, pb.add(this.cell, pb.vec3(0, 0, 1)));
        this.$l.rdf = noise3D(this, pb.add(this.cell, pb.vec3(1, 0, 1)));
        this.$l.lub = noise3D(this, pb.add(this.cell, pb.vec3(0, 1, 0)));
        this.$l.rub = noise3D(this, pb.add(this.cell, pb.vec3(1, 1, 0)));
        this.$l.luf = noise3D(this, pb.add(this.cell, pb.vec3(0, 1, 1)));
        this.$l.ruf = noise3D(this, pb.add(this.cell, pb.vec3(1, 1, 1)));
        this.$return(pb.mix(pb.mix(pb.mix(this.ldb, this.rdb, this.local.x), pb.mix(this.ldf, this.rdf, this.local.x), this.local.z), pb.mix(pb.mix(this.lub, this.rub, this.local.x), pb.mix(this.luf, this.ruf, this.local.x), this.local.z), this.local.y));
    });
    return pb.getGlobalScope()[funcName](p);
}

/**
 * Presents a transformation from one space to another
 * @public
 */ class XForm extends makeEventTarget(Object)() {
    /** @internal */ _parent;
    /** @internal */ _children;
    /** @internal */ _position;
    /** @internal */ _scaling;
    /** @internal */ _rotation;
    /** @internal */ _localMatrix;
    /** @internal */ _worldMatrix;
    /** @internal */ _worldMatrixDet;
    /** @internal */ _invWorldMatrix;
    /** @internal */ _tmpLocalMatrix;
    /** @internal */ _tmpWorldMatrix;
    /** @internal */ _transformTag;
    /** @internal */ _transformChangeCallback;
    /**
   * Creates an instance of XForm
   */ constructor(){
        super();
        this._parent = null;
        this._children = [];
        this._transformChangeCallback = ()=>this._onTransformChanged(true);
        this._position = new ObservableVector3(0, 0, 0);
        this._position.callback = this._transformChangeCallback;
        this._scaling = new ObservableVector3(1, 1, 1);
        this._scaling.callback = this._transformChangeCallback;
        this._rotation = new ObservableQuaternion();
        this._rotation.callback = this._transformChangeCallback;
        this._worldMatrix = null;
        this._worldMatrixDet = null;
        this._invWorldMatrix = null;
        this._localMatrix = null;
        this._transformTag = 0;
        this._tmpLocalMatrix = Matrix4x4.identity();
        this._tmpWorldMatrix = Matrix4x4.identity();
    }
    /** Parent of the xform */ get parent() {
        return this._parent;
    }
    set parent(p) {
        p = p || null;
        if (p !== this._parent) {
            this._setParent(p);
        }
    }
    /** Children of this xform */ get children() {
        return this._children;
    }
    /**
   * Position of the xform relative to it's parent
   */ get position() {
        if (!this._position) {
            this.syncTRS();
        }
        return this._position;
    }
    set position(val) {
        if (!this._position) {
            this.syncTRS();
        }
        this._position.setXYZ(val[0], val[1], val[2]);
    }
    /**
   * Scaling of the xform
   */ get scale() {
        if (!this._scaling) {
            this.syncTRS();
        }
        return this._scaling;
    }
    set scale(val) {
        if (!this._scaling) {
            this.syncTRS();
        }
        this._scaling.setXYZ(val[0], val[1], val[2]);
    }
    /**
   * Rotation of the xform
   */ get rotation() {
        if (!this._rotation) {
            this.syncTRS();
        }
        return this._rotation;
    }
    set rotation(val) {
        if (!this._rotation) {
            this.syncTRS();
        }
        this._rotation.setXYZW(val[0], val[1], val[2], val[3]);
    }
    worldToThis(v, result) {
        if (v instanceof Vector3) {
            result = result || new Vector3();
            this.invWorldMatrix.transformPointAffine(v, result);
            return result;
        } else {
            result = result || new Vector4();
            this.invWorldMatrix.transformAffine(v, result);
            return result;
        }
    }
    otherToThis(other, v, result) {
        return this.worldToThis(other.thisToWorld(v, result), result);
    }
    thisToWorld(v, result) {
        if (v instanceof Vector3) {
            result = result || new Vector3();
            this.worldMatrix.transformPointAffine(v, result);
            return result;
        } else {
            result = result || new Vector4();
            this.worldMatrix.transformAffine(v, result);
            return result;
        }
    }
    thisToOther(other, v, result) {
        return other.worldToThis(this.thisToWorld(v, result), result);
    }
    /**
   * Gets the position of the xform in world space
   * @returns position of the xform in world space
   */ getWorldPosition() {
        return new Vector3(this.worldMatrix.m03, this.worldMatrix.m13, this.worldMatrix.m23);
    }
    /**
   * Moves the xform by an offset vector
   * @param delta - The offset vector
   * @returns self
   */ moveBy(delta) {
        this._position.addBy(delta);
        return this;
    }
    /**
   * Scales the xform by a given scale factor
   * @param factor - The scale factor
   * @returns self
   */ scaleBy(factor) {
        this._scaling.mulBy(factor);
        return this;
    }
    /**
   * Sets the local transform matrix of the xform
   * @param matrix - The transform matrix to set
   * @returns self
   */ setLocalTransform(matrix) {
        this._localMatrix = matrix;
        this._position = null;
        this._rotation = null;
        this._scaling = null;
        this._onTransformChanged(false);
        return this;
    }
    /** Local transformation matrix of the xform */ get localMatrix() {
        if (!this._localMatrix) {
            this._localMatrix = this._tmpLocalMatrix;
            this._localMatrix.scaling(this._scaling).rotateLeft(new Matrix4x4(this._rotation)).translateLeft(this._position);
        }
        return this._localMatrix;
    }
    set localMatrix(matrix) {
        this.setLocalTransform(matrix);
    }
    /** World transformation matrix of the xform */ get worldMatrix() {
        if (!this._worldMatrix) {
            this._worldMatrix = this._tmpWorldMatrix;
            if (this._parent) {
                Matrix4x4.multiplyAffine(this._parent.worldMatrix, this.localMatrix, this._worldMatrix);
            } else {
                this._worldMatrix.set(this.localMatrix);
            }
        }
        return this._worldMatrix;
    }
    /** The determinant of world matrix */ get worldMatrixDet() {
        if (this._worldMatrixDet === null) {
            this._worldMatrixDet = this.worldMatrix.det();
        }
        return this._worldMatrixDet;
    }
    /** Inverse of the world transformation matrix of the xform */ get invWorldMatrix() {
        if (!this._invWorldMatrix) {
            this._invWorldMatrix = Matrix4x4.invertAffine(this.worldMatrix);
        }
        return this._invWorldMatrix;
    }
    /**
   * Sets the local tranformation matrix by a look-at matrix
   * @param eye - The eye position used to make the look-at matrix
   * @param target - The target position used to make the look-at matrix
   * @param up - The up vector used to make the look-at matrix
   * @returns self
   */ lookAt(eye, target, up) {
        Matrix4x4.lookAt(eye, target, up).decompose(this._scaling, this._rotation, this._position);
        return this;
    }
    /**
   * Removes this node from it's parent and add this node to another parent node if required
   * @param p - The new parent node that this node should be added to or null
   * @returns self
   */ reparent(p) {
        this.parent = p;
        return this;
    }
    /** @internal */ getTag() {
        return this._transformTag;
    }
    /** @internal */ syncTRS() {
        this._position = new ObservableVector3();
        this._rotation = new ObservableQuaternion();
        this._scaling = new ObservableVector3();
        this._localMatrix.decompose(this._scaling, this._rotation, this._position);
        this._position.callback = this._transformChangeCallback;
        this._rotation.callback = this._transformChangeCallback;
        this._scaling.callback = this._transformChangeCallback;
    }
    /** @internal */ _onTransformChanged(invalidateLocal) {
        if (invalidateLocal) {
            this._localMatrix = null;
        }
        if (this._worldMatrix) {
            this._worldMatrix = null;
            this._invWorldMatrix = null;
            this._transformTag++;
            for (const child of this._children){
                child._onTransformChanged(false);
            }
        }
        this._worldMatrixDet = null;
    }
    /** @internal */ _setParent(p) {
        if (this._parent !== p) {
            if (this._parent) {
                this._parent._children.splice(this._parent._children.indexOf(this), 1);
            }
            this._parent = p;
            if (this._parent) {
                this._parent._children.push(this);
            }
            this._onTransformChanged(false);
        }
    }
}

/**
 * The base class for any kind of scene objects
 *
 * @remarks
 * We use a data structure called SceneGraph to store scenes,
 * which consists of a couple of scene objects forming a
 * hierarchical structure. This is the base class for any kind
 * of the scene object, which contains the basic properties such
 * as position, rotation, and scale of the object.
 *
 * @public
 */ class SceneNode extends XForm {
    /*
  static readonly PICK_INHERITED = -1;
  static readonly PICK_DISABLED = 0;
  static readonly PICK_ENABLED = 1;
  */ static BBOXDRAW_INHERITED = -1;
    static BBOXDRAW_DISABLED = 0;
    static BBOXDRAW_LOCAL = 1;
    static BBOXDRAW_WORLD = 2;
    /** @internal */ _clipMode;
    /** @internal */ _renderOrder;
    /** @internal */ _boxDrawMode;
    /** @internal */ _visible;
    /** @internal */ _pickMode;
    /** @internal */ _name;
    /** @internal */ _scene;
    /** @internal */ _bv;
    /** @internal */ _bvDirty;
    /** @internal */ _bvWorld;
    /** @internal */ _placeToOctree;
    /**
   * Creates a new scene node
   * @param scene - Which scene the node belongs to
   */ constructor(scene){
        super();
        this._scene = scene;
        this._name = '';
        this._bv = null;
        this._bvWorld = null;
        this._bvDirty = true;
        this._clipMode = true;
        this._boxDrawMode = SceneNode.BBOXDRAW_DISABLED;
        this._visible = 'inherit';
        this._pickMode = false;
        this._placeToOctree = true;
        if (scene && this !== scene.rootNode) {
            this.reparent(scene.rootNode);
        }
    }
    /** @internal */ get placeToOctree() {
        return this._placeToOctree;
    }
    set placeToOctree(val) {
        if (!!val !== this._placeToOctree) {
            this._placeToOctree = !!val;
            if (this.isGraphNode()) {
                this.scene.invalidateNodePlacement(this);
            }
        }
    }
    /**
   * Name of the scene node
   */ get name() {
        return this._name;
    }
    set name(val) {
        this._name = val || '';
    }
    /** The scene to which the node belongs */ get scene() {
        return this._scene;
    }
    /** true if the node is attached to the scene node, false otherwise */ get attached() {
        return !!this._scene?.rootNode?.isParentOf(this);
    }
    /**
   * Check if given node is a direct child of the node
   * @param child - The node to be checked
   * @returns true if the given node is a direct child of this node, false otherwise
   */ hasChild(child) {
        return this._children.indexOf(child) >= 0;
    }
    /**
   * Removes all children from this node
   */ removeChildren() {
        while(this._children.length){
            this._children[0].remove();
        }
    }
    /**
   * Checks if this node is the direct parent or indirect parent of a given node
   * @param child - The node to be checked
   * @returns true if this node is the direct parent or indirect parent of the given node, false otherwise
   */ isParentOf(child) {
        while(child && child !== this){
            child = child.parent;
        }
        return child === this;
    }
    /**
   * Removes this node from it's parent
   * @returns self
   */ remove() {
        this.parent = null;
        return this;
    }
    /**
   * Traverse the entire subtree of this node by a visitor
   * @param v - The visitor that will travel the subtree of this node
   * @param inverse - true if traversing from bottom to top, otherwise top to bottom
   */ traverse(v, inverse) {
        if (inverse) {
            for(let i = this._children.length - 1; i >= 0; i--){
                this._children[i].traverse(v, inverse);
            }
            v.visit(this);
        } else {
            v.visit(this);
            for (const child of this._children){
                child.traverse(v);
            }
        }
    }
    /**
   * Iterate self and all of the children
   * 
   * @remarks
   * DO NOT remove child duration iteration!
   * 
   * @param callback - callback function that will be called on each node
   */ iterate(callback) {
        callback(this);
        for (const child of this._children){
            child.iterate(callback);
        }
    }
    /** true if this is a graph node, false otherwise */ isGraphNode() {
        return false;
    }
    /** true if this is a light node, false otherwise */ isLight() {
        return false;
    }
    /** true if this is a mesh node, false otherwise */ isMesh() {
        return false;
    }
    /** true if this is a batch group, false otherwise */ isBatchGroup() {
        return false;
    }
    /** true if this is a terrain node, false otherwise */ isTerrain() {
        return false;
    }
    /** true if this is a camera node, false otherwise */ isCamera() {
        return false;
    }
    /** true if this is a punctual light node, false otherwise */ isPunctualLight() {
        return false;
    }
    /** Disposes the node */ dispose() {
        this.remove();
        this.removeChildren();
    }
    /**
   * Computes the bounding volume of the node
   * @param bv - The output bounding volume
   * @returns The output bounding volume
   */ computeBoundingVolume(bv) {
        return bv;
    }
    /**
   * Gets the bounding volume of the node
   * @returns The bounding volume of the node
   */ getBoundingVolume() {
        if (this._bvDirty) {
            this._bv = this.computeBoundingVolume(this._bv) || null;
            this._bvDirty = false;
        }
        return this._bv;
    }
    /**
   * Sets the bounding volume of the node
   * @param bv - The bounding volume to set
   */ setBoundingVolume(bv) {
        if (bv !== this._bv) {
            this._bv = bv;
            this.invalidateBoundingVolume();
        }
    }
    /**
   * Gets the world space bounding volume of the node
   * @returns The world space bounding volume of the node
   */ getWorldBoundingVolume() {
        if (!this._bvWorld) {
            this._bvWorld = this.getBoundingVolume()?.transform(this.worldMatrix) ?? null;
        }
        return this._bvWorld;
    }
    /**
   * Force the bounding volume to be recalculated
   */ invalidateBoundingVolume() {
        this._bvDirty = true;
        this.invalidateWorldBoundingVolume(false);
    }
    /** Force the world space bounding volume to be recalculated */ invalidateWorldBoundingVolume(transformChanged) {
        this._bvWorld = null;
        if (this._scene) {
            if (transformChanged) {
                this.iterate((node)=>{
                    if (node.isGraphNode()) {
                        this._scene.invalidateNodePlacement(node);
                    }
                });
            } else if (this.isGraphNode()) {
                this._scene.invalidateNodePlacement(this);
            }
        }
    }
    /** Clip mode */ get clipTestEnabled() {
        return this._clipMode;
    }
    set clipTestEnabled(val) {
        this._clipMode = val;
    }
    /** Computed value of show state */ get hidden() {
        let node = this;
        while(node && node._visible === 'inherit'){
            node = node.parent;
        }
        return node ? node._visible === 'hidden' : false;
    }
    /** Show state */ get showState() {
        return this._visible;
    }
    set showState(val) {
        if (val !== this._visible) {
            const prevHidden = this.hidden;
            this._visible = val;
            if (prevHidden !== this.hidden) {
                this.notifyHiddenChanged();
            }
        }
    }
    /** Computed value of pick mode */ get pickable() {
        return this._pickMode;
    }
    set pickable(val) {
        this._pickMode = !!val;
    }
    /** Computed value for bounding box draw mode */ get computedBoundingBoxDrawMode() {
        if (this._boxDrawMode === SceneNode.BBOXDRAW_INHERITED) {
            let parent = this.parent;
            while(parent && !parent.isGraphNode()){
                parent = parent.parent;
            }
            return parent?.computedBoundingBoxDrawMode ?? SceneNode.BBOXDRAW_DISABLED;
        }
        return this._boxDrawMode;
    }
    /** Bounding box draw mode */ get boundingBoxDrawMode() {
        return this._boxDrawMode;
    }
    set boundingBoxDrawMode(mode) {
        this._boxDrawMode = mode;
    }
    /** @internal */ _setParent(p) {
        let lastParent = this._parent;
        let newParent = p;
        if (newParent !== lastParent) {
            const sceneLast = this.attached ? this.scene : null;
            const sceneNew = newParent?.attached ? newParent.scene : null;
            const willDetach = sceneLast && sceneLast !== sceneNew;
            const willAttach = sceneNew && sceneLast !== sceneNew;
            willDetach && this._willDetach();
            willAttach && this._willAttach();
            super._setParent(newParent);
            willDetach && this._detached();
            willAttach && this._attached();
        }
        while(lastParent){
            lastParent.dispatchEvent(this, 'noderemoved');
            lastParent = lastParent.parent;
        }
        while(newParent){
            newParent.dispatchEvent(this, 'nodeattached');
            newParent = newParent.parent;
        }
    }
    /** @internal */ _onTransformChanged(invalidateLocal) {
        super._onTransformChanged(invalidateLocal);
        this.invalidateWorldBoundingVolume(true);
        this.dispatchEvent(this, 'transformchanged');
    }
    /** @internal */ _willAttach() {}
    /** @internal */ _attached() {}
    /** @internal */ _willDetach() {}
    /** @internal */ _detached() {}
    /** @internal */ notifyHiddenChanged() {
        this._visibleChanged();
        this.dispatchEvent(this, 'visiblechanged');
        for (const child of this._children){
            if (child.showState === 'inherit') {
                child.notifyHiddenChanged();
            }
        }
    }
    /** @internal */ _visibleChanged() {}
}

new AABB();
new Vector2(0, 0);
[
    Matrix4x4.identity(),
    // rotation z 270
    Matrix4x4.rotationZ(270 * Math.PI / 180),
    //new Matrix4x4(0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
    // rotation z 90
    Matrix4x4.rotationZ(90 * Math.PI / 180),
    //new Matrix4x4(0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
    // rotation z 180
    Matrix4x4.rotationZ(180 * Math.PI / 180)
];

/** @internal */ ({
    cascades: [
        {
            size: 450.0,
            strength: 0.8,
            croppiness: -1.2,
            minWave: 0,
            maxWave: 100
        },
        {
            size: 103.0,
            strength: 0.8,
            croppiness: -1.5,
            minWave: 0,
            maxWave: 100
        },
        {
            size: 13,
            strength: 0.9,
            croppiness: -1.5,
            minWave: 0,
            maxWave: 7
        }
    ],
    resolution: 256,
    wind: new Vector2(2, 2),
    alignment: 0.01,
    foamParams: new Vector2(1, 2),
    randomSeed: 0
});

/**
 * The camera node class
 * @public
 */ class Camera extends SceneNode {
    /** @internal */ _projMatrix;
    /** @internal */ _viewMatrix;
    /** @internal */ _viewProjMatrix;
    /** @internal */ _rotationMatrix;
    /** @internal */ _invViewProjMatrix;
    /** @internal */ _clipPlane;
    /** @internal */ _controller;
    /** @internal */ _frustum;
    /** @internal */ _frustumV;
    /** @internal */ _dirty;
    /** @internal */ _sampleCount;
    /** @internal */ _framebuffer;
    /** @internal */ _viewport;
    /** @internal */ _scissor;
    /** @internal */ _clearColor;
    /** @internal */ _clipMask;
    /** @internal */ _oit;
    /** @internal */ _depthPrePass;
    /** @internal */ _commandBufferReuse;
    /**
   * Creates a new camera node
   * @param scene - The scene that the camera belongs to
   * @param projectionMatrix - Projection matrix for this camera
   */ constructor(scene, projectionMatrix){
        super(scene);
        this._projMatrix = projectionMatrix || Matrix4x4.identity();
        this._viewMatrix = Matrix4x4.identity();
        this._viewProjMatrix = Matrix4x4.identity();
        this._invViewProjMatrix = Matrix4x4.identity();
        this._clipPlane = null;
        this._dirty = true;
        this._controller = null;
        this._framebuffer = null;
        this._viewport = null;
        this._scissor = null;
        this._clearColor = new Vector4(0, 0, 0, 1);
        this._clipMask = 0;
        this._sampleCount = 1;
        this._frustum = null;
        this._frustumV = null;
        this._oit = null;
        this._depthPrePass = false;
        this._commandBufferReuse = true;
    }
    /** Clip plane in camera space */ get clipPlane() {
        return this._clipPlane;
    }
    set clipPlane(plane) {
        this._clipPlane = plane;
        this._invalidate(false);
    }
    /** Whether to perform a depth pass */ get depthPrePass() {
        return this._depthPrePass;
    }
    set depthPrePass(val) {
        this._depthPrePass = !!val;
    }
    /** Whether to allow command buffer reuse optimization */ get commandBufferReuse() {
        return this._commandBufferReuse;
    }
    set commandBufferReuse(val) {
        this._commandBufferReuse = !!val;
    }
    /**
   * Sample count for MSAA
   *
   * @remarks
   * If greater than one, force the scene to be rendered using multisampled framebuffer
   */ get sampleCount() {
        return this._sampleCount;
    }
    set sampleCount(val) {
        if (val !== 1 && val !== 4) {
            console.error(`Invalid sample count: ${val}`);
        } else {
            this._sampleCount = val;
        }
    }
    /** OIT */ get oit() {
        return this._oit;
    }
    set oit(val) {
        this._oit = val;
    }
    /** Clip plane mask */ get clipMask() {
        return this._clipMask;
    }
    set clipMask(val) {
        this._clipMask = val;
    }
    /** Framebuffer object into which the scene will be rendered */ get framebuffer() {
        return this._framebuffer;
    }
    set framebuffer(fb) {
        this._framebuffer = fb ?? null;
    }
    /** Viewport used for rendering, if null, use full framebuffer size */ get viewport() {
        return this._viewport ? [
            ...this._viewport
        ] : null;
    }
    set viewport(rect) {
        this._viewport = rect?.slice() ?? null;
    }
    /** Scissor rectangle used for rendering, if null, use viewport value */ get scissor() {
        return this._scissor ? [
            ...this._scissor
        ] : null;
    }
    set scissor(rect) {
        this._scissor = rect?.slice() ?? null;
    }
    /** Color value used to clear color buffer before rendering, if null, color buffer will not be cleared */ get clearColor() {
        return this._clearColor;
    }
    set clearColor(val) {
        if (!val) {
            this._clearColor = null;
        } else {
            this._clearColor.set(val);
        }
    }
    /**
   * Handle input events
   * @param ev - input event object
   * @param type - event type, default to ev.type
   * @returns Boolean value indicates whether the event was handled.
   */ handleEvent(ev, type) {
        let handled = false;
        if (this._controller) {
            type = type ?? ev.type;
            if (type === 'pointerdown') {
                handled = this._controller.onMouseDown(ev);
            } else if (type === 'pointerup') {
                handled = this._controller.onMouseUp(ev);
            } else if (type === 'pointermove') {
                handled = this._controller.onMouseMove(ev);
            } else if (type === 'wheel') {
                handled = this._controller.onMouseWheel(ev);
            } else if (type === 'keydown') {
                handled = this._controller.onKeyDown(ev);
            } else if (type === 'keyup') {
                handled = this._controller.onKeyUp(ev);
            }
            if (handled) {
                ev.preventDefault();
            }
        }
        return handled;
    }
    /**
   * Place the camera by specifying the camera position and the target point
   * @param eye - The camera position
   * @param target - The target point to look at
   * @param up - The up vector
   * @returns self
   */ lookAt(eye, target, up) {
        return this.setLocalTransform(Matrix4x4.lookAt(eye, target, up));
    }
    /**
   * Place the camera to look at a given cube face at a given camera position
   * @param face - The cube face to look at
   * @param position - The camera position
   * @returns self
   */ lookAtCubeFace(face, position) {
        return this.setLocalTransform(Matrix4x4.lookAtCubeFace(face, position ?? this.position));
    }
    /**
   * Setup a perspective projection matrix for the camera
   * @param fovY - The vertical field of view in radians.
   * @param aspect - The aspect ratio
   * @param zNear - The near clip plane
   * @param zFar - The far clip plane
   * @returns self
   */ setPerspective(fovY, aspect, zNear, zFar) {
        this._projMatrix.perspective(fovY, aspect, zNear, zFar);
        this._invalidate(true);
        return this;
    }
    /**
   * Setup a orthogonal projection matrix for the camera
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum.
   * @param far - Far bound of the frustum.
   * @returns self
   */ setOrtho(left, right, bottom, top, near, far) {
        this._projMatrix.ortho(left, right, bottom, top, near, far);
        this._invalidate(true);
        return this;
    }
    /**
   * Setup a projection matrix for the camera
   * @param matrix - The projection matrix
   */ setProjectionMatrix(matrix) {
        if (matrix && matrix !== this._projMatrix) {
            this._projMatrix.set(matrix);
            this._invalidate(true);
        }
    }
    /**
   * Gets the projection matrix of the camera
   * @returns The projection matrix
   */ getProjectionMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._projMatrix;
    }
    getRotationMatrix() {
        const rotationMatrix = new Matrix4x4();
        this.worldMatrix.decompose(null, rotationMatrix, null);
        const xAxis = rotationMatrix.getRow(0).xyz().scaleBy(-1);
        const yAxis = rotationMatrix.getRow(1).xyz();
        const zAxis = rotationMatrix.getRow(2).xyz().scaleBy(-1);
        rotationMatrix.setRow(0, new Vector4(xAxis.x, xAxis.y, xAxis.z, 0));
        rotationMatrix.setRow(1, new Vector4(yAxis.x, yAxis.y, yAxis.z, 0));
        rotationMatrix.setRow(2, new Vector4(zAxis.x, zAxis.y, zAxis.z, 0));
        return rotationMatrix;
    }
    /**
   * View matrix of the camera
   *
   * @remarks
   * Camera's view matrix will transform a point from the world space to the camera space
   */ get viewMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._viewMatrix;
    }
    get viewProjectionMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._viewProjMatrix;
    }
    /**
   * The inverse-view-projection matrix of the camera
   *
   * @remarks
   * The inverse-view-projection matrix transforms a point from the clip space to the camera space
   */ get invViewProjectionMatrix() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._invViewProjMatrix;
    }
    /** Gets the frustum of the camera */ get frustum() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        return this._frustum;
    }
    get frustumViewSpace() {
        if (this._dirty) {
            this._dirty = false;
            this._compute();
        }
        if (!this._frustumV) {
            this._frustumV = new Frustum(this._projMatrix);
        }
        return this._frustumV;
    }
    /** The camera controller  */ get controller() {
        return this._controller || null;
    }
    set controller(controller) {
        this.setController(controller);
    }
    /** {@inheritDoc SceneNode.isCamera} */ isCamera() {
        return true;
    }
    /** Gets the near clip plane of the camera */ getNearPlane() {
        return this._projMatrix.getNearPlane();
    }
    /** Gets the far clip plane of the camera */ getFarPlane() {
        return this._projMatrix.getFarPlane();
    }
    /** Gets the vertical field of view of the camera */ getFOV() {
        return this._projMatrix.getFov();
    }
    /** Gets the tangent of half of the vertical field of view */ getTanHalfFovy() {
        return this._projMatrix.getTanHalfFov();
    }
    /** Gets the aspect ratio */ getAspect() {
        return this._projMatrix.getAspect();
    }
    /**
   * Renders a scene
   * @param scene - The scene to be rendered
   * @param compositor - Compositor instance that will be used to apply postprocess effects
   */ render(scene, compositor, logger) {
        const device = Application.instance.device;
        device.pushDeviceStates();
        device.reverseVertexWindingOrder(false);
        device.setFramebuffer(this._framebuffer);
        SceneRenderer.setClearColor(this._clearColor);
        SceneRenderer.renderScene(scene, this, compositor, logger);
        device.popDeviceStates();
    }
    /**
   * Updates the controller state
   */ updateController() {
        this._controller?.update();
    }
    /**
   * Reset the controller
   */ resetController() {
        this._controller?.reset();
    }
    /** @internal */ setController(controller) {
        if (this._controller !== controller) {
            if (controller && controller._getCamera() && controller._getCamera() !== this) {
                throw new Error('Camera.setController failed: one camera controller object cannot be assigned to multiple camera');
            }
            this._controller?._setCamera(null);
            this._controller = controller;
            this._controller?._setCamera(this);
        }
        return this;
    }
    /** @internal */ _invalidate(projectMatrixChanged) {
        this._dirty = true;
        if (projectMatrixChanged) {
            this._frustumV = null;
        }
    }
    /** @internal */ _compute() {
        this._computeProj();
        Matrix4x4.invertAffine(this.worldMatrix, this._viewMatrix);
        Matrix4x4.multiply(this._projMatrix, this._viewMatrix, this._viewProjMatrix);
        Matrix4x4.invert(this._viewProjMatrix, this._invViewProjMatrix);
        if (!this._frustum) {
            this._frustum = new Frustum(this._viewProjMatrix);
        } else {
            this._frustum.initWithMatrix(this._viewProjMatrix);
        }
    }
    /** @internal */ _computeProj() {}
    /** @internal */ _onTransformChanged(invalidateLocal) {
        super._onTransformChanged(invalidateLocal);
        this._invalidate(false);
    }
    /** {@inheritdoc SceneNode.dispose} */ dispose() {
        this.setController(null);
        this._projMatrix = null;
        this._viewMatrix = null;
        this._viewProjMatrix = null;
    }
}

const fogTypeMap = {
    linear: ShaderHelper.FOG_TYPE_LINEAR,
    exp: ShaderHelper.FOG_TYPE_EXP,
    exp2: ShaderHelper.FOG_TYPE_EXP2,
    scatter: ShaderHelper.FOG_TYPE_SCATTER,
    none: ShaderHelper.FOG_TYPE_NONE
};
const defaultSkyWorldMatrix = Matrix4x4.identity();
/**
 * The sky renderer
 * @public
 */ class SkyRenderer {
    _skyType;
    _skyColor;
    _skyboxTexture;
    _updateRadianceMaps;
    _radianceMapDirty;
    _scatterSkyboxFramebuffer;
    _scatterSkyboxTextureWidth;
    _aerialPerspectiveDensity;
    _radianceMap;
    _radianceMapWidth;
    _irradianceMap;
    _irradianceMapWidth;
    _fogType;
    _fogColor;
    _fogParams;
    _cloudy;
    _cloudIntensity;
    _wind;
    _nearestSampler;
    _programSky;
    _bindgroupSky;
    _programFog;
    _bindgroupFog;
    _programFogScatter;
    _bindgroupFogScatter;
    _vertexLayout;
    _primitiveSky;
    _skyWorldMatrix;
    _renderStatesSky;
    _renderStatesSkyNoDepthTest;
    _renderStatesFog;
    _renderStatesFogScatter;
    _drawGround;
    _lastSunDir;
    /**
   * Creates an instance of SkyRenderer
   */ constructor(){
        this._skyType = 'scatter';
        this._updateRadianceMaps = true;
        this._radianceMapDirty = true;
        this._skyColor = Vector4.zero();
        this._skyboxTexture = null;
        this._scatterSkyboxFramebuffer = null;
        this._scatterSkyboxTextureWidth = 256;
        this._aerialPerspectiveDensity = 1;
        this._radianceMap = null;
        this._radianceMapWidth = 128;
        this._irradianceMap = null;
        this._irradianceMapWidth = 64;
        this._fogType = 'none';
        this._fogColor = Vector4.one();
        this._fogParams = new Vector4(1, 100, 50, 0.002);
        this._cloudy = 0.6;
        this._cloudIntensity = 40;
        this._wind = Vector2.zero();
        this._drawGround = false;
        this._nearestSampler = null;
        this._programSky = {};
        this._bindgroupSky = {};
        this._programFog = null;
        this._bindgroupFog = null;
        this._programFogScatter = null;
        this._bindgroupFogScatter = null;
        this._vertexLayout = null;
        this._primitiveSky = null;
        this._renderStatesSky = null;
        this._renderStatesSkyNoDepthTest = null;
        this._renderStatesFog = null;
        this._renderStatesFogScatter = null;
        this._skyWorldMatrix = defaultSkyWorldMatrix;
        this._lastSunDir = Vector3.zero();
    }
    /** @internal */ getHash(ctx) {
        return ctx.applyFog === 'scatter' ? '1' : ctx.applyFog ? '2' : '0';
    }
    /** Which type of the sky should be rendered */ get skyType() {
        return this._skyType;
    }
    set skyType(val) {
        if (val !== this._skyType) {
            this._skyType = val;
            this.invalidateIBLMaps();
        }
    }
    /** Whether ground should be rendered */ get drawGround() {
        return this._drawGround;
    }
    set drawGround(val) {
        this._drawGround = !!val;
    }
    /**
   * Wether the IBL maps should be updated automatically.
   *
   * @remarks
   * If use use the sky for image-based lighting, the value shoud be set to true. default is false
   *
   */ get autoUpdateIBLMaps() {
        return this._updateRadianceMaps;
    }
    set autoUpdateIBLMaps(val) {
        if (this._updateRadianceMaps !== !!val) {
            this._updateRadianceMaps = !!val;
            if (this._updateRadianceMaps) {
                this.invalidateIBLMaps();
            }
        }
    }
    /**
   * The solid sky color
   */ get skyColor() {
        return this._skyColor;
    }
    set skyColor(val) {
        if (!val.equalsTo(this._skyColor)) {
            this._skyColor.set(val);
            this.invalidateIBLMaps();
        }
    }
    /** Aerial perspective density */ get aerialPerspectiveDensity() {
        return this._aerialPerspectiveDensity;
    }
    set aerialPerspectiveDensity(val) {
        this._aerialPerspectiveDensity = val;
    }
    /**
   * Light density of the sky.
   *
   * @remarks
   * This value controls how much cloud should be rendered when the sky type is scatter.
   * Typically, the value should be in the range of 0 to 1.
   */ get cloudy() {
        return this._cloudy;
    }
    set cloudy(val) {
        if (val !== this._cloudy && this._skyType === 'scatter') {
            this._cloudy = val;
            this.invalidateIBLMaps();
        }
    }
    /**
   * Intensity of the sky color
   */ get cloudIntensity() {
        return this._cloudIntensity;
    }
    set cloudIntensity(val) {
        if (val !== this._cloudIntensity && this._skyType === 'scatter') {
            this._cloudIntensity = val;
            this.invalidateIBLMaps();
        }
    }
    /**
   * Wind velocity
   *
   * @remarks
   * This value affects the movement of the cloud
   */ get wind() {
        return this._wind;
    }
    set wind(val) {
        this._wind.set(val);
    }
    /**
   * Radiance map of the sky.
   */ get radianceMap() {
        if (!this._radianceMap) {
            this._radianceMap = Application.instance.device.createCubeTexture('rgba16f', this._radianceMapWidth);
            this._radianceMap.name = 'SkyRadianceMap';
        }
        return this._radianceMap;
    }
    /**
   * Irradiance map of the sky.
   */ get irradianceMap() {
        if (!this._irradianceMap) {
            this._irradianceMap = Application.instance.device.createCubeTexture('rgba16f', this._irradianceMapWidth, {
                samplerOptions: {
                    mipFilter: 'none'
                }
            });
            this._irradianceMap.name = 'SkyIrradianceMap';
        }
        return this._irradianceMap;
    }
    /**
   * Cube texture for skybox.
   */ get skyboxTexture() {
        return this._skyboxTexture;
    }
    set skyboxTexture(tex) {
        if (tex !== this._skyboxTexture) {
            this._skyboxTexture = tex;
            if (this._skyType === 'skybox') {
                this.invalidateIBLMaps();
            }
        }
    }
    /** @internal */ get skyWorldMatrix() {
        return this._skyWorldMatrix;
    }
    set skyWorldMatrix(val) {
        val = val ?? defaultSkyWorldMatrix;
        if (val !== this._skyWorldMatrix) {
            this._skyWorldMatrix = val;
            this.invalidateIBLMaps();
        }
    }
    /** @internal */ get mappedFogType() {
        return fogTypeMap[this._fogType];
    }
    /** Current fog type */ get fogType() {
        return this._fogType;
    }
    set fogType(val) {
        this._fogType = val;
    }
    /** Start distance of linear fog */ get fogStart() {
        return this._fogParams.x;
    }
    set fogStart(val) {
        this._fogParams.x = val;
    }
    /** End distance of linear fog */ get fogEnd() {
        return this._fogParams.y;
    }
    set fogEnd(val) {
        this._fogParams.y = val;
    }
    /** Top distance of fog if fog type is not scatter */ get fogTop() {
        return this._fogParams.z;
    }
    set fogTop(val) {
        this._fogParams.z = val;
    }
    /** Density of exp/exp2 fog */ get fogDensity() {
        return this._fogParams.w;
    }
    set fogDensity(val) {
        this._fogParams.w = val;
    }
    /** The fog color if fog type is not scatter */ get fogColor() {
        return this._fogColor;
    }
    set fogColor(val) {
        this._fogColor.set(val);
    }
    /** @internal */ get fogParams() {
        return this._fogParams;
    }
    set fogParams(val) {
        this._fogParams.set(val);
    }
    /**
   * Force the radiance map and irradiance map to be regenerated.
   */ invalidateIBLMaps() {
        this._radianceMapDirty = true;
    }
    /** @internal */ drawScatteredFog(ctx) {
        return ctx.sunLight && this._fogType === 'scatter';
    }
    /** @internal */ getAerialPerspectiveLUT(ctx) {
        if (this.drawScatteredFog(ctx)) {
            const sunDir = SkyRenderer._getSunDir(ctx.sunLight);
            const alpha = Math.PI / 2 - Math.acos(Math.max(-1, Math.min(1, sunDir.y)));
            const farPlane = ctx.camera.getFarPlane() * this._aerialPerspectiveDensity * this._aerialPerspectiveDensity;
            return ScatteringLut.getAerialPerspectiveLut(alpha, farPlane);
        } else {
            return null;
        }
    }
    /**
   * Regenerate the radiance map and irradiance map
   *
   * @param sunLight - The sun light
   */ updateIBLMaps(sunDir) {
        const device = Application.instance.device;
        let bakedSkyboxTexture = null;
        if (this._skyType === 'skybox' && this._skyboxTexture) {
            bakedSkyboxTexture = this._skyboxTexture;
        } else {
            if (!this._scatterSkyboxFramebuffer) {
                const texCaps = device.getDeviceCaps().textureCaps;
                const format = texCaps.supportHalfFloatColorBuffer && texCaps.supportLinearHalfFloatTexture ? 'rgba16f' : texCaps.supportFloatColorBuffer && texCaps.supportLinearFloatTexture ? 'rgba32f' : 'rgba8unorm';
                const tex = device.createCubeTexture(format, this._scatterSkyboxTextureWidth);
                tex.name = 'BakedSkyboxTexture';
                this._scatterSkyboxFramebuffer = device.createFrameBuffer([
                    tex
                ], null);
                this._radianceMapDirty = true;
            }
            const camera = new Camera(null);
            camera.setPerspective(Math.PI / 2, 1, 1, 20);
            const saveRenderStates = device.getRenderStates();
            device.pushDeviceStates();
            device.setFramebuffer(this._scatterSkyboxFramebuffer);
            for (const face of [
                CubeFace.PX,
                CubeFace.NX,
                CubeFace.PY,
                CubeFace.NY,
                CubeFace.PZ,
                CubeFace.NZ
            ]){
                camera.lookAtCubeFace(face);
                this._scatterSkyboxFramebuffer.setColorAttachmentCubeFace(0, face);
                this._renderSky(camera, false, sunDir, true, false);
            }
            device.popDeviceStates();
            device.setRenderStates(saveRenderStates);
            bakedSkyboxTexture = this._scatterSkyboxFramebuffer.getColorAttachments()[0];
        }
        prefilterCubemap(bakedSkyboxTexture, 'ggx', this.radianceMap);
        prefilterCubemap(bakedSkyboxTexture, 'lambertian', this.irradianceMap);
    }
    /** @internal */ renderFog(ctx) {
        const camera = ctx.camera;
        const sceneDepthTexture = ctx.linearDepthTexture;
        const device = ctx.device;
        const savedRenderStates = device.getRenderStates();
        this._prepareSkyBox(device);
        const sunLight = ctx.sunLight;
        if (this._fogType === 'scatter' && !sunLight) {
            console.error('Cannot render scattering fog without sun light');
            return;
        }
        const fogProgram = this._fogType === 'scatter' ? this._programFogScatter : this._programFog;
        const renderStates = this._fogType === 'scatter' ? this._renderStatesFogScatter : this._renderStatesFog;
        if (fogProgram && sceneDepthTexture) {
            const bindgroup = this._fogType === 'scatter' ? this._bindgroupFogScatter : this._bindgroupFog;
            bindgroup.setTexture('depthTex', sceneDepthTexture, this._nearestSampler);
            bindgroup.setValue('rt', device.getFramebuffer() ? 1 : 0);
            bindgroup.setValue('invProjViewMatrix', camera.invViewProjectionMatrix);
            bindgroup.setValue('cameraNearFar', new Vector2(camera.getNearPlane(), camera.getFarPlane()));
            bindgroup.setValue('cameraPosition', camera.getWorldPosition());
            bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
            if (this._fogType === 'scatter') {
                const sunDir = sunLight ? sunLight.directionAndCutoff.xyz().scaleBy(-1) : ShaderHelper.defaultSunDir;
                const alpha = Math.PI / 2 - Math.acos(Math.max(-1, Math.min(1, sunDir.y)));
                const scale = this._aerialPerspectiveDensity * this._aerialPerspectiveDensity;
                const farPlane = ctx.camera.getFarPlane() * scale;
                bindgroup.setTexture('apLut', ScatteringLut.getAerialPerspectiveLut(alpha, farPlane));
                bindgroup.setValue('sliceDist', farPlane / ScatteringLut.aerialPerspectiveSliceZ);
                bindgroup.setValue('sunDir', sunDir);
                bindgroup.setValue('worldScale', scale);
            } else {
                bindgroup.setValue('fogType', this.mappedFogType);
                bindgroup.setValue('fogColor', this._fogColor);
                bindgroup.setValue('fogParams', this._fogParams);
            }
            device.setProgram(fogProgram);
            device.setBindGroup(0, bindgroup);
            device.setVertexLayout(this._vertexLayout);
            device.setRenderStates(renderStates);
            device.draw('triangle-strip', 0, 4);
            device.setRenderStates(savedRenderStates);
        }
    }
    /** @internal */ renderSky(ctx) {
        const sunDir = SkyRenderer._getSunDir(ctx.sunLight);
        if (!sunDir.equalsTo(this._lastSunDir)) {
            this._radianceMapDirty = true;
        }
        this._renderSky(ctx.camera, true, sunDir, this._drawGround, this._skyType === 'scatter' && this._cloudy > 0);
        if (this._radianceMapDirty && ctx.env.light.type === 'ibl') {
            if (ctx.env.light.radianceMap && (ctx.env.light.radianceMap === this._radianceMap || ctx.env.light.irradianceMap === this._irradianceMap)) {
                this._radianceMapDirty = false;
                this._lastSunDir.set(sunDir);
                this.updateIBLMaps(sunDir);
            }
        }
    }
    /** @internal */ _renderSky(camera, depthTest, sunDir, drawGround, drawCloud) {
        const device = Application.instance.device;
        const savedRenderStates = device.getRenderStates();
        this._prepareSkyBox(device);
        if (this._skyType === 'scatter') {
            this._drawScattering(camera, sunDir, depthTest, drawGround, drawCloud);
        } else if (this._skyType === 'skybox' && this._skyboxTexture) {
            this._drawSkybox(camera, depthTest);
        } else {
            this._drawSkyColor(camera, depthTest);
        }
        device.setRenderStates(savedRenderStates);
    }
    /** @internal */ _drawSkyColor(camera, depthTest) {
        const device = Application.instance.device;
        const bindgroup = this._bindgroupSky.color;
        bindgroup.setValue('viewProjMatrix', camera.viewProjectionMatrix);
        bindgroup.setValue('worldMatrix', this._skyWorldMatrix);
        bindgroup.setValue('cameraPos', camera.getWorldPosition());
        bindgroup.setValue('color', this._skyColor);
        bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
        device.setProgram(this._programSky.color);
        device.setBindGroup(0, bindgroup);
        device.setRenderStates(depthTest ? this._renderStatesSky : this._renderStatesSkyNoDepthTest);
        this._primitiveSky.draw();
    }
    /** @internal */ _drawSkybox(camera, depthTest) {
        const device = Application.instance.device;
        const bindgroup = this._bindgroupSky.skybox;
        bindgroup.setTexture('skyCubeMap', this._skyboxTexture);
        bindgroup.setValue('flip', device.getFramebuffer() && device.type === 'webgpu' ? new Vector4(1, -1, 1, 1) : new Vector4(1, 1, 1, 1));
        bindgroup.setValue('viewProjMatrix', camera.viewProjectionMatrix);
        bindgroup.setValue('worldMatrix', this._skyWorldMatrix);
        bindgroup.setValue('cameraPos', camera.getWorldPosition());
        bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
        device.setProgram(this._programSky.skybox);
        device.setBindGroup(0, bindgroup);
        device.setRenderStates(depthTest ? this._renderStatesSky : this._renderStatesSkyNoDepthTest);
        this._primitiveSky.draw();
    }
    /** @internal */ _drawScattering(camera, sunDir, depthTest, drawGround, drawCloud) {
        const device = Application.instance.device;
        const alpha = Math.PI / 2 - Math.acos(Math.max(-1, Math.min(1, sunDir.y)));
        const tLut = ScatteringLut.getTransmittanceLut();
        const skyLut = ScatteringLut.getSkyViewLut(alpha);
        //const apLut = ScatteringLut.getAerialPerspectiveLut(alpha, 8000);
        const program = drawCloud ? this._programSky.scatter : this._programSky['scatter-nocloud'];
        const bindgroup = drawCloud ? this._bindgroupSky.scatter : this._bindgroupSky['scatter-nocloud'];
        bindgroup.setValue('sunDir', sunDir);
        bindgroup.setValue('flip', device.getFramebuffer() && device.type === 'webgpu' ? new Vector4(1, -1, 1, 1) : new Vector4(1, 1, 1, 1));
        bindgroup.setValue('viewProjMatrix', camera.viewProjectionMatrix);
        bindgroup.setValue('worldMatrix', this._skyWorldMatrix);
        bindgroup.setValue('cameraPos', camera.getWorldPosition());
        bindgroup.setValue('srgbOut', device.getFramebuffer() ? 0 : 1);
        bindgroup.setTexture('tLut', tLut);
        bindgroup.setTexture('skyLut', skyLut);
        if (drawCloud) {
            bindgroup.setValue('cloudy', this._cloudy);
            bindgroup.setValue('cloudIntensity', this._cloudIntensity);
            bindgroup.setValue('time', device.frameInfo.elapsedOverall * 0.001);
            bindgroup.setValue('velocity', this._wind);
        }
        bindgroup.setValue('drawGround', drawGround ? 1 : 0);
        device.setProgram(program);
        device.setBindGroup(0, bindgroup);
        device.setRenderStates(depthTest ? this._renderStatesSky : this._renderStatesSkyNoDepthTest);
        this._primitiveSky.draw();
    }
    /** @internal */ _prepareSkyBox(device) {
        if (!this._programFogScatter) {
            this._programFogScatter = device.buildRenderProgram({
                label: 'FogScatter',
                vertex (pb) {
                    this.rt = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 1, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        if (device.type === 'webgpu') {
                            this.$if(pb.notEqual(this.rt, 0), function() {
                                this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                            });
                        }
                    });
                },
                fragment (pb) {
                    this.depthTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                    this.invProjViewMatrix = pb.mat4().uniform(0);
                    this.cameraNearFar = pb.vec2().uniform(0);
                    this.cameraPosition = pb.vec3().uniform(0);
                    this.apLut = pb.tex2D().uniform(0);
                    this.worldScale = pb.float().uniform(0);
                    this.sliceDist = pb.float().uniform(0);
                    this.sunDir = pb.vec3().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.depthValue = pb.textureSample(this.depthTex, this.$inputs.uv);
                        if (device.type === 'webgl') {
                            this.$l.linearDepth = decodeNormalizedFloatFromRGBA(this, this.depthValue);
                        } else {
                            this.$l.linearDepth = this.depthValue.r;
                        }
                        this.$l.nonLinearDepth = pb.div(pb.sub(pb.div(this.cameraNearFar.x, this.linearDepth), this.cameraNearFar.y), pb.sub(this.cameraNearFar.x, this.cameraNearFar.y));
                        //this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), this.nonLinearDepth, 1);
                        this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), pb.sub(pb.mul(this.nonLinearDepth, 2), 1), 1);
                        this.$l.hPos = pb.mul(this.invProjViewMatrix, this.clipSpacePos);
                        this.$l.hPos = pb.div(this.$l.hPos, this.$l.hPos.w);
                        this.$l.viewDir = pb.sub(this.hPos.xyz, this.cameraPosition);
                        // Assume object is above the sea level
                        this.viewDir.y = pb.max(0, this.viewDir.y);
                        this.$l.distance = pb.mul(pb.length(this.viewDir), this.worldScale);
                        this.$l.slice0 = pb.floor(pb.div(this.distance, this.sliceDist));
                        this.$l.slice1 = pb.add(this.slice0, 1);
                        this.$l.factor = pb.sub(pb.div(this.distance, this.sliceDist), this.slice0);
                        this.$l.viewNormal = pb.normalize(this.viewDir);
                        this.$l.horizonAngle = pb.acos(pb.clamp(pb.dot(pb.normalize(this.sunDir.xz), pb.normalize(this.viewNormal.xz)), 0, 1));
                        this.$l.zenithAngle = pb.asin(this.viewNormal.y);
                        this.$l.sliceU = pb.max(pb.div(this.horizonAngle, Math.PI * 2), 0.5 / ScatteringLut.aerialPerspectiveSliceZ);
                        this.$l.u0 = pb.div(pb.add(this.slice0, this.sliceU), ScatteringLut.aerialPerspectiveSliceZ);
                        this.$l.u1 = pb.add(this.u0, 1 / ScatteringLut.aerialPerspectiveSliceZ);
                        this.$l.v = pb.div(this.zenithAngle, Math.PI / 2);
                        this.$l.t0 = pb.textureSampleLevel(this.apLut, pb.vec2(this.u0, this.v), 0);
                        this.$l.t1 = pb.textureSampleLevel(this.apLut, pb.vec2(this.u1, this.v), 0);
                        this.$l.t = pb.mix(this.t0, this.t1, this.factor);
                        this.$outputs.outColor = pb.vec4(this.t.rgb, pb.sub(1, this.t.a));
                    });
                }
            });
            this._bindgroupFogScatter = device.createBindGroup(this._programFogScatter.bindGroupLayouts[0]);
        }
        if (!this._programFog) {
            this._programFog = device.buildRenderProgram({
                label: 'Fog',
                vertex (pb) {
                    this.rt = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 1, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        if (device.type === 'webgpu') {
                            this.$if(pb.notEqual(this.rt, 0), function() {
                                this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                            });
                        }
                    });
                },
                fragment (pb) {
                    this.depthTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                    this.invProjViewMatrix = pb.mat4().uniform(0);
                    this.cameraNearFar = pb.vec2().uniform(0);
                    this.cameraPosition = pb.vec3().uniform(0);
                    this.fogType = pb.int().uniform(0);
                    this.fogColor = pb.vec4().uniform(0);
                    this.fogParams = pb.vec4().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$l.depthValue = pb.textureSample(this.depthTex, this.$inputs.uv);
                        if (device.type === 'webgl') {
                            this.$l.linearDepth = decodeNormalizedFloatFromRGBA(this, this.depthValue);
                        } else {
                            this.$l.linearDepth = this.depthValue.r;
                        }
                        this.$l.nonLinearDepth = pb.div(pb.sub(pb.div(this.cameraNearFar.x, this.linearDepth), this.cameraNearFar.y), pb.sub(this.cameraNearFar.x, this.cameraNearFar.y));
                        //this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), this.nonLinearDepth, 1);
                        this.$l.clipSpacePos = pb.vec4(pb.sub(pb.mul(this.$inputs.uv, 2), pb.vec2(1)), pb.sub(pb.mul(this.nonLinearDepth, 2), 1), 1);
                        this.$l.hPos = pb.mul(this.invProjViewMatrix, this.clipSpacePos);
                        this.$l.hPos = pb.div(this.$l.hPos, this.$l.hPos.w);
                        this.$l.viewDir = pb.sub(this.hPos.xyz, this.cameraPosition);
                        this.$l.fogFactor = ShaderHelper.computeFogFactor(this, this.viewDir, this.fogType, this.fogParams);
                        this.$l.color = pb.mul(this.fogColor.rgb, this.fogFactor);
                        this.$if(pb.equal(this.srgbOut, 0), function() {
                            this.$outputs.outColor = pb.vec4(this.color, this.fogFactor);
                        }).$else(function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color), this.fogFactor);
                        });
                    });
                }
            });
            this._bindgroupFog = device.createBindGroup(this._programFog.bindGroupLayouts[0]);
        }
        if (!this._programSky.color) {
            this._programSky.color = device.buildRenderProgram({
                label: 'SolidColorSky',
                vertex (pb) {
                    this.$inputs.pos = pb.vec3().attrib('position');
                    this.worldMatrix = pb.mat4().uniform(0);
                    this.viewProjMatrix = pb.mat4().uniform(0);
                    this.cameraPos = pb.vec3().uniform(0);
                    pb.main(function() {
                        this.$l.worldDirection = pb.mul(this.worldMatrix, pb.vec4(this.$inputs.pos, 0)).xyz;
                        this.$builtins.position = pb.mul(this.viewProjMatrix, pb.vec4(pb.add(this.worldDirection, this.cameraPos), 1));
                        this.$builtins.position.z = this.$builtins.position.w;
                    });
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.color = pb.vec4().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    pb.main(function() {
                        this.$if(pb.equal(this.srgbOut, 0), function() {
                            this.$outputs.outColor = pb.vec4(this.color.rgb, 1);
                        }).$else(function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color.rgb), 1);
                        });
                    });
                }
            });
            this._bindgroupSky.color = device.createBindGroup(this._programSky.color.bindGroupLayouts[0]);
        }
        if (!this._programSky.scatter) {
            this._programSky.scatter = SkyRenderer._createScatterProgram(device, true);
            this._bindgroupSky.scatter = device.createBindGroup(this._programSky.scatter.bindGroupLayouts[0]);
        }
        if (!this._programSky['scatter-nocloud']) {
            this._programSky['scatter-nocloud'] = SkyRenderer._createScatterProgram(device, false);
            this._bindgroupSky['scatter-nocloud'] = device.createBindGroup(this._programSky['scatter-nocloud'].bindGroupLayouts[0]);
        }
        if (!this._programSky.skybox) {
            this._programSky.skybox = device.buildRenderProgram({
                label: 'SkyBoxSky',
                vertex (pb) {
                    this.$inputs.pos = pb.vec3().attrib('position');
                    this.$outputs.texCoord = pb.vec3();
                    this.worldMatrix = pb.mat4().uniform(0);
                    this.viewProjMatrix = pb.mat4().uniform(0);
                    this.cameraPos = pb.vec3().uniform(0);
                    this.flip = pb.vec4().uniform(0);
                    pb.main(function() {
                        this.$outputs.texCoord = this.$inputs.pos;
                        this.$l.worldPos = pb.add(this.cameraPos, pb.mul(this.worldMatrix, pb.vec4(this.$inputs.pos, 0)).xyz);
                        this.$builtins.position = pb.mul(this.viewProjMatrix, pb.vec4(this.worldPos, 1), this.flip);
                        this.$builtins.position.z = this.$builtins.position.w;
                    });
                },
                fragment (pb) {
                    this.$outputs.outColor = pb.vec4();
                    this.skyCubeMap = pb.texCube().uniform(0);
                    this.srgbOut = pb.int().uniform(0);
                    pb.main(function() {
                        this.$l.texCoord = pb.normalize(this.$inputs.texCoord);
                        this.$l.color = pb.textureSampleLevel(this.skyCubeMap, this.texCoord, 0).rgb;
                        this.$if(pb.equal(this.srgbOut, 0), function() {
                            this.$outputs.outColor = pb.vec4(this.color, 1);
                        }).$else(function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color), 1);
                        });
                    });
                }
            });
            this._bindgroupSky.skybox = device.createBindGroup(this._programSky.skybox.bindGroupLayouts[0]);
        }
        if (!this._renderStatesSky) {
            this._renderStatesSky = device.createRenderStateSet();
            this._renderStatesSky.useDepthState().enableTest(true).enableWrite(false).setCompareFunc('le');
            this._renderStatesSky.useRasterizerState().setCullMode('none');
        }
        if (!this._renderStatesSkyNoDepthTest) {
            this._renderStatesSkyNoDepthTest = device.createRenderStateSet();
            this._renderStatesSkyNoDepthTest.useDepthState().enableTest(false).enableWrite(false);
            this._renderStatesSkyNoDepthTest.useRasterizerState().setCullMode('none');
        }
        if (!this._renderStatesFog) {
            this._renderStatesFog = device.createRenderStateSet();
            this._renderStatesFog.useRasterizerState().setCullMode('none');
            this._renderStatesFog.useBlendingState().enable(true).setBlendFunc('one', 'inv-src-alpha');
            this._renderStatesFog.useDepthState().enableTest(false).enableWrite(false);
        }
        if (!this._renderStatesFogScatter) {
            this._renderStatesFogScatter = device.createRenderStateSet();
            this._renderStatesFogScatter.useRasterizerState().setCullMode('none');
            this._renderStatesFogScatter.useBlendingState().enable(true).setBlendFunc('one', 'inv-src-alpha');
            this._renderStatesFogScatter.useDepthState().enableTest(true).enableWrite(false).setCompareFunc('gt');
        }
        if (!this._nearestSampler) {
            this._nearestSampler = device.createSampler({
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
        }
        if (!this._vertexLayout) {
            this._vertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                            -1,
                            -1,
                            1,
                            -1,
                            -1,
                            1,
                            1,
                            1
                        ]))
                    }
                ]
            });
        }
        if (!this._primitiveSky) {
            this._primitiveSky = new BoxShape({
                size: 8
            });
        }
    }
    /** @internal */ static _getSunDir(sunLight) {
        // TODO: reduce GC
        return sunLight?.directionAndCutoff.xyz().scaleBy(-1) ?? ShaderHelper.defaultSunDir;
    }
    static _createScatterProgram(device, cloud) {
        return device.buildRenderProgram({
            vertex (pb) {
                this.$inputs.pos = pb.vec3().attrib('position');
                this.worldMatrix = pb.mat4().uniform(0);
                this.viewProjMatrix = pb.mat4().uniform(0);
                this.cameraPos = pb.vec3().uniform(0);
                this.flip = pb.vec4().uniform(0);
                pb.main(function() {
                    this.$outputs.worldDirection = pb.mul(this.worldMatrix, pb.vec4(this.$inputs.pos, 0)).xyz;
                    this.$builtins.position = pb.mul(this.viewProjMatrix, pb.vec4(pb.add(this.$outputs.worldDirection, this.cameraPos), 1), this.flip);
                    this.$builtins.position.z = this.$builtins.position.w;
                });
            },
            fragment (pb) {
                this.$outputs.outColor = pb.vec4();
                this.tLut = pb.tex2D().uniform(0);
                this.skyLut = pb.tex2D().uniform(0);
                this.sunDir = pb.vec3().uniform(0);
                if (cloud) {
                    this.cloudy = pb.float().uniform(0);
                    this.cloudIntensity = pb.float().uniform(0);
                    this.time = pb.float().uniform(0);
                    this.velocity = pb.vec2().uniform(0);
                }
                this.drawGround = pb.int().uniform(0);
                this.srgbOut = pb.int().uniform(0);
                this.viewPos = pb.vec3(ScatteringLut.viewPosition.x, ScatteringLut.viewPosition.y, ScatteringLut.viewPosition.z);
                pb.func('getMiePhase', [
                    pb.float('cosTheta')
                ], function() {
                    this.$l.g = pb.float(0.8);
                    this.$l.scale = pb.float(3 / (Math.PI * 8));
                    this.$l.gg = pb.mul(this.g, this.g);
                    this.$l.num = pb.mul(pb.sub(1, this.gg), pb.add(pb.mul(this.cosTheta, this.cosTheta), 1));
                    this.$l.denom = pb.mul(pb.add(2, this.gg), pb.pow(pb.sub(pb.add(1, this.gg), pb.mul(this.g, this.cosTheta, 2)), 1.5));
                    this.$return(pb.div(pb.mul(this.scale, this.num), this.denom));
                });
                pb.func('noise', [
                    pb.vec3('p'),
                    pb.float('t')
                ], function() {
                    this.p2 = pb.mul(this.p, 0.25);
                    this.f = pb.mul(smoothNoise3D(this, this.p2), 0.5);
                    this.p2 = pb.mul(this.p2, 3.02);
                    this.p2.y = pb.sub(this.p2.y, pb.mul(this.t, 0.02));
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.25));
                    this.p2 = pb.mul(this.p2, 3.03);
                    this.p2.y = pb.add(this.p2.y, pb.mul(this.t, 0.01));
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.125));
                    this.p2 = pb.mul(this.p2, 3.02);
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.0625));
                    this.p2 = pb.mul(this.p2, 3.01);
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.03125));
                    this.p2 = pb.mul(this.p2, 3.01);
                    this.f = pb.add(this.f, pb.mul(smoothNoise3D(this, this.p2), 0.015625));
                    this.$return(this.f);
                });
                pb.func('getValFromSkyLUT', [
                    pb.vec3('rayDir'),
                    pb.vec3('sunDir')
                ], function() {
                    this.$l.height = pb.length(this.viewPos);
                    this.$l.up = pb.div(this.viewPos, this.height);
                    this.$l.c = pb.div(pb.sqrt(pb.sub(pb.mul(this.height, this.height), pb.mul(ScatteringLut.groundRadius, ScatteringLut.groundRadius))), this.height);
                    this.$l.horizonAngle = pb.acos(pb.clamp(this.c, -1, 1));
                    this.$l.altitudeAngle = pb.sub(this.horizonAngle, pb.acos(pb.dot(this.rayDir, this.up)));
                    this.$l.azimuthAngle = pb.float();
                    this.$if(pb.greaterThan(pb.abs(this.altitudeAngle), Math.PI * 0.5 - 0.0001), function() {
                        this.azimuthAngle = 0;
                    }).$else(function() {
                        this.$l.right = pb.cross(this.sunDir, this.up);
                        this.$l.forward = pb.cross(this.up, this.right);
                        this.$l.projectedDir = pb.normalize(pb.sub(this.rayDir, pb.mul(this.up, pb.dot(this.rayDir, this.up))));
                        this.$l.sinTheta = pb.dot(this.projectedDir, this.right);
                        this.$l.cosTheta = pb.dot(this.projectedDir, this.forward);
                        this.azimuthAngle = pb.add(pb.atan2(this.sinTheta, this.cosTheta), Math.PI);
                    });
                    this.$l.v = pb.add(0.5, pb.mul(0.5, pb.sign(this.altitudeAngle), pb.sqrt(pb.mul(pb.abs(this.altitudeAngle), 2 / Math.PI))));
                    this.$l.uv = pb.vec2(pb.div(this.azimuthAngle, Math.PI * 2), this.v);
                    this.$return(pb.textureSampleLevel(this.skyLut, this.uv, 0).rgb);
                });
                pb.func('sunWithBloom', [
                    pb.vec3('rayDir'),
                    pb.vec3('sunDir')
                ], function() {
                    this.$l.sunSolidAngle = 0.53 * Math.PI / 180;
                    this.$l.minSunCosTheta = pb.cos(this.sunSolidAngle);
                    this.$l.cosTheta = pb.dot(this.rayDir, this.sunDir);
                    this.$if(pb.greaterThanEqual(this.cosTheta, this.minSunCosTheta), function() {
                        this.$return(pb.vec3(1));
                    });
                    this.$l.offset = pb.sub(this.minSunCosTheta, this.cosTheta);
                    this.$l.gaussianBloom = pb.mul(pb.exp(pb.mul(this.offset, -50000)), 0.5);
                    this.$l.invBloom = pb.mul(pb.div(1, pb.add(0.02, pb.mul(this.offset, 300))), 0.01);
                    this.$return(pb.vec3(pb.add(this.gaussianBloom, this.invBloom)));
                });
                pb.func('rayIntersectSphere', [
                    pb.vec3('ro'),
                    pb.vec3('rd'),
                    pb.float('rad')
                ], function() {
                    this.$l.b = pb.dot(this.ro, this.rd);
                    this.$l.c = pb.sub(pb.dot(this.ro, this.ro), pb.mul(this.rad, this.rad));
                    this.$if(pb.and(pb.greaterThan(this.c, 0), pb.greaterThan(this.b, 0)), function() {
                        this.$return(pb.float(-1));
                    });
                    this.$l.bb = pb.mul(this.b, this.b);
                    this.$l.discr = pb.sub(this.bb, this.c);
                    this.$if(pb.lessThan(this.discr, 0), function() {
                        this.$return(pb.float(-1));
                    });
                    this.$if(pb.greaterThan(this.discr, this.bb), function() {
                        this.$return(pb.sub(pb.sqrt(this.discr), this.b));
                    });
                    this.$return(pb.sub(pb.neg(pb.sqrt(this.discr)), this.b));
                });
                pb.func('getValFromTLUT', [
                    pb.vec3('pos'),
                    pb.vec3('sunDir')
                ], function() {
                    this.$l.height = pb.length(this.pos);
                    this.$l.up = pb.div(this.pos, this.height);
                    this.$l.sunCosZenithAngle = pb.dot(this.sunDir, this.up);
                    this.$l.uv = pb.vec2(pb.clamp(pb.add(0.5, pb.mul(this.sunCosZenithAngle, 0.5)), 0, 1), pb.max(0, pb.min(1, pb.div(pb.sub(this.height, ScatteringLut.groundRadius), pb.sub(ScatteringLut.atmosphereRadius, ScatteringLut.groundRadius)))));
                    this.$return(pb.textureSampleLevel(this.tLut, this.uv, 0).rgb);
                });
                pb.main(function() {
                    this.$l.rayDir = pb.normalize(this.$inputs.worldDirection);
                    // ad-hoc
                    this.$l.sunIntensity = pb.sqrt(pb.max(0, pb.mul(this.sunDir.y, this.rayDir.y)));
                    // compute cloud
                    if (cloud) {
                        this.$l.noiseValue = pb.float();
                        this.$if(pb.lessThanEqual(this.rayDir.y, 0), function() {
                            this.noiseValue = 0;
                        }).$else(function() {
                            this.$l.tMin = pb.div(3000, this.rayDir.y);
                            this.$l.cloudPoint = pb.mul(this.rayDir, this.tMin);
                            this.speed = pb.mul(pb.vec3(this.velocity.x, 0, this.velocity.y), this.time);
                            this.$l.noiseScale = pb.float(4e-4);
                            this.noiseValue = this.noise(pb.mul(pb.add(this.cloudPoint, this.speed), this.noiseScale), this.time);
                            this.noiseValue = pb.add(this.noiseValue, this.cloudy);
                            this.noiseValue = pb.smoothStep(1, pb.add(1, this.cloudy), this.noiseValue);
                        });
                        // use sun color as cloud color
                        this.$l.sunColor = pb.mul(this.getValFromSkyLUT(this.sunDir, this.sunDir), this.sunIntensity);
                        this.$l.cloudColor = pb.mul(this.sunColor.rgb, pb.mul(this.noiseValue, this.cloudIntensity));
                    }
                    // Compute sky color
                    this.$l.skyRayDir = this.$choice(pb.equal(this.drawGround, 0), pb.normalize(pb.vec3(this.rayDir.x, pb.max(0, this.rayDir.y), this.rayDir.z)), this.rayDir);
                    this.$l.lum = this.getValFromSkyLUT(this.skyRayDir, this.sunDir);
                    this.$l.sunLum = this.sunWithBloom(this.rayDir, this.sunDir);
                    this.sunLum = pb.smoothStep(pb.vec3(0.002), pb.vec3(1), this.sunLum);
                    this.$if(pb.greaterThan(pb.length(this.sunLum), 0), function() {
                        this.$if(pb.greaterThanEqual(this.rayIntersectSphere(this.viewPos, this.rayDir, ScatteringLut.groundRadius), 0), function() {
                            this.sunLum = pb.vec3(0);
                        }).$else(function() {
                            this.sunLum = pb.mul(this.sunLum, this.getValFromTLUT(this.viewPos, this.sunDir));
                        });
                    });
                    if (cloud) {
                        this.lum = pb.add(this.lum, this.sunLum);
                        // blend
                        this.$l.vfactor = pb.clamp(pb.div(pb.sub(this.rayDir.y, 0.01), pb.sub(0.03, 0.01)), 0, 1);
                        this.$l.factor = pb.clamp(pb.mul(this.noiseValue, this.vfactor), 0, 1);
                        this.$l.color = pb.mix(this.lum, this.cloudColor, this.factor);
                    } else {
                        this.$l.color = this.lum;
                    }
                    this.color = pb.mul(this.color, 8);
                    this.color = pb.pow(this.color, pb.vec3(1.3));
                    this.color = pb.div(this.color, pb.add(pb.mul(pb.smoothStep(0, 0.2, pb.clamp(this.sunDir.y, 0, 1)), 2), 0.15));
                    this.$if(pb.equal(this.srgbOut, 0), function() {
                        this.$outputs.outColor = pb.vec4(this.color, 1);
                    }).$else(function() {
                        this.$outputs.outColor = pb.vec4(linearToGamma(this, this.color), 1);
                    });
                });
            }
        });
    }
}

/**
 * Temporal framebuffer cache
 *
 * @internal
 */ class TemporalCache {
    static _ownDepthTextures = new Set();
    static _variantWidth = 0;
    static _variantHeight = 0;
    static _releaseFuncs = new Map();
    static _cachedFrameBuffers = {};
    static getFramebufferFixedSize(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, sampleCount = 1) {
        return this.getFramebuffer(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, false, sampleCount);
    }
    static getFramebufferVariantSize(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, sampleCount = 1) {
        return this.getFramebuffer(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, true, sampleCount);
    }
    static getFramebufferFixedSizeWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, sampleCount = 1) {
        return this.getFramebufferWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, false, sampleCount);
    }
    static getFramebufferVariantSizeWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, sampleCount = 1) {
        return this.getFramebufferWithDepth(depthTex, numLayers, colorFmt, colorType, mipmapping, true, sampleCount);
    }
    static getFramebuffer(width, height, numLayers, colorFmt, depthFmt, colorType, depthType, mipmapping, variant, sampleCount) {
        if (variant && (width !== this._variantWidth || height !== this._variantHeight)) {
            this.purgeVariantFramebuffers();
            this._variantWidth = width;
            this._variantHeight = height;
        }
        if (colorType !== '2darray' && depthType !== '2darray') {
            numLayers = 1;
        }
        const device = Application.instance.device;
        if (device.type === 'webgl') {
            sampleCount = 1;
        }
        const sizeHash = variant ? '' : `${width}x${height}`;
        const fmtHash = `${colorFmt ?? ''}:${depthFmt ?? ''}:${colorFmt ? colorType : ''}:${numLayers}:${depthFmt ? depthType : ''}:${colorFmt && mipmapping ? 1 : 0}:${sampleCount}`;
        const sizedFrameBuffers = this._cachedFrameBuffers[sizeHash];
        const fbList = sizedFrameBuffers?.get(null)?.[fmtHash];
        let fb = null;
        if (!fbList || fbList.length === 0) {
            let colorTex = null;
            const opt = mipmapping ? {} : {
                samplerOptions: {
                    mipFilter: 'none'
                }
            };
            if (colorFmt) {
                switch(colorType){
                    case '2d':
                        colorTex = device.createTexture2D(colorFmt, width, height, opt);
                        break;
                    case '2darray':
                        colorTex = device.createTexture2DArray(colorFmt, width, height, numLayers, opt);
                        break;
                    case 'cube':
                        colorTex = device.createCubeTexture(colorFmt, width, opt);
                        break;
                }
            }
            let depthTex = null;
            if (depthFmt) {
                switch(depthType){
                    case '2d':
                        depthTex = device.createTexture2D(depthFmt, width, height);
                        break;
                    case '2darray':
                        depthTex = device.createTexture2DArray(depthFmt, width, height, numLayers);
                        break;
                    case 'cube':
                        depthTex = device.createCubeTexture(depthFmt, width);
                        break;
                }
            }
            fb = device.createFrameBuffer(colorTex ? [
                colorTex
            ] : [], depthTex, {
                sampleCount,
                ignoreDepthStencil: false
            });
            this._ownDepthTextures.add(depthTex);
        } else {
            fb = fbList.pop();
        }
        this._releaseFuncs.set(fb, variant ? this.releaseWithoutDepthTexVariantSize : this.releaseWithoutDepthTexFixedSize);
        return fb;
    }
    static getFramebufferWithDepth(depth, numLayers, colorFmt, colorType, mipmapping, variant, sampleCount) {
        if (variant && (depth.width !== this._variantWidth || depth.height !== this._variantHeight)) {
            this.purgeVariantFramebuffers();
            this._variantWidth = depth.width;
            this._variantHeight = depth.height;
        }
        if (!colorFmt || colorType !== '2darray') {
            numLayers = 1;
        }
        const device = Application.instance.device;
        if (device.type === 'webgl') {
            sampleCount = 1;
        }
        const sizeHash = variant ? '' : `${depth.width}x${depth.height}`;
        const fmtHash = `${colorFmt ?? ''}:${depth.format}:${colorFmt ? colorType : ''}:${numLayers}:${depth.target}:${colorFmt && mipmapping ? 1 : 0}:${sampleCount}`;
        const sizedFrameBuffers = this._cachedFrameBuffers[sizeHash];
        const fbList = sizedFrameBuffers?.get(depth)?.[fmtHash];
        let fb = null;
        if (!fbList || fbList.length === 0) {
            let colorTex = null;
            const opt = mipmapping ? {} : {
                samplerOptions: {
                    mipFilter: 'none'
                }
            };
            if (colorFmt) {
                switch(colorType){
                    case '2d':
                        colorTex = device.createTexture2D(colorFmt, depth.width, depth.height, opt);
                        break;
                    case '2darray':
                        colorTex = device.createTexture2DArray(colorFmt, depth.width, depth.height, numLayers, opt);
                        break;
                    case 'cube':
                        colorTex = device.createCubeTexture(colorFmt, depth.width, opt);
                        break;
                }
            }
            fb = device.createFrameBuffer([
                colorTex
            ], depth, {
                sampleCount,
                ignoreDepthStencil: false
            });
            depth.on('disposed', ()=>{
                const sizedFrameBuffers = this._cachedFrameBuffers[sizeHash];
                const entry = sizedFrameBuffers?.get(depth);
                if (entry) {
                    for(const k in entry){
                        const index = entry[k].indexOf(fb);
                        if (index >= 0) {
                            entry[k].splice(index, 1);
                            if (entry[k].length === 0) {
                                delete entry[k];
                            }
                        }
                    }
                    if (Object.getOwnPropertyNames(entry).length === 0) {
                        sizedFrameBuffers.delete(depth);
                    }
                }
                fb.getColorAttachments()[0]?.dispose();
                fb.dispose();
            });
        } else {
            fb = fbList.pop();
        }
        this._releaseFuncs.set(fb, variant ? this.releaseWithDepthTexVariantSize : this.releaseWithDepthTexFixedSize);
        return fb;
    }
    static releaseFramebuffer(fb) {
        const releaseFunc = this._releaseFuncs.get(fb);
        if (releaseFunc) {
            releaseFunc.call(this, fb);
            this._releaseFuncs.delete(fb);
        }
    }
    static releaseWithDepthTexFixedSize(fb) {
        this.releaseFrameBufferInternal(fb, fb.getDepthAttachment(), true);
    }
    static releaseWithDepthTexVariantSize(fb) {
        this.releaseFrameBufferInternal(fb, fb.getDepthAttachment(), false);
    }
    static releaseWithoutDepthTexFixedSize(fb) {
        this.releaseFrameBufferInternal(fb, null, true);
    }
    static releaseWithoutDepthTexVariantSize(fb) {
        this.releaseFrameBufferInternal(fb, null, false);
    }
    static releaseFrameBufferInternal(fb, withDepthTex, withSize) {
        const tex = fb.getDepthAttachment() ?? fb.getColorAttachments()[0];
        const sizeHash = withSize ? `${tex.width}x${tex.height}` : '';
        let variantSizeFrameBuffers = this._cachedFrameBuffers[sizeHash];
        if (!variantSizeFrameBuffers) {
            variantSizeFrameBuffers = new Map();
            this._cachedFrameBuffers[sizeHash] = variantSizeFrameBuffers;
        }
        const colorTex = fb.getColorAttachments()[0];
        const depthTex = fb.getDepthAttachment();
        const numLayers = colorTex?.isTexture2DArray() ? colorTex.depth : depthTex?.isTexture2DArray() ? depthTex.depth : 1;
        const hash = `${colorTex?.format ?? ''}:${depthTex?.format ?? ''}:${colorTex ? colorTex.target : ''}:${numLayers}:${depthTex ? depthTex.target : ''}:${colorTex?.mipLevelCount > 1 ? 1 : 0}:${fb.getSampleCount()}`;
        let entry = variantSizeFrameBuffers.get(withDepthTex);
        if (!entry) {
            entry = {};
            variantSizeFrameBuffers.set(withDepthTex, entry);
        }
        let fblist = entry[hash];
        if (!fblist) {
            fblist = [];
            entry[hash] = fblist;
        }
        fblist.push(fb);
    }
    static purgeVariantFramebuffers() {
        const variantSizeFrameBuffers = this._cachedFrameBuffers[''];
        variantSizeFrameBuffers?.forEach((val, key)=>{
            for(const k in val){
                val[k].forEach((fb)=>{
                    fb.getColorAttachments()[0].dispose();
                    fb.dispose();
                });
            }
            if (this._ownDepthTextures.has(key)) {
                this._ownDepthTextures.delete(key);
                key?.dispose();
            }
        });
        variantSizeFrameBuffers?.clear();
    }
}

/** @internal */ class ShadowImpl {
    _resourceDirty;
    constructor(){
        this._resourceDirty = true;
    }
    invalidateResource() {
        this._resourceDirty = true;
    }
    updateResources(shadowMapParams) {
        this.doUpdateResources(shadowMapParams);
    }
}

/*
  const PCF_KERNEL_3x3 = [
    [0.5, 1.0, 0.5],
    [1.0, 1.0, 1.0],
    [0.5, 1.0, 0.5]
  ];
  const PCF_KERNEL_SUM_3x3 = 7;

  const PCF_KERNEL_5x5 = [
    [0.0, 0.5, 1.0, 0.5, 0.0],
    [0.5, 1.0, 1.0, 1.0, 0.5],
    [1.0, 1.0, 1.0, 1.0, 1.0],
    [0.5, 1.0, 1.0, 1.0, 0.5],
    [0.0, 0.5, 1.0, 0.5, 0.0]
  ];
  const PCF_KERNEL_SUM_5x5 = 17;

  const PCF_KERNEL_7x7 = [
    [0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0]
  ];
  const PCF_KERNEL_SUM_7x7 = 33;

  const PCF_KERNEL_9x9 = [
    [0.0, 0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0, 0.0],
    [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
    [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
    [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0],
    [0.0, 0.0, 0.0, 0.5, 1.0, 0.5, 0.0, 0.0, 0.0]
  ];
  const PCF_KERNEL_SUM_9x9 = 53;
  */ const PCF_POISSON_DISC = [
    [
        0.511749,
        0.547686
    ],
    [
        0.58929,
        0.257224
    ],
    [
        0.165018,
        0.57663
    ],
    [
        0.407692,
        0.742285
    ],
    [
        0.707012,
        0.646523
    ],
    [
        0.31463,
        0.466825
    ],
    [
        0.801257,
        0.485186
    ],
    [
        0.418136,
        0.146517
    ],
    [
        0.579889,
        0.0368284
    ],
    [
        0.79801,
        0.140114
    ],
    [
        -0.0413185,
        0.371455
    ],
    [
        -0.0529108,
        0.627352
    ],
    [
        0.0821375,
        0.882071
    ],
    [
        0.17308,
        0.301207
    ],
    [
        -0.120452,
        0.867216
    ],
    [
        0.371096,
        0.916454
    ],
    [
        -0.178381,
        0.146101
    ],
    [
        -0.276489,
        0.550525
    ],
    [
        0.12542,
        0.126643
    ],
    [
        -0.296654,
        0.286879
    ],
    [
        0.261744,
        -0.00604975
    ],
    [
        -0.213417,
        0.715776
    ],
    [
        0.425684,
        -0.153211
    ],
    [
        -0.480054,
        0.321357
    ],
    [
        -0.0717878,
        -0.0250567
    ],
    [
        -0.328775,
        -0.169666
    ],
    [
        -0.394923,
        0.130802
    ],
    [
        -0.553681,
        -0.176777
    ],
    [
        -0.722615,
        0.120616
    ],
    [
        -0.693065,
        0.309017
    ],
    [
        0.603193,
        0.791471
    ],
    [
        -0.0754941,
        -0.297988
    ],
    [
        0.109303,
        -0.156472
    ],
    [
        0.260605,
        -0.280111
    ],
    [
        0.129731,
        -0.487954
    ],
    [
        -0.537315,
        0.520494
    ],
    [
        -0.42758,
        0.800607
    ],
    [
        0.77309,
        -0.0728102
    ],
    [
        0.908777,
        0.328356
    ],
    [
        0.985341,
        0.0759158
    ],
    [
        0.947536,
        -0.11837
    ],
    [
        -0.103315,
        -0.610747
    ],
    [
        0.337171,
        -0.584
    ],
    [
        0.210919,
        -0.720055
    ],
    [
        0.41894,
        -0.36769
    ],
    [
        -0.254228,
        -0.49368
    ],
    [
        -0.428562,
        -0.404037
    ],
    [
        -0.831732,
        -0.189615
    ],
    [
        -0.922642,
        0.0888026
    ],
    [
        -0.865914,
        0.427795
    ],
    [
        0.706117,
        -0.311662
    ],
    [
        0.545465,
        -0.520942
    ],
    [
        -0.695738,
        0.664492
    ],
    [
        0.389421,
        -0.899007
    ],
    [
        0.48842,
        -0.708054
    ],
    [
        0.760298,
        -0.62735
    ],
    [
        -0.390788,
        -0.707388
    ],
    [
        -0.591046,
        -0.686721
    ],
    [
        -0.769903,
        -0.413775
    ],
    [
        -0.604457,
        -0.502571
    ],
    [
        -0.557234,
        0.00451362
    ],
    [
        0.147572,
        -0.924353
    ],
    [
        -0.0662488,
        -0.892081
    ],
    [
        0.863832,
        -0.4072
    ]
];
function getShadowMapTexelSize(scope) {
    return scope.$builder.div(1, ShaderHelper.getShadowCameraParams(scope).z);
}
function getShadowMapSize(scope) {
    return ShaderHelper.getShadowCameraParams(scope).z;
}
/** @internal */ function computeShadowMapDepth(scope, worldPos, targetFormat) {
    const funcNameComputeShadowMapDepth = 'Z_computeShadowMapDepth';
    const pb = scope.$builder;
    pb.func(funcNameComputeShadowMapDepth, [
        pb.vec3('worldPos')
    ], function() {
        if (hasDepthChannel(targetFormat)) {
            // use native shadowmap
            this.$return(pb.vec4(pb.emulateDepthClamp ? pb.clamp(scope.$inputs.clamppedDepth, 0, 1) : scope.$builtins.fragCoord.z, 0, 0, 1));
        } else {
            this.$l.depth = pb.float();
            this.$l.lightType = ShaderHelper.getLightTypeForShadow(this);
            this.$if(pb.equal(this.lightType, LIGHT_TYPE_DIRECTIONAL), function() {
                this.depth = pb.emulateDepthClamp ? pb.clamp(this.$inputs.clamppedDepth, 0, 1) : this.$builtins.fragCoord.z;
            }).$elseif(pb.equal(this.lightType, LIGHT_TYPE_POINT), function() {
                this.$l.lightSpacePos = pb.mul(ShaderHelper.getLightViewMatrixForShadow(this), pb.vec4(this.worldPos, 1));
                this.depth = pb.clamp(pb.div(pb.length(this.lightSpacePos.xyz), ShaderHelper.getLightPositionAndRangeForShadow(this).w), 0, 1);
            }).$else(function() {
                this.$l.lightSpacePos = pb.mul(ShaderHelper.getLightViewMatrixForShadow(this), pb.vec4(this.worldPos, 1));
                this.depth = pb.clamp(pb.div(pb.neg(this.lightSpacePos.z), ShaderHelper.getLightPositionAndRangeForShadow(this).w), 0, 1);
            });
            this.$return(targetFormat === 'rgba8unorm' ? encodeNormalizedFloatToRGBA(this, this.depth) : pb.vec4(this.depth, 0, 0, 1));
        }
    });
    return pb.getGlobalScope()[funcNameComputeShadowMapDepth](worldPos);
}
/** @internal */ function computeReceiverPlaneDepthBias(scope, texCoord) {
    const funcNameComputeReceiverPlaneDepthBias = 'lib_computeReceiverPlaneDepthBias';
    const pb = scope.$builder;
    pb.func(funcNameComputeReceiverPlaneDepthBias, [
        pb.vec4('coords')
    ], function() {
        this.$l.dx = pb.dpdx(this.coords);
        this.$l.dy = pb.dpdy(this.coords);
        this.$l.biasMultiply = pb.float(1);
        this.$l.uv = pb.vec2(pb.sub(pb.mul(this.dy.y, this.dx.z), pb.mul(this.dx.y, this.dy.z)), pb.sub(pb.mul(this.dx.x, this.dy.z), pb.mul(this.dy.x, this.dx.z)));
        this.$l.uv = pb.mul(this.$l.uv, pb.div(this.biasMultiply, pb.sub(pb.mul(this.dx.x, this.dy.y), pb.mul(this.dx.y, this.dy.x))));
        // from unity shader
        this.$l.minFractionalError = pb.float(0.01);
        this.$l.fractionalSamplingError = pb.dot(pb.vec2(getShadowMapTexelSize(this)), pb.abs(this.$l.uv));
        this.$l.staticBias = pb.min(this.$l.fractionalSamplingError, this.$l.minFractionalError);
        // return
        this.$return(pb.vec3(this.$l.uv, this.$l.staticBias));
    });
    return pb.getGlobalScope()[funcNameComputeReceiverPlaneDepthBias](texCoord);
}
// reference: github.com/google/filament
function interleavedGradientNoise(scope, c) {
    const pb = scope.$builder;
    const x = 0.06711056;
    const y = 0.00583715;
    const z = 52.9829189;
    return pb.fract(pb.mul(z, pb.fract(pb.dot(c, pb.vec2(x, y)))));
}
// reference: github.com/google/filament
function getRandomRotationMatrix(scope, fragCoord) {
    const funcNameGetRandomRotationMatrix = 'lib_getRandomRotationMatrix';
    const pb = scope.$builder;
    pb.func(funcNameGetRandomRotationMatrix, [
        pb.vec2('fragCoord')
    ], function() {
        this.$l.randomAngle = pb.mul(interleavedGradientNoise(this, fragCoord), 2 * Math.PI);
        this.$l.randomBase = pb.vec2(pb.cos(this.randomAngle), pb.sin(this.randomAngle));
        this.$return(pb.mat2(this.randomBase.x, this.randomBase.y, pb.neg(this.randomBase.y), this.randomBase.x));
    });
    return pb.getGlobalScope()[funcNameGetRandomRotationMatrix](fragCoord);
}
function getPoissonDiscSampleRadius(scope) {
    return ShaderHelper.getDepthBiasValues(scope).z;
}
function sampleShadowMapPCF(scope, shadowMapFormat, pos, offset, depth, cascade) {
    const funcName = cascade ? 'lib_sampleShadowMapCascadePCF' : 'lib_sampleShadowMapPCF';
    const pb = scope.$builder;
    const nativeShadowMap = hasDepthChannel(shadowMapFormat);
    pb.func(funcName, [
        pb.vec2('coords'),
        pb.float('z'),
        pb.vec2('offset'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        const sampleDepth = this.z;
        const uv = pb.add(this.coords, this.offset);
        if (nativeShadowMap) {
            this.$return(cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), uv, this.cascade, sampleDepth) : pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), uv, sampleDepth));
        } else {
            this.$l.shadowTex = cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), uv, this.cascade, 0) : pb.textureSampleLevel(ShaderHelper.getShadowMap(this), uv, 0);
            if (shadowMapFormat === 'rgba8unorm') {
                this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
            }
            this.$return(pb.step(sampleDepth, this.shadowTex.x));
        }
    });
    return pb.getGlobalScope()[funcName](pos, depth, offset, ...cascade ? [
        cascade
    ] : []);
}
function sampleShadowMap(scope, lightType, shadowMapFormat, pos, depth, cascade) {
    const funcNameSampleShadowMap = 'lib_sampleShadowMap';
    const pb = scope.$builder;
    const nativeShadowMap = hasDepthChannel(shadowMapFormat);
    pb.func(funcNameSampleShadowMap, [
        lightType === LIGHT_TYPE_POINT ? pb.vec3('coords') : pb.vec2('coords'),
        pb.float('z'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        if (lightType === LIGHT_TYPE_POINT) {
            if (nativeShadowMap) {
                this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, this.z), 0, 1));
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (shadowMapFormat === 'rgba8unorm') {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.z, this.shadowTex.x));
            }
        } else {
            if (nativeShadowMap) {
                this.$return(cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, this.cascade, this.z) : pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, this.z));
            } else {
                this.$l.shadowTex = cascade && Application.instance.device.type !== 'webgl' ? pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.coords, this.cascade, 0) : pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (shadowMapFormat === 'rgba8unorm') {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.z, this.shadowTex.x));
            }
        }
    });
    return cascade ? pb.getGlobalScope()[funcNameSampleShadowMap](pos, depth, cascade) : pb.getGlobalScope()[funcNameSampleShadowMap](pos, depth);
}
function chebyshevUpperBound(scope, distance, occluder) {
    const funcNameChebyshevUpperBound = 'lib_chebyshevUpperBound';
    const pb = scope.$builder;
    pb.func(funcNameChebyshevUpperBound, [
        pb.float('distance'),
        pb.vec2('occluder')
    ], function() {
        this.$l.shadow = pb.float(1);
        this.$l.test = pb.step(this.distance, this.occluder.x);
        this.$if(pb.notEqual(this.test, 1), function() {
            this.$l.d = pb.sub(this.distance, this.occluder.x);
            this.$l.variance = pb.max(pb.mul(this.occluder.y, this.occluder.y), 0);
            const darkness = ShaderHelper.getDepthBiasValues(this).z;
            this.shadow = pb.div(this.variance, pb.add(this.variance, pb.mul(this.d, this.d)));
            this.shadow = pb.clamp(pb.div(pb.sub(this.shadow, darkness), pb.sub(1, darkness)), 0, 1);
        });
        this.$return(this.shadow);
    });
    return pb.getGlobalScope()[funcNameChebyshevUpperBound](distance, occluder);
}
/** @internal */ function filterShadowVSM(scope, lightType, shadowMapFormat, texCoord, cascade) {
    const funcNameFilterShadowVSM = 'lib_filterShadowVSM';
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowVSM, [
        pb.vec4('texCoord'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        if (lightType === LIGHT_TYPE_POINT) {
            this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.texCoord.xyz, 0);
            this.$return(chebyshevUpperBound(this, this.texCoord.w, shadowMapFormat === 'rgba8unorm' ? decode2HalfFromRGBA(this, this.shadowTex) : this.shadowTex.rg));
        } else {
            if (Application.instance.device.type !== 'webgl' && cascade) {
                this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.texCoord.xy, this.cascade, 0);
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.texCoord.xy, 0);
            }
            this.$return(chebyshevUpperBound(this, this.texCoord.z, shadowMapFormat === 'rgba8unorm' ? decode2HalfFromRGBA(this, this.shadowTex) : this.shadowTex.rg));
        }
    });
    return pb.getGlobalScope()[funcNameFilterShadowVSM](texCoord, ...cascade ? [
        cascade
    ] : []);
}
/** @internal */ function filterShadowESM(scope, lightType, shadowMapFormat, shadowVertex, cascade) {
    const funcNameFilterShadowESM = 'lib_filterShadowESM';
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowESM, [
        lightType === LIGHT_TYPE_POINT ? pb.vec3('shadowVertex') : pb.vec4('shadowVertex'),
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        if (lightType === LIGHT_TYPE_POINT) {
            this.$l.depth = pb.div(pb.length(this.shadowVertex.xyz), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
            this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowVertex.xyz, 0);
            if (shadowMapFormat === 'rgba8unorm') {
                this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
            }
        } else {
            if (cascade && Application.instance.device.type !== 'webgl') {
                this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.shadowVertex.xy, this.cascade, 0);
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowVertex.xy, 0);
            }
            if (shadowMapFormat === 'rgba8unorm') {
                this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
            }
            if (lightType === LIGHT_TYPE_SPOT) {
                this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                this.$l.depth = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.shadowVertex.z, this.nearFar);
            } else {
                this.$l.depth = this.shadowVertex.z;
            }
        }
        const depthScale = ShaderHelper.getDepthBiasValues(this).z;
        this.$return(pb.clamp(pb.exp(pb.min(87, pb.mul(depthScale, pb.sub(this.shadowTex.x, this.depth)))), 0, 1));
    });
    return pb.getGlobalScope()[funcNameFilterShadowESM](shadowVertex, ...cascade ? [
        cascade
    ] : []);
}
/** @internal */ function filterShadowPCF(scope, lightType, shadowMapFormat, kernelSize, texCoord, receiverPlaneDepthBias, cascade) {
    const funcNameFilterShadowPCF = `lib_filterShadowPCF${kernelSize}x${kernelSize}`;
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowPCF, [
        pb.vec4('texCoord'),
        ...receiverPlaneDepthBias ? [
            pb.vec3('receiverPlaneDepthBias')
        ] : [],
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        this.$l.lightDepth = this.texCoord.z;
        if (receiverPlaneDepthBias) {
            this.lightDepth = pb.sub(this.lightDepth, this.receiverPlaneDepthBias.z);
        }
        const shadowMapTexelSize = getShadowMapTexelSize(this);
        this.$l.uv = pb.add(pb.mul(this.texCoord.xy, pb.vec2(getShadowMapSize(this))), pb.vec2(0));
        this.$l.st = pb.fract(this.uv);
        this.$l.baseUV = pb.sub(pb.floor(this.uv), pb.vec2(0.5));
        this.baseUV = pb.mul(this.baseUV, shadowMapTexelSize);
        this.$l.shadow = pb.float(0);
        if (kernelSize === 3) {
            this.$l.uvw0 = pb.sub(pb.vec2(3), pb.mul(2, this.st));
            this.$l.uvw1 = pb.add(pb.vec2(1), pb.mul(2, this.st));
            this.$l.u = pb.mul(pb.vec2(pb.sub(pb.div(pb.sub(2, this.st.x), this.uvw0.x), 1), pb.add(pb.div(this.st.x, this.uvw1.x), 1)), shadowMapTexelSize);
            this.$l.v = pb.mul(pb.vec2(pb.sub(pb.div(pb.sub(2, this.st.y), this.uvw0.y), 1), pb.add(pb.div(this.st.y, this.uvw1.y), 1)), shadowMapTexelSize);
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.x), this.lightDepth, this.cascade), this.uvw0.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.x), this.lightDepth, this.cascade), this.uvw1.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.y), this.lightDepth, this.cascade), this.uvw0.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.y), this.lightDepth, this.cascade), this.uvw1.x, this.uvw1.y));
            this.shadow = pb.div(this.shadow, 16);
        } else if (kernelSize === 5) {
            this.$l.uvw0 = pb.sub(pb.vec2(4), pb.mul(this.st, 3));
            this.$l.uvw1 = pb.vec2(7);
            this.$l.uvw2 = pb.add(pb.vec2(1), pb.mul(this.st, 3));
            this.$l.u = pb.mul(pb.vec3(pb.sub(pb.div(pb.sub(3, pb.mul(this.st.x, 2)), this.uvw0.x), 2), pb.div(pb.add(this.st.x, 3), this.uvw1.x), pb.add(pb.div(this.st.x, this.uvw2.x), 2)), shadowMapTexelSize);
            this.$l.v = pb.mul(pb.vec3(pb.sub(pb.div(pb.sub(3, pb.mul(this.st.y, 2)), this.uvw0.y), 2), pb.div(pb.add(this.st.y, 3), this.uvw1.y), pb.add(pb.div(this.st.y, this.uvw2.y), 2)), shadowMapTexelSize);
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.x), this.lightDepth, this.cascade), this.uvw0.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.x), this.lightDepth, this.cascade), this.uvw1.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.z, this.v.x), this.lightDepth, this.cascade), this.uvw2.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.y), this.lightDepth, this.cascade), this.uvw0.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.y), this.lightDepth, this.cascade), this.uvw1.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.z, this.v.y), this.lightDepth, this.cascade), this.uvw2.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.x, this.v.z), this.lightDepth, this.cascade), this.uvw0.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.y, this.v.z), this.lightDepth, this.cascade), this.uvw1.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.vec2(this.u.z, this.v.z), this.lightDepth, this.cascade), this.uvw2.x, this.uvw2.y));
            this.shadow = pb.div(this.shadow, 144);
        } else if (kernelSize === 7) {
            this.$l.uvw0 = pb.sub(pb.mul(this.st, 5), pb.vec2(6));
            this.$l.uvw1 = pb.sub(pb.mul(this.st, 11), pb.vec2(28));
            this.$l.uvw2 = pb.sub(pb.mul(this.st, -11), pb.vec2(17));
            this.$l.uvw3 = pb.sub(pb.mul(this.st, -5), 1);
            this.$l.u = pb.vec4(pb.sub(pb.div(pb.sub(pb.mul(this.st.x, 4), 5), this.uvw0.x), 3), pb.sub(pb.div(pb.sub(pb.mul(this.st.x, 4), 16), this.uvw1.x), 1), pb.add(pb.div(pb.sub(pb.mul(this.st.x, -7), 5), this.uvw2.x), 1), pb.add(pb.div(pb.neg(this.st.x), this.uvw3.x), 3));
            this.$l.v = pb.vec4(pb.sub(pb.div(pb.sub(pb.mul(this.st.y, 4), 5), this.uvw0.y), 3), pb.sub(pb.div(pb.sub(pb.mul(this.st.y, 4), 16), this.uvw1.y), 1), pb.add(pb.div(pb.sub(pb.mul(this.st.y, -7), 5), this.uvw2.y), 1), pb.add(pb.div(pb.neg(this.st.y), this.uvw3.y), 3));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.x), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw0.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.y), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw1.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.z), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw2.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.x, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw0.x, this.uvw3.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.y, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw1.x, this.uvw3.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.z, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw2.x, this.uvw3.y));
            this.shadow = pb.add(this.shadow, pb.mul(sampleShadowMapPCF(this, shadowMapFormat, this.baseUV, pb.mul(pb.vec2(this.u.w, this.v.w), shadowMapTexelSize), this.lightDepth, this.cascade), this.uvw3.x, this.uvw3.y));
            this.shadow = pb.div(this.shadow, 2704);
        }
        this.$return(this.shadow);
    });
    return pb.getGlobalScope()[funcNameFilterShadowPCF](texCoord, ...receiverPlaneDepthBias ? [
        receiverPlaneDepthBias
    ] : [], ...cascade ? [
        cascade
    ] : []);
}
/** @internal */ function filterShadowPoissonDisc(scope, lightType, shadowMapFormat, tapCount, texCoord, receiverPlaneDepthBias, cascade) {
    const funcNameFilterShadowPoissonDisc = 'lib_filterShadowPoissonDisc';
    const pb = scope.$builder;
    pb.func(funcNameFilterShadowPoissonDisc, [
        pb.vec4('texCoord'),
        ...receiverPlaneDepthBias ? [
            pb.vec3('receiverPlaneDepthBias')
        ] : [],
        ...cascade ? [
            pb.int('cascade')
        ] : []
    ], function() {
        this.$l.lightDepth = this.texCoord.z;
        if (receiverPlaneDepthBias) {
            this.lightDepth = pb.sub(this.lightDepth, this.receiverPlaneDepthBias.z);
        }
        this.$l.duv = pb.vec2();
        this.$l.filterRadius = pb.mul(getShadowMapTexelSize(this), getPoissonDiscSampleRadius(this));
        this.$l.matrix = getRandomRotationMatrix(this, this.$builtins.fragCoord.xy);
        this.$l.shadow = pb.float(0);
        for(let i = 0; i < tapCount; i++){
            this.duv = pb.mul(this.matrix, pb.mul(pb.vec2(PCF_POISSON_DISC[i][0], PCF_POISSON_DISC[i][1]), this.filterRadius));
            const sampleDepth = receiverPlaneDepthBias ? pb.add(this.lightDepth, pb.dot(this.duv, this.receiverPlaneDepthBias.xy)) : this.lightDepth;
            this.shadow = pb.add(this.shadow, sampleShadowMap(this, lightType, shadowMapFormat, pb.add(this.texCoord.xy, this.duv), sampleDepth, this.cascade));
        }
        this.shadow = pb.div(this.shadow, tapCount);
        this.$return(this.shadow);
    });
    return pb.getGlobalScope()[funcNameFilterShadowPoissonDisc](texCoord, ...receiverPlaneDepthBias ? [
        receiverPlaneDepthBias
    ] : [], ...cascade ? [
        cascade
    ] : []);
}

/** @internal */ class SSM extends ShadowImpl {
    static instance = new SSM();
    constructor(){
        super();
    }
    resourceDirty() {
        return false;
    }
    getType() {
        return 'hard';
    }
    getShadowMapBorder(shadowMapParams) {
        return 0;
    }
    getShadowMap(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? shadowMapParams.shadowMapFramebuffer.getDepthAttachment() : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(this.useNativeShadowMap(shadowMapParams)) || null;
    }
    postRenderShadowMap() {}
    releaseTemporalResources(shadowMapParams) {}
    getDepthScale() {
        return 1;
    }
    setDepthScale(val) {}
    getShaderHash() {
        return '';
    }
    getShadowMapColorFormat(shadowMapParams) {
        if (this.useNativeShadowMap(shadowMapParams)) {
            return null;
        } else {
            const device = Application.instance.device;
            if (device.type === 'webgl') {
                return device.getDeviceCaps().textureCaps.supportFloatColorBuffer ? 'rgba32f' : device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? 'rgba16f' : 'rgba8unorm';
            } else {
                return 'r32f';
            }
        }
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return Application.instance.device.type === 'webgl' ? 'd24s8' : 'd32f';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            this.$l.shadowCoord = pb.div(this.shadowVertex.xyz, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord.xyz, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    if (shadowMapParams.shadowMap.isTexture2DArray()) {
                        this.shadow = pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.split, this.shadowCoord.z);
                    } else {
                        this.shadow = pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.shadowCoord.z);
                    }
                } else {
                    if (shadowMapParams.shadowMap.isTexture2DArray()) {
                        this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.split, 0);
                    } else {
                        this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, 0);
                    }
                    if (!floatDepthTexture) {
                        this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                    }
                    this.shadow = pb.step(this.shadowCoord.z, this.shadowTex.x);
                }
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                    this.$l.maxZ = pb.max(pb.max(pb.abs(this.dir.x), pb.abs(this.dir.y)), pb.abs(this.dir.z));
                    this.$l.distance = ShaderHelper.linearDepthToNonLinear(this, this.maxZ, this.nearFar);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, pb.div(this.maxZ, ShaderHelper.getLightPositionAndRangeForShadow(this).w), this.NdotL, true);
                    this.$return(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.dir, pb.sub(this.distance, this.shadowBias)));
                } else {
                    this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                    this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.dir, 0);
                    if (!floatDepthTexture) {
                        this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                    }
                    this.distance = pb.sub(this.distance, this.shadowBias);
                    this.$return(pb.step(this.distance, this.shadowTex.x));
                }
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex.xyz, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord.xyz, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$if(this.inShadow, function() {
                    if (that.useNativeShadowMap(shadowMapParams)) {
                        this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                        this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                        this.shadow = pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, this.shadowCoord.z);
                    } else {
                        if (shadowMapParams.lightType === LIGHT_TYPE_SPOT) {
                            this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                            this.shadowCoord.z = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.shadowCoord.z, this.nearFar);
                            this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, true);
                        } else {
                            this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                        }
                        this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                        this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.shadowCoord.xy, 0);
                        if (!floatDepthTexture) {
                            this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                        }
                        this.shadow = pb.step(this.shadowCoord.z, this.shadowTex.x);
                    }
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return Application.instance.device.type !== 'webgl';
    }
}

/**
 * Gaussian blur blitter
 * @public
 */ class GaussianBlurBlitter extends Blitter {
    /** @internal */ _phase;
    /** @internal */ _kernelSize;
    /** @internal */ _sigma;
    /** @internal */ _blurSize;
    /** @internal */ _logSpace;
    /** @internal */ _logSpaceMultiplier;
    /** @internal */ _depthTex;
    /** @internal */ _depthCutoff;
    /**
   * Creates an instance of GaussianBlurBlitter
   * @param phase - Blitter phase
   * @param kernalSize - kernel size
   * @param sigma - Gaussian standard deviation
   * @param blurSize - Blur radius
   */ constructor(phase, kernalSize, sigma, blurSize){
        super();
        this._phase = phase;
        this._kernelSize = kernalSize;
        this._sigma = sigma;
        this._blurSize = blurSize;
        this._logSpace = false;
        this._logSpaceMultiplier = 1;
        this._depthTex = null;
        this._depthCutoff = 0.7;
    }
    /** Blur radius */ get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    /** Kernel size */ get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        if (this._kernelSize !== val) {
            this._kernelSize = val;
            this.invalidateHash();
        }
    }
    /** true if the box filter will be applied in logarithmic space */ get logSpace() {
        return this._logSpace;
    }
    set logSpace(val) {
        if (this._logSpace !== !!val) {
            this._logSpace = !!val;
            this.invalidateHash();
        }
    }
    /** Multiplier for logarithmic space blur */ get logSpaceMultiplier() {
        return this._logSpaceMultiplier;
    }
    set logSpaceMultiplier(val) {
        this._logSpaceMultiplier = val;
    }
    /** Linear depth texture */ get depthTexture() {
        return this._depthTex;
    }
    set depthTexture(tex) {
        if (this._depthTex !== tex) {
            if (!tex || !this._depthTex) {
                this.invalidateHash();
            }
            this._depthTex = tex;
        }
    }
    /** Depth cutoff */ get depthCutoff() {
        return this._depthCutoff;
    }
    set depthCutoff(val) {
        this._depthCutoff = val;
    }
    /**
   * {@inheritDoc Blitter.setup}
   * @override
   */ setup(scope, type) {
        const pb = scope.$builder;
        if (pb.shaderKind === 'fragment') {
            if (this._depthTex) {
                scope.depthTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                scope.depthCutoff = pb.float().uniform(0);
            }
            scope.sigma = pb.float().uniform(0);
            scope.blurSize = pb.float().uniform(0);
            if (this._logSpace && this._phase === 'horizonal') {
                scope.multiplier = pb.float().uniform(0);
            }
            if (this._phase !== 'horizonal' && this._phase !== 'vertical') {
                throw new Error(`GaussianBlurFilter.setupFilter() failed: invalid phase: ${this._phase}`);
            }
            if (!Number.isInteger(this._kernelSize) || this._kernelSize < 0 || (this._kernelSize & 1) === 0) {
                throw new Error(`GaussianBlurFilter.setupFilter() failed: invalid kernel size: ${this._kernelSize}`);
            }
            scope.blurMultiplyVec = type === 'cube' ? this._phase === 'horizonal' ? pb.vec3(1, 0, 0) : pb.vec3(0, 1, 0) : this._phase === 'horizonal' ? pb.vec2(1, 0) : pb.vec2(0, 1);
            scope.numBlurPixelsPerSide = pb.float((this._kernelSize + 1) / 2);
        }
    }
    /**
   * {@inheritDoc Blitter.setUniforms}
   * @override
   */ setUniforms(bindGroup) {
        bindGroup.setValue('sigma', this._sigma);
        bindGroup.setValue('blurSize', this._blurSize);
        if (this._logSpace && this._phase === 'horizonal') {
            bindGroup.setValue('multiplier', this._logSpaceMultiplier);
        }
        if (this._depthTex) {
            bindGroup.setTexture('depthTex', this._depthTex);
            bindGroup.setValue('depthCutoff', this._depthCutoff);
        }
    }
    /**
   * {@inheritDoc Blitter.filter}
   * @override
   */ filter(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const that = this;
        const pb = scope.$builder;
        if (that._depthTex) {
            pb.func('getLinearDepth', [
                pb.vec2('uv')
            ], function() {
                this.$l.depthValue = pb.textureSample(this.depthTex, this.uv);
                if (pb.getDevice().type === 'webgl') {
                    this.$return(decodeNormalizedFloatFromRGBA(this, this.depthValue));
                } else {
                    this.$return(this.depthValue.r);
                }
            });
        }
        scope.incrementalGaussian = pb.vec3();
        scope.incrementalGaussian.x = pb.div(1, pb.mul(scope.sigma, Math.sqrt(2 * Math.PI)));
        scope.incrementalGaussian.y = pb.exp(pb.div(-0.5, pb.mul(scope.sigma, scope.sigma)));
        scope.incrementalGaussian.z = pb.mul(scope.incrementalGaussian.y, scope.incrementalGaussian.y);
        scope.coefficientSum = pb.float(0);
        scope.minExpValue = pb.vec4(87, 87, 87, 87);
        scope.d0 = that.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        if (that._logSpace) {
            scope.avgValue = pb.vec4(scope.incrementalGaussian.x);
        } else {
            scope.avgValue = pb.mul(that.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType), scope.incrementalGaussian.x);
        }
        if (that._depthTex) {
            scope.centerDepth = scope.getLinearDepth(srcUV);
        }
        scope.coefficientSum = pb.add(scope.coefficientSum, scope.incrementalGaussian.x);
        scope.incrementalGaussian = pb.vec3(pb.mul(scope.incrementalGaussian.xy, scope.incrementalGaussian.yz), scope.incrementalGaussian.z);
        scope.$for(pb.float('i'), 1, scope.numBlurPixelsPerSide, function() {
            this.$l.uv1 = pb.sub(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i));
            this.$l.d1 = pb.vec4();
            if (that._depthTex) {
                this.$l.depth1 = this.getLinearDepth(this.uv1);
                this.$l.test1 = pb.lessThan(pb.abs(pb.sub(this.depth1, this.centerDepth)), this.depthCutoff);
            } else {
                this.$l.test1 = true;
            }
            this.$if(this.test1, function() {
                this.d1 = that.readTexel(scope, type, srcTex, this.uv1, srcLayer, sampleType);
            });
            this.$l.uv2 = pb.add(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), this.$l.d2 = pb.vec4();
            if (that._depthTex) {
                this.$l.depth2 = this.getLinearDepth(this.uv2);
                this.$l.test2 = pb.lessThan(pb.abs(pb.sub(this.depth2, this.centerDepth)), this.depthCutoff);
            } else {
                this.$l.test2 = true;
            }
            this.$if(this.test2, function() {
                this.d2 = that.readTexel(scope, type, srcTex, pb.add(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), srcLayer, sampleType);
            });
            if (that._logSpace) {
                if (that._phase === 'horizonal') {
                    this.$if(this.test1, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.mul(pb.sub(this.d1, this.d0), this.multiplier))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                    this.$if(this.test2, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.mul(pb.sub(this.d2, this.d0), this.multiplier))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                } else {
                    this.$if(this.test1, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.sub(this.d1, this.d0))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                    this.$if(this.test2, function() {
                        this.avgValue = pb.add(this.avgValue, pb.mul(pb.exp(pb.min(this.minExpValue, pb.sub(this.d2, this.d0))), this.incrementalGaussian.x));
                        this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                    });
                }
            } else {
                this.$if(this.test1, function() {
                    this.avgValue = pb.add(this.avgValue, pb.mul(this.d1, this.incrementalGaussian.x));
                    this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                });
                this.$if(this.test2, function() {
                    this.avgValue = pb.add(this.avgValue, pb.mul(this.d2, this.incrementalGaussian.x));
                    this.coefficientSum = pb.add(this.coefficientSum, this.incrementalGaussian.x);
                });
            }
            this.incrementalGaussian = pb.vec3(pb.mul(this.incrementalGaussian.xy, this.incrementalGaussian.yz), this.incrementalGaussian.z);
        });
        scope.$l.outColor = pb.div(scope.avgValue, scope.coefficientSum);
        if (that._logSpace) {
            if (that._phase === 'horizonal') {
                scope.outColor = pb.add(pb.mul(scope.multiplier, scope.d0), pb.log(scope.outColor));
            } else {
                scope.outColor = pb.add(scope.d0, pb.log(scope.outColor));
            }
        }
        return scope.outColor;
    }
    /**
   * {@inheritDoc Blitter.calcHash}
   * @override
   */ calcHash() {
        return `${this._depthTex ? 1 : 0}-${this._phase}-${this._kernelSize}-${Number(!!this._logSpace)}`;
    }
}

class BlurBlitter extends GaussianBlurBlitter {
    _packFloat;
    get packFloat() {
        return this._packFloat;
    }
    set packFloat(b) {
        if (this._packFloat !== !!b) {
            this._packFloat = !!b;
            this.invalidateHash();
        }
    }
    readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const pb = scope.$builder;
        const texel = super.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        if (this.packFloat) {
            return pb.vec4(decodeNormalizedFloatFromRGBA(scope, texel), 0, 0, 1);
        } else {
            return texel;
        }
    }
    writeTexel(scope, type, srcUV, texel) {
        const outTexel = super.writeTexel(scope, type, srcUV, texel);
        if (this.packFloat) {
            return encodeNormalizedFloatToRGBA(scope, outTexel.r);
        } else {
            return outTexel;
        }
    }
    calcHash() {
        return `${super.calcHash()}-${Number(this.packFloat)}`;
    }
}
/** @internal */ class ESM extends ShadowImpl {
    /** @internal */ _depthScale;
    /** @internal */ _blur;
    /** @internal */ _kernelSize;
    /** @internal */ _blurSize;
    /** @internal */ _logSpace;
    /** @internal */ _blitterH;
    /** @internal */ _blitterV;
    /** @internal */ _mipmap;
    constructor(kernelSize, blurSize, depthScale){
        super();
        this._blur = true;
        this._depthScale = depthScale ?? 500;
        this._kernelSize = kernelSize ?? 5;
        this._blurSize = blurSize ?? 1;
        this._logSpace = true;
        this._mipmap = true;
        this._blitterH = new BlurBlitter('horizonal', this._kernelSize, 4, 1 / 1024);
        this._blitterV = new BlurBlitter('vertical', this._kernelSize, 4, 1 / 1024);
    }
    resourceDirty() {
        return this._resourceDirty;
    }
    get blur() {
        return this._blur;
    }
    set blur(val) {
        if (this._blur !== !!val) {
            this._blur = !!val;
            this._resourceDirty = true;
        }
    }
    get mipmap() {
        return this._mipmap;
    }
    set mipmap(b) {
        if (this._mipmap !== !!b) {
            this._mipmap = !!b;
            if (this._blur) {
                this._resourceDirty = true;
            }
        }
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        this._kernelSize = val;
    }
    get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    get logSpace() {
        return this._logSpace;
    }
    set logSpace(val) {
        this._logSpace = !!val;
    }
    getType() {
        return 'esm';
    }
    getShadowMapBorder(shadowMapParams) {
        return this._blur ? Math.ceil((this._kernelSize + 1) / 2 * this._blurSize) : 0;
    }
    getShadowMap(shadowMapParams) {
        const implData = shadowMapParams.implData;
        return implData ? implData.blurFramebuffer2.getColorAttachments()[0] : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        const implData = {
            blurFramebuffer: null,
            blurFramebuffer2: null
        };
        shadowMapParams.implData = implData;
        const colorFormat = this.getShadowMapColorFormat(shadowMapParams);
        const target = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].target;
        const shadowMapWidth = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].width;
        const shadowMapHeight = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].height;
        if (this._blur) {
            shadowMapParams.implData = {
                blurFramebuffer: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, false),
                blurFramebuffer2: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, this._mipmap)
            };
        }
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(false) ?? null;
    }
    postRenderShadowMap(shadowMapParams) {
        if (shadowMapParams.implData) {
            const implData = shadowMapParams.implData;
            const colorAttachment = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
            this._blitterH.blurSize = this._blurSize / colorAttachment.width;
            this._blitterH.kernelSize = this._kernelSize;
            this._blitterH.logSpace = this._logSpace;
            this._blitterH.packFloat = colorAttachment.format === 'rgba8unorm';
            this._blitterV.blurSize = this._blurSize / colorAttachment.height;
            this._blitterV.kernelSize = this._kernelSize;
            this._blitterV.logSpace = this._logSpace;
            this._blitterV.packFloat = colorAttachment.format === 'rgba8unorm';
            this._blitterH.blit(colorAttachment, implData.blurFramebuffer);
            this._blitterV.blit(implData.blurFramebuffer.getColorAttachments()[0], implData.blurFramebuffer2);
        }
    }
    releaseTemporalResources(shadowMapParams) {
        const implData = shadowMapParams.implData;
        if (implData) {
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer);
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer2);
        }
    }
    getDepthScale() {
        return this._depthScale;
    }
    setDepthScale(val) {
        this._depthScale = val;
    }
    getShaderHash() {
        return '';
    }
    getShadowMapColorFormat(shadowMapParams) {
        const device = Application.instance.device;
        return device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? device.type === 'webgl' ? 'rgba16f' : 'r16f' : device.getDeviceCaps().textureCaps.supportFloatColorBuffer ? device.type === 'webgl' ? 'rgba32f' : 'r32f' : 'rgba8unorm';
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return 'd24s8';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$if(this.inShadow, function() {
                this.shadow = filterShadowESM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                this.$return(filterShadowESM(this, LIGHT_TYPE_POINT, shadowMapParams.shadowMap.format, this.dir));
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$if(this.inShadow, function() {
                    this.shadow = filterShadowESM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return false;
    }
}

class VSMBlitter extends Blitter {
    _phase;
    _packFloat;
    _blurSize;
    _kernelSize;
    constructor(phase, kernelSize, blurSize, packFloat){
        super();
        this._phase = phase;
        this._blurSize = blurSize;
        this._kernelSize = kernelSize;
        this._packFloat = packFloat;
    }
    get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        if (val !== this._kernelSize) {
            this._kernelSize = val;
            this.invalidateHash();
        }
    }
    get packFloat() {
        return this._packFloat;
    }
    set packFloat(b) {
        if (this._packFloat !== !!b) {
            this._packFloat = !!b;
            this.invalidateHash();
        }
    }
    setup(scope, type) {
        const pb = scope.$builder;
        if (pb.shaderKind === 'fragment') {
            scope.blurSize = pb.float().uniform(0);
            scope.blurMultiplyVec = type === 'cube' ? this._phase === 'horizonal' ? pb.vec3(1, 0, 0) : pb.vec3(0, 1, 0) : this._phase === 'horizonal' ? pb.vec2(1, 0) : pb.vec2(0, 1);
            scope.numBlurPixelsPerSide = pb.float((this._kernelSize + 1) / 2);
            scope.weight = pb.float(1 / (this._kernelSize * this._kernelSize));
        }
    }
    setUniforms(bindGroup) {
        bindGroup.setValue('blurSize', this._blurSize);
    }
    readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const pb = scope.$builder;
        const texel = super.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        if (this._packFloat) {
            if (this._phase === 'horizonal') {
                return pb.vec4(decodeNormalizedFloatFromRGBA(scope, texel));
            } else {
                return pb.vec4(decode2HalfFromRGBA(scope, texel), 0, 0);
            }
        } else {
            return texel;
        }
    }
    writeTexel(scope, type, srcUV, texel) {
        const outTexel = super.writeTexel(scope, type, srcUV, texel);
        if (this._packFloat) {
            return encode2HalfToRGBA(scope, outTexel.x, outTexel.y);
        } else {
            return outTexel;
        }
    }
    filter(scope, type, srcTex, srcUV, srcLayer, sampleType) {
        const that = this;
        const pb = scope.$builder;
        scope.d0 = that.readTexel(scope, type, srcTex, srcUV, srcLayer, sampleType);
        scope.mean = pb.float(0);
        scope.squaredMean = pb.float(0);
        scope.$for(pb.float('i'), 1, scope.numBlurPixelsPerSide, function() {
            this.d1 = that.readTexel(this, type, srcTex, pb.sub(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), srcLayer, sampleType);
            this.d2 = that.readTexel(this, type, srcTex, pb.add(srcUV, pb.mul(this.blurMultiplyVec, this.blurSize, this.i)), srcLayer, sampleType);
            this.mean = pb.add(this.mean, this.d1.x);
            this.mean = pb.add(this.mean, this.d2.x);
            if (that._phase === 'horizonal') {
                this.squaredMean = pb.add(this.squaredMean, pb.mul(this.d1.x, this.d1.x));
                this.squaredMean = pb.add(this.squaredMean, pb.mul(this.d2.x, this.d2.x));
            } else {
                this.squaredMean = pb.add(this.squaredMean, pb.dot(this.d1.xy, this.d1.xy));
                this.squaredMean = pb.add(this.squaredMean, pb.dot(this.d2.xy, this.d2.xy));
            }
        });
        scope.mean = pb.div(scope.mean, that._kernelSize);
        scope.squaredMean = pb.div(scope.squaredMean, that._kernelSize);
        scope.stdDev = pb.sqrt(pb.max(0, pb.sub(scope.squaredMean, pb.mul(scope.mean, scope.mean))));
        return pb.vec4(scope.mean, scope.stdDev, 0, 1);
    }
    calcHash() {
        return `${this._phase}-${this._kernelSize}-${Number(this._packFloat)}`;
    }
}
/** @internal */ class VSM extends ShadowImpl {
    /** @internal */ _blur;
    /** @internal */ _kernelSize;
    /** @internal */ _blurSize;
    /** @internal */ _blitterH;
    /** @internal */ _blitterV;
    /** @internal */ _mipmap;
    /** @internal */ _darkness;
    constructor(kernelSize, blurSize, darkness){
        super();
        this._blur = true;
        this._kernelSize = kernelSize ?? 5;
        this._blurSize = blurSize ?? 1;
        this._darkness = darkness ?? 0;
        this._mipmap = true;
        this._blitterH = new VSMBlitter('horizonal', this._kernelSize, 1 / 1024, false);
        this._blitterV = new VSMBlitter('vertical', this._kernelSize, 1 / 1024, false);
    }
    resourceDirty() {
        return this._resourceDirty;
    }
    get blur() {
        return this._blur;
    }
    set blur(val) {
        if (this._blur !== !!val) {
            this._blur = !!val;
            this._resourceDirty = true;
        }
    }
    get mipmap() {
        return this._mipmap;
    }
    set mipmap(b) {
        if (this._mipmap !== !!b) {
            this._mipmap = !!b;
            if (this._blur) {
                this._resourceDirty = true;
            }
        }
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        this._kernelSize = val;
    }
    get blurSize() {
        return this._blurSize;
    }
    set blurSize(val) {
        this._blurSize = val;
    }
    getDepthScale() {
        return this._darkness;
    }
    setDepthScale(val) {
        this._darkness = val;
    }
    getType() {
        return 'vsm';
    }
    getShadowMapBorder(shadowMapParams) {
        return this._blur ? Math.ceil((this._kernelSize + 1) / 2 * this._blurSize) : 0;
    }
    getShadowMap(shadowMapParams) {
        const implData = shadowMapParams.implData;
        return implData ? implData.blurFramebuffer2.getColorAttachments()[0] : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        const colorFormat = this.getShadowMapColorFormat(shadowMapParams);
        const target = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].target;
        const shadowMapWidth = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].width;
        const shadowMapHeight = shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0].height;
        if (this._blur) {
            shadowMapParams.implData = {
                blurFramebuffer: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, false),
                blurFramebuffer2: TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, shadowMapParams.numShadowCascades, colorFormat, null, target, null, this._mipmap)
            };
        }
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(false) ?? null;
    }
    postRenderShadowMap(shadowMapParams) {
        if (this._blur) {
            const implData = shadowMapParams.implData;
            this._blitterH.blurSize = this._blurSize / shadowMapParams.shadowMap.width;
            this._blitterH.kernelSize = this._kernelSize;
            this._blitterH.packFloat = shadowMapParams.shadowMap.format === 'rgba8unorm';
            this._blitterV.blurSize = this._blurSize / shadowMapParams.shadowMap.height;
            this._blitterV.kernelSize = this._kernelSize;
            this._blitterV.packFloat = shadowMapParams.shadowMap.format === 'rgba8unorm';
            this._blitterH.blit(shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0], implData.blurFramebuffer);
            this._blitterV.blit(implData.blurFramebuffer.getColorAttachments()[0], implData.blurFramebuffer2);
        }
    }
    releaseTemporalResources(shadowMapParams) {
        const implData = shadowMapParams.implData;
        if (implData) {
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer);
            TemporalCache.releaseFramebuffer(implData.blurFramebuffer2);
        }
    }
    getShaderHash() {
        return '';
    }
    getShadowMapColorFormat(shadowMapParams) {
        const device = Application.instance.device;
        return device.getDeviceCaps().textureCaps.supportFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearFloatTexture ? device.type === 'webgl' ? 'rgba32f' : 'rg32f' : device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer && device.getDeviceCaps().textureCaps.supportLinearHalfFloatTexture ? device.type === 'webgl' ? 'rgba16f' : 'rg16f' : 'rgba8unorm';
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return 'd24s8';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                this.shadow = filterShadowVSM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                this.$l.coord = pb.vec4(this.dir, pb.sub(this.distance, this.shadowBias));
                this.$return(filterShadowVSM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.coord));
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$if(this.inShadow, function() {
                    if (shadowMapParams.lightType === LIGHT_TYPE_SPOT) {
                        this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                        this.shadowCoord.z = ShaderHelper.nonLinearDepthToLinearNormalized(this, this.shadowCoord.z, this.nearFar);
                        this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, true);
                    } else {
                        this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                    }
                    this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                    this.shadow = filterShadowVSM(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, this.shadowCoord);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return false;
    }
}

/** @internal */ class PCFPD extends ShadowImpl {
    _tapCount;
    _sampleRadius;
    _shadowSampler;
    constructor(tapCount, sampleRadius){
        super();
        this._tapCount = tapCount ?? 3;
        this._sampleRadius = sampleRadius ?? 1;
        this._shadowSampler = null;
    }
    get tapCount() {
        return this._tapCount;
    }
    set tapCount(val) {
        this._tapCount = val;
    }
    getType() {
        return 'pcf-pd';
    }
    dispose() {
        this._shadowSampler = null;
    }
    resourceDirty() {
        return false;
    }
    getShadowMapBorder(shadowMapParams) {
        return this._sampleRadius + 1;
    }
    getShadowMap(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? shadowMapParams.shadowMapFramebuffer.getDepthAttachment() : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(this.useNativeShadowMap(shadowMapParams)) || null;
    }
    postRenderShadowMap() {}
    releaseTemporalResources(shadowMapParams) {}
    getDepthScale() {
        return this._sampleRadius;
    }
    setDepthScale(val) {
        this._sampleRadius = val;
    }
    getShaderHash() {
        return `${this._tapCount}`;
    }
    getShadowMapColorFormat(shadowMapParams) {
        if (this.useNativeShadowMap(shadowMapParams)) {
            return null;
        } else {
            const device = Application.instance.device;
            return device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? device.type === 'webgl' ? 'rgba16f' : 'r16f' : device.getDeviceCaps().textureCaps.supportFloatColorBuffer ? device.type === 'webgl' ? 'rgba32f' : 'r32f' : 'rgba8unorm';
        }
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return Application.instance.device.type === 'webgl' ? 'd24s8' : 'd32f';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                this.shadow = filterShadowPoissonDisc(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._tapCount, this.shadowCoord, this.receiverPlaneDepthBias, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                    this.$l.maxZ = pb.max(pb.max(pb.abs(this.dir.x), pb.abs(this.dir.y)), pb.abs(this.dir.z));
                    this.$l.distance = ShaderHelper.linearDepthToNonLinear(this, this.maxZ, this.nearFar);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, pb.div(this.maxZ, ShaderHelper.getLightPositionAndRangeForShadow(this).w), this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                } else {
                    this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                }
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
                this.$if(this.inShadow, function() {
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                    this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                    this.shadow = filterShadowPoissonDisc(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._tapCount, this.shadowCoord, this.receiverPlaneDepthBias);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return Application.instance.device.type !== 'webgl';
    }
    /** @internal */ sampleShadowMap(shadowMapParams, scope, coords, z, bias) {
        const funcNameSampleShadowMap = 'lib_sampleShadowMap';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMap, [
            pb.vec3('coords'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            if (that.useNativeShadowMap(shadowMapParams)) {
                this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, pb.sub(this.z, this.bias)), 0, 1));
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$l.distance = pb.sub(this.z, this.bias);
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMap](coords, z, bias);
    }
    /** @internal */ sampleShadowMapCSM(shadowMapParams, scope, coords, split, z, bias) {
        const funcNameSampleShadowMapCSM = 'lib_sampleShadowMapCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMapCSM, [
            pb.vec4('coords'),
            pb.int('split'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            this.$l.distance = pb.sub(this.z, this.bias);
            if (that.useNativeShadowMap(shadowMapParams)) {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$return(pb.clamp(pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, this.distance), 0, 1));
                } else {
                    this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.distance), 0, 1));
                }
            } else {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, 0);
                } else {
                    this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, 0);
                }
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMapCSM](coords, split, z, bias);
    }
}

/** @internal */ class PCFOPT extends ShadowImpl {
    _kernelSize;
    _shadowSampler;
    constructor(kernelSize){
        super();
        this._kernelSize = kernelSize ?? 5;
        this._shadowSampler = null;
    }
    get kernelSize() {
        return this._kernelSize;
    }
    set kernelSize(val) {
        val = val !== 3 && val !== 5 && val !== 7 ? 5 : val;
        this._kernelSize = val;
    }
    getType() {
        return 'pcf-opt';
    }
    dispose() {
        this._shadowSampler = null;
    }
    resourceDirty() {
        return false;
    }
    getShadowMapBorder(shadowMapParams) {
        return this._kernelSize;
    }
    getShadowMap(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? shadowMapParams.shadowMapFramebuffer.getDepthAttachment() : shadowMapParams.shadowMapFramebuffer.getColorAttachments()[0];
    }
    doUpdateResources(shadowMapParams) {
        shadowMapParams.shadowMap = this.getShadowMap(shadowMapParams);
        shadowMapParams.shadowMapSampler = shadowMapParams.shadowMap?.getDefaultSampler(this.useNativeShadowMap(shadowMapParams)) || null;
    }
    postRenderShadowMap() {}
    releaseTemporalResources(shadowMapParams) {}
    getDepthScale() {
        return 1;
    }
    setDepthScale(val) {}
    getShaderHash() {
        return `${this._kernelSize}`;
    }
    getShadowMapColorFormat(shadowMapParams) {
        return this.useNativeShadowMap(shadowMapParams) ? null : 'rgba8unorm';
    }
    getShadowMapDepthFormat(shadowMapParams) {
        return Application.instance.device.type === 'webgl' ? 'd24s8' : 'd32f';
    }
    computeShadowMapDepth(shadowMapParams, scope, worldPos) {
        return computeShadowMapDepth(scope, worldPos, shadowMapParams.shadowMap.format);
    }
    computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        const funcNameComputeShadowCSM = 'lib_computeShadowCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadowCSM, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL'),
            pb.int('split')
        ], function() {
            this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
            this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
            this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
            this.$l.shadow = pb.float(1);
            this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
            this.$if(this.inShadow, function() {
                this.$l.shadowBias = ShadowMapper.computeShadowBiasCSM(shadowMapParams, this, this.NdotL, this.split);
                this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                this.shadow = filterShadowPCF(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._kernelSize, this.shadowCoord, this.receiverPlaneDepthBias, this.split);
            });
            this.$return(this.shadow);
        });
        return pb.getGlobalScope()[funcNameComputeShadowCSM](shadowVertex, NdotL, split);
    }
    computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        const funcNameComputeShadow = 'lib_computeShadow';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameComputeShadow, [
            pb.vec4('shadowVertex'),
            pb.float('NdotL')
        ], function() {
            if (shadowMapParams.lightType === LIGHT_TYPE_POINT) {
                this.$l.dir = pb.sub(this.shadowVertex.xyz, ShaderHelper.getLightPositionAndRangeForShadow(this).xyz);
                if (that.useNativeShadowMap(shadowMapParams)) {
                    this.$l.nearFar = ShaderHelper.getShadowCameraParams(this).xy;
                    this.$l.maxZ = pb.max(pb.max(pb.abs(this.dir.x), pb.abs(this.dir.y)), pb.abs(this.dir.z));
                    this.$l.distance = ShaderHelper.linearDepthToNonLinear(this, this.maxZ, this.nearFar);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, pb.div(this.maxZ, ShaderHelper.getLightPositionAndRangeForShadow(this).w), this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                } else {
                    this.$l.distance = pb.div(pb.length(this.dir), ShaderHelper.getLightPositionAndRangeForShadow(this).w);
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.distance, this.NdotL, true);
                    this.$return(that.sampleShadowMap(shadowMapParams, this, this.dir, this.distance, this.shadowBias));
                }
            } else {
                this.$l.shadowCoord = pb.div(this.shadowVertex, this.shadowVertex.w);
                this.$l.shadowCoord = pb.add(pb.mul(this.shadowCoord, 0.5), 0.5);
                this.$l.inShadow = pb.all(pb.bvec2(pb.all(pb.bvec4(pb.greaterThanEqual(this.shadowCoord.x, 0), pb.lessThanEqual(this.shadowCoord.x, 1), pb.greaterThanEqual(this.shadowCoord.y, 0), pb.lessThanEqual(this.shadowCoord.y, 1))), pb.lessThanEqual(this.shadowCoord.z, 1)));
                this.$l.shadow = pb.float(1);
                this.$l.receiverPlaneDepthBias = computeReceiverPlaneDepthBias(this, this.shadowCoord);
                this.$if(this.inShadow, function() {
                    this.$l.shadowBias = ShadowMapper.computeShadowBias(shadowMapParams, this, this.shadowCoord.z, this.NdotL, false);
                    this.shadowCoord.z = pb.sub(this.shadowCoord.z, this.shadowBias);
                    this.shadow = filterShadowPCF(this, shadowMapParams.lightType, shadowMapParams.shadowMap.format, that._kernelSize, this.shadowCoord, this.receiverPlaneDepthBias);
                });
                this.$return(this.shadow);
            }
        });
        return pb.getGlobalScope()[funcNameComputeShadow](shadowVertex, NdotL);
    }
    useNativeShadowMap(shadowMapParams) {
        return Application.instance.device.type !== 'webgl';
    }
    /** @internal */ sampleShadowMap(shadowMapParams, scope, coords, z, bias) {
        const funcNameSampleShadowMap = `lib_sampleShadowMap`;
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMap, [
            pb.vec3('coords'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            if (that.useNativeShadowMap(shadowMapParams)) {
                this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords, pb.sub(this.z, this.bias)), 0, 1));
            } else {
                this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords, 0);
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$l.distance = pb.sub(this.z, this.bias);
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMap](coords, z, bias);
    }
    /** @internal */ sampleShadowMapCSM(shadowMapParams, scope, coords, split, z, bias) {
        const funcNameSampleShadowMapCSM = 'lib_sampleShadowMapCSM';
        const pb = scope.$builder;
        const that = this;
        pb.func(funcNameSampleShadowMapCSM, [
            pb.vec4('coords'),
            pb.int('split'),
            pb.float('z'),
            pb.float('bias')
        ], function() {
            const floatDepthTexture = shadowMapParams.shadowMap.format !== 'rgba8unorm';
            this.$l.distance = pb.sub(this.z, this.bias);
            if (that.useNativeShadowMap(shadowMapParams)) {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$return(pb.clamp(pb.textureArraySampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, this.distance), 0, 1));
                } else {
                    this.$return(pb.clamp(pb.textureSampleCompareLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.distance), 0, 1));
                }
            } else {
                if (shadowMapParams.shadowMap.isTexture2DArray()) {
                    this.$l.shadowTex = pb.textureArraySampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, this.split, 0);
                } else {
                    this.$l.shadowTex = pb.textureSampleLevel(ShaderHelper.getShadowMap(this), this.coords.xy, 0);
                }
                if (!floatDepthTexture) {
                    this.shadowTex.x = decodeNormalizedFloatFromRGBA(this, this.shadowTex);
                }
                this.$return(pb.step(this.distance, this.shadowTex.x));
            }
        });
        return pb.getGlobalScope()[funcNameSampleShadowMapCSM](coords, split, z, bias);
    }
}

const tmpMatrix = new Matrix4x4();
const tmpFrustum = new Frustum(Matrix4x4.identity());
// const zeroPosition = Vector3.zero();
/**
 * The shadow map generator
 * @public
 */ class ShadowMapper {
    /** @internal */ static _snapMatrix = new Matrix4x4();
    /** @internal */ static _target = new Vector3();
    /** @internal */ static _up = new Vector3();
    /** @internal */ static _frustumMin = new Vector3();
    /** @internal */ static _frustumMax = new Vector3();
    /** @internal */ static _frustumCenter = new Vector3();
    /** @internal */ static _lightCameras = new WeakMap();
    /** @internal */ static _shadowMapParams = [];
    /** @internal */ _light;
    /** @internal */ _config;
    /** @internal */ _resourceDirty;
    /** @internal */ _shadowMode;
    /** @internal */ _shadowDistance;
    /** @internal */ _impl;
    /** @internal */ _pdSampleCount;
    /** @internal */ _pdSampleRadius;
    /** @internal */ _pcfKernelSize;
    /** @internal */ _vsmBlurKernelSize;
    /** @internal */ _vsmBlurRadius;
    /** @internal */ _vsmDarkness;
    /** @internal */ _esmBlur;
    /** @internal */ _esmBlurKernelSize;
    /** @internal */ _esmBlurRadius;
    /** @internal */ _esmDepthScale;
    /** @internal */ _shadowRegion;
    /**
   * Creates an instance of ShadowMapper
   * @param light - The light that is used to generate shadow map
   */ constructor(light){
        this._light = light;
        this._config = {
            shadowMapSize: 1024,
            numCascades: 1,
            splitLambda: 0.5,
            depthBias: 0.05,
            normalBias: 0.05,
            nearClip: 1
        };
        this._resourceDirty = true;
        this._shadowMode = 'hard';
        this._shadowDistance = 2000;
        this._impl = null;
        this._pdSampleCount = 12;
        this._pdSampleRadius = 4;
        this._pcfKernelSize = 5;
        this._vsmBlurKernelSize = 5;
        this._vsmBlurRadius = 4;
        this._vsmDarkness = 0.3;
        this._esmBlur = true;
        this._esmBlurKernelSize = 5;
        this._esmBlurRadius = 4;
        this._esmDepthScale = 200;
        this._shadowRegion = null;
        this.applyMode(this._shadowMode);
    }
    /** The light that is used to generate shadow map */ get light() {
        return this._light;
    }
    /** Size of the shadow map */ get shadowMapSize() {
        return this._config.shadowMapSize;
    }
    set shadowMapSize(num) {
        if (!Number.isInteger(num) || num < 1) {
            console.error(`invalid shadow map size: ${num}`);
            return;
        }
        if (this._config.shadowMapSize !== num) {
            this._config.shadowMapSize = num;
            this._resourceDirty = true;
        }
    }
    /** Shadow region for directional light */ get shadowRegion() {
        return this._shadowRegion;
    }
    set shadowRegion(region) {
        this._shadowRegion = region;
    }
    /** Maximum distance from the camera, shadow will not be rendered beyond this range */ get shadowDistance() {
        return this._shadowDistance;
    }
    set shadowDistance(val) {
        this._shadowDistance = Math.max(0, val);
    }
    /** Count of the cascades, The maximum value is 4 */ get numShadowCascades() {
        return this._config.numCascades;
    }
    set numShadowCascades(num) {
        if (num !== 1 && num !== 2 && num !== 3 && num !== 4) {
            console.error(`invalid shadow cascade number: ${num}`);
            return;
        }
        if (!this._light.isDirectionLight() && num > 1) {
            console.error(`only directional light can have more than one shadow cascades`);
            return;
        }
        if (num !== this._config.numCascades) {
            this._config.numCascades = num;
            this._resourceDirty = true;
        }
    }
    /** The split lambda for cascaded shadow mapping */ get splitLambda() {
        return this._config.splitLambda;
    }
    set splitLambda(val) {
        if (this._config.splitLambda !== val) {
            this._config.splitLambda = val;
        }
    }
    /** Depth bias for the shadow map */ get depthBias() {
        return this._config.depthBias;
    }
    set depthBias(val) {
        this._config.depthBias = val;
    }
    /** Normal bias for the shadow map */ get normalBias() {
        return this._config.normalBias;
    }
    set normalBias(val) {
        this._config.normalBias = val;
    }
    /** Near clip plane */ get nearClip() {
        return this._config.nearClip;
    }
    set nearClip(val) {
        if (this._config.nearClip !== val) {
            this._config.nearClip = val;
        }
    }
    /** Shadow map mode */ get mode() {
        return this._shadowMode;
    }
    set mode(mode) {
        if (mode !== this._shadowMode) {
            this._shadowMode = mode;
            this.applyMode(this._shadowMode);
        }
    }
    /** Generated shadow map */ /*
  get shadowMap(): ShadowMapType {
    return (this._impl.getShadowMap(this) ?? this._framebuffer?.getColorAttachments()[0] ?? null) as ShadowMapType;
  }
  */ /** Sampler of the shadow map */ /*
  get shadowMapSampler(): TextureSampler {
    return this._impl.getShadowMapSampler(this);
  }
  */ /** @internal */ getShaderHash(shadowMapParams) {
        return `${shadowMapParams.impl.constructor.name}_${shadowMapParams.impl.getShaderHash()}_${shadowMapParams.lightType}_${shadowMapParams.shadowMap.target}_${Number(shadowMapParams.numShadowCascades > 1)}_${Number(Application.instance.device.getDeviceCaps().textureCaps.getTextureFormatInfo(shadowMapParams.shadowMap.format).filterable)}`;
    }
    /** Sample count for poisson disc PCF */ get pdSampleCount() {
        return this._pdSampleCount;
    }
    set pdSampleCount(val) {
        val = Math.min(Math.max(1, Number(val) >> 0), 64);
        if (val !== this._pdSampleCount) {
            this._pdSampleCount = val;
            this.asPCFPD() && (this.asPCFPD().tapCount = this._pdSampleCount);
        }
    }
    /** Radius for poisson disc PCF */ get pdSampleRadius() {
        return this._pdSampleRadius;
    }
    set pdSampleRadius(val) {
        val = Math.max(0, Number(val) >> 0);
        if (val !== this._pdSampleRadius) {
            this._pdSampleRadius = val;
            this.asPCFPD()?.setDepthScale(this._pdSampleRadius);
        }
    }
    /** Kernel size for optimized PCF */ get pcfKernelSize() {
        return this._pcfKernelSize;
    }
    set pcfKernelSize(val) {
        val = val !== 3 && val !== 5 && val !== 7 ? 5 : val;
        if (val !== this._pcfKernelSize) {
            this._pcfKernelSize = val;
            this.asPCFOPT() && (this.asPCFOPT().kernelSize = this._pcfKernelSize);
        }
    }
    /** Kernel size of VSM */ get vsmBlurKernelSize() {
        return this._vsmBlurKernelSize;
    }
    set vsmBlurKernelSize(val) {
        val = Math.max(3, Number(val) >> 0) | 1;
        if (val !== this._vsmBlurKernelSize) {
            this._vsmBlurKernelSize = val;
            this.asVSM() && (this.asVSM().kernelSize = this._vsmBlurKernelSize);
        }
    }
    /** Blur radius for VSM */ get vsmBlurRadius() {
        return this._vsmBlurRadius;
    }
    set vsmBlurRadius(val) {
        val = Math.max(0, Number(val) || 0);
        if (val !== this._vsmBlurRadius) {
            this._vsmBlurRadius = val;
            this.asVSM() && (this.asVSM().blurSize = this._vsmBlurRadius);
        }
    }
    /** Darkness for VSM */ get vsmDarkness() {
        return this._vsmDarkness;
    }
    set vsmDarkness(val) {
        val = Math.min(0.999, Math.max(0, Number(val) || 0));
        if (val !== this._vsmDarkness) {
            this._vsmDarkness = val;
            this.asVSM()?.setDepthScale(this._vsmDarkness);
        }
    }
    /** Whether to enable ESM blur */ get esmBlur() {
        return this._esmBlur;
    }
    set esmBlur(val) {
        if (!!val !== this.esmBlur) {
            this._esmBlur = !!val;
            this.asESM() && (this.asESM().blur = this._esmBlur);
        }
    }
    /** Kernel size for ESM */ get esmBlurKernelSize() {
        return this._esmBlurKernelSize;
    }
    set esmBlurKernelSize(val) {
        val = Math.max(3, Number(val) >> 0) | 1;
        if (val !== this._esmBlurKernelSize) {
            this._esmBlurKernelSize = val;
            this.asESM() && (this.asESM().kernelSize = this._esmBlurKernelSize);
        }
    }
    /** Blur radius for ESM */ get esmBlurRadius() {
        return this._esmBlurRadius;
    }
    set esmBlurRadius(val) {
        val = Math.max(0, Number(val) || 0);
        if (val !== this._esmBlurRadius) {
            this._esmBlurRadius = val;
            this.asESM() && (this.asESM().blurSize = this._esmBlurRadius);
        }
    }
    /** Depth scale for ESM */ get esmDepthScale() {
        return this._esmDepthScale;
    }
    set esmDepthScale(val) {
        val = Math.max(0, Number(val) || 0);
        if (val !== this._esmDepthScale) {
            this._esmDepthScale = val;
            this.asESM()?.setDepthScale(this._esmDepthScale);
        }
    }
    /** @internal */ computeShadow(shadowMapParams, scope, shadowVertex, NdotL) {
        return this._impl.computeShadow(shadowMapParams, scope, shadowVertex, NdotL);
    }
    /** @internal */ computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split) {
        return this._impl.computeShadowCSM(shadowMapParams, scope, shadowVertex, NdotL, split);
    }
    /** @internal */ static releaseTemporalResources(ctx) {
        if (ctx.shadowMapInfo) {
            for (const k of ctx.shadowMapInfo.keys()){
                const shadowMapParams = ctx.shadowMapInfo.get(k);
                TemporalCache.releaseFramebuffer(shadowMapParams.shadowMapFramebuffer);
                shadowMapParams.impl.releaseTemporalResources(shadowMapParams);
                shadowMapParams.lightType = LIGHT_TYPE_NONE;
                shadowMapParams.depthClampEnabled = false;
                shadowMapParams.shaderHash = '';
                shadowMapParams.numShadowCascades = 1;
                shadowMapParams.shadowMapFramebuffer = null;
                shadowMapParams.impl = null;
                shadowMapParams.shadowMap = null;
                shadowMapParams.shadowMapSampler = null;
                shadowMapParams.implData = null;
                this._shadowMapParams.push(shadowMapParams);
            }
            ctx.shadowMapInfo = null;
        }
    }
    /** @internal */ static computeShadowBias(shadowMapParams, scope, z, NdotL, linear) {
        const pb = scope.$builder;
        const depthBiasParam = ShaderHelper.getDepthBiasValues(scope);
        if (shadowMapParams.lightType === LIGHT_TYPE_DIRECTIONAL) {
            return pb.dot(pb.mul(depthBiasParam.xy, pb.vec2(1, pb.sub(1, NdotL))), pb.vec2(1, 1));
        } else {
            const nearFar = ShaderHelper.getShadowCameraParams(scope).xy;
            const linearDepth = linear ? z : ShaderHelper.nonLinearDepthToLinearNormalized(scope, z, nearFar);
            const biasScaleFactor = pb.mix(1, depthBiasParam.w, linearDepth);
            return pb.dot(pb.mul(depthBiasParam.xy, pb.vec2(1, pb.sub(1, NdotL)), biasScaleFactor), pb.vec2(1, 1));
        }
    }
    /** @internal */ static computeShadowBiasCSM(shadowMapParams, scope, NdotL, split) {
        const pb = scope.$builder;
        const depthBiasParam = ShaderHelper.getDepthBiasValues(scope);
        const splitFlags = pb.vec4(pb.float(pb.equal(split, 0)), pb.float(pb.equal(split, 1)), pb.float(pb.equal(split, 2)), pb.float(pb.equal(split, 3)));
        const depthBiasScale = pb.dot(ShaderHelper.getDepthBiasScales(scope), splitFlags);
        return pb.dot(pb.mul(depthBiasParam.xy, pb.vec2(1, pb.sub(1, NdotL)), depthBiasScale), pb.vec2(1, 1));
    }
    /** @internal */ isTextureInvalid(texture, target, format, width, height) {
        return texture && (texture.target !== target || texture.format !== format || texture.width !== width || texture.height !== height || texture.depth !== this.numShadowCascades);
    }
    /** @internal */ createTexture(target, format, width, height, depth) {
        const device = Application.instance.device;
        const options = {
            samplerOptions: {
                mipFilter: 'none'
            }
        };
        switch(target){
            case '2d':
                return device.createTexture2D(format, width, height, options);
            case 'cube':
                return device.createCubeTexture(format, width, options);
            case '2darray':
                return device.createTexture2DArray(format, width, height, depth, options);
            default:
                return null;
        }
    }
    /** @internal */ updateResources(shadowMapParams) {
        const device = Application.instance.device;
        const colorFormat = shadowMapParams.impl.getShadowMapColorFormat(shadowMapParams);
        const depthFormat = shadowMapParams.impl.getShadowMapDepthFormat(shadowMapParams);
        const numCascades = shadowMapParams.numShadowCascades;
        const useTextureArray = numCascades > 1 && device.type !== 'webgl';
        const shadowMapWidth = numCascades > 1 && !useTextureArray ? 2 * this._config.shadowMapSize : this._config.shadowMapSize;
        const shadowMapHeight = numCascades > 2 && !useTextureArray ? 2 * this._config.shadowMapSize : this._config.shadowMapSize;
        const colorTarget = useTextureArray ? '2darray' : this._light.isPointLight() ? 'cube' : '2d';
        const depthTarget = device.type === 'webgl' ? '2d' : colorTarget;
        shadowMapParams.shadowMapFramebuffer = TemporalCache.getFramebufferFixedSize(shadowMapWidth, shadowMapHeight, numCascades, colorFormat, depthFormat, colorTarget, depthTarget, false, 1);
        shadowMapParams.impl = this._impl;
        this._impl.updateResources(shadowMapParams);
    }
    /** @internal */ createLightCameraPoint(lightCamera) {
        //lightCamera.reparent(this._light);
        lightCamera.reparent(lightCamera.scene.rootNode);
        lightCamera.position.setXYZ(0, 0, 0);
        lightCamera.rotation.identity();
        lightCamera.scale.setXYZ(1, 1, 1);
        lightCamera.setPerspective(Math.PI / 2, 1, this._config.nearClip, Math.min(this._shadowDistance, this._light.range));
        lightCamera.position.set(this._light.positionAndRange.xyz());
    }
    /** @internal */ createLightCameraSpot(lightCamera) {
        lightCamera.reparent(this._light);
        lightCamera.position.setXYZ(0, 0, 0);
        lightCamera.rotation.identity();
        lightCamera.scale.setXYZ(1, 1, 1);
        lightCamera.setPerspective(2 * this._light.cutoff, 1, this._config.nearClip, Math.min((this._shadowDistance, this._light).range));
    }
    /** @internal */ createLightCameraDirectional(sceneAABB, sceneCamera, lightCamera, cropMatrix, border) {
        let frustum = sceneCamera.frustumViewSpace;
        if (this._shadowDistance < sceneCamera.getFarPlane()) {
            tmpMatrix.set(sceneCamera.getProjectionMatrix());
            tmpMatrix.setNearFar(tmpMatrix.getNearPlane(), this._shadowDistance);
            //tmpMatrix.multiplyRight(sceneCamera.viewMatrix);
            tmpFrustum.initWithMatrix(tmpMatrix);
            frustum = tmpFrustum;
        }
        border = border || 0;
        const expand = (this.shadowMapSize - 2 * border) / this.shadowMapSize;
        //const frustum = sceneCamera.frustum;
        const frustumMin = ShadowMapper._frustumMin;
        const frustumMax = ShadowMapper._frustumMax;
        const frustumCenter = ShadowMapper._frustumCenter;
        const target = ShadowMapper._target;
        const up = ShadowMapper._up;
        // const frustum = new Frustum(sceneCamera.viewProjectionMatrix);
        frustumMin.setXYZ(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        frustumMax.setXYZ(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        frustum.corners.forEach((p)=>{
            frustumMin.inplaceMin(p);
            frustumMax.inplaceMax(p);
        });
        let radius = Vector3.distance(frustumMin, frustumMax) * 0.5 * expand;
        const center = sceneCamera.thisToWorld(Vector3.add(frustumMin, frustumMax, frustumCenter).scaleBy(0.5), frustumCenter);
        // Bounding sphere of the shadow camera should not be larger than bounding sphere of the scene.
        const sceneRadius = sceneAABB.diagonalLength * 0.5 * expand;
        if (sceneRadius < radius) {
            radius = sceneRadius;
            Vector3.add(sceneAABB.minPoint, sceneAABB.maxPoint, center).scaleBy(0.5);
        }
        target.setXYZ(center.x + this._light.directionAndCutoff.x, center.y + this._light.directionAndCutoff.y, center.z + this._light.directionAndCutoff.z);
        up.setXYZ(0, 1, 0);
        lightCamera.lookAt(center, target, up);
        lightCamera.position.set(center);
        lightCamera.setOrtho(-radius, radius, -radius, radius, -radius, radius);
        center.setXYZ(0, 0, 0);
        lightCamera.viewProjectionMatrix.transformPointP(center, center);
        if (cropMatrix) {
            const tx = center.x * this.shadowMapSize * 0.5;
            const ty = center.y * this.shadowMapSize * 0.5;
            const rx = Math.round(tx);
            const ry = Math.round(ty);
            center.setXYZ((rx - tx) * 2 / this.shadowMapSize, (ry - ty) * 2 / this.shadowMapSize, 0);
            cropMatrix.translation(center);
        }
    /*
    const minx = frustumMin.x;
    const maxx = frustumMax.x;
    const miny = frustumMin.y;
    const maxy = frustumMax.y;
    const minz = frustumMin.z;
    const maxz = frustumMax.z;
    const texelSizeW = (maxx - minx) / this.shadowMapSize;
    const texelSizeH = (maxy - miny) / this.shadowMapSize;
    const cx = Math.floor((minx + maxx) / 2 / texelSizeW) * texelSizeW;
    const cy = Math.floor((miny + maxy) / 2 / texelSizeH) * texelSizeH;
    const cz = (minz + maxz) / 2;
    const hx = Math.floor(((maxx - minx) * (expand + 0.5)) / texelSizeW) * texelSizeW;
    const hy = Math.floor(((maxy - miny) * (expand + 0.5)) / texelSizeH) * texelSizeH;
    lightCamera.position.setXYZ(cx, cy, cz);
    lightCamera.setOrtho(
      -hx,
      hx,
      -hy,
      hy,
      sceneMax.z - maxz,
      sceneMax.z - minz + 1
    );
    if (cropMatrix) {
      // compute crop matrix
      let clipMaxX = 0,
        clipMaxY = 0;
      let clipMinX = Number.MAX_VALUE,
        clipMinY = Number.MAX_VALUE;
      frustum.corners.forEach((p) => {
        const clipPos = lightCamera.viewProjectionMatrix.transformPoint(p);
        clipPos.x = Math.min(1, Math.max(-1, clipPos.x / clipPos.w));
        clipPos.y = Math.min(1, Math.max(-1, clipPos.y / clipPos.w));
        if (clipPos.x > clipMaxX) {
          clipMaxX = clipPos.x;
        }
        if (clipPos.x < clipMinX) {
          clipMinX = clipPos.x;
        }
        if (clipPos.y > clipMaxY) {
          clipMaxY = clipPos.y;
        }
        if (clipPos.y < clipMinY) {
          clipMinY = clipPos.y;
        }
      });
      const clipW = clipMaxX - clipMinX;
      const clipH = clipMaxY - clipMinY;
      clipMinX -= expand * clipW;
      clipMinY -= expand * clipH;
      clipMaxX += expand * clipW;
      clipMaxY += expand * clipH;
      const scaleX = 2 / (clipMaxX - clipMinX);
      const scaleY = 2 / (clipMaxY - clipMinY);
      const offsetX = -0.5 * (clipMaxX + clipMinX) * scaleX;
      const offsetY = -0.5 * (clipMaxY + clipMinY) * scaleY;
      cropMatrix.identity();
      cropMatrix.m00 = scaleX;
      cropMatrix.m11 = scaleY;
      cropMatrix.m03 = offsetX;
      cropMatrix.m13 = offsetY;
    }
    */ }
    /** @internal */ static fetchShadowMapParams() {
        if (this._shadowMapParams.length > 0) {
            return this._shadowMapParams.pop();
        } else {
            return {
                lightType: LIGHT_TYPE_NONE,
                depthClampEnabled: false,
                shaderHash: '',
                cameraParams: new Vector4(),
                cascadeDistances: new Vector4(),
                depthBiasScales: new Vector4(),
                depthBiasValues: [
                    new Vector4(),
                    new Vector4(),
                    new Vector4(),
                    new Vector4()
                ],
                numShadowCascades: 1,
                shadowMatrices: new Float32Array(16 * 4),
                shadowMap: null,
                shadowMapSampler: null,
                shadowMapFramebuffer: null,
                impl: null,
                implData: null
            };
        }
    }
    /** @internal */ static fetchCameraForScene(scene) {
        const cameras = this._lightCameras.get(scene);
        if (!cameras || cameras.length === 0) {
            return new Camera(scene);
        } else {
            const camera = cameras.pop();
            camera.parent = scene.rootNode;
            camera.position.setXYZ(0, 0, 0);
            camera.rotation.identity();
            camera.scale.setXYZ(1, 1, 1);
            camera.clipMask = 0;
            return camera;
        }
    }
    /** @internal */ static releaseCamera(camera) {
        let cameras = this._lightCameras.get(camera.scene);
        if (!cameras) {
            cameras = [];
            this._lightCameras.set(camera.scene, cameras);
        }
        camera.remove();
        cameras.push(camera);
    }
    /** @internal */ calcSplitDistances(nearPlane, farPlane, numCascades) {
        const result = [
            0,
            0,
            0,
            0,
            0
        ];
        for(let i = 0; i <= numCascades; ++i){
            const fIDM = i / numCascades;
            const fLog = nearPlane * Math.pow(farPlane / nearPlane, fIDM);
            const fUniform = nearPlane + (farPlane - nearPlane) * fIDM;
            result[i] = fLog * this._config.splitLambda + fUniform * (1 - this._config.splitLambda);
        }
        return result;
    }
    /** @internal */ calcDepthBiasParams(shadowMapCamera, shadowMapSize, depthBias, normalBias, depthScale, result) {
        const sizeNear = Math.min(shadowMapCamera.getProjectionMatrix().getNearPlaneWidth(), shadowMapCamera.getProjectionMatrix().getNearPlaneHeight());
        const sizeFar = Math.min(shadowMapCamera.getProjectionMatrix().getFarPlaneWidth(), shadowMapCamera.getProjectionMatrix().getFarPlaneHeight());
        const scaleFactor = sizeNear / shadowMapSize / 2;
        result.setXYZW(depthBias * scaleFactor, normalBias * scaleFactor, depthScale, sizeFar / sizeNear);
    }
    /** @internal */ postRenderShadowMap(shadowMapParams) {
        this._impl.postRenderShadowMap(shadowMapParams);
    }
    /** @internal */ render(ctx, renderPass) {
        if (!ctx.shadowMapInfo) {
            ctx.shadowMapInfo = new Map();
        }
        const shadowMapParams = ShadowMapper.fetchShadowMapParams();
        shadowMapParams.impl = this._impl;
        shadowMapParams.lightType = this.light.lightType;
        shadowMapParams.numShadowCascades = shadowMapParams.lightType === LIGHT_TYPE_DIRECTIONAL ? this._config.numCascades : 1;
        ctx.shadowMapInfo.set(this.light, shadowMapParams);
        const scene = ctx.scene;
        const camera = ctx.camera;
        renderPass.light = this._light;
        this.updateResources(shadowMapParams);
        shadowMapParams.shaderHash = this.getShaderHash(shadowMapParams);
        const device = Application.instance.device;
        const fb = shadowMapParams.shadowMapFramebuffer;
        shadowMapParams.depthClampEnabled = false;
        renderPass.clearColor = fb.getColorAttachments()[0] ? fb.getColorAttachments()[0].isFloatFormat() ? new Vector4(1, 1, 1, 1) : new Vector4(0, 0, 0, 1) : null;
        const depthScale = this._impl.getDepthScale();
        const shadowRegion = this._light.isDirectionLight() && this._shadowRegion && this._shadowRegion.isValid() ? this._shadowRegion : scene.boundingBox;
        if (this._light.isPointLight()) {
            const shadowMapRenderCamera = ShadowMapper.fetchCameraForScene(scene);
            this.createLightCameraPoint(shadowMapRenderCamera);
            this.calcDepthBiasParams(shadowMapRenderCamera, this._config.shadowMapSize, this._config.depthBias, this._config.normalBias, depthScale, shadowMapParams.depthBiasValues[0]);
            shadowMapParams.cameraParams.setXYZW(shadowMapRenderCamera.getNearPlane(), shadowMapRenderCamera.getFarPlane(), this._config.shadowMapSize, this._shadowDistance);
            device.setFramebuffer(fb);
            shadowMapParams.shadowMatrices.set(Matrix4x4.transpose(shadowMapRenderCamera.viewMatrix));
            for (const face of [
                CubeFace.PX,
                CubeFace.NX,
                CubeFace.PY,
                CubeFace.NY,
                CubeFace.PZ,
                CubeFace.NZ
            ]){
                shadowMapRenderCamera.lookAtCubeFace(face);
                fb.setColorAttachmentCubeFace(0, face);
                fb.setDepthAttachmentCubeFace(face);
                ctx.camera = shadowMapRenderCamera;
                renderPass.render(ctx);
            }
            shadowMapParams.shadowMatrices.set(Matrix4x4.identity());
            ShadowMapper.releaseCamera(shadowMapRenderCamera);
        } else {
            if (this._config.numCascades > 1) {
                const distances = this.calcSplitDistances(camera.getNearPlane(), Math.min(this._shadowDistance, camera.getFarPlane()), this._config.numCascades);
                const cascadeCamera = ShadowMapper.fetchCameraForScene(scene);
                const shadowMapRenderCamera = ShadowMapper.fetchCameraForScene(scene);
                const shadowMapCullCamera = ShadowMapper.fetchCameraForScene(scene);
                shadowMapCullCamera.clipMask = AABB.ClipLeft | AABB.ClipRight | AABB.ClipBottom | AABB.ClipTop;
                cascadeCamera.reparent(camera);
                shadowMapParams.depthClampEnabled = Application.instance.device.getDeviceCaps().shaderCaps.supportFragmentDepth;
                for(let split = 0; split < this._config.numCascades; split++){
                    cascadeCamera.setPerspective(camera.getFOV(), camera.getAspect(), distances[split], distances[split + 1]);
                    const snapMatrix = ShadowMapper._snapMatrix;
                    const border = shadowMapParams.impl.getShadowMapBorder(shadowMapParams); //20 / this._config.shadowMapSize;
                    this.createLightCameraDirectional(shadowRegion, cascadeCamera, shadowMapRenderCamera, snapMatrix, border);
                    this.createLightCameraDirectional(shadowRegion, cascadeCamera, shadowMapCullCamera, null, border);
                    this.calcDepthBiasParams(shadowMapRenderCamera, this._config.shadowMapSize, this._config.depthBias, this._config.normalBias, depthScale, shadowMapParams.depthBiasValues[split]);
                    shadowMapParams.depthBiasScales[split] = 1;
                    // Incorrect calculation
                    // shadowMapParams.depthBiasScales[split] = shadowMapParams.depthBiasValues[0].x !== 0 ? shadowMapParams.depthBiasValues[split].x / shadowMapParams.depthBiasValues[0].x : 1;
                    shadowMapParams.cameraParams.setXYZW(shadowMapRenderCamera.getNearPlane(), shadowMapRenderCamera.getFarPlane(), this._config.shadowMapSize, this._shadowDistance);
                    let scissor = null;
                    if (fb.getColorAttachments()[0]?.isTexture2DArray() || fb.getDepthAttachment()?.isTexture2DArray()) {
                        shadowMapRenderCamera.setProjectionMatrix(Matrix4x4.multiply(snapMatrix, shadowMapRenderCamera.getProjectionMatrix()));
                        fb.setColorAttachmentLayer(0, split);
                        fb.setDepthAttachmentLayer(split);
                    } else {
                        const numRows = this._config.numCascades > 2 ? 2 : 1;
                        const numCols = this._config.numCascades > 1 ? 2 : 1;
                        const adjMatrix = new Matrix4x4();
                        const col = split % 2;
                        const row = split >> 1;
                        adjMatrix.setRowXYZW(0, 1.5 - 0.5 * numCols, 0, 0, 0);
                        adjMatrix.setRowXYZW(1, 0, 1.5 - 0.5 * numRows, 0, 0);
                        adjMatrix.setRowXYZW(2, 0, 0, 1, 0);
                        adjMatrix.setRowXYZW(3, col - 0.5 * numCols + 0.5, row - 0.5 * numRows + 0.5, 0, 1);
                        shadowMapRenderCamera.setProjectionMatrix(Matrix4x4.multiply(adjMatrix, Matrix4x4.multiply(snapMatrix, shadowMapRenderCamera.getProjectionMatrix())));
                        if (device.type === 'webgpu') {
                            scissor = [
                                col * this._config.shadowMapSize,
                                (numRows - 1 - row) * this._config.shadowMapSize,
                                this._config.shadowMapSize,
                                this._config.shadowMapSize
                            ];
                        } else {
                            scissor = [
                                col * this._config.shadowMapSize,
                                row * this._config.shadowMapSize,
                                this._config.shadowMapSize,
                                this._config.shadowMapSize
                            ];
                        }
                    }
                    device.setFramebuffer(fb);
                    device.setScissor(scissor);
                    ctx.camera = shadowMapRenderCamera;
                    renderPass.render(ctx, shadowMapCullCamera);
                    shadowMapParams.shadowMatrices.set(Matrix4x4.transpose(shadowMapRenderCamera.viewProjectionMatrix), split * 16);
                    shadowMapParams.cascadeDistances[split] = distances[split + 1];
                }
                ShadowMapper.releaseCamera(cascadeCamera);
                ShadowMapper.releaseCamera(shadowMapRenderCamera);
                ShadowMapper.releaseCamera(shadowMapCullCamera);
            } else {
                const shadowMapRenderCamera = ShadowMapper.fetchCameraForScene(scene);
                const snapMatrix = ShadowMapper._snapMatrix;
                shadowMapRenderCamera.clipMask = AABB.ClipLeft | AABB.ClipRight | AABB.ClipBottom | AABB.ClipTop;
                if (this._light.isDirectionLight()) {
                    this.createLightCameraDirectional(shadowRegion, camera, shadowMapRenderCamera, snapMatrix, shadowMapParams.impl.getShadowMapBorder(shadowMapParams));
                } else {
                    this.createLightCameraSpot(shadowMapRenderCamera);
                }
                this.calcDepthBiasParams(shadowMapRenderCamera, this._config.shadowMapSize, this._config.depthBias, this._config.normalBias, depthScale, shadowMapParams.depthBiasValues[0]);
                shadowMapParams.cameraParams.setXYZW(shadowMapRenderCamera.getNearPlane(), shadowMapRenderCamera.getFarPlane(), this._config.shadowMapSize, this._shadowDistance);
                device.setFramebuffer(fb);
                shadowMapRenderCamera.setProjectionMatrix(Matrix4x4.multiply(snapMatrix, shadowMapRenderCamera.getProjectionMatrix()));
                ctx.camera = shadowMapRenderCamera;
                renderPass.render(ctx);
                shadowMapParams.shadowMatrices.set(Matrix4x4.transpose(shadowMapRenderCamera.viewProjectionMatrix));
                ShadowMapper.releaseCamera(shadowMapRenderCamera);
            }
        }
        ctx.camera = camera;
        this.postRenderShadowMap(shadowMapParams);
    }
    /** @internal */ applyMode(mode) {
        if (mode !== 'hard' && mode !== 'vsm' && mode !== 'esm' && mode !== 'pcf-pd' && mode !== 'pcf-opt') {
            console.error(`ShadowMapper.setShadowMode() failed: invalid mode: ${mode}`);
            return;
        }
        this._impl = null;
        if (mode === 'hard') {
            this._impl = new SSM();
        } else if (mode === 'vsm') {
            this._impl = new VSM(this._vsmBlurKernelSize, this._vsmBlurRadius, this._vsmDarkness);
        } else if (mode === 'esm') {
            this._impl = new ESM(this._esmBlurKernelSize, this._esmBlurRadius, this._esmDepthScale);
        } else if (mode === 'pcf-pd') {
            this._impl = new PCFPD(this._pdSampleCount, this._pdSampleRadius);
        } else if (mode === 'pcf-opt') {
            this._impl = new PCFOPT(this._pcfKernelSize);
        }
    }
    /** @internal */ asVSM() {
        return this._impl?.getType() === 'vsm' ? this._impl : null;
    }
    /** @internal */ asESM() {
        return this._impl?.getType() === 'esm' ? this._impl : null;
    }
    /** @internal */ asPCFPD() {
        return this._impl?.getType() === 'pcf-pd' ? this._impl : null;
    }
    /** @internal */ asPCFOPT() {
        return this._impl?.getType() === 'pcf-opt' ? this._impl : null;
    }
}

class ClusteredLight {
    _tileCountX;
    _tileCountY;
    _tileCountZ;
    _lights;
    _lightIndexTexture;
    _lightIndexFramebuffer;
    _lightIndexProgram;
    _bindGroup;
    _lightIndexVertexLayout;
    _lightIndexRenderStates;
    _lightBuffer;
    _sizeParam;
    _countParam;
    _clusterParam;
    constructor(){
        this._tileCountX = 16;
        this._tileCountY = 16;
        this._tileCountZ = 32;
        this._lights = new Float32Array(12 * (MAX_CLUSTERED_LIGHTS + 1));
        this._lightIndexTexture = null;
        this._lightIndexFramebuffer = null;
        this._lightIndexProgram = null;
        this._lightBuffer = null;
        this._bindGroup = null;
        this._lightIndexVertexLayout = null;
        this._lightIndexRenderStates = null;
        this._sizeParam = new Vector4();
        this._countParam = new Int32Array(4);
        this._clusterParam = new Vector4();
    }
    get lightBuffer() {
        return this._lightBuffer;
    }
    get clusterParam() {
        return this._clusterParam;
    }
    get countParam() {
        return this._countParam;
    }
    get lightIndexTexture() {
        return this._lightIndexTexture;
    }
    createVertexLayout(device, textureWidth, textureHeight) {
        let vb;
        if (device.type === 'webgl') {
            const vertices = new Float32Array(this._tileCountX * this._tileCountY * this._tileCountZ * 3);
            for(let i = 0; i < vertices.length; i++){
                const ix = i % textureWidth;
                const iy = Math.floor(i / textureWidth);
                vertices[i * 3 + 0] = 2 * (ix + 0.5) / textureWidth - 1;
                vertices[i * 3 + 1] = 2 * (iy + 0.5) / textureHeight - 1;
                vertices[i * 3 + 2] = i;
            }
            vb = device.createVertexBuffer('position_f32x3', vertices);
        } else {
            const vertices = new Float32Array(this._tileCountX * this._tileCountY * this._tileCountZ * 2);
            for(let i = 0; i < vertices.length; i++){
                const ix = i % textureWidth;
                const iy = Math.floor(i / textureWidth);
                vertices[i * 2 + 0] = 2 * (ix + 0.5) / textureWidth - 1;
                vertices[i * 2 + 1] = 2 * (iy + 0.5) / textureHeight - 1;
            }
            vb = device.createVertexBuffer('position_f32x2', vertices);
        }
        this._lightIndexVertexLayout = device.createVertexLayout({
            vertexBuffers: [
                {
                    buffer: vb
                }
            ]
        });
    }
    createRenderState(device) {
        this._lightIndexRenderStates = device.createRenderStateSet();
        this._lightIndexRenderStates.useDepthState().enableTest(false).enableWrite(false);
        this._lightIndexRenderStates.useRasterizerState().setCullMode('none');
    }
    createProgram(device) {
        const webgl1 = device.type === 'webgl';
        this._lightIndexProgram = device.buildRenderProgram({
            vertex (pb) {
                this.$inputs.pos = (webgl1 ? pb.vec3() : pb.vec2()).attrib('position');
                this.$outputs.value = webgl1 ? pb.vec4() : pb.uvec4();
                this.invProjMatrix = pb.mat4().uniform(0);
                this.viewMatrix = pb.mat4().uniform(0);
                this.sizeParam = pb.vec4().uniform(0);
                this.countParam = pb.ivec4().uniform(0);
                this[ShaderHelper.getLightBufferUniformName()] = pb.vec4[(MAX_CLUSTERED_LIGHTS + 1) * 3]().uniformBuffer(0);
                pb.func('lineIntersectionToZPlane', [
                    pb.vec3('a'),
                    pb.vec3('b'),
                    pb.float('zDistance')
                ], function() {
                    this.$l.normal = pb.vec3(0, 0, 1);
                    this.$l.ab = pb.sub(this.b, this.a);
                    this.$l.t = pb.div(pb.sub(this.zDistance, pb.dot(this.normal, this.a)), pb.dot(this.normal, this.ab));
                    this.$return(pb.add(this.a, pb.mul(this.t, this.ab)));
                });
                pb.func('clipToView', [
                    pb.vec4('clip')
                ], function() {
                    this.$l.view = pb.mul(this.invProjMatrix, this.clip);
                    this.$return(pb.div(this.view, this.view.w));
                });
                pb.func('screenToView', [
                    pb.vec4('screen')
                ], function() {
                    this.$l.texCoord = pb.div(this.screen.xy, this.sizeParam.xy);
                    this.$l.clip = pb.vec4(pb.sub(pb.mul(pb.vec2(this.texCoord.x, pb.sub(1, this.texCoord.y)), 2), pb.vec2(1)), this.screen.z, this.screen.w);
                    this.$return(this.clipToView(this.clip));
                });
                pb.func('sphereIntersectsAABB', [
                    pb.vec4('sphere'),
                    pb.vec3('aabbMin'),
                    pb.vec3('aabbMax')
                ], function() {
                    this.$l.dmin = pb.float(0);
                    this.$if(pb.lessThanEqual(this.sphere.w, 0), function() {
                        this.$return(true);
                    });
                    this.$for(pb.int('i'), 0, 3, function() {
                        this.$if(pb.lessThan(this.sphere.at(this.i), this.aabbMin.at(this.i)), function() {
                            this.$l.delta = pb.sub(this.sphere.at(this.i), this.aabbMin.at(this.i));
                            this.dmin = pb.add(this.dmin, pb.mul(this.delta, this.delta));
                        }).$elseif(pb.greaterThan(this.sphere.at(this.i), this.aabbMax.at(this.i)), function() {
                            this.$l.delta = pb.sub(this.sphere.at(this.i), this.aabbMax.at(this.i));
                            this.dmin = pb.add(this.dmin, pb.mul(this.delta, this.delta));
                        });
                    });
                    this.$if(pb.lessThanEqual(this.dmin, pb.mul(this.sphere.w, this.sphere.w)), function() {
                        this.$return(true);
                    });
                    this.$return(false);
                });
                pb.main(function() {
                    if (pb.getDevice().type !== 'webgpu') {
                        this.$builtins.pointSize = 1;
                    }
                    this.$builtins.position = pb.vec4(this.$inputs.pos.xy, 0, 1);
                    if (pb.getDevice().type === 'webgpu') {
                        this.$builtins.position = pb.mul(this.$builtins.position, pb.vec4(1, -1, 1, 1));
                    }
                    this.$l.tileIndex = webgl1 ? pb.int(this.$inputs.pos.z) : pb.int(this.$builtins.vertexIndex);
                    this.$l.tileSize = pb.div(this.sizeParam.xy, pb.vec2(this.countParam.xy));
                    this.$l.zIndex = pb.div(this.tileIndex, pb.mul(this.countParam.x, this.countParam.y));
                    this.$l.yIndex = pb.div(pb.sub(this.tileIndex, pb.mul(this.zIndex, this.countParam.x, this.countParam.y)), this.countParam.x);
                    this.$l.xIndex = pb.sub(this.tileIndex, pb.add(pb.mul(this.zIndex, this.countParam.x, this.countParam.y), pb.mul(this.yIndex, this.countParam.x)));
                    this.$l.maxPoint_sS = pb.vec4(pb.mul(pb.vec2(pb.float(pb.add(this.xIndex, 1)), pb.float(pb.add(this.yIndex, 1))), this.tileSize), 0.0, 1.0);
                    this.$l.minPoint_sS = pb.vec4(pb.mul(pb.vec2(pb.float(this.xIndex), pb.float(this.yIndex)), this.tileSize), 0.0, 1.0);
                    this.$l.maxPoint_vS = this.screenToView(this.maxPoint_sS).xyz;
                    this.$l.minPoint_vS = this.screenToView(this.minPoint_sS).xyz;
                    this.$l.tileNear = pb.mul(pb.neg(this.sizeParam.z), pb.pow(pb.div(this.sizeParam.w, this.sizeParam.z), pb.div(pb.float(this.zIndex), pb.float(this.countParam.z))));
                    this.$l.tileFar = pb.mul(pb.neg(this.sizeParam.z), pb.pow(pb.div(this.sizeParam.w, this.sizeParam.z), pb.div(pb.add(pb.float(this.zIndex), 1), pb.float(this.countParam.z))));
                    this.$l.eyePos = pb.vec3(0);
                    this.$l.minPointNear = this.lineIntersectionToZPlane(this.eyePos, this.minPoint_vS, this.tileNear);
                    this.$l.minPointFar = this.lineIntersectionToZPlane(this.eyePos, this.minPoint_vS, this.tileFar);
                    this.$l.maxPointNear = this.lineIntersectionToZPlane(this.eyePos, this.maxPoint_vS, this.tileNear);
                    this.$l.maxPointFar = this.lineIntersectionToZPlane(this.eyePos, this.maxPoint_vS, this.tileFar);
                    this.$l.aabbMin = pb.min(pb.min(this.minPointNear, this.minPointFar), pb.min(this.maxPointNear, this.maxPointFar));
                    this.$l.aabbMax = pb.max(pb.max(this.minPointNear, this.minPointFar), pb.max(this.maxPointNear, this.maxPointFar));
                    this.$l.n = pb.int(0);
                    if (webgl1) {
                        this.$l.lightIndices = pb.float[8]();
                        this.$for(pb.int('i'), 0, 8, function() {
                            this.lightIndices.setAt(this.i, 0);
                        });
                        this.$for(pb.int('i'), 1, 256, function() {
                            this.$if(pb.equal(this.i, this.countParam.w), function() {
                                this.$break();
                            });
                            this.$l.light = this[ShaderHelper.getLightBufferUniformName()].at(pb.mul(this.i, 3));
                            this.$l.lightPos = pb.mul(this.viewMatrix, pb.vec4(this.light.xyz, 1));
                            this.$l.lightPos.w = this.light.w;
                            this.$if(this.sphereIntersectsAABB(this.lightPos, this.aabbMin, this.aabbMax), function() {
                                this.$for(pb.int('j'), 0, 8, function() {
                                    this.$if(pb.equal(this.j, this.n), function() {
                                        this.lightIndices.setAt(this.j, pb.float(this.i));
                                        this.n = pb.add(this.n, 1);
                                        this.$break();
                                    });
                                });
                                this.$if(pb.equal(this.n, 8), function() {
                                    this.$break();
                                });
                            });
                        });
                        this.$outputs.value.r = pb.add(pb.mul(this.lightIndices[0], 256), this.lightIndices[1]);
                        this.$outputs.value.g = pb.add(pb.mul(this.lightIndices[2], 256), this.lightIndices[3]);
                        this.$outputs.value.b = pb.add(pb.mul(this.lightIndices[4], 256), this.lightIndices[5]);
                        this.$outputs.value.a = pb.add(pb.mul(this.lightIndices[6], 256), this.lightIndices[7]);
                    } else {
                        this.$l.lightIndex = [
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0),
                            pb.uint(0)
                        ];
                        this.$for(pb.uint('i'), 1, pb.uint(this.countParam.w), function() {
                            this.$l.light = this[ShaderHelper.getLightBufferUniformName()].at(pb.mul(this.i, 3));
                            this.$l.lightPos = pb.mul(this.viewMatrix, pb.vec4(this.light.xyz, 1));
                            this.$l.lightPos.w = this.light.w;
                            this.$if(this.sphereIntersectsAABB(this.lightPos, this.aabbMin, this.aabbMax), function() {
                                this.lightIndex.setAt(this.n, this.i);
                                this.n = pb.add(this.n, 1);
                                this.$if(pb.equal(this.n, 16), function() {
                                    this.$break();
                                });
                            });
                        });
                        this.$l.r = pb.add(pb.sal(this.lightIndex[0], 24), pb.sal(this.lightIndex[1], 16), pb.sal(this.lightIndex[2], 8), this.lightIndex[3]);
                        this.$l.g = pb.add(pb.sal(this.lightIndex[4], 24), pb.sal(this.lightIndex[5], 16), pb.sal(this.lightIndex[6], 8), this.lightIndex[7]);
                        this.$l.b = pb.add(pb.sal(this.lightIndex[8], 24), pb.sal(this.lightIndex[9], 16), pb.sal(this.lightIndex[10], 8), this.lightIndex[11]);
                        this.$l.a = pb.add(pb.sal(this.lightIndex[12], 24), pb.sal(this.lightIndex[13], 16), pb.sal(this.lightIndex[14], 8), this.lightIndex[15]);
                        this.$outputs.value = pb.uvec4(this.r, this.g, this.b, this.a);
                    }
                });
            },
            fragment (pb) {
                this.$outputs.color = webgl1 ? pb.vec4() : pb.uvec4();
                pb.main(function() {
                    this.$outputs.color = this.$inputs.value;
                });
            }
        });
        this._bindGroup = device.createBindGroup(this._lightIndexProgram.bindGroupLayouts[0]);
        this._lightBuffer?.dispose();
        const lightBufferType = this._lightIndexProgram.getBindingInfo(ShaderHelper.getLightBufferUniformName()).type;
        this._lightBuffer = device.createStructuredBuffer(lightBufferType, {
            usage: 'uniform'
        });
    }
    createLightIndexTexture(device) {
        const exp = Math.log2(this._tileCountX * this._tileCountY * this._tileCountZ);
        const a = exp + 1 >>> 1;
        const b = exp - a;
        const textureWidth = 2 << a - 1;
        const textureHeight = 2 << b - 1;
        if (textureWidth * textureHeight !== this._tileCountX * this._tileCountY * this._tileCountZ) {
            throw new Error('Internal error');
        }
        this._lightIndexTexture = device.createTexture2D(device.type === 'webgl' ? 'rgba32f' : 'rgba32ui', textureWidth, textureHeight, {
            samplerOptions: {
                mipFilter: 'none'
            }
        });
        this._lightIndexTexture.name = 'ClusterLightIndex';
        this._lightIndexFramebuffer?.dispose();
        this._lightIndexFramebuffer = device.createFrameBuffer([
            this._lightIndexTexture
        ], null);
    }
    calculateLightIndex(camera, renderQueue) {
        const numLights = this.getVisibleLights(renderQueue, this._lights);
        const device = Application.instance.device;
        if (!this._lightIndexTexture) {
            this.createLightIndexTexture(device);
        }
        if (!this._lightIndexProgram) {
            this.createProgram(device);
        }
        if (!this._lightIndexVertexLayout) {
            this.createVertexLayout(device, this._lightIndexTexture.width, this._lightIndexTexture.height);
        }
        if (!this._lightIndexRenderStates) {
            this.createRenderState(device);
        }
        const viewport = device.getViewport();
        const vw = device.screenToDevice(viewport.width);
        const vh = device.screenToDevice(viewport.height);
        const scale = this._tileCountZ / Math.log2(camera.getFarPlane() / camera.getNearPlane());
        const bias = -(this._tileCountZ * Math.log2(camera.getNearPlane()) / Math.log2(camera.getFarPlane() / camera.getNearPlane()));
        this._clusterParam.setXYZW(vw, vh, scale, bias);
        device.pushDeviceStates();
        device.setFramebuffer(this._lightIndexFramebuffer);
        if (numLights > 0) {
            this._lightBuffer.bufferSubData(0, this._lights);
            this._sizeParam.setXYZW(vw, vh, camera.getNearPlane(), camera.getFarPlane());
            this._countParam[0] = this._tileCountX;
            this._countParam[1] = this._tileCountY;
            this._countParam[2] = this._tileCountZ;
            this._countParam[3] = numLights + 1;
            this._bindGroup.setValue('invProjMatrix', Matrix4x4.invert(camera.getProjectionMatrix()));
            this._bindGroup.setValue('viewMatrix', camera.viewMatrix);
            this._bindGroup.setValue('sizeParam', this._sizeParam);
            this._bindGroup.setValue('countParam', this._countParam);
            this._bindGroup.setBuffer(ShaderHelper.getLightBufferUniformName(), this._lightBuffer);
            device.setProgram(this._lightIndexProgram);
            device.setVertexLayout(this._lightIndexVertexLayout);
            device.setBindGroup(0, this._bindGroup);
            const savedRS = device.getRenderStates();
            device.setRenderStates(this._lightIndexRenderStates);
            device.draw('point-list', 0, this._tileCountX * this._tileCountY * this._tileCountZ);
            device.setRenderStates(savedRS);
        } else {
            device.clearFrameBuffer(new Vector4(0, 0, 0, 0), 1, 0);
        }
        device.popDeviceStates();
    }
    getVisibleLights(renderQueue, lights) {
        const numLights = Math.min(renderQueue.unshadowedLights.length, MAX_CLUSTERED_LIGHTS);
        for(let i = 1; i <= numLights; i++){
            const light = renderQueue.unshadowedLights[i - 1];
            lights.set(light.positionAndRange, i * 12);
            lights.set(light.directionAndCutoff, i * 12 + 4);
            lights.set(light.diffuseAndIntensity, i * 12 + 8);
        }
        return numLights;
    }
}

class GlobalBindGroupAllocator {
    static _layouts = {};
    static _allocators = [];
    _bindGroups;
    constructor(){
        this._bindGroups = {};
    }
    static get() {
        return this._allocators.pop() ?? new GlobalBindGroupAllocator();
    }
    static release(allocator) {
        this._allocators.push(allocator);
    }
    /**
   * Allocate global bind group according to current draw context
   * @param ctx - Draw context
   * @returns Global bind group
   */ getGlobalBindGroup(ctx) {
        const hash = ctx.renderPassHash;
        let bindGroup = this._bindGroups[hash];
        if (!bindGroup) {
            let layout = GlobalBindGroupAllocator._layouts[hash];
            if (!layout) {
                const ret = ctx.device.programBuilder.buildRender({
                    vertex (pb) {
                        ShaderHelper.prepareVertexShader(pb, ctx);
                        pb.main(function() {});
                    },
                    fragment (pb) {
                        ShaderHelper.prepareFragmentShader(pb, ctx);
                        pb.main(function() {});
                    }
                });
                layout = ret[2][0];
                GlobalBindGroupAllocator._layouts[hash] = layout;
            }
            bindGroup = ctx.device.createBindGroup(layout);
            this._bindGroups[hash] = bindGroup;
        }
        return bindGroup;
    }
}

/**
 * Forward render scheme
 * @internal
 */ class SceneRenderer {
    /** @internal */ static _scenePass = new LightPass();
    /** @internal */ static _depthPass = new DepthPass();
    /** @internal */ static _shadowMapPass = new ShadowMapPass();
    /** @internal */ static _clusters = [];
    /** lighting render pass */ static get sceneRenderPass() {
        return this._scenePass;
    }
    /** depth render pass */ static get depthRenderPass() {
        return this._depthPass;
    }
    /** shadow map render pass */ static get shadowMapRenderPass() {
        return this._shadowMapPass;
    }
    /** @internal */ static setClearColor(color) {
        this._scenePass.clearColor = color;
    }
    /** @internal */ static getClusteredLight() {
        if (this._clusters.length > 0) {
            return this._clusters.pop();
        }
        return new ClusteredLight();
    }
    /** @internal */ static freeClusteredLight(clusteredLight) {
        this._clusters.push(clusteredLight);
    }
    /**
   * Renders a scene by given camera
   * @param scene - The scene to be rendered
   * @param camera - The camera that will be used to render the scene
   * @param compositor - The compositor that will be used to apply postprocess effects
   */ static renderScene(scene, camera, compositor, logger) {
        const device = Application.instance.device;
        const ctx = {
            device,
            scene,
            primaryCamera: camera,
            oit: null,
            globalBindGroupAllocator: GlobalBindGroupAllocator.get(),
            camera,
            compositor: compositor?.needDrawPostEffects() ? compositor : null,
            timestamp: device.frameInfo.frameTimestamp,
            logger,
            queue: 0,
            lightBlending: false,
            renderPass: null,
            renderPassHash: null,
            applyFog: null,
            flip: false,
            drawEnvLight: false,
            env: null
        };
        scene.frameUpdate();
        if (camera && !device.isContextLost()) {
            this._renderScene(ctx);
        }
        GlobalBindGroupAllocator.release(ctx.globalBindGroupAllocator);
    }
    /** @internal */ static _renderSceneDepth(ctx, renderQueue, depthFramebuffer) {
        const device = ctx.device;
        device.pushDeviceStates();
        device.setFramebuffer(depthFramebuffer);
        this._depthPass.clearColor = device.type === 'webgl' ? new Vector4(0, 0, 0, 1) : new Vector4(1, 1, 1, 1);
        this._depthPass.render(ctx, null, renderQueue);
        device.popDeviceStates();
    }
    /** @internal */ static _renderScene(ctx) {
        const device = ctx.device;
        const vp = ctx.camera.viewport;
        const scissor = ctx.camera.scissor;
        const finalFramebuffer = device.getFramebuffer();
        const drawingBufferWidth = device.getDrawingBufferWidth();
        const drawingBufferHeight = device.getDrawingBufferHeight();
        ctx.depthFormat = 'd24s8';
        ctx.viewportX = finalFramebuffer ? vp?.[0] ?? 0 : device.screenToDevice(vp?.[0] ?? 0);
        ctx.viewportY = finalFramebuffer ? vp?.[1] ?? 0 : device.screenToDevice(vp?.[1] ?? 0);
        ctx.viewportWidth = finalFramebuffer ? vp?.[2] ?? finalFramebuffer.getWidth() : vp ? device.screenToDevice(vp[2]) : device.getDrawingBufferWidth();
        ctx.viewportHeight = finalFramebuffer ? vp?.[3] ?? finalFramebuffer.getHeight() : vp ? device.screenToDevice(vp[3]) : device.getDrawingBufferHeight();
        ctx.defaultViewport = !finalFramebuffer && !vp;
        const oversizedViewport = vp && !device.getDeviceCaps().miscCaps.supportOversizedViewport && (ctx.viewportX < 0 || ctx.viewportY < 0 || ctx.viewportX + ctx.viewportWidth > drawingBufferWidth || ctx.viewportY + ctx.viewportHeight > drawingBufferHeight);
        // TODO: determin the color buffer format
        const colorFmt = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? 'rgba16f' : 'rgba8unorm';
        let tempFramebuffer = null;
        let depthFramebuffer = null;
        const renderQueue = this._scenePass.cullScene(ctx, ctx.camera);
        ctx.sunLight = renderQueue.sunLight;
        ctx.clusteredLight = this.getClusteredLight();
        ctx.clusteredLight.calculateLightIndex(ctx.camera, renderQueue);
        this.renderShadowMaps(ctx, renderQueue.shadowedLights);
        const sampleCount = ctx.compositor ? 1 : ctx.primaryCamera.sampleCount;
        if (ctx.primaryCamera.depthPrePass || oversizedViewport || ctx.scene.env.needSceneDepthTexture() || ctx.primaryCamera.oit || ctx.compositor?.requireLinearDepth()) {
            const format = device.type === 'webgl' ? 'rgba8unorm' : 'r32f';
            if (!finalFramebuffer && !vp) {
                depthFramebuffer = TemporalCache.getFramebufferVariantSize(drawingBufferWidth, drawingBufferHeight, 1, format, ctx.depthFormat, '2d', '2d', false);
            } else {
                const originDepth = finalFramebuffer?.getDepthAttachment();
                depthFramebuffer = originDepth?.isTexture2D() ? TemporalCache.getFramebufferFixedSizeWithDepth(originDepth, 1, format, '2d', false) : TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false);
            }
            this._renderSceneDepth(ctx, renderQueue, depthFramebuffer);
            ctx.linearDepthTexture = depthFramebuffer.getColorAttachments()[0];
            ctx.depthTexture = depthFramebuffer.getDepthAttachment();
            if (ctx.depthTexture === finalFramebuffer?.getDepthAttachment()) {
                tempFramebuffer = finalFramebuffer;
            } else {
                if (ctx.defaultViewport) {
                    tempFramebuffer = TemporalCache.getFramebufferVariantSize(ctx.depthTexture.width, ctx.depthTexture.height, 1, colorFmt, ctx.depthFormat, '2d', '2d', false, sampleCount);
                } else {
                    tempFramebuffer = TemporalCache.getFramebufferFixedSize(ctx.depthTexture.width, ctx.depthTexture.height, 1, colorFmt, ctx.depthFormat, '2d', '2d', false, sampleCount);
                }
            }
        } else {
            ctx.linearDepthTexture = null;
            ctx.depthTexture = null;
            if (!vp) {
                tempFramebuffer = finalFramebuffer;
            } else {
                tempFramebuffer = TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, colorFmt, ctx.depthFormat, '2d', '2d', false, sampleCount);
            }
        }
        if (tempFramebuffer && tempFramebuffer !== finalFramebuffer) {
            device.pushDeviceStates();
            device.setFramebuffer(tempFramebuffer);
        } else {
            device.setViewport(vp);
            device.setScissor(scissor);
        }
        this._scenePass.clearDepth = 1; //ctx.depthTexture ? null : 1;
        this._scenePass.clearStencil = 0; //ctx.depthTexture ? null : 0;
        ctx.compositor?.begin(ctx);
        this._scenePass.render(ctx, null, renderQueue);
        ctx.compositor?.end(ctx);
        renderQueue.dispose();
        if (tempFramebuffer && tempFramebuffer !== finalFramebuffer) {
            const blitter = new CopyBlitter();
            if (oversizedViewport) {
                blitter.destRect = [
                    ctx.viewportX,
                    ctx.viewportY,
                    ctx.viewportWidth,
                    ctx.viewportHeight
                ];
            } else {
                blitter.viewport = vp;
            }
            blitter.scissor = scissor;
            blitter.srgbOut = !finalFramebuffer;
            const srcTex = tempFramebuffer.getColorAttachments()[0];
            blitter.blit(srcTex, finalFramebuffer ?? null, device.createSampler({
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none'
            }));
            device.popDeviceStates();
        }
        if (depthFramebuffer) {
            TemporalCache.releaseFramebuffer(depthFramebuffer);
        }
        if (tempFramebuffer && tempFramebuffer !== finalFramebuffer) {
            TemporalCache.releaseFramebuffer(tempFramebuffer);
        }
        ShadowMapper.releaseTemporalResources(ctx);
        this.freeClusteredLight(ctx.clusteredLight);
    }
    /** @internal */ static renderShadowMaps(ctx, lights) {
        ctx.renderPass = this._shadowMapPass;
        ctx.device.pushDeviceStates();
        for (const light of lights){
            light.shadow.render(ctx, this._shadowMapPass);
        }
        ctx.device.popDeviceStates();
    }
}

/**
 * Base class for any kind of environment light
 * @public
 */ class EnvironmentLighting {
    /**
   * Whether this is an instance of EnvIBL
   * @returns true if this is an instance of EnvIBL
   */ isIBL() {
        return false;
    }
    /**
   * Whether this is an instance of EnvConstantAmbient
   * @returns true if this is an instance of EnvConstantAmbient
   */ isConstant() {
        return false;
    }
    /**
   * Whether this is an instance of EnvHemisphericAmbient
   * @returns true if this is an instance of EnvHemisphericAmbient
   */ isHemispheric() {
        return false;
    }
}
/**
 * IBL based environment lighting
 * @public
 */ class EnvIBL extends EnvironmentLighting {
    /** @internal */ static UNIFORM_NAME_IBL_RADIANCE_MAP = 'zIBLRadianceMap';
    /** @internal */ static UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD = 'zIBLRadianceMapMaxLOD';
    /** @internal */ static UNIFORM_NAME_IBL_IRRADIANCE_MAP = 'zIBLIrradianceMap';
    /** @internal */ _radianceMap;
    /** @internal */ _irradianceMap;
    /**
   * Creates an instance of EnvIBL
   * @param radianceMap - The radiance map
   * @param irradianceMap - The irradiance map
   */ constructor(radianceMap, irradianceMap){
        super();
        this._radianceMap = radianceMap || null;
        this._irradianceMap = irradianceMap || null;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getType}
   * @override
   */ getType() {
        return 'ibl';
    }
    /** The radiance map */ get radianceMap() {
        return this._radianceMap;
    }
    set radianceMap(tex) {
        this._radianceMap = tex;
    }
    /** The irradiance map */ get irradianceMap() {
        return this._irradianceMap;
    }
    set irradianceMap(tex) {
        this._irradianceMap = tex;
    }
    /**
   * {@inheritDoc EnvironmentLighting.initShaderBindings}
   * @override
   */ initShaderBindings(pb) {
        if (pb.shaderKind === 'fragment') {
            if (this._radianceMap) {
                pb.getGlobalScope()[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP] = pb.texCube().uniform(0);
                pb.getGlobalScope()[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD] = pb.float().uniform(0);
            }
            if (this._irradianceMap) {
                pb.getGlobalScope()[EnvIBL.UNIFORM_NAME_IBL_IRRADIANCE_MAP] = pb.texCube().uniform(0);
            }
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.updateBindGroup}
   * @override
   */ updateBindGroup(bg) {
        if (this._radianceMap) {
            bg.setValue(EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD, this._radianceMap.mipLevelCount - 1);
            bg.setTexture(EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP, this._radianceMap);
        }
        if (this._irradianceMap) {
            bg.setTexture(EnvIBL.UNIFORM_NAME_IBL_IRRADIANCE_MAP, this._irradianceMap);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.getRadiance}
   * @override
   */ getRadiance(scope, refl, roughness) {
        const pb = scope.$builder;
        return Application.instance.device.getDeviceCaps().shaderCaps.supportShaderTextureLod ? pb.textureSampleLevel(scope[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP], refl, pb.mul(roughness, scope[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP_MAX_LOD])).rgb : pb.textureSample(scope[EnvIBL.UNIFORM_NAME_IBL_RADIANCE_MAP], refl).rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getIrradiance}
   * @override
   */ getIrradiance(scope, normal) {
        const pb = scope.$builder;
        return pb.textureSampleLevel(scope[EnvIBL.UNIFORM_NAME_IBL_IRRADIANCE_MAP], normal, 0).rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasRadiance}
   * @override
   */ hasRadiance() {
        return !!this._radianceMap;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasIrradiance}
   * @override
   */ hasIrradiance() {
        return !!this._irradianceMap;
    }
    /**
   * {@inheritDoc EnvironmentLighting.isIBL}
   * @override
   */ isIBL() {
        return true;
    }
}
/**
 * Constant ambient light
 * @public
 */ class EnvConstantAmbient extends EnvironmentLighting {
    /** @internal */ static UNIFORM_NAME_CONSTANT_AMBIENT = 'zConstantAmbient';
    /** @internal */ _ambientColor;
    /**
   * Creates an instance of EnvConstantAmbient
   * @param ambientColor - The ambient color
   */ constructor(ambientColor){
        super();
        this._ambientColor = ambientColor ? new Vector4(ambientColor) : new Vector4(0, 0, 0, 1);
    }
    /** The ambient color */ get ambientColor() {
        return this._ambientColor;
    }
    set ambientColor(ambientColor) {
        if (ambientColor) {
            this._ambientColor.set(ambientColor);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.getType}
   * @override
   */ getType() {
        return 'constant';
    }
    /**
   * {@inheritDoc EnvironmentLighting.initShaderBindings}
   * @override
   */ initShaderBindings(pb) {
        if (pb.shaderKind === 'fragment') {
            pb.getGlobalScope()[EnvConstantAmbient.UNIFORM_NAME_CONSTANT_AMBIENT] = pb.vec4().uniform(0);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.updateBindGroup}
   * @override
   */ updateBindGroup(bg) {
        bg.setValue(EnvConstantAmbient.UNIFORM_NAME_CONSTANT_AMBIENT, this._ambientColor);
    }
    /**
   * {@inheritDoc EnvironmentLighting.getRadiance}
   * @override
   */ getRadiance(scope, refl, roughness) {
        return null;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getIrradiance}
   * @override
   */ getIrradiance(scope, normal) {
        return scope[EnvConstantAmbient.UNIFORM_NAME_CONSTANT_AMBIENT].rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasRadiance}
   * @override
   */ hasRadiance() {
        return false;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasIrradiance}
   * @override
   */ hasIrradiance() {
        return true;
    }
    /**
   * {@inheritDoc EnvironmentLighting.isConstant}
   * @override
   */ isConstant() {
        return true;
    }
}
/**
 * Hemispheric ambient light
 * @public
 */ class EnvHemisphericAmbient extends EnvironmentLighting {
    /** @internal */ static UNIFORM_NAME_AMBIENT_UP = 'zHemisphericAmbientUp';
    /** @internal */ static UNIFORM_NAME_AMBIENT_DOWN = 'zHemisphericAmbientDown';
    /** @internal */ _ambientUp;
    /** @internal */ _ambientDown;
    /**
   * Creates an instance of EnvConstantAmbient
   * @param ambientUp - The upside ambient color
   * @param ambientDown - The downside ambient color
   */ constructor(ambientUp, ambientDown){
        super();
        this._ambientUp = new Vector4(ambientUp);
        this._ambientDown = new Vector4(ambientDown);
    }
    /** The upside ambient color */ get ambientUp() {
        return this._ambientUp;
    }
    set ambientUp(color) {
        if (color) {
            this._ambientUp.set(color);
        }
    }
    /** The downside ambient color */ get ambientDown() {
        return this._ambientDown;
    }
    set ambientDown(color) {
        if (color) {
            this._ambientDown.set(color);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.getType}
   * @override
   */ getType() {
        return 'hemisphere';
    }
    /**
   * {@inheritDoc EnvironmentLighting.initShaderBindings}
   * @override
   */ initShaderBindings(pb) {
        if (pb.shaderKind === 'fragment') {
            pb.getGlobalScope()[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_UP] = pb.vec4().uniform(0);
            pb.getGlobalScope()[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_DOWN] = pb.vec4().uniform(0);
        }
    }
    /**
   * {@inheritDoc EnvironmentLighting.updateBindGroup}
   * @override
   */ updateBindGroup(bg) {
        bg.setValue(EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_UP, this._ambientUp);
        bg.setValue(EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_DOWN, this._ambientDown);
    }
    /**
   * {@inheritDoc EnvironmentLighting.getRadiance}
   * @override
   */ getRadiance(scope, refl, roughness) {
        return null;
    }
    /**
   * {@inheritDoc EnvironmentLighting.getIrradiance}
   * @override
   */ getIrradiance(scope, normal) {
        const pb = scope.$builder;
        const factor = pb.add(pb.mul(normal.y, 0.5), 0.5);
        return pb.mix(scope[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_DOWN], scope[EnvHemisphericAmbient.UNIFORM_NAME_AMBIENT_UP], factor).rgb;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasRadiance}
   * @override
   */ hasRadiance() {
        return false;
    }
    /**
   * {@inheritDoc EnvironmentLighting.hasIrradiance}
   * @override
   */ hasIrradiance() {
        return true;
    }
    /**
   * {@inheritDoc EnvironmentLighting.isHemispheric}
   * @override
   */ isHemispheric() {
        return true;
    }
}

/** @internal */ class RaycastVisitor {
    /** @internal */ _ray;
    /** @internal */ _rayLocal;
    /** @internal */ _intersected;
    /** @internal */ _intersectedDist;
    constructor(ray, length){
        this._ray = ray;
        this._rayLocal = new Ray();
        this._intersected = null;
        this._intersectedDist = length;
    }
    get intersected() {
        return this._intersected;
    }
    get intersectedDist() {
        return this._intersectedDist;
    }
    get intersectedPoint() {
        return Vector3.add(this._ray.origin, Vector3.scale(this._ray.direction, this._intersectedDist));
    }
    visit(target) {
        if (target instanceof OctreeNode) {
            return this.visitOctreeNode(target);
        }
        if (target.isMesh()) {
            return this.visitMesh(target);
        } else if (target.isTerrain()) {
            return this.visitTerrain(target);
        }
        return false;
    }
    visitTerrain(node) {
        if (!node.hidden && node.pickable) {
            this._ray.transform(node.invWorldMatrix, this._rayLocal);
            const d = node.rayIntersect(this._rayLocal); // this._rayLocal.bboxIntersectionTestEx(node.getBoundingVolume().toAABB());
            if (d !== null && d < this._intersectedDist) {
                this._intersectedDist = d;
                this._intersected = node;
                return true;
            }
        }
        return false;
    }
    visitMesh(node) {
        if (!node.hidden && node.pickable) {
            this._ray.transform(node.invWorldMatrix, this._rayLocal);
            const d = node.primitive.raycast(this._rayLocal);
            if (d !== null && d < this._intersectedDist) {
                this._intersectedDist = d;
                this._intersected = node.getPickTarget() ?? node;
                return true;
            }
        }
        return false;
    }
    visitOctreeNode(node) {
        if (node.getLevel() === 0 || this._ray.bboxIntersectionTest(node.getBoxLoosed()) !== null) {
            const nodes = node.getNodes();
            for(let i = 0; i < nodes.length; i++){
                this.visit(nodes[i]);
            }
            return true;
        }
        return false;
    }
}

/**
 * Wrapper for environmant lighting
 * @public
 */ class EnvLightWrapper {
    _envLight;
    _ambientColor;
    _ambientDown;
    _ambientUp;
    _radianceMap;
    _irradianceMap;
    _strength;
    /** @internal */ constructor(){
        this._envLight = new EnvIBL();
        this._ambientColor = new Vector4(0.2, 0.2, 0.2, 1);
        this._ambientDown = new Vector4(0.2, 0.2, 0.2, 1);
        this._ambientUp = new Vector4(0.3, 0.5, 0.8, 1);
        this._radianceMap = null;
        this._irradianceMap = null;
        this._strength = 1;
    }
    /** @internal */ getHash(ctx) {
        return ctx.drawEnvLight ? `${this.type}:${this._envLight.hasRadiance() ? '1' : '0'}:${this._envLight.hasIrradiance() ? '1' : '0'}` : 'none';
    }
    /** @internal */ get envLight() {
        return this._envLight;
    }
    /** The strength of environment lighting */ get strength() {
        return this._strength;
    }
    set strength(val) {
        this._strength = val;
    }
    /** Ambient light color for environment light type constant */ get ambientColor() {
        return this._ambientColor.clone();
    }
    set ambientColor(val) {
        this._ambientColor.set(val);
        if (this.type === 'constant') {
            this._envLight.ambientColor = this._ambientColor;
        }
    }
    /** Up color for environment light type hemisphere */ get ambientUp() {
        return this._ambientUp.clone();
    }
    set ambientUp(val) {
        this._ambientUp.set(val);
        if (this.type === 'hemisphere') {
            this._envLight.ambientUp = this._ambientUp;
        }
    }
    /** Down color for environment light type hemisphere */ get ambientDown() {
        return this._ambientDown.clone();
    }
    set ambientDown(val) {
        this._ambientDown.set(val);
        if (this.type === 'hemisphere') {
            this._envLight.ambientDown = this._ambientDown;
        }
    }
    /** Radiance map for environment light type ibl */ get radianceMap() {
        return this._radianceMap;
    }
    set radianceMap(tex) {
        this._radianceMap = tex ?? null;
        if (this.type === 'ibl') {
            this._envLight.radianceMap = this._radianceMap;
        }
    }
    /** Irradiance map for environment light type ibl */ get irradianceMap() {
        return this._irradianceMap;
    }
    set irradianceMap(tex) {
        this._irradianceMap = tex ?? null;
        if (this.type === 'ibl') {
            this._envLight.irradianceMap = this._irradianceMap;
        }
    }
    /** The environment light type */ get type() {
        return this._envLight?.getType() ?? 'none';
    }
    set type(val) {
        switch(val){
            case 'none':
                this._envLight = null;
                break;
            case 'ibl':
                if (this._envLight?.getType() !== val) {
                    this._envLight = new EnvIBL(this._radianceMap, this._irradianceMap);
                }
                break;
            case 'constant':
                if (this._envLight?.getType() !== val) {
                    this._envLight = new EnvConstantAmbient(this._ambientColor);
                }
                break;
            case 'hemisphere':
                if (this._envLight?.getType() !== val) {
                    this._envLight = new EnvHemisphericAmbient(this._ambientUp, this._ambientDown);
                }
                break;
        }
    }
}
/**
 * Environment of scene
 * @public
 */ class Environment {
    _sky;
    _light;
    /** @internal */ constructor(){
        this._sky = new SkyRenderer();
        this._light = new EnvLightWrapper();
    }
    /** The sky renderer */ get sky() {
        return this._sky;
    }
    /** The environment lighting renderer */ get light() {
        return this._light;
    }
    /** @internal */ getHash(ctx) {
        return `${this.light?.getHash(ctx)}:${this._sky?.getHash(ctx)}`;
    }
    /** @internal */ needSceneDepthTexture() {
        return this._sky.fogType !== 'none';
    }
}

/**
 * Event that will be fired when the scene needs to be updated
 * @public
 */ class SceneUpdateEvent {
    static NAME = 'sceneupdate';
    scene;
    type = SceneUpdateEvent.NAME;
    constructor(scene){
        this.scene = scene;
    }
}
/**
 * Presents a world that manages a couple of objects that will be rendered
 * @public
 */ class Scene extends makeEventTarget(Object)() {
    /** @internal */ static _nextId = 0;
    /** @internal */ _rootNode;
    /** @internal */ _octree;
    /** @internal */ _nodePlaceList;
    /** @internal */ _env;
    /** @internal */ _updateEvent;
    /** @internal */ _updateFrame;
    /** @internal */ _animationSet;
    /** @internal */ _id;
    /**
   * Creates an instance of scene
   */ constructor(){
        super();
        this._id = ++Scene._nextId;
        this._octree = new Octree(this, 8, 8);
        this._nodePlaceList = new Set();
        this._env = new Environment();
        this._updateEvent = new SceneUpdateEvent(this);
        this._updateFrame = -1;
        this._animationSet = [];
        this._rootNode = new SceneNode(this);
    }
    /** @internal */ get animationSet() {
        return this._animationSet;
    }
    /**
   * Gets the unique identifier of the scene
   */ get id() {
        return this._id;
    }
    /**
   * Gets the root scene node of the scene
   */ get rootNode() {
        return this._rootNode;
    }
    /**
   * Gets the octree
   */ get octree() {
        // Make sure the octree state is up to date
        this.updateNodePlacement(this._octree, this._nodePlaceList);
        return this._octree;
    }
    /**
   * Gets the bounding box of the scene
   */ get boundingBox() {
        this.updateNodePlacement(this._octree, this._nodePlaceList);
        // this._syncBVChangedList();
        return this._octree.getRootNode().getBoxLoosed();
    }
    /**
   * The environment of the scene
   */ get env() {
        return this._env;
    }
    /**
   * Disposes the scene
   */ dispose() {
        this._rootNode = null;
    }
    /**
   * Cast a ray into the scene to get the closest object hit by the ray
   * @param camera - The camera used to compute the ray
   * @param screenX - The x position on screen
   * @param screenY - The y position on screen
   * @returns The closest object hit by the ray
   */ raycast(camera, screenX, screenY) {
        const width = camera.viewport ? camera.viewport[2] : Application.instance.device.getViewport().width;
        const height = camera.viewport ? camera.viewport[3] : Application.instance.device.getViewport().height;
        const ray = this.constructRay(camera, width, height, screenX, screenY);
        const raycastVisitor = new RaycastVisitor(ray, camera.getFarPlane());
        this.octree.getRootNode().traverse(raycastVisitor);
        return raycastVisitor.intersected ? {
            node: raycastVisitor.intersected,
            dist: raycastVisitor.intersectedDist,
            point: raycastVisitor.intersectedPoint
        } : null;
    }
    /**
   * Constructs a ray by a given camera and the position on screen
   * @param camera - The camera used to compute the ray
   * @param viewportWidth - Width of the viewport
   * @param viewportHeight - Height of the viewport
   * @param screenX - The x position on screen
   * @param screenY - The y position on screen
   * @param invModelMatrix - A matrix used to transform the ray
   * @returns The constructed ray
   */ constructRay(camera, viewportWidth, viewportHeight, screenX, screenY, invModelMatrix) {
        const vClip = new Vector4(2 * screenX / viewportWidth - 1, 1 - 2 * screenY / viewportHeight, 1, 1);
        const vWorld = camera.invViewProjectionMatrix.transform(vClip);
        vWorld.scaleBy(1 / vWorld.w);
        let vEye = camera.getWorldPosition();
        let vDir = Vector3.sub(vWorld.xyz(), vEye).inplaceNormalize();
        if (invModelMatrix) {
            vEye = invModelMatrix.transformPointAffine(vEye);
            vDir = invModelMatrix.transformVectorAffine(vDir);
        }
        return new Ray(vEye, vDir);
    }
    /** @internal */ invalidateNodePlacement(node) {
        if (node.placeToOctree || node.octreeNode) {
            this._nodePlaceList.add(node);
        }
    }
    /** @internal */ frameUpdate() {
        const frameInfo = Application.instance.device.frameInfo;
        if (frameInfo.frameCounter !== this._updateFrame) {
            this._updateFrame = frameInfo.frameCounter;
            for (const an of this._animationSet){
                an.update();
            }
            // check environment lighting
            if (this.env.light.type === 'ibl') {
                if (!this.env.light.radianceMap) {
                    if (this.env.sky.skyType !== 'none') {
                        this.env.light.radianceMap = this.env.sky.radianceMap;
                    }
                } else if (this.env.light.radianceMap === this.env.sky.radianceMap) {
                    if (this.env.sky.skyType === 'none') {
                        this.env.light.radianceMap = null;
                    }
                }
                if (!this.env.light.irradianceMap) {
                    if (this.env.sky.skyType !== 'none') {
                        this.env.light.irradianceMap = this.env.sky.irradianceMap;
                    }
                } else if (this.env.light.irradianceMap === this.env.sky.irradianceMap) {
                    if (this.env.sky.skyType === 'none') {
                        this.env.light.irradianceMap = null;
                    }
                }
            }
            // update scene objects first
            this.dispatchEvent(this._updateEvent);
            this.updateNodePlacement(this._octree, this._nodePlaceList);
        }
    }
    /**
   * Update node placement in the octree
   */ updateNodePlacement(octree, list) {
        function placeNode(node, attached) {
            if (attached && !node.hidden && node.placeToOctree) {
                octree.placeNode(node);
            } else {
                octree.removeNode(node);
            }
            list.delete(node);
        }
        if (list.size > 0) {
            while(list.size > 0){
                const node = list.keys().next().value;
                if (octree) {
                    placeNode(node, node.attached);
                } else {
                    list.delete(node);
                }
            }
        }
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
/**
 * Graph scene node
 *
 * @remarks
 * Graph node is the base class of any kind of scene node that will be placed into the octree
 *
 * @public
 */ class GraphNode extends SceneNode {
    _octreeNode;
    /**
   * Creates a graph node
   * @param scene - The scene to which the node belongs
   */ constructor(scene){
        super(scene);
        this._renderOrder = 0;
        this._octreeNode = null;
    }
    /** @internal */ get octreeNode() {
        return this._octreeNode;
    }
    set octreeNode(node) {
        this._octreeNode = node;
    }
    /**
   * Render order of the node
   */ get renderOrder() {
        return this._renderOrder;
    }
    set renderOrder(val) {
        this._renderOrder = val;
    }
    /** Gets the name */ getName() {
        return this._name;
    }
    /**
   * {@inheritDoc SceneNode.isGraphNode}
   * @override
   */ isGraphNode() {
        return true;
    }
    /**
   * {@inheritDoc Drawable.getXForm}
   */ getXForm() {
        return this;
    }
    /**
   * {@inheritDoc Drawable.getBoneMatrices}
   */ getBoneMatrices() {
        return null;
    }
    /**
   * {@inheritDoc Drawable.getInvBindMatrix}
   */ getInvBindMatrix() {
        return null;
    }
    /**
   * {@inheritDoc Drawable.getSortDistance}
   */ getSortDistance(camera) {
        const cameraWorldMatrix = camera.worldMatrix;
        const objectWorldMatrix = this.worldMatrix;
        const dx = cameraWorldMatrix.m03 - objectWorldMatrix.m03;
        const dy = cameraWorldMatrix.m13 - objectWorldMatrix.m13;
        const dz = cameraWorldMatrix.m23 - objectWorldMatrix.m23;
        return dx * dx + dy * dy * dz * dz;
    }
    /**
   * {@inheritDoc Drawable.isBatchable}
   */ isBatchable() {
        return false;
    }
    /** @internal */ _visibleChanged() {
        this._scene?.invalidateNodePlacement(this);
    }
}

function mixinDrawable(baseCls) {
    const cls = class extends baseCls {
        _mdRenderQueueRef;
        _mdDrawableBindGroup;
        _mdDrawableBindGroupInstanced;
        _mdDrawableBindGroupSkin;
        constructor(...args){
            super(...args);
            this._mdRenderQueueRef = [];
            this._mdDrawableBindGroup = null;
            this._mdDrawableBindGroupInstanced = new Map();
            this._mdDrawableBindGroupSkin = null;
            this.getXForm().on('transformchanged', (node)=>{
                for (const ref of this._mdRenderQueueRef){
                    if (ref.ref) {
                        this.applyTransformUniforms(ref.ref);
                    }
                }
            });
        }
        pushRenderQueueRef(ref) {
            this.renderQueueRefPrune();
            this._mdRenderQueueRef.push(ref);
        }
        renderQueueRefPrune() {
            while(this._mdRenderQueueRef.length > 0){
                const ref = this._mdRenderQueueRef[this._mdRenderQueueRef.length - 1].ref;
                if (!ref) {
                    this._mdRenderQueueRef.pop();
                } else {
                    return ref;
                }
            }
            return null;
        }
        applyInstanceOffsetAndStride(renderQueue, stride, offset) {
            const drawableBindGroup = this.getDrawableBindGroup(Application.instance.device, true, renderQueue);
            drawableBindGroup.setValue(ShaderHelper.getInstanceDataStrideUniformName(), stride >> 2);
            drawableBindGroup.setValue(ShaderHelper.getInstanceDataOffsetUniformName(), offset >> 2);
        }
        applyTransformUniforms(renderQueue) {
            const instanceInfo = renderQueue.getInstanceInfo(this);
            const drawableBindGroup = this.getDrawableBindGroup(Application.instance.device, !!instanceInfo, renderQueue);
            if (instanceInfo) {
                instanceInfo.bindGroup.bindGroup.setRawData(ShaderHelper.getInstanceDataUniformName(), instanceInfo.offset * 4, this.getXForm().worldMatrix, 0, 16);
            } else {
                drawableBindGroup.setValue(ShaderHelper.getWorldMatrixUniformName(), this.getXForm().worldMatrix);
            }
        }
        applyMaterialUniforms(instanceInfo) {
            const uniforms = this.getInstanceUniforms();
            if (uniforms) {
                instanceInfo.bindGroup.bindGroup.setRawData(ShaderHelper.getInstanceDataUniformName(), (instanceInfo.offset + 16) * 4, uniforms, 0, uniforms.length);
            }
        }
        /** @internal */ bind(ctx) {
            const device = ctx.device;
            const drawableBindGroup = this.getDrawableBindGroup(device, !!ctx.instanceData, ctx.renderQueue);
            device.setBindGroup(1, drawableBindGroup);
            device.setBindGroup(3, ctx.instanceData ? ctx.instanceData.bindGroup.bindGroup : null);
            if (ctx.skinAnimation) {
                const boneTexture = this.getBoneMatrices();
                drawableBindGroup.setTexture(ShaderHelper.getBoneMatricesUniformName(), boneTexture);
                drawableBindGroup.setValue(ShaderHelper.getBoneInvBindMatrixUniformName(), this.getInvBindMatrix());
                drawableBindGroup.setValue(ShaderHelper.getBoneTextureSizeUniformName(), boneTexture.width);
            }
        }
        /** @internal */ getDrawableBindGroup(device, instancing, renderQueue) {
            const skinning = !!this.getBoneMatrices();
            let bindGroup = skinning ? this._mdDrawableBindGroupSkin : instancing ? this._mdDrawableBindGroupInstanced.get(renderQueue) : this._mdDrawableBindGroup;
            if (!bindGroup) {
                const buildInfo = new ProgramBuilder(device).buildRender({
                    vertex (pb) {
                        ShaderHelper.vertexShaderDrawableStuff(this, skinning, instancing);
                        pb.main(function() {});
                    },
                    fragment (pb) {
                        pb.main(function() {});
                    }
                });
                bindGroup = device.createBindGroup(buildInfo[2][1]);
                if (skinning) {
                    this._mdDrawableBindGroupSkin = bindGroup;
                } else if (instancing) {
                    this._mdDrawableBindGroupInstanced.set(renderQueue, bindGroup);
                } else {
                    this._mdDrawableBindGroup = bindGroup;
                }
            }
            return bindGroup;
        }
    };
    return cls;
}

/**
 * Mesh node
 * @public
 */ class Mesh extends applyMixins(GraphNode, mixinDrawable) {
    /** @internal */ _primitive;
    /** @internal */ _material;
    /** @internal */ _castShadow;
    /** @internal */ _bboxChangeCallback;
    /** @internal */ _animatedBoundingBox;
    /** @internal */ _boneMatrices;
    /** @internal */ _invBindMatrix;
    /** @internal */ _instanceHash;
    /** @internal */ _batchable;
    /** @internal */ _boundingBoxNode;
    /** @internal */ _instanceColor;
    /**
   * Creates an instance of mesh node
   * @param scene - The scene to which the mesh node belongs
   */ constructor(scene, primitive, material){
        super(scene);
        this._primitive = null;
        this._material = null;
        this._castShadow = true;
        this._animatedBoundingBox = null;
        this._boneMatrices = null;
        this._invBindMatrix = null;
        this._instanceHash = null;
        this._boundingBoxNode = null;
        this._instanceColor = Vector4.zero();
        this._batchable = Application.instance.deviceType !== 'webgl';
        this._bboxChangeCallback = this._onBoundingboxChange.bind(this);
        // use setter
        this.primitive = primitive ?? null;
        this.material = material ?? Mesh._getDefaultMaterial();
    }
    /**
   * {@inheritDoc Drawable.getName}
   */ getName() {
        return this._name;
    }
    /**
   * {@inheritDoc BatchDrawable.getInstanceId}
   */ getInstanceId(renderPass) {
        return `${this._instanceHash}:${this.worldMatrixDet >= 0}`;
    }
    /**
   * {@inheritDoc BatchDrawable.getInstanceUniforms}
   */ getInstanceUniforms() {
        return this.material.$instanceUniforms;
    }
    /**
   * {@inheritDoc Drawable.getInstanceColor}
   */ getInstanceColor() {
        return this._instanceColor;
    }
    /**
   * {@inheritDoc Drawable.getPickTarget }
   */ getPickTarget() {
        return this;
    }
    /** Wether the mesh node casts shadows */ get castShadow() {
        return this._castShadow;
    }
    set castShadow(b) {
        this._castShadow = b;
    }
    /** Primitive of the mesh */ get primitive() {
        return this._primitive;
    }
    set primitive(prim) {
        if (prim !== this._primitive) {
            if (this._primitive) {
                this._primitive.removeBoundingboxChangeCallback(this._bboxChangeCallback);
            }
            this._primitive = prim || null;
            if (this._primitive) {
                this._primitive.addBoundingboxChangeCallback(this._bboxChangeCallback);
            }
            this._instanceHash = this._primitive && this._material ? `${this.constructor.name}:${this._scene.id}:${this._primitive.id}:${this._material.instanceId}` : null;
            this.invalidateBoundingVolume();
        }
    }
    /** Material of the mesh */ get material() {
        return this._material;
    }
    set material(m) {
        if (this._material !== m) {
            this._material = m;
            this._instanceHash = this._primitive && this._material ? `${this.constructor.name}:${this._scene.id}:${this._primitive.id}:${this._material.instanceId}` : null;
        }
    }
    /** Wether to draw the bounding box of the mesh node */ get drawBoundingBox() {
        return !!this._boundingBoxNode;
    }
    set drawBoundingBox(val) {
        if (!!this._boundingBoxNode !== !!val) {
            if (!val) {
                this._boundingBoxNode.remove();
                this._boundingBoxNode = null;
            } else {
                if (!Mesh._defaultBoxFrame) {
                    Mesh._defaultBoxFrame = new BoxFrameShape({
                        size: 1
                    });
                }
                this._boundingBoxNode = new Mesh(this._scene, Mesh._defaultBoxFrame).reparent(this);
                this._boundingBoxNode.scale.set(this.getBoundingVolume().toAABB().size);
                this._boundingBoxNode.position.set(this.getBoundingVolume().toAABB().minPoint);
            }
        }
    }
    /**
   * {@inheritDoc SceneNode.isMesh}
   */ isMesh() {
        return true;
    }
    /**
   * Sets the bounding box for animation
   * @param bbox - The bounding box for animation
   */ setAnimatedBoundingBox(bbox) {
        this._animatedBoundingBox = bbox;
        this.invalidateBoundingVolume();
    }
    /**
   * Sets the texture that contains the bone matrices for skeletal animation
   * @param matrices - The texture that contains the bone matrices
   */ setBoneMatrices(matrices) {
        this._boneMatrices = matrices;
    }
    /**
   * Sets the inverse bind matrix for skeletal animation
   * @param matrix - The matrix to set
   */ setInvBindMatrix(matrix) {
        this._invBindMatrix = matrix;
    }
    /**
   * {@inheritDoc Drawable.isBatchable}
   */ isBatchable() {
        return this._batchable && !this._boneMatrices && this._material?.isBatchable();
    }
    /** Disposes the mesh node */ dispose() {
        this._primitive = null;
        this._material = null;
        super.dispose();
    }
    /**
   * {@inheritDoc Drawable.getQueueType}
   */ getQueueType() {
        return this.material?.getQueueType() ?? QUEUE_OPAQUE;
    }
    /**
   * {@inheritDoc Drawable.isUnlit}
   */ isUnlit() {
        return !this.material?.supportLighting();
    }
    /**
   * {@inheritDoc Drawable.draw}
   */ draw(ctx) {
        this.bind(ctx);
        this.material.draw(this.primitive, ctx);
    }
    /**
   * {@inheritDoc Drawable.getMaterial}
   */ getMaterial() {
        return this.material;
    }
    /**
   * {@inheritDoc Drawable.getBoneMatrices}
   */ getBoneMatrices() {
        return this._boneMatrices;
    }
    /**
   * {@inheritDoc Drawable.getInvBindMatrix}
   */ getInvBindMatrix() {
        return this._invBindMatrix;
    }
    /**
   * {@inheritDoc Drawable.getXForm}
   */ getXForm() {
        // mesh transform should be ignored when skinned
        return this;
    }
    /** @internal */ computeBoundingVolume(bv) {
        let bbox;
        if (this._animatedBoundingBox) {
            bbox = this._animatedBoundingBox;
        } else {
            const primitive = this.primitive;
            bbox = primitive ? primitive.getBoundingVolume() : null;
        }
        if (bbox && this._boundingBoxNode) {
            this._boundingBoxNode.scale.set(bbox.toAABB().size);
            this._boundingBoxNode.position.set(bbox.toAABB().minPoint);
        }
        return bbox;
    }
    /** @internal */ _onBoundingboxChange() {
        this.invalidateBoundingVolume();
    }
    /** @internal */ static _defaultMaterial = null;
    /** @internal */ static _defaultBoxFrame = null;
    /** @internal */ static _getDefaultMaterial() {
        if (!this._defaultMaterial) {
            this._defaultMaterial = new LambertMaterial();
        }
        return this._defaultMaterial;
    }
}

/**
 * Perspective camera class
 * @public
 */ class PerspectiveCamera extends Camera {
    /** @internal */ _near;
    _far;
    _fovY;
    _aspect;
    _window;
    /**
   * Creates an instance of PerspectiveCamera
   * @param scene - The scene that the camera belongs to.
   * @param fovY - A radian value indicates the field of view in Y axis
   * @param aspect - Aspect ratio of the perspective transform
   * @param near - The near clip plane
   * @param far - The far clip plane
   */ constructor(scene, fovY, aspect, near, far){
        super(scene);
        this._fovY = fovY;
        this._aspect = aspect;
        this._near = near;
        this._far = far;
        this._window = null;
        this._invalidate(true);
    }
    /** Sub-window of the frustum */ get window() {
        return this._window;
    }
    set window(val) {
        this._window = val ?? null;
        this._invalidate(true);
    }
    /** The near clip plane */ get near() {
        return this._near;
    }
    set near(val) {
        if (val !== this._near) {
            this._near = val;
            this._invalidate(true);
        }
    }
    /** The far clip plane */ get far() {
        return this._far;
    }
    set far(val) {
        if (val !== this._far) {
            this._far = val;
            this._invalidate(true);
        }
    }
    /** Radian value indicates the field of view in Y axis */ get fovY() {
        return this._fovY;
    }
    set fovY(val) {
        if (val === 0) {
            debugger;
        }
        if (val !== this._fovY) {
            this._fovY = val;
            this._invalidate(true);
        }
    }
    /** Aspect ratio of the perspective transform */ get aspect() {
        return this._aspect;
    }
    set aspect(val) {
        if (val !== this._aspect) {
            this._aspect = val;
            this._invalidate(true);
        }
    }
    /**
   * {@inheritDoc Camera.setPerspective}
   */ setPerspective(fovY, aspect, zNear, zFar) {
        if (fovY === 0) {
            debugger;
        }
        this._aspect = aspect;
        this._fovY = fovY;
        this._near = zNear;
        this._far = zFar;
        this._invalidate(true);
        return this;
    }
    /**
   * Not valid for PerspectiveCamera
   *
   * @remarks
   * This method is only valid for {@link Camera} class or {@link OrthoCamera} class.
   */ setOrtho(left, right, bottom, top, near, far) {
        throw new Error(`setOrtho() not allowed on PerspectiveCamera`);
    }
    /**
   * Setup a projection matrix for the camera
   * @param matrix - The projection matrix
   */ setProjectionMatrix(matrix) {
        if (matrix && matrix !== this._projMatrix && matrix.isPerspective()) {
            if (matrix.getFov() === 0) {
                debugger;
            }
            this._aspect = matrix.getAspect();
            this._fovY = matrix.getFov();
            this._near = matrix.getNearPlane();
            this._far = matrix.getFarPlane();
            this._invalidate(true);
        } else {
            throw new Error(`PerspectiveCamera.setProjectionMatrix(): param is not a perspective projection matrix`);
        }
    }
    /** @internal */ _computeProj() {
        const h = this._near * Math.tan(this._fovY * 0.5);
        const w = h * this._aspect;
        let left = -w;
        let right = w;
        let top = h;
        let bottom = -h;
        if (this._window) {
            const width = right - left;
            const height = top - bottom;
            left += width * this._window[0];
            bottom += height * this._window[1];
            right = left + width * this._window[2];
            top = bottom + height * this._window[3];
        }
        this._projMatrix.frustum(left, right, bottom, top, this._near, this._far);
    //this._projMatrix.perspective(this._fovY, this._aspect, this._near, this._far);
    }
}

/**
 * Base class for any kind of camera controllers
 * @public
 */ class BaseCameraController {
    /** @internal */ _camera;
    /**
   * Creates an instance of BaseCameraController
   */ constructor(){
        this._camera = null;
        this.reset();
    }
    /** @internal */ _getCamera() {
        return this._camera;
    }
    /** @internal */ _setCamera(camera) {
        if (this._camera !== camera) {
            this._camera = camera;
            this.reset();
        }
    }
    /**
   * Resets state
   */ reset() {}
    /** @internal */ onMouseDown(evt) {
        return this._onMouseDown(evt);
    }
    /** @internal */ onMouseUp(evt) {
        return this._onMouseUp(evt);
    }
    /** @internal */ onMouseWheel(evt) {
        return this._onMouseWheel(evt);
    }
    /** @internal */ onMouseMove(evt) {
        return this._onMouseMove(evt);
    }
    /** @internal */ onKeyDown(evt) {
        return this._onKeyDown(evt);
    }
    /** @internal */ onKeyUp(evt) {
        return this._onKeyUp(evt);
    }
    /**
   * Updates state
   */ update() {}
    /**
   * Mouse down event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseDown(evt) {
        return false;
    }
    /**
   * Mouse up event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseUp(evt) {
        return false;
    }
    /**
   * Mouse wheel event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseWheel(evt) {
        return false;
    }
    /**
   * Mouse move event handler
   * @param evt - Mouse event
   * @returns Boolean value indices whether this event was handled
   */ _onMouseMove(evt) {
        return false;
    }
    /**
   * Key down event handler
   * @param evt - Keyboard event
   * @returns Boolean value indices whether this event was handled
   */ _onKeyDown(evt) {
        return false;
    }
    /**
   * Key up event handler
   * @param evt - Keyboard event
   * @returns Boolean value indices whether this event was handled
   */ _onKeyUp(evt) {
        return false;
    }
}

/**
 * Orbit camera controller
 * @public
 */ class OrbitCameraController extends BaseCameraController {
    /** @internal */ options;
    /** @internal */ mouseDown;
    /** @internal */ lastMouseX;
    /** @internal */ lastMouseY;
    /** @internal */ rotateX;
    /** @internal */ rotateY;
    /** @internal */ eyePos;
    /** @internal */ upVector;
    /** @internal */ xVector;
    /** @internal */ target;
    /** @internal */ direction;
    /** @internal */ quat;
    /** @internal */ scale;
    /**
   * Creates an instance of OrbitCameraController
   * @param options - The creation options
   */ constructor(options){
        super();
        this.options = Object.assign({
            center: Vector3.zero(),
            distance: 1,
            damping: 0.1,
            moveSpeed: 0.2,
            rotateSpeed: 0.01,
            zoomSpeed: 1
        }, options || {});
        this.rotateX = 0;
        this.rotateY = 0;
        this.eyePos = new Vector3();
        this.upVector = Vector3.axisPY();
        this.xVector = new Vector3();
        this.target = new Vector3();
        this.direction = new Vector3();
        this.quat = new Quaternion();
        this.scale = 1;
    }
    /** Rotation center */ get center() {
        return this.options.center;
    }
    set center(val) {
        this.options.center.set(val);
    }
    /**
   * {@inheritDoc BaseCameraController.reset}
   * @override
   */ reset() {
        this.mouseDown = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.rotateX = 0;
        this.rotateY = 0;
        this.upVector = Vector3.axisPY();
        this.scale = 1;
        this._loadCameraParams();
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseDown}
   * @override
   */ _onMouseDown(evt) {
        if (evt.button === 0) {
            this.mouseDown = true;
            this.lastMouseX = evt.offsetX;
            this.lastMouseY = evt.offsetY;
            this.rotateX = 0;
            this.rotateY = 0;
            return true;
        }
        return false;
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseUp}
   * @override
   */ _onMouseUp(evt) {
        if (evt.button === 0 && this.mouseDown) {
            this.mouseDown = false;
            return true;
        }
        return false;
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseWheel}
   * @override
   */ _onMouseWheel(evt) {
        const factor = Math.pow(0.9, Math.abs(this.options.zoomSpeed));
        if (evt.deltaY > 0) {
            this.scale /= factor;
        } else {
            this.scale *= factor;
        }
        return true;
    }
    /**
   * {@inheritDoc BaseCameraController._onMouseMove}
   * @override
   */ _onMouseMove(evt) {
        if (this.mouseDown) {
            const dx = evt.offsetX - this.lastMouseX;
            const dy = evt.offsetY - this.lastMouseY;
            this.lastMouseX = evt.offsetX;
            this.lastMouseY = evt.offsetY;
            this.rotateX -= dy * this.options.rotateSpeed;
            this.rotateY -= dx * this.options.rotateSpeed;
            return true;
        }
        return false;
    }
    /** @internal */ _loadCameraParams() {
        const camera = this._getCamera();
        if (camera) {
            this.eyePos = this._getCamera().position;
            this.target.set(this.options.center);
            camera.lookAt(this.eyePos, this.target, this.upVector);
            Vector3.sub(this.eyePos, this.target, this.direction);
            this.options.distance = this.direction.magnitude;
            this.direction.inplaceNormalize();
            const mat = this._getCamera().localMatrix;
            this.xVector.setXYZ(mat[0], mat[1], mat[2]);
        }
    }
    /**
   * Set options
   * @param opt - options
   */ setOptions(opt) {
        opt && Object.assign(this.options, opt);
        this.reset();
    }
    /**
   * {@inheritDoc BaseCameraController.update}
   * @override
   */ update() {
        if (this._getCamera()) {
            const dx = this.options.center.x - this.target.x;
            const dy = this.options.center.y - this.target.y;
            const dz = this.options.center.z - this.target.z;
            this.eyePos.x += dx;
            this.eyePos.y += dy;
            this.eyePos.z += dz;
            this.target.set(this.options.center);
            Quaternion.fromAxisAngle(this.xVector, this.rotateX, this.quat);
            this.quat.transform(this.eyePos.subBy(this.target), this.eyePos);
            Quaternion.fromEulerAngle(0, this.rotateY, 0, 'XYZ', this.quat);
            this.quat.transform(this.eyePos, this.eyePos);
            this.quat.transform(this.xVector, this.xVector).inplaceNormalize();
            Vector3.normalize(this.eyePos, this.direction).inplaceNormalize();
            Vector3.cross(this.direction, this.xVector, this.upVector).inplaceNormalize();
            Vector3.add(this.target, Vector3.scale(this.direction, this.options.distance * this.scale), this.eyePos);
            this._getCamera().lookAt(this.eyePos, this.target, this.upVector);
            // this._loadCameraParams();
            if (this.mouseDown) {
                this.rotateX = 0;
                this.rotateY = 0;
            } else {
                this.rotateX *= 1 - this.options.damping;
                this.rotateY *= 1 - this.options.damping;
                if (Math.abs(this.rotateX) < 0.0001) {
                    this.rotateX = 0;
                }
                if (Math.abs(this.rotateY) < 0.0001) {
                    this.rotateY = 0;
                }
            }
        }
    }
}

/**
 * Base class for any type of post effect
 * @public
 */ class AbstractPostEffect {
    _outputTexture;
    _quadVertexLayout;
    _quadRenderStateSet;
    _enabled;
    _opaque;
    /**
   * Creates an instance of a post effect
   * @param name - Name of the post effect
   */ constructor(){
        this._outputTexture = null;
        this._quadVertexLayout = null;
        this._quadRenderStateSet = null;
        this._enabled = true;
        this._opaque = false;
    }
    /** Whether this post effect is enabled */ get enabled() {
        return this._enabled;
    }
    set enabled(val) {
        this._enabled = !!val;
    }
    /** Whether this post effect will be rendered at opaque phase */ get opaque() {
        return this._opaque;
    }
    /**
   * Check if the post effect should be rendered upside down.
   * @param device - The device object
   * @returns true if the post effect should be rendered upside down
   */ needFlip(device) {
        return device.type === 'webgpu' && !!device.getFramebuffer();
    }
    /**
   * Disposes the post effect.
   */ dispose() {
        this._quadVertexLayout?.dispose();
        this._quadVertexLayout = null;
        this._quadRenderStateSet = null;
    }
    /**
   * Draws a fullscreen quad
   * @param renderStateSet - Render states that will be used when drawing the fullscreen quad.
   */ drawFullscreenQuad(renderStateSet) {
        drawFullscreenQuad(renderStateSet);
    /*
    const device = Application.instance.device;
    if (!this._quadVertexLayout) {
      this._quadVertexLayout = this.createVertexLayout(device);
    }
    if (!this._quadRenderStateSet) {
      this._quadRenderStateSet = this.createRenderStates(device);
    }
    const lastRenderState = device.getRenderStates();
    device.setVertexLayout(this._quadVertexLayout);
    device.setRenderStates(renderStateSet ?? this._quadRenderStateSet);
    device.draw('triangle-strip', 0, 4);
    device.setRenderStates(lastRenderState);
    */ }
    /** @internal */ createVertexLayout(device) {
        return device.createVertexLayout({
            vertexBuffers: [
                {
                    buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                        -1,
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1
                    ]))
                }
            ]
        });
    }
    /** @internal */ createRenderStates(device) {
        const renderStates = device.createRenderStateSet();
        renderStates.useRasterizerState().setCullMode('none');
        renderStates.useDepthState().enableTest(false).enableWrite(false);
        return renderStates;
    }
}

/**
 * The tonemap post effect
 * @public
 */ class Tonemap extends AbstractPostEffect {
    static _nearestSampler = null;
    static _programTonemap = null;
    _bindgroupTonemap;
    _exposure;
    /**
   * Creates an instance of tonemap post effect
   */ constructor(){
        super();
        this._bindgroupTonemap = null;
        this._opaque = false;
        this._exposure = 1;
    }
    /** Exposure value */ get exposure() {
        return this._exposure;
    }
    set exposure(val) {
        this._exposure = val;
    }
    /** {@inheritDoc AbstractPostEffect.requireLinearDepthTexture} */ requireLinearDepthTexture() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.requireDepthAttachment} */ requireDepthAttachment() {
        return false;
    }
    /** {@inheritDoc AbstractPostEffect.apply} */ apply(ctx, inputColorTexture, sceneDepthTexture, srgbOutput) {
        const device = ctx.device;
        this._prepare(device, inputColorTexture);
        this._tonemap(device, inputColorTexture, srgbOutput);
    }
    /** @internal */ _tonemap(device, inputColorTexture, sRGBOutput) {
        this._bindgroupTonemap.setValue('srgbOut', sRGBOutput ? 1 : 0);
        this._bindgroupTonemap.setValue('exposure', this._exposure);
        this._bindgroupTonemap.setValue('flip', this.needFlip(device) ? 1 : 0);
        this._bindgroupTonemap.setTexture('tex', inputColorTexture, Tonemap._nearestSampler);
        device.setProgram(Tonemap._programTonemap);
        device.setBindGroup(0, this._bindgroupTonemap);
        this.drawFullscreenQuad();
    }
    /** @internal */ _prepare(device, srcTexture) {
        if (!Tonemap._programTonemap) {
            Tonemap._programTonemap = device.buildRenderProgram({
                vertex (pb) {
                    this.flip = pb.int().uniform(0);
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.srgbOut = pb.int().uniform(0);
                    this.exposure = pb.float().uniform(0);
                    this.tex = pb.tex2D().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.func('RRTAndODTFit', [
                        pb.vec3('v')
                    ], function() {
                        this.$l.a = pb.sub(pb.mul(this.v, pb.add(this.v, pb.vec3(0.0245786))), pb.vec3(0.000090537));
                        this.$l.b = pb.add(pb.mul(this.v, pb.add(pb.mul(this.v, 0.983729), pb.vec3(0.432951))), pb.vec3(0.238081));
                        this.$return(pb.div(this.a, this.b));
                    });
                    pb.main(function() {
                        this.$l.vSample = pb.textureSample(this.tex, this.$inputs.uv);
                        this.$l.ACESInputMat = pb.mat3(0.59719, 0.076, 0.0284, 0.35458, 0.90834, 0.13383, 0.04823, 0.01566, 0.83777);
                        this.$l.ACESOutputMat = pb.mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276, -0.07367, -0.00605, 1.07602);
                        this.$l.color = pb.mul(this.vSample.rgb, pb.div(this.exposure, 0.6));
                        this.color = pb.mul(this.ACESInputMat, this.color);
                        this.color = this.RRTAndODTFit(this.color);
                        this.color = pb.mul(this.ACESOutputMat, this.color);
                        this.color = pb.clamp(this.color, pb.vec3(0), pb.vec3(1));
                        this.$if(pb.notEqual(this.srgbOut, 0), function() {
                            this.$l.color = linearToGamma(this, this.color);
                        });
                        this.$outputs.outColor = pb.vec4(this.color, 1);
                    });
                }
            });
        }
        if (!this._bindgroupTonemap) {
            this._bindgroupTonemap = device.createBindGroup(Tonemap._programTonemap.bindGroupLayouts[0]);
        }
        if (!Tonemap._nearestSampler) {
            Tonemap._nearestSampler = device.createSampler({
                magFilter: 'nearest',
                minFilter: 'nearest',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
        }
    }
    /** {@inheritDoc AbstractPostEffect.dispose} */ dispose() {
        super.dispose();
        this._bindgroupTonemap?.dispose();
        this._bindgroupTonemap = null;
    }
}

/**
 * Post processing compositor
 * @public
 */ class Compositor {
    /** @internal */ _postEffectsOpaque;
    /** @internal */ _postEffectsTransparency;
    /** @internal */ static _blitSampler = null;
    /** @internal */ static _blitProgram = null;
    /** @internal */ static _blitBindgroup = null;
    /** @internal */ static _blitRenderStates = null;
    /** @internal */ static _blitVertexLayout = null;
    /**
   * Creates an instance of Compositor
   */ constructor(){
        this._postEffectsOpaque = [];
        this._postEffectsTransparency = [];
    }
    /** @internal */ requireLinearDepth() {
        for (const postEffect of this._postEffectsOpaque){
            if (postEffect.requireLinearDepthTexture()) {
                return true;
            }
        }
        for (const postEffect of this._postEffectsTransparency){
            if (postEffect.requireLinearDepthTexture()) {
                return true;
            }
        }
        return false;
    }
    /**
   * Adds a posteffect
   *
   * @param postEffect - The post effect to add
   * @param opaque - true if the post effect should be applied after the opaque pass and before the transparent pass, otherwise the post effect should be applied after the transparent pass
   */ appendPostEffect(postEffect) {
        if (postEffect) {
            if (this._postEffectsOpaque.indexOf(postEffect) >= 0 || this._postEffectsTransparency.indexOf(postEffect) >= 0) {
                console.error(`Posteffect cannot be added to same compositor multiple times`);
                return;
            }
            const postEffects = postEffect.opaque ? this._postEffectsOpaque : this._postEffectsTransparency;
            postEffects.push(postEffect);
        }
    }
    /**
   * Removes a posteffect that was previously added
   *
   * @param postEffect - The posteffect to be remove.
   */ removePostEffect(postEffect) {
        for (const list of [
            this._postEffectsOpaque,
            this._postEffectsTransparency
        ]){
            const index = list.indexOf(postEffect);
            if (index >= 0) {
                list.splice(index, 1);
                return;
            }
        }
    }
    /**
   * Removes all post effects
   */ clear() {
        this._postEffectsOpaque = [];
        this._postEffectsTransparency = [];
    }
    /**
   * Gets all post effects
   */ getPostEffects() {
        return [
            ...this._postEffectsOpaque,
            ...this._postEffectsTransparency
        ];
    }
    /** @internal */ begin(ctx) {
        const device = ctx.device;
        const format = device.getDeviceCaps().textureCaps.supportHalfFloatColorBuffer ? 'rgba16f' : 'rgba8unorm';
        const finalFramebuffer = device.getFramebuffer();
        const depth = finalFramebuffer?.getDepthAttachment();
        let pingpongFramebuffers;
        let msFramebuffer = null;
        if (ctx.primaryCamera.sampleCount > 1) {
            msFramebuffer = depth ? TemporalCache.getFramebufferVariantSizeWithDepth(depth, 1, format, '2d', false, ctx.primaryCamera.sampleCount) : TemporalCache.getFramebufferVariantSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, ctx.primaryCamera.sampleCount);
        }
        if (ctx.defaultViewport) {
            pingpongFramebuffers = [
                depth ? TemporalCache.getFramebufferVariantSizeWithDepth(depth, 1, format, '2d', false, 1) : TemporalCache.getFramebufferVariantSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 1),
                depth ? TemporalCache.getFramebufferVariantSizeWithDepth(depth, 1, format, '2d', false, 1) : TemporalCache.getFramebufferVariantSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 1)
            ];
        } else {
            pingpongFramebuffers = [
                depth ? TemporalCache.getFramebufferFixedSizeWithDepth(depth, 1, format, '2d', false, 4) : TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 4),
                depth ? TemporalCache.getFramebufferFixedSizeWithDepth(depth, 1, format, '2d', false, 4) : TemporalCache.getFramebufferFixedSize(ctx.viewportWidth, ctx.viewportHeight, 1, format, ctx.depthFormat, '2d', '2d', false, 4)
            ];
        }
        let writeIndex;
        if (msFramebuffer) {
            writeIndex = 3;
            device.setFramebuffer(msFramebuffer);
        } else {
            writeIndex = 0;
            device.setFramebuffer(pingpongFramebuffers[writeIndex]);
        }
        device.setViewport(null);
        device.setScissor(null);
        ctx.compositorContex = {
            finalFramebuffer,
            pingpongFramebuffers,
            msFramebuffer,
            writeIndex
        };
    }
    /** @internal */ drawPostEffects(ctx, opaque, sceneDepthTexture) {
        const postEffects = opaque ? this._postEffectsOpaque : this._postEffectsTransparency;
        if (postEffects.length > 0) {
            const device = ctx.device;
            for(let i = 0; i < postEffects.length; i++){
                const postEffect = postEffects[i];
                if (!postEffect.enabled) {
                    continue;
                }
                const inputTexture = device.getFramebuffer().getColorAttachments()[0];
                const isLast = this.isLastPostEffect(opaque, i);
                const finalEffect = isLast && (!postEffect.requireDepthAttachment() || !!ctx.compositorContex.finalFramebuffer);
                if (finalEffect) {
                    device.setFramebuffer(ctx.compositorContex.finalFramebuffer);
                    device.setViewport(null);
                    device.setScissor(null);
                } else {
                    ctx.compositorContex.writeIndex = (1 + ctx.compositorContex.writeIndex) % 2;
                    device.setFramebuffer(ctx.compositorContex.pingpongFramebuffers[ctx.compositorContex.writeIndex]);
                    device.setViewport(null);
                    device.setScissor(null);
                }
                postEffect.apply(ctx, inputTexture, sceneDepthTexture, !device.getFramebuffer());
            }
        }
    }
    /** @internal */ end(ctx) {
        const device = ctx.device;
        if (device.getFramebuffer() !== ctx.compositorContex.finalFramebuffer) {
            const srcTex = device.getFramebuffer().getColorAttachments()[0];
            device.setFramebuffer(ctx.compositorContex.finalFramebuffer);
            device.setViewport(null);
            device.setScissor(null);
            Compositor._blit(device, srcTex, !ctx.compositorContex.finalFramebuffer);
        }
        TemporalCache.releaseFramebuffer(ctx.compositorContex.pingpongFramebuffers[0]);
        TemporalCache.releaseFramebuffer(ctx.compositorContex.pingpongFramebuffers[1]);
        if (ctx.compositorContex.msFramebuffer) {
            TemporalCache.releaseFramebuffer(ctx.compositorContex.msFramebuffer);
        }
        ctx.compositorContex = null;
    }
    /** @internal */ isLastPostEffect(opaque, index) {
        const list = opaque ? this._postEffectsOpaque : this._postEffectsTransparency;
        for(let i = index; i < list.length; i++){
            if (list[i].enabled) {
                return false;
            }
        }
        if (opaque) {
            for(let i = 0; i < this._postEffectsTransparency.length; i++){
                if (this._postEffectsTransparency[i].enabled) {
                    return false;
                }
            }
        }
        return true;
    }
    /** @internal */ needDrawPostEffects() {
        for(let i = 0; i < this._postEffectsOpaque.length; i++){
            if (this._postEffectsOpaque[i].enabled) {
                return true;
            }
        }
        for(let i = 0; i < this._postEffectsTransparency.length; i++){
            if (this._postEffectsTransparency[i].enabled) {
                return true;
            }
        }
        return false;
    }
    /** @internal */ static _blit(device, srcTex, srgbOutput) {
        if (!this._blitProgram) {
            this._blitProgram = device.buildRenderProgram({
                vertex (pb) {
                    this.$inputs.pos = pb.vec2().attrib('position');
                    this.$outputs.uv = pb.vec2();
                    this.flip = pb.int().uniform(0);
                    pb.main(function() {
                        this.$builtins.position = pb.vec4(this.$inputs.pos, 0, 1);
                        this.$outputs.uv = pb.add(pb.mul(this.$inputs.pos.xy, 0.5), pb.vec2(0.5));
                        this.$if(pb.notEqual(this.flip, 0), function() {
                            this.$builtins.position.y = pb.neg(this.$builtins.position.y);
                        });
                    });
                },
                fragment (pb) {
                    this.srcTex = pb.tex2D().sampleType('unfilterable-float').uniform(0);
                    this.srgbOutput = pb.int().uniform(0);
                    this.$outputs.outColor = pb.vec4();
                    pb.main(function() {
                        this.$outputs.outColor = pb.textureSample(this.srcTex, this.$inputs.uv);
                        this.$if(pb.notEqual(this.srgbOutput, 0), function() {
                            this.$outputs.outColor = pb.vec4(linearToGamma(this, this.$outputs.outColor.rgb), 1);
                        });
                    });
                }
            });
            this._blitBindgroup = device.createBindGroup(this._blitProgram.bindGroupLayouts[0]);
            this._blitVertexLayout = device.createVertexLayout({
                vertexBuffers: [
                    {
                        buffer: device.createVertexBuffer('position_f32x2', new Float32Array([
                            -1,
                            -1,
                            1,
                            -1,
                            -1,
                            1,
                            1,
                            1
                        ]))
                    }
                ]
            });
            this._blitSampler = device.createSampler({
                minFilter: 'nearest',
                magFilter: 'nearest',
                mipFilter: 'none',
                addressU: 'clamp',
                addressV: 'clamp'
            });
            this._blitRenderStates = device.createRenderStateSet();
            this._blitRenderStates.useRasterizerState().setCullMode('none');
            this._blitRenderStates.useDepthState().enableTest(false).enableWrite(false);
        }
        this._blitBindgroup.setTexture('srcTex', srcTex, this._blitSampler);
        this._blitBindgroup.setValue('srgbOutput', srgbOutput ? 1 : 0);
        this._blitBindgroup.setValue('flip', device.type === 'webgpu' && !!device.getFramebuffer() ? 1 : 0);
        device.setRenderStates(this._blitRenderStates);
        device.setProgram(this._blitProgram);
        device.setBindGroup(0, this._blitBindgroup);
        device.setVertexLayout(this._blitVertexLayout);
        device.draw('triangle-strip', 0, 4);
    }
}

/**
 * WebGL constant value definitions
 */ var WebGLEnum;
(function(WebGLEnum) {
    WebGLEnum[WebGLEnum["READ_BUFFER"] = 0xc02] = "READ_BUFFER";
    WebGLEnum[WebGLEnum["UNPACK_ROW_LENGTH"] = 0xcf2] = "UNPACK_ROW_LENGTH";
    WebGLEnum[WebGLEnum["UNPACK_SKIP_ROWS"] = 0xcf3] = "UNPACK_SKIP_ROWS";
    WebGLEnum[WebGLEnum["UNPACK_SKIP_PIXELS"] = 0xcf4] = "UNPACK_SKIP_PIXELS";
    WebGLEnum[WebGLEnum["PACK_ROW_LENGTH"] = 0xd02] = "PACK_ROW_LENGTH";
    WebGLEnum[WebGLEnum["PACK_SKIP_ROWS"] = 0xd03] = "PACK_SKIP_ROWS";
    WebGLEnum[WebGLEnum["PACK_SKIP_PIXELS"] = 0xd04] = "PACK_SKIP_PIXELS";
    WebGLEnum[WebGLEnum["COLOR"] = 0x1800] = "COLOR";
    WebGLEnum[WebGLEnum["DEPTH"] = 0x1801] = "DEPTH";
    WebGLEnum[WebGLEnum["STENCIL"] = 0x1802] = "STENCIL";
    WebGLEnum[WebGLEnum["RED"] = 0x1903] = "RED";
    WebGLEnum[WebGLEnum["RGB8"] = 0x8051] = "RGB8";
    WebGLEnum[WebGLEnum["RGBA8"] = 0x8058] = "RGBA8";
    WebGLEnum[WebGLEnum["RGB10_A2"] = 0x8059] = "RGB10_A2";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_3D"] = 0x806a] = "TEXTURE_BINDING_3D";
    WebGLEnum[WebGLEnum["UNPACK_SKIP_IMAGES"] = 0x806d] = "UNPACK_SKIP_IMAGES";
    WebGLEnum[WebGLEnum["UNPACK_IMAGE_HEIGHT"] = 0x806e] = "UNPACK_IMAGE_HEIGHT";
    WebGLEnum[WebGLEnum["TEXTURE_3D"] = 0x806f] = "TEXTURE_3D";
    WebGLEnum[WebGLEnum["TEXTURE_WRAP_R"] = 0x8072] = "TEXTURE_WRAP_R";
    WebGLEnum[WebGLEnum["MAX_3D_TEXTURE_SIZE"] = 0x8073] = "MAX_3D_TEXTURE_SIZE";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_2_10_10_10_REV"] = 0x8368] = "UNSIGNED_INT_2_10_10_10_REV";
    WebGLEnum[WebGLEnum["MAX_ELEMENTS_VERTICES"] = 0x80e8] = "MAX_ELEMENTS_VERTICES";
    WebGLEnum[WebGLEnum["MAX_ELEMENTS_INDICES"] = 0x80e9] = "MAX_ELEMENTS_INDICES";
    WebGLEnum[WebGLEnum["TEXTURE_MIN_LOD"] = 0x813a] = "TEXTURE_MIN_LOD";
    WebGLEnum[WebGLEnum["TEXTURE_MAX_LOD"] = 0x813b] = "TEXTURE_MAX_LOD";
    WebGLEnum[WebGLEnum["TEXTURE_BASE_LEVEL"] = 0x813c] = "TEXTURE_BASE_LEVEL";
    WebGLEnum[WebGLEnum["TEXTURE_MAX_LEVEL"] = 0x813d] = "TEXTURE_MAX_LEVEL";
    WebGLEnum[WebGLEnum["MIN"] = 0x8007] = "MIN";
    WebGLEnum[WebGLEnum["MAX"] = 0x8008] = "MAX";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT24"] = 0x81a6] = "DEPTH_COMPONENT24";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_LOD_BIAS"] = 0x84fd] = "MAX_TEXTURE_LOD_BIAS";
    WebGLEnum[WebGLEnum["TEXTURE_COMPARE_MODE"] = 0x884c] = "TEXTURE_COMPARE_MODE";
    WebGLEnum[WebGLEnum["TEXTURE_COMPARE_FUNC"] = 0x884d] = "TEXTURE_COMPARE_FUNC";
    WebGLEnum[WebGLEnum["CURRENT_QUERY"] = 0x8865] = "CURRENT_QUERY";
    WebGLEnum[WebGLEnum["QUERY_RESULT"] = 0x8866] = "QUERY_RESULT";
    WebGLEnum[WebGLEnum["QUERY_RESULT_AVAILABLE"] = 0x8867] = "QUERY_RESULT_AVAILABLE";
    WebGLEnum[WebGLEnum["STREAM_READ"] = 0x88e1] = "STREAM_READ";
    WebGLEnum[WebGLEnum["STREAM_COPY"] = 0x88e2] = "STREAM_COPY";
    WebGLEnum[WebGLEnum["STATIC_READ"] = 0x88e5] = "STATIC_READ";
    WebGLEnum[WebGLEnum["STATIC_COPY"] = 0x88e6] = "STATIC_COPY";
    WebGLEnum[WebGLEnum["DYNAMIC_READ"] = 0x88e9] = "DYNAMIC_READ";
    WebGLEnum[WebGLEnum["DYNAMIC_COPY"] = 0x88ea] = "DYNAMIC_COPY";
    WebGLEnum[WebGLEnum["MAX_DRAW_BUFFERS"] = 0x8824] = "MAX_DRAW_BUFFERS";
    WebGLEnum[WebGLEnum["DRAW_BUFFER0"] = 0x8825] = "DRAW_BUFFER0";
    WebGLEnum[WebGLEnum["DRAW_BUFFER1"] = 0x8826] = "DRAW_BUFFER1";
    WebGLEnum[WebGLEnum["DRAW_BUFFER2"] = 0x8827] = "DRAW_BUFFER2";
    WebGLEnum[WebGLEnum["DRAW_BUFFER3"] = 0x8828] = "DRAW_BUFFER3";
    WebGLEnum[WebGLEnum["DRAW_BUFFER4"] = 0x8829] = "DRAW_BUFFER4";
    WebGLEnum[WebGLEnum["DRAW_BUFFER5"] = 0x882a] = "DRAW_BUFFER5";
    WebGLEnum[WebGLEnum["DRAW_BUFFER6"] = 0x882b] = "DRAW_BUFFER6";
    WebGLEnum[WebGLEnum["DRAW_BUFFER7"] = 0x882c] = "DRAW_BUFFER7";
    WebGLEnum[WebGLEnum["DRAW_BUFFER8"] = 0x882d] = "DRAW_BUFFER8";
    WebGLEnum[WebGLEnum["DRAW_BUFFER9"] = 0x882e] = "DRAW_BUFFER9";
    WebGLEnum[WebGLEnum["DRAW_BUFFER10"] = 0x882f] = "DRAW_BUFFER10";
    WebGLEnum[WebGLEnum["DRAW_BUFFER11"] = 0x8830] = "DRAW_BUFFER11";
    WebGLEnum[WebGLEnum["DRAW_BUFFER12"] = 0x8831] = "DRAW_BUFFER12";
    WebGLEnum[WebGLEnum["DRAW_BUFFER13"] = 0x8832] = "DRAW_BUFFER13";
    WebGLEnum[WebGLEnum["DRAW_BUFFER14"] = 0x8833] = "DRAW_BUFFER14";
    WebGLEnum[WebGLEnum["DRAW_BUFFER15"] = 0x8834] = "DRAW_BUFFER15";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 0x8b49] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_VERTEX_UNIFORM_COMPONENTS"] = 0x8b4a] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["SAMPLER_3D"] = 0x8b5f] = "SAMPLER_3D";
    WebGLEnum[WebGLEnum["SAMPLER_2D_SHADOW"] = 0x8b62] = "SAMPLER_2D_SHADOW";
    WebGLEnum[WebGLEnum["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 0x8b8b] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    WebGLEnum[WebGLEnum["PIXEL_PACK_BUFFER"] = 0x88eb] = "PIXEL_PACK_BUFFER";
    WebGLEnum[WebGLEnum["PIXEL_UNPACK_BUFFER"] = 0x88ec] = "PIXEL_UNPACK_BUFFER";
    WebGLEnum[WebGLEnum["PIXEL_PACK_BUFFER_BINDING"] = 0x88ed] = "PIXEL_PACK_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["PIXEL_UNPACK_BUFFER_BINDING"] = 0x88ef] = "PIXEL_UNPACK_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["FLOAT_MAT2x3"] = 0x8b65] = "FLOAT_MAT2x3";
    WebGLEnum[WebGLEnum["FLOAT_MAT2x4"] = 0x8b66] = "FLOAT_MAT2x4";
    WebGLEnum[WebGLEnum["FLOAT_MAT3x2"] = 0x8b67] = "FLOAT_MAT3x2";
    WebGLEnum[WebGLEnum["FLOAT_MAT3x4"] = 0x8b68] = "FLOAT_MAT3x4";
    WebGLEnum[WebGLEnum["FLOAT_MAT4x2"] = 0x8b69] = "FLOAT_MAT4x2";
    WebGLEnum[WebGLEnum["FLOAT_MAT4x3"] = 0x8b6a] = "FLOAT_MAT4x3";
    WebGLEnum[WebGLEnum["SRGB"] = 0x8c40] = "SRGB";
    WebGLEnum[WebGLEnum["SRGB8"] = 0x8c41] = "SRGB8";
    WebGLEnum[WebGLEnum["SRGB_ALPHA"] = 0x8c42] = "SRGB_ALPHA";
    WebGLEnum[WebGLEnum["SRGB8_ALPHA8"] = 0x8c43] = "SRGB8_ALPHA8";
    WebGLEnum[WebGLEnum["COMPARE_REF_TO_TEXTURE"] = 0x884e] = "COMPARE_REF_TO_TEXTURE";
    WebGLEnum[WebGLEnum["RGBA32F"] = 0x8814] = "RGBA32F";
    WebGLEnum[WebGLEnum["RGB32F"] = 0x8815] = "RGB32F";
    WebGLEnum[WebGLEnum["RGBA16F"] = 0x881a] = "RGBA16F";
    WebGLEnum[WebGLEnum["RGB16F"] = 0x881b] = "RGB16F";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_INTEGER"] = 0x88fd] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    WebGLEnum[WebGLEnum["MAX_ARRAY_TEXTURE_LAYERS"] = 0x88ff] = "MAX_ARRAY_TEXTURE_LAYERS";
    WebGLEnum[WebGLEnum["MIN_PROGRAM_TEXEL_OFFSET"] = 0x8904] = "MIN_PROGRAM_TEXEL_OFFSET";
    WebGLEnum[WebGLEnum["MAX_PROGRAM_TEXEL_OFFSET"] = 0x8905] = "MAX_PROGRAM_TEXEL_OFFSET";
    WebGLEnum[WebGLEnum["MAX_VARYING_COMPONENTS"] = 0x8b4b] = "MAX_VARYING_COMPONENTS";
    WebGLEnum[WebGLEnum["TEXTURE_2D_ARRAY"] = 0x8c1a] = "TEXTURE_2D_ARRAY";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_2D_ARRAY"] = 0x8c1d] = "TEXTURE_BINDING_2D_ARRAY";
    WebGLEnum[WebGLEnum["R11F_G11F_B10F"] = 0x8c3a] = "R11F_G11F_B10F";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_10F_11F_11F_REV"] = 0x8c3b] = "UNSIGNED_INT_10F_11F_11F_REV";
    WebGLEnum[WebGLEnum["RGB9_E5"] = 0x8c3d] = "RGB9_E5";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_5_9_9_9_REV"] = 0x8c3e] = "UNSIGNED_INT_5_9_9_9_REV";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 0x8c7f] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    WebGLEnum[WebGLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 0x8c80] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_VARYINGS"] = 0x8c83] = "TRANSFORM_FEEDBACK_VARYINGS";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_START"] = 0x8c84] = "TRANSFORM_FEEDBACK_BUFFER_START";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 0x8c85] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 0x8c88] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    WebGLEnum[WebGLEnum["RASTERIZER_DISCARD"] = 0x8c89] = "RASTERIZER_DISCARD";
    WebGLEnum[WebGLEnum["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 0x8c8a] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 0x8c8b] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    WebGLEnum[WebGLEnum["INTERLEAVED_ATTRIBS"] = 0x8c8c] = "INTERLEAVED_ATTRIBS";
    WebGLEnum[WebGLEnum["SEPARATE_ATTRIBS"] = 0x8c8d] = "SEPARATE_ATTRIBS";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER"] = 0x8c8e] = "TRANSFORM_FEEDBACK_BUFFER";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 0x8c8f] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["RGBA32UI"] = 0x8d70] = "RGBA32UI";
    WebGLEnum[WebGLEnum["RGB32UI"] = 0x8d71] = "RGB32UI";
    WebGLEnum[WebGLEnum["RGBA16UI"] = 0x8d76] = "RGBA16UI";
    WebGLEnum[WebGLEnum["RGB16UI"] = 0x8d77] = "RGB16UI";
    WebGLEnum[WebGLEnum["RGBA8UI"] = 0x8d7c] = "RGBA8UI";
    WebGLEnum[WebGLEnum["RGB8UI"] = 0x8d7d] = "RGB8UI";
    WebGLEnum[WebGLEnum["RGBA32I"] = 0x8d82] = "RGBA32I";
    WebGLEnum[WebGLEnum["RGB32I"] = 0x8d83] = "RGB32I";
    WebGLEnum[WebGLEnum["RGBA16I"] = 0x8d88] = "RGBA16I";
    WebGLEnum[WebGLEnum["RGB16I"] = 0x8d89] = "RGB16I";
    WebGLEnum[WebGLEnum["RGBA8I"] = 0x8d8e] = "RGBA8I";
    WebGLEnum[WebGLEnum["RGB8I"] = 0x8d8f] = "RGB8I";
    WebGLEnum[WebGLEnum["RED_INTEGER"] = 0x8d94] = "RED_INTEGER";
    WebGLEnum[WebGLEnum["RGB_INTEGER"] = 0x8d98] = "RGB_INTEGER";
    WebGLEnum[WebGLEnum["RGBA_INTEGER"] = 0x8d99] = "RGBA_INTEGER";
    WebGLEnum[WebGLEnum["SAMPLER_2D_ARRAY"] = 0x8dc1] = "SAMPLER_2D_ARRAY";
    WebGLEnum[WebGLEnum["SAMPLER_2D_ARRAY_SHADOW"] = 0x8dc4] = "SAMPLER_2D_ARRAY_SHADOW";
    WebGLEnum[WebGLEnum["SAMPLER_CUBE_SHADOW"] = 0x8dc5] = "SAMPLER_CUBE_SHADOW";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_VEC2"] = 0x8dc6] = "UNSIGNED_INT_VEC2";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_VEC3"] = 0x8dc7] = "UNSIGNED_INT_VEC3";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_VEC4"] = 0x8dc8] = "UNSIGNED_INT_VEC4";
    WebGLEnum[WebGLEnum["INT_SAMPLER_2D"] = 0x8dca] = "INT_SAMPLER_2D";
    WebGLEnum[WebGLEnum["INT_SAMPLER_3D"] = 0x8dcb] = "INT_SAMPLER_3D";
    WebGLEnum[WebGLEnum["INT_SAMPLER_CUBE"] = 0x8dcc] = "INT_SAMPLER_CUBE";
    WebGLEnum[WebGLEnum["INT_SAMPLER_2D_ARRAY"] = 0x8dcf] = "INT_SAMPLER_2D_ARRAY";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_2D"] = 0x8dd2] = "UNSIGNED_INT_SAMPLER_2D";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_3D"] = 0x8dd3] = "UNSIGNED_INT_SAMPLER_3D";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_CUBE"] = 0x8dd4] = "UNSIGNED_INT_SAMPLER_CUBE";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 0x8dd7] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT32F"] = 0x8cac] = "DEPTH_COMPONENT32F";
    WebGLEnum[WebGLEnum["DEPTH32F_STENCIL8"] = 0x8cad] = "DEPTH32F_STENCIL8";
    WebGLEnum[WebGLEnum["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 0x8dad] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 0x8210] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 0x8211] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 0x8212] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 0x8213] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 0x8214] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 0x8215] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 0x8216] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 0x8217] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_DEFAULT"] = 0x8218] = "FRAMEBUFFER_DEFAULT";
    WebGLEnum[WebGLEnum["UNSIGNED_INT_24_8"] = 0x84fa] = "UNSIGNED_INT_24_8";
    WebGLEnum[WebGLEnum["DEPTH24_STENCIL8"] = 0x88f0] = "DEPTH24_STENCIL8";
    WebGLEnum[WebGLEnum["UNSIGNED_NORMALIZED"] = 0x8c17] = "UNSIGNED_NORMALIZED";
    WebGLEnum[WebGLEnum["DRAW_FRAMEBUFFER_BINDING"] = 0x8ca6] = "DRAW_FRAMEBUFFER_BINDING";
    WebGLEnum[WebGLEnum["READ_FRAMEBUFFER"] = 0x8ca8] = "READ_FRAMEBUFFER";
    WebGLEnum[WebGLEnum["DRAW_FRAMEBUFFER"] = 0x8ca9] = "DRAW_FRAMEBUFFER";
    WebGLEnum[WebGLEnum["READ_FRAMEBUFFER_BINDING"] = 0x8caa] = "READ_FRAMEBUFFER_BINDING";
    WebGLEnum[WebGLEnum["RENDERBUFFER_SAMPLES"] = 0x8cab] = "RENDERBUFFER_SAMPLES";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 0x8cd4] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    WebGLEnum[WebGLEnum["MAX_COLOR_ATTACHMENTS"] = 0x8cdf] = "MAX_COLOR_ATTACHMENTS";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT1"] = 0x8ce1] = "COLOR_ATTACHMENT1";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT2"] = 0x8ce2] = "COLOR_ATTACHMENT2";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT3"] = 0x8ce3] = "COLOR_ATTACHMENT3";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT4"] = 0x8ce4] = "COLOR_ATTACHMENT4";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT5"] = 0x8ce5] = "COLOR_ATTACHMENT5";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT6"] = 0x8ce6] = "COLOR_ATTACHMENT6";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT7"] = 0x8ce7] = "COLOR_ATTACHMENT7";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT8"] = 0x8ce8] = "COLOR_ATTACHMENT8";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT9"] = 0x8ce9] = "COLOR_ATTACHMENT9";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT10"] = 0x8cea] = "COLOR_ATTACHMENT10";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT11"] = 0x8ceb] = "COLOR_ATTACHMENT11";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT12"] = 0x8cec] = "COLOR_ATTACHMENT12";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT13"] = 0x8ced] = "COLOR_ATTACHMENT13";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT14"] = 0x8cee] = "COLOR_ATTACHMENT14";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT15"] = 0x8cef] = "COLOR_ATTACHMENT15";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 0x8d56] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    WebGLEnum[WebGLEnum["MAX_SAMPLES"] = 0x8d57] = "MAX_SAMPLES";
    WebGLEnum[WebGLEnum["HALF_FLOAT"] = 0x140b] = "HALF_FLOAT";
    WebGLEnum[WebGLEnum["RG"] = 0x8227] = "RG";
    WebGLEnum[WebGLEnum["RG_INTEGER"] = 0x8228] = "RG_INTEGER";
    WebGLEnum[WebGLEnum["R8"] = 0x8229] = "R8";
    WebGLEnum[WebGLEnum["RG8"] = 0x822b] = "RG8";
    WebGLEnum[WebGLEnum["R16F"] = 0x822d] = "R16F";
    WebGLEnum[WebGLEnum["R32F"] = 0x822e] = "R32F";
    WebGLEnum[WebGLEnum["RG16F"] = 0x822f] = "RG16F";
    WebGLEnum[WebGLEnum["RG32F"] = 0x8230] = "RG32F";
    WebGLEnum[WebGLEnum["R8I"] = 0x8231] = "R8I";
    WebGLEnum[WebGLEnum["R8UI"] = 0x8232] = "R8UI";
    WebGLEnum[WebGLEnum["R16I"] = 0x8233] = "R16I";
    WebGLEnum[WebGLEnum["R16UI"] = 0x8234] = "R16UI";
    WebGLEnum[WebGLEnum["R32I"] = 0x8235] = "R32I";
    WebGLEnum[WebGLEnum["R32UI"] = 0x8236] = "R32UI";
    WebGLEnum[WebGLEnum["RG8I"] = 0x8237] = "RG8I";
    WebGLEnum[WebGLEnum["RG8UI"] = 0x8238] = "RG8UI";
    WebGLEnum[WebGLEnum["RG16I"] = 0x8239] = "RG16I";
    WebGLEnum[WebGLEnum["RG16UI"] = 0x823a] = "RG16UI";
    WebGLEnum[WebGLEnum["RG32I"] = 0x823b] = "RG32I";
    WebGLEnum[WebGLEnum["RG32UI"] = 0x823c] = "RG32UI";
    WebGLEnum[WebGLEnum["VERTEX_ARRAY_BINDING"] = 0x85b5] = "VERTEX_ARRAY_BINDING";
    WebGLEnum[WebGLEnum["R8_SNORM"] = 0x8f94] = "R8_SNORM";
    WebGLEnum[WebGLEnum["RG8_SNORM"] = 0x8f95] = "RG8_SNORM";
    WebGLEnum[WebGLEnum["RGB8_SNORM"] = 0x8f96] = "RGB8_SNORM";
    WebGLEnum[WebGLEnum["RGBA8_SNORM"] = 0x8f97] = "RGBA8_SNORM";
    WebGLEnum[WebGLEnum["SIGNED_NORMALIZED"] = 0x8f9c] = "SIGNED_NORMALIZED";
    WebGLEnum[WebGLEnum["COPY_READ_BUFFER"] = 0x8f36] = "COPY_READ_BUFFER";
    WebGLEnum[WebGLEnum["COPY_WRITE_BUFFER"] = 0x8f37] = "COPY_WRITE_BUFFER";
    WebGLEnum[WebGLEnum["COPY_READ_BUFFER_BINDING"] = 0x8f36] = "COPY_READ_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["COPY_WRITE_BUFFER_BINDING"] = 0x8f37] = "COPY_WRITE_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER"] = 0x8a11] = "UNIFORM_BUFFER";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_BINDING"] = 0x8a28] = "UNIFORM_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_START"] = 0x8a29] = "UNIFORM_BUFFER_START";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_SIZE"] = 0x8a2a] = "UNIFORM_BUFFER_SIZE";
    WebGLEnum[WebGLEnum["MAX_VERTEX_UNIFORM_BLOCKS"] = 0x8a2b] = "MAX_VERTEX_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 0x8a2d] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["MAX_COMBINED_UNIFORM_BLOCKS"] = 0x8a2e] = "MAX_COMBINED_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["MAX_UNIFORM_BUFFER_BINDINGS"] = 0x8a2f] = "MAX_UNIFORM_BUFFER_BINDINGS";
    WebGLEnum[WebGLEnum["MAX_UNIFORM_BLOCK_SIZE"] = 0x8a30] = "MAX_UNIFORM_BLOCK_SIZE";
    WebGLEnum[WebGLEnum["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 0x8a31] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 0x8a33] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    WebGLEnum[WebGLEnum["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 0x8a34] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    WebGLEnum[WebGLEnum["ACTIVE_UNIFORM_BLOCKS"] = 0x8a36] = "ACTIVE_UNIFORM_BLOCKS";
    WebGLEnum[WebGLEnum["UNIFORM_TYPE"] = 0x8a37] = "UNIFORM_TYPE";
    WebGLEnum[WebGLEnum["UNIFORM_SIZE"] = 0x8a38] = "UNIFORM_SIZE";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_INDEX"] = 0x8a3a] = "UNIFORM_BLOCK_INDEX";
    WebGLEnum[WebGLEnum["UNIFORM_OFFSET"] = 0x8a3b] = "UNIFORM_OFFSET";
    WebGLEnum[WebGLEnum["UNIFORM_ARRAY_STRIDE"] = 0x8a3c] = "UNIFORM_ARRAY_STRIDE";
    WebGLEnum[WebGLEnum["UNIFORM_MATRIX_STRIDE"] = 0x8a3d] = "UNIFORM_MATRIX_STRIDE";
    WebGLEnum[WebGLEnum["UNIFORM_IS_ROW_MAJOR"] = 0x8a3e] = "UNIFORM_IS_ROW_MAJOR";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_BINDING"] = 0x8a3f] = "UNIFORM_BLOCK_BINDING";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_DATA_SIZE"] = 0x8a40] = "UNIFORM_BLOCK_DATA_SIZE";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 0x8a42] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 0x8a43] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 0x8a44] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    WebGLEnum[WebGLEnum["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 0x8a46] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    WebGLEnum[WebGLEnum["INVALID_INDEX"] = 0xffffffff] = "INVALID_INDEX";
    WebGLEnum[WebGLEnum["MAX_VERTEX_OUTPUT_COMPONENTS"] = 0x9122] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_INPUT_COMPONENTS"] = 0x9125] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    WebGLEnum[WebGLEnum["MAX_SERVER_WAIT_TIMEOUT"] = 0x9111] = "MAX_SERVER_WAIT_TIMEOUT";
    WebGLEnum[WebGLEnum["OBJECT_TYPE"] = 0x9112] = "OBJECT_TYPE";
    WebGLEnum[WebGLEnum["SYNC_CONDITION"] = 0x9113] = "SYNC_CONDITION";
    WebGLEnum[WebGLEnum["SYNC_STATUS"] = 0x9114] = "SYNC_STATUS";
    WebGLEnum[WebGLEnum["SYNC_FLAGS"] = 0x9115] = "SYNC_FLAGS";
    WebGLEnum[WebGLEnum["SYNC_FENCE"] = 0x9116] = "SYNC_FENCE";
    WebGLEnum[WebGLEnum["SYNC_GPU_COMMANDS_COMPLETE"] = 0x9117] = "SYNC_GPU_COMMANDS_COMPLETE";
    WebGLEnum[WebGLEnum["UNSIGNALED"] = 0x9118] = "UNSIGNALED";
    WebGLEnum[WebGLEnum["SIGNALED"] = 0x9119] = "SIGNALED";
    WebGLEnum[WebGLEnum["ALREADY_SIGNALED"] = 0x911a] = "ALREADY_SIGNALED";
    WebGLEnum[WebGLEnum["TIMEOUT_EXPIRED"] = 0x911b] = "TIMEOUT_EXPIRED";
    WebGLEnum[WebGLEnum["CONDITION_SATISFIED"] = 0x911c] = "CONDITION_SATISFIED";
    WebGLEnum[WebGLEnum["WAIT_FAILED"] = 0x911d] = "WAIT_FAILED";
    WebGLEnum[WebGLEnum["SYNC_FLUSH_COMMANDS_BIT"] = 0x1] = "SYNC_FLUSH_COMMANDS_BIT";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 0x88fe] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    WebGLEnum[WebGLEnum["ANY_SAMPLES_PASSED"] = 0x8c2f] = "ANY_SAMPLES_PASSED";
    WebGLEnum[WebGLEnum["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 0x8d6a] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    WebGLEnum[WebGLEnum["SAMPLER_BINDING"] = 0x8919] = "SAMPLER_BINDING";
    WebGLEnum[WebGLEnum["RGB10_A2UI"] = 0x906f] = "RGB10_A2UI";
    WebGLEnum[WebGLEnum["INT_2_10_10_10_REV"] = 0x8d9f] = "INT_2_10_10_10_REV";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK"] = 0x8e22] = "TRANSFORM_FEEDBACK";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_PAUSED"] = 0x8e23] = "TRANSFORM_FEEDBACK_PAUSED";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_ACTIVE"] = 0x8e24] = "TRANSFORM_FEEDBACK_ACTIVE";
    WebGLEnum[WebGLEnum["TRANSFORM_FEEDBACK_BINDING"] = 0x8e25] = "TRANSFORM_FEEDBACK_BINDING";
    WebGLEnum[WebGLEnum["TEXTURE_IMMUTABLE_FORMAT"] = 0x912f] = "TEXTURE_IMMUTABLE_FORMAT";
    WebGLEnum[WebGLEnum["MAX_ELEMENT_INDEX"] = 0x8d6b] = "MAX_ELEMENT_INDEX";
    WebGLEnum[WebGLEnum["TEXTURE_IMMUTABLE_LEVELS"] = 0x82df] = "TEXTURE_IMMUTABLE_LEVELS";
    WebGLEnum[WebGLEnum["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 0x9247] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    WebGLEnum[WebGLEnum["DEPTH_BUFFER_BIT"] = 0x100] = "DEPTH_BUFFER_BIT";
    WebGLEnum[WebGLEnum["STENCIL_BUFFER_BIT"] = 0x400] = "STENCIL_BUFFER_BIT";
    WebGLEnum[WebGLEnum["COLOR_BUFFER_BIT"] = 0x4000] = "COLOR_BUFFER_BIT";
    WebGLEnum[WebGLEnum["POINTS"] = 0x0] = "POINTS";
    WebGLEnum[WebGLEnum["LINES"] = 0x1] = "LINES";
    WebGLEnum[WebGLEnum["LINE_LOOP"] = 0x2] = "LINE_LOOP";
    WebGLEnum[WebGLEnum["LINE_STRIP"] = 0x3] = "LINE_STRIP";
    WebGLEnum[WebGLEnum["TRIANGLES"] = 0x4] = "TRIANGLES";
    WebGLEnum[WebGLEnum["TRIANGLE_STRIP"] = 0x5] = "TRIANGLE_STRIP";
    WebGLEnum[WebGLEnum["TRIANGLE_FAN"] = 0x6] = "TRIANGLE_FAN";
    WebGLEnum[WebGLEnum["ZERO"] = 0x0] = "ZERO";
    WebGLEnum[WebGLEnum["ONE"] = 0x1] = "ONE";
    WebGLEnum[WebGLEnum["SRC_COLOR"] = 0x300] = "SRC_COLOR";
    WebGLEnum[WebGLEnum["ONE_MINUS_SRC_COLOR"] = 0x301] = "ONE_MINUS_SRC_COLOR";
    WebGLEnum[WebGLEnum["SRC_ALPHA"] = 0x302] = "SRC_ALPHA";
    WebGLEnum[WebGLEnum["ONE_MINUS_SRC_ALPHA"] = 0x303] = "ONE_MINUS_SRC_ALPHA";
    WebGLEnum[WebGLEnum["DST_ALPHA"] = 0x304] = "DST_ALPHA";
    WebGLEnum[WebGLEnum["ONE_MINUS_DST_ALPHA"] = 0x305] = "ONE_MINUS_DST_ALPHA";
    WebGLEnum[WebGLEnum["DST_COLOR"] = 0x306] = "DST_COLOR";
    WebGLEnum[WebGLEnum["ONE_MINUS_DST_COLOR"] = 0x307] = "ONE_MINUS_DST_COLOR";
    WebGLEnum[WebGLEnum["SRC_ALPHA_SATURATE"] = 0x308] = "SRC_ALPHA_SATURATE";
    WebGLEnum[WebGLEnum["FUNC_ADD"] = 0x8006] = "FUNC_ADD";
    WebGLEnum[WebGLEnum["FUNC_MIN"] = 0x8007] = "FUNC_MIN";
    WebGLEnum[WebGLEnum["FUNC_MAX"] = 0x8008] = "FUNC_MAX";
    WebGLEnum[WebGLEnum["BLEND_EQUATION"] = 0x8009] = "BLEND_EQUATION";
    WebGLEnum[WebGLEnum["BLEND_EQUATION_RGB"] = 0x8009] = "BLEND_EQUATION_RGB";
    WebGLEnum[WebGLEnum["BLEND_EQUATION_ALPHA"] = 0x883d] = "BLEND_EQUATION_ALPHA";
    WebGLEnum[WebGLEnum["FUNC_SUBTRACT"] = 0x800a] = "FUNC_SUBTRACT";
    WebGLEnum[WebGLEnum["FUNC_REVERSE_SUBTRACT"] = 0x800b] = "FUNC_REVERSE_SUBTRACT";
    WebGLEnum[WebGLEnum["BLEND_DST_RGB"] = 0x80c8] = "BLEND_DST_RGB";
    WebGLEnum[WebGLEnum["BLEND_SRC_RGB"] = 0x80c9] = "BLEND_SRC_RGB";
    WebGLEnum[WebGLEnum["BLEND_DST_ALPHA"] = 0x80ca] = "BLEND_DST_ALPHA";
    WebGLEnum[WebGLEnum["BLEND_SRC_ALPHA"] = 0x80cb] = "BLEND_SRC_ALPHA";
    WebGLEnum[WebGLEnum["CONSTANT_COLOR"] = 0x8001] = "CONSTANT_COLOR";
    WebGLEnum[WebGLEnum["ONE_MINUS_CONSTANT_COLOR"] = 0x8002] = "ONE_MINUS_CONSTANT_COLOR";
    WebGLEnum[WebGLEnum["CONSTANT_ALPHA"] = 0x8003] = "CONSTANT_ALPHA";
    WebGLEnum[WebGLEnum["ONE_MINUS_CONSTANT_ALPHA"] = 0x8004] = "ONE_MINUS_CONSTANT_ALPHA";
    WebGLEnum[WebGLEnum["BLEND_COLOR"] = 0x8005] = "BLEND_COLOR";
    WebGLEnum[WebGLEnum["ARRAY_BUFFER"] = 0x8892] = "ARRAY_BUFFER";
    WebGLEnum[WebGLEnum["ELEMENT_ARRAY_BUFFER"] = 0x8893] = "ELEMENT_ARRAY_BUFFER";
    WebGLEnum[WebGLEnum["ARRAY_BUFFER_BINDING"] = 0x8894] = "ARRAY_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["ELEMENT_ARRAY_BUFFER_BINDING"] = 0x8895] = "ELEMENT_ARRAY_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["STREAM_DRAW"] = 0x88e0] = "STREAM_DRAW";
    WebGLEnum[WebGLEnum["STATIC_DRAW"] = 0x88e4] = "STATIC_DRAW";
    WebGLEnum[WebGLEnum["DYNAMIC_DRAW"] = 0x88e8] = "DYNAMIC_DRAW";
    WebGLEnum[WebGLEnum["BUFFER_SIZE"] = 0x8764] = "BUFFER_SIZE";
    WebGLEnum[WebGLEnum["BUFFER_USAGE"] = 0x8765] = "BUFFER_USAGE";
    WebGLEnum[WebGLEnum["CURRENT_VERTEX_ATTRIB"] = 0x8626] = "CURRENT_VERTEX_ATTRIB";
    WebGLEnum[WebGLEnum["FRONT"] = 0x404] = "FRONT";
    WebGLEnum[WebGLEnum["BACK"] = 0x405] = "BACK";
    WebGLEnum[WebGLEnum["FRONT_AND_BACK"] = 0x408] = "FRONT_AND_BACK";
    WebGLEnum[WebGLEnum["TEXTURE_2D"] = 0xde1] = "TEXTURE_2D";
    WebGLEnum[WebGLEnum["CULL_FACE"] = 0xb44] = "CULL_FACE";
    WebGLEnum[WebGLEnum["BLEND"] = 0xbe2] = "BLEND";
    WebGLEnum[WebGLEnum["DITHER"] = 0xbd0] = "DITHER";
    WebGLEnum[WebGLEnum["STENCIL_TEST"] = 0xb90] = "STENCIL_TEST";
    WebGLEnum[WebGLEnum["DEPTH_TEST"] = 0xb71] = "DEPTH_TEST";
    WebGLEnum[WebGLEnum["SCISSOR_TEST"] = 0xc11] = "SCISSOR_TEST";
    WebGLEnum[WebGLEnum["POLYGON_OFFSET_FILL"] = 0x8037] = "POLYGON_OFFSET_FILL";
    WebGLEnum[WebGLEnum["SAMPLE_ALPHA_TO_COVERAGE"] = 0x809e] = "SAMPLE_ALPHA_TO_COVERAGE";
    WebGLEnum[WebGLEnum["SAMPLE_COVERAGE"] = 0x80a0] = "SAMPLE_COVERAGE";
    WebGLEnum[WebGLEnum["NO_ERROR"] = 0x0] = "NO_ERROR";
    WebGLEnum[WebGLEnum["INVALID_ENUM"] = 0x500] = "INVALID_ENUM";
    WebGLEnum[WebGLEnum["INVALID_VALUE"] = 0x501] = "INVALID_VALUE";
    WebGLEnum[WebGLEnum["INVALID_OPERATION"] = 0x502] = "INVALID_OPERATION";
    WebGLEnum[WebGLEnum["OUT_OF_MEMORY"] = 0x505] = "OUT_OF_MEMORY";
    WebGLEnum[WebGLEnum["CW"] = 0x900] = "CW";
    WebGLEnum[WebGLEnum["CCW"] = 0x901] = "CCW";
    WebGLEnum[WebGLEnum["LINE_WIDTH"] = 0xb21] = "LINE_WIDTH";
    WebGLEnum[WebGLEnum["ALIASED_POINT_SIZE_RANGE"] = 0x846d] = "ALIASED_POINT_SIZE_RANGE";
    WebGLEnum[WebGLEnum["ALIASED_LINE_WIDTH_RANGE"] = 0x846e] = "ALIASED_LINE_WIDTH_RANGE";
    WebGLEnum[WebGLEnum["CULL_FACE_MODE"] = 0xb45] = "CULL_FACE_MODE";
    WebGLEnum[WebGLEnum["FRONT_FACE"] = 0xb46] = "FRONT_FACE";
    WebGLEnum[WebGLEnum["DEPTH_RANGE"] = 0xb70] = "DEPTH_RANGE";
    WebGLEnum[WebGLEnum["DEPTH_WRITEMASK"] = 0xb72] = "DEPTH_WRITEMASK";
    WebGLEnum[WebGLEnum["DEPTH_CLEAR_VALUE"] = 0xb73] = "DEPTH_CLEAR_VALUE";
    WebGLEnum[WebGLEnum["DEPTH_FUNC"] = 0xb74] = "DEPTH_FUNC";
    WebGLEnum[WebGLEnum["STENCIL_CLEAR_VALUE"] = 0xb91] = "STENCIL_CLEAR_VALUE";
    WebGLEnum[WebGLEnum["STENCIL_FUNC"] = 0xb92] = "STENCIL_FUNC";
    WebGLEnum[WebGLEnum["STENCIL_FAIL"] = 0xb94] = "STENCIL_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_PASS_DEPTH_FAIL"] = 0xb95] = "STENCIL_PASS_DEPTH_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_PASS_DEPTH_PASS"] = 0xb96] = "STENCIL_PASS_DEPTH_PASS";
    WebGLEnum[WebGLEnum["STENCIL_REF"] = 0xb97] = "STENCIL_REF";
    WebGLEnum[WebGLEnum["STENCIL_VALUE_MASK"] = 0xb93] = "STENCIL_VALUE_MASK";
    WebGLEnum[WebGLEnum["STENCIL_WRITEMASK"] = 0xb98] = "STENCIL_WRITEMASK";
    WebGLEnum[WebGLEnum["STENCIL_BACK_FUNC"] = 0x8800] = "STENCIL_BACK_FUNC";
    WebGLEnum[WebGLEnum["STENCIL_BACK_FAIL"] = 0x8801] = "STENCIL_BACK_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_BACK_PASS_DEPTH_FAIL"] = 0x8802] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    WebGLEnum[WebGLEnum["STENCIL_BACK_PASS_DEPTH_PASS"] = 0x8803] = "STENCIL_BACK_PASS_DEPTH_PASS";
    WebGLEnum[WebGLEnum["STENCIL_BACK_REF"] = 0x8ca3] = "STENCIL_BACK_REF";
    WebGLEnum[WebGLEnum["STENCIL_BACK_VALUE_MASK"] = 0x8ca4] = "STENCIL_BACK_VALUE_MASK";
    WebGLEnum[WebGLEnum["STENCIL_BACK_WRITEMASK"] = 0x8ca5] = "STENCIL_BACK_WRITEMASK";
    WebGLEnum[WebGLEnum["VIEWPORT"] = 0xba2] = "VIEWPORT";
    WebGLEnum[WebGLEnum["SCISSOR_BOX"] = 0xc10] = "SCISSOR_BOX";
    WebGLEnum[WebGLEnum["COLOR_CLEAR_VALUE"] = 0xc22] = "COLOR_CLEAR_VALUE";
    WebGLEnum[WebGLEnum["COLOR_WRITEMASK"] = 0xc23] = "COLOR_WRITEMASK";
    WebGLEnum[WebGLEnum["UNPACK_ALIGNMENT"] = 0xcf5] = "UNPACK_ALIGNMENT";
    WebGLEnum[WebGLEnum["PACK_ALIGNMENT"] = 0xd05] = "PACK_ALIGNMENT";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_SIZE"] = 0xd33] = "MAX_TEXTURE_SIZE";
    WebGLEnum[WebGLEnum["MAX_VIEWPORT_DIMS"] = 0xd3a] = "MAX_VIEWPORT_DIMS";
    WebGLEnum[WebGLEnum["SUBPIXEL_BITS"] = 0xd50] = "SUBPIXEL_BITS";
    WebGLEnum[WebGLEnum["RED_BITS"] = 0xd52] = "RED_BITS";
    WebGLEnum[WebGLEnum["GREEN_BITS"] = 0xd53] = "GREEN_BITS";
    WebGLEnum[WebGLEnum["BLUE_BITS"] = 0xd54] = "BLUE_BITS";
    WebGLEnum[WebGLEnum["ALPHA_BITS"] = 0xd55] = "ALPHA_BITS";
    WebGLEnum[WebGLEnum["DEPTH_BITS"] = 0xd56] = "DEPTH_BITS";
    WebGLEnum[WebGLEnum["STENCIL_BITS"] = 0xd57] = "STENCIL_BITS";
    WebGLEnum[WebGLEnum["POLYGON_OFFSET_UNITS"] = 0x2a00] = "POLYGON_OFFSET_UNITS";
    WebGLEnum[WebGLEnum["POLYGON_OFFSET_FACTOR"] = 0x8038] = "POLYGON_OFFSET_FACTOR";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_2D"] = 0x8069] = "TEXTURE_BINDING_2D";
    WebGLEnum[WebGLEnum["SAMPLE_BUFFERS"] = 0x80a8] = "SAMPLE_BUFFERS";
    WebGLEnum[WebGLEnum["SAMPLES"] = 0x80a9] = "SAMPLES";
    WebGLEnum[WebGLEnum["SAMPLE_COVERAGE_VALUE"] = 0x80aa] = "SAMPLE_COVERAGE_VALUE";
    WebGLEnum[WebGLEnum["SAMPLE_COVERAGE_INVERT"] = 0x80ab] = "SAMPLE_COVERAGE_INVERT";
    WebGLEnum[WebGLEnum["COMPRESSED_TEXTURE_FORMATS"] = 0x86a3] = "COMPRESSED_TEXTURE_FORMATS";
    WebGLEnum[WebGLEnum["DONT_CARE"] = 0x1100] = "DONT_CARE";
    WebGLEnum[WebGLEnum["FASTEST"] = 0x1101] = "FASTEST";
    WebGLEnum[WebGLEnum["NICEST"] = 0x1102] = "NICEST";
    WebGLEnum[WebGLEnum["GENERATE_MIPMAP_HINT"] = 0x8192] = "GENERATE_MIPMAP_HINT";
    WebGLEnum[WebGLEnum["BYTE"] = 0x1400] = "BYTE";
    WebGLEnum[WebGLEnum["UNSIGNED_BYTE"] = 0x1401] = "UNSIGNED_BYTE";
    WebGLEnum[WebGLEnum["SHORT"] = 0x1402] = "SHORT";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT"] = 0x1403] = "UNSIGNED_SHORT";
    WebGLEnum[WebGLEnum["INT"] = 0x1404] = "INT";
    WebGLEnum[WebGLEnum["UNSIGNED_INT"] = 0x1405] = "UNSIGNED_INT";
    WebGLEnum[WebGLEnum["FLOAT"] = 0x1406] = "FLOAT";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT"] = 0x1902] = "DEPTH_COMPONENT";
    WebGLEnum[WebGLEnum["ALPHA"] = 0x1906] = "ALPHA";
    WebGLEnum[WebGLEnum["RGB"] = 0x1907] = "RGB";
    WebGLEnum[WebGLEnum["RGBA"] = 0x1908] = "RGBA";
    WebGLEnum[WebGLEnum["LUMINANCE"] = 0x1909] = "LUMINANCE";
    WebGLEnum[WebGLEnum["LUMINANCE_ALPHA"] = 0x190a] = "LUMINANCE_ALPHA";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT_4_4_4_4"] = 0x8033] = "UNSIGNED_SHORT_4_4_4_4";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT_5_5_5_1"] = 0x8034] = "UNSIGNED_SHORT_5_5_5_1";
    WebGLEnum[WebGLEnum["UNSIGNED_SHORT_5_6_5"] = 0x8363] = "UNSIGNED_SHORT_5_6_5";
    WebGLEnum[WebGLEnum["FRAGMENT_SHADER"] = 0x8b30] = "FRAGMENT_SHADER";
    WebGLEnum[WebGLEnum["VERTEX_SHADER"] = 0x8b31] = "VERTEX_SHADER";
    WebGLEnum[WebGLEnum["MAX_VERTEX_ATTRIBS"] = 0x8869] = "MAX_VERTEX_ATTRIBS";
    WebGLEnum[WebGLEnum["MAX_VERTEX_UNIFORM_VECTORS"] = 0x8dfb] = "MAX_VERTEX_UNIFORM_VECTORS";
    WebGLEnum[WebGLEnum["MAX_VARYING_VECTORS"] = 0x8dfc] = "MAX_VARYING_VECTORS";
    WebGLEnum[WebGLEnum["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 0x8b4d] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    WebGLEnum[WebGLEnum["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 0x8b4c] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_IMAGE_UNITS"] = 0x8872] = "MAX_TEXTURE_IMAGE_UNITS";
    WebGLEnum[WebGLEnum["MAX_FRAGMENT_UNIFORM_VECTORS"] = 0x8dfd] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    WebGLEnum[WebGLEnum["SHADER_TYPE"] = 0x8b4f] = "SHADER_TYPE";
    WebGLEnum[WebGLEnum["DELETE_STATUS"] = 0x8b80] = "DELETE_STATUS";
    WebGLEnum[WebGLEnum["LINK_STATUS"] = 0x8b82] = "LINK_STATUS";
    WebGLEnum[WebGLEnum["VALIDATE_STATUS"] = 0x8b83] = "VALIDATE_STATUS";
    WebGLEnum[WebGLEnum["ATTACHED_SHADERS"] = 0x8b85] = "ATTACHED_SHADERS";
    WebGLEnum[WebGLEnum["ACTIVE_UNIFORMS"] = 0x8b86] = "ACTIVE_UNIFORMS";
    WebGLEnum[WebGLEnum["ACTIVE_ATTRIBUTES"] = 0x8b89] = "ACTIVE_ATTRIBUTES";
    WebGLEnum[WebGLEnum["SHADING_LANGUAGE_VERSION"] = 0x8b8c] = "SHADING_LANGUAGE_VERSION";
    WebGLEnum[WebGLEnum["CURRENT_PROGRAM"] = 0x8b8d] = "CURRENT_PROGRAM";
    WebGLEnum[WebGLEnum["NEVER"] = 0x200] = "NEVER";
    WebGLEnum[WebGLEnum["LESS"] = 0x201] = "LESS";
    WebGLEnum[WebGLEnum["EQUAL"] = 0x202] = "EQUAL";
    WebGLEnum[WebGLEnum["LEQUAL"] = 0x203] = "LEQUAL";
    WebGLEnum[WebGLEnum["GREATER"] = 0x204] = "GREATER";
    WebGLEnum[WebGLEnum["NOTEQUAL"] = 0x205] = "NOTEQUAL";
    WebGLEnum[WebGLEnum["GEQUAL"] = 0x206] = "GEQUAL";
    WebGLEnum[WebGLEnum["ALWAYS"] = 0x207] = "ALWAYS";
    WebGLEnum[WebGLEnum["KEEP"] = 0x1e00] = "KEEP";
    WebGLEnum[WebGLEnum["REPLACE"] = 0x1e01] = "REPLACE";
    WebGLEnum[WebGLEnum["INCR"] = 0x1e02] = "INCR";
    WebGLEnum[WebGLEnum["DECR"] = 0x1e03] = "DECR";
    WebGLEnum[WebGLEnum["INVERT"] = 0x150a] = "INVERT";
    WebGLEnum[WebGLEnum["INCR_WRAP"] = 0x8507] = "INCR_WRAP";
    WebGLEnum[WebGLEnum["DECR_WRAP"] = 0x8508] = "DECR_WRAP";
    WebGLEnum[WebGLEnum["VENDOR"] = 0x1f00] = "VENDOR";
    WebGLEnum[WebGLEnum["RENDERER"] = 0x1f01] = "RENDERER";
    WebGLEnum[WebGLEnum["VERSION"] = 0x1f02] = "VERSION";
    WebGLEnum[WebGLEnum["NEAREST"] = 0x2600] = "NEAREST";
    WebGLEnum[WebGLEnum["LINEAR"] = 0x2601] = "LINEAR";
    WebGLEnum[WebGLEnum["NEAREST_MIPMAP_NEAREST"] = 0x2700] = "NEAREST_MIPMAP_NEAREST";
    WebGLEnum[WebGLEnum["LINEAR_MIPMAP_NEAREST"] = 0x2701] = "LINEAR_MIPMAP_NEAREST";
    WebGLEnum[WebGLEnum["NEAREST_MIPMAP_LINEAR"] = 0x2702] = "NEAREST_MIPMAP_LINEAR";
    WebGLEnum[WebGLEnum["LINEAR_MIPMAP_LINEAR"] = 0x2703] = "LINEAR_MIPMAP_LINEAR";
    WebGLEnum[WebGLEnum["TEXTURE_MAG_FILTER"] = 0x2800] = "TEXTURE_MAG_FILTER";
    WebGLEnum[WebGLEnum["TEXTURE_MIN_FILTER"] = 0x2801] = "TEXTURE_MIN_FILTER";
    WebGLEnum[WebGLEnum["TEXTURE_WRAP_S"] = 0x2802] = "TEXTURE_WRAP_S";
    WebGLEnum[WebGLEnum["TEXTURE_WRAP_T"] = 0x2803] = "TEXTURE_WRAP_T";
    WebGLEnum[WebGLEnum["TEXTURE"] = 0x1702] = "TEXTURE";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP"] = 0x8513] = "TEXTURE_CUBE_MAP";
    WebGLEnum[WebGLEnum["TEXTURE_BINDING_CUBE_MAP"] = 0x8514] = "TEXTURE_BINDING_CUBE_MAP";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_POSITIVE_X"] = 0x8515] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 0x8516] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 0x8517] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 0x8518] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 0x8519] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    WebGLEnum[WebGLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 0x851a] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    WebGLEnum[WebGLEnum["MAX_CUBE_MAP_TEXTURE_SIZE"] = 0x851c] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    WebGLEnum[WebGLEnum["TEXTURE0"] = 0x84c0] = "TEXTURE0";
    WebGLEnum[WebGLEnum["TEXTURE1"] = 0x84c1] = "TEXTURE1";
    WebGLEnum[WebGLEnum["TEXTURE2"] = 0x84c2] = "TEXTURE2";
    WebGLEnum[WebGLEnum["TEXTURE3"] = 0x84c3] = "TEXTURE3";
    WebGLEnum[WebGLEnum["TEXTURE4"] = 0x84c4] = "TEXTURE4";
    WebGLEnum[WebGLEnum["TEXTURE5"] = 0x84c5] = "TEXTURE5";
    WebGLEnum[WebGLEnum["TEXTURE6"] = 0x84c6] = "TEXTURE6";
    WebGLEnum[WebGLEnum["TEXTURE7"] = 0x84c7] = "TEXTURE7";
    WebGLEnum[WebGLEnum["TEXTURE8"] = 0x84c8] = "TEXTURE8";
    WebGLEnum[WebGLEnum["TEXTURE9"] = 0x84c9] = "TEXTURE9";
    WebGLEnum[WebGLEnum["TEXTURE10"] = 0x84ca] = "TEXTURE10";
    WebGLEnum[WebGLEnum["TEXTURE11"] = 0x84cb] = "TEXTURE11";
    WebGLEnum[WebGLEnum["TEXTURE12"] = 0x84cc] = "TEXTURE12";
    WebGLEnum[WebGLEnum["TEXTURE13"] = 0x84cd] = "TEXTURE13";
    WebGLEnum[WebGLEnum["TEXTURE14"] = 0x84ce] = "TEXTURE14";
    WebGLEnum[WebGLEnum["TEXTURE15"] = 0x84cf] = "TEXTURE15";
    WebGLEnum[WebGLEnum["TEXTURE16"] = 0x84d0] = "TEXTURE16";
    WebGLEnum[WebGLEnum["TEXTURE17"] = 0x84d1] = "TEXTURE17";
    WebGLEnum[WebGLEnum["TEXTURE18"] = 0x84d2] = "TEXTURE18";
    WebGLEnum[WebGLEnum["TEXTURE19"] = 0x84d3] = "TEXTURE19";
    WebGLEnum[WebGLEnum["TEXTURE20"] = 0x84d4] = "TEXTURE20";
    WebGLEnum[WebGLEnum["TEXTURE21"] = 0x84d5] = "TEXTURE21";
    WebGLEnum[WebGLEnum["TEXTURE22"] = 0x84d6] = "TEXTURE22";
    WebGLEnum[WebGLEnum["TEXTURE23"] = 0x84d7] = "TEXTURE23";
    WebGLEnum[WebGLEnum["TEXTURE24"] = 0x84d8] = "TEXTURE24";
    WebGLEnum[WebGLEnum["TEXTURE25"] = 0x84d9] = "TEXTURE25";
    WebGLEnum[WebGLEnum["TEXTURE26"] = 0x84da] = "TEXTURE26";
    WebGLEnum[WebGLEnum["TEXTURE27"] = 0x84db] = "TEXTURE27";
    WebGLEnum[WebGLEnum["TEXTURE28"] = 0x84dc] = "TEXTURE28";
    WebGLEnum[WebGLEnum["TEXTURE29"] = 0x84dd] = "TEXTURE29";
    WebGLEnum[WebGLEnum["TEXTURE30"] = 0x84de] = "TEXTURE30";
    WebGLEnum[WebGLEnum["TEXTURE31"] = 0x84df] = "TEXTURE31";
    WebGLEnum[WebGLEnum["ACTIVE_TEXTURE"] = 0x84e0] = "ACTIVE_TEXTURE";
    WebGLEnum[WebGLEnum["REPEAT"] = 0x2901] = "REPEAT";
    WebGLEnum[WebGLEnum["CLAMP_TO_EDGE"] = 0x812f] = "CLAMP_TO_EDGE";
    WebGLEnum[WebGLEnum["MIRRORED_REPEAT"] = 0x8370] = "MIRRORED_REPEAT";
    WebGLEnum[WebGLEnum["FLOAT_VEC2"] = 0x8b50] = "FLOAT_VEC2";
    WebGLEnum[WebGLEnum["FLOAT_VEC3"] = 0x8b51] = "FLOAT_VEC3";
    WebGLEnum[WebGLEnum["FLOAT_VEC4"] = 0x8b52] = "FLOAT_VEC4";
    WebGLEnum[WebGLEnum["INT_VEC2"] = 0x8b53] = "INT_VEC2";
    WebGLEnum[WebGLEnum["INT_VEC3"] = 0x8b54] = "INT_VEC3";
    WebGLEnum[WebGLEnum["INT_VEC4"] = 0x8b55] = "INT_VEC4";
    WebGLEnum[WebGLEnum["BOOL"] = 0x8b56] = "BOOL";
    WebGLEnum[WebGLEnum["BOOL_VEC2"] = 0x8b57] = "BOOL_VEC2";
    WebGLEnum[WebGLEnum["BOOL_VEC3"] = 0x8b58] = "BOOL_VEC3";
    WebGLEnum[WebGLEnum["BOOL_VEC4"] = 0x8b59] = "BOOL_VEC4";
    WebGLEnum[WebGLEnum["FLOAT_MAT2"] = 0x8b5a] = "FLOAT_MAT2";
    WebGLEnum[WebGLEnum["FLOAT_MAT3"] = 0x8b5b] = "FLOAT_MAT3";
    WebGLEnum[WebGLEnum["FLOAT_MAT4"] = 0x8b5c] = "FLOAT_MAT4";
    WebGLEnum[WebGLEnum["SAMPLER_2D"] = 0x8b5e] = "SAMPLER_2D";
    WebGLEnum[WebGLEnum["SAMPLER_CUBE"] = 0x8b60] = "SAMPLER_CUBE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_ENABLED"] = 0x8622] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_SIZE"] = 0x8623] = "VERTEX_ATTRIB_ARRAY_SIZE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_STRIDE"] = 0x8624] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_TYPE"] = 0x8625] = "VERTEX_ATTRIB_ARRAY_TYPE";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 0x886a] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_POINTER"] = 0x8645] = "VERTEX_ATTRIB_ARRAY_POINTER";
    WebGLEnum[WebGLEnum["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 0x889f] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    WebGLEnum[WebGLEnum["IMPLEMENTATION_COLOR_READ_TYPE"] = 0x8b9a] = "IMPLEMENTATION_COLOR_READ_TYPE";
    WebGLEnum[WebGLEnum["IMPLEMENTATION_COLOR_READ_FORMAT"] = 0x8b9b] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    WebGLEnum[WebGLEnum["COMPILE_STATUS"] = 0x8b81] = "COMPILE_STATUS";
    WebGLEnum[WebGLEnum["LOW_FLOAT"] = 0x8df0] = "LOW_FLOAT";
    WebGLEnum[WebGLEnum["MEDIUM_FLOAT"] = 0x8df1] = "MEDIUM_FLOAT";
    WebGLEnum[WebGLEnum["HIGH_FLOAT"] = 0x8df2] = "HIGH_FLOAT";
    WebGLEnum[WebGLEnum["LOW_INT"] = 0x8df3] = "LOW_INT";
    WebGLEnum[WebGLEnum["MEDIUM_INT"] = 0x8df4] = "MEDIUM_INT";
    WebGLEnum[WebGLEnum["HIGH_INT"] = 0x8df5] = "HIGH_INT";
    WebGLEnum[WebGLEnum["FRAMEBUFFER"] = 0x8d40] = "FRAMEBUFFER";
    WebGLEnum[WebGLEnum["RENDERBUFFER"] = 0x8d41] = "RENDERBUFFER";
    WebGLEnum[WebGLEnum["RGBA4"] = 0x8056] = "RGBA4";
    WebGLEnum[WebGLEnum["RGB5_A1"] = 0x8057] = "RGB5_A1";
    WebGLEnum[WebGLEnum["RGB565"] = 0x8d62] = "RGB565";
    WebGLEnum[WebGLEnum["DEPTH_COMPONENT16"] = 0x81a5] = "DEPTH_COMPONENT16";
    WebGLEnum[WebGLEnum["STENCIL_INDEX8"] = 0x8d48] = "STENCIL_INDEX8";
    WebGLEnum[WebGLEnum["DEPTH_STENCIL"] = 0x84f9] = "DEPTH_STENCIL";
    WebGLEnum[WebGLEnum["RENDERBUFFER_WIDTH"] = 0x8d42] = "RENDERBUFFER_WIDTH";
    WebGLEnum[WebGLEnum["RENDERBUFFER_HEIGHT"] = 0x8d43] = "RENDERBUFFER_HEIGHT";
    WebGLEnum[WebGLEnum["RENDERBUFFER_INTERNAL_FORMAT"] = 0x8d44] = "RENDERBUFFER_INTERNAL_FORMAT";
    WebGLEnum[WebGLEnum["RENDERBUFFER_RED_SIZE"] = 0x8d50] = "RENDERBUFFER_RED_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_GREEN_SIZE"] = 0x8d51] = "RENDERBUFFER_GREEN_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_BLUE_SIZE"] = 0x8d52] = "RENDERBUFFER_BLUE_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_ALPHA_SIZE"] = 0x8d53] = "RENDERBUFFER_ALPHA_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_DEPTH_SIZE"] = 0x8d54] = "RENDERBUFFER_DEPTH_SIZE";
    WebGLEnum[WebGLEnum["RENDERBUFFER_STENCIL_SIZE"] = 0x8d55] = "RENDERBUFFER_STENCIL_SIZE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 0x8cd0] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 0x8cd1] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 0x8cd2] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 0x8cd3] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    WebGLEnum[WebGLEnum["COLOR_ATTACHMENT0"] = 0x8ce0] = "COLOR_ATTACHMENT0";
    WebGLEnum[WebGLEnum["DEPTH_ATTACHMENT"] = 0x8d00] = "DEPTH_ATTACHMENT";
    WebGLEnum[WebGLEnum["STENCIL_ATTACHMENT"] = 0x8d20] = "STENCIL_ATTACHMENT";
    WebGLEnum[WebGLEnum["DEPTH_STENCIL_ATTACHMENT"] = 0x821a] = "DEPTH_STENCIL_ATTACHMENT";
    WebGLEnum[WebGLEnum["NONE"] = 0x0] = "NONE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_COMPLETE"] = 0x8cd5] = "FRAMEBUFFER_COMPLETE";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 0x8cd6] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 0x8cd7] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 0x8cd9] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_UNSUPPORTED"] = 0x8cdd] = "FRAMEBUFFER_UNSUPPORTED";
    WebGLEnum[WebGLEnum["FRAMEBUFFER_BINDING"] = 0x8ca6] = "FRAMEBUFFER_BINDING";
    WebGLEnum[WebGLEnum["RENDERBUFFER_BINDING"] = 0x8ca7] = "RENDERBUFFER_BINDING";
    WebGLEnum[WebGLEnum["MAX_RENDERBUFFER_SIZE"] = 0x84e8] = "MAX_RENDERBUFFER_SIZE";
    WebGLEnum[WebGLEnum["INVALID_FRAMEBUFFER_OPERATION"] = 0x506] = "INVALID_FRAMEBUFFER_OPERATION";
    WebGLEnum[WebGLEnum["UNPACK_FLIP_Y_WEBGL"] = 0x9240] = "UNPACK_FLIP_Y_WEBGL";
    WebGLEnum[WebGLEnum["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 0x9241] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    WebGLEnum[WebGLEnum["CONTEXT_LOST_WEBGL"] = 0x9242] = "CONTEXT_LOST_WEBGL";
    WebGLEnum[WebGLEnum["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 0x9243] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    WebGLEnum[WebGLEnum["BROWSER_DEFAULT_WEBGL"] = 0x9244] = "BROWSER_DEFAULT_WEBGL";
    WebGLEnum[WebGLEnum["TEXTURE_MAX_ANISOTROPY"] = 0x84fe] = "TEXTURE_MAX_ANISOTROPY";
    WebGLEnum[WebGLEnum["MAX_TEXTURE_MAX_ANISOTROPY"] = 0x84ff] = "MAX_TEXTURE_MAX_ANISOTROPY";
})(WebGLEnum || (WebGLEnum = {}));

function isWebGL2(gl) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return !!(gl && gl.texStorage2D);
}
class WebGLError extends Error {
    static errorToString = {
        [WebGLEnum.NO_ERROR]: 'NO_ERROR',
        [WebGLEnum.INVALID_ENUM]: 'INVALID_ENUM',
        [WebGLEnum.INVALID_VALUE]: 'INVALID_VALUE',
        [WebGLEnum.INVALID_OPERATION]: 'INVALID_OPERATION',
        [WebGLEnum.INVALID_FRAMEBUFFER_OPERATION]: 'INVALID_FRAMEBUFFER_OPERATION',
        [WebGLEnum.OUT_OF_MEMORY]: 'OUT_OF_MEMORY',
        [WebGLEnum.CONTEXT_LOST_WEBGL]: 'CONTEXT_LOST_WEBGL'
    };
    code;
    constructor(code){
        super(WebGLError.errorToString[code]);
        this.code = code;
    }
}

const blendEquationMap = {
    add: WebGLEnum.FUNC_ADD,
    subtract: WebGLEnum.FUNC_SUBTRACT,
    'reverse-subtract': WebGLEnum.FUNC_REVERSE_SUBTRACT,
    max: WebGLEnum.FUNC_MAX,
    min: WebGLEnum.FUNC_MIN
};
const blendEquationInvMap = {
    [WebGLEnum.FUNC_ADD]: 'add',
    [WebGLEnum.FUNC_SUBTRACT]: 'subtract',
    [WebGLEnum.FUNC_REVERSE_SUBTRACT]: 'reverse-subtract',
    [WebGLEnum.FUNC_MAX]: 'max',
    [WebGLEnum.FUNC_MIN]: 'min'
};
const blendFuncMap = {
    zero: WebGLEnum.ZERO,
    one: WebGLEnum.ONE,
    'src-alpha': WebGLEnum.SRC_ALPHA,
    'inv-src-alpha': WebGLEnum.ONE_MINUS_SRC_ALPHA,
    'src-alpha-saturate': WebGLEnum.BLEND,
    'dst-alpha': WebGLEnum.DST_ALPHA,
    'inv-dst-alpha': WebGLEnum.ONE_MINUS_DST_ALPHA,
    'src-color': WebGLEnum.SRC_COLOR,
    'inv-src-color': WebGLEnum.ONE_MINUS_SRC_COLOR,
    'dst-color': WebGLEnum.DST_COLOR,
    'inv-dst-color': WebGLEnum.ONE_MINUS_DST_COLOR,
    'const-color': WebGLEnum.CONSTANT_COLOR,
    'inv-const-color': WebGLEnum.ONE_MINUS_CONSTANT_COLOR,
    'const-alpha': WebGLEnum.CONSTANT_ALPHA,
    'inv-const-alpha': WebGLEnum.ONE_MINUS_CONSTANT_ALPHA
};
const blendFuncInvMap = {
    [WebGLEnum.ZERO]: 'zero',
    [WebGLEnum.ONE]: 'one',
    [WebGLEnum.SRC_ALPHA]: 'src-alpha',
    [WebGLEnum.ONE_MINUS_SRC_ALPHA]: 'inv-src-alpha',
    [WebGLEnum.SRC_ALPHA_SATURATE]: 'src-alpha-saturate',
    [WebGLEnum.DST_ALPHA]: 'dst-alpha',
    [WebGLEnum.ONE_MINUS_DST_ALPHA]: 'inv-dst-alpha',
    [WebGLEnum.SRC_COLOR]: 'src-color',
    [WebGLEnum.ONE_MINUS_SRC_COLOR]: 'inv-src-color',
    [WebGLEnum.DST_COLOR]: 'dst-color',
    [WebGLEnum.ONE_MINUS_DST_COLOR]: 'inv-dst-color',
    [WebGLEnum.CONSTANT_COLOR]: 'const-color',
    [WebGLEnum.ONE_MINUS_CONSTANT_COLOR]: 'inv-const-color',
    [WebGLEnum.CONSTANT_ALPHA]: 'const-alpha',
    [WebGLEnum.ONE_MINUS_CONSTANT_ALPHA]: 'inv-const-alpha'
};
const faceModeMap = {
    none: WebGLEnum.NONE,
    front: WebGLEnum.FRONT,
    back: WebGLEnum.BACK
};
const faceModeInvMap = {
    [WebGLEnum.NONE]: 'none',
    [WebGLEnum.FRONT]: 'front',
    [WebGLEnum.BACK]: 'back'
};
({
    cw: WebGLEnum.CW,
    ccw: WebGLEnum.CCW
});
({
    [WebGLEnum.CW]: 'cw',
    [WebGLEnum.CCW]: 'ccw'
});
const stencilOpMap = {
    keep: WebGLEnum.KEEP,
    zero: WebGLEnum.ZERO,
    replace: WebGLEnum.REPLACE,
    incr: WebGLEnum.INCR,
    'incr-wrap': WebGLEnum.INCR_WRAP,
    decr: WebGLEnum.DECR,
    'decr-wrap': WebGLEnum.DECR_WRAP,
    invert: WebGLEnum.INVERT
};
const stencilOpInvMap = {
    [WebGLEnum.KEEP]: 'keep',
    [WebGLEnum.ZERO]: 'zero',
    [WebGLEnum.REPLACE]: 'replace',
    [WebGLEnum.INCR]: 'incr',
    [WebGLEnum.INCR_WRAP]: 'incr-wrap',
    [WebGLEnum.DECR]: 'decr',
    [WebGLEnum.DECR_WRAP]: 'decr-wrap',
    [WebGLEnum.INVERT]: 'invert'
};
const compareFuncMap = {
    always: WebGLEnum.ALWAYS,
    le: WebGLEnum.LEQUAL,
    ge: WebGLEnum.GEQUAL,
    lt: WebGLEnum.LESS,
    gt: WebGLEnum.GREATER,
    eq: WebGLEnum.EQUAL,
    ne: WebGLEnum.NOTEQUAL,
    never: WebGLEnum.NEVER
};
const compareFuncInvMap = {
    [WebGLEnum.NONE]: null,
    [WebGLEnum.ALWAYS]: 'always',
    [WebGLEnum.LEQUAL]: 'le',
    [WebGLEnum.GEQUAL]: 'ge',
    [WebGLEnum.LESS]: 'lt',
    [WebGLEnum.GREATER]: 'gt',
    [WebGLEnum.EQUAL]: 'eq',
    [WebGLEnum.NOTEQUAL]: 'ne',
    [WebGLEnum.NEVER]: 'never'
};
const textureWrappingMap = {
    repeat: WebGLEnum.REPEAT,
    'mirrored-repeat': WebGLEnum.MIRRORED_REPEAT,
    clamp: WebGLEnum.CLAMP_TO_EDGE
};
const typeMap = {
    [PBPrimitiveType.BOOL]: WebGLEnum.BOOL,
    [PBPrimitiveType.BVEC2]: WebGLEnum.BOOL_VEC2,
    [PBPrimitiveType.BVEC3]: WebGLEnum.BOOL_VEC3,
    [PBPrimitiveType.BVEC4]: WebGLEnum.BOOL_VEC4,
    [PBPrimitiveType.F32]: WebGLEnum.FLOAT,
    [PBPrimitiveType.F32VEC2]: WebGLEnum.FLOAT_VEC2,
    [PBPrimitiveType.F32VEC3]: WebGLEnum.FLOAT_VEC3,
    [PBPrimitiveType.F32VEC4]: WebGLEnum.FLOAT_VEC4,
    [PBPrimitiveType.I8]: WebGLEnum.BYTE,
    [PBPrimitiveType.I16]: WebGLEnum.SHORT,
    [PBPrimitiveType.I32]: WebGLEnum.INT,
    [PBPrimitiveType.I32VEC2]: WebGLEnum.INT_VEC2,
    [PBPrimitiveType.I32VEC3]: WebGLEnum.INT_VEC3,
    [PBPrimitiveType.I32VEC4]: WebGLEnum.INT_VEC4,
    [PBPrimitiveType.U8]: WebGLEnum.UNSIGNED_BYTE,
    [PBPrimitiveType.U8_NORM]: WebGLEnum.UNSIGNED_BYTE,
    [PBPrimitiveType.I8_NORM]: WebGLEnum.BYTE,
    [PBPrimitiveType.U16]: WebGLEnum.UNSIGNED_SHORT,
    [PBPrimitiveType.U16_NORM]: WebGLEnum.UNSIGNED_SHORT,
    [PBPrimitiveType.I16_NORM]: WebGLEnum.SHORT,
    [PBPrimitiveType.U32]: WebGLEnum.UNSIGNED_INT,
    [PBPrimitiveType.U32VEC2]: WebGLEnum.UNSIGNED_INT_VEC2,
    [PBPrimitiveType.U32VEC3]: WebGLEnum.UNSIGNED_INT_VEC3,
    [PBPrimitiveType.U32VEC4]: WebGLEnum.UNSIGNED_INT_VEC4
};
const primitiveTypeMap = {
    'triangle-list': WebGLEnum.TRIANGLES,
    'triangle-strip': WebGLEnum.TRIANGLE_STRIP,
    'triangle-fan': WebGLEnum.TRIANGLE_FAN,
    'line-list': WebGLEnum.LINES,
    'line-strip': WebGLEnum.LINE_STRIP,
    'point-list': WebGLEnum.POINTS
};
const textureTargetMap = {
    '2d': WebGLEnum.TEXTURE_2D,
    '3d': WebGLEnum.TEXTURE_3D,
    cube: WebGLEnum.TEXTURE_CUBE_MAP,
    '2darray': WebGLEnum.TEXTURE_2D_ARRAY
};
const cubeMapFaceMap = {
    [CubeFace.PX]: WebGLEnum.TEXTURE_CUBE_MAP_POSITIVE_X,
    [CubeFace.NX]: WebGLEnum.TEXTURE_CUBE_MAP_NEGATIVE_X,
    [CubeFace.PY]: WebGLEnum.TEXTURE_CUBE_MAP_POSITIVE_Y,
    [CubeFace.NY]: WebGLEnum.TEXTURE_CUBE_MAP_NEGATIVE_Y,
    [CubeFace.PZ]: WebGLEnum.TEXTURE_CUBE_MAP_POSITIVE_Z,
    [CubeFace.NZ]: WebGLEnum.TEXTURE_CUBE_MAP_NEGATIVE_Z
};
function textureMagFilterToWebGL(magFilter) {
    switch(magFilter){
        case 'nearest':
            return WebGLEnum.NEAREST;
        case 'linear':
            return WebGLEnum.LINEAR;
        default:
            return WebGLEnum.NONE;
    }
}
function textureMinFilterToWebGL(minFilter, mipFilter) {
    switch(minFilter){
        case 'nearest':
            switch(mipFilter){
                case 'none':
                    return WebGLEnum.NEAREST;
                case 'nearest':
                    return WebGLEnum.NEAREST_MIPMAP_NEAREST;
                case 'linear':
                    return WebGLEnum.NEAREST_MIPMAP_LINEAR;
            }
            break;
        case 'linear':
            switch(mipFilter){
                case 'none':
                    return WebGLEnum.LINEAR;
                case 'nearest':
                    return WebGLEnum.LINEAR_MIPMAP_NEAREST;
                case 'linear':
                    return WebGLEnum.LINEAR_MIPMAP_LINEAR;
            }
            break;
    }
    return WebGLEnum.NONE;
}

let _uniqueId = 0;
class WebGLGPUObject extends makeEventTarget(Object)() {
    _device;
    _object;
    _uid;
    _cid;
    _name;
    _restoreHandler;
    constructor(device){
        super();
        this._device = device;
        this._object = null;
        this._uid = ++_uniqueId;
        this._cid = 1;
        this._name = `${genDefaultName(this)}#${this._uid}`;
        this._restoreHandler = null;
        this._device.addGPUObject(this);
    }
    get device() {
        return this._device;
    }
    get object() {
        return this._object;
    }
    get disposed() {
        return !this._object;
    }
    get restoreHandler() {
        return this._restoreHandler;
    }
    set restoreHandler(handler) {
        this._restoreHandler = handler;
    }
    get uid() {
        return this._uid;
    }
    get cid() {
        return this._cid;
    }
    get name() {
        return this._name;
    }
    set name(val) {
        if (val !== this._name) {
            const evt = new DeviceGPUObjectRenameEvent(this, this._name);
            this._name = val;
            this._device.dispatchEvent(evt);
        }
    }
    isVertexLayout() {
        return false;
    }
    isFramebuffer() {
        return false;
    }
    isSampler() {
        return false;
    }
    isTexture() {
        return false;
    }
    isTexture2D() {
        return false;
    }
    isTexture2DArray() {
        return false;
    }
    isTexture3D() {
        return false;
    }
    isTextureCube() {
        return false;
    }
    isTextureVideo() {
        return false;
    }
    isProgram() {
        return false;
    }
    isBuffer() {
        return false;
    }
    isBindGroup() {
        return false;
    }
    dispose() {
        if (!this.disposed) {
            this._device.disposeObject(this, true);
        }
    }
    async reload() {
        if (this.disposed) {
            const p = this._device.restoreObject(this);
            this._cid++;
            return p;
        }
    }
    destroy() {
        throw new Error('Abstract function call: destroy()');
    }
    async restore() {
        throw new Error('Abstract function call: restore()');
    }
}

class WebGLBaseTexture extends WebGLGPUObject {
    _target;
    _memCost;
    _flags;
    _width;
    _height;
    _depth;
    _format;
    _mipLevelCount;
    _samplerOptions;
    _webgl1fallback;
    constructor(device, target){
        super(device);
        this._target = target || '2d';
        this._memCost = 0;
        this._flags = 0;
        this._width = 0;
        this._height = 0;
        this._depth = 1;
        this._format = 'unknown';
        this._mipLevelCount = 0;
        this._samplerOptions = null;
        this._webgl1fallback = false;
    }
    get target() {
        return this._target;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get depth() {
        return this._depth;
    }
    get format() {
        return this._format;
    }
    get mipLevelCount() {
        return this._mipLevelCount;
    }
    get samplerOptions() {
        return this._samplerOptions;
    }
    set samplerOptions(options) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._samplerOptions = options ? Object.assign({}, this._getSamplerOptions(params, !!options.compare), options) : null;
    }
    get isWebGL1Fallback() {
        return this._webgl1fallback;
    }
    isFilterable() {
        if (!this.getTextureCaps().getTextureFormatInfo(this._format)?.filterable) {
            return false;
        }
        if (!this.device.isWebGL2 && !isPowerOf2(this._width) && !isPowerOf2(this._height)) {
            return false;
        }
        return true;
    }
    destroy() {
        if (this._object) {
            this._device.context.deleteTexture(this._object);
            this._device.invalidateBindingTextures();
            this._object = null;
            this._device.updateVideoMemoryCost(-this._memCost);
            this._memCost = 0;
        }
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.init();
        }
    }
    isTexture() {
        return true;
    }
    getTextureCaps() {
        return this._device.getDeviceCaps().textureCaps;
    }
    isSRGBFormat() {
        return isSRGBTextureFormat(this._format);
    }
    isFloatFormat() {
        return isFloatTextureFormat(this._format);
    }
    isIntegerFormat() {
        return isIntegerTextureFormat(this._format);
    }
    isSignedFormat() {
        return isSignedTextureFormat(this._format);
    }
    isCompressedFormat() {
        return isCompressedTextureFormat(this._format);
    }
    isDepth() {
        return hasDepthChannel(this._format);
    }
    getDefaultSampler(shadow) {
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        return this._device.createSampler(!this._samplerOptions || !this._samplerOptions.compare !== !shadow ? this._getSamplerOptions(params, shadow) : this._samplerOptions);
    }
    /** @internal */ allocInternal(format, width, height, depth, numMipLevels) {
        if (!this._device.isWebGL2 && (!isPowerOf2(width) || !isPowerOf2(height))) {
            numMipLevels = 1;
            this._webgl1fallback = true;
        } else {
            this._webgl1fallback = false;
        }
        this._device.setCurrentSamplerForTexture(this, null);
        if (numMipLevels === 0) {
            numMipLevels = this._calcMipLevelCount(format, width, height, depth);
        } else if (numMipLevels !== 1) {
            let size = Math.max(width, height);
            if (this.isTexture3D()) {
                size = Math.max(size, depth);
            }
            const autoMipLevelCount = Math.floor(Math.log2(size)) + 1; //this._calcMipLevelCount(format, width, height, depth);
            if (!Number.isInteger(numMipLevels) || numMipLevels < 0 || numMipLevels > autoMipLevelCount) {
                numMipLevels = autoMipLevelCount;
            }
        }
        if (this._object && (this._format !== format || this._width !== width || this._height !== height || this._depth !== depth, this._mipLevelCount !== numMipLevels)) {
            const obj = this._object;
            this._device.runNextFrame(()=>{
                this._device.context.deleteTexture(obj);
                this._device.invalidateBindingTextures();
            });
            this._object = null;
        }
        if (!this._object) {
            this._format = format;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._mipLevelCount = numMipLevels;
            if (!this._device.isContextLost()) {
                this._object = this._device.context.createTexture();
                const gl = this._device.context;
                this._device.bindTexture(textureTargetMap[this._target], 0, this);
                //gl.bindTexture(textureTargetMap[this._target], this._object);
                const params = this.getTextureCaps().getTextureFormatInfo(this._format);
                if (isWebGL2(gl) && !this.isTextureVideo()) {
                    if (!this.isTexture3D() && !this.isTexture2DArray()) {
                        gl.texStorage2D(textureTargetMap[this._target], this._mipLevelCount, params.glInternalFormat, this._width, this._height);
                    } else {
                        gl.texStorage3D(textureTargetMap[this._target], this._mipLevelCount, params.glInternalFormat, this._width, this._height, this._depth);
                    }
                    this._device.context.texParameteri(textureTargetMap[this._target], WebGLEnum.TEXTURE_BASE_LEVEL, 0);
                    this._device.context.texParameteri(textureTargetMap[this._target], WebGLEnum.TEXTURE_MAX_LEVEL, this._mipLevelCount - 1);
                } else {
                    let w = this._width;
                    let h = this._height;
                    const isCompressed = isCompressedTextureFormat(this._format);
                    const blockWidth = getTextureFormatBlockWidth(this._format);
                    const blockHeight = getTextureFormatBlockHeight(this._format);
                    const blockSize = getTextureFormatBlockSize(this._format);
                    for(let mip = 0; mip < numMipLevels; mip++){
                        const data = isCompressed ? new Uint8Array(Math.ceil(w / blockWidth) * Math.ceil(h / blockHeight) * blockSize) : null;
                        data?.fill(0xff);
                        if (this.isTextureCube()) {
                            for(let face = 0; face < 6; face++){
                                const faceTarget = cubeMapFaceMap[face];
                                if (isCompressed) {
                                    this._device.context.compressedTexImage2D(faceTarget, mip, params.glInternalFormat, w, h, 0, data);
                                } else {
                                    this._device.context.texImage2D(faceTarget, mip, params.glInternalFormat, w, h, 0, params.glFormat, params.glType[0], null);
                                }
                            }
                        } else {
                            if (isCompressed) {
                                this._device.context.compressedTexImage2D(textureTargetMap[this._target], mip, params.glInternalFormat, w, h, 0, data);
                            } else {
                                this._device.context.texImage2D(textureTargetMap[this._target], mip, params.glInternalFormat, w, h, 0, params.glFormat, params.glType[0], null);
                            }
                        }
                        w = Math.max(w >> 1, 1);
                        h = Math.max(h >> 1, 1);
                    }
                }
                const k = this.isTextureCube() ? 6 : 1;
                const memCost = this.getTextureCaps().calcMemoryUsage(this._format, params.glType[0], this._width * this._height * this._depth * k);
                this._device.updateVideoMemoryCost(memCost - this._memCost);
                this._memCost = memCost;
            }
        }
    }
    /** @internal */ _calcMipLevelCount(format, width, height, depth) {
        if (hasDepthChannel(format) || this.isTextureVideo()) {
            return 1;
        }
        if (this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) {
            return 1;
        }
        if (!this._device.isWebGL2 && (!isPowerOf2(width) || !isPowerOf2(height))) {
            return 1;
        }
        const params = this.getTextureCaps().getTextureFormatInfo(format);
        if (!params || !params.renderable) {
            return 1;
        }
        let size = Math.max(width, height);
        if (this.isTexture3D()) {
            size = Math.max(size, depth);
        }
        return Math.floor(Math.log2(size)) + 1;
    }
    /** @internal */ _getSamplerOptions(params, shadow) {
        const comparison = this.isDepth() && shadow;
        const filterable = params.filterable || comparison;
        const magFilter = filterable ? 'linear' : 'nearest';
        const minFilter = filterable ? 'linear' : 'nearest';
        const mipFilter = this._mipLevelCount > 1 ? filterable ? 'linear' : 'nearest' : 'none';
        return {
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter,
            minFilter,
            mipFilter,
            compare: comparison ? 'le' : null
        };
    }
}

class WebGLTexture2D extends WebGLBaseTexture {
    constructor(device){
        super(device, '2d');
    }
    isTexture2D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.bindTexture(textureTargetMap[this._target], 0, this);
        //this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, width, height, params.glFormat, params.glType[0], data);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, xOffset, yOffset, x, y, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.bindTexture(textureTargetMap[this._target], 0, this);
        //this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        if (x === 0 && y === 0 && width === data.width && height === data.height) {
            this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, params.glFormat, params.glType[0], data);
        } else {
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, x, y, width, height, 0, 0, width, height);
            this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, params.glFormat, params.glType[0], cvs);
            cvs.width = 0;
            cvs.height = 0;
        }
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    async readPixels(x, y, w, h, faceOrLevel, mipLevel, buffer) {
        if (faceOrLevel !== 0) {
            throw new Error(`Texture2D.readPixels(): parameter 'faceOrLayer' must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        if (!this.device.isContextLost() && !this.disposed) {
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            await this._device.readPixels(0, x, y, w, h, buffer);
            this._device.popDeviceStates();
            fb.dispose();
        }
    }
    readPixelsToBuffer(x, y, w, h, faceOrLevel, mipLevel, buffer) {
        if (faceOrLevel !== 0) {
            throw new Error(`Texture2D.readPixelsToBuffer(): parameter 'faceOrLayer' must be 0`);
        }
        if (mipLevel >= this.mipLevelCount || mipLevel < 0) {
            throw new Error(`Texture2D.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        if (!this.device.isContextLost() && !this.disposed) {
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
            this._device.popDeviceStates();
            fb.dispose();
        }
    }
    loadFromElement(element, sRGB, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            const format = sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm';
            this.loadImage(element, format);
        }
    }
    createEmpty(format, width, height, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, width, height, 0);
        }
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.bindTexture(target, 0, this);
            //this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (data.isCubemap || data.isVolume) {
            console.error('loading 2d texture with mipmap data failed: data is not 2d texture');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error(new Error('webgl device does not support storage texture'));
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, width, height, numMipLevels) {
        this.allocInternal(format, width, height, 1, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    /** @internal */ loadLevels(levels, sRGB) {
        let format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        let swizzle = false;
        if (format === 'bgra8unorm') {
            format = 'rgba8unorm';
            swizzle = true;
        } else if (format === 'bgra8unorm-srgb') {
            format = 'rgba8unorm-srgb';
            swizzle = true;
        }
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.warn('No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            const target = textureTargetMap[this._target];
            this._device.bindTexture(target, 0, this);
            //this._device.context.bindTexture(target, this._object);
            this.device.clearErrors();
            for(let i = 0; i < this._mipLevelCount; i++){
                if (levels.isCompressed) {
                    this._device.context.compressedTexSubImage2D(target, i, 0, 0, levels.mipDatas[0][i].width, levels.mipDatas[0][i].height, params.glInternalFormat, levels.mipDatas[0][i].data);
                } else {
                    if (swizzle) {
                        // convert bgra to rgba
                        for(let j = 0; j < levels.mipDatas[0][i].width * levels.mipDatas[0][i].height; j++){
                            const t = levels.mipDatas[0][i].data[j * 4];
                            levels.mipDatas[0][i].data[j * 4] = levels.mipDatas[0][i].data[j * 4 + 2];
                            levels.mipDatas[0][i].data[j * 4 + 2] = t;
                        }
                    }
                    this._device.context.texSubImage2D(target, i, 0, 0, levels.mipDatas[0][i].width, levels.mipDatas[0][i].height, params.glFormat, params.glType[0], levels.mipDatas[0][i].data);
                }
                const err = this.device.getError();
                if (err) {
                    console.error(err);
                    return;
                }
            }
        }
    }
    /** @internal */ loadImage(element, format) {
        this.allocInternal(format, Number(element.width), Number(element.height), 1, 0);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            this.device.clearErrors();
            const target = textureTargetMap[this._target];
            this._device.bindTexture(target, 0, this);
            //this._device.context.bindTexture(target, this._object);
            this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 4);
            this._device.context.texSubImage2D(target, 0, 0, 0, params.glFormat, params.glType[0], element);
            const err = this.device.getError();
            if (err) {
                console.error(err);
            }
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
}

class WebGLTexture2DArray extends WebGLBaseTexture {
    constructor(device){
        if (!device.isWebGL2) {
            throw new Error('device does not support 2d texture array');
        }
        super(device, '2darray');
    }
    isTexture2DArray() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        const gl = this._device.context;
        this._device.bindTexture(textureTargetMap[this._target], 0, this);
        //gl.bindTexture(textureTargetMap[this._target], this._object);
        gl.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, zOffset, width, height, depth, params.glFormat, params.glType[0], data);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, 1) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture2DArray.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, levels.arraySize, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            const gl = this._device.context;
            this._device.bindTexture(textureTargetMap[this._target], 0, this);
            //gl.bindTexture(textureTargetMap[this._target], this._object);
            this.device.clearErrors();
            for(let layer = 0; layer < levels.arraySize; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture2DArray.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    if (levels.isCompressed) {
                        gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glInternalFormat, levels.mipDatas[layer][i].data);
                    } else {
                        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glFormat, params.glType[0], levels.mipDatas[layer][i].data);
                    }
                    const err = this.device.getError();
                    if (err) {
                        console.error(err);
                        return;
                    }
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
    updateFromElement(data, xOffset, yOffset, layerIndex, x, y, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        const gl = this._device.context;
        this._device.bindTexture(textureTargetMap[this._target], 0, this);
        //gl.bindTexture(textureTargetMap[this._target], this._object);
        gl.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        if (x === 0 && y === 0 && width === data.width && height === data.height) {
            gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, layerIndex, width, height, 1, params.glFormat, params.glType[0], data);
        } else {
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, x, y, width, height, 0, 0, width, height);
            gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, layerIndex, width, height, 1, params.glFormat, params.glType[0], cvs);
            cvs.width = 0;
            cvs.height = 0;
        }
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, width, height, depth, 0);
        }
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.bindTexture(target, 0, this);
            //this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixels(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        return new Promise((resolve)=>{
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentLayer(0, layer);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixels(0, x, y, w, h, buffer).then(()=>{
                fb.dispose();
                resolve();
            });
            this._device.popDeviceStates();
        });
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (layer < 0 || layer >= this._depth) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid layer: ${layer}`);
        }
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`Texture2DArray.readPixelsToBuffer(): invalid miplevel: ${mipLevel}`);
        }
        const fb = this._device.createFrameBuffer([
            this
        ], null);
        fb.setColorAttachmentLayer(0, layer);
        fb.setColorAttachmentMipLevel(0, mipLevel);
        fb.setColorAttachmentGenerateMipmaps(0, false);
        this._device.pushDeviceStates();
        this._device.setFramebuffer(fb);
        this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
        this._device.popDeviceStates();
        fb.dispose();
    }
    loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
}

class WebGLTexture3D extends WebGLBaseTexture {
    constructor(device){
        if (!device.isWebGL2) {
            throw new Error('device does not support 3D texture');
        }
        super(device, '3d');
    }
    get depth() {
        return this._depth;
    }
    isTexture3D() {
        return true;
    }
    init() {
        this.loadEmpty(this._format, this._width, this._height, this._depth, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, zOffset, width, height, depth) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, this._depth, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        const gl = this._device.context;
        this._device.bindTexture(textureTargetMap[this._target], 0, this);
        //gl.bindTexture(textureTargetMap[this._target], this._object);
        gl.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        gl.texSubImage3D(textureTargetMap[this._target], 0, xOffset, yOffset, zOffset, width, height, depth, params.glFormat, params.glType[0], data);
    }
    createEmpty(format, width, height, depth, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, width, height, depth, 0);
        }
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.bindTexture(target, 0, this);
            //this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    readPixels(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixels(): parameter mipLevel must be 0`);
        }
        return new Promise((resolve)=>{
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentLayer(0, layer);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixels(0, x, y, w, h, buffer).then(()=>{
                fb.dispose();
                resolve();
            });
            this._device.popDeviceStates();
        });
    }
    readPixelsToBuffer(x, y, w, h, layer, mipLevel, buffer) {
        if (mipLevel !== 0) {
            throw new Error(`Texture3D.readPixelsToBuffer(): parameter mipLevel must be 0`);
        }
        const fb = this._device.createFrameBuffer([
            this
        ], null);
        fb.setColorAttachmentLayer(0, layer);
        fb.setColorAttachmentGenerateMipmaps(0, false);
        this._device.pushDeviceStates();
        this._device.setFramebuffer(fb);
        this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
        this._device.popDeviceStates();
        fb.dispose();
    }
    createWithMipmapData(data, creationFlags) {
        if (!data.arraySize) {
            console.error('Texture2DArray.createWithMipmapData() failed: Data is not texture array');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('Texture2DArray.createWithMipmapData() failed: Webgl device does not support storage texture');
            } else {
                this.loadLevels(data);
            }
        }
    }
    loadLevels(levels) {
        const format = levels.format;
        const width = levels.width;
        const height = levels.height;
        const depth = levels.depth;
        const mipLevelCount = levels.mipLevels === 1 && !(this._flags & GPUResourceUsageFlags.TF_NO_MIPMAP) ? this._calcMipLevelCount(levels.format, width, height, depth) : levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.error('Texture2DArray.loadLevels(): No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, levels.arraySize, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            const gl = this._device.context;
            this._device.bindTexture(textureTargetMap[this._target], 0, this);
            //gl.bindTexture(textureTargetMap[this._target], this._object);
            this.device.clearErrors();
            for(let layer = 0; layer < depth; layer++){
                if (levels.mipDatas[layer].length !== levels.mipLevels) {
                    console.log(`Texture2DArray.loadLevels() failed: Invalid texture data`);
                    return;
                }
                for(let i = 0; i < levels.mipLevels; i++){
                    if (levels.isCompressed) {
                        gl.compressedTexSubImage3D(gl.TEXTURE_3D, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glInternalFormat, levels.mipDatas[layer][i].data);
                    } else {
                        gl.texSubImage3D(gl.TEXTURE_3D, i, 0, 0, layer, levels.mipDatas[layer][i].width, levels.mipDatas[layer][i].height, 1, params.glFormat, params.glType[0], levels.mipDatas[layer][i].data);
                    }
                    const err = this.device.getError();
                    if (err) {
                        console.error(err);
                        return;
                    }
                }
            }
            if (levels.mipLevels !== this.mipLevelCount) {
                this.generateMipmaps();
            }
        }
    }
    /** @internal */ loadEmpty(format, width, height, depth, numMipLevels) {
        this.allocInternal(format, width, height, depth, numMipLevels);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
}

class WebGLTextureCube extends WebGLBaseTexture {
    constructor(device){
        super(device, 'cube');
    }
    init() {
        this.loadEmpty(this._format, this._width, this._mipLevelCount);
    }
    update(data, xOffset, yOffset, width, height, face) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.bindTexture(textureTargetMap[this._target], 0, this);
        //this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        this._device.context.texSubImage2D(cubeMapFaceMap[face], 0, xOffset, yOffset, width, height, params.glFormat, params.glType[0], data);
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    updateFromElement(data, xOffset, yOffset, face, x, y, width, height) {
        if (this._device.isContextLost()) {
            return;
        }
        if (!this._object) {
            this.allocInternal(this._format, this._width, this._height, 1, this._mipLevelCount);
        }
        const params = this.getTextureCaps().getTextureFormatInfo(this._format);
        this._device.bindTexture(textureTargetMap[this._target], 0, this);
        //this._device.context.bindTexture(textureTargetMap[this._target], this._object);
        this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
        if (x === 0 && y === 0 && width === data.width && height === data.height) {
            this._device.context.texSubImage2D(cubeMapFaceMap[face], 0, xOffset, yOffset, params.glFormat, params.glType[0], data);
        } else {
            const cvs = document.createElement('canvas');
            cvs.width = width;
            cvs.height = height;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(data, x, y, width, height, 0, 0, width, height);
            this._device.context.texSubImage2D(textureTargetMap[this._target], 0, xOffset, yOffset, params.glFormat, params.glType[0], cvs);
            cvs.width = 0;
            cvs.height = 0;
        }
        if (this._mipLevelCount > 1) {
            this.generateMipmaps();
        }
    }
    createEmpty(format, size, creationFlags) {
        this._flags = Number(creationFlags) || 0;
        if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
            console.error(new Error('webgl device does not support storage texture'));
        } else {
            this.loadEmpty(format, size, 0);
        }
    }
    readPixels(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        return new Promise((resolve)=>{
            const fb = this._device.createFrameBuffer([
                this
            ], null);
            fb.setColorAttachmentCubeFace(0, face);
            fb.setColorAttachmentMipLevel(0, mipLevel);
            fb.setColorAttachmentGenerateMipmaps(0, false);
            this._device.pushDeviceStates();
            this._device.setFramebuffer(fb);
            this._device.readPixels(0, x, y, w, h, buffer).then(()=>{
                fb.dispose();
                resolve();
            });
            this._device.popDeviceStates();
        });
    }
    readPixelsToBuffer(x, y, w, h, face, mipLevel, buffer) {
        if (mipLevel < 0 || mipLevel >= this.mipLevelCount) {
            throw new Error(`TextureCube.readPixels(): invalid miplevel: ${mipLevel}`);
        }
        const fb = this._device.createFrameBuffer([
            this
        ], null);
        fb.setColorAttachmentCubeFace(0, face);
        fb.setColorAttachmentMipLevel(0, mipLevel);
        fb.setColorAttachmentGenerateMipmaps(0, false);
        this._device.pushDeviceStates();
        this._device.setFramebuffer(fb);
        this._device.readPixelsToBuffer(0, x, y, w, h, buffer);
        this._device.popDeviceStates();
        fb.dispose();
    }
    isTextureCube() {
        return true;
    }
    generateMipmaps() {
        if (this._object && this._mipLevelCount > 1) {
            const target = textureTargetMap[this._target];
            this._device.bindTexture(target, 0, this);
            //this._device.context.bindTexture(target, this._object);
            this._device.context.generateMipmap(target);
        }
    }
    createWithMipmapData(data, sRGB, creationFlags) {
        if (!data.isCubemap) {
            console.error('loading cubmap with mipmap data failed: data is not cubemap');
        } else {
            this._flags = Number(creationFlags) || 0;
            if (this._flags & GPUResourceUsageFlags.TF_WRITABLE) {
                console.error('webgl device does not support storage texture');
            } else {
                this.loadLevels(data, sRGB);
            }
        }
    }
    /** @internal */ loadEmpty(format, size, mipLevelCount) {
        this.allocInternal(format, size, size, 1, mipLevelCount);
        if (this._mipLevelCount > 1 && !this._device.isContextLost()) {
            this.generateMipmaps();
        }
    }
    loadImages(images, format) {
        const width = images[0].width;
        const height = images[0].height;
        if (images.length !== 6) {
            console.error(new Error('cubemap face list must have 6 images'));
            return;
        }
        for(let i = 1; i < 6; i++){
            if (images[i].width !== width || images[i].height !== height) {
                console.error(new Error('cubemap face images must have identical sizes'));
                return;
            }
        }
        if (width === 0 || height === 0) {
            return;
        }
        this.allocInternal(format, width, height, 1, 0);
        if (!this._device.isContextLost()) {
            this.device.clearErrors();
            this._device.bindTexture(textureTargetMap[this._target], 0, this);
            //this._device.context.bindTexture(textureTargetMap[this._target], this._object);
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            for(let face = 0; face < 6; face++){
                this._device.context.texSubImage2D(cubeMapFaceMap[face], 0, 0, 0, params.glFormat, params.glType[0], images[face]);
                const err = this.device.getError();
                if (err) {
                    console.error(err);
                    return;
                }
            }
            if (this._mipLevelCount > 1) {
                this.generateMipmaps();
            }
        }
    }
    loadLevels(levels, sRGB) {
        const format = sRGB ? linearTextureFormatToSRGB(levels.format) : levels.format;
        const width = levels.width;
        const height = levels.height;
        const mipLevelCount = levels.mipLevels;
        if (levels.isCompressed) {
            if (!this.getTextureCaps().supportS3TCSRGB || !this.getTextureCaps().supportS3TC) {
                console.warn('No s3tc compression format support');
                return;
            }
        }
        this.allocInternal(format, width, height, 1, mipLevelCount);
        if (!this._device.isContextLost()) {
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            this._device.bindTexture(textureTargetMap[this._target], 0, this);
            //this._device.context.bindTexture(textureTargetMap[this._target], this._object);
            this.device.clearErrors();
            for(let face = 0; face < 6; face++){
                const faceTarget = cubeMapFaceMap[face];
                if (this._mipLevelCount > 1 && levels.mipDatas[face].length !== this._mipLevelCount) {
                    console.log(`invalid texture data`);
                    return;
                }
                for(let i = 0; i < this._mipLevelCount; i++){
                    if (levels.isCompressed) {
                        this._device.context.compressedTexSubImage2D(faceTarget, i, 0, 0, levels.mipDatas[face][i].width, levels.mipDatas[face][i].height, params.glInternalFormat, levels.mipDatas[face][i].data);
                    } else {
                        this._device.context.texSubImage2D(faceTarget, i, 0, 0, levels.mipDatas[face][i].width, levels.mipDatas[face][i].height, params.glFormat, params.glType[0], levels.mipDatas[face][i].data);
                    }
                    const err = this.device.getError();
                    if (err) {
                        console.error(err);
                        return;
                    }
                }
            }
        }
    }
}

class WebGLTextureVideo extends WebGLBaseTexture {
    _source;
    _callbackId;
    constructor(device, source){
        super(device, '2d');
        this._source = null;
        this._callbackId = null;
        this._format = 'unknown';
        this.loadFromElement(source);
    }
    isTextureVideo() {
        return true;
    }
    get source() {
        return this._source;
    }
    destroy() {
        if (this._source && this._callbackId !== null) {
            this._source.cancelVideoFrameCallback(this._callbackId);
        }
        super.destroy();
    }
    init() {
        this.loadElement(this._source);
    }
    /** @internal */ loadFromElement(el) {
        this._flags = GPUResourceUsageFlags.TF_NO_MIPMAP;
        this.loadElement(el);
    }
    generateMipmaps() {
    // Does nothing
    }
    readPixels(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixels()`);
    }
    readPixelsToBuffer(x, y, w, h, faceOrLayer, mipLevel, buffer) {
        throw new Error(`Video texture does not support readPixelsToBuffer()`);
    }
    /** @internal */ updateVideoFrame() {
        if (this.object && this._source.currentTime > 0 && !this._source.requestVideoFrameCallback) {
            this.update();
            return true;
        }
        return false;
    }
    /** @internal */ update() {
        this.allocInternal('rgba8unorm', this._source.videoWidth, this._source.videoHeight, 1, 1);
        if (!this._device.isContextLost()) {
            const target = textureTargetMap[this._target];
            const params = this.getTextureCaps().getTextureFormatInfo(this._format);
            this._device.bindTexture(target, 0, this);
            //this._device.context.bindTexture(target, this._object);
            this._device.context.pixelStorei(this._device.context.UNPACK_ALIGNMENT, 1);
            this._device.context.texImage2D(target, 0, params.glInternalFormat, params.glFormat, params.glType[0], this._source);
        }
    }
    /** @internal */ loadElement(element) {
        if (this._source && this._callbackId !== null) {
            this._source.cancelVideoFrameCallback(this._callbackId);
            this._callbackId = null;
        }
        this._source = element;
        if (this._source?.requestVideoFrameCallback) {
            const that = this;
            that._callbackId = this._source.requestVideoFrameCallback(function cb() {
                if (that._object) {
                    that.update();
                    that._callbackId = that._source.requestVideoFrameCallback(cb);
                }
            });
        }
        this.allocInternal('rgba8unorm', Math.max(this._source.videoWidth, 1), Math.max(this._source.videoHeight, 1), 1, 1);
    }
}

class WebGLVertexLayout extends WebGLGPUObject {
    _vertexData;
    _dirty;
    constructor(device, options){
        super(device);
        this._vertexData = new VertexData();
        this._dirty = false;
        for (const vb of options.vertexBuffers){
            this._vertexData.setVertexBuffer(vb.buffer, vb.stepMode);
        }
        if (options.indexBuffer) {
            this._vertexData.setIndexBuffer(options.indexBuffer);
        }
        this.load();
    }
    destroy() {
        if (this._object && this._device.vaoExt) {
            this._device.vaoExt.deleteVertexArray(this._object);
        }
        this._object = null;
    }
    async restore() {
        if (!this._device.isContextLost()) {
            this.load();
        }
    }
    get vertexBuffers() {
        return this._vertexData.vertexBuffers;
    }
    get indexBuffer() {
        return this._vertexData.indexBuffer;
    }
    setDrawOffset(buffer, byteOffset) {
        for (const info of this._vertexData.vertexBuffers){
            if (info?.buffer === buffer && info.drawOffset !== byteOffset) {
                info.drawOffset = byteOffset;
                this._dirty = true;
            }
        }
    }
    getVertexBuffer(semantic) {
        return this._vertexData.getVertexBuffer(semantic);
    }
    getVertexBufferInfo(semantic) {
        return this._vertexData.getVertexBufferInfo(semantic);
    }
    getIndexBuffer() {
        return this._vertexData.getIndexBuffer();
    }
    bind() {
        if (this._object && this._device.vaoExt) {
            this._device.vaoExt.bindVertexArray(this._object);
            if (this._dirty) {
                this._dirty = false;
                this.bindBuffers();
            }
        } else {
            this.bindBuffers();
        }
    }
    draw(primitiveType, first, count) {
        this._device.setVertexLayout(this);
        this._device.draw(primitiveType, first, count);
    }
    drawInstanced(primitiveType, first, count, numInstances) {
        this._device.setVertexLayout(this);
        this._device.drawInstanced(primitiveType, first, count, numInstances);
    }
    isVertexLayout() {
        return true;
    }
    load() {
        if (this._device.isContextLost()) {
            return;
        }
        if (this._device.vaoExt) {
            if (!this._object) {
                this._object = this._device.vaoExt.createVertexArray();
                this._device.vaoExt.bindVertexArray(this._object);
                this.bindBuffers();
                this._device.vaoExt.bindVertexArray(null);
            }
        } else {
            this._object = {};
        }
    }
    bindBuffers() {
        const vertexBuffers = this._vertexData.vertexBuffers;
        const gl = this._device.context;
        for(let loc = 0; loc < vertexBuffers.length; loc++){
            const bufferInfo = vertexBuffers[loc];
            const buffer = bufferInfo?.buffer;
            if (buffer) {
                if (buffer.disposed) {
                    buffer.reload();
                }
                gl.bindBuffer(WebGLEnum.ARRAY_BUFFER, buffer.object);
                gl.enableVertexAttribArray(loc);
                if (bufferInfo.stepMode === 'instance' && this._device.instancedArraysExt) {
                    gl.vertexAttribPointer(loc, bufferInfo.type.cols, typeMap[bufferInfo.type.scalarType], bufferInfo.type.normalized, bufferInfo.stride, bufferInfo.offset);
                    this._device.instancedArraysExt.vertexAttribDivisor(loc, 1);
                } else {
                    gl.vertexAttribPointer(loc, bufferInfo.type.cols, typeMap[bufferInfo.type.scalarType], bufferInfo.type.normalized, bufferInfo.stride, bufferInfo.drawOffset + bufferInfo.offset);
                }
            } else {
                gl.disableVertexAttribArray(loc);
            }
        }
        if (this._vertexData.indexBuffer?.disposed) {
            this._vertexData.indexBuffer.reload();
        }
        gl.bindBuffer(WebGLEnum.ELEMENT_ARRAY_BUFFER, this._vertexData.indexBuffer ? this._vertexData.indexBuffer.object : null);
    }
}

class WebGLGPUBuffer extends WebGLGPUObject {
    _size;
    _usage;
    _systemMemoryBuffer;
    _systemMemory;
    _memCost;
    constructor(device, usage, data, systemMemory = false){
        super(device);
        if (usage & GPUResourceUsageFlags.BF_VERTEX && usage & GPUResourceUsageFlags.BF_INDEX) {
            throw new Error('buffer usage must not have Vertex and Index simultaneously');
        }
        if (!device.isWebGL2 && !(usage & GPUResourceUsageFlags.BF_VERTEX) && !(usage & GPUResourceUsageFlags.BF_INDEX) && !(usage & GPUResourceUsageFlags.BF_UNIFORM)) {
            throw new Error('no Vertex or Index or Uniform usage set when creating buffer');
        }
        if (device.isWebGL2 && !(usage & ~GPUResourceUsageFlags.DYNAMIC)) {
            throw new Error('buffer usage not set when creating buffer');
        }
        if (usage & GPUResourceUsageFlags.DYNAMIC && usage & GPUResourceUsageFlags.MANAGED) {
            throw new Error('buffer usage DYNAMIC and MANAGED can not be both set');
        }
        this._object = null;
        this._memCost = 0;
        this._usage = usage;
        this._size = typeof data === 'number' ? data : data.byteLength;
        if (this._size <= 0) {
            throw new Error('can not create buffer with zero size');
        }
        this._systemMemory = !!systemMemory;
        if (this._systemMemory || this._usage & GPUResourceUsageFlags.MANAGED) {
            this._systemMemoryBuffer = new Uint8Array(this._size);
            if (data && typeof data !== 'number') {
                this._systemMemoryBuffer.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            }
        } else {
            this._systemMemoryBuffer = null;
        }
        if (!this._systemMemory) {
            this.load(this._systemMemoryBuffer || (typeof data === 'number' ? null : data));
        }
    }
    get byteLength() {
        return this._size;
    }
    get systemMemoryBuffer() {
        return this._systemMemoryBuffer?.buffer || null;
    }
    get usage() {
        return this._usage;
    }
    bufferSubData(dstByteOffset, data, srcPos, srcLength) {
        srcPos = Number(srcPos) || 0;
        dstByteOffset = Number(dstByteOffset) || 0;
        srcLength = Number(srcLength) || data.length - srcPos;
        if (srcPos + srcLength > data.length) {
            throw new Error('bufferSubData() failed: source buffer is too small');
        }
        if (dstByteOffset + srcLength * data.BYTES_PER_ELEMENT > this.byteLength) {
            throw new Error('bufferSubData() failed: dest buffer is too small');
        }
        if (this._systemMemory || this._usage & GPUResourceUsageFlags.MANAGED) {
            // copy to system backup buffer if present
            this._systemMemoryBuffer.set(new Uint8Array(data.buffer, data.byteOffset + srcPos * data.BYTES_PER_ELEMENT, srcLength * data.BYTES_PER_ELEMENT), dstByteOffset);
        }
        if (!this._systemMemory && !this.device.isContextLost()) {
            if (this.disposed) {
                this.reload();
            }
            if (!this._device.isWebGL2 && (srcPos !== 0 || srcLength !== data.length)) {
                data = data.subarray(srcPos, srcPos + srcLength);
            }
            this._device.vaoExt?.bindVertexArray(null);
            let target;
            if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                target = WebGLEnum.ELEMENT_ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                target = WebGLEnum.ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                target = WebGLEnum.UNIFORM_BUFFER;
            } else if (this._usage & (GPUResourceUsageFlags.BF_READ | GPUResourceUsageFlags.BF_WRITE)) {
                target = WebGLEnum.COPY_WRITE_BUFFER;
            } else {
                throw new Error(`Invalid buffer usage`);
            }
            this._device.context.bindBuffer(target, this._object);
            if (this._device.isWebGL2) {
                this._device.context.bufferSubData(target, dstByteOffset, data, srcPos, srcLength);
            } else {
                this._device.context.bufferSubData(target, dstByteOffset, data);
            }
        }
    }
    async getBufferSubData(dstBuffer, offsetInBytes, sizeInBytes) {
        if (this.disposed) {
            this.reload();
        }
        return this._getBufferData(dstBuffer, offsetInBytes, sizeInBytes);
    }
    async _getBufferData(dstBuffer, offsetInBytes, sizeInBytes) {
        offsetInBytes = Number(offsetInBytes) || 0;
        sizeInBytes = Number(sizeInBytes) || this.byteLength - offsetInBytes;
        if (offsetInBytes < 0 || offsetInBytes + sizeInBytes > this.byteLength) {
            throw new Error('data query range out of bounds');
        }
        if (dstBuffer && dstBuffer.byteLength < sizeInBytes) {
            throw new Error('no enough space for querying buffer data');
        }
        dstBuffer = dstBuffer || new Uint8Array(sizeInBytes);
        if (this._systemMemoryBuffer) {
            dstBuffer.set(new Uint8Array(this._systemMemoryBuffer, offsetInBytes, sizeInBytes));
        } else {
            const gl = this._device.context;
            if (isWebGL2(gl)) {
                const sync = gl.fenceSync(WebGLEnum.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                await this.clientWaitAsync(gl, sync, 0, 10);
                gl.deleteSync(sync);
            }
            this._device.vaoExt?.bindVertexArray(null);
            let target;
            if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                target = WebGLEnum.ELEMENT_ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                target = WebGLEnum.ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                target = WebGLEnum.UNIFORM_BUFFER;
            } else if (this._usage & (GPUResourceUsageFlags.BF_READ | GPUResourceUsageFlags.BF_WRITE)) {
                target = WebGLEnum.COPY_READ_BUFFER;
            } else {
                throw new Error(`Invalid buffer usage`);
            }
            gl.bindBuffer(target, this._object);
            gl.getBufferSubData(target, offsetInBytes, dstBuffer, 0, sizeInBytes);
            gl.bindBuffer(target, null);
        }
        return dstBuffer;
    }
    async restore() {
        if (!this._systemMemory && !this._object && !this._device.isContextLost()) {
            this.load(this._systemMemoryBuffer);
        }
    }
    destroy() {
        if (!this._systemMemory && this._object) {
            this._device.context.deleteBuffer(this._object);
            this._object = null;
            this._device.updateVideoMemoryCost(-this._memCost);
            this._memCost = 0;
        }
    }
    isBuffer() {
        return true;
    }
    load(data) {
        if (!this._device.isContextLost()) {
            if (!this._object) {
                this._object = this._device.context.createBuffer();
            }
            this._device.vaoExt?.bindVertexArray(null);
            let usage = this._usage & GPUResourceUsageFlags.DYNAMIC ? WebGLEnum.DYNAMIC_DRAW : WebGLEnum.STATIC_DRAW;
            let target;
            if (this._usage & GPUResourceUsageFlags.BF_INDEX) {
                target = WebGLEnum.ELEMENT_ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_VERTEX) {
                target = WebGLEnum.ARRAY_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_UNIFORM) {
                target = WebGLEnum.UNIFORM_BUFFER;
            } else if (this._usage & GPUResourceUsageFlags.BF_READ) {
                target = WebGLEnum.COPY_READ_BUFFER;
                usage = WebGLEnum.STREAM_READ;
            } else if (this._usage & GPUResourceUsageFlags.BF_WRITE) {
                target = WebGLEnum.COPY_WRITE_BUFFER;
            } else {
                throw new Error(`WebGLGPUBuffer.load() failed: invalid buffer usage: ${this._usage}`);
            }
            this._device.context.bindBuffer(target, this._object);
            if (data) {
                this._device.context.bufferData(target, data, usage);
            } else {
                this._device.context.bufferData(target, this._size + 15 & ~15, usage);
            }
        }
        this._device.updateVideoMemoryCost(this._size - this._memCost);
        this._memCost = this._size;
    }
    /** @internal */ async clientWaitAsync(gl, sync, flags, interval_ms) {
        return new Promise((resolve, reject)=>{
            function test() {
                const res = gl.clientWaitSync(sync, flags, 0);
                if (res == gl.WAIT_FAILED) {
                    reject();
                    return;
                }
                if (res == gl.TIMEOUT_EXPIRED) {
                    setTimeout(test, interval_ms);
                    return;
                }
                resolve();
            }
            test();
        });
    }
}

const typeU16$1 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const typeU32 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U32);
class WebGLIndexBuffer extends WebGLGPUBuffer {
    indexType;
    length;
    constructor(device, data, usage){
        if (!(data instanceof Uint16Array) && !(data instanceof Uint32Array)) {
            throw new Error('invalid index data');
        }
        super(device, GPUResourceUsageFlags.BF_INDEX | usage, data);
        this.indexType = data instanceof Uint16Array ? typeU16$1 : typeU32;
        this.length = data.length;
    }
}

const STATUS_UNCHECKED = 0;
const STATUS_OK = 1;
const STATUS_FAILED = 2;
class WebGLFrameBuffer extends WebGLGPUObject {
    _options;
    _needBindBuffers;
    _drawTags;
    _lastDrawTag;
    _status;
    _statusAA;
    _width;
    _height;
    _isMRT;
    _drawBuffers;
    _hash;
    _depthAttachmentTarget;
    _colorAttachmentsAA;
    _depthAttachmentAA;
    _intermediateAttachments;
    _framebufferAA;
    constructor(device, colorAttachments, depthAttachment, opt){
        super(device);
        if (colorAttachments.length > 0 && colorAttachments.findIndex((val)=>!val) >= 0) {
            throw new Error('WebGLFramebuffer(): invalid color attachments');
        }
        this._object = null;
        this._framebufferAA = null;
        this._colorAttachmentsAA = null;
        this._depthAttachmentAA = null;
        this._intermediateAttachments = null;
        this._needBindBuffers = false;
        this._drawTags = 0;
        this._lastDrawTag = -1;
        this._status = STATUS_UNCHECKED;
        this._statusAA = STATUS_UNCHECKED;
        this._options = {
            colorAttachments: colorAttachments?.length > 0 ? colorAttachments.map((value)=>({
                    texture: value,
                    face: 0,
                    layer: 0,
                    level: 0,
                    generateMipmaps: true
                })) : null,
            depthAttachment: depthAttachment ? {
                texture: depthAttachment,
                face: 0,
                layer: 0,
                level: 0,
                generateMipmaps: false
            } : null,
            sampleCount: device.type === 'webgl' ? 1 : opt?.sampleCount ?? 1,
            ignoreDepthStencil: opt?.ignoreDepthStencil ?? false
        };
        if (!this._options.colorAttachments && !this._options.depthAttachment) {
            throw new Error('WebGLFramebuffer(): colorAttachments or depthAttachment must be specified');
        }
        this._width = this._options.colorAttachments ? this._options.colorAttachments[0].texture.width : this._options.depthAttachment.texture.width;
        this._height = this._options.colorAttachments ? this._options.colorAttachments[0].texture.height : this._options.depthAttachment.texture.height;
        if (this._options.colorAttachments && this._options.colorAttachments.findIndex((val)=>val.texture.width !== this._width || val.texture.height !== this._height) >= 0 || this._options.depthAttachment && (this._options.depthAttachment.texture.width !== this._width || this._options.depthAttachment.texture.height !== this._height)) {
            throw new Error('WebGLFramebuffer(): attachment textures must have same width and height');
        }
        this._drawBuffers = this._options.colorAttachments?.map((val, index)=>WebGLEnum.COLOR_ATTACHMENT0 + index) ?? [];
        this._isMRT = this._drawBuffers.length > 1;
        if (this._options.depthAttachment) {
            const format = this._options.depthAttachment.texture.format;
            this._depthAttachmentTarget = hasStencilChannel(format) ? WebGLEnum.DEPTH_STENCIL_ATTACHMENT : WebGLEnum.DEPTH_ATTACHMENT;
        } else {
            this._depthAttachmentTarget = WebGLEnum.NONE;
        }
        const colorAttachmentHash = this._options.colorAttachments?.map((tex)=>tex.texture.format).join(':') ?? '';
        const depthAttachmentHash = this._options.depthAttachment?.texture.format ?? '';
        this._hash = `${colorAttachmentHash}-${depthAttachmentHash}-${this._options.sampleCount ?? 1}`;
        this._init();
    }
    tagDraw() {
        this._drawTags++;
    }
    isMRT() {
        return this._isMRT;
    }
    getWidth() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return Math.max(attachment.texture.width >> attachment.level, 1);
    }
    getHeight() {
        const attachment = this._options.colorAttachments?.[0] ?? this._options.depthAttachment;
        return Math.max(attachment.texture.height >> attachment.level, 1);
    }
    getHash() {
        return this._hash;
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            if (this._options?.depthAttachment?.texture?.disposed) {
                await this._options.depthAttachment.texture.reload();
            }
            if (this._options?.colorAttachments) {
                for (const k of this._options.colorAttachments){
                    if (k?.texture?.disposed) {
                        await k.texture.reload();
                    }
                }
            }
        }
        this._init();
    }
    destroy() {
        if (this._object) {
            this._device.context.deleteFramebuffer(this._object);
            this._object = null;
            if (this._colorAttachmentsAA) {
                for (const rb of this._colorAttachmentsAA){
                    this._device.context.deleteRenderbuffer(rb);
                }
                this._colorAttachmentsAA = null;
            }
            if (this._depthAttachmentAA) {
                this._device.context.deleteRenderbuffer(this._depthAttachmentAA);
                this._depthAttachmentAA = null;
            }
            if (this._framebufferAA) {
                this._device.context.deleteFramebuffer(this._framebufferAA);
                this._framebufferAA = null;
            }
            if (this._intermediateAttachments) {
                for (const entry of this._intermediateAttachments){
                    for (const rb of entry[1]){
                        if (rb) {
                            this._device.context.deleteTexture(rb.texture);
                            this._device.invalidateBindingTextures();
                        }
                    }
                }
                this._intermediateAttachments = null;
            }
        }
    }
    setColorAttachmentGenerateMipmaps(index, generateMipmaps) {
        const k = this._options.colorAttachments?.[index];
        if (k) {
            k.generateMipmaps = !!generateMipmaps;
        }
    }
    setColorAttachmentCubeFace(index, face) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.face !== face) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.face = face;
                this.bind();
            } else {
                k.face = face;
            }
        }
    }
    setColorAttachmentMipLevel(index, level) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.level !== level) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.level = level;
                this.bind();
            } else {
                k.level = level;
            }
        }
    }
    setColorAttachmentLayer(index, layer) {
        const k = this._options.colorAttachments?.[index];
        if (k && k.layer !== layer) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.layer = layer;
                this.bind();
            } else {
                k.layer = layer;
            }
        }
    }
    setDepthAttachmentCubeFace(face) {
        const k = this._options.depthAttachment;
        if (k && k.face !== face) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.face = face;
                this.bind();
            } else {
                k.face = face;
            }
        }
    }
    setDepthAttachmentLayer(layer) {
        const k = this._options.depthAttachment;
        if (k && k.layer !== layer) {
            this._needBindBuffers = true;
            if (this._device.context._currentFramebuffer === this) {
                this.unbind();
                k.layer = layer;
                this.bind();
            } else {
                k.layer = layer;
            }
        }
    }
    getDepthAttachment() {
        return this._options?.depthAttachment?.texture || null;
    }
    getColorAttachments() {
        return this._options.colorAttachments?.map((val)=>val.texture || null) || [];
    }
    bind() {
        if (this._object) {
            this._device.context._currentFramebuffer = this;
            this._lastDrawTag = -1;
            if (this._needBindBuffers) {
                this._needBindBuffers = false;
                if (!this._bindBuffersAA() || !this._bindBuffers()) {
                    this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
                    this._device.context._currentFramebuffer = null;
                    return false;
                }
            }
            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._framebufferAA || this._object);
            const drawBuffersExt = this._device.drawBuffersExt;
            if (drawBuffersExt) {
                drawBuffersExt.drawBuffers(this._drawBuffers);
            } else if (this._isMRT) {
                console.error('device does not support multiple framebuffer color attachments');
            }
            this._device.setViewport(null);
            this._device.setScissor(null);
            return true;
        }
        return false;
    }
    unbind() {
        if (this._device.context._currentFramebuffer === this) {
            this._updateMSAABuffer();
            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
            this._device.context._currentFramebuffer = null;
            this._device.setViewport();
            this._device.setScissor();
            const drawBuffersExt = this._device.drawBuffersExt;
            if (drawBuffersExt) {
                drawBuffersExt.drawBuffers([
                    WebGLEnum.BACK
                ]);
            }
            if (this._options.colorAttachments) {
                for (const attachment of this._options.colorAttachments){
                    const tex = attachment.texture;
                    if (attachment.level > 0) {
                        const texture = this._intermediateAttachments?.get(tex)?.[attachment.level];
                        if (texture) {
                            const tmpFramebuffer = this._device.context.createFramebuffer();
                            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, tmpFramebuffer);
                            this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, WebGLEnum.COLOR_ATTACHMENT0, WebGLEnum.TEXTURE_2D, texture.texture, 0);
                            if (tex.isTexture2D()) {
                                this._device.bindTexture(WebGLEnum.TEXTURE_2D, 0, tex);
                                //this._device.context.bindTexture(WebGLEnum.TEXTURE_2D, tex.object);
                                this._device.context.copyTexSubImage2D(WebGLEnum.TEXTURE_2D, attachment.level, 0, 0, 0, 0, texture.width, texture.height);
                            } else if (tex.isTextureCube()) {
                                this._device.bindTexture(WebGLEnum.TEXTURE_CUBE_MAP, 0, tex);
                                //this._device.context.bindTexture(WebGLEnum.TEXTURE_CUBE_MAP, tex.object);
                                this._device.context.copyTexSubImage2D(cubeMapFaceMap[attachment.face ?? CubeFace.PX], attachment.level, 0, 0, 0, 0, texture.width, texture.height);
                            }
                            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
                            this._device.context.deleteFramebuffer(tmpFramebuffer);
                        }
                    }
                    if (attachment.generateMipmaps && tex.mipLevelCount > 1) {
                        tex.generateMipmaps();
                    }
                }
            }
        }
    }
    _updateMSAABuffer() {
        if (this._options.sampleCount > 1 && this._lastDrawTag !== this._drawTags) {
            const gl = this._device.context;
            gl.bindFramebuffer(WebGLEnum.READ_FRAMEBUFFER, this._framebufferAA);
            gl.bindFramebuffer(WebGLEnum.DRAW_FRAMEBUFFER, this._object);
            let depthStencilMask = 0;
            if (!this._options.ignoreDepthStencil && this._depthAttachmentTarget !== WebGLEnum.NONE) {
                depthStencilMask = WebGLEnum.DEPTH_BUFFER_BIT | (this._depthAttachmentTarget === WebGLEnum.DEPTH_STENCIL_ATTACHMENT ? WebGLEnum.STENCIL_BUFFER_BIT : 0);
            }
            for(let i = 0; i < this._drawBuffers.length; i++){
                for(let j = 0; j < this._drawBuffers.length; j++){
                    this._drawBuffers[j] = j === i ? WebGLEnum.COLOR_ATTACHMENT0 + i : WebGLEnum.NONE;
                }
                gl.readBuffer(this._drawBuffers[i]);
                gl.drawBuffers(this._drawBuffers);
                gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, WebGLEnum.COLOR_BUFFER_BIT | depthStencilMask, WebGLEnum.NEAREST);
                depthStencilMask = 0;
            }
            if (depthStencilMask !== 0) {
                gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, depthStencilMask, WebGLEnum.NEAREST);
            }
            for(let i = 0; i < this._drawBuffers.length; i++){
                this._drawBuffers[i] = WebGLEnum.COLOR_ATTACHMENT0 + i;
            }
            gl.bindFramebuffer(WebGLEnum.READ_FRAMEBUFFER, null);
            gl.bindFramebuffer(WebGLEnum.DRAW_FRAMEBUFFER, null);
            this._lastDrawTag = this._drawTags;
        }
    }
    _load() {
        if (this._device.isContextLost()) {
            return;
        }
        do {
            if (this._options.sampleCount > 1) {
                this._framebufferAA = this._device.context.createFramebuffer();
                this._colorAttachmentsAA = [];
                this._depthAttachmentAA = null;
                if (!this._bindBuffersAA()) {
                    this.dispose();
                    break;
                }
            }
            this._object = this._device.context.createFramebuffer();
            this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._object);
            if (!this._bindBuffers()) {
                this.dispose();
            }
        }while (0)
        this._lastDrawTag = -1;
        this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, null);
        this._device.context._currentFramebuffer = null;
    }
    _bindAttachment(attachment, info) {
        if (info.texture) {
            let intermediateTexture = null;
            if (this.device.type === 'webgl' && info.level > 0) {
                if (!this._intermediateAttachments) {
                    this._intermediateAttachments = new Map();
                }
                let intermediateAttachments = this._intermediateAttachments.get(info.texture);
                if (!intermediateAttachments) {
                    intermediateAttachments = [];
                    this._intermediateAttachments.set(info.texture, intermediateAttachments);
                }
                if (!intermediateAttachments[info.level]) {
                    let width = info.texture.width;
                    let height = info.texture.height;
                    let level = info.level;
                    while(level-- > 0){
                        width = Math.max(width >> 1, 1);
                        height = Math.max(height >> 1, 1);
                    }
                    const formatInfo = this.device.getDeviceCaps().textureCaps.getTextureFormatInfo(info.texture.format);
                    intermediateTexture = this._device.context.createTexture();
                    this._device.context.activeTexture(WebGLEnum.TEXTURE0);
                    this._device.context.bindTexture(WebGLEnum.TEXTURE_2D, intermediateTexture);
                    this._device.context.texImage2D(WebGLEnum.TEXTURE_2D, 0, formatInfo.glInternalFormat, width, height, 0, formatInfo.glFormat, formatInfo.glType[0], null);
                    intermediateAttachments[info.level] = {
                        texture: intermediateTexture,
                        width,
                        height
                    };
                    this._device.bindTexture(WebGLEnum.TEXTURE_2D, 0, null);
                } else {
                    intermediateTexture = intermediateAttachments[info.level].texture;
                }
            }
            if (intermediateTexture) {
                this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, attachment, WebGLEnum.TEXTURE_2D, intermediateTexture, 0);
            } else {
                if (info.texture.isTexture2D()) {
                    if (intermediateTexture) {
                        this._device.context.framebufferRenderbuffer(WebGLEnum.FRAMEBUFFER, attachment, WebGLEnum.RENDERBUFFER, intermediateTexture);
                    } else {
                        this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, attachment, WebGLEnum.TEXTURE_2D, info.texture.object, info.level ?? 0);
                    }
                } else if (info.texture.isTextureCube()) {
                    this._device.context.framebufferTexture2D(WebGLEnum.FRAMEBUFFER, attachment, cubeMapFaceMap[info.face ?? CubeFace.PX], info.texture.object, info.level ?? 0);
                } else if (info.texture.isTexture2DArray() || info.texture.isTexture3D()) {
                    this._device.context.framebufferTextureLayer(WebGLEnum.FRAMEBUFFER, attachment, info.texture.object, info.level ?? 0, info.layer ?? 0);
                } else {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    _bindBuffers() {
        if (!this._object) {
            return false;
        }
        this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._object);
        if (this._depthAttachmentTarget !== WebGLEnum.NONE) {
            if (!this._bindAttachment(this._depthAttachmentTarget, this._options.depthAttachment)) {
                return false;
            }
        }
        for(let i = 0; (i < this._options.colorAttachments?.length) ?? 0; i++){
            const opt = this._options.colorAttachments[i];
            if (opt.texture) {
                if (!this._bindAttachment(WebGLEnum.COLOR_ATTACHMENT0 + i, opt)) {
                    return false;
                }
            }
        }
        if (this._status === STATUS_UNCHECKED) {
            const status = this._device.context.checkFramebufferStatus(WebGLEnum.FRAMEBUFFER);
            if (status !== WebGLEnum.FRAMEBUFFER_COMPLETE) {
                console.error(`Framebuffer not complete: ${status}`);
                this._status = STATUS_FAILED;
            } else {
                this._status = STATUS_OK;
            }
        }
        return this._status === STATUS_OK;
    }
    _createRenderbufferAA(texture) {
        const renderBuffer = this._device.context.createRenderbuffer();
        const formatInfo = this.device.getDeviceCaps().textureCaps.getTextureFormatInfo(texture.format);
        this._device.context.bindRenderbuffer(WebGLEnum.RENDERBUFFER, renderBuffer);
        this._device.context.renderbufferStorageMultisample(WebGLEnum.RENDERBUFFER, this._options.sampleCount, formatInfo.glInternalFormat, this._options.depthAttachment.texture.width, this._options.depthAttachment.texture.height);
        return renderBuffer;
    }
    _bindBuffersAA() {
        if (!this._framebufferAA) {
            return true;
        }
        this._device.context.bindFramebuffer(WebGLEnum.FRAMEBUFFER, this._framebufferAA);
        if (this._depthAttachmentTarget !== WebGLEnum.NONE) {
            if (!this._depthAttachmentAA) {
                this._depthAttachmentAA = this._createRenderbufferAA(this._options.depthAttachment.texture);
            }
            this._device.context.framebufferRenderbuffer(WebGLEnum.FRAMEBUFFER, this._depthAttachmentTarget, WebGLEnum.RENDERBUFFER, this._depthAttachmentAA);
        }
        for(let i = 0; (i < this._options.colorAttachments?.length) ?? 0; i++){
            const opt = this._options.colorAttachments[i];
            if (opt.texture) {
                if (!this._colorAttachmentsAA[i]) {
                    this._colorAttachmentsAA[i] = this._createRenderbufferAA(this._options.colorAttachments[i].texture);
                }
                this._device.context.framebufferRenderbuffer(WebGLEnum.FRAMEBUFFER, WebGLEnum.COLOR_ATTACHMENT0 + i, WebGLEnum.RENDERBUFFER, this._colorAttachmentsAA[i]);
            }
        }
        if (this._statusAA === STATUS_UNCHECKED) {
            const status = this._device.context.checkFramebufferStatus(WebGLEnum.FRAMEBUFFER);
            if (status !== WebGLEnum.FRAMEBUFFER_COMPLETE) {
                console.error(`Framebuffer not complete: ${status}`);
                this._statusAA = STATUS_FAILED;
            } else {
                this._statusAA = STATUS_OK;
            }
        }
        return this._statusAA === STATUS_OK;
    }
    _init() {
        if (this._options.sampleCount !== 1 && this._options.sampleCount !== 4) {
            throw new Error(`WebGLFramebuffer(): Sample should be 1 or 4, got ${this._options.sampleCount}`);
        }
        if (this._options.sampleCount > 1 && !this._device.getDeviceCaps().framebufferCaps.supportMultisampledFramebuffer) {
            throw new Error('WebGLFramebuffer(): Multisampled frame buffer not supported');
        }
        this._load();
    }
    isFramebuffer() {
        return true;
    }
    getSampleCount() {
        return this._options.sampleCount;
    }
}

class WebGLRenderState {
    static _defaultState;
    static _currentState;
    apply(gl, force) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const c = this.constructor;
        if (force || c._currentState !== this) {
            this._apply(gl);
        }
        c._currentState = this;
    }
    static get defaultState() {
        return WebGLRenderState._defaultState;
    }
    static applyDefaults(gl, force) {
        if (force || this._currentState !== this._defaultState) {
            this._defaultState.apply(gl, force);
        }
    }
}
class WebGLColorState extends WebGLRenderState {
    static _defaultState = new WebGLColorState();
    static _currentState = null;
    redMask;
    greenMask;
    blueMask;
    alphaMask;
    constructor(){
        super();
        this.redMask = this.greenMask = this.blueMask = this.alphaMask = true;
    }
    clone() {
        return new WebGLColorState().setColorMask(this.redMask, this.greenMask, this.blueMask, this.alphaMask);
    }
    setColorMask(r, g, b, a) {
        this.redMask = r;
        this.greenMask = g;
        this.blueMask = b;
        this.alphaMask = a;
        return this;
    }
    _apply(gl) {
        gl.colorMask(this.redMask, this.greenMask, this.blueMask, this.alphaMask);
    }
}
class WebGLBlendingState extends WebGLRenderState {
    static _defaultState = new WebGLBlendingState();
    static _currentState = null;
    _srcBlendRGB;
    _dstBlendRGB;
    _srcBlendAlpha;
    _dstBlendAlpha;
    _rgbEquation;
    _alphaEquation;
    enabled;
    alphaToCoverageEnabled;
    constructor(){
        super();
        this.enabled = false;
        this.alphaToCoverageEnabled = false;
        this.srcBlendRGB = 'one';
        this.dstBlendRGB = 'zero';
        this.srcBlendAlpha = 'one';
        this.dstBlendAlpha = 'zero';
        this.rgbEquation = 'add';
        this.alphaEquation = 'add';
    }
    clone() {
        const other = new WebGLBlendingState();
        other.enable(this.enabled);
        other.enableAlphaToCoverage(this.alphaToCoverageEnabled);
        other.setBlendFuncRGB(this.srcBlendRGB, this.dstBlendRGB);
        other.setBlendFuncAlpha(this.srcBlendAlpha, this.dstBlendAlpha);
        other.setBlendEquation(this.rgbEquation, this.alphaEquation);
        return other;
    }
    get srcBlendRGB() {
        return blendFuncInvMap[this._srcBlendRGB];
    }
    set srcBlendRGB(val) {
        this._srcBlendRGB = blendFuncMap[val];
    }
    get dstBlendRGB() {
        return blendFuncInvMap[this._dstBlendRGB];
    }
    set dstBlendRGB(val) {
        this._dstBlendRGB = blendFuncMap[val];
    }
    get srcBlendAlpha() {
        return blendFuncInvMap[this._srcBlendAlpha];
    }
    set srcBlendAlpha(val) {
        this._srcBlendAlpha = blendFuncMap[val];
    }
    get dstBlendAlpha() {
        return blendFuncInvMap[this._dstBlendAlpha];
    }
    set dstBlendAlpha(val) {
        this._dstBlendAlpha = blendFuncMap[val];
    }
    get rgbEquation() {
        return blendEquationInvMap[this._rgbEquation];
    }
    set rgbEquation(val) {
        this._rgbEquation = blendEquationMap[val];
    }
    get alphaEquation() {
        return blendEquationInvMap[this._alphaEquation];
    }
    set alphaEquation(val) {
        this._alphaEquation = blendEquationMap[val];
    }
    enable(b) {
        this.enabled = !!b;
        return this;
    }
    enableAlphaToCoverage(b) {
        this.alphaToCoverageEnabled = !!b;
        return this;
    }
    setBlendFunc(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendFuncRGB(src, dest) {
        this.srcBlendRGB = src;
        this.dstBlendRGB = dest;
        return this;
    }
    setBlendFuncAlpha(src, dest) {
        this.srcBlendAlpha = src;
        this.dstBlendAlpha = dest;
        return this;
    }
    setBlendEquation(rgb, alpha) {
        this.rgbEquation = rgb;
        this.alphaEquation = alpha;
        return this;
    }
    _apply(gl) {
        if (this.enabled) {
            gl.enable(WebGLEnum.BLEND);
            gl.blendEquationSeparate(this._rgbEquation, this._alphaEquation);
            if (this._srcBlendRGB === this._srcBlendAlpha && this._dstBlendRGB === this._dstBlendAlpha) {
                gl.blendFunc(this._srcBlendRGB, this._dstBlendRGB);
            } else {
                gl.blendFuncSeparate(this._srcBlendRGB, this._dstBlendRGB, this._srcBlendAlpha, this._dstBlendAlpha);
            }
        } else {
            gl.disable(WebGLEnum.BLEND);
        }
        if (this.alphaToCoverageEnabled) {
            gl.enable(WebGLEnum.SAMPLE_ALPHA_TO_COVERAGE);
        } else {
            gl.disable(WebGLEnum.SAMPLE_ALPHA_TO_COVERAGE);
        }
    }
}
class WebGLRasterizerState extends WebGLRenderState {
    static _defaultState = new WebGLRasterizerState();
    static _currentState = null;
    _cullMode;
    constructor(){
        super();
        this.cullMode = 'back';
    }
    clone() {
        return new WebGLRasterizerState().setCullMode(this.cullMode);
    }
    get cullMode() {
        return faceModeInvMap[this._cullMode];
    }
    set cullMode(val) {
        this._cullMode = faceModeMap[val];
    }
    setCullMode(mode) {
        this.cullMode = mode;
        return this;
    }
    get depthClampEnabled() {
        return false;
    }
    set depthClampEnabled(val) {
        this.enableDepthClamp(val);
    }
    enableDepthClamp(enable) {
        if (enable) {
            console.error('Depth clamp not supported');
        }
        return this;
    }
    _apply(gl) {
        if (this.cullMode == 'none') {
            gl.disable(WebGLEnum.CULL_FACE);
        } else {
            gl.enable(WebGLEnum.CULL_FACE);
            gl.cullFace(this._cullMode);
        }
    }
}
class WebGLDepthState extends WebGLRenderState {
    static _defaultState = new WebGLDepthState();
    static _currentState = null;
    testEnabled;
    writeEnabled;
    _compareFunc;
    constructor(){
        super();
        this.testEnabled = true;
        this.writeEnabled = true;
        this.compareFunc = 'le';
    }
    clone() {
        const other = new WebGLDepthState();
        other.enableTest(this.testEnabled);
        other.enableWrite(this.writeEnabled);
        other.setCompareFunc(this.compareFunc);
        return other;
    }
    get compareFunc() {
        return compareFuncInvMap[this._compareFunc];
    }
    set compareFunc(val) {
        this._compareFunc = compareFuncMap[val];
    }
    enableTest(b) {
        this.testEnabled = b;
        return this;
    }
    enableWrite(b) {
        this.writeEnabled = b;
        return this;
    }
    setCompareFunc(func) {
        this.compareFunc = func;
        return this;
    }
    _apply(gl) {
        if (this.testEnabled) {
            gl.enable(WebGLEnum.DEPTH_TEST);
            gl.depthFunc(this._compareFunc);
        } else {
            gl.disable(WebGLEnum.DEPTH_TEST);
        }
        gl.depthMask(this.writeEnabled);
    }
}
class WebGLStencilState extends WebGLRenderState {
    static _defaultState = new WebGLStencilState();
    static _currentState = null;
    enabled;
    writeMask;
    ref;
    readMask;
    _failOp;
    _failOpBack;
    _zFailOp;
    _zFailOpBack;
    _passOp;
    _passOpBack;
    _func;
    _funcBack;
    constructor(){
        super();
        this.enabled = false;
        this.failOp = this.failOpBack = 'keep';
        this.zFailOp = this.zFailOpBack = 'keep';
        this.passOp = this.passOpBack = 'keep';
        this.func = this.funcBack = 'always';
        this.ref = 0;
        this.writeMask = 0xffffffff;
        this.readMask = 0xffffffff;
    }
    clone() {
        const other = new WebGLStencilState();
        other.enable(this.enabled);
        other.setWriteMask(this.writeMask);
        other.setFrontOp(this.failOp, this.zFailOp, this.passOp);
        other.setBackOp(this.failOpBack, this.zFailOpBack, this.passOpBack);
        other.setFrontCompareFunc(this.func);
        other.setBackCompareFunc(this.funcBack);
        other.setReference(this.ref);
        other.setReadMask(this.readMask);
        return other;
    }
    get failOp() {
        return stencilOpInvMap[this._failOp];
    }
    set failOp(val) {
        this._failOp = stencilOpMap[val];
    }
    get failOpBack() {
        return stencilOpInvMap[this._failOpBack];
    }
    set failOpBack(val) {
        this._failOpBack = stencilOpMap[val];
    }
    get zFailOp() {
        return stencilOpInvMap[this._zFailOp];
    }
    set zFailOp(val) {
        this._zFailOp = stencilOpMap[val];
    }
    get zFailOpBack() {
        return stencilOpInvMap[this._zFailOpBack];
    }
    set zFailOpBack(val) {
        this._zFailOpBack = stencilOpMap[val];
    }
    get passOp() {
        return stencilOpInvMap[this._passOp];
    }
    set passOp(val) {
        this._passOp = stencilOpMap[val];
    }
    get passOpBack() {
        return stencilOpInvMap[this._passOpBack];
    }
    set passOpBack(val) {
        this._passOpBack = stencilOpMap[val];
    }
    get func() {
        return compareFuncInvMap[this._func];
    }
    set func(val) {
        this._func = compareFuncMap[val];
    }
    get funcBack() {
        return compareFuncInvMap[this._funcBack];
    }
    set funcBack(val) {
        this._funcBack = compareFuncMap[val];
    }
    enable(b) {
        this.enabled = b;
        return this;
    }
    setWriteMask(mask) {
        this.writeMask = mask;
        return this;
    }
    setFrontOp(fail, zfail, zpass) {
        this.failOp = fail;
        this.zFailOp = zfail;
        this.passOp = zpass;
        return this;
    }
    setBackOp(fail, zfail, zpass) {
        this.failOpBack = fail;
        this.zFailOpBack = zfail;
        this.passOpBack = zpass;
        return this;
    }
    setFrontCompareFunc(func) {
        this.func = func;
        return this;
    }
    setBackCompareFunc(func) {
        this.funcBack = func;
        return this;
    }
    setReference(ref) {
        this.ref = ref;
        return this;
    }
    setReadMask(mask) {
        this.readMask = mask;
        return this;
    }
    _apply(gl) {
        if (this.enabled) {
            gl.enable(WebGLEnum.STENCIL_TEST);
            gl.stencilMaskSeparate(WebGLEnum.FRONT, this.writeMask);
            gl.stencilMaskSeparate(WebGLEnum.BACK, this.writeMask);
            gl.stencilFuncSeparate(WebGLEnum.FRONT, this._func, this.ref, this.readMask);
            gl.stencilFuncSeparate(WebGLEnum.BACK, this._funcBack, this.ref, this.readMask);
            gl.stencilOpSeparate(WebGLEnum.FRONT, this._failOp, this._zFailOp, this._passOp);
            gl.stencilOpSeparate(WebGLEnum.BACK, this._failOpBack, this._zFailOpBack, this._passOpBack);
        } else {
            gl.disable(WebGLEnum.STENCIL_TEST);
        }
    }
}
class WebGLRenderStateSet {
    _gl;
    colorState;
    blendingState;
    rasterizerState;
    depthState;
    stencilState;
    constructor(gl){
        this._gl = gl;
        this.colorState = null;
        this.blendingState = null;
        this.rasterizerState = null;
        this.depthState = null;
        this.stencilState = null;
    }
    clone() {
        const newStateSet = new WebGLRenderStateSet(this._gl);
        newStateSet.colorState = (this.colorState?.clone()) ?? null;
        newStateSet.blendingState = (this.blendingState?.clone()) ?? null;
        newStateSet.rasterizerState = (this.rasterizerState?.clone()) ?? null;
        newStateSet.depthState = (this.depthState?.clone()) ?? null;
        newStateSet.stencilState = (this.stencilState?.clone()) ?? null;
        return newStateSet;
    }
    copyFrom(stateSet) {
        this.colorState = stateSet.colorState;
        this.blendingState = stateSet.blendingState;
        this.rasterizerState = stateSet.rasterizerState;
        this.depthState = stateSet.depthState;
        this.stencilState = stateSet.stencilState;
    }
    apply(force) {
        const gl = this._gl;
        if (this.colorState) {
            this.colorState.apply(gl, force);
        } else {
            WebGLColorState.applyDefaults(gl, force);
        }
        if (this.blendingState) {
            this.blendingState.apply(gl, force);
        } else {
            WebGLBlendingState.applyDefaults(gl, force);
        }
        if (this.rasterizerState) {
            this.rasterizerState.apply(gl, force);
        } else {
            WebGLRasterizerState.applyDefaults(gl, force);
        }
        if (this.depthState) {
            this.depthState.apply(gl, force);
        } else {
            WebGLDepthState.applyDefaults(gl, force);
        }
        if (this.stencilState) {
            this.stencilState.apply(gl, force);
        } else {
            WebGLStencilState.applyDefaults(gl, force);
        }
    }
    useColorState(state) {
        return this.colorState = state ?? this.colorState ?? new WebGLColorState();
    }
    defaultColorState() {
        this.colorState = null;
    }
    useBlendingState(state) {
        return this.blendingState = state ?? this.blendingState ?? new WebGLBlendingState();
    }
    defaultBlendingState() {
        this.blendingState = null;
    }
    useRasterizerState(state) {
        return this.rasterizerState = state ?? this.rasterizerState ?? new WebGLRasterizerState();
    }
    defaultRasterizerState() {
        this.rasterizerState = null;
    }
    useDepthState(state) {
        return this.depthState = state ?? this.depthState ?? new WebGLDepthState();
    }
    defaultDepthState() {
        this.depthState = null;
    }
    useStencilState(state) {
        return this.stencilState = state ?? this.stencilState ?? new WebGLStencilState();
    }
    defaultStencilState() {
        this.stencilState = null;
    }
    static applyDefaults(gl, force) {
        WebGLColorState.applyDefaults(gl, force);
        WebGLBlendingState.applyDefaults(gl, force);
        WebGLRasterizerState.applyDefaults(gl, force);
        WebGLDepthState.applyDefaults(gl, force);
        WebGLStencilState.applyDefaults(gl, force);
    }
}

const GPU_DISJOINT_EXT = 0x8fbb;
const TIME_ELAPSED_EXT = 0x88bf;
var QueryState;
(function(QueryState) {
    QueryState[QueryState["QUERY_STATE_NONE"] = 0] = "QUERY_STATE_NONE";
    QueryState[QueryState["QUERY_STATE_QUERYING"] = 1] = "QUERY_STATE_QUERYING";
    QueryState[QueryState["QUERY_STATE_FINISHED"] = 2] = "QUERY_STATE_FINISHED";
})(QueryState || (QueryState = {}));
class GPUTimer {
    _device;
    _query;
    _state;
    _timerQuery;
    _gpuTime;
    constructor(device){
        this._device = device;
        this._state = 0;
        this._gpuTime = null;
        const gl = this._device.context;
        if (isWebGL2(gl)) {
            const ext = gl.getExtension('EXT_disjoint_timer_query_webgl2');
            if (ext) {
                this._timerQuery = {
                    createQuery: gl.createQuery.bind(gl),
                    deleteQuery: gl.deleteQuery.bind(gl),
                    beginQuery: gl.beginQuery.bind(gl),
                    endQuery: gl.endQuery.bind(gl),
                    isQuery: gl.isQuery.bind(gl),
                    getQuery: gl.getQuery.bind(gl),
                    getQueryObject: gl.getQueryParameter.bind(gl),
                    queryCounter: ext.queryCounterEXT.bind(ext)
                };
            }
        } else {
            const ext = gl.getExtension('EXT_disjoint_timer_query');
            if (ext) {
                this._timerQuery = {
                    createQuery: ext.createQueryEXT.bind(ext),
                    deleteQuery: ext.deleteQueryEXT.bind(ext),
                    beginQuery: ext.beginQueryEXT.bind(ext),
                    endQuery: ext.endQueryEXT.bind(ext),
                    isQuery: ext.isQueryEXT.bind(ext),
                    getQuery: ext.getQueryEXT.bind(ext),
                    getQueryObject: ext.getQueryObjectEXT.bind(ext),
                    queryCounter: ext.queryCounterEXT.bind(ext)
                };
            }
        }
        this._query = this._timerQuery ? this._timerQuery.createQuery() : null;
    }
    get gpuTimerSupported() {
        return !!this._query;
    }
    begin() {
        if (this._state === 1) {
            this.end();
        }
        if (this._query) {
            this._timerQuery.beginQuery(TIME_ELAPSED_EXT, this._query);
        }
        this._gpuTime = null;
        this._state = 1;
    }
    end() {
        if (this._state === 1) {
            if (this._query) {
                this._timerQuery.endQuery(TIME_ELAPSED_EXT);
            }
            this._state = 2;
        }
    }
    ended() {
        return this._state !== 1;
    }
    elapsed() {
        if (this._state === 2) {
            if (this._gpuTime === null && this._query && this._timerQuery.getQueryObject(this._query, WebGLEnum.QUERY_RESULT_AVAILABLE)) {
                const gpuTimerDisjoint = this._device.context.getParameter(GPU_DISJOINT_EXT);
                if (!gpuTimerDisjoint) {
                    this._gpuTime = Number(this._timerQuery.getQueryObject(this._query, WebGLEnum.QUERY_RESULT)) / 1000000;
                }
            }
        }
        return this._gpuTime;
    }
}

class WebGLFramebufferCaps {
    _isWebGL2;
    _extDrawBuffers;
    _extFloatBlending;
    maxDrawBuffers;
    maxColorAttachmentBytesPerSample;
    supportMultisampledFramebuffer;
    supportFloatBlending;
    supportDepth32float;
    supportDepth32floatStencil8;
    constructor(gl){
        this._isWebGL2 = isWebGL2(gl);
        this._extDrawBuffers = this._isWebGL2 ? null : gl.getExtension('WEBGL_draw_buffers');
        this._extFloatBlending = gl.getExtension('EXT_float_blend');
        this.maxDrawBuffers = this._isWebGL2 || this._extDrawBuffers ? Math.min(gl.getParameter(WebGLEnum.MAX_COLOR_ATTACHMENTS), gl.getParameter(WebGLEnum.MAX_DRAW_BUFFERS)) : 1;
        this.maxColorAttachmentBytesPerSample = this.maxDrawBuffers * 16;
        this.supportMultisampledFramebuffer = isWebGL2(gl);
        this.supportFloatBlending = !!this._extFloatBlending;
        this.supportDepth32float = this._isWebGL2;
        this.supportDepth32floatStencil8 = this._isWebGL2;
    }
}
class WebGLMiscCaps {
    _isWebGL2;
    _extIndexUint32;
    _extBlendMinMax;
    supportOversizedViewport;
    supportBlendMinMax;
    support32BitIndex;
    supportDepthClamp;
    maxBindGroups;
    maxTexCoordIndex;
    constructor(gl){
        this._isWebGL2 = isWebGL2(gl);
        this._extBlendMinMax = null;
        this._extIndexUint32 = isWebGL2 ? gl.getExtension('OES_element_index_uint') : null;
        if (this._isWebGL2) {
            this.supportBlendMinMax = true;
            this.support32BitIndex = true;
        } else {
            this._extBlendMinMax = gl.getExtension('EXT_blend_minmax');
            this.supportBlendMinMax = !!this._extBlendMinMax;
            this.support32BitIndex = !!this._extIndexUint32;
        }
        this.supportOversizedViewport = true;
        this.supportDepthClamp = false;
        this.maxBindGroups = 4;
        this.maxTexCoordIndex = 8;
    }
}
class WebGLShaderCaps {
    _extFragDepth;
    _extStandardDerivatives;
    _extShaderTextureLod;
    supportFragmentDepth;
    supportStandardDerivatives;
    supportShaderTextureLod;
    supportHighPrecisionFloat;
    supportHighPrecisionInt;
    maxUniformBufferSize;
    uniformBufferOffsetAlignment;
    maxStorageBufferSize;
    storageBufferOffsetAlignment;
    constructor(gl){
        this._extFragDepth = null;
        this._extStandardDerivatives = null;
        this.maxStorageBufferSize = 0;
        this.storageBufferOffsetAlignment = 0;
        if (isWebGL2(gl)) {
            this.supportFragmentDepth = true;
            this.supportStandardDerivatives = true;
            this.supportShaderTextureLod = true;
            this.supportHighPrecisionFloat = true;
            this.maxUniformBufferSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE) || 16384;
            this.uniformBufferOffsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT) || 256;
        } else {
            this._extFragDepth = gl.getExtension('EXT_frag_depth');
            this.supportFragmentDepth = !!this._extFragDepth;
            this._extStandardDerivatives = gl.getExtension('OES_standard_derivatives');
            this.supportStandardDerivatives = !!this._extStandardDerivatives;
            this._extShaderTextureLod = gl.getExtension('EXT_shader_texture_lod');
            this.supportShaderTextureLod = !!this._extShaderTextureLod;
            this.supportHighPrecisionFloat = gl.getShaderPrecisionFormat && !!gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT)?.precision && !!gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)?.precision;
            this.maxUniformBufferSize = 0;
            this.uniformBufferOffsetAlignment = 1;
        }
    }
}
class WebGLTextureCaps {
    _isWebGL2;
    _extS3TC;
    _extS3TCSRGB;
    _extTextureFilterAnisotropic;
    _extDepthTexture;
    _extSRGB;
    _extTextureFloat;
    _extTextureFloatLinear;
    _extTextureHalfFloat;
    _extTextureHalfFloatLinear;
    _textureFormatInfos;
    maxTextureSize;
    maxCubeTextureSize;
    npo2Mipmapping;
    npo2Repeating;
    supportS3TC;
    supportS3TCSRGB;
    supportDepthTexture;
    support3DTexture;
    supportSRGBTexture;
    supportFloatTexture;
    supportLinearFloatTexture;
    supportHalfFloatTexture;
    supportLinearHalfFloatTexture;
    supportAnisotropicFiltering;
    supportFloatColorBuffer;
    supportHalfFloatColorBuffer;
    supportFloatBlending;
    constructor(gl){
        this._isWebGL2 = isWebGL2(gl);
        this._extTextureFilterAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        this.supportAnisotropicFiltering = !!this._extTextureFilterAnisotropic;
        if (this._isWebGL2) {
            this.supportDepthTexture = true;
        } else {
            this._extDepthTexture = gl.getExtension('WEBGL_depth_texture');
            this.supportDepthTexture = !!this._extDepthTexture;
        }
        this.support3DTexture = this._isWebGL2;
        this._extSRGB = this._isWebGL2 ? null : gl.getExtension('EXT_sRGB');
        this.supportSRGBTexture = this._isWebGL2 || !!this._extSRGB;
        if (this._isWebGL2) {
            this.supportFloatTexture = true;
        } else {
            this._extTextureFloat = gl.getExtension('OES_texture_float');
            this.supportFloatTexture = !!this._extTextureFloat;
        }
        this._extTextureFloatLinear = gl.getExtension('OES_texture_float_linear');
        this.supportLinearFloatTexture = !!this._extTextureFloatLinear;
        if (this._isWebGL2) {
            this.supportHalfFloatTexture = true;
            this.supportLinearHalfFloatTexture = true;
        } else {
            this._extTextureHalfFloat = gl.getExtension('OES_texture_half_float');
            this.supportHalfFloatTexture = !!this._extTextureHalfFloat;
            this._extTextureHalfFloatLinear = gl.getExtension('OES_texture_half_float_linear');
            this.supportLinearHalfFloatTexture = !!this._extTextureHalfFloatLinear;
        }
        if (this._isWebGL2) {
            if (gl.getExtension('EXT_color_buffer_float')) {
                this.supportHalfFloatColorBuffer = true;
                this.supportFloatColorBuffer = true;
            } else if (gl.getExtension('EXT_color_buffer_half_float')) {
                this.supportHalfFloatColorBuffer = true;
                this.supportFloatColorBuffer = false;
            } else {
                this.supportHalfFloatColorBuffer = false;
                this.supportFloatColorBuffer = false;
            }
        } else {
            this.supportFloatColorBuffer = !!gl.getExtension('WEBGL_color_buffer_float');
            this.supportHalfFloatColorBuffer = !!gl.getExtension('EXT_color_buffer_half_float');
        }
        this.supportFloatBlending = this.supportFloatColorBuffer && !!gl.getExtension('EXT_float_blend');
        this._extS3TC = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        this.supportS3TC = !!this._extS3TC;
        this._extS3TCSRGB = gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');
        this.supportS3TCSRGB = !!this._extS3TCSRGB;
        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.maxCubeTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        if (this._isWebGL2) {
            this.npo2Mipmapping = true;
            this.npo2Repeating = true;
        } else {
            this.npo2Mipmapping = false;
            this.npo2Repeating = false;
        }
        this._textureFormatInfos = {
            rgba8unorm: {
                glFormat: gl.RGBA,
                glInternalFormat: this._isWebGL2 ? gl.RGBA8 : gl.RGBA,
                glType: [
                    gl.UNSIGNED_BYTE,
                    gl.UNSIGNED_SHORT_4_4_4_4,
                    gl.UNSIGNED_SHORT_5_5_5_1
                ],
                filterable: true,
                renderable: true,
                compressed: false
            }
        };
        if (this.supportS3TC) {
            this._textureFormatInfos['dxt1'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt3'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt5'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
        }
        if (this.supportS3TCSRGB) {
            this._textureFormatInfos['dxt1-srgb'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TCSRGB.COMPRESSED_SRGB_S3TC_DXT1_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt3-srgb'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TCSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
            this._textureFormatInfos['dxt5-srgb'] = {
                glFormat: gl.NONE,
                glInternalFormat: this._extS3TCSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
                glType: [
                    gl.NONE
                ],
                filterable: true,
                renderable: false,
                compressed: true
            };
        }
        if (isWebGL2(gl)) {
            this._textureFormatInfos['r8unorm'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R8,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: true,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r8snorm'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R8_SNORM,
                glType: [
                    gl.BYTE
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['r16f'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R16F,
                glType: [
                    gl.HALF_FLOAT,
                    gl.FLOAT
                ],
                filterable: this.supportLinearHalfFloatTexture,
                renderable: this.supportHalfFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['r32f'] = {
                glFormat: gl.RED,
                glInternalFormat: gl.R32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: this.supportLinearFloatTexture,
                renderable: this.supportFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['r8ui'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R8UI,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r8i'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R8I,
                glType: [
                    gl.BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r16ui'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R16UI,
                glType: [
                    gl.UNSIGNED_SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r16i'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R16I,
                glType: [
                    gl.SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r32ui'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R32UI,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['r32i'] = {
                glFormat: gl.RED_INTEGER,
                glInternalFormat: gl.R32I,
                glType: [
                    gl.INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg8unorm'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: true,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg8snorm'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8_SNORM,
                glType: [
                    gl.BYTE
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['rg16f'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG16F,
                glType: [
                    gl.HALF_FLOAT,
                    gl.FLOAT
                ],
                filterable: this.supportLinearHalfFloatTexture,
                renderable: this.supportHalfFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rg32f'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: this.supportLinearFloatTexture,
                renderable: this.supportFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rg8ui'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8UI,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg8i'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG8I,
                glType: [
                    gl.BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg16ui'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG16UI,
                glType: [
                    gl.UNSIGNED_SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg16i'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG16I,
                glType: [
                    gl.SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg32ui'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG32UI,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg32i'] = {
                glFormat: gl.RG,
                glInternalFormat: gl.RG32I,
                glType: [
                    gl.INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba8unorm-srgb'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.SRGB8_ALPHA8,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: true,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba8snorm'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.RGBA8_SNORM,
                glType: [
                    gl.BYTE
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['rgba16f'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.RGBA16F,
                glType: [
                    gl.HALF_FLOAT,
                    gl.FLOAT
                ],
                filterable: this.supportLinearHalfFloatTexture,
                renderable: this.supportHalfFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rgba32f'] = {
                glFormat: gl.RGBA,
                glInternalFormat: gl.RGBA32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: this.supportLinearFloatTexture,
                renderable: this.supportFloatColorBuffer,
                compressed: false
            };
            this._textureFormatInfos['rgba8ui'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA8UI,
                glType: [
                    gl.UNSIGNED_BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba8i'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA8I,
                glType: [
                    gl.BYTE
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba16ui'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA16UI,
                glType: [
                    gl.UNSIGNED_SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba16i'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA16I,
                glType: [
                    gl.SHORT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba32ui'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA32UI,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rgba32i'] = {
                glFormat: gl.RGBA_INTEGER,
                glInternalFormat: gl.RGBA32I,
                glType: [
                    gl.INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['rg11b10uf'] = {
                glFormat: gl.RGB,
                glInternalFormat: gl.R11F_G11F_B10F,
                glType: [
                    gl.UNSIGNED_INT_10F_11F_11F_REV
                ],
                filterable: true,
                renderable: false,
                compressed: false
            };
            this._textureFormatInfos['d16'] = {
                glFormat: gl.DEPTH_COMPONENT,
                glInternalFormat: gl.DEPTH_COMPONENT16,
                glType: [
                    gl.UNSIGNED_SHORT,
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d24'] = {
                glFormat: gl.DEPTH_COMPONENT,
                glInternalFormat: gl.DEPTH_COMPONENT24,
                glType: [
                    gl.UNSIGNED_INT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d32f'] = {
                glFormat: gl.DEPTH_COMPONENT,
                glInternalFormat: gl.DEPTH_COMPONENT32F,
                glType: [
                    gl.FLOAT
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d24s8'] = {
                glFormat: gl.DEPTH_STENCIL,
                glInternalFormat: gl.DEPTH24_STENCIL8,
                glType: [
                    gl.UNSIGNED_INT_24_8
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
            this._textureFormatInfos['d32fs8'] = {
                glFormat: gl.DEPTH_STENCIL,
                glInternalFormat: gl.DEPTH32F_STENCIL8,
                glType: [
                    gl.FLOAT_32_UNSIGNED_INT_24_8_REV
                ],
                filterable: false,
                renderable: true,
                compressed: false
            };
        } else {
            if (this.supportFloatTexture) {
                this._textureFormatInfos['rgba32f'] = {
                    glFormat: gl.RGBA,
                    glInternalFormat: gl.RGBA,
                    glType: [
                        gl.FLOAT,
                        gl.UNSIGNED_BYTE,
                        gl.UNSIGNED_SHORT_4_4_4_4,
                        gl.UNSIGNED_SHORT_5_5_5_1
                    ],
                    filterable: this.supportLinearFloatTexture,
                    renderable: this.supportFloatColorBuffer,
                    compressed: false
                };
            }
            if (this.supportHalfFloatTexture) {
                this._textureFormatInfos['rgba16f'] = {
                    glFormat: gl.RGBA,
                    glInternalFormat: gl.RGBA,
                    glType: [
                        this._extTextureHalfFloat.HALF_FLOAT_OES,
                        gl.UNSIGNED_BYTE,
                        gl.UNSIGNED_SHORT_4_4_4_4,
                        gl.UNSIGNED_SHORT_5_5_5_1
                    ],
                    filterable: this.supportLinearHalfFloatTexture,
                    renderable: this.supportHalfFloatColorBuffer,
                    compressed: false
                };
            }
            if (this.supportSRGBTexture) {
                this._textureFormatInfos['rgba8unorm-srgb'] = {
                    glFormat: this._extSRGB.SRGB_ALPHA_EXT,
                    glInternalFormat: this._extSRGB.SRGB_ALPHA_EXT,
                    glType: [
                        gl.UNSIGNED_BYTE
                    ],
                    filterable: true,
                    renderable: false,
                    compressed: false
                };
            }
            if (this.supportDepthTexture) {
                this._textureFormatInfos['d16'] = {
                    glFormat: gl.DEPTH_COMPONENT,
                    glInternalFormat: gl.DEPTH_COMPONENT,
                    glType: [
                        gl.UNSIGNED_SHORT
                    ],
                    filterable: false,
                    renderable: true,
                    compressed: false
                };
                this._textureFormatInfos['d24'] = {
                    glFormat: gl.DEPTH_COMPONENT,
                    glInternalFormat: gl.DEPTH_COMPONENT,
                    glType: [
                        gl.UNSIGNED_INT
                    ],
                    filterable: false,
                    renderable: true,
                    compressed: false
                };
                this._textureFormatInfos['d24s8'] = {
                    glFormat: gl.DEPTH_STENCIL,
                    glInternalFormat: gl.DEPTH_STENCIL,
                    glType: [
                        this._extDepthTexture.UNSIGNED_INT_24_8_WEBGL
                    ],
                    filterable: false,
                    renderable: true,
                    compressed: false
                };
            }
        }
    }
    calcMemoryUsage(format, type, numPixels) {
        switch(format){
            case 'd16':
            case 'd24':
            case 'd24s8':
            case 'd32f':
                switch(type){
                    case WebGLEnum.UNSIGNED_SHORT:
                        return numPixels * 2;
                    default:
                        return numPixels * 4;
                }
            case 'd32fs8':
                return numPixels * 8;
            case 'dxt1':
            case 'dxt1-srgb':
                return numPixels / 2;
            case 'dxt3':
            case 'dxt3-srgb':
            case 'dxt5':
            case 'dxt5-srgb':
                return numPixels;
            case 'r16f':
                switch(type){
                    case WebGLEnum.HALF_FLOAT:
                        return numPixels * 2;
                    default:
                        return numPixels * 4;
                }
            case 'r16i':
            case 'r16ui':
                return numPixels * 2;
            case 'r32f':
            case 'r32i':
            case 'r32ui':
                return numPixels * 4;
            case 'r8unorm':
            case 'r8snorm':
            case 'r8i':
            case 'r8ui':
                return numPixels;
            case 'rg16f':
                switch(type){
                    case WebGLEnum.HALF_FLOAT:
                        return numPixels * 4;
                    default:
                        return numPixels * 8;
                }
            case 'rg16i':
            case 'rg16ui':
                return numPixels * 4;
            case 'rg32f':
            case 'rg32i':
            case 'rg32ui':
                return numPixels * 8;
            case 'rg8unorm':
            case 'rg8snorm':
            case 'rg8i':
            case 'rg8ui':
                return numPixels * 2;
            case 'rgba16f':
                switch(type){
                    case WebGLEnum.HALF_FLOAT:
                        return numPixels * 8;
                    default:
                        return numPixels * 16;
                }
            case 'rgba16i':
            case 'rgba16ui':
                return numPixels * 8;
            case 'rgba32f':
            case 'rgba32i':
            case 'rgba32ui':
                return numPixels * 16;
            case 'rgba8unorm':
            case 'rgba8unorm-srgb':
            case 'rgba8snorm':
            case 'rgba8i':
            case 'rgba8ui':
                return numPixels * 4;
            default:
                return 0;
        }
    }
    getTextureFormatInfo(format) {
        return this._textureFormatInfos[format];
    }
}

class WebGLStructuredBuffer extends WebGLGPUBuffer {
    _structure;
    _data;
    constructor(device, structure, usage, source){
        if (!structure?.isStructType()) {
            throw new Error('invalid structure type');
        }
        if (usage & GPUResourceUsageFlags.BF_INDEX) {
            throw new Error('structured buffer must not have Index usage flag');
        }
        if (usage & GPUResourceUsageFlags.BF_READ || usage & GPUResourceUsageFlags.BF_WRITE) {
            throw new Error('structured buffer must not have Read or Write usage flags');
        }
        if (usage & GPUResourceUsageFlags.BF_VERTEX) {
            if (structure.structMembers.length !== 1 || !structure.structMembers[0].type.isArrayType()) {
                throw new Error('structured buffer for vertex usage must have only one array member');
            }
            if (!WebGLStructuredBuffer.isValidArrayElementType(structure.structMembers[0].type.elementType)) {
                throw new Error('invalid vertex data type when creating vertex buffer');
            }
        }
        const layout = structure.toBufferLayout(0, structure.layout);
        if (source && layout.byteSize !== source.byteLength) {
            throw new Error(`create structured buffer failed: invalid source size: ${source.byteLength}, should be ${layout.byteSize}`);
        }
        const useSystemMemory = !device.isWebGL2 && (usage & GPUResourceUsageFlags.BF_UNIFORM) !== 0;
        super(device, usage, source || layout.byteSize, useSystemMemory);
        this._data = new StructuredBufferData(layout, useSystemMemory ? this.systemMemoryBuffer : this);
        this._structure = structure;
    }
    set(name, value) {
        this._data.set(name, value);
    }
    get structure() {
        return this._structure;
    }
    set structure(st) {
        if (st && !st.isCompatibleType(this._structure)) {
            const layout = st.toBufferLayout(0, st.layout);
            if (layout.byteSize > this.byteLength) {
                throw new Error(`set structure type failed: new structure type is too large: ${layout.byteSize}`);
            }
            this._data = new StructuredBufferData(layout, this);
            this._structure = st;
        }
    }
    getUniformData() {
        return this._data;
    }
    static isValidArrayElementType(type) {
        if (type.isPrimitiveType()) {
            return type.scalarType !== PBPrimitiveType.BOOL && !type.isMatrixType();
        } else if (type.isStructType()) {
            for (const member of type.structMembers){
                if (!member.type.isPrimitiveType() || member.type.scalarType === PBPrimitiveType.BOOL || member.type.isMatrixType()) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
}

class WebGLBindGroup extends WebGLGPUObject {
    _layout;
    _dynamicOffsets;
    _resources;
    constructor(device, layout){
        super(device);
        this._device = device;
        this._layout = layout;
        this._dynamicOffsets = null;
        this._resources = {};
        this._object = {};
        for (const entry of this._layout.entries){
            if (entry.buffer && entry.buffer.hasDynamicOffset) {
                if (!this._dynamicOffsets) {
                    this._dynamicOffsets = [];
                }
                this._dynamicOffsets[entry.buffer.dynamicOffsetIndex] = 0;
            }
        }
    }
    getGPUId() {
        return String(this._uid);
    }
    getLayout() {
        return this._layout;
    }
    getBuffer(name) {
        return this._getBuffer(name, true);
    }
    getDynamicOffsets() {
        return this._dynamicOffsets;
    }
    setBuffer(name, buffer, offset, bindOffset, bindSize) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.name === bindName) {
                if (!entry.buffer) {
                    console.log(`setBuffer() failed: resource '${name}' is not buffer`);
                } else {
                    if (buffer && !(buffer.usage & GPUResourceUsageFlags.BF_UNIFORM)) {
                        console.log(`setBuffer() failed: buffer resource '${name}' must be type '${entry.buffer.type}'`);
                    } else if (buffer !== this._resources[entry.name]) {
                        this._resources[entry.name] = buffer;
                    }
                    if (entry.buffer.hasDynamicOffset) {
                        this._dynamicOffsets[entry.buffer.dynamicOffsetIndex] = offset ?? 0;
                    }
                }
                return;
            }
        }
        console.log(`setBuffer() failed: no buffer resource named '${name}'`);
    }
    setRawData(name, byteOffset, data, srcPos, srcLength) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setRawData(mappedName, byteOffset, data, srcPos, srcLength);
        } else {
            const buffer = this._getBuffer(name, false);
            if (buffer) {
                buffer.bufferSubData(byteOffset, data, srcPos, srcLength);
            } else {
                console.log(`set(): no uniform buffer named '${name}'`);
            }
        }
    }
    setValue(name, value) {
        const mappedName = this._layout.nameMap?.[name];
        if (mappedName) {
            this.setValue(mappedName, {
                [name]: value
            });
        } else {
            const buffer = this._getBuffer(name, false);
            if (buffer) {
                if (!(buffer instanceof WebGLStructuredBuffer)) {
                    throw new Error(`BindGroup.setValue() failed: '${name}' is not structured buffer`);
                }
                if (value?.BYTES_PER_ELEMENT) {
                    buffer.bufferSubData(0, value);
                } else {
                    for(const k in value){
                        buffer.set(k, value[k]);
                    }
                }
            } else {
                console.log(`set(): no uniform buffer named '${name}'`);
            }
        }
    }
    setTextureView(name, value, level, face, mipCount, sampler) {
        throw new Error('setTextureView() not supported for webgl device');
    }
    getTexture(name) {
        const entry = this._findTextureLayout(name);
        if (entry) {
            return (this._resources[name]?.[0]) || null;
        } else {
            throw new Error(`getTexture() failed:${name} is not a texture`);
        }
    }
    setTexture(name, texture, sampler) {
        const entry = this._findTextureLayout(name);
        if (entry) {
            this._resources[name] = [
                texture,
                sampler || texture.getDefaultSampler(!!entry.texture?.autoBindSamplerComparison)
            ];
        } else {
            console.log(`setTexture() failed: no texture uniform named '${name}'`);
        }
    }
    setSampler(name, value) {
    // no sampler uniform support for webgl
    }
    apply(program, offsets) {
        const webgl2 = this._device.isWebGL2;
        const dynamicOffsets = offsets ?? this.getDynamicOffsets();
        for(let i = 0; i < this._layout.entries.length; i++){
            const entry = this._layout.entries[i];
            const res = this._resources[entry.name];
            if (res instanceof WebGLGPUBuffer) {
                if (webgl2) {
                    if (entry.buffer.hasDynamicOffset) {
                        program.setBlock(entry.type.structName, res, dynamicOffsets[entry.buffer.dynamicOffsetIndex]);
                    } else {
                        program.setBlock(entry.type.structName, res, 0);
                    }
                } else if (res instanceof WebGLStructuredBuffer) {
                    program.setUniform(entry.name, res.getUniformData().uniforms);
                }
            } else if (Array.isArray(res)) {
                if (res[0].isTextureVideo()) {
                    res[0].updateVideoFrame();
                }
                // res[0].sampler = res[1];
                program.setUniform(entry.name, res);
            }
        }
    }
    destroy() {
        this._resources = {};
        this._object = null;
    }
    async restore() {
        this._object = {};
    }
    isBindGroup() {
        return true;
    }
    _getBuffer(name, nocreate = false) {
        const bindName = this._layout.nameMap?.[name] ?? name;
        for (const entry of this._layout.entries){
            if (entry.buffer && entry.name === bindName) {
                let buffer = this._resources[entry.name];
                if (!buffer && !nocreate) {
                    buffer = this._device.createStructuredBuffer(entry.type, {
                        usage: 'uniform'
                    });
                    this._resources[entry.name] = buffer;
                }
                return buffer;
            }
        }
        return null;
    }
    _findTextureLayout(name) {
        for (const entry of this._layout.entries){
            if ((entry.texture || entry.storageTexture || entry.externalTexture) && entry.name === name) {
                return entry;
            }
        }
        return null;
    }
}

class WebGLGPUProgram extends WebGLGPUObject {
    _vs;
    _fs;
    _unitCounter;
    _uniformSetters;
    _uniformInfo;
    _blockInfo;
    _bindGroupLayouts;
    _vertexAttributes;
    _error;
    _vertexShader;
    _fragmentShader;
    constructor(device, vertexShader, fragmentShader, bindGroupLayouts, vertexAttributes){
        super(device);
        this._object = this._device.context.createProgram();
        this._unitCounter = 0;
        this._uniformSetters = null;
        this._uniformInfo = null;
        this._blockInfo = null;
        this._error = '';
        this._vertexShader = null;
        this._fragmentShader = null;
        this._vs = vertexShader;
        this._fs = fragmentShader;
        this._bindGroupLayouts = [
            ...bindGroupLayouts
        ];
        this._vertexAttributes = [
            ...vertexAttributes
        ];
        this.load();
    }
    get type() {
        return 'render';
    }
    getCompileError() {
        return this._error;
    }
    getShaderSource(kind) {
        switch(kind){
            case 'vertex':
                return this._vs;
            case 'fragment':
                return this._fs;
            case 'compute':
                return null;
        }
    }
    getBindingInfo(name) {
        for(let group = 0; group < this._bindGroupLayouts.length; group++){
            const layout = this._bindGroupLayouts[group];
            const bindName = layout.nameMap?.[name] ?? name;
            for(let binding = 0; binding < layout.entries.length; binding++){
                const bindingPoint = layout.entries[binding];
                if (bindingPoint.name === bindName) {
                    return {
                        group: group,
                        binding: binding,
                        type: bindingPoint.type
                    };
                }
            }
        }
        return null;
    }
    get bindGroupLayouts() {
        return this._bindGroupLayouts;
    }
    get vertexAttributes() {
        return this._vertexAttributes;
    }
    setUniform(name, value) {
        const setter = this._uniformSetters[name];
        if (setter) {
            setter(value);
        } else {
            const proto = Object.getPrototypeOf(value);
            if (proto === Object.getPrototypeOf({})) {
                this._setUniformStruct(name, value);
            } else if (proto == Object.getPrototypeOf([])) {
                this._setUniformArray(name, value);
            }
        }
    }
    setBlock(name, value, offset) {
        const info = this._blockInfo[name];
        if (info) {
            this._device.bindUniformBuffer(info.index, value, offset);
        /*
      if (offset) {
        (this._device.context as WebGL2RenderingContext).bindBufferRange(
          WebGLEnum.UNIFORM_BUFFER,
          info.index,
          value.object,
          offset,
          value.byteLength - offset
        );
      } else {
        (this._device.context as WebGL2RenderingContext).bindBufferBase(
          WebGLEnum.UNIFORM_BUFFER,
          info.index,
          value.object
        );
      }
      */ } else {
            console.error(`Block not found: ${name}`);
        }
    }
    destroy() {
        if (this._object) {
            this._device.context.deleteProgram(this._object);
            this._object = null;
            this._unitCounter = 0;
            this._uniformSetters = null;
            this._uniformInfo = null;
            this._blockInfo = null;
            this._error = '';
            this._vertexShader = null;
            this._fragmentShader = null;
        }
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this.load();
        }
    }
    isProgram() {
        return true;
    }
    use() {
        if (this !== this._device.context._currentProgram) {
            if (!this.checkLoad()) {
                return false;
            }
        /*
      this._device.context._currentProgram = this;
      this._device.context.useProgram(this._object);
      */ }
        return true;
    }
    createUniformBuffer(uniform) {
        const type = this.getBindingInfo(uniform)?.type;
        return type ? this.device.createStructuredBuffer(type, {
            usage: 'uniform'
        }) : null;
    }
    _setUniformStruct(name, value) {
        for(const k in value){
            this.setUniform(`${name}.${k}`, value[k]);
        }
    }
    _setUniformArray(name, value) {
        for(let i = 0; i < value.length; i++){
            this.setUniform(`${name}[${i}]`, value[i]);
        }
    }
    load() {
        if (this._device.isContextLost()) {
            return;
        }
        const gl = this._device.context;
        this._error = null;
        this._uniformSetters = {};
        if (!this._object) {
            this._object = this._device.context.createProgram();
        }
        this._vertexShader = gl.createShader(WebGLEnum.VERTEX_SHADER);
        gl.attachShader(this._object, this._vertexShader);
        gl.shaderSource(this._vertexShader, this._vs);
        gl.compileShader(this._vertexShader);
        this._fragmentShader = gl.createShader(WebGLEnum.FRAGMENT_SHADER);
        gl.attachShader(this._object, this._fragmentShader);
        gl.shaderSource(this._fragmentShader, this._fs);
        gl.compileShader(this._fragmentShader);
        for(let loc = 0; loc < semanticList.length; loc++){
            gl.bindAttribLocation(this._object, loc, semanticList[loc]);
        }
        gl.linkProgram(this._object);
    }
    checkLoad() {
        if (!this._object) {
            return false;
        }
        if (this._vertexShader) {
            const gl = this._device.context;
            if (!this._device.isContextLost()) {
                if (!gl.getProgramParameter(this._object, WebGLEnum.LINK_STATUS)) {
                    if (!gl.getShaderParameter(this._vertexShader, WebGLEnum.COMPILE_STATUS)) {
                        this._error = gl.getShaderInfoLog(this._vertexShader);
                        console.error(new Error(`Compile shader failed: ${this._error}`));
                    } else if (!gl.getShaderParameter(this._fragmentShader, WebGLEnum.COMPILE_STATUS)) {
                        this._error = gl.getShaderInfoLog(this._fragmentShader);
                        console.error(new Error(`Compile shader failed: ${this._error}`));
                    } else {
                        this._error = gl.getProgramInfoLog(this._object);
                        console.error(new Error(`Load program failed: \n${this._error}`));
                    }
                }
            }
            gl.deleteShader(this._vertexShader);
            this._vertexShader = null;
            gl.deleteShader(this._fragmentShader);
            this._fragmentShader = null;
            if (this._error) {
                gl.deleteProgram(this._object);
                this._object = null;
                return false;
            }
            this._device.context._currentProgram = this;
            this._device.context.useProgram(this._object);
            this._uniformSetters = this.createUniformSetters();
        } else {
            this._device.context._currentProgram = this;
            this._device.context.useProgram(this._object);
        }
        return true;
    }
    createUniformSetter(info) {
        const loc = info.location;
        const isArray = info.isArray;
        const gl = this._device.context;
        switch(info.type){
            case WebGLEnum.FLOAT:
                return this.getUniformSetterfv(loc);
            case WebGLEnum.FLOAT_VEC2:
                return this.getUniformSetter2fv(loc);
            case WebGLEnum.FLOAT_VEC3:
                return this.getUniformSetter3fv(loc);
            case WebGLEnum.FLOAT_VEC4:
                return this.getUniformSetter4fv(loc);
            case WebGLEnum.INT:
                return this.getUniformSetteriv(loc);
            case WebGLEnum.INT_VEC2:
                return this.getUniformSetter2iv(loc);
            case WebGLEnum.INT_VEC3:
                return this.getUniformSetter3iv(loc);
            case WebGLEnum.INT_VEC4:
                return this.getUniformSetter4iv(loc);
            case WebGLEnum.UNSIGNED_INT:
                return this.getUniformSetteruiv(loc);
            case WebGLEnum.UNSIGNED_INT_VEC2:
                return this.getUniformSetter2uiv(loc);
            case WebGLEnum.UNSIGNED_INT_VEC3:
                return this.getUniformSetter3uiv(loc);
            case WebGLEnum.UNSIGNED_INT_VEC4:
                return this.getUniformSetter4uiv(loc);
            case WebGLEnum.BOOL:
                return this.getUniformSetteriv(loc);
            case WebGLEnum.BOOL_VEC2:
                return this.getUniformSetter2iv(loc);
            case WebGLEnum.BOOL_VEC3:
                return this.getUniformSetter3iv(loc);
            case WebGLEnum.BOOL_VEC4:
                return this.getUniformSetter4iv(loc);
            case WebGLEnum.FLOAT_MAT2:
                return this.getUniformSetterMatrix2(loc);
            case WebGLEnum.FLOAT_MAT2x3:
                return this.getUniformSetterMatrix23(loc);
            case WebGLEnum.FLOAT_MAT2x4:
                return this.getUniformSetterMatrix24(loc);
            case WebGLEnum.FLOAT_MAT3:
                return this.getUniformSetterMatrix3(loc);
            case WebGLEnum.FLOAT_MAT3x2:
                return this.getUniformSetterMatrix32(loc);
            case WebGLEnum.FLOAT_MAT3x4:
                return this.getUniformSetterMatrix34(loc);
            case WebGLEnum.FLOAT_MAT4:
                return this.getUniformSetterMatrix4(loc);
            case WebGLEnum.FLOAT_MAT4x2:
                return this.getUniformSetterMatrix42(loc);
            case WebGLEnum.FLOAT_MAT4x3:
                return this.getUniformSetterMatrix43(loc);
            case WebGLEnum.SAMPLER_2D:
            case WebGLEnum.SAMPLER_2D_SHADOW:
            case WebGLEnum.INT_SAMPLER_2D:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_2D:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        gl.uniform1i(loc, unit);
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_2D, unit);
                    }
                }
            case WebGLEnum.SAMPLER_2D_ARRAY:
            case WebGLEnum.SAMPLER_2D_ARRAY_SHADOW:
            case WebGLEnum.INT_SAMPLER_2D_ARRAY:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        gl.uniform1i(loc, unit);
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_2D_ARRAY, unit);
                    }
                }
            case WebGLEnum.SAMPLER_CUBE:
            case WebGLEnum.SAMPLER_CUBE_SHADOW:
            case WebGLEnum.INT_SAMPLER_CUBE:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_CUBE:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        gl.uniform1i(loc, unit);
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_CUBE_MAP, unit);
                    }
                }
            case WebGLEnum.SAMPLER_3D:
            case WebGLEnum.INT_SAMPLER_3D:
            case WebGLEnum.UNSIGNED_INT_SAMPLER_3D:
                {
                    const unit = this._unitCounter;
                    this._unitCounter += info.size;
                    if (!isArray) {
                        gl.uniform1i(loc, unit);
                        return this.getSamplerSetter(loc, WebGLEnum.TEXTURE_3D, unit);
                    }
                }
        }
        console.error(`Error: unsupported uniform type: ${info.name}`);
        return null;
    }
    createUniformSetters() {
        const uniformSetters = {};
        const gl = this._device.context;
        const numUniforms = gl.getProgramParameter(this._object, WebGLEnum.ACTIVE_UNIFORMS);
        this._uniformInfo = [];
        for(let index = 0; index < numUniforms; index++){
            const info = gl.getActiveUniform(this._object, index);
            let name = info.name;
            let isArray = false;
            if (name.startsWith('gl_') || name.startsWith('webgl_')) {
                this._uniformInfo.push(null);
            } else {
                if (name.substr(-3) === '[0]') {
                    // is array
                    name = name.substr(0, name.length - 3);
                    isArray = true;
                }
                const size = info.size;
                const type = info.type;
                const blockIndex = -1;
                const offset = 0;
                const location = gl.getUniformLocation(this._object, info.name);
                const view = null;
                const { ctor: viewCtor, elementSize: viewElementSize } = this.getTypedArrayInfo(info.type);
                const uniformInfo = {
                    index,
                    name,
                    size,
                    type,
                    blockIndex,
                    offset,
                    isArray,
                    location,
                    view,
                    viewCtor,
                    viewElementSize
                };
                this._uniformInfo.push(uniformInfo);
                if (location) {
                    uniformSetters[name] = this.createUniformSetter(uniformInfo);
                }
            }
        }
        if (isWebGL2(gl)) {
            this._blockInfo = {};
            const numBlocks = gl.getProgramParameter(this._object, WebGLEnum.ACTIVE_UNIFORM_BLOCKS);
            for(let i = 0; i < numBlocks; i++){
                const name = gl.getActiveUniformBlockName(this._object, i);
                const index = gl.getUniformBlockIndex(this._object, name);
                const usedInVS = !!gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER);
                const usedInFS = !!gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER);
                const used = usedInVS || usedInFS;
                const size = gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_DATA_SIZE);
                const uniformIndices = gl.getActiveUniformBlockParameter(this._object, i, WebGLEnum.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES);
                this._blockInfo[name] = {
                    index,
                    used,
                    size,
                    uniformIndices
                };
                gl.uniformBlockBinding(this._object, index, index);
            }
        /*
      const indices: number[] = this._uniformInfo.map(val => val.index);
      const types = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_TYPE);
      const sizes = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_SIZE);
      const blockIndices = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_BLOCK_INDEX);
      const offsets = gl.getActiveUniforms(this._object, indices, WebGLEnum.UNIFORM_OFFSET);
      this._uniformInfo.forEach((val, index) => {
        val.type = types[index];
        val.size = sizes[index];
        val.blockIndex = blockIndices[index];
        val.offset = offsets[index];
      });
      */ }
        return uniformSetters;
    }
    getUniformSetterfv(location) {
        return (value)=>{
            this._device.context.uniform1fv(location, value);
        };
    }
    getUniformSetter2fv(location) {
        return (value)=>{
            this._device.context.uniform2fv(location, value);
        };
    }
    getUniformSetter3fv(location) {
        return (value)=>{
            this._device.context.uniform3fv(location, value);
        };
    }
    getUniformSetter4fv(location) {
        return (value)=>{
            this._device.context.uniform4fv(location, value);
        };
    }
    getUniformSetteriv(location) {
        return (value)=>{
            this._device.context.uniform1iv(location, value);
        };
    }
    getUniformSetter2iv(location) {
        return (value)=>{
            this._device.context.uniform2iv(location, value);
        };
    }
    getUniformSetter3iv(location) {
        return (value)=>{
            this._device.context.uniform3iv(location, value);
        };
    }
    getUniformSetter4iv(location) {
        return (value)=>{
            this._device.context.uniform4iv(location, value);
        };
    }
    getUniformSetteruiv(location) {
        return (value)=>{
            this._device.context.uniform1uiv(location, value);
        };
    }
    getUniformSetter2uiv(location) {
        return (value)=>{
            this._device.context.uniform2uiv(location, value);
        };
    }
    getUniformSetter3uiv(location) {
        return (value)=>{
            this._device.context.uniform3uiv(location, value);
        };
    }
    getUniformSetter4uiv(location) {
        return (value)=>{
            this._device.context.uniform4uiv(location, value);
        };
    }
    getUniformSetterMatrix2(location) {
        return (value)=>{
            this._device.context.uniformMatrix2fv(location, false, value);
        };
    }
    getUniformSetterMatrix23(location) {
        return (value)=>{
            this._device.context.uniformMatrix2x3fv(location, false, value);
        };
    }
    getUniformSetterMatrix24(location) {
        return (value)=>{
            this._device.context.uniformMatrix2x4fv(location, false, value);
        };
    }
    getUniformSetterMatrix32(location) {
        return (value)=>{
            this._device.context.uniformMatrix3x2fv(location, false, value);
        };
    }
    getUniformSetterMatrix3(location) {
        return (value)=>{
            this._device.context.uniformMatrix3fv(location, false, value);
        };
    }
    getUniformSetterMatrix34(location) {
        return (value)=>{
            this._device.context.uniformMatrix3x4fv(location, false, value);
        };
    }
    getUniformSetterMatrix42(location) {
        return (value)=>{
            this._device.context.uniformMatrix4x2fv(location, false, value);
        };
    }
    getUniformSetterMatrix43(location) {
        return (value)=>{
            this._device.context.uniformMatrix4x3fv(location, false, value);
        };
    }
    getUniformSetterMatrix4(location) {
        return (value)=>{
            this._device.context.uniformMatrix4fv(location, false, value);
        };
    }
    getSamplerSetter(location, target, unit) {
        return (texture)=>this._device.bindTexture(target, unit, texture[0], texture[1]);
    /*
    const gl = this._device.context;
    return isWebGL2(gl)
      ? (texture: [WebGLBaseTexture, WebGLTextureSampler]) => {
          const tex = texture?.[0].object ?? null;
          const sampler = texture?.[1].object ?? null;
          //gl.uniform1i(location, unit);
          gl.activeTexture(this._device.context.TEXTURE0 + unit);
          gl.bindTexture(target, tex);
          gl.bindSampler(unit, sampler);
        }
      : (texture: [WebGLBaseTexture, WebGLTextureSampler]) => {
          const tex = texture?.[0] ?? null;
          const sampler = texture?.[1] ?? null;
          //gl.uniform1i(location, unit);
          gl.activeTexture(this._device.context.TEXTURE0 + unit);
          gl.bindTexture(target, tex?.object ?? null);
          if (tex && sampler && this._device.getCurrentSamplerForTexture(tex) !== sampler) {
            const fallback = tex.isWebGL1Fallback;
            this._device.setCurrentSamplerForTexture(tex, sampler);
            gl.texParameteri(
              target,
              WebGLEnum.TEXTURE_WRAP_S,
              textureWrappingMap[false && fallback ? 'clamp' : sampler.addressModeU]
            );
            gl.texParameteri(
              target,
              WebGLEnum.TEXTURE_WRAP_T,
              textureWrappingMap[false && fallback ? 'clamp' : sampler.addressModeV]
            );
            gl.texParameteri(
              target,
              WebGLEnum.TEXTURE_MAG_FILTER,
              textureMagFilterToWebGL(sampler.magFilter)
            );
            gl.texParameteri(
              target,
              WebGLEnum.TEXTURE_MIN_FILTER,
              textureMinFilterToWebGL(sampler.minFilter, tex.isWebGL1Fallback ? 'none' : sampler.mipFilter)
            );
            if (this._device.getDeviceCaps().textureCaps.supportAnisotropicFiltering) {
              gl.texParameterf(target, WebGLEnum.TEXTURE_MAX_ANISOTROPY, sampler.maxAnisotropy);
            }
          }
        };
    */ }
    getTypedArrayInfo(type) {
        let ctor = null;
        let elementSize = 0;
        switch(type){
            case WebGLEnum.INT:
                ctor = Int32Array;
                elementSize = 4;
                break;
            case WebGLEnum.INT_VEC2:
                ctor = Int32Array;
                elementSize = 8;
                break;
            case WebGLEnum.INT_VEC3:
                ctor = Int32Array;
                elementSize = 12;
                break;
            case WebGLEnum.INT_VEC4:
                ctor = Int32Array;
                elementSize = 16;
                break;
            case WebGLEnum.UNSIGNED_INT:
            case WebGLEnum.BOOL:
                ctor = Uint32Array;
                elementSize = 4;
                break;
            case WebGLEnum.UNSIGNED_INT_VEC2:
            case WebGLEnum.BOOL_VEC2:
                ctor = Uint32Array;
                elementSize = 8;
                break;
            case WebGLEnum.UNSIGNED_INT_VEC3:
            case WebGLEnum.BOOL_VEC3:
                ctor = Uint32Array;
                elementSize = 12;
                break;
            case WebGLEnum.UNSIGNED_INT_VEC4:
            case WebGLEnum.BOOL_VEC4:
                ctor = Uint32Array;
                elementSize = 16;
                break;
            case WebGLEnum.FLOAT:
                ctor = Float32Array;
                elementSize = 4;
                break;
            case WebGLEnum.FLOAT_VEC2:
                ctor = Float32Array;
                elementSize = 8;
                break;
            case WebGLEnum.FLOAT_VEC3:
                ctor = Float32Array;
                elementSize = 12;
                break;
            case WebGLEnum.FLOAT_VEC4:
            case WebGLEnum.FLOAT_MAT2:
                ctor = Float32Array;
                elementSize = 16;
                break;
            case WebGLEnum.FLOAT_MAT2x3:
            case WebGLEnum.FLOAT_MAT3x2:
                ctor = Float32Array;
                elementSize = 24;
                break;
            case WebGLEnum.FLOAT_MAT2x4:
            case WebGLEnum.FLOAT_MAT4x2:
                ctor = Float32Array;
                elementSize = 32;
                break;
            case WebGLEnum.FLOAT_MAT3:
                ctor = Float32Array;
                elementSize = 36;
                break;
            case WebGLEnum.FLOAT_MAT3x4:
            case WebGLEnum.FLOAT_MAT4x3:
                ctor = Float32Array;
                elementSize = 48;
                break;
            case WebGLEnum.FLOAT_MAT4:
                ctor = Float32Array;
                elementSize = 64;
                break;
        }
        return {
            ctor,
            elementSize
        };
    }
}

class WebGLTextureSampler extends WebGLGPUObject {
    _options;
    constructor(device, options){
        super(device);
        this._options = Object.assign({
            addressU: 'clamp',
            addressV: 'clamp',
            addressW: 'clamp',
            magFilter: 'nearest',
            minFilter: 'nearest',
            mipFilter: 'none',
            lodMin: 0,
            lodMax: 32,
            compare: null,
            maxAnisotropy: 1
        }, options || {});
        this._load();
    }
    get addressModeU() {
        return this._options.addressU;
    }
    get addressModeV() {
        return this._options.addressV;
    }
    get addressModeW() {
        return this._options.addressW;
    }
    get magFilter() {
        return this._options.magFilter;
    }
    get minFilter() {
        return this._options.minFilter;
    }
    get mipFilter() {
        return this._options.mipFilter;
    }
    get lodMin() {
        return this._options.lodMin;
    }
    get lodMax() {
        return this._options.lodMax;
    }
    get compare() {
        return this._options.compare;
    }
    get maxAnisotropy() {
        return this._options.maxAnisotropy;
    }
    destroy() {
        if (this._object && isWebGL2(this._device.context)) {
            this._device.context.deleteSampler(this._object);
        }
        this._object = null;
    }
    async restore() {
        if (!this._object && !this._device.isContextLost()) {
            this._load();
        }
    }
    apply(texture) {
        if (texture?.object && !this._device.isWebGL2 && !this._device.isContextLost()) {
            const gl = this._device.context;
            const target = textureTargetMap[texture.target];
            this._device.bindTexture(target, 0, texture);
            //gl.bindTexture(target, texture.object);
            gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_S, textureWrappingMap[this._options.addressU]);
            gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_T, textureWrappingMap[this._options.addressV]);
            gl.texParameteri(target, WebGLEnum.TEXTURE_MAG_FILTER, textureMagFilterToWebGL(this._options.magFilter));
            gl.texParameteri(target, WebGLEnum.TEXTURE_MIN_FILTER, textureMinFilterToWebGL(this._options.minFilter, this._options.mipFilter));
            if (this._device.getDeviceCaps().textureCaps.supportAnisotropicFiltering) {
                gl.texParameterf(target, WebGLEnum.TEXTURE_MAX_ANISOTROPY, this._options.maxAnisotropy);
            }
        }
    }
    _load() {
        if (!isWebGL2(this._device.context)) {
            this._object = {};
            return true;
        }
        if (!this._device.isContextLost()) {
            const gl = this._device.context;
            if (!this._object) {
                this._object = gl.createSampler();
            }
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_WRAP_S, textureWrappingMap[this._options.addressU]);
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_WRAP_T, textureWrappingMap[this._options.addressV]);
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_WRAP_R, textureWrappingMap[this._options.addressW]);
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_MAG_FILTER, textureMagFilterToWebGL(this._options.magFilter));
            gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_MIN_FILTER, textureMinFilterToWebGL(this._options.minFilter, this._options.mipFilter));
            gl.samplerParameterf(this._object, WebGLEnum.TEXTURE_MIN_LOD, this._options.lodMin);
            gl.samplerParameterf(this._object, WebGLEnum.TEXTURE_MAX_LOD, this._options.lodMax);
            if (this._options.compare === null) {
                gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_COMPARE_MODE, WebGLEnum.NONE);
            } else {
                gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_COMPARE_MODE, WebGLEnum.COMPARE_REF_TO_TEXTURE);
                gl.samplerParameteri(this._object, WebGLEnum.TEXTURE_COMPARE_FUNC, compareFuncMap[this._options.compare]);
            }
            if (this._device.getDeviceCaps().textureCaps.supportAnisotropicFiltering) {
                gl.samplerParameterf(this._object, WebGLEnum.TEXTURE_MAX_ANISOTROPY, this._options.maxAnisotropy);
            }
        }
        return true;
    }
    isSampler() {
        return true;
    }
}

class SamplerCache {
    _device;
    _samplers;
    constructor(device){
        this._device = device;
        this._samplers = {};
    }
    fetchSampler(options) {
        const hash = this.hash(options);
        let sampler = this._samplers[hash];
        if (!sampler) {
            sampler = this.createSampler(options);
            this._samplers[hash] = sampler;
        }
        return sampler;
    }
    hash(options) {
        const addressU = options.addressU ? String(options.addressU) : '';
        const addressV = options.addressV ? String(options.addressV) : '';
        const addressW = options.addressW ? String(options.addressW) : '';
        const magFilter = options.magFilter ? String(options.magFilter) : '';
        const minFilter = options.minFilter ? String(options.minFilter) : '';
        const mipFilter = options.mipFilter ? String(options.mipFilter) : '';
        const lodMin = options.lodMin ? String(options.lodMin) : '';
        const lodMax = options.lodMax ? String(options.lodMax) : '';
        const compare = options.compare ? String(options.compare) : '';
        const maxAnisotropy = options.maxAnisotropy ? String(options.maxAnisotropy) : '';
        return `${addressU}:${addressV}:${addressW}:${magFilter}:${minFilter}:${mipFilter}:${lodMin}:${lodMax}:${compare}:${maxAnisotropy}`;
    }
    createSampler(options) {
        return new WebGLTextureSampler(this._device, options);
    }
}

const typeU16 = PBPrimitiveTypeInfo.getCachedTypeInfo(PBPrimitiveType.U16);
const tempInt32Array = new Int32Array(4);
const tempUint32Array = new Uint32Array(4);
class WebGLDevice extends BaseDevice {
    _context;
    _isWebGL2;
    _msaaSampleCount;
    _loseContextExtension;
    _contextLost;
    _isRendering;
    _dpr;
    _reverseWindingOrder;
    _deviceCaps;
    _vaoExt;
    _instancedArraysExt;
    _drawBuffersExt;
    _currentProgram;
    _currentVertexData;
    _currentStateSet;
    _currentBindGroups;
    _currentBindGroupOffsets;
    _currentViewport;
    _currentScissorRect;
    _samplerCache;
    _textureSamplerMap;
    _captureRenderBundle;
    _deviceUniformBuffers;
    _deviceUniformBufferOffsets;
    _bindTextures;
    _bindSamplers;
    constructor(backend, cvs, options){
        super(cvs, backend);
        this._dpr = Math.max(1, Math.floor(options?.dpr ?? window.devicePixelRatio));
        this._isRendering = false;
        this._captureRenderBundle = null;
        this._msaaSampleCount = options?.msaa ? 4 : 1;
        let context = null;
        context = this.canvas.getContext(backend === backend1 ? 'webgl' : 'webgl2', {
            antialias: !!options?.msaa,
            depth: true,
            stencil: true,
            premultipliedAlpha: false
        });
        if (!context) {
            throw new Error('Invalid argument or no webgl support');
        }
        this._isWebGL2 = isWebGL2(context);
        this._contextLost = false;
        this._reverseWindingOrder = false;
        this._deviceCaps = null;
        this._context = context;
        this._currentProgram = null;
        this._currentVertexData = null;
        this._currentStateSet = null;
        this._currentBindGroups = [];
        this._currentBindGroupOffsets = [];
        this._currentViewport = null;
        this._currentScissorRect = null;
        this._deviceUniformBuffers = [];
        this._deviceUniformBufferOffsets = [];
        this._bindTextures = {
            [WebGLEnum.TEXTURE_2D]: [],
            [WebGLEnum.TEXTURE_CUBE_MAP]: [],
            [WebGLEnum.TEXTURE_3D]: [],
            [WebGLEnum.TEXTURE_2D_ARRAY]: []
        };
        this._bindSamplers = [];
        this._samplerCache = new SamplerCache(this);
        this._textureSamplerMap = new WeakMap();
        this._loseContextExtension = this._context.getExtension('WEBGL_lose_context');
        this.canvas.addEventListener('webglcontextlost', (evt)=>{
            this._contextLost = true;
            evt.preventDefault();
            this.handleContextLost();
        }, false);
        this.canvas.addEventListener('webglcontextrestored', (evt)=>{
            this._contextLost = false;
            this.handleContextRestored();
        }, false);
    }
    get context() {
        return this._context;
    }
    getFrameBufferSampleCount() {
        return this.getFramebuffer()?.getSampleCount() ?? this._msaaSampleCount;
    }
    get isWebGL2() {
        return this._isWebGL2;
    }
    get drawingBufferWidth() {
        return this.getDrawingBufferWidth();
    }
    get drawingBufferHeight() {
        return this.getDrawingBufferHeight();
    }
    get clientWidth() {
        return this.canvas.clientWidth;
    }
    get clientHeight() {
        return this.canvas.clientHeight;
    }
    getScale() {
        return this._dpr;
    }
    isContextLost() {
        return this._context.isContextLost();
    }
    getDeviceCaps() {
        return this._deviceCaps;
    }
    get vaoExt() {
        return this._vaoExt;
    }
    get instancedArraysExt() {
        return this._instancedArraysExt;
    }
    get drawBuffersExt() {
        return this._drawBuffersExt;
    }
    getDrawingBufferWidth() {
        return this._context._currentFramebuffer?.getWidth() || this._context.drawingBufferWidth;
    }
    getDrawingBufferHeight() {
        return this._context._currentFramebuffer?.getHeight() || this._context.drawingBufferHeight;
    }
    getBackBufferWidth() {
        return this.canvas.width;
    }
    getBackBufferHeight() {
        return this.canvas.height;
    }
    invalidateBindingTextures() {
        this._bindTextures = {
            [WebGLEnum.TEXTURE_2D]: [],
            [WebGLEnum.TEXTURE_CUBE_MAP]: [],
            [WebGLEnum.TEXTURE_3D]: [],
            [WebGLEnum.TEXTURE_2D_ARRAY]: []
        };
    }
    bindTexture(target, layer, texture, sampler) {
        const tex = texture?.object ?? null;
        const gl = this._context;
        gl.activeTexture(WebGLEnum.TEXTURE0 + layer);
        if (this._bindTextures[target][layer] !== tex) {
            gl.bindTexture(target, tex);
            this._bindTextures[target][layer] = tex;
        }
        if (this._isWebGL2) {
            const samp = sampler?.object ?? null;
            if (samp && this._bindSamplers[layer] !== samp) {
                gl.bindSampler(layer, samp);
                this._bindSamplers[layer] = samp;
            }
        } else if (texture && sampler && this._textureSamplerMap.get(texture) !== sampler) {
            const fallback = texture.isWebGL1Fallback;
            this._textureSamplerMap.set(texture, sampler);
            gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_S, textureWrappingMap[sampler.addressModeU]);
            gl.texParameteri(target, WebGLEnum.TEXTURE_WRAP_T, textureWrappingMap[sampler.addressModeV]);
            gl.texParameteri(target, WebGLEnum.TEXTURE_MAG_FILTER, textureMagFilterToWebGL(sampler.magFilter));
            gl.texParameteri(target, WebGLEnum.TEXTURE_MIN_FILTER, textureMinFilterToWebGL(sampler.minFilter, fallback ? 'none' : sampler.mipFilter));
            if (this.getDeviceCaps().textureCaps.supportAnisotropicFiltering) {
                gl.texParameterf(target, WebGLEnum.TEXTURE_MAX_ANISOTROPY, sampler.maxAnisotropy);
            }
        }
    }
    bindUniformBuffer(index, buffer, offset) {
        if (this._deviceUniformBuffers[index] !== buffer.object || this._deviceUniformBufferOffsets[index] !== offset) {
            if (offset) {
                this.context.bindBufferRange(WebGLEnum.UNIFORM_BUFFER, index, buffer.object, offset, buffer.byteLength - offset);
            } else {
                this.context.bindBufferBase(WebGLEnum.UNIFORM_BUFFER, index, buffer.object);
            }
            this._deviceUniformBuffers[index] = buffer.object;
            this._deviceUniformBufferOffsets[index] = offset;
        }
    }
    async initContext() {
        this.initContextState();
        this.on('resize', (evt)=>{
            const width = Math.max(1, Math.round(this.canvas.clientWidth * this._dpr));
            const height = Math.max(1, Math.round(this.canvas.clientHeight * this._dpr));
            if (width !== this.canvas.width || height !== this.canvas.height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this.setViewport(this._currentViewport);
                this.setScissor(this._currentScissorRect);
            }
        });
        this.dispatchEvent(new DeviceResizeEvent(this.canvas.clientWidth, this.canvas.clientHeight));
    }
    clearFrameBuffer(clearColor, clearDepth, clearStencil) {
        const gl = this._context;
        const colorFlag = clearColor ? gl.COLOR_BUFFER_BIT : 0;
        const depthFlag = typeof clearDepth === 'number' ? gl.DEPTH_BUFFER_BIT : 0;
        const stencilFlag = typeof clearStencil === 'number' ? gl.STENCIL_BUFFER_BIT : 0;
        if (colorFlag || depthFlag || stencilFlag) {
            WebGLDepthState.applyDefaults(this._context);
            if (isWebGL2(gl) && gl._currentFramebuffer) {
                if (depthFlag || stencilFlag) {
                    const depthAttachment = gl._currentFramebuffer.getDepthAttachment();
                    if (depthAttachment) {
                        gl.clearBufferfi(WebGLEnum.DEPTH_STENCIL, 0, clearDepth || 1, clearStencil || 0);
                    }
                }
                if (colorFlag) {
                    const attachments = gl._currentFramebuffer.getColorAttachments();
                    for(let i = 0; i < attachments.length; i++){
                        if (isIntegerTextureFormat(attachments[i].format)) {
                            if (isSignedTextureFormat(attachments[i].format)) {
                                tempInt32Array[0] = clearColor[0];
                                tempInt32Array[1] = clearColor[1];
                                tempInt32Array[2] = clearColor[2];
                                tempInt32Array[3] = clearColor[3];
                                gl.clearBufferiv(WebGLEnum.COLOR, i, tempInt32Array);
                            } else {
                                tempUint32Array[0] = clearColor[0];
                                tempUint32Array[1] = clearColor[1];
                                tempUint32Array[2] = clearColor[2];
                                tempUint32Array[3] = clearColor[3];
                                gl.clearBufferuiv(WebGLEnum.COLOR, i, tempUint32Array);
                            }
                        } else {
                            gl.clearBufferfv(WebGLEnum.COLOR, i, clearColor);
                        }
                    }
                }
            } else {
                gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                gl.clearDepth(clearDepth);
                gl.clearStencil(clearStencil);
                gl.clear(colorFlag | depthFlag | stencilFlag);
            }
            gl._currentFramebuffer?.tagDraw();
        }
    }
    // factory
    createGPUTimer() {
        return new GPUTimer(this);
    }
    createRenderStateSet() {
        return new WebGLRenderStateSet(this._context);
    }
    createSampler(options) {
        return this._samplerCache.fetchSampler(options);
    }
    createTextureFromMipmapData(data, sRGB, options) {
        if (!data) {
            console.error(`Device.createTextureFromMipmapData() failed: invalid data`);
            return null;
        }
        if (data.isCubemap) {
            const tex = new WebGLTextureCube(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        } else if (data.isVolume) {
            const tex = new WebGLTexture3D(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else if (data.isArray) {
            const tex = new WebGLTexture2DArray(this);
            tex.createWithMipmapData(data, this.parseTextureOptions(options));
            return tex;
        } else {
            const tex = new WebGLTexture2D(this);
            tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
            return tex;
        }
    }
    createTexture2D(format, width, height, options) {
        const tex = (options?.texture) ?? new WebGLTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2D() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createEmpty(format, width, height, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGLTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromMipmapData() failed: options.texture must be 2d texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DFromImage(element, sRGB, options) {
        const tex = (options?.texture) ?? new WebGLTexture2D(this);
        if (!tex.isTexture2D()) {
            console.error('createTexture2DFromImage() failed: options.texture must be 2d texture');
            return null;
        }
        tex.loadFromElement(element, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArray(format, width, height, depth, options) {
        const tex = (options?.texture) ?? new WebGLTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArray() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromImages(elements, sRGB, options) {
        if (!elements || elements.length === 0) {
            console.error('createTexture2DArrayFromImages() failed: Invalid image elements');
            return null;
        }
        let width = 0;
        let height = 0;
        for (const element of elements){
            if (width === 0 || height === 0) {
                width = element.width;
                height = element.height;
            } else if (width !== element.width || height !== element.height) {
                console.error('createTexture2DArrayFromImages() failed: Image elements must have the same size');
                return null;
            }
        }
        if (options?.texture && !options.texture.isTexture2DArray()) {
            console.error('createTexture2DArrayFromImages() failed: options.texture must be 2d array texture');
            return null;
        }
        let tex = options?.texture;
        if (tex) {
            if (tex.depth !== elements.length) {
                console.error('createTexture2DArrayFromImages() failed: Layer count of options.texture not match the given image elements');
                return null;
            }
            if (tex.width !== width || tex.height !== height) {
                console.error('createTexture2DArrayFromImages() failed: Size of options.texture not match the given image elements');
                return null;
            }
        } else {
            tex = this.createTexture2DArray(sRGB ? 'rgba8unorm-srgb' : 'rgba8unorm', width, height, elements.length, options);
            for(let i = 0; i < elements.length; i++){
                tex.updateFromElement(elements[i], 0, 0, i, 0, 0, width, height);
            }
        }
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture3D(format, width, height, depth, options) {
        if (!this.isWebGL2) {
            console.error('device does not support 3d texture');
            return null;
        }
        const tex = (options?.texture) ?? new WebGLTexture3D(this);
        if (!tex.isTexture3D()) {
            console.error('createTexture3D() failed: options.texture must be 3d texture');
            return null;
        }
        tex.createEmpty(format, width, height, depth, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTexture(format, size, options) {
        const tex = (options?.texture) ?? new WebGLTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTexture() failed: options.texture must be cube texture');
            return null;
        }
        tex.createEmpty(format, size, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createCubeTextureFromMipmapData(data, sRGB, options) {
        const tex = (options?.texture) ?? new WebGLTextureCube(this);
        if (!tex.isTextureCube()) {
            console.error('createCubeTextureFromMipmapData() failed: options.texture must be cube texture');
            return null;
        }
        tex.createWithMipmapData(data, sRGB, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTexture2DArrayFromMipmapData(data, options) {
        const tex = (options?.texture) ?? new WebGLTexture2DArray(this);
        if (!tex.isTexture2DArray()) {
            console.error('createTexture2DArrayFromMipmapData() failed: options.texture must be 2d array texture');
            return null;
        }
        tex.createWithMipmapData(data, this.parseTextureOptions(options));
        tex.samplerOptions = options?.samplerOptions ?? null;
        return tex;
    }
    createTextureVideo(el, samplerOptions) {
        const tex = new WebGLTextureVideo(this, el);
        tex.samplerOptions = samplerOptions ?? null;
        return tex;
    }
    createGPUProgram(params) {
        if (params.type === 'compute') {
            throw new Error('device does not support compute shader');
        }
        const renderProgramParams = params.params;
        return new WebGLGPUProgram(this, renderProgramParams.vs, renderProgramParams.fs, renderProgramParams.bindGroupLayouts, renderProgramParams.vertexAttributes);
    }
    createBindGroup(layout) {
        return new WebGLBindGroup(this, layout);
    }
    createBuffer(sizeInBytes, options) {
        return new WebGLGPUBuffer(this, this.parseBufferOptions(options), sizeInBytes);
    }
    copyBuffer(sourceBuffer, destBuffer, srcOffset, dstOffset, bytes) {
        if (!this.isWebGL2) {
            console.error(`copyBuffer() is not supported for current device`);
            return;
        }
        const gl = this._context;
        gl.bindBuffer(gl.COPY_READ_BUFFER, sourceBuffer.object);
        gl.bindBuffer(gl.COPY_WRITE_BUFFER, destBuffer.object);
        gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, srcOffset, dstOffset, bytes);
    }
    createIndexBuffer(data, options) {
        return new WebGLIndexBuffer(this, data, this.parseBufferOptions(options, 'index'));
    }
    createStructuredBuffer(structureType, options, data) {
        return new WebGLStructuredBuffer(this, structureType, this.parseBufferOptions(options), data);
    }
    createVertexLayout(options) {
        return new WebGLVertexLayout(this, options);
    }
    createFrameBuffer(colorAttachments, depthAttachement, options) {
        this.pushDeviceStates();
        const fb = new WebGLFrameBuffer(this, colorAttachments, depthAttachement, options);
        this.popDeviceStates();
        return fb;
    }
    setBindGroup(index, bindGroup, bindGroupOffsets) {
        if (bindGroupOffsets && !isWebGL2(this._context)) {
            throw new Error(`setBindGroup(): no dynamic offset buffer support for WebGL1 device`);
        }
        this._currentBindGroups[index] = bindGroup;
        this._currentBindGroupOffsets[index] = bindGroupOffsets || null;
    }
    getBindGroup(index) {
        return [
            this._currentBindGroups[index],
            this._currentBindGroupOffsets[index]
        ];
    }
    // render related
    setViewport(vp) {
        if (vp === null || vp === undefined || !Array.isArray(vp) && vp.default) {
            this._currentViewport = {
                x: 0,
                y: 0,
                width: this.deviceToScreen(this.drawingBufferWidth),
                height: this.deviceToScreen(this.drawingBufferHeight),
                default: true
            };
        } else {
            if (Array.isArray(vp)) {
                this._currentViewport = {
                    x: vp[0],
                    y: vp[1],
                    width: vp[2],
                    height: vp[3],
                    default: false
                };
            } else {
                this._currentViewport = Object.assign({
                    default: false
                }, vp);
            }
        }
        this._context.viewport(this.screenToDevice(this._currentViewport.x), this.screenToDevice(this._currentViewport.y), this.screenToDevice(this._currentViewport.width), this.screenToDevice(this._currentViewport.height));
    }
    getViewport() {
        return Object.assign({}, this._currentViewport);
    }
    setScissor(scissor) {
        if (scissor === null || scissor === undefined || !Array.isArray(scissor) && scissor.default) {
            this._currentScissorRect = {
                x: 0,
                y: 0,
                width: this.deviceToScreen(this.drawingBufferWidth),
                height: this.deviceToScreen(this.drawingBufferHeight),
                default: true
            };
        } else {
            if (Array.isArray(scissor)) {
                this._currentScissorRect = {
                    x: scissor[0],
                    y: scissor[1],
                    width: scissor[2],
                    height: scissor[3],
                    default: false
                };
            } else {
                this._currentScissorRect = Object.assign({
                    default: false
                }, scissor);
            }
        }
        this._context.scissor(this.screenToDevice(this._currentScissorRect.x), this.screenToDevice(this._currentScissorRect.y), this.screenToDevice(this._currentScissorRect.width), this.screenToDevice(this._currentScissorRect.height));
    }
    getScissor() {
        return Object.assign({}, this._currentScissorRect);
    }
    setProgram(program) {
        this._currentProgram = program;
    }
    getProgram() {
        return this._currentProgram;
    }
    setVertexLayout(vertexData) {
        this._currentVertexData = vertexData;
    }
    getVertexLayout() {
        return this._currentVertexData;
    }
    setRenderStates(stateSet) {
        this._currentStateSet = stateSet;
    }
    getRenderStates() {
        return this._currentStateSet;
    }
    setFramebuffer(rt) {
        if (rt !== this._context._currentFramebuffer) {
            this._context._currentFramebuffer?.unbind();
            rt?.bind();
        }
    }
    getFramebuffer() {
        return this._context._currentFramebuffer ?? null;
    }
    reverseVertexWindingOrder(reverse) {
        if (this._reverseWindingOrder !== !!reverse) {
            this._reverseWindingOrder = !!reverse;
            this._context.frontFace(reverse ? this._context.CW : this._context.CCW);
        }
    }
    isWindingOrderReversed() {
        return !!this._reverseWindingOrder;
    }
    flush() {
        this.context.flush();
    }
    async readPixels(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? fb.getColorAttachments()[index] : null;
        const format = colorAttachment ? colorAttachment.format : 'rgba8unorm';
        let glFormat = WebGLEnum.NONE;
        let glType = WebGLEnum.NONE;
        const pixelSize = getTextureFormatBlockSize(format);
        glFormat = this.context.getParameter(WebGLEnum.IMPLEMENTATION_COLOR_READ_FORMAT);
        glType = this.context.getParameter(WebGLEnum.IMPLEMENTATION_COLOR_READ_TYPE);
        if ((glFormat !== WebGLEnum.RGBA || glType !== WebGLEnum.UNSIGNED_BYTE && glType !== WebGLEnum.FLOAT) && !isWebGL2(this.context)) {
            throw new Error(`readPixels() failed: invalid format: ${format}`);
        }
        const byteSize = w * h * pixelSize;
        if (buffer.byteLength < byteSize) {
            throw new Error(`readPixels() failed: destination buffer must have at least ${byteSize} bytes`);
        }
        if (isWebGL2(this.context)) {
            const stagingBuffer = this.createBuffer(byteSize, {
                usage: 'read',
                managed: false
            });
            this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, stagingBuffer.object);
            this.context.readBuffer(fb ? WebGLEnum.COLOR_ATTACHMENT0 + index : WebGLEnum.COLOR_ATTACHMENT0);
            this.flush();
            this.context.readPixels(x, y, w, h, glFormat, glType, 0);
            this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, null);
            const data = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            await stagingBuffer.getBufferSubData(data);
            stagingBuffer.dispose();
        } else {
            this.context.readPixels(x, y, w, h, glFormat, glType, buffer);
        }
    }
    readPixelsToBuffer(index, x, y, w, h, buffer) {
        const fb = this.getFramebuffer();
        const colorAttachment = fb ? fb.getColorAttachments()[index] : null;
        const format = colorAttachment ? colorAttachment.format : 'rgba8unorm';
        let glFormat = WebGLEnum.NONE;
        let glType = WebGLEnum.NONE;
        if (!isWebGL2(this.context)) {
            throw new Error('readPixels() failed: readPixels() requires webgl2 device');
        }
        if (isCompressedTextureFormat(format) || hasDepthChannel(format)) {
            throw new Error(`readPixels() failed: invalid format: ${format}`);
        }
        const r = hasRedChannel(format);
        const g = hasGreenChannel(format);
        const b = hasBlueChannel(format);
        const a = hasAlphaChannel(format);
        const numChannels = (r ? 1 : 0) + (g ? 1 : 0) + (b ? 1 : 0) + (a ? 1 : 0);
        const size = getTextureFormatBlockSize(format) / numChannels;
        const integer = isIntegerTextureFormat(format);
        const float = isFloatTextureFormat(format);
        const signed = isSignedTextureFormat(format);
        if (r && g && b && a) {
            glFormat = integer ? WebGLEnum.RGBA_INTEGER : WebGLEnum.RGBA;
        } else if (r && g) {
            glFormat = integer ? WebGLEnum.RG_INTEGER : WebGLEnum.RG;
        } else if (r) {
            glFormat = integer ? WebGLEnum.RED_INTEGER : WebGLEnum.RED;
        }
        if (size === 1) {
            glType = signed ? WebGLEnum.BYTE : WebGLEnum.UNSIGNED_BYTE;
        } else if (size === 2) {
            glType = float ? WebGLEnum.HALF_FLOAT : signed ? WebGLEnum.SHORT : WebGLEnum.UNSIGNED_SHORT;
        } else if (size === 4) {
            glType = float ? WebGLEnum.FLOAT : signed ? WebGLEnum.INT : WebGLEnum.UNSIGNED_INT;
        }
        this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, buffer.object);
        this.context.readBuffer(fb ? WebGLEnum.COLOR_ATTACHMENT0 + index : WebGLEnum.COLOR_ATTACHMENT0);
        this.flush();
        this.context.readPixels(x, y, w, h, glFormat, glType, 0);
        this.context.bindBuffer(WebGLEnum.PIXEL_PACK_BUFFER, null);
    }
    looseContext() {
        if (!this.context.isContextLost()) {
            this._loseContextExtension?.loseContext();
        }
    }
    restoreContext() {
        if (this.context.isContextLost()) {
            this.clearErrors();
            this._loseContextExtension?.restoreContext();
            const err = this.getError();
            if (err) {
                console.log(err);
            }
        }
    }
    beginCapture() {
        if (this._captureRenderBundle) {
            throw new Error('Device.beginCapture() failed: device is already capturing draw commands');
        }
        this._captureRenderBundle = [];
    }
    endCapture() {
        if (!this._captureRenderBundle) {
            throw new Error('Device.endCapture() failed: device is not capturing draw commands');
        }
        const result = this._captureRenderBundle;
        this._captureRenderBundle = null;
        return result;
    }
    executeRenderBundle(renderBundle) {
        for (const drawcall of renderBundle){
            this.setProgram(drawcall.program);
            this.setVertexLayout(drawcall.vertexLayout);
            this.setRenderStates(drawcall.renderStateSet);
            for(let i = 0; i < 4; i++){
                this.setBindGroup(i, drawcall.bindGroups[i], drawcall.bindGroupOffsets[i]);
            }
            if (drawcall.numInstances === 0) {
                this.draw(drawcall.primitiveType, drawcall.first, drawcall.count);
            } else {
                this.drawInstanced(drawcall.primitiveType, drawcall.first, drawcall.count, drawcall.numInstances);
            }
        }
    }
    /** @internal */ onBeginFrame() {
        if (this._contextLost) {
            if (!this._context.isContextLost()) {
                this._contextLost = false;
                this.handleContextRestored();
            }
        }
        return !this._contextLost;
    }
    /** @internal */ onEndFrame() {}
    /** @internal */ _draw(primitiveType, first, count) {
        if (this._currentVertexData) {
            this._currentVertexData.bind();
            if (this._currentProgram) {
                if (!this._currentProgram.use()) {
                    return;
                }
                for(let i = 0; i < this._currentProgram.bindGroupLayouts.length; i++){
                    const bindGroup = this._currentBindGroups[i];
                    if (bindGroup) {
                        const offsets = this._currentBindGroupOffsets[i];
                        bindGroup.apply(this._currentProgram, offsets);
                    } else {
                        console.error(`Missing bind group (${i}) when drawing with program '${this._currentProgram.name}'`);
                        return;
                    }
                }
            }
            if (this._currentStateSet) {
                this._currentStateSet.apply();
            } else {
                WebGLRenderStateSet.applyDefaults(this._context);
            }
            const indexBuffer = this._currentVertexData.indexBuffer;
            if (indexBuffer) {
                this.context.drawElements(primitiveTypeMap[primitiveType], count, typeMap[indexBuffer.indexType.primitiveType], first * (indexBuffer.indexType === typeU16 ? 2 : 4));
            } else {
                this.context.drawArrays(primitiveTypeMap[primitiveType], first, count);
            }
            this._context._currentFramebuffer?.tagDraw();
        }
        if (this._captureRenderBundle) {
            const rs = this._currentStateSet?.clone() ?? this.createRenderStateSet();
            if (this._reverseWindingOrder) {
                const rasterState = rs.rasterizerState;
                if (!rasterState) {
                    rs.useRasterizerState().setCullMode('front');
                } else if (rasterState.cullMode === 'back') {
                    rasterState.cullMode = 'front';
                } else if (rasterState.cullMode === 'front') {
                    rasterState.cullMode = 'back';
                }
            }
            this._captureRenderBundle.push({
                bindGroups: [
                    ...this._currentBindGroups
                ],
                bindGroupOffsets: this._currentBindGroupOffsets.map((val)=>val ? [
                        ...val
                    ] : null),
                program: this._currentProgram,
                vertexLayout: this._currentVertexData,
                primitiveType: primitiveType,
                renderStateSet: rs,
                count,
                first,
                numInstances: 0
            });
        }
    }
    /** @internal */ _drawInstanced(primitiveType, first, count, numInstances) {
        if (this.instancedArraysExt && this._currentVertexData) {
            this._currentVertexData.bind();
            if (this._currentProgram) {
                if (!this._currentProgram.use()) {
                    return;
                }
                for(let i = 0; i < this._currentBindGroups.length; i++){
                    const bindGroup = this._currentBindGroups[i];
                    if (bindGroup) {
                        const offsets = this._currentBindGroupOffsets[i];
                        bindGroup.apply(this._currentProgram, offsets);
                    }
                }
            }
            this._currentStateSet?.apply();
            const indexBuffer = this._currentVertexData.indexBuffer;
            if (indexBuffer) {
                this.instancedArraysExt.drawElementsInstanced(primitiveTypeMap[primitiveType], count, typeMap[indexBuffer.indexType.primitiveType], first * (indexBuffer.indexType === typeU16 ? 2 : 4), numInstances);
            } else {
                this.instancedArraysExt.drawArraysInstanced(primitiveTypeMap[primitiveType], first, count, numInstances);
            }
            this._context._currentFramebuffer?.tagDraw();
        }
        if (this._captureRenderBundle) {
            this._captureRenderBundle.push({
                bindGroups: [
                    ...this._currentBindGroups
                ],
                bindGroupOffsets: this._currentBindGroupOffsets.map((val)=>val ? [
                        ...val
                    ] : null),
                program: this._currentProgram,
                vertexLayout: this._currentVertexData,
                primitiveType: primitiveType,
                renderStateSet: this._currentStateSet?.clone() ?? null,
                count,
                first,
                numInstances
            });
        }
    }
    /** @internal */ _compute() {
        throw new Error('WebGL device does not support compute shader');
    }
    /** @internal */ createInstancedArraysEXT() {
        const gl = this._context;
        if (isWebGL2(gl)) {
            return {
                vertexAttribDivisor: gl.vertexAttribDivisor.bind(gl),
                drawArraysInstanced: gl.drawArraysInstanced.bind(gl),
                drawElementsInstanced: gl.drawElementsInstanced.bind(gl)
            };
        } else {
            const extInstancedArray = gl.getExtension('ANGLE_instanced_arrays');
            return extInstancedArray ? {
                vertexAttribDivisor: extInstancedArray.vertexAttribDivisorANGLE.bind(extInstancedArray),
                drawArraysInstanced: extInstancedArray.drawArraysInstancedANGLE.bind(extInstancedArray),
                drawElementsInstanced: extInstancedArray.drawElementsInstancedANGLE.bind(extInstancedArray)
            } : null;
        }
    }
    /** @internal */ createDrawBuffersEXT() {
        const gl = this._context;
        if (isWebGL2(gl)) {
            return {
                drawBuffers: gl.drawBuffers.bind(gl)
            };
        } else {
            const extDrawBuffers = gl.getExtension('WEBGL_draw_buffers');
            return extDrawBuffers ? {
                drawBuffers: extDrawBuffers.drawBuffersWEBGL.bind(extDrawBuffers)
            } : null;
        }
    }
    /** @internal */ createVertexArrayObjectEXT() {
        const gl = this._context;
        if (isWebGL2(gl)) {
            return {
                createVertexArray: gl.createVertexArray.bind(gl),
                bindVertexArray: gl.bindVertexArray.bind(gl),
                deleteVertexArray: gl.deleteVertexArray.bind(gl),
                isVertexArray: gl.isVertexArray.bind(gl)
            };
        } else {
            const extVAO = gl.getExtension('OES_vertex_array_object');
            return extVAO ? {
                createVertexArray: extVAO.createVertexArrayOES.bind(extVAO),
                bindVertexArray: extVAO.bindVertexArrayOES.bind(extVAO),
                deleteVertexArray: extVAO.deleteVertexArrayOES.bind(extVAO),
                isVertexArray: extVAO.isVertexArrayOES.bind(extVAO)
            } : null;
        }
    }
    /** @internal */ handleContextLost() {
        this._isRendering = this.isRendering;
        this.exitLoop();
        console.log('handle context lost');
        this.invalidateAll();
        this.dispatchEvent(new DeviceLostEvent());
    }
    /** @internal */ handleContextRestored() {
        console.log('handle context restored');
        this.initContextState();
        this._textureSamplerMap = new WeakMap();
        this._currentProgram = null;
        this._currentVertexData = null;
        this._currentStateSet = null;
        this._currentBindGroups = [];
        this._currentBindGroupOffsets = [];
        this._currentViewport = null;
        this._currentScissorRect = null;
        this._samplerCache = new SamplerCache(this);
        if (this._isRendering) {
            this._isRendering = false;
            this.reloadAll().then(()=>{
                this.dispatchEvent(new DeviceRestoreEvent());
                this.runLoop(this.runLoopFunction);
            });
        }
    }
    /** @internal */ initContextState() {
        this._deviceCaps = {
            miscCaps: new WebGLMiscCaps(this._context),
            framebufferCaps: new WebGLFramebufferCaps(this._context),
            shaderCaps: new WebGLShaderCaps(this._context),
            textureCaps: new WebGLTextureCaps(this._context)
        };
        this._vaoExt = this.createVertexArrayObjectEXT();
        this._instancedArraysExt = this.createInstancedArraysEXT();
        this._drawBuffersExt = this.createDrawBuffersEXT();
        this._context.pixelStorei(WebGLEnum.UNPACK_COLORSPACE_CONVERSION_WEBGL, WebGLEnum.NONE);
        this._context.pixelStorei(WebGLEnum.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.setViewport(null);
        this.setScissor(null);
        this._context.enable(WebGLEnum.SCISSOR_TEST);
        this.enableGPUTimeRecording(true);
        this._context._currentFramebuffer = undefined;
        this._context._currentProgram = undefined;
        this._deviceUniformBuffers = [];
        this._deviceUniformBufferOffsets = [];
        this._bindTextures = {
            [WebGLEnum.TEXTURE_2D]: [],
            [WebGLEnum.TEXTURE_CUBE_MAP]: [],
            [WebGLEnum.TEXTURE_3D]: [],
            [WebGLEnum.TEXTURE_2D_ARRAY]: []
        };
        this._bindSamplers = [];
    }
    /** @internal */ clearErrors() {
        while(this._context.getError());
    }
    /** @internal */ getCurrentSamplerForTexture(tex) {
        return this._textureSamplerMap.get(tex);
    }
    /** @internal */ setCurrentSamplerForTexture(tex, sampler) {
        this._textureSamplerMap.set(tex, sampler);
    }
    getError(throwError) {
        const errcode = this._context.getError();
        const err = errcode === WebGLEnum.NO_ERROR ? null : new WebGLError(errcode);
        if (err && throwError) {
            throw err;
        }
        return err;
    }
}
let webGL1Supported = null;
let webGL2Supported = null;
const factory = makeEventTarget(WebGLDevice)();
async function createWebGLDevice(backend, cvs, options) {
    try {
        const device = new factory(backend, cvs, options);
        await device.initContext();
        device.setViewport();
        device.setScissor();
        return device;
    } catch (err) {
        console.error(err);
        return null;
    }
}
/** @internal */ const backend1 = {
    typeName () {
        return 'webgl';
    },
    supported () {
        if (webGL1Supported === null) {
            const cvs = document.createElement('canvas');
            const gl = cvs.getContext('webgl');
            webGL1Supported = !!gl;
            cvs.width = 0;
            cvs.height = 0;
        }
        return webGL1Supported;
    },
    async createDevice (cvs, options) {
        return createWebGLDevice(this, cvs, options);
    }
};
/** @internal */ const backend2 = {
    typeName () {
        return 'webgl2';
    },
    supported () {
        if (webGL2Supported === null) {
            const cvs = document.createElement('canvas');
            const gl = cvs.getContext('webgl2');
            webGL2Supported = !!gl;
            cvs.width = 0;
            cvs.height = 0;
        }
        return webGL2Supported;
    },
    async createDevice (cvs, options) {
        return createWebGLDevice(this, cvs, options);
    }
};

/**
 * The WebGL2 backend
 * @public
 */ const backendWebGL2 = backend2;

const myApp = new Application({
    backend: backendWebGL2,
    canvas: document.querySelector('#my-canvas')
});
myApp.ready().then(function() {
    const scene = new Scene();
    // Hemisphere lighting
    scene.env.light.type = 'hemisphere';
    scene.env.light.ambientUp = new Vector4(0, 0.4, 1, 1);
    scene.env.light.ambientDown = new Vector4(0.3, 0.2, 0, 1);
    // Create a sphere
    const material = new LambertMaterial();
    new Mesh(scene, new SphereShape(), material);
    // Create camera
    const camera = new PerspectiveCamera(scene, Math.PI / 3, myApp.device.canvas.width / myApp.device.canvas.height, 1, 600);
    camera.lookAt(new Vector3(0, 0, 4), Vector3.zero(), new Vector3(0, 1, 0));
    camera.controller = new OrbitCameraController();
    const compositor = new Compositor();
    // Add a Tonemap post-processing effect
    compositor.appendPostEffect(new Tonemap());
    myApp.inputManager.use(camera.handleEvent.bind(camera));
    myApp.on('tick', function() {
        camera.updateController();
        const width = myApp.device.deviceToScreen(myApp.device.canvas.width);
        const height = myApp.device.deviceToScreen(myApp.device.canvas.height);
        // The lower half of the screen has ambient light
        scene.env.light.type = 'hemisphere';
        camera.viewport = [
            0,
            0,
            width,
            height >> 1
        ];
        camera.aspect = camera.viewport[2] / camera.viewport[3];
        camera.render(scene, compositor);
        // No ambient light on the upper half of the screen
        scene.env.light.type = 'none';
        camera.viewport = [
            0,
            height >> 1,
            width,
            height - (height >> 1)
        ];
        camera.aspect = camera.viewport[2] / camera.viewport[3];
        camera.render(scene, compositor);
    });
    myApp.run();
});
//# sourceMappingURL=tut-15.js.map
